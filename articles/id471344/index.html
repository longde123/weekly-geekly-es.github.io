<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😺 📯 👩🏾‍💼 Sekali lagi Tentang ImmutableList di Jawa 💱 🌅 🙇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel saya sebelumnya, “ Mengalami ImmutableList di Jawa, ” saya mengusulkan solusi untuk masalah tidak adanya daftar yang tidak dapat diubah ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sekali lagi Tentang ImmutableList di Jawa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471344/"><p>  Dalam artikel saya sebelumnya, “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengalami ImmutableList di Jawa,</a> ” saya mengusulkan solusi untuk masalah tidak adanya daftar yang tidak dapat diubah di Jawa, yang tidak diperbaiki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, baik sekarang maupun sebelumnya</a> , di Jawa. </p><br><p>  Solusinya kemudian dikerjakan hanya pada tingkat "ada ide seperti itu", dan implementasi dalam kode itu bengkok, karena itu semuanya dianggap agak skeptis.  Pada artikel ini, saya mengusulkan solusi yang dimodifikasi.  Logika penggunaan dan API dibawa ke tingkat yang dapat diterima.  Implementasi dalam kode hingga tingkat beta. </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p> Kami akan menggunakan definisi dari artikel asli.  Secara khusus, ini berarti <code>ImmutableList</code> adalah daftar referensi yang tidak dapat diubah untuk beberapa objek.  Jika objek-objek ini berubah menjadi tidak berubah, maka daftar juga tidak akan menjadi objek abadi, terlepas dari namanya.  Dalam praktiknya, ini tidak mungkin menyakiti siapa pun, tetapi untuk menghindari harapan yang tidak dapat dibenarkan perlu disebutkan. </p><br><p>  Juga jelas bahwa ketidakmampuan daftar dapat "diretas" melalui refleksi, atau dengan membuat kelas Anda sendiri dalam paket yang sama, diikuti dengan naik ke bidang yang dilindungi daftar, atau sesuatu yang serupa. </p><br><p>  Berbeda dengan artikel asli, kami tidak akan berpegang pada prinsip "semua atau tidak sama sekali": penulis di sana tampaknya percaya bahwa jika masalahnya tidak dapat diselesaikan di tingkat JDK, maka tidak ada yang harus dilakukan.  (Sebenarnya, pertanyaan lain, "tidak dapat diselesaikan" atau "penulis Java tidak memiliki keinginan untuk menyelesaikannya." Sepertinya saya masih mungkin dengan menambahkan antarmuka, kelas, dan metode tambahan untuk membawa koleksi yang ada lebih dekat ke penampilan yang diinginkan, meskipun kurang cantik daripada jika Anda langsung memikirkannya, tapi sekarang ini bukan tentang itu.) </p><br><p>  Kami akan membuat perpustakaan yang berhasil hidup berdampingan dengan koleksi yang ada di Jawa. </p><br><p>  Gagasan utama perpustakaan: </p><br><ul><li>  Ada <code>MutableList</code> dan <code>MutableList</code> .  Dengan casting type tidak mungkin untuk mendapatkan satu dari yang lain. </li><li>  Dalam proyek kami, yang ingin kami tingkatkan menggunakan perpustakaan, kami mengganti semua <code>List</code> dengan salah satu dari dua antarmuka ini.  Jika suatu saat Anda tidak dapat melakukannya tanpa <code>List</code> , maka pada kesempatan pertama kami akan mengonversi <code>List</code> dari / ke salah satu dari dua antarmuka.  Hal yang sama berlaku untuk saat-saat menerima / mengirimkan data ke perpustakaan pihak ketiga menggunakan <code>List</code> . </li><li>  Konversi timbal balik antara <code>MutableList</code> , <code>MutableList</code> , <code>List</code> harus dilakukan secepat mungkin (yaitu, tanpa menyalin daftar, jika mungkin).  Tanpa konversi pulang-pergi "murah", seluruh ide mulai tampak meragukan. </li></ul><br><p>  Perlu dicatat bahwa hanya daftar yang dipertimbangkan, karena saat ini hanya diterapkan di perpustakaan.  Tapi tidak ada yang mencegah perpustakaan dari melengkapi dengan <code>Set</code> dan <code>Map</code> . </p><br><h2 id="api">  API </h2><br><h3 id="immutablelist">  Daftar Abadi </h3><br><p>  <code>ImmutableList</code> adalah penerus dari <code>ReadOnlyList</code> (yang, seperti pada artikel sebelumnya, adalah antarmuka <code>List</code> disalin dari mana semua metode bermutasi dilemparkan).  Metode ditambahkan: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contentEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;? extends E&gt; iterable)</span></span></span></span>;</code> </pre> <br><p>  Metode <code>toList</code> memberikan kemampuan untuk meneruskan <code>ImmutableList</code> ke potongan kode yang menunggu <code>List</code> .  Wrapper dikembalikan di mana semua metode modifikasi mengembalikan <code>UnsupportedOperationException</code> , dan metode yang tersisa diarahkan ke <code>ImmutableList</code> asli. </p><br><p>  Metode <code>mutable</code> mengubah <code>MutableList</code> menjadi <code>MutableList</code> .  Wrapper dikembalikan di mana semua metode dialihkan ke <code>ImmutableList</code> asli hingga perubahan pertama.  Sebelum perubahan, pembungkus dilepaskan dari <code>ImmutableList</code> asli, menyalin isinya ke <code>ArrayList</code> internal, di mana semua operasi kemudian dialihkan. </p><br><p>  Metode <code>contentEquals</code> dimaksudkan untuk membandingkan konten daftar dengan konten yang lulus <code>Iterable</code> sewenang-wenang (tentu saja, operasi ini hanya bermakna bagi implementasi <code>Iterable</code> yang memiliki urutan elemen yang berbeda). </p><br><p>  Perhatikan bahwa dalam implementasi <code>ReadOnlyList</code> , metode <code>iterator</code> dan <code>listIterator</code> mengembalikan standar <code>java.util.Iterator</code> / <code>java.util.ListIterator</code> .  Iterator ini berisi metode modifikasi yang harus ditekan dengan melempar <code>UnsupportedOperationException</code> .  Akan lebih baik untuk membuat <code>ReadOnlyIterator</code> kami, tetapi dalam hal ini kami tidak dapat menulis <code>for (Object item : immutableList)</code> , yang akan segera merusak semua kesenangan menggunakan perpustakaan. </p><br><h3 id="mutablelist">  MutableList </h3><br><p>  <code>MutableList</code> adalah turunan dari <code>List</code> reguler.  Metode ditambahkan: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">releaseSnapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contentEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;? extends E&gt; iterable)</span></span></span></span>;</code> </pre> <br><p>  Metode <code>snapshot</code> dirancang untuk mendapatkan "snapshot" dari keadaan <code>MutableList</code> saat ini sebagai <code>MutableList</code> .  "Snapshot" disimpan di dalam <code>MutableList</code> , dan jika keadaan belum berubah pada saat pemanggilan metode selanjutnya, instance <code>ImmutableList</code> .  "Snapshot" yang disimpan di dalamnya dibuang saat pertama kali metode modifikasi dipanggil, atau ketika <code>releaseSnapshot</code> dipanggil.  Metode <code>releaseSnapshot</code> dapat digunakan untuk menghemat memori jika Anda yakin tidak ada yang akan membutuhkan "snapshot", tetapi metode modifikasi tidak akan segera dipanggil. </p><br><h3 id="mutabor">  Mutabor </h3><br><p>  Kelas <code>Mutabor</code> menyediakan seperangkat metode statis yang merupakan "titik masuk" ke perpustakaan. </p><br><p>  Ya, proyek ini sekarang disebut "mutabor" (itu sesuai dengan "bisa berubah", dan dalam terjemahan itu berarti "Saya akan mengubah", yang sesuai dengan ide cepat "mengubah" beberapa jenis koleksi menjadi yang lain). </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E[] original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToImmutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyToMutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; original)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E&gt; <span class="hljs-function"><span class="hljs-function">MutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToMutableList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;E&gt; original)</span></span></span></span>;</code> </pre> <br><p>  <code>copyTo*</code> dirancang untuk membuat koleksi yang sesuai dengan menyalin data yang disediakan.  Metode <code>convertTo*</code> konversi cepat koleksi yang ditransfer ke jenis yang diinginkan, dan jika tidak memungkinkan untuk dengan cepat dikonversi, mereka melakukan penyalinan lambat.  Jika konversi cepat berhasil, maka koleksi asli dihapus, dan diasumsikan bahwa itu tidak akan digunakan di masa depan (meskipun bisa, tetapi ini hampir tidak masuk akal). </p><br><p>  Panggilan ke konstruktor <code>ImmutableList</code> implementasi <code>MutableList</code> / <code>MutableList</code> disembunyikan.  Diasumsikan bahwa pengguna hanya berurusan dengan antarmuka, ia tidak membuat objek seperti itu, dan menggunakan metode yang dijelaskan di atas untuk mengubah koleksi. </p><br><h2 id="detali-realizacii">  Detail implementasi </h2><br><h3 id="immutablelistimpl">  ImmutableListImpl </h3><br><p>  Merangkum berbagai objek.  Implementasi kira-kira sesuai dengan implementasi <code>ArrayList</code> , dari mana semua metode modifikasi dan pemeriksaan untuk modifikasi bersamaan dilemparkan. </p><br><p>  Implementasi metode <code>toList</code> dan <code>contentEquals</code> juga cukup sepele.  Metode <code>toList</code> mengembalikan pembungkus yang mengalihkan panggilan ke <code>ImmutableList</code> diberikan; penyalinan data secara lambat tidak terjadi. </p><br><p>  Metode <code>mutable</code> mengembalikan <code>MutableListImpl</code> dibuat berdasarkan <code>MutableListImpl</code> ini.  Penyalinan data tidak terjadi sampai metode pengubahan apa pun dipanggil pada <code>MutableList</code> diterima. </p><br><h3 id="mutablelistimpl">  MutableListImpl </h3><br><p>  Meringkas tautan ke <code>List</code> dan <code>List</code> <code>ImmutableList</code> .  Saat membuat objek, hanya satu dari dua tautan ini yang selalu diisi, yang lainnya tetap <code>null</code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ImmutableList&lt;E&gt; immutable; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> List&lt;E&gt; list;</code> </pre> <br><p>  Metode Immutable mengarahkan ulang panggilan ke <code>ImmutableList</code> jika bukan <code>null</code> , dan ke <code>List</code> sebaliknya. </p><br><p>  Metode memodifikasi mengarahkan panggilan ke <code>List</code> , setelah menginisialisasi: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(immutable.toList()); } immutable = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br><p>  Metode <code>snapshot</code> terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ImmutableList&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">snapshot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immutable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> immutable; } immutable = InternalUtils.convertToImmutableList(list); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immutable != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    //   ,  . //     immutable     . list = null; return immutable; } immutable = InternalUtils.copyToImmutableList(list); return immutable; }</span></span></code> </pre> <br><p>  Penerapan <code>contentEquals</code> <code>releaseSnapshot</code> dan <code>contentEquals</code> sepele. </p><br><p>  Pendekatan ini memungkinkan Anda untuk meminimalkan jumlah salinan data selama penggunaan "biasa", menggantikan salinan dengan konversi cepat. </p><br><h3 id="bystroe-preobrazovanie-spiskov">  Konversi daftar cepat </h3><br><p>  Konversi cepat dimungkinkan untuk kelas <code>ArrayList</code> atau <code>Arrays$ArrayList</code> (hasil dari metode <code>Arrays.asList()</code> ).  Dalam praktiknya, dalam sebagian besar kasus, justru kelas-kelas inilah yang muncul. </p><br><p>  Di dalam kelas-kelas ini berisi array elemen.  Inti dari konversi cepat adalah untuk mendapatkan referensi ke array ini melalui refleksi (ini adalah bidang pribadi) dan menggantinya dengan referensi ke array kosong.  Ini memastikan bahwa satu-satunya referensi ke array tetap dengan objek kita, dan array tetap tidak berubah. </p><br><p>  Di versi perpustakaan sebelumnya, konversi cepat dari jenis koleksi dilakukan dengan memanggil konstruktor.  Pada saat yang sama, objek koleksi asli memburuk (menjadi tidak cocok untuk digunakan lebih lanjut), yang tidak Anda sadari secara tidak terduga dari perancang.  Sekarang, metode statis khusus digunakan untuk konversi, dan koleksi asli tidak rusak, tetapi hanya dihapus.  Dengan demikian, perilaku yang tidak biasa yang menakutkan dihilangkan. </p><br><h3 id="problemy-s-equals--hashcode">  Masalah dengan equals / hashCode </h3><br><p>  Koleksi Java menggunakan pendekatan yang sangat aneh untuk mengimplementasikan metode <code>equals</code> dan <code>hashCode</code> . </p><br><p>  Perbandingan dilakukan sesuai dengan konten, yang tampaknya logis, tetapi kelas daftar itu sendiri tidak diperhitungkan.  Karenanya, misalnya, <code>ArrayList</code> dan <code>LinkedList</code> dengan konten yang sama akan <code>equals</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Inilah implementasi equals / hashCode dari AbstractList (dari mana ArrayList diwarisi)</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ListIterator&lt;E&gt; e1 = listIterator(); ListIterator e2 = ((List) o).listIterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (e1.hasNext() &amp;&amp; e2.hasNext()) { E o1 = e1.next(); Object o2 = e2.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(o1==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? o2==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : o1.equals(o2))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(e1.hasNext() || e2.hasNext()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashCode = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (E e : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) hashCode = <span class="hljs-number"><span class="hljs-number">31</span></span>*hashCode + (e==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : e.hashCode()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashCode; }</code> </pre> </div></div><br><p>  Dengan demikian, sekarang benar-benar semua implementasi <code>List</code> diharuskan memiliki implementasi yang <code>equals</code> (dan, sebagai hasilnya, <code>hashCode</code> ).  Kalau tidak, Anda bisa mendapatkan situasi ketika <code>a.equals(b) &amp;&amp; !b.equals(a)</code> , yang tidak baik.  Situasi serupa terjadi dengan <code>Set</code> dan <code>Map</code> . </p><br><p>  Dalam aplikasi ke pustaka, ini berarti bahwa implementasi <code>equals</code> dan <code>hashCode</code> untuk <code>MutableList</code> ditentukan sebelumnya, dan dalam implementasi seperti itu, <code>MutableList</code> dan <code>MutableList</code> dengan konten yang sama tidak dapat <code>equals</code> (karena <code>ImmutableList</code> bukan <code>List</code> ).  Oleh karena itu, metode <code>contentEquals</code> telah ditambahkan untuk membandingkan konten. </p><br><p>  Implementasi metode <code>equals</code> dan <code>hashCode</code> untuk <code>ImmutableList</code> dibuat sangat mirip dengan versi dari <code>AbstractList</code> , tetapi dengan penggantian <code>List</code> oleh <code>ReadOnlyList</code> . </p><br><h2 id="itogo">  Total </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber dan tes perpustakaan diposting dengan referensi</a> dalam bentuk proyek pakar. </p><br><p>  Jika seseorang ingin menggunakan perpustakaan, ia telah membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grup</a> untuk "umpan balik". </p><br><p>  Menggunakan perpustakaan cukup jelas, berikut adalah contoh singkat: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myBusinessProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Entity&gt; tempFromDb = queryEntitiesFromDatabase(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM my_table"</span></span>); ImmutableList&lt;Entity&gt; fromDb = Mutabor.convertToImmutableList(tempFromDb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromDb.isEmpty() || !someChecksPassed(fromDb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//... MutableList&lt;Entity&gt; list = fromDb.mutable(); //time to change list.remove(1); ImmutableList&lt;Entity&gt; processed = list.snapshot(); //time to change ended //... if (!callSideLibraryExpectsListParameter(processed.toList())) { return false; } for (Entity entity : processed) { outputToUI(entity); } return true; }</span></span></code> </pre> <br><p>  Semoga beruntung untuk semuanya!  Kirim laporan bug! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471344/">https://habr.com/ru/post/id471344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471332/index.html">Kisah-kisah komputer bulan. Bagian 3</a></li>
<li><a href="../id471334/index.html">Untuk menghafal, tetapi tidak menjejalkan - belajar "dengan kartu"</a></li>
<li><a href="../id471336/index.html">Holivar. Sejarah Runet. Bagian 6. Kunci: Lurk, Tape, 282 dan jalur Cina</a></li>
<li><a href="../id471340/index.html">Drimsim vs Mate 20 Pro Round! Tapi untuk siapa?</a></li>
<li><a href="../id471342/index.html">Avalonia yang bergaya</a></li>
<li><a href="../id471346/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 384 (7 - 13 Oktober 2019)</a></li>
<li><a href="../id471348/index.html">Aplikasi TypeScript dengan tumpukan penuh</a></li>
<li><a href="../id471350/index.html">Membalikkan rekayasa amplifier operasional dengan noise rendah dari komputer analog pada tahun 1969</a></li>
<li><a href="../id471352/index.html">Menulis presentasi di LaTeX</a></li>
<li><a href="../id471358/index.html">Bagaimana cara menulis kontrak pintar dengan Python pada Ontologi? Bagian 4: API Asli</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>