<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™† ğŸ•µğŸ¿ ğŸ•¶ï¸ Pengembangan bot Python TamTam â›„ï¸ ğŸŒ· ğŸ‘¨ğŸ¾â€ğŸ”§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Izinkan saya memperkenalkan diri: nama saya Sergey Agaltsov, dan saya seorang "programmer in life." Ini berarti bahwa saya telah lama menj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan bot Python TamTam</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/466373/"><p><img src="https://habrastorage.org/webt/hv/5y/zn/hv5yzn1xbdnmstacgsl-4bqqcfc.jpeg"></p><br><p>  Halo, Habr!  Izinkan saya memperkenalkan diri: nama saya Sergey Agaltsov, dan saya seorang "programmer in life."  Ini berarti bahwa saya telah lama menjadi manajer TI, dan sama sekali bukan programmer karena profesi, tetapi saya menggunakan pemrograman terus-menerus, baik dalam kegiatan utama saya maupun sebagai hobi.  Seperti yang sering dikatakan salah satu mantan bos saya - "Seryoga! Anda kembali masuk ke pemrograman!"  Benar, saya tidak bisa mengatakan bahwa dia atau siapa pun pernah merasa sangat tidak puas dengan ini. </p><br><p>  Setelah kemunculan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bot API</a> pada messenger TamTam, saya, sebagai programmer yang benar, dan karena itu malas, membuat 2 pustaka Python untuk bekerja dengannya: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API klien terbuka</a> (selanjutnya - OAC) - awalnya membuatnya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generator OpenAPI</a> berdasarkan skema API, kemudian mengadaptasinya dengan mempertimbangkan fitur-fitur generator; </li><li>  shell untuk klien ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TamTamBot</a> (selanjutnya - TTB), yang menyederhanakan pekerjaan dengan OAC. </li></ul><br><p>  Jadi ada SDK TamTam Python tertentu. </p><br><p>  Saya melakukan ini pertama-tama "untuk diri saya sendiri, untuk jiwa", tetapi juga menyarankan agar komunitas TamTam, jika diinginkan, menggunakannya.  Tapi, seperti yang Anda tahu, tidak ada satu pun perbuatan baik yang tidak dihukum - orang diminta untuk menulis artikel pelatihan.  Dan di sinilah saya dengan artikel ini.  Di dalamnya, saya akan memberi tahu Anda cara mengembangkan bot sederhana menggunakan perpustakaan ini. </p><a name="habracut"></a><br><h1 id="zadacha">  Tantangan </h1><br><p>  Kembangkan bot yang dirancang untuk menyederhanakan tindakan pengembang bot.  Bot harus bekerja dalam mode polling permanen negara-api (polling panjang).  Dalam artikel ini, bot akan dilatih untuk menunjukkan bagian dalam dari pesan yang dikirim kepadanya, dan juga dikonfigurasi agar sesuai dengan fungsionalitas yang dikembangkan. </p><br><p>  Dapat dipahami bahwa pembaca telah menginstal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python 3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">git</a> , terhubung ke lingkungan pengembangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyCharm</a> (lingkungan pengembangan mungkin berbeda, tetapi ceritanya akan didasarkan pada PyCharm).  Memahami dasar-dasar OOP diinginkan. </p><br><h1 id="poluchenie-tokena-bota">  Mendapatkan token bot </h1><br><p>  Token <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diperoleh</a> melalui panggilan ke bot khusus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@PrimeBot</a> </p><br><p>  Kami menemukan bot ini di TamTam, masukkan perintah / buat dan jawab pertanyaan: </p><br><ul><li> Masukkan nama pendek unik bot dalam huruf Latin - ini adalah nama pengguna bot yang dengannya bot akan tersedia melalui @ atau dengan tautan dari formulir <code>https://tt.me/username</code> .  Tidak ada batasan khusus pada nama pengguna.  Secara khusus, kata bot adalah opsional. </li><li>  Masukkan nama - ini adalah nama tampilan bot.  Di sini Anda sudah bisa menggunakan alfabet Cyrillic. </li></ul><br><p>  Jika semuanya dimasukkan dengan benar, maka bot yang dibuat akan ditambahkan ke kontak dan sebagai imbalannya kami akan menerima token - urutan karakter bentuk: HDyDvomx6TfsXkgwfFCUY410fv-vbf4XVjr8JVSUu4c. </p><br><h1 id="pervichnaya-nastroyka">  Pengaturan awal </h1><br><div class="spoiler">  <b class="spoiler_title">Tampilkan</b> <div class="spoiler_text"><p>  Buat direktori: </p><br><pre> <code class="plaintext hljs">mkdir ttBotDevHelper</code> </pre> <br><p>  Pergi ke sana: </p><br><pre> <code class="plaintext hljs">cd ttBotDevHelper/</code> </pre> <br><p>  Kami menginisialisasi repositori git: </p><br><pre> <code class="plaintext hljs">git init</code> </pre> <br><p>  Unduh pustaka yang diperlukan, dengan menambahkannya sebagai submodul git: </p><br><pre> <code class="plaintext hljs">git submodule add https://github.com/asvbkr/openapi_client.git openapi_client git submodule add https://github.com/asvbkr/TamTamBot.git TamTamBot</code> </pre> <br><p>  Kami membuka direktori yang dibuat di PyCharm (misalnya, dari penjelajah di bawah menu konteks "Buka Folder sebagai proyek PyCharm") dan membuat file yang bot kami akan berisi - File / New / Python file.  Pada dialog yang muncul, masukkan nama - ttBotDevHelper, dan jawablah secara positif pertanyaan penambahan ke git. </p><br><p>  Sekarang kita perlu membuat lingkungan virtual untuk proyek kita. </p><br><p>  Untuk membuat lingkungan virtual, pilih File / Pengaturan dan pilih subkunci Project Interpreter pada tab proyek.  Selanjutnya, di sebelah kanan, klik ikon roda gigi dan pilih Tambahkan: </p><br><p><img src="https://habrastorage.org/webt/dg/js/qv/dgjsqvo0ygtsp12lehregxcm8po.png" alt="gambar"></p><br><p>  PyCharm akan menawarkan opsi akomodasi sendiri. </p><br><p><img src="https://habrastorage.org/webt/lp/gg/og/lpggogip_ekpmuoiegolvfxyk2s.png" alt="gambar"></p><br><p>  Masuk akal untuk setuju dengannya. </p><br><p>  Setelah membuat lingkungan virtual, layar sebelumnya akan terbuka, tetapi itu sudah akan berisi informasi tentang lingkungan yang dibuat.  Pada layar ini, Anda perlu menginstal paket yang diperlukan dengan mengklik ikon "+" di sebelah kanan dan memasukkan nama paket: </p><br><ul><li>  permintaan </li><li>  enam </li></ul><br><p>  Kemudian kami menambahkan file .gitignore ke proyek, tidak termasuk file yang tidak diperlukan di git, dengan konten berikut: </p><br><pre> <code class="plaintext hljs">venv/ .idea/ # Byte-compiled / optimized / DLL files __pycache__/ *.py[cod] *$py.class *.log *.log.* .env ttb.sqlite3</code> </pre> <br><p>  Tambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">variabel lingkungan</a> bernama <code>TT_BOT_API_TOKEN</code> , di mana kami menunjukkan nilai token bot kami yang diterima dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tt.me/primebot</a> dan mulai ulang PyCharm. </p><br><p>  <strong>(!)</strong> Alih-alih menambahkan variabel lingkungan langsung ke lingkungan OS, PyCharm secara optimal menggunakan file .env khusus.  Konfigurasi akan dibahas di bawah. </p><br><p>  Selamat, sekarang Anda dapat melanjutkan ke bagian yang paling menarik - menulis bot Anda. </p></div></div><br><h1 id="zapusk-prosteyshego-bota">  Peluncuran bot sederhana </h1><br><p>  Buka file ttBotDevHelper.py dan tulis baris pertama: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: UTF-8 -*- from TamTamBot.TamTamBot import TamTamBot class BotDevHelper(TamTamBot): pass</span></span></code> </pre> <br><p>  Di sini kita membuat kelas bot kita berdasarkan kelas TamTamBot. </p><br><p>  PyCharm menyarankan bahwa kelas BotDevHelper berisi metode abstrak yang perlu diimplementasikan.  Tekan Alt-Enter pada nama kelas, pilih "Terapkan metode abstrak", pilih semua metode (2 dari mereka) yang diusulkan oleh PyCharm dan klik OK.  Akibatnya, dua metode properti kosong akan ditambahkan: token dan deskripsi.  Kami memodifikasi kode yang dihasilkan sebagai berikut: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: UTF-8 -*- import os from TamTamBot.TamTamBot import TamTamBot from TamTamBot.utils.lng import set_use_django class BotDevHelper(TamTamBot): @property def token(self): return os.environ.get('TT_BOT_API_TOKEN') @property def description(self): return '       .\n\n' \ 'This bot is an helper in the development and management of bots.' if __name__ == '__main__': set_use_django(False) BotDevHelper().polling()</span></span></code> </pre> <br><p>  Properti <code>token</code> mengembalikan token bot kami, yang nilainya diambil dari variabel lingkungan <code>TT_BOT_API_TOKEN</code> .  Properti <code>description</code> mengembalikan deskripsi panjang bot kami, yang akan ditampilkan kepada pengguna. </p><br><p>  Kode di akhir file diperlukan untuk menjalankan bot kami dalam mode polling status. </p><br><p>  Saya perhatikan bahwa kelas dasar <code>TamTamBot</code> melibatkan penggunaan server web Django untuk bekerja dalam mode web hook.  Tapi sekarang tugasnya lebih sederhana, dan kami tidak perlu Django, yang kami laporkan di baris <code>set_use_django(False)</code> .  Di sini, metode <code>polling()</code> dipanggil untuk objek kelas kami, yang memastikan operasi dalam mode yang diperlukan. </p><br><p>  Minimal yang perlu dilakukan.  Kode ini sudah cukup berfungsi.  Jalankan untuk menjalankan.  Untuk melakukan ini, tekan kombinasi tombol Ctrl-Shift-F10. </p><br><p>  Jika Anda tidak menambahkan variabel lingkungan lebih awal, langsung ke OS, maka kesalahan dengan pesan "No access_token" akan terjadi saat startup.  Untuk memperbaikinya, konfigurasikan PyCharm untuk menggunakan file .env. </p><br><div class="spoiler">  <b class="spoiler_title">Tunjukkan caranya</b> <div class="spoiler_text"><p>  Buat file teks .env.  Isinya dalam kasus kami adalah sebagai berikut: </p><br><pre> <code class="plaintext hljs">TT_BOT_API_TOKEN=__</code> </pre> <br><p>  Sekarang Anda harus menghubungkannya ke konfigurasi peluncuran di PyCharm: </p><br><p>  Kami memilih Jalankan / Edit konfigurasi dan pada tab EnvFile kami menghubungkan file .env kami: </p><br><p><img src="https://habrastorage.org/webt/2s/6s/ci/2s6scissf6roedcy6r26rjoi6ve.png" alt="gambar"></p><br><p>  Kemudian klik Terapkan. </p></div></div><br><p>  Setelah memulai bot, Anda dapat pergi ke TamTam, membuka dialog dengan bot kami dan klik tombol "Mulai".  Bot akan melaporkan informasi tentang negara adidaya yang tersembunyi.  Ini berarti bot berfungsi.  Sementara bot bekerja dalam mode demo, di mana 4 perintah tersedia.  Lihat saja. </p><br><p>  Terlepas dari pendapat yang jelas dari bot tentang kesejukannya, dia dengan malu-malu mengisyaratkan fakta bahwa sejauh ini dia tidak bisa melakukan apa-apa.  Untuk mengajarinya segala yang diperlukan untuk penaklukan dunia adalah tugas kita. </p><br><h1 id="priyom-soobscheniya-istochnika-i-otpravka-otvetnogo-soobscheniya-s-vnutrennim-predstavleniem-soobscheniya-istochnika">  Menerima pesan sumber dan mengirim pesan tanggapan dengan representasi internal dari pesan sumber </h1><br><p>  Kami akan memblokir metode <code>receive_text()</code> , kontrol yang ditransfer saat mengirim teks ke obrolan dengan bot: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive_text</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update)</span></span></span><span class="hljs-function">:</span></span> res = self.msg.send_message(NewMessageBody(<span class="hljs-string"><span class="hljs-string">f' : </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{update.message}</span></span></span><span class="hljs-string">'</span></span>, link=update.link), user_id=update.user_id) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bool(res)</code> </pre> <br><p>  Objek <code>update</code> kelas <code>UpdateCmn</code> , yang diteruskan ke metode ini, berisi berbagai informasi yang berguna dan, khususnya, semua yang kita butuhkan sekarang: </p><br><ul><li>  <code>update.message</code> - objek yang berisi pesan itu sendiri; </li><li>  <code>update.link</code> - tautan respons siap ke pesan ini; </li><li>  <code>update.user_id</code> - pengidentifikasi pengguna yang mengirim pesan. </li></ul><br><p>  Untuk mengirim pesan dari bot, kami menggunakan variabel <code>self.msg</code> , yang berisi objek <code>MessagesApi</code> yang mengimplementasikan fungsionalitas yang dijelaskan di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pesan</a> pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi API</a> .  Objek ini berisi metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>send_message()</code></a> yang kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>send_message()</code></a> , yang menyediakan pengiriman pesan.  Minimal, metode ini harus melewati objek kelas <code>NewMessageBody</code> dan tujuan - ID pengguna, dalam kasus kami. </p><br><p>  Pada gilirannya, objek kelas <code>NewMessageBody</code> dalam hal ini dibuat dengan mengirimkan representasi tekstual dari objek pesan sumber dan tautan respons ke pesan sumber. </p><br><p>  Kami memulai ulang bot kami dan memeriksa dalam dialog dengan bot bahwa bot menghasilkan respons terhadap pesan kami yang berisi representasi internal dari objek pesan sumber. </p><br><p>  Kode sumber untuk status ini ada di <a href="">sini</a> . </p><br><h1 id="dobavlenie-novoy-komandy-bota-s-parametrom---pokaz-vnutrennego-predstavleniya-soobscheniya-po-ego-identifikatoru">  Menambahkan perintah bot baru dengan parameter - menampilkan representasi internal pesan oleh pengidentifikasi </h1><br><p>  Ketika mengembangkan bot, seringkali diperlukan untuk melihat representasi internal dari pesan menggunakan satu atau lebih pengidentifikasi pesan yang dikenal (id pesan pertengahan).  Tambahkan fungsi ini ke bot kami.  Untuk melakukan ini, pertama-tama, kami menggunakan secara terpisah fungsi untuk menghasilkan informasi tentang representasi internal pesan: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view_messages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update, list_mid, link=None)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> msgs = self.msg.get_messages(message_ids=list_mid) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msgs: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> msgs.messages: r = self.msg.send_message(NewMessageBody(<span class="hljs-string"><span class="hljs-string">f' </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{msg.body.mid}</span></span></span><span class="hljs-string">:\n`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{msg}</span></span></span><span class="hljs-string">`'</span></span>[:NewMessageBody.MAX_BODY_LENGTH], link=link), user_id=update.user_id) res = res <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre> <br><p>  Dalam metode ini, kami melewati daftar mid. </p><br><p>  Untuk mendapatkan objek pesan, kami menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>self.msg.get_messages</code></a> , yang mengembalikan daftar objek di properti pesan. </p><br><p>  Selanjutnya, representasi tekstual dari masing-masing pesan yang diterima dikirim ke dialog kami dalam pesan terpisah.  Untuk menghindari kesalahan, teks dari pesan yang dihasilkan dipotong oleh konstanta dari panjang pesan maksimum - <code>NewMessageBody.MAX_BODY_LENGTH</code> . </p><br><p>  Kemudian tambahkan metode yang memproses perintah.  <strong>Sebut</strong> saja <strong>vmp</strong> .  Anda bisa melewati daftar tengah ke perintah dengan spasi. </p><br><p>  TTB dirancang sehingga penangan perintah harus dibuat sebagai metode dengan nama <code>cmd_handler_%s</code> , di mana% s adalah nama perintah.  Yaitu  untuk perintah vmp, metode ini akan dipanggil <code>cmd_handler_vmp</code> .  Objek dari kelas <code>UpdateCmn</code> diteruskan ke penangan perintah.  Selain itu, untuk sebuah perintah, ini mungkin berisi properti <code>cmd_args</code> , yang berisi kamus baris dan kata-kata di dalamnya yang dimasukkan dengan perintah </p><br><p>  Kode akan terlihat seperti ini: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmd_handler_vmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> update.this_cmd_response: <span class="hljs-comment"><span class="hljs-comment">#    ,       if update.cmd_args: #        list_id = [] parts = update.cmd_args.get('c_parts') or [] if parts: for line in parts: for part in line: list_id.append(str(part)) if list_id: res = self.view_messages(update, list_id, update.link) return bool(res)</span></span></code> </pre> <br><p>  Kami me-restart bot.  Sekarang, jika Anda mengetik perintah dalam dialog bot seperti: <code>/vmp mid1 mid2</code> (Anda dapat mengambil cek pertengahan mereka sebelumnya), maka sebagai gantinya kami mendapatkan dua pesan dengan representasi internal dari objek pesan sumber, untuk masing-masing mid yang ditransmisikan. </p><br><p>  Kode sumber untuk status ini ada di <a href="">sini</a> . </p><br><h1 id="modifikaciya-komandy-bota-dlya-raboty-s-tekstovym-otvetom">  Modifikasi perintah bot untuk bekerja dengan respons teks </h1><br><p>  Anda juga dapat mencoba meneruskan pesan dari saluran / obrolan lain.  Tetapi dalam kasus ini, hanya apa yang terkandung dalam pesan sumber dalam dialog dengan bot yang akan ditampilkan.  Khususnya, ketika mengirim pesan, informasi tombol tidak disimpan. </p><br><p>  Tetapi bagaimana jika kita ingin melihat informasi tentang pesan asli?  Dalam hal ini, Anda perlu mengambil pertengahan dari pesan yang diteruskan. </p><br><p>  Untuk mengimplementasikan mode ini, kami memodifikasi perintah <strong>vmp</strong> sehingga ketika dipanggil tanpa parameter, ia mengharapkan pesan untuk diteruskan, dan setelah itu mengambil bagian tengah dari pesan yang dikirim dan menampilkan informasi tentangnya. </p><br><p>  <strong>(!)</strong> Untuk operasi yang benar dari fungsi ini, bot harus diberikan izin untuk membaca dari saluran / sumber obrolan. </p><br><p>  Kami memodifikasi kode perintah sebagai berikut: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmd_handler_vmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> update.this_cmd_response: <span class="hljs-comment"><span class="hljs-comment">#    ,       if update.cmd_args: #        list_id = [] parts = update.cmd_args.get('c_parts') or [] if parts: for line in parts: for part in line: list_id.append(str(part)) if list_id: res = self.view_messages(update, list_id, update.link) else: #      self.msg.send_message(NewMessageBody(f' **  /    :'), user_id=update.user_id) update.required_cmd_response = True #       else: #    message = update.message link = message.link #       link #  -   . if link and link.type == MessageLinkType.FORWARD: res = self.view_messages(update, [link.message.mid], update.link) else: #         ,    . self.msg.send_message(NewMessageBody(f'.  **   /. , .'), user_id=update.user_id) return False return bool(res)</span></span></code> </pre> <br><p>  Dan sejak itu  dengan pendekatan ini, risiko meningkat karena kurangnya akses ke pesan, maka dalam metode <code>view_messages()</code> kami menambahkan cek untuk kepatuhan dengan jumlah pesan yang diminta / diterima: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view_messages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update, list_mid, link=None)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> msgs = self.msg.get_messages(message_ids=list_mid) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msgs: <span class="hljs-comment"><span class="hljs-comment">#    mid     if len(msgs.messages) &lt; len(list_mid): self.msg.send_message(NewMessageBody( f'     .    @{self.username}  /  .', link=update.link ), user_id=update.user_id) return False else: for msg in msgs.messages: r = self.msg.send_message(NewMessageBody(f' {msg.body.mid}:\n`{msg}`'[:NewMessageBody.MAX_BODY_LENGTH], link=link), user_id=update.user_id) res = res or r return res</span></span></code> </pre> <br><p>  Kami me-restart bot, memberikan perintah / vmp, dan setelah prompt tentang perlunya penerusan ditampilkan, kami meneruskan pesan dari saluran / obrolan.  Jika bot memiliki hak untuk membaca pesan di saluran / obrolan ini, representasi tekstual dari objek pesan yang diteruskan akan ditampilkan.  Jika tidak ada akses, bot akan melaporkan kemungkinan masalah dan akan menunggu penerusan dari sumber yang benar. </p><br><h1 id="nastroyka-svoystv-bota">  Pengaturan properti bot </h1><br><p>  Sekarang tinggal membawa gloss.  Mari kita tutup properti <code>about</code> , yang mengembalikan teks yang ditampilkan oleh bot ketika ia mulai bekerja, serta perintah / mulai. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta"> @property def about(self): return '       .'</span></span></code> </pre> <br><p>  Kami akan memblokir metode <code>get_commands()</code> , yang mengembalikan daftar perintah bot kami, yang muncul dalam dialog dengan bot. </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_commands</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: () -&gt; [BotCommand] commands = [ BotCommand('start', ' '), BotCommand('menu', ' '), BotCommand('vmp', '  '), ] return commands</span></span></code> </pre> <br><p>  Mari matikan properti main_menu_buttons, yang mengembalikan daftar tombol pada menu utama, dipanggil oleh perintah / menu. </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main_menu_buttons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: () -&gt; [] buttons = [ #       -  [CallbackButtonCmd(' ', 'start')], #        - .    -  [CallbackButtonCmd('  ', 'vmp', intent=Intent.POSITIVE)], ] return buttons</span></span></code> </pre> <br><p>  Kami me-restart bot, pastikan semuanya beres.  Selamat, bot pertama Anda telah dibuat dan, terlepas dari beberapa mainan, ia cukup menuntut fungsionalitas. </p><br><p>  Kode sumber untuk status ini ada di <a href="">sini</a> . </p><br><p>  Bot @devhelpbot yang berfungsi dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Itu saja untuk saat ini.  Jika topiknya menarik, maka dalam artikel berikut ini saya dapat mempertimbangkan pengembangan bot lebih lanjut.  Misalnya, menambahkan tombol khusus (khususnya, Ya / Tidak) dan memprosesnya, mengirim berbagai jenis konten (file, foto, dll.), Bekerja dalam mode webhook, dll. </p><br><p>  Ngomong-ngomong, Anda dapat dengan cepat mengajukan pertanyaan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">obrolan khusus</a> .  Saran / ide langsung di sana. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466373/">https://habr.com/ru/post/id466373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466361/index.html">Bagaimana Cossack menerima sertifikat GICSP</a></li>
<li><a href="../id466363/index.html">Slurm DevOps. Hari pertama Git, CI / CD, IaC dan Green Dinosaur</a></li>
<li><a href="../id466365/index.html">Mengembangkan OS Seperti Unix-Monolitik - Memulai (1)</a></li>
<li><a href="../id466367/index.html">Tingkat API Android, kompatibilitas mundur dan maju</a></li>
<li><a href="../id466371/index.html">3 Keberatan Penjualan Teratas yang Mungkin Anda Hadapi Bekerja dengan Teknologi Trending</a></li>
<li><a href="../id466375/index.html">Museum DataArt. KUVT2 - belajar dan bermain</a></li>
<li><a href="../id466379/index.html">Jalankan perangkat lunak "desktop" pada mikrokontroler</a></li>
<li><a href="../id466381/index.html">Bagaimana lampu LED Era berubah pada tahun 2019</a></li>
<li><a href="../id466383/index.html">Cryptocurrency Ocean: ulasan tentang 50 proyek teratas dengan CoinMarketCap</a></li>
<li><a href="../id466385/index.html">Memahami broker pesan. Mempelajari mekanisme pengiriman pesan melalui ActiveMQ dan Kafka. Bab 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>