<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏻 👨‍👩‍👦‍👦 👩🏿‍🤝‍👨🏾 Unsafe.AsSpan: Span <T> Wie werden Zeiger ersetzt? 🍥 🧑🏿‍🤝‍🧑🏽 🈵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C# ist eine unglaublich flexible Sprache. Darauf können Sie nicht nur die Backend- oder Desktop-Anwendungen schreiben. Ich verwende C# , um mit wissen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unsafe.AsSpan: Span <T> Wie werden Zeiger ersetzt?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465077/"><p><img src="https://habrastorage.org/webt/3f/dh/ia/3fdhia5h25mpjbabeocnlygdd1c.png"></p><br><p> <code>C#</code> ist eine unglaublich flexible Sprache.  Darauf können Sie nicht nur die Backend- oder Desktop-Anwendungen schreiben.  Ich verwende <code>C#</code> , um mit wissenschaftlichen Daten zu arbeiten, die bestimmte Anforderungen an die in der Sprache verfügbaren Tools stellen.  Obwohl <code>netcore</code> die Agenda <code>netcore</code> (wenn man bedenkt, dass nach <code>netstandard2.0</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meisten</a> Funktionen beider Sprachen und der Laufzeit nicht mehr auf <code>netframework</code> ), <code>netframework</code> ich weiterhin mit Legacy-Projekten. </p><br><p>  In diesem Artikel beschäftige ich mich mit einer nicht offensichtlichen (aber wahrscheinlich erwünschten?) Anwendung von <code>Span&lt;T&gt;</code> und dem Unterschied zwischen der <code>Span&lt;T&gt;</code> <code>netframework</code> in <code>netframework</code> und <code>netcore</code> aufgrund der Besonderheiten von <code>clr</code> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Haftungsausschluss 1</b> <div class="spoiler_text"><p>  Die Codefragmente in diesem Artikel sind keinesfalls für die Verwendung in realen Projekten vorgesehen. </p><br><p>  Die vorgeschlagene Lösung des (weit hergeholten?) Problems ist eher ein Proof-of-Concept. <br>  Wenn Sie dies in Ihrem Projekt implementieren, tun Sie dies in jedem Fall auf eigene Gefahr und Gefahr. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Haftungsausschluss 2</b> <div class="spoiler_text"><p>  Ich bin mir absolut sicher, dass irgendwo in jedem Fall <strong>definitiv</strong> jemand ins Knie schießen wird. </p><br><p>  Es <code>C#</code> unwahrscheinlich, dass der Typ-Sicherheitsbypass in <code>C#</code> zu etwas Gutem führt. </p><br><p>  Aus offensichtlichen Gründen habe ich diesen Code nicht in allen möglichen Situationen getestet, die vorläufigen Ergebnisse sehen jedoch vielversprechend aus. </p></div></div><br><h1 id="a-zachem-mne-voobsche-spant">  Warum brauche ich <code>Span&lt;T&gt;</code> ? </h1><br><p>  Mit Spen können Sie bequemer mit Arrays nicht <code>unmanaged</code> Typen arbeiten und so die Anzahl der erforderlichen Zuordnungen reduzieren.  Trotz der Tatsache, dass die Span-Unterstützung in <code>BCL</code> <code>netframework</code> fast vollständig fehlt, können mit <code>System.Memory</code> , <code>System.Buffers</code> und <code>System.Runtime.CompilerServices.Unsafe</code> mehrere Tools abgerufen werden. <br>  Die Verwendung von Spannen in meinem Legacy-Projekt ist begrenzt, ich fand sie jedoch nicht offensichtlich, während ich auf die Typensicherheit spuckte. <br>  Was ist diese Anwendung?  In meinem Projekt arbeite ich mit Daten, die aus einem wissenschaftlichen Werkzeug stammen.  Dies sind Bilder, die im Allgemeinen ein Array von <code>T[]</code> , wobei <code>T</code> einer der nicht <code>unmanaged</code> primitiven Typen ist, beispielsweise <code>Int32</code> (auch bekannt als <code>int</code> ).  Um diese Images korrekt auf die Festplatte zu serialisieren, muss ich das unglaublich unbequeme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Legacy-Format unterstützen</a> , das <a href="">1981</a> vorgeschlagen wurde und sich seitdem kaum geändert hat.  Das Hauptproblem dieses Formats ist, dass es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BigEndian ist</a> .  Um ein unkomprimiertes Array von <code>T[]</code> zu schreiben (oder zu lesen), müssen Sie die Endianess jedes Elements ändern.  Die triviale Aufgabe. <br>  Was sind einige offensichtliche Lösungen? </p><br><ol><li>  Wir iterieren über das Array <code>T[]</code> , rufen <code>BitConverter.GetBytes(T)</code> , erweitern diese wenigen Bytes und kopieren sie in das <code>BitConverter.GetBytes(T)</code> . </li><li>  Wir iterieren über das Array <code>T[]</code> , führen Betrugsfälle der Form <code>new byte[] {(byte)((x &amp; 0xFF00) &gt;&gt; 8), (byte)(x &amp; 0x00FF)};</code>  (sollte bei Doppelbyte-Typen funktionieren), schreiben Sie in das Ziel-Array. </li><li>  <sup>*</sup> Aber ist <code>T[]</code> ein Array?  Elemente sind in einer Reihe, richtig?  Sie können also den ganzen Weg gehen, zum Beispiel <code>Buffer.BlockCopy(intArray, 0, byteArray, 0, intArray.Length * sizeof(int));</code>  .  Die Methode kopiert das Array in das Array und ignoriert dabei die Typprüfung.  Es ist nur notwendig, die Grenzen und die Zuordnung nicht zu übersehen.  Wir mischen die Bytes als Ergebnis. </li><li>  <sup>*</sup> Sie sagen, dass <code>C#</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>(C++)++</code></a> .  Aktivieren <code>/unsafe</code> , aktivieren <code>fixed(int* p = &amp;intArr[0]) byte* bPtr = (byte*)p;</code>  und jetzt können Sie die Byte-Darstellung des Quell-Arrays umgehen, die Endianess im laufenden Betrieb ändern und Blöcke auf die Festplatte schreiben ( <code>stackalloc byte[]</code> oder <code>ArrayPool&lt;byte&gt;.Shared</code> Für den Zwischenpuffer <code>ArrayPool&lt;byte&gt;.Shared</code> ), ohne Speicher für ein ganz neues Byte-Array <code>ArrayPool&lt;byte&gt;.Shared</code> . </li></ol><br><p>  Es scheint, dass Punkt <strong>4</strong> es Ihnen ermöglicht, alle Probleme zu lösen, aber die explizite Verwendung von <code>unsafe</code> Kontext und das Arbeiten mit Zeigern ist irgendwie völlig anders.  Dann <code>Span&lt;T&gt;</code> uns <code>Span&lt;T&gt;</code> . </p><br><h1 id="spant"> <code>Span&lt;T&gt;</code> </h1> <br><p>  <code>Span&lt;T&gt;</code> sollte technisch gesehen Werkzeuge für die Arbeit mit Speicherplots bereitstellen, fast wie das Durcharbeiten von Zeigern, ohne dass das Array im Speicher „repariert“ werden muss.  Solch ein <code>GC</code> fähiger Zeiger mit Arraygrenzen.  Alles ist gut und sicher. <br>  Eine Sache, aber - trotz der Fülle von <code>System.Runtime.CompilerServices.Unsafe</code> , <code>Span&lt;T&gt;</code> auf Typ <code>Span&lt;T&gt;</code> genagelt <code>T</code>  Da spen im Wesentlichen ein Zeiger mit einer Länge von <sup>1</sup> + ist, was ist, wenn Sie Ihren Zeiger herausziehen, ihn in einen anderen Typ konvertieren, die Länge neu berechnen und eine neue Spanne erstellen?  Glücklicherweise haben wir <code>public Span&lt;T&gt;(void* pointer, int length)</code> . <br>  Schreiben wir einen einfachen Test: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*   endianess */</span></span>} Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {<span class="hljs-number"><span class="hljs-number">123</span></span>}; Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; y = DangerousCast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(x); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Flip(y); Assert.AreNotEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Flip(y); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br><p>  Fortgeschrittenere Entwickler als ich sollte sofort erkennen, was hier falsch ist.  Wird der Test fehlschlagen?  Die Antwort <strong>hängt</strong> , wie es normalerweise passiert, <strong>davon ab</strong> . <br>  In diesem Fall hängt es hauptsächlich von der Laufzeit ab.  Auf <code>netcore</code> Test funktionieren, aber auf <code>netframework</code> , wie es <code>netframework</code> . <br>  Interessanterweise funktioniert der Test in 100% der Fälle korrekt, wenn Sie einige der Aufsätze entfernen. <br>  Lass es uns richtig machen. </p><br><p>  <sup>1</sup> Ich habe mich <em>geirrt</em> . </p><br><h1 id="pravilnyy-otvet-zavisit">  Richtige Antwort: hängt davon ab </h1><br><p>  Warum hängt das Ergebnis <em>ab</em> ? <br>  Lassen Sie uns alles Unnötige entfernen und hier einen solchen Code schreiben: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Check(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Check</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">-100</span></span>}; Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; y = As&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">@"FRAMEWORK_NAME"</span></span>); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y); Console.WriteLine(); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x, <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0]"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y, <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0]"</span></span>); Console.WriteLine(); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Offset&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0] offset by size_t"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Offset&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0] offset by size_t"</span></span>); Console.WriteLine(); GC.Collect(<span class="hljs-number"><span class="hljs-number">0</span></span>, GCCollectionMode.Forced, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x, <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0] after GC"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y, <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0] after GC"</span></span>); Console.WriteLine(); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y); }</code> </pre> <br><p>  Die <code>Write&lt;T, U&gt;</code> -Methode akzeptiert eine Spanne vom Typ <code>T</code> , liest die Adresse des ersten Elements und liest durch diesen Zeiger ein Element vom Typ <code>U</code>  Mit anderen Worten, <code>Write&lt;int, int&gt;(ref x)</code> gibt die Adresse im Speicher + die Nummer 999 aus. <br>  Normales <code>Write</code> druckt ein Array. <br>  Nun zur <code>As&lt;,&gt;</code> -Methode: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> Span&lt;U&gt; As&lt;T, U&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> U : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span>(T* ptr = span) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Span&lt;U&gt;(ptr, span.Length * Unsafe.SizeOf&lt;T&gt;() / Unsafe.SizeOf&lt;U&gt;()); }</code> </pre> <br><p>  <code>C#</code> <code>Span&lt;T&gt;.GetPinnableReference()</code> unterstützt diesen Datensatz mit <code>Span&lt;T&gt;.GetPinnableReference()</code> jetzt, indem implizit die <code>Span&lt;T&gt;.GetPinnableReference()</code> -Methode <code>Span&lt;T&gt;.GetPinnableReference()</code> wird. <br>  Führen Sie diese Methode auf <code>netframework4.8</code> im <code>x64</code> Modus aus.  Wir schauen uns an, was passiert: </p><br><pre> <code class="plaintext hljs">LEGACY [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ] 0x|00|00|02|8C|00|00|2F|B0 999 Span&lt;int&gt; [0] 0x|00|00|02|8C|00|00|2F|B0 999 Span&lt;byte&gt;[0] 0x|00|00|02|8C|00|00|2F|B8 11 Span&lt;int&gt; [0] offset by size_t 0x|00|00|02|8C|00|00|2F|B8 11 Span&lt;byte&gt;[0] offset by size_t 0x|00|00|02|8C|00|00|2B|18 999 Span&lt;int&gt; [0] after GC 0x|00|00|02|8C|00|00|2F|B0 6750318 Span&lt;byte&gt;[0] after GC [ 999, 123, 11, -100 ] [ 110, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]</code> </pre> <br><p>  Anfänglich verhalten sich beide Bereiche (trotz der unterschiedlichen Typen) identisch, und der Bereich <code>Span&lt;byte&gt;</code> repräsentiert im Wesentlichen eine Byteansicht des ursprünglichen Arrays.  Was du brauchst. <br>  Okay, versuchen wir, den Beginn der Spanne auf die Größe eines <code>IntPtr</code> (oder <code>2 X int</code> auf <code>x64</code> ) zu verschieben und zu lesen.  Wir erhalten das dritte Element des Arrays und die richtige Adresse.  Und dann werden wir den Müll sammeln ... </p><br><pre> <code class="plaintext hljs">GC.Collect(0, GCCollectionMode.Forced, true, true);</code> </pre> <br><p>  Das letzte Flag in dieser Methode fordert den <code>GC</code> den Heap zu komprimieren.  Nach dem Aufruf von <code>GC.Collect</code> <code>GC</code> das ursprüngliche lokale Array.  <code>Span&lt;int&gt;</code> spiegelt diese Änderungen wider, aber unser <code>Span&lt;byte&gt;</code> weiterhin auf die alte Adresse, bei der jetzt nicht klar ist, was.  Eine großartige Möglichkeit, sich alle Knie auf einmal zu erschießen! </p><br><p>  Schauen wir uns nun das Ergebnis des exakt gleichen Codefragments an, das auf <code>netcore3.0.100-preview8</code> . </p><br><pre> <code class="plaintext hljs">CORE [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ] 0x|00|00|01|F2|8F|BD|C6|90 999 Span&lt;int&gt; [0] 0x|00|00|01|F2|8F|BD|C6|90 999 Span&lt;byte&gt;[0] 0x|00|00|01|F2|8F|BD|C6|98 11 Span&lt;int&gt; [0] offset by size_t 0x|00|00|01|F2|8F|BD|C6|98 11 Span&lt;byte&gt;[0] offset by size_t 0x|00|00|01|F2|8F|BD|BF|38 999 Span&lt;int&gt; [0] after GC 0x|00|00|01|F2|8F|BD|BF|38 999 Span&lt;byte&gt;[0] after GC [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ]</code> </pre> <br><p>  Alles funktioniert und es funktioniert <em>stabil</em> , soweit ich sehen kann.  Nach der Verdichtung ändern beide Spanier ihren Zeiger.  Großartig!  Aber wie kann es jetzt in einem Legacy-Projekt funktionieren? </p><br><h1 id="jit-intrinsic">  Jit intrinsisch </h1><br><p>  Ich habe absolut vergessen, dass die Unterstützung für Spans in <code>netcore</code> durch <a href="">intrinsik</a> implementiert wird.  Mit anderen Worten, <code>netcore</code> kann interne Zeiger sogar auf ein Array-Fragment erstellen und Links korrekt aktualisieren, wenn der <code>GC</code> es verschiebt.  In <code>netframework</code> ist die <code>nuget</code> Implementierung einer Spanne eine Krücke.  Tatsächlich haben wir zwei verschiedene Spen: Einer wird aus dem Array erstellt und verfolgt seine Links, der zweite aus dem Zeiger und hat keine Ahnung, auf was er zeigt.  Nach dem Verschieben des ursprünglichen Arrays zeigt der Bereichszeiger weiterhin auf die Stelle, an der der Zeiger in seinen Konstruktor übergeben wurde.  Zum Vergleich ist dies eine <em>Beispielimplementierung</em> von span in <code>netcore</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Span&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ByReference&lt;T&gt; _pointer; <span class="hljs-comment"><span class="hljs-comment">//  -   private readonly int _length; }</span></span></code> </pre> <br><p>  und im <code>netframework</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Span&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pinnable&lt;T&gt; _pinnable; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IntPtr _byteOffset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _length; }</code> </pre> <br><p>  <code>_pinnable</code> enthält einen Verweis auf das Array. Wenn einer an den Konstruktor übergeben wurde, enthält <code>_byteOffset</code> eine Verschiebung (selbst die Spanne im gesamten Array weist eine Verschiebung ungleich Null auf, die sich <em>wahrscheinlich</em> auf die Art und Weise bezieht, wie das Array im Speicher dargestellt wird).  Wenn Sie den <code>void*</code> -Zeiger an den Konstruktor übergeben, wird er einfach in ein absolutes <code>_byteOffset</code> .  Die Spanne wird eng an den Speicherbereich <code>if(_pinnable is null) {/*    */} else {/*    _pinnable */}</code> , und alle Instanzmethoden enthalten <code>if(_pinnable is null) {/*    */} else {/*    _pinnable */}</code> Bedingungen wie <code>if(_pinnable is null) {/*    */} else {/*    _pinnable */}</code> .  Was tun in einer solchen Situation? </p><br><h1 id="kak-delat-ne-stoit-no-ya-vse-zhe-sdelal">  Wie es geht, ist es nicht wert, aber ich habe es trotzdem getan </h1><br><p>  Dieser Abschnitt ist verschiedenen Implementierungen <code>netframework</code> , die von <code>netframework</code> unterstützt werden und die das <code>netframework</code> <code>Span&lt;T&gt; -&gt; Span&lt;U&gt;</code> , wobei alle erforderlichen Links <code>netframework</code> . <br>  <strong>Ich warne Sie: Dies ist eine Zone abnormaler Programmierung mit möglicherweise grundlegenden Fehlern und einem undefinierten Verhalten am Ende</strong> </p><br><h2 id="metod-1-naivnyy">  Methode 1: Naiv </h2><br><p>  Wie das Beispiel gezeigt hat, führt die Konvertierung von Zeigern auf <code>netframework</code> nicht zum gewünschten Ergebnis.  Wir brauchen den <code>_pinnable</code> Wert.  Okay, wir werden das Spiegelbild aufdecken, indem wir die privaten Felder herausziehen (sehr schlecht und nicht immer möglich). Wir werden es in einem neuen Zeitraum schreiben. Wir werden glücklich sein.  Es gibt nur ein <em>kleines</em> Problem: spen ist eine Referenzstruktur, es kann weder ein generisches Argument sein, noch kann es in ein <code>object</code> gepackt werden.  Standardreflexionsmethoden erfordern auf die eine oder andere Weise, die Spanne in den Referenztyp zu verschieben.  Ich habe keinen einfachen Weg gefunden (auch wenn ich über private Felder nachgedacht habe). </p><br><h2 id="metod-2-we-need-to-go-deeper">  Methode 2: Wir müssen tiefer gehen </h2><br><p>  Alles wurde bereits vor mir getan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[1]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[3]</a> ).  Spen ist eine Struktur, unabhängig von <code>T</code> drei Felder belegen dieselbe Speichermenge ( <em>auf derselben Architektur</em> ).  Was ist, wenn <code>[FieldOffset(0)]</code> ?  Kaum gesagt als getan. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange&lt;T, U&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> U : unmanaged { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;T&gt; Span_1; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;U&gt; Span_2; }</code> </pre> <br><p>  Wenn Sie jedoch das Programm starten (oder besser gesagt, wenn Sie versuchen, einen Typ zu verwenden), trifft <code>TypeLoadException</code> eine <code>TypeLoadException</code> - ein Generikum kann nicht <code>LayoutKind.Explicit</code> .  Okay, es spielt keine Rolle, gehen wir den schwierigen Weg: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; ByteSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">sbyte</span></span>&gt; SByteSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span>&gt; UShortSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>&gt; ShortSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt; UIntSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; IntSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>&gt; ULongSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; LongSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; FloatSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; DoubleSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; CharSpan; }</code> </pre> <br><p>  Jetzt können Sie dies tun: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Span&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">As2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { IntSpan = span }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exchange.ByteSpan; }</code> </pre> <br><p>  Die Methode funktioniert nur mit einem Problem: <code>_length</code> Feld <code>_length</code> kopiert. Wenn Sie also <code>int</code> -&gt; <code>byte</code> <code>_length</code> , <code>_length</code> die <code>_length</code> viermal kleiner als das reale Array. <br>  Kein Problem: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Raw { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Pinnable; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Pointer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Length; } [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange { <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Raw RawView; }</code> </pre> <br><p>  Jetzt <code>RawView</code> Sie über <code>RawView</code> auf jedes einzelne Feld zugreifen. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Span&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">As2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { IntSpan = span }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { RawView = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Raw() { Pinnable = exchange.RawView.Pinnable, Pointer = exchange.RawView.Pointer, Length = exchange.RawView.Length * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exchange2.ByteSpan; }</code> </pre> <br><p>  Und es funktioniert <strong>wie es sollte</strong> , wenn Sie die Verwendung schmutziger Tricks ignorieren.  Minus - Die generische Version des Konverters kann nicht erstellt werden. Sie müssen sich mit vordefinierten Typen zufrieden geben. </p><br><h2 id="metod-3-bezumnyy">  Methode 3: Verrückt </h2><br><p>  Wie jeder normale Programmierer automatisiere ich gerne Dinge.  Die Notwendigkeit, Konverter für ein Paar nicht <code>unmanaged</code> Typen zu schreiben, hat mir nicht gefallen.  Welche Lösung kann angeboten werden?  Lassen Sie die <code>CLR</code> Code <em>für Sie</em> schreiben. </p><br><p>  Wie erreicht man das?  Es gibt verschiedene Möglichkeiten, es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> .  Kurz gesagt, der Prozess sieht folgendermaßen aus: <br>  Erstellen Sie einen Build Builder -&gt; erstellen Sie einen Modul Builder -&gt; erstellen Sie einen Typ -&gt; {Felder, Methoden usw.} -&gt; am Ausgang erhalten wir eine Instanz von <code>Type</code> . <br>  Um genau zu verstehen, wie der Typ aussehen sollte (es ist eine <code>ref struct</code> ), verwenden wir ein beliebiges Werkzeug vom Typ <code>ildasm</code> .  In meinem Fall war es <strong>dotPeek</strong> . <br>  Das Erstellen eines Type Builders sieht ungefähr so ​​aus: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeBuilder = _mBuilder.DefineType(<span class="hljs-string"><span class="hljs-string">$"Generated_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(T).Name}</span></span></span><span class="hljs-string">"</span></span>, TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.ExplicitLayout <span class="hljs-comment"><span class="hljs-comment">// &lt;-    | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit, typeof(ValueType));</span></span></code> </pre> <br><p>  Nun die Felder.  Da wir <code>Span&lt;T&gt;</code> aufgrund der unterschiedlichen Längen nicht direkt nach <code>Span&lt;U&gt;</code> kopieren können, müssen wir für jede Besetzung zwei Typen erstellen </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Generated_Int32 { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;Int32&gt; Span; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Raw Raw; }</code> </pre> <br><p>  Hier können wir <code>Raw</code> mit unseren Händen deklarieren und wiederverwenden.  Vergessen Sie nicht <code>IsByRefLikeAttribute</code> .  Mit Feldern ist alles einfach: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spanField = typeBuilder.DefineField(<span class="hljs-string"><span class="hljs-string">"Span"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Span&lt;T&gt;), FieldAttributes.Private); spanField.SetOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rawField = typeBuilder.DefineField(<span class="hljs-string"><span class="hljs-string">"Raw"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Raw), FieldAttributes.Private); rawField.SetOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Das ist alles, der einfachste Typ ist fertig.  Zwischenspeichern Sie nun das Assembly-Modul.  Benutzerdefinierte Typen werden beispielsweise im Wörterbuch zwischengespeichert ( <code>T -&gt; Generated_{nameof(T)}</code> ).  Wir erstellen einen Wrapper, der gemäß den beiden Typen <code>TIn</code> und <code>TOut</code> zwei Arten von Helfern generiert und die erforderlichen Operationen für die <code>TOut</code> ausführt.  Es gibt aber einen.  Wie bei der Reflexion ist es fast unmöglich, sie für Spannweiten (oder andere <code>ref struct</code> ) zu verwenden.  <em>Oder ich habe keine einfache Lösung gefunden</em> .  Wie soll ich sein? </p><br><h2 id="delegates-to-the-rescue">  Delegierte zur Rettung </h2><br><p>  Reflexionsmethoden sehen normalerweise ungefähr so ​​aus: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodInfo mi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] otherArgs</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p>  Sie enthalten keine Informationen zu Typen. Wenn das Verpacken (= Verpackung) für Sie akzeptabel ist, gibt es keine Probleme. <br>  In unserem Fall müssen <code>@this</code> und <code>otherArgs</code> eine <code>ref struct</code> , die ich nicht <code>otherArgs</code> konnte. <br>  Es gibt jedoch einen einfacheren Weg.  Stellen wir uns vor, ein Typ verfügt über Getter- und Setter-Methoden (keine Eigenschaften, sondern manuell erstellte einfache Methoden). <br>  Zum Beispiel: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Generated_Int32.SetSpan(Span&lt;Int32&gt; span) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Span = span;</code> </pre> <br><p>  Zusätzlich zur Methode können wir einen Delegatentyp deklarieren (explizit im Code): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SpanSetterDelegate&lt;T&gt;(Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p>  Wir müssen dies tun, da die Standardaktion eine <code>Action&lt;Span&lt;T&gt;&gt;</code> -Signatur haben müsste, aber spenes nicht als generische Argumente verwendet werden können.  <code>SpanSetterDelegate</code> ist jedoch ein absolut gültiger Delegat. <br>  Erstellen Sie die erforderlichen Delegaten.  Führen Sie dazu Standardmanipulationen durch: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mi = type.GetMethod(<span class="hljs-string"><span class="hljs-string">"Method_Name"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,    public &amp; instance var spanSetter = (SpanSetterDelegate&lt;T&gt;) mi.CreateDelegate(typeof(SpanSetterDelegate&lt;T&gt;), @this);</span></span></code> </pre> <br><p>  Jetzt kann <code>spanSetter</code> beispielsweise als <code>spanSetter(Span&lt;T&gt;.Empty);</code>  .  Bei <code>@this</code> <sup>2</sup> handelt es sich um eine Instanz unseres dynamischen Typs, die natürlich über <code>Activator.CreateInstance(type)</code> , da die Struktur einen Standardkonstruktor ohne Argumente hat. </p><br><p>  Die letzte Grenze - wir müssen dynamisch Methoden generieren. </p><br><p>  <sup>2</sup> Möglicherweise stellen Sie fest, dass hier etwas schief geht - <code>Activator.CreateInstance()</code> packt eine <code>ref struct</code> Instanz.  Siehe Ende des nächsten Abschnitts. </p><br><h2 id="znakomtes-reflectionemit">  Treffen Sie <code>Reflection.Emit</code> </h2><br><p>  Ich denke, dass Methoden mit <code>Expression</code> generiert werden könnten, as  Die Körper unserer Trivial Getter / Setter bestehen buchstäblich aus ein paar Ausdrücken.  Ich habe einen anderen, direkteren Ansatz gewählt. </p><br><p>  Wenn Sie sich den <strong>IL-</strong> Code eines trivialen Getters ansehen, sehen Sie so etwas wie ( <code>Debug</code> , <code>X86</code> , <code>netframework4.8</code> ) </p><br><pre> <code class="plaintext hljs">nop ldarg.0 ldfld /* - */ stloc.0 br.s /*  */ ldloc.0 ret</code> </pre> <br><p>  Es gibt unzählige Orte zum Stoppen und Debuggen. <br>  In der Release-Version bleibt nur das Wichtigste übrig: </p><br><pre> <code class="plaintext hljs">ldarg.0 ldfld /* - */ ret</code> </pre> <br><p>  Das Nullargument der Instanzmethode lautet ... <code>this</code> .  Daher ist in <strong>IL</strong> Folgendes geschrieben: <br>  1) Laden Sie <code>this</code> herunter <br>  2) Laden Sie den Feldwert <br>  3) Bring es zurück </p><br><p>  Nur was?  <code>Reflection.Emit</code> hat eine spezielle Überladung, die neben dem Operationscode auch einen Felddeskriptorparameter enthält.  Genauso wie wir es zuvor erhalten haben, zum Beispiel <code>spanField</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getSpan = type.DefineMethod(<span class="hljs-string"><span class="hljs-string">"GetSpan"</span></span>, MethodAttributes.Public | MethodAttributes.HideBySig, CallingConventions.Standard, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Span&lt;T&gt;), Array.Empty&lt;Type&gt;()); gen = getSpan.GetILGenerator(); gen.Emit(OpCodes.Ldarg_0); gen.Emit(OpCodes.Ldfld, spanField); gen.Emit(OpCodes.Ret);</code> </pre> <br><p>  Für den Setter ist es etwas komplizierter. Sie müssen dies auf den Stapel laden, das erste Argument der Funktion laden, dann die Schreibanweisung im Feld aufrufen und nichts zurückgeben: </p><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> stfld <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret</code> </pre> <br><p>  Nachdem Sie dieses Verfahren für das <code>Raw</code> Feld durchgeführt und die erforderlichen Delegaten deklariert haben (oder die Standarddelegierten verwendet haben), erhalten Sie einen dynamischen Typ und vier Zugriffsmethoden, aus denen die richtigen generischen Delegaten generiert werden. </p><br><p>  Wir schreiben eine Wrapper-Klasse, die unter Verwendung von zwei generischen Parametern ( <code>TIn</code> , <code>TOut</code> ) <code>TOut</code> empfängt, die auf die entsprechenden (zwischengespeicherten) dynamischen Typen <code>TIn</code> . <code>TOut</code> erstellt sie ein Objekt jedes Typs und generiert nämlich vier generische Delegaten </p><br><ol><li>  <code>void SetSpan(Span&lt;TIn&gt; span)</code> , um den Quellbereich in die Struktur zu schreiben </li><li>  <code>Raw GetRaw()</code> , um den Inhalt eines <code>Raw GetRaw()</code> als <code>Raw</code> Struktur zu lesen </li><li>  <code>void SetRaw(Raw raw)</code> , um die geänderte <code>Raw</code> Struktur in das zweite Objekt zu schreiben </li><li>  <code>Span&lt;TOut&gt; GetSpan()</code> , um die Spanne des gewünschten Typs mit korrekt eingestellten und neu berechneten Feldern zurückzugeben. </li></ol><br><p>  Interessanterweise müssen dynamische Typinstanzen einmal erstellt werden.  Beim Erstellen eines Delegaten wird ein Verweis auf diese Objekte als <code>@this</code> Parameter übergeben.  <strong>Hier liegt ein Verstoß gegen die Regeln vor.</strong>  <strong><code>Activator.CreateInstance</code> gibt ein <code>object</code> .</strong>  <strong>Anscheinend liegt dies an der Tatsache, dass der dynamische Typ selbst nicht <code>ref</code></strong> <code>type.IsByRef</code> <strong>funktionierte (</strong> <code>type.IsByRef</code> <s>Like</s> <code>== false</code> <strong>), aber es war möglich, <code>ref</code> like Felder zu erstellen.</strong>  <strong>Anscheinend ist eine solche Einschränkung in der Sprache vorhanden, aber die <code>CLR</code> verdaut sie.</strong>  <strong>Vielleicht werden hier bei nicht standardmäßiger Verwendung die Knie angeschossen.</strong>  <sup>3</sup> </p><br><p>  Wir erhalten also eine Instanz eines generischen Typs, die vier Delegaten und zwei implizite Verweise auf Instanzen dynamischer Klassen enthält.  Delegaten und Strukturen können wiederverwendet werden, wenn dieselben Castes hintereinander ausgeführt werden.  Um die Leistung zu verbessern, werden wir erneut (bereits ein <code>(TIn, TOut) -&gt; Generator&lt;TIn, TOut&gt;</code> ) für ein Paar <code>(TIn, TOut) -&gt; Generator&lt;TIn, TOut&gt;</code> . </p><br><h2 id="shtrih-posledniy-privodim-tipy-spantin---spantout">  Der Strich ist der letzte: Wir geben Typen an, <code>Span&lt;TIn&gt; -&gt; Span&lt;TOut&gt;</code> </h2><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Span&lt;TOut&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;TIn&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      if (span.IsEmpty) return Span&lt;TOut&gt;.Empty; // Caller   ,       if (span.Length * Unsafe.SizeOf&lt;TIn&gt;() % Unsafe.SizeOf&lt;TOut&gt;() != 0) throw new InvalidOperationException(); //      // Span&lt;TIn&gt; _input.Span = span; _spanSetter(span); //  Raw // Raw raw = _input.Raw; var raw = _rawGetter(); var newRaw = new Raw() { Pinnable = raw.Pinnable, //    Pinnable Pointer = raw.Pointer, //   Length = raw.Length * Unsafe.SizeOf&lt;TIn&gt;() / Unsafe.SizeOf&lt;TOut&gt;() //   }; //   Raw    // Raw _output.Raw = newRaw; _rawSetter(newRaw); //     // Span&lt;TOut&gt; _output.Span return _spanGetter(); }</span></span></code> </pre> <br><h1 id="vyvod">  Fazit </h1><br><p>  Manchmal - aus sportlichen Gründen - können Sie einige der Einschränkungen der Sprache umgehen und nicht standardmäßige Funktionen implementieren.  Natürlich auf eigene Gefahr und Gefahr.  Es ist erwähnenswert, dass Sie mit der dynamischen Methode Zeiger und <code>unsafe / fixed</code> Kontexte vollständig aufgeben können, was ein Bonus sein kann.  Der offensichtliche Nachteil ist die Notwendigkeit der Reflexion und Typerzeugung. </p><br><h1 id="dlya-teh-kto-dochital-do-konca">  Für diejenigen, die bis zum Ende gelesen haben. </h1><br><div class="spoiler">  <b class="spoiler_title">Naive Benchmark-Ergebnisse</b> <div class="spoiler_text"><p>  Und wie schnell ist das alles? <br>  Ich habe die Geschwindigkeit von Kasten in einem dummen Szenario verglichen, das nicht die tatsächliche / potenzielle Verwendung solcher Kasten und Bereiche widerspiegelt, aber zumindest eine Vorstellung von Geschwindigkeit gibt. </p><br><ol><li> <code>Cast_Explicit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendet die Konvertierung über einen explizit deklarierten Typ wie in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode 2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jede Kaste erfordert die Zuweisung von zwei kleinen Strukturen und den Zugang zu den Feldern;</font></font></li><li> <code>Cast_IL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementiert </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode 3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , erstellt jedoch jedes Mal eine neue Instanz </font></font><code>Generator&lt;TIn, TOut&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was zu ständigen Suchen in Wörterbüchern führt, nachdem der erste Durchgang alle Typen generiert hat;</font></font></li><li> <code>Cast_IL_Cached</code>     <code>Generator&lt;TIn, TOut&gt;</code> , -     , ..       ; </li><li> <code>Buffer</code>   ,       ,     .     . </li></ol><br><p>    —         <code>int[N]</code>   <code>N/2</code>   . </p><br><p>   ,        ,    .              ,             .    ,          ,            .  ,  <em></em> <em></em> <em>   </em>     <code>unmanaged</code>   <em>  </em> . </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 Intel Core i7-2700K CPU 3.50GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores [Host] : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.3815.0 Clr : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.3815.0 Job=Clr Runtime=Clr InvocationCount=1 UnrollFactor=1</code> </pre><br><div class="scrollable-table"><table><thead><tr><th> Method </th><th>  N. </th><th> Mean </th><th>  Fehler </th><th> StdDev </th><th> Median </th><th> Ratio </th><th> RatioSD </th></tr></thead><tbody><tr><td> <strong>Cast_Explicit</strong> </td><td>  <strong>100</strong> </td><td> <strong>362.2 ns</strong> </td><td> <strong>18.0967 ns</strong> </td><td> <strong>52.7888 ns</strong> </td><td> <strong>400.0 ns</strong> </td><td> <strong>1.00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td> Cast_IL </td><td>  100 </td><td> 1,237.9 ns </td><td> 28.5954 ns </td><td> 67.4027 ns </td><td> 1,200.0 ns </td><td> 3.47 </td><td> 0.51 </td></tr><tr><td> Cast_IL_Cached </td><td>  100 </td><td> 522.8 ns </td><td> 25.2640 ns </td><td> 71.2576 ns </td><td> 500.0 ns </td><td> 1.46 </td><td> 0.27 </td></tr><tr><td> Buffer </td><td>  100 </td><td> 300.0 ns </td><td> 0.0000 ns </td><td> 0.0000 ns </td><td> 300.0 ns </td><td> 0.78 </td><td> 0.11 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td>  <strong>1000</strong> </td><td> <strong>2,628.6 ns</strong> </td><td> <strong>54.0688 ns</strong> </td><td> <strong>64.3650 ns</strong> </td><td> <strong>2,600.0 ns</strong> </td><td> <strong>1.00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td> Cast_IL </td><td>  1000 </td><td> 3,216.7 ns </td><td> 49.8568 ns </td><td> 38.9249 ns </td><td> 3,200.0 ns </td><td> 1.21 </td><td> 0.03 </td></tr><tr><td> Cast_IL_Cached </td><td>  1000 </td><td> 2,484.6 ns </td><td> 44.9717 ns </td><td> 37.5534 ns </td><td> 2,500.0 ns </td><td> 0.94 </td><td> 0.02 </td></tr><tr><td> Buffer </td><td>  1000 </td><td> 2,055.6 ns </td><td> 43.9695 ns </td><td> 73.4631 ns </td><td> 2,000.0 ns </td><td> 0.78 </td><td> 0.03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td> <strong>1000000</strong> </td><td> <strong>2,515,157.1 ns</strong> </td><td> <strong>11,809.8538 ns</strong> </td><td> <strong>10,469.1278 ns</strong> </td><td> <strong>2,516,050.0 ns</strong> </td><td> <strong>1.00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td> Cast_IL </td><td>  1.000.000 </td><td> 2,263,826.7 ns </td><td> 23,724.4930 ns </td><td> 22,191.9054 ns </td><td> 2,262,000.0 ns </td><td> 0.90 </td><td> 0.01 </td></tr><tr><td> Cast_IL_Cached </td><td>  1.000.000 </td><td> 2,265,186.7 ns </td><td> 19,505.5913 ns </td><td> 18,245.5422 ns </td><td> 2,266,300.0 ns </td><td> 0.90 </td><td> 0.01 </td></tr><tr><td> Buffer </td><td>  1.000.000 </td><td> 1,959,547.8 ns </td><td> 39,175.7435 ns </td><td> 49,544.7719 ns </td><td> 1,959,200.0 ns </td><td> 0.78 </td><td> 0.02 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td> <strong>100000000</strong> </td><td> <strong>255,751,392.9 ns</strong> </td><td> <strong>2,595,107.7066 ns</strong> </td><td> <strong>2,300,495.3873 ns</strong> </td><td> <strong>255,298,950.0 ns</strong> </td><td> <strong>1.00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td> Cast_IL </td><td> 100000000 </td><td> 228,709,457.1 ns </td><td> 527,430.9293 ns </td><td> 467,553.7809 ns </td><td> 228,864,100.0 ns </td><td> 0.89 </td><td> 0.01 </td></tr><tr><td> Cast_IL_Cached </td><td> 100000000 </td><td> 227,966,553.8 ns </td><td> 355,027.3545 ns </td><td> 296,463.9203 ns </td><td> 227,903,600.0 ns </td><td> 0.89 </td><td> 0.01 </td></tr><tr><td> Buffer </td><td> 100000000 </td><td> 213,216,776.9 ns </td><td> 1,198,565.1142 ns </td><td> 1,000,856.1536 ns </td><td> 213,517,800.0 ns </td><td> 0.83 </td><td> 0.01 </td></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title">Acknowledgements</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>JetBrains</strong></a> (      :-))   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>R#</strong></a>    <strong>VS</strong>  standalone- <strong>dotPeek</strong> ,     .  <code>BenchmarkDotNet</code>  BenchmarkDotNet, youtube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>NDC Conferences</strong></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>DotNext</strong></a>    ,  ,         . </p></div></div><br><h1 id="ps">  PS </h1><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p> <sup>3</sup>         ,      <code>ref</code> ,      ,   .  <s></s>   (   )   .    <code>ref</code> structs,        </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Raw Generated_Int32.GetRaw(Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; span) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Generated_Int32() { Span = span }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inst.Raw; }</code> </pre> <br><p>     ,     <code>Reflection.Emit</code> .      ,   <em></em>  <code>ILGenerator.DeclareLocal</code> .     </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Generated_Int32.GetSpan(Raw raw);</code> </pre> <br><p>    </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> Raw GetRaw&lt;T&gt;(Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged; <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> Span&lt;T&gt; GetSpan&lt;T&gt;(Raw raw) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p> , <em> </em> ,       <code>ref</code> — .  Weil     ,      </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getter = type.GetMethod(<span class="hljs-string"><span class="hljs-string">@"GetRaw"</span></span>, BindingFlags.Static | BindingFlags.Public).CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(GetRaw&lt;T&gt;), <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> GetRaw&lt;T&gt;;</code> </pre> <br><p>   —  </p><br><pre> <code class="cs hljs">Raw raw = getter(Span&lt;TIn&gt;.Empty); Raw newRaw = convert(raw); Span&lt;TOut&gt; = setter(newRaw);</code> </pre> </div></div><br><p> <em>UPD01:   </em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465077/">https://habr.com/ru/post/de465077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465063/index.html">Die 10 häufigsten Fehler bei der Arbeit mit der Spring-Plattform. Teil 2</a></li>
<li><a href="../de465069/index.html">Neu in Hadoop: Lernen Sie die verschiedenen Dateiformate in Hadoop kennen</a></li>
<li><a href="../de465071/index.html">TechTrain 2019 IT Festival: Wie JUG.ru, JUGNsk und JUG.MSK daran teilnahmen</a></li>
<li><a href="../de465073/index.html">Nicht auftauchen! Unterbrechbare Übergänge in iOS</a></li>
<li><a href="../de465075/index.html">In der Fahrerkabine</a></li>
<li><a href="../de465081/index.html">CLRium # 6: Parallelität und Parallelität. Lernen Sie die Magie der Aufgabenparallelisierung</a></li>
<li><a href="../de465083/index.html">Wachsame Türüberwachung</a></li>
<li><a href="../de465085/index.html">Anti-Phishing-Checkliste</a></li>
<li><a href="../de465087/index.html">Wie die NASA Snoopy engagierte und Barbie-Klamotten aufhob</a></li>
<li><a href="../de465089/index.html">Wie der Zufall den Mathematikern helfen kann</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>