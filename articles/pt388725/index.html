<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏾 🤜🏼 🆗 A lógica do spin-off 2: alguns algoritmos de encadeamento 🐵 🤟🏽 👨🏾‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desafio:
 separar as seqüências de eventos frequentemente repetidas em uma cadeia separada na qual não haverá nada supérfluo.
 Esta tarefa tem muitas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A lógica do spin-off 2: alguns algoritmos de encadeamento</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/388725/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desafio:</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
separar as seqüências de eventos frequentemente repetidas em uma cadeia separada na qual não haverá nada supérfluo.</font></font><br>
<a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta tarefa tem muitas soluções. Freqüentemente usado "cozimento" - os relacionamentos que são freqüentemente usados ​​são fixos, enquanto outros são enfraquecidos. Na final, você deve ter uma cadeia na qual os eventos repetidos com mais frequência tenham fortes laços. Esta solução tem muitas deficiências, entre as quais - baixa velocidade. Mas temos ondas de identificação de Redozubov, podemos usar outros algoritmos que podem formar uma nova cadeia após a primeira repetição. Vamos começar com um simples. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">última nota</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um método para registrar todos os eventos em uma cadeia de memória é descrito. </font><font style="vertical-align: inherit;">Deixe o sistema ler uma vez a palavra "decadência" e, em outro momento - a palavra "cachoeira". </font><font style="vertical-align: inherit;">Essas duas palavras têm a mesma parte - o final de três letras. </font><font style="vertical-align: inherit;">De acordo com as condições do problema, é necessário destacar a "almofada" da corrente. </font><font style="vertical-align: inherit;">Essa cadeia não possui pré-condições, ou seja, reconhece facilmente a entrada correspondente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma solução</font></font></h2><br>
<img src="https://habrastorage.org/files/e2d/fed/f56/e2dfedf56cab44f5b147eabedaa9d22f.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dividimos a tarefa em duas: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) encontre duas séries semelhantes de eventos (você precisa entender que aproximadamente essas duas palavras contêm sequências semelhantes) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) selecione-as em uma cadeia separada (“pad”)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos começar com a parte 2. Complicamos o neurocluster com carimbos de data e hora, que armazenam todos os eventos na cadeia de memória, como mostra a figura. Graças à parte de reconhecimento (a direção das conexões dos atributos até o registro de data e hora generalizado), a subtarefa 1 será resolvida - para encontrar uma posição com atributos comuns e, graças à cadeia de memória com links desativados, a subtarefa 2 será resolvida. A solução para a subtarefa 2 é a seguinte: começaremos a chamar duas palavras ao mesmo tempo onde eles têm em comum. Ou seja, o sistema enviará ativação por neurônios que correspondem a essas letras. Se a letra for encontrada nas duas palavras, ela deverá ser lembrada. Para fazer isso, deixe a memória acontecer com metade da força. Se o limiar de ativação do neurônio for T, a cadeia de memória deverá enviar 0,5 T do potencial de ação. O limite de ativação será excedido somente sequando o sintoma se encontrou nas duas cadeias. Depois disso, o sintoma é ativado. Então você pode usar o algoritmo usual de memorização com o código do artigo anterior - o hipocampo criará uma cadeia de memória, atribuindo a ele os sinais comuns às duas cadeias. Reduzimos a solução para a anterior.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No ENS (NS natural), a “meia ativação” pode ser alcançada variando o tempo de envio (o número de picos que chegaram), o número de neurotransmissores ou talvez usando conexões inibitórias (para transformar 1T em 0,5T).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A subtarefa 1 é um pouco mais complicada, pois deve funcionar com reconhecimento difuso. </font><font style="vertical-align: inherit;">Ou seja, mesmo se houver apenas alguns sinais comuns na cadeia que estão perdidos em algum lugar no meio da cadeia, você ainda deve perceber essa situação. </font><font style="vertical-align: inherit;">Deixe-me lembrá-lo de que, relativamente falando, os neurônios podem estar em três modos - descanso, enviando um único sinal e modo de ativação de alta frequência. </font><font style="vertical-align: inherit;">Pode-se aceitar que o "reconhecimento total" leva à transição do neurônio para o modo de ativação de alta frequência, e o reconhecimento difuso leva a uma única transmissão de sinal. </font><font style="vertical-align: inherit;">Ou podemos assumir que haverá neurônios especializados no neurocluster, alguns dos quais funcionarão apenas com completa coincidência e reconhecimento confiante, e o outro neurônio funcionará se apenas parte dos recursos forem reconhecidos. </font><font style="vertical-align: inherit;">Existem muitas soluções, o principal é perceber de alguma forma a aparência da ativação nos clusters desejados.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando fazer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
a questão é a que horas fazer essa pesquisa. Pode haver várias abordagens: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) um modo de suspensão especializado - mais precisamente, “suspensão lenta”. O sistema passa por todos os eventos que aprendeu em um dia e procura correspondências com suas outras memórias. Nesse caso, o sistema usa a memória - enviando em uma cadeia descendente e, em seguida, dá tempo para os neurônios dos sinais enviarem sinais que já estão "subindo" para outras memórias. Depois disso, ele resume e procura as memórias que têm a maior quantidade de ativação total. Em seguida, ele seleciona um desses locais e lança a subtarefa 2 - "selecione a cadeia".</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) sem um regime de sono especializado. </font><font style="vertical-align: inherit;">O sistema pode realizar uma pesquisa em tempo real, durante a percepção - e como é a situação atual? </font><font style="vertical-align: inherit;">Na verdade, a busca ocorre automaticamente durante o pensamento normal, devido ao envio de sinais pelos neurônios, o sistema pode apenas prestar atenção às memórias que têm muito em comum com a situação atual e, se necessário, executar a análise - destaque a sub-cadeia geral.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmos similares</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esses algoritmos parecem simples, mas contêm muitas sutilezas, ainda mais do que no algoritmo de classificação rápida, que, como você sabe, não pode ser escrito por muito tempo sem erros.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa tarefa é semelhante às tarefas conhecidas, por exemplo, procurando subsequências de DNA comuns. Somente o DNA em cada etapa pode ter apenas um nucleotídeo e, na rede neural de cada registro de data e hora, pode haver um número arbitrário de caracteres. Portanto, essa tarefa é um caso mais geral em comparação com a pesquisa de DNA. Se você tentar transferir algoritmos existentes e resolver esse problema de "brecha", sem redes neurais, manipulando as listas de sinais, sua cabeça começará a girar - todas essas listas aninhadas de correspondências, listas de sequências de correspondências, outras perguntas. Resolver esse problema enviando ativações para neurônios é muito mais fácil - os neurônios já existem, eles fazem tudo automaticamente, a memória já é alocada a eles, nenhuma lista aninhada é necessária, resta apenas analisar alguns neurônios e executar os algoritmos necessários.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu chamo as subtarefas 1 e 2 modos com uma e duas cadeias principais, respectivamente. </font><font style="vertical-align: inherit;">Ou seja, "quantos neurônios descendentes ativos nas cadeias de memória enviam sinais na tentativa de destacar correspondências". </font><font style="vertical-align: inherit;">Se houver apenas uma dessas cadeias recuperadas, ela estará procurando um segundo candidato para verificação. </font><font style="vertical-align: inherit;">E se o candidato já foi encontrado, você pode ativá-lo e começar a destacar os sinais. </font><font style="vertical-align: inherit;">Esses nomes - "1 ou 2 cadeias principais" - tornarão possível fazer referência a esses algoritmos por nome, em vez de "subtarefa 1 ou 2". </font><font style="vertical-align: inherit;">O modo com uma cadeia principal também pode ser chamado de "modo de busca por coincidência" e as duas cadeias principais podem ser chamadas de modo de destaque por coincidência.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisar correspondências ...</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(1 × 2, 1 cadeia principal) pode ser realizada das seguintes maneiras: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) visualize linearmente todas as memórias que se encontraram durante o dia. A transição para este modo para fins de depuração pode ser feita da seguinte forma: um caractere Unicode especial ou uma palavra especial é inserida nos conjuntos de testes de dados de entrada para a RNA; após a leitura, a RNA muda para o modo "suspensão lenta" e começa a procurar correspondências. O significado é este: eles encheram a RNA com dados reais, lançaram algoritmos de depuração para encontrar generalizações.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) usar não uma pesquisa linear, mas iniciar a análise com as situações mais interessantes - com as que apresentavam a maior cor emocional. Essa otimização é necessária, pois esses algoritmos são muito vorazes. Em ratos, parece que a lembrança do que era dia ocorre apenas 10 vezes mais rápido do que durante o dia. O sono leva menos tempo que a vigília. Portanto, com uma distribuição uniforme do tempo em todas as memórias, cada memória pode ser gerenciada para comparar apenas algumas situações semelhantes, a maioria das quais serão lixo e coincidências insignificantes. Portanto, é benéfico concentrar-se no mais importante e começar a trabalhar com ele. Podemos dizer que o algoritmo adiciona mais uma etapa - 0 cadeias principais; nessa etapa, o sistema deve selecionar o próximo evento na memória com a máxima importância,e passe para a próxima etapa - faça dela a cadeia principal para encontrar correspondências.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3) é possível fazer serifas a partir do momento da vigília - com antecedência para criar conexões com os lugares mais interessantes que precisam ser comparados à noite. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cadeias selecionadas com coincidências são lembradas, mas no futuro elas podem ser esquecidas se sua importância desaparecer com o tempo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquecendo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O esquecimento faz com que o neurocluster seja excluído - a operação removeNC, o inverso da operação newNC. </font><font style="vertical-align: inherit;">No ENS, os neurônios não vão a lugar algum, eles não morrem, suas conexões simplesmente se enfraquecem a tal ponto que eles não reagem mais aos seus sinais e estarão prontos para se reajustar para se lembrar de outra combinação. </font><font style="vertical-align: inherit;">Em nosso modelo, esses neurônios não precisam ser armazenados, podem ser removidos imediatamente - isso acelerará a operação da RNA, reduzirá o consumo de memória e simplificará a depuração. </font><font style="vertical-align: inherit;">Isso permite que você talvez reduza os requisitos de consumo de memória em uma ordem de magnitude.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralelização</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fazer a transição do modo 1 para 2, primeiro tentei criar neurônios de controle que produzissem comutação de sinal, análise e mudança de modo. Mas achei esse trabalho de nível muito baixo e comecei a escrever códigos C ++ imperativos - códigos como “percorra todos os clusters, analise-os, selecione o que você precisa, pense em mudar o modo de operação”.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A questão do desempenho de um sistema desse tipo: se você criar hardware para neurônios, poderá paralelizá-los (sim, pelo menos em placas de vídeo). Em seguida, o código com controle de neurônios e conexões dentro do cluster é paralelo fácil e automaticamente (este é apenas um pacote de ativação que é paralelo de acordo com as condições da tarefa), mas o código C ++ imperativo precisa ser paralelizado a cada vez independentemente. Portanto, para pequenas redes neurais de thread único, é mais fácil escrever código C ++ e para RNAs massivamente paralelas, é melhor transferir esse trabalho dentro da própria RNA para os ombros dos neurônios e as conexões entre eles. Não devemos esquecer que o "ciclo através de todos os neurônios" ou o "ciclo através de todos os neuroclusters" em C ++ do ponto de vista do hardware RNA é O (1), uma única etapa do envio da ativação. Portanto, pode ser visto1VTs e 2VTs (cadeias principais) para RNAs idealmente paralelizadas têm a mesma complexidade computacional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Continuação: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previsão primitiva na RNA</font></font></a></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt388725/">https://habr.com/ru/post/pt388725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt388711/index.html">Automação de iluminação de um terreno em uma vila ou o primeiro passo para uma casa inteligente</a></li>
<li><a href="../pt388713/index.html">O sétimo período da tabela periódica está agora preenchido, e isso é oficialmente</a></li>
<li><a href="../pt388715/index.html">Na nova versão do Android N, o Google mudará para o OpenJDK</a></li>
<li><a href="../pt388719/index.html">A lógica do pensamento - spin-off</a></li>
<li><a href="../pt388723/index.html">Morreu Peter Naur, um dos criadores de Algol e a notação BNF</a></li>
<li><a href="../pt388727/index.html">Os desenvolvedores de um implante que pode restaurar a funcionalidade de membros paralisados ​​receberam US $ 16 milhões</a></li>
<li><a href="../pt388729/index.html">M5BAT - uma nova abordagem para armazenamento de energia industrial</a></li>
<li><a href="../pt388731/index.html">7 melhores fotos científicas de 2015, de acordo com a Wired</a></li>
<li><a href="../pt388733/index.html">Lançar o Windows 95 no Nintendo 3DS? Sim é possivel</a></li>
<li><a href="../pt388735/index.html">De volta ao básico: a demanda por fitas de áudio aumentou significativamente em 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>