<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏽 🌪️ 👨🏻‍🎓 PubSub hampir gratis: PEMBERITAHUAN fitur di PostgreSQL 👨🏼‍⚖️ ⛷️ 🤸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika layanan microser Anda sudah menggunakan database PostgreSQL umum untuk menyimpan data, atau jika beberapa contoh layanan yang sama menggunakannya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PubSub hampir gratis: PEMBERITAHUAN fitur di PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484978/">  Jika layanan microser Anda <u>sudah menggunakan database PostgreSQL umum</u> untuk menyimpan data, atau jika beberapa contoh layanan yang sama menggunakannya di server yang berbeda, Anda bisa <b>mendapatkan pesan "</b> PubSub <b>" di</b> antara mereka yang relatif murah tanpa integrasi ke dalam arsitektur Redis, cluster RabbitMQ, atau menanamkan ke dalam kode aplikasi <a href="https://habr.com/ru/post/326880/">sistem MQ lain</a> . <br><br>  Untuk melakukan ini, kami <b>tidak akan menulis</b> <a href="https://habr.com/ru/post/483014/">pesan ke tabel database</a> , karena ini menyebabkan terlalu banyak biaya overhead, pertama <a href="https://habr.com/ru/company/postgrespro/blog/459250/">menulis yang ditransmisikan</a> , dan kemudian juga <a href="https://habr.com/post/481866/">membersihkan dari yang sudah dibaca</a> . <br><br>  Kami akan mengirim dan menerima data menggunakan mekanisme <a href="https://postgrespro.ru/docs/postgresql/12/sql-notify">NOTIFY</a> / <a href="https://postgrespro.ru/docs/postgresql/12/sql-listen">LISTEN</a> , dan kami akan mengumpulkan implementasi model untuk Node.js. <br><br><img src="https://habrastorage.org/webt/er/e_/dv/ere_dvhj_y3sjkypbqeezzg_xn4.png"><br><br>  Tetapi dengan cara ini ada garu yang harus dielakkan dengan hati-hati. <br><a name="habracut"></a><br><h2>  Fitur Protokol </h2><br><h4>  Dengarkan </h4><br><pre><code class="sql hljs">LISTEN </code> </pre> <blockquote>  Aplikasi yang menggunakan perpustakaan libpq mengeksekusi perintah LISTEN sebagai perintah SQL biasa, dan kemudian secara berkala harus memanggil fungsi PQnotifies untuk memeriksa notifikasi baru. </blockquote>  Jika Anda tidak menulis pustaka untuk bekerja dengan PG, tetapi sudah aplikasi tertentu, dalam kebanyakan kasus, Anda tidak akan memiliki akses ke panggilan ke fungsi ini. <br><br>  Tetapi jika pustaka tersebut telah ditulis untuk Anda sesuai dengan rekomendasi untuk memproses <a href="https://postgrespro.ru/docs/postgresql/12/libpq-async">permintaan</a> dan <a href="https://postgrespro.ru/docs/postgresql/12/libpq-notify">pemberitahuan</a> <a href="https://postgrespro.ru/docs/postgresql/12/libpq-async">asinkron</a> , Anda akan secara otomatis menerima pesan dalam kode aplikasi.  Jika tidak, Anda cukup <b>menjalankan <code>SELECT 1</code> secara berkala</b> pada koneksi, maka pemberitahuan akan muncul bersama dengan hasil permintaan: <blockquote>  Dalam rilis libpq yang sangat lama, hanya ada satu cara untuk memastikan penerimaan pesan tepat waktu dari perintah NOTIFY - untuk terus-menerus mengirim perintah, bahkan yang kosong, dan kemudian memeriksa PQnotify setelah setiap panggilan PQexec.  Meskipun metode ini masih berfungsi, itu dianggap usang karena penggunaan prosesor yang tidak efisien. </blockquote>  Dalam hal, misalnya, <a href="https://postgrespro.ru/docs/postgresql/12/app-psql">psql,</a> tampilannya seperti ini: <br><br><pre> <code class="plaintext hljs">_tmp=# LISTEN test; LISTEN _tmp=# SELECT 1; ?column? ---------- 1 (1 row) Asynchronous notification "test" with payload "abc123" received from server process with PID 63991.</code> </pre><br>  Jika untuk tugas yang diterapkan, kami dapat menyetujui penundaan maksimum dalam mengirimkan pesan dalam waktu 1 detik, dengan interval seperti itu, kami melaksanakan permintaan tersebut.  Pada saat yang sama, metode ini membantu untuk <b>memantau "liveness" dari koneksi</b> , memastikan bahwa tidak ada yang secara tidak sengaja <code>pg_terminate_backend</code> dari sisi server melalui <code>pg_terminate_backend</code> , atau tidak ada "crash" tiba-tiba dari PG tanpa pemberitahuan kepada klien. <br><br><h4>  PEMBERITAHUAN </h4><br><pre> <code class="sql hljs">NOTIFY  [ ,  ]</code> </pre> <br><blockquote>  Perintah NOTIFY mengirimkan acara pemberitahuan bersama dengan baris "pesan" tambahan untuk semua aplikasi klien yang sebelumnya telah mengeksekusi saluran dengan nama saluran yang ditentukan dalam database LISTEN saat ini. <br>  ... <br>  Baris "pesan" yang akan dikirim bersamaan dengan pemberitahuan ... harus berupa <a href="https://postgrespro.ru/docs/postgresql/12/sql-syntax-lexical">konstanta teks sederhana</a> .  Dalam konfigurasi standar, <b>panjangnya harus kurang dari 8000 byte</b> . </blockquote>  Yaitu, jika "pesan" kami tiba-tiba berisi sesuatu yang sangat berbeda dari ASCII, maka kami <u>harus menyaringnya</u> , dan jika itu melebihi ukuran 8000 byte (bukan karakter!), Lalu <u>potong menjadi blok dan tempelkan</u> .  Pada saat yang sama, kita harus menghemat bandwidth saluran dan sumber daya server untuk memproses transfer blok seperti itu - yaitu, tambahkan sedikit layanan "mengikat" ke konten yang berguna mungkin, tetapi juga tidak "mencekik" aplikasi klien, memaksanya untuk berkemas dengan <code>gzip -9</code> . <br><br>  Dari keuntungan tambahan mekanisme, seseorang juga dapat mencatat pengikatan pada "sumber" pesan ... <br><blockquote>  ... pekerjaan tambahan dapat dihindari dengan memeriksa apakah <b>PID dari proses pensinyalan</b> (ditunjukkan dalam data acara) cocok dengan PID sesi itu sendiri (Anda dapat menemukannya dengan menghubungi libpq).  Jika mereka cocok, maka sesi menerima pemberitahuan tentang tindakannya sendiri, sehingga dapat diabaikan. </blockquote>  ... dan pesanan pengiriman terjamin: <br><blockquote>  Selain memfilter pemberitahuan duplikat berikutnya, NOTIFY memastikan bahwa pemberitahuan dari satu transaksi selalu tiba dalam urutan yang sama dengan saat mereka dikirim.  Juga dijamin bahwa <b>pesan dari transaksi yang berbeda tiba sesuai urutan transaksi ini dilakukan</b> . </blockquote>  Kami tidak akan secara khusus menggabungkan apa pun, sehingga setiap permintaan kami hanya akan sesuai dengan transaksi terpisah. <br><br>  Tetapi ingat bahwa jika ada juga aktivitas aplikasi pada koneksi yang digunakan untuk pertukaran, PEMBERITAHUAN kami mungkin tidak berada dalam transaksi atas kehendak bebas kami sendiri, sehingga <u>efek samping dapat terjadi</u> : <br><blockquote>  Transaksi memiliki dampak signifikan pada PEMBERITAHUAN.  Pertama, jika NOTIFY dijalankan di dalam suatu transaksi, pemberitahuan dikirimkan kepada penerima setelah transaksi dilakukan, dan hanya dalam kasus ini.  Ini masuk akal, karena <b>dalam hal transaksi sedang terputus, tindakan semua perintah di dalamnya dibatalkan, termasuk PEMBERITAHUAN</b> . </blockquote>  Oleh karena itu, lebih baik menggunakan koneksi di mana jelas tidak ada transaksi atau permintaan panjang. <br><br><h4>  AccessExclusiveLock pada objek 0 dari kelas 1262 dari database 0 </h4><br>  Jika tiba-tiba PEMBERITAHUAN Anda mulai tumpul dan mencatat ekspektasi kunci seperti itu, maka Anda masih "tumbuh dari celana pendek", dan inilah saatnya untuk memikirkan MQ "dewasa". <br><br>  Bagaimanapun, antrian notifikasi, meskipun cukup besar (8GB pada build standar), masih terbatas.  Menurut <a href="">jawaban Tom Lane</a> : <br><blockquote>  <i>Kunci ini ditahan saat memasukkan pesan notifikasi transaksi, setelah itu transaksi melakukan dan melepaskan kunci.</i> </blockquote>  Artinya, tidak ada terlalu banyak opsi untuk dikerjakan: <br><br><ul><li>  <b>kirim tetapi lebih jarang</b> <br>  Yaitu, untuk menggabungkan indikator yang dikirim, jika ini adalah beberapa penghitung, dalam interval yang lebih lama. </li><li>  <b>kirim lebih sedikit</b> <br>  Misalnya, untuk menghapus "default" dari sudut pandang nilai-nilai kunci aplikasi dari JSON yang ditransmisikan. </li><li>  <b>hanya mengirim sinyal</b> , tidak ada konten sama sekali <br>  Sebagai pilihan - untuk memulai beberapa saluran, nama masing-masing sudah akan memiliki beberapa pengertian yang berlaku. </li><li>  masih <b>melakukan pengiriman dari database</b> </li></ul><br><h2>  Mengirim pesan yang rumit </h2><br><h4>  Pengodean tubuh </h4><br>  Dalam kasus umum, kami mungkin ingin mengirimkan tidak hanya karakter yang diizinkan dalam pesan, tetapi juga huruf Rusia, dan "sembarang binari" - oleh karena itu, akan lebih mudah untuk menggunakan <u>konversi ke representasi hex</u> untuk membentuk string yang ditransmisikan.  Dan ya, metode ini bekerja dengan sangat baik: <br><br><pre> <code class="sql hljs">NOTIFY test, E'\x20\x21'</code> </pre> <br><pre> <code class="plaintext hljs">Asynchronous notification "test" with payload " !" received from server process with PID 63991.</code> </pre> <br>  Tetapi mari kita kembali ke dokumentasi: <br><blockquote>  Anda harus memastikan bahwa urutan byte yang Anda buat dengan cara ini, terutama dalam notasi oktal dan heksadesimal, membentuk <b>karakter yang valid dalam penyandian server</b> .  Ketika server beroperasi dengan pengkodean UTF-8, alih-alih rekaman byte seperti itu, gunakan urutan khusus Unicode atau sintaks Unicode alternatif yang dijelaskan dalam Bagian 4.1.2.3.  (Jika tidak, Anda harus menyandikan karakter UTF-8 secara manual dan menulisnya dengan byte, yang sangat merepotkan.) </blockquote>  Oleh karena itu, bahkan dengan simbol umum tanda kutip dari win1251, kami menerima roti dalam kesedihan: <br><br><pre> <code class="sql hljs">NOTIFY test, E'\x98' <span class="hljs-comment"><span class="hljs-comment">-- ERROR: invalid byte sequence for encoding "UTF8": 0x98</span></span></code> </pre> <br>  Karena kami tidak ingin " <i>menyandikan karakter UTF-8 secara manual dan menulisnya dengan byte</i> ", kami akan langsung setuju untuk mengirim isi pesan yang <b>dikemas dalam base64</b> jika ada karakter di luar rentang <code>\x20-\x7E</code> atau, jika perlu, segmentasi.  Di satu sisi, metode pengemasan seperti itu tidak meningkatkan redundansi terlalu banyak (koefisien 4: 3), di sisi lain, metode ini diterapkan pada tingkat pustaka sistem dalam bahasa apa pun dan akan memberikan beban tambahan minimal. <br><br>  Tetapi bahkan jika kita tidak memiliki karakter "aneh", dan pesannya cocok dalam satu segmen, masih ada satu fitur - <b>lolos dari tanda kutip</b> : <br><blockquote>  Untuk memasukkan tanda kutip dalam satu baris, tulis <u>dua tanda kutip</u> di <u>sebelahnya</u> , misalnya: 'Joan of Arc'.  Perhatikan bahwa ini tidak sama dengan kutipan ganda ("). </blockquote><br><h4>  Identifikasi Segmen </h4><br>  Tugas selanjutnya adalah "memotong" pesan dengan benar ke dalam <b>blok</b> - <b>blok yang</b> diizinkan untuk pengiriman <b>7999 byte</b> , jika ukurannya tiba-tiba melebihi nilai ini.  Dan agar penerima dapat mengumpulkannya tanpa melanggar urutan atau jatuh ke dalam rantai segmen "alien".  Untuk ini, masing-masing dari mereka perlu diidentifikasi. <br><br>  Sebenarnya, kita sudah tahu dua "koordinat" - ini adalah <u>PID dari proses pengiriman</u> dan <u>nama saluran</u> yang datang di setiap notifikasi.  Dan urutan kedatangan segmen dijamin oleh protokol itu sendiri. <br><br><div class="spoiler">  <b class="spoiler_title">Tetangga Menulis</b> <div class="spoiler_text">  Kami tidak akan mempertimbangkan kasus ketika <i>beberapa penulis pada saluran yang sama</i> aktif pada saat yang sama dengan <i>menghubungkan ke database</i> (yaitu, jelas dalam proses aplikasi yang sama).  Secara teknis, ini dapat didukung dengan melewati pengenal tambahan di header segmen - tetapi lebih baik untuk "berbagi" objek PubSub tunggal di dalam aplikasi Anda. <br></div></div><br><h4>  Batas Kontainer </h4><br>  Untuk merakit sebuah wadah integral dari beberapa segmen, kita perlu mengetahui saat penyelesaiannya.  Ada dua cara khas untuk ini: <br><br><ul><li>  transfer ukuran target (dalam byte atau segmen) di yang pertama </li><li>  transmisi tanda [bukan] segmen terakhir di masing-masing </li></ul><br>  Karena kami menulis PubSub setelah semua, sebagian besar pesan kami akan pendek dan tidak menguntungkan untuk memesan banyak byte untuk transfer ukuran.  Oleh karena itu, kami akan menggunakan metode kedua, setelah mencadangkan <u>karakter pertama dari data segmen</u> sebagai bendera kelanjutan / ujung wadah. <br><br><h4>  Transfer Objek </h4><br>  Untuk mengirimkan string teks biasa dan objek JSON sebagai "pesan", kami menambahkan <u>satu lagi tanda simbol</u> untuk transformasi terbalik di sisi penerima. <br><br>  Karena kami memutuskan untuk menyandikan "non-format" di base64, untuk bendera kami dapat mengambil karakter yang diizinkan yang tidak ada dalam set ini. <br><br>  Total, kami mendapat opsi berikut untuk segmen yang ditransmisikan: <br><br><pre> <code class="plaintext hljs">-- ""   !simple string -- "  "  @{"a":1} --    base64 #&lt;segment&gt; --    base64 $&lt;segment&gt;</code> </pre><br>  Seperti yang Anda lihat, itu cukup untuk menganalisis ketika menerima segmen hanya karakter pertama untuk memahami apa yang perlu dilakukan dengan itu lebih lanjut. <br><br><h2>  Menulis Implementasi PubSub </h2><br>  Aplikasi kita akan berada di Node.js, jadi kita akan menggunakan <a href="https://www.npmjs.com/package/pg">modul node-postgres</a> untuk bekerja dengan PostgreSQL. <br><br><div class="spoiler">  <b class="spoiler_title">Kami menulis bingkai awal</b> <div class="spoiler_text">  Untuk memulai, mari buat PubSub sebagai pewaris <a href="https://nodejs.org/dist/latest-v12.x/docs/api/events.html">EventEmitter</a> , untuk dapat menghasilkan acara bagi mereka yang berlangganan saluran tertentu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PubSub = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">connection, interval, skipSelf</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     this.connection = connection; //        this.connection.on('notification', p._onmessage.bind(this)); //         this.skipSelf = skipSelf; //  "" setInterval(() =&gt; { this.connection.query('SELECT 1'); }, interval); //     ""  this.slices = {}; }; util.inherits(PubSub, EventEmitter); const p = PubSub.prototype;</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Kami bekerja dengan saluran</b> <div class="spoiler_text">  Karena LISTEN / UNLISTEN tidak bersumpah dengan cara apa pun ketika berlangganan kembali ke saluran atau berhenti berlangganan dari apa yang tidak kami langgani, kami tidak akan mempersulit apa pun. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     - "",      //     -        const quot = str =&gt; /^[_a-z][0-9a-z_\$]*$/.test(str) ? str : `"${str}"`; p.subscribe = function(channel) { this.connection.query(`LISTEN ${quot(channel)}`); return this; }; p.unsubscribe = function(channel) { this.connection.query(`UNLISTEN ${quot(channel)}`); return this; };</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Mengirim dan menerima pesan</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_LIMIT = <span class="hljs-number"><span class="hljs-number">8000</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_STR = <span class="hljs-string"><span class="hljs-string">'!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_OBJ = <span class="hljs-string"><span class="hljs-string">'@'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_SEQ = <span class="hljs-string"><span class="hljs-string">'#'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_FL_FIN = <span class="hljs-string"><span class="hljs-string">'$'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_SZ_HEAD = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PAYLOAD_SZ_DATA = PAYLOAD_LIMIT - PAYLOAD_SZ_HEAD; <span class="hljs-comment"><span class="hljs-comment">//  ""  const reASCII = /^[\x20-\x7E]*$/; //  p.publish = function(channel, payload) { let query = `NOTIFY ${quot(channel)}`; if (payload !== null &amp;&amp; payload !== undefined) { //    -    let str = typeof payload == 'string' ? PAYLOAD_FL_STR + payload : PAYLOAD_FL_OBJ + JSON.stringify(payload); if (str.length &gt; PAYLOAD_LIMIT || !reASCII.test(str)) { //   base64- const b64 = Buffer.from(str).toString('base64'); for (let pos = 0, len = b64.length; pos &lt; len; pos += PAYLOAD_SZ_DATA) { let fin = pos + PAYLOAD_SZ_DATA; let seg = fin &gt;= len ? PAYLOAD_FL_FIN + b64.slice(pos) : PAYLOAD_FL_SEQ + b64.slice(pos, fin); this.connection.query(`${query}, '${seg}'`); } } else { //        ? //     str = str.replace(/'/g, "''"); this.connection.query(`${query}, '${str}'`); } } else { //       this.connection.query(query); } return this; }; //    p._onmessage = function(msg) { const {processId, channel, payload} = msg; //  "" if (processId == this.connection.processID &amp;&amp; this.skipSelf) { return; } // ""  const id = `${processId}:${channel}`; let rv; //   let fl = payload.charAt(0); if (fl == PAYLOAD_FL_SEQ || fl == PAYLOAD_FL_FIN) { // base64 const str = payload.slice(PAYLOAD_SZ_HEAD); const slices = this.slices; let b64; if (fl == PAYLOAD_FL_FIN) { //   if (slices[id]) { slices[id].push(str); b64 = slices[id].join(''); delete slices[id]; } else { b64 = str; } } else { //     if (slices[id]) { slices[id].push(str); } else { slices[id] = [str]; } } if (b64) { rv = Buffer.from(b64, 'base64').toString(); fl = rv.charAt(0); } } else { //  / rv = payload; } if (rv !== undefined) { //   '' let res = { processId , channel }; if (rv) { //       let data = rv.slice(1); res.payload = fl == PAYLOAD_FL_OBJ ? JSON.parse(data) : data; } this.emit(channel, res); } };</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Beberapa tes</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pg = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'pg'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pgsql = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pg.Client({ <span class="hljs-attr"><span class="hljs-attr">host</span></span> : <span class="hljs-string"><span class="hljs-string">'example-db'</span></span> , <span class="hljs-attr"><span class="hljs-attr">port</span></span> : <span class="hljs-number"><span class="hljs-number">5432</span></span> , <span class="hljs-attr"><span class="hljs-attr">user</span></span> : <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> , <span class="hljs-attr"><span class="hljs-attr">password</span></span> : <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> , <span class="hljs-attr"><span class="hljs-attr">database</span></span> : <span class="hljs-string"><span class="hljs-string">'_tmp'</span></span> }); pgsql.connect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> psA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PubSub(pgsql, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> psB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PubSub(pgsql, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chA = <span class="hljs-string"><span class="hljs-string">'channel:A'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chB = <span class="hljs-string"><span class="hljs-string">'channel:B'</span></span>; psA.subscribe(chA); psB.subscribe(chB); psA.on(chA, (msg) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'A:rcv'</span></span>, msg); }); psB.on(chB, (msg) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'B:rcv'</span></span>, msg); }); psB.publish(chA); psB.publish(chA, <span class="hljs-string"><span class="hljs-string">'simple string'</span></span>); psB.publish(chA, <span class="hljs-string"><span class="hljs-string">'  '</span></span>); psB.publish(chA, {<span class="hljs-attr"><span class="hljs-attr">a</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>}); psA.publish(chB, <span class="hljs-string"><span class="hljs-string">'   100  '</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">100</span></span>)); });</code> </pre></div></div><br>  Semuanya sangat sederhana, sehingga Anda dapat dengan mudah menerapkannya pada PL lain yang digunakan dalam proyek Anda, dengan mengambil contoh sebagai dasar untuk bekerja dengan pemberitahuan asinkron: <br><br><ul><li>  <a href="http://initd.org/psycopg/docs/advanced.html">Python</a> </li><li>  <a href="https://tapoueh.org/blog/2018/07/postgresql-listen-notify/">Pergi</a> </li><li>  <a href="https://omniti.com/seeds/stop-collaborate-and-listen-notify.html">Perl</a> </li><li>  <a href="https://blog.lelonek.me/listen-and-notify-postgresql-commands-in-elixir-187c49597851">Elixir</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484978/">https://habr.com/ru/post/id484978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484964/index.html">Mengkonfigurasi keseimbangan beban pada InfoWatch Traffic Monitor</a></li>
<li><a href="../id484966/index.html">Template siap pakai untuk pengujian menggunakan Spring</a></li>
<li><a href="../id484968/index.html">WPF DataGrid. Berjuang untuk Templat</a></li>
<li><a href="../id484972/index.html">Wine 5.0 dirilis</a></li>
<li><a href="../id484974/index.html">Wang Tiles untuk Simulasi Mesin Turing</a></li>
<li><a href="../id484982/index.html">Apakah mudah untuk mengatur bisnis Anda untuk spesialis IT</a></li>
<li><a href="../id484984/index.html">Pengembang game unity. Kursus baru dari OTUS</a></li>
<li><a href="../id484990/index.html">Luxoft TechTalks - podcast video dari pakar IT global dan banyak lagi</a></li>
<li><a href="../id484992/index.html">Lebih cantik dalam proyek-proyek besar: luangkan 20 menit untuk pengaturan, lupakan memformat selamanya</a></li>
<li><a href="../id484996/index.html">Virtual PBX Beeline. Apa yang manajer tidak akan memberi tahu Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>