<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🎓 🕴🏾 👩🏿‍🤝‍👨🏾 MVC +方案与胖控制器 📓 ㊙️ 🙉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="MVC +方案与胖控制器 


现代的PHP框架（Symphony，Laravel，下文中无处不在）令人信服地表明，实现Model-View-Controller模式并不是那么简单。 由于某种原因，所有实现都容易受到所有人，开发人员以及框架本身的谴责。 


 为什么会这样呢？ 有什么办法可以解决这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVC +方案与胖控制器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424595/"><h1 id="mvc--scenario-protiv-tolstyh-kontrollerov">  MVC +方案与胖控制器 </h1><br><p>现代的PHP框架（Symphony，Laravel，下文中无处不在）令人信服地表明，实现Model-View-Controller模式并不是那么简单。 由于某种原因，所有实现都容易受到所有人，开发人员以及框架本身的谴责。 </p><br><p> 为什么会这样呢？ 有什么办法可以解决这个问题？ 让我们做对。 </p><a name="habracut"></a><br><h2 id="terminologiya"> 术语学 </h2><br><ul><li> 模型-模型（所需数据的整形） </li><li> 视图-视图（模型数据修饰器） </li><li> 控制器-控制器（根据需要提供模型视图协调器） </li><li> 模板-演示模板 </li><li> 渲染-渲染（演示图像的形成，设计） </li><li> 渲染器-渲染器（形状，演示图像的设计器） </li></ul><br><h2 id="tolstyy-kontroller"> 厚控制器 </h2><br><p> 这是一个典型的胖控制器： </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *   *      ID */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionUserHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         ( ) $user = UserModel::find($userId); //       -   $name = $user-&gt;firstName.' '.$user-&gt;lastName; //         $view = new View('hello', ['name' =&gt; $name]); //  ( )     return $view-&gt;render(); } }</span></span></code> </pre> <br><p> 我们看到了什么？ 我们看到了香醋！ 在控制器中，所有可能的东西都混在一起了-模型和表示，实际上还有控制器本身！ </p><br><p> 我们看到模型的名称和模板紧密地连接到控制器中。 这不是嗡嗡声。 我们在控制器中看到了对模型数据的操纵-由名字和姓氏组成的全名。 这不是嗡嗡声。 </p><br><p> 还有一件事：我们没有明确看到此示例，但它是隐式的。 即：只有一种渲染方式（图像形成）！ 只有一个：根据php文件中的模板！ 如果我要pdf？ 如果我不想在文件中，而是在php行中？ 我在数百个小模板上进行了精心设计的设计。 我不得不自己脱口而出字符串模板的渲染器。 我当然没有过热，但是原则上是这样。 </p><br><p> 简短摘要： </p><br><blockquote> 现代框架在每个人的MVC实施中都有共同的缺陷： <br><ol><li> 对MVC-view（View）的狭义解释<strong><em>仅</em></strong>是<em>“使用PHP文件中的模板进行</em> <em>查看</em> <em>”，</em>而不是<em>“使用任何渲染器进行查看”。</em> </li><li>  <strong><em>只能</em></strong>将MVC模型的狭义解释为“数据库模型域”，而不是<em>“任何用于表示的数据编译器”。</em> </li><li> 他们激发了同时包含所有逻辑（业务，演示和交互）的所谓<em>“ Thick Controllers”</em>的使用。 这完全破坏了MVC的主要目标-三合会组件之间的责任划分。 </li></ol><br></blockquote><p> 为了解决这些缺点，最好仔细研究一下MVC的组件。 </p><br><h2 id="predstavlenie---eto-renderer"> 视图是一个渲染器 </h2><br><p> 看一下第一个缺点： </p><br><blockquote><ol><li> 对MVC-view（View）的狭义解释<strong><em>仅</em></strong>是<em>“使用PHP文件中的模板进行</em> <em>查看</em> <em>”，</em>而不是<em>“使用任何渲染器进行查看”。</em> </li></ol><br></blockquote><p> 在这里，一切都非常简单-问题声明本身已经表明了解决问题的方法。 我们只需要说任何渲染器都可以使用该视图。 为此，只需将新的<code>renderer</code>属性添加到View类： </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $template, $data, $renderer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__costruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($template, $data, $renderer = NULL)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br><p> 因此，我们为视图定义了一个新的<code>renderer</code>属性。 在最一般的情况下，此属性的值可以是任何<code>callable</code>函数，该函数可形成使用已传输的模板传输到其的数据的图像。 </p><br><p> 大多数应用程序仅使用一个渲染器，即使使用多个渲染器，还是首选其中之一。 因此，假设存在一些默认渲染器，则将<code>renderer</code>参数定义为可选。 </p><br><p> 简单吗？ 很简单 其实不是那么简单。 事实是，MVC中的<code>View</code>与框架中的<code>View</code>并不完全相同。 没有模板，框架中的<code>View</code>无法生存。 但是由于某种原因在MVC中使用的<code>View</code>对这些相同的模板一无所知。 怎么了 是的，因为对于MVC <code>View</code> ，这是<em>将模型数据转换为图像的任何转换</em> ，而不仅仅是模板引擎。 当我们在请求处理程序中编写如下代码时： </p><br><pre> <code class="php hljs">$name = <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello, {$name}!"</span></span>;</code> </pre> <br><p> 甚至： </p><br><pre> <code class="php hljs">$return json_encode($name); <span class="hljs-comment"><span class="hljs-comment">// Ajax response</span></span></code> </pre> <br><p> 然后我们真正定义了MVC中的View，而没有涉及框架中的任何<code>View</code> ！ </p><br><p> 但是现在一切都非常简单：框架中的<code>View</code> ，这是MVC中<code>View</code>的子集。 而且，一个非常狭窄的子集，即，它只是基于PHP文件的模板引擎。 </p><br><p> 摘要：它是<code></code> ，即 数据图像的任何装饰器都是MVC中的View。 那些位于框架中的<code>View</code>只是一种<code></code> 。 </p><br><h2 id="model-domena--model-predstavleniya-viewmodel--domainmodel"> 域模型/视图模型（ViewModel / DomainModel） </h2><br><p> 现在来看第二个缺点： </p><br><blockquote><ol><li>  <strong><em>只能</em></strong>将MVC模型的狭义解释为“数据库模型域”，而不是<em>“任何用于表示的数据编译器”。</em> </li></ol><br></blockquote><p> 对每个人来说显而易见的是，MVC模型是由其他部分组成的复杂事物。 社区同意将模型分解为两个组件：域模型（DomainModel）和表示模型（ViewModel）。 </p><br><p> 域模型是存储在数据库中的模型，即 归一化模型数据。 在不同的字段中输入“名字”和“姓氏”。 框架仅被模型的这一特定部分所占据，这是因为数据存储是它自己的世界，并且经过了深入研究。 </p><br><p> 但是，应用程序需要聚合的数据而不是规范化的数据。 域数据必须编译为图像，例如：“ Hello，Ivan！”，“ Dear Ivan Petrov！”，甚至“ For Ivan <strong>a</strong> Petrov <strong>a</strong> ！”。 这些转换后的数据称为另一个模型-表示模型。 因此，现代框架仍然忽略了模型的这一部分。 它被忽略，因为在如何处理上没有达成共识。 而且，如果框架不提供解决方案，那么程序员将采用最简单的方式-他们将视图模型扔到控制器中。 他们得到了讨厌但不可避免的胖控制器！ </p><br><p> 总计：为了实现MVC，您需要实现一个视图模型。 没有其他选择。 鉴于表示形式及其数据可以是任何形式，我们声明存在问题。 </p><br><h2 id="scenariy-protiv-tolstyh-kontrollerov"> 方案与胖控制器 </h2><br><p> 框架的最后一个缺点是： </p><br><blockquote><ol><li> 他们激发了同时包含所有逻辑（业务，演示和交互）的所谓<em>“ Thick Controllers”</em>的使用。 这完全破坏了MVC的主要目标-三合会组件之间的责任划分。 </li></ol><br></blockquote><p> 在这里，我们了解了MVC的基础知识。 让我们清楚一点。 因此，MVC假定三元组组件之间的职责分配如下： </p><br><ul><li> 控制器是<em>交互逻辑</em> ，即 与外界（请求-响应）和内部（模型-演示）的互动， </li><li> 该模型是<em>业务逻辑</em> ，即 为特定请求生成数据， </li><li> 表示是<em>表示</em>的<em>逻辑</em> ，即 装饰模型生成的数据。 </li></ul><br><p> 来吧 责任的两个层次清晰可见： </p><br><ul><li> 组织级别是控制者， </li><li> 执行层是模型和表示。 </li></ul><br><p> 简而言之，Controller可以操纵“模型”和“视图”犁。 这是一种简单的方法。 如果不是以简单的方式，而是更具体地？ 控制器如何精确转向？ 以及“模型”和“视图”犁到底如何？ </p><br><p> 控制器转向如下： </p><br><ul><li> 收到应用程序的请求， </li><li> 决定要为此请求使用哪个模型和哪个视图， </li><li> 调用选定的模型并从中接收数据， </li><li> 使用从模型接收的数据调用选定的视图， </li><li> 将由View装饰的数据返回给应用程序。 </li></ul><br><p> 这样的东西。 该方案的本质是，模型和表示形式成为查询执行链中的链接。 此外，通过连续的链接：首先，模型将请求转换为某些数据，然后视图将这些模型数据转换为根据特定请求的需要修饰的答案。 就像，人形请求在视觉上用模板装饰，而android请求则用JSON编码器装饰。 </p><br><p> 现在，让我们尝试弄清楚表演者的耕作方式-模型和演示。 上面我们说过，关于将模型分解为两个子组件存在共识：领域模型和表示模型。 这意味着可以有更多的表演者-不是两个，而是三个。 而不是执行链 </p><br><blockquote>  <code></code> &gt;&gt; <code></code> </blockquote><p> 可能有一条链 </p><br><blockquote>  <code> </code> <code> </code> &gt;&gt; <code></code> <code> </code> &gt;&gt; <code></code> </blockquote><p> 问题是：为什么只有两个或三个？ 如果您需要更多？ 自然的答案是，为了上帝的缘故，需要您所需的一切！ </p><br><p> 其他有用的艺术家也可以立即看到：验证器，重定向器，各种渲染器，以及通常所有不可预测但令人愉悦的东西。 </p><br><p> 让我们回顾一下： </p><br><blockquote><ul><li> 执行级别MVC（ <code></code> - <code></code> ）可以实现为链接链，其中每个链接将前一个链接的输出转换为下一个链接的输入。 </li><li> 第一个链接的输入是应用程序请求。 </li><li> 最后一个链接的输出是应用程序对请求的响应。 </li></ul><br></blockquote><p> 我将此链称为<code>Scenario</code> ，但对于链的链接，我尚未确定名称。 当前选项包括场景（作为脚本的一部分），过滤器（作为数据转换器），脚本动作。 一般来说，链接的名称不是那么重要，还有更重要的事情。 </p><br><p> 该方案出现的后果是巨大的。 即：方案承担了主计长的主要责任-确定请求所需的模型和表示并启动它们。 因此，控制器仅具有两个职责：与外界交互（请求-响应）和运行脚本。 从某种意义上说，这是很好的，MVC三合会的所有组件都将顺序分解，变得更加具体和易于管理。 而且在另一个方面还是不错的-MVCS控制器成为纯粹的内部不可变类，因此，即使在原则上也不会变胖。 </p><br><p> 使用场景会导致MVC模式的另一种变化；我将此变化称为<strong><code>MVCS</code></strong> - <code>Model-View-Controller-Scenario</code> 。 </p><br><p> 关于MVC分解的更多信息。 现代框架将所有典型的功能分解到了极限，很自然地摆脱了与外部世界交互的职责中概念MVC的部分。 因此，经过特殊训练的类（例如<code>HTTP </code>和<code></code>将参与用户请求处理。 结果，Controller不会收到初始的用户请求，而是会收到一些改进的<code></code> ，从而可以将控制器与请求的细节隔离开来。 类似地，与HTTP响应的细节进行隔离，从而使MVC模块可以定义自己的响应类型。 另外，这些框架完全实现了MVC的两个组件-域模型和表示模板，但是，我们已经讨论过了。 我对MVC的不断完善和具体化一直在持续进行着，这真是令人耳目一新。 </p><br><h2 id="primer-ispolzovaniya-mvcs">  MVCS示例 </h2><br><p> 现在，让我们看看如何在<em>MVCS</em>中实现本文开头的<em>Fat Cortroller</em>示例。 </p><br><p> 我们首先创建一个MVCS控制器： </p><br><pre> <code class="php hljs">$mvcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MvcsController();</code> </pre> <br><p>  MVCS控制器从外部路由器接收请求。 让路由器将“ user / hello / XXX”形式的URI转换为这样的操作并请求参数： </p><br><pre> <code class="php hljs">$requestAction = <span class="hljs-string"><span class="hljs-string">'user/hello'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   $requestParams = ['XXX']; //   -  </span></span></code> </pre> <br><p> 考虑到MVCS控制器接受脚本而不是URI，我们需要将一些脚本映射到请求的操作。 最好在MVCS容器中完成此操作： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   MVCS  URI  $mvcs-&gt;set('scenarios', [ 'user/hello' =&gt; 'UserModel &gt; UserViewModel &gt; view, hello', ..., ]);</span></span></code> </pre> <br><p> 让我们仔细看看这种情况。 这是由'&gt;'分隔的三个数据转换器的链： </p><br><ul><li>  “ UserModel”是域模型“ User”的名称，模型的输入将是请求参数，输出将是实际的模型数据， </li><li>  “ UserViewModel”是用于将域数据转换为视图数据的视图模型的名称， </li><li>  “视图，您好”是称为“ hello”的PHP模板的系统视图“模板”。 </li></ul><br><p> 现在，我们只需要将脚本中涉及的两个转换器作为闭合函数添加到MVCS容器中： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   UserModel $mvcs-&gt;set('UserModel', function($id) { $users = [ 1 =&gt; ['first' =&gt; '', 'last' =&gt; ''], 2 =&gt; ['first' =&gt; '', 'last' =&gt; ''], ]; return isset($users[$id]) ? $users[$id] : NULL; }); //   UserViewModel $mvcs-&gt;set('UserViewModel', function($user) { //    PHP  : 'echo "Hello, $name!"'; return ['name' =&gt; $user['first'].' '.$user['last']]; });</span></span></code> </pre> <br><p> 仅此而已！ 对于每个请求，有必要确定相应的脚本及其所有场景（系统场景除外，例如“视图”）。 仅此而已。 </p><br><p> 现在，我们准备测试MVCS的不同请求： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//        $scenarios = $mvcs-&gt;get('scenarios'); $scenario = $scenarios[$requestAction]; //      ... //   'user/hello/1'  ' '   'hello' $requestParams = ['1']; $response = $mvcs-&gt;play($scenario, $requestParams); //   'user/hello/2'  ' '   'hello' $requestParams = ['2']; $response = $mvcs-&gt;play($scenario, $requestParams);</span></span></code> </pre> <br><blockquote>  <em>PHP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MVCS</a>实现在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">托管</a> 。</em> <br>  <em>该示例在<code>example</code> MVCS目录中。</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424595/">https://habr.com/ru/post/zh-CN424595/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424585/index.html">Crytek发布的CryEngine 5.5</a></li>
<li><a href="../zh-CN424587/index.html">《向大型公司销售》一书的摘要</a></li>
<li><a href="../zh-CN424589/index.html">如何注册博士机器学习程序</a></li>
<li><a href="../zh-CN424591/index.html">没有理想：我如何为自己寻找编程语言</a></li>
<li><a href="../zh-CN424593/index.html">C ++ 11和事件处理</a></li>
<li><a href="../zh-CN424597/index.html">RubyRussia会议发言人Marcus Schirp的访谈</a></li>
<li><a href="../zh-CN424599/index.html">您必须选择所需的软件：准时编写或高质量</a></li>
<li><a href="../zh-CN424601/index.html">互联网上的信息架构第1部分</a></li>
<li><a href="../zh-CN424603/index.html">《为什么我们错了》一书 在行动中思考陷阱。” 摘录第1部分</a></li>
<li><a href="../zh-CN424605/index.html">扎克伯格的资金：协作+技术+开放科学</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>