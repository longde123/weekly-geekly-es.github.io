<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📴 👨🏻‍🏫 ⚽️ MBED, ou sur les abstractions qui fuient 🤸🏾 😬 🤾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il jeta un coup d'œil vers mbed. À première vue, cela semblait très intéressant - un cadre indépendant de fer, en C ++, avec un support pour un tas de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MBED, ou sur les abstractions qui fuient</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/387299/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il jeta un coup d'œil vers mbed. À première vue, cela semblait très intéressant - un cadre indépendant de fer, en C ++, avec un support pour un tas de microcontrôleurs et de cartes de démonstration, un compilateur en ligne avec intégration dans le système de contrôle de version. Un tas d'exemples qui convainquent davantage l'élégance du cadre. Presque toutes les interfaces du microcontrôleur sont accessibles directement hors de la boîte en utilisant les classes correspondantes déjà implémentées. Prenez-le directement de la boîte et programmez en C ++ sans regarder la fiche technique du microcontrôleur - n'est-ce pas un rêve? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La plate-forme de test est le STM Nucleo F030 de longue date, pris en charge par cette plate-forme. Il y a beaucoup de bons tutoriels sur la façon de s'inscrire et de démarrer le premier projet, nous n'en parlerons pas. Allons directement à l'intéressant.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette carte ne contient pas trop de périphériques "embarqués". </font><font style="vertical-align: inherit;">LED et bouton - c'est toute la richesse. </font><font style="vertical-align: inherit;">Eh bien, le premier projet - le "Hello world" classique du monde des microcontrôleurs - clignote avec une LED. </font><font style="vertical-align: inherit;">Voici le code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbed.h"</span></span></span></span>
<span class="hljs-function"><span class="hljs-function">DigitalOut </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LED1)</span></span></span></span>;
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)<font></font>
    {<font></font>
        wait_ms(<span class="hljs-number"><span class="hljs-number">500</span></span>);<font></font>
        myled = myled ^ <span class="hljs-number"><span class="hljs-number">1</span></span>;<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sympa après tout, non? </font><font style="vertical-align: inherit;">Vous n'avez vraiment même pas besoin de consulter la fiche technique du contrôleur! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, le classique «Hello world» est également disponible dès la sortie de la boîte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbed.h"</span></span></span></span>
<span class="hljs-function"><span class="hljs-function">Serial </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBTX, USBRX)</span></span></span></span>;
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello world\n\r"</span></span>);
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)<font></font>
    {<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'est-ce pas vraiment génial? «Out of the box» avons-nous une console dans laquelle une impression système standard fonctionne? Soit dit en passant, le port apparaît également immédiatement lorsque la carte est connectée à l'ordinateur, avec un disque virtuel, sur lequel il vous suffit de copier le binaire assemblé - et la carte se redémarrera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais revenons à la LED clignotante. Compilation, téléchargement sur la carte - clignotant! Mais en quelque sorte trop vite, évidemment plus d'une fois par seconde, mais au moins 5 fois ... Oups ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je suis un peu distrait par les "abstractions trouées" mentionnées dans le titre. J'ai lu ce terme avec Joel Spolsky. Voici sa citation: "</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si j'enseigne aux programmeurs C ++, ce serait bien si je n'avais pas besoin de leur parler de l'arithmétique char * et pointeur, mais je pourrais aller directement aux lignes de la bibliothèque de modèles standard. Mais un jour ils écriront "foo" + "bar" et d'étranges problèmes surgiront, mais je dois encore leur expliquer ce qu'est char *. Ou ils essaieront d'appeler une fonction Windows avec un paramètre de type LPTSTR et échoueront jusqu'à ce qu'ils apprennent char * et les pointeurs et les fichiers d'en-tête Unicode et wchar_t et TCHAR - tout ce qui brille à travers les trous dans les abstractions.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aussi paradoxal que cela puisse être, la loi des abstractions trouées ne permet pas de prendre et de commencer à programmer un microcontrôleur comme celui-ci (même s'il s'agit du «bonjour» le plus simple de trois lignes), sans regarder sa fiche technique et sans avoir une idée que le microcontrôleur a le même intérieur, ainsi que ce qui se cache derrière toutes ces classes en abstraction. Contrairement aux promesses des marketeurs ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, après avoir fortement soupiré, nous commençons à chercher. Si sous mes yeux ce n'était pas une abstraction, mais un environnement de développement complet pour le contrôleur, il serait clair où creuser. Mais où creuser en cas de code ci-dessus? Si même le contenu du fichier mbed.h ne permet pas de voir l'abstraction?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heureusement, la bibliothèque mbed elle-même est open source, et vous pouvez la télécharger et voir ce qu'elle contient. </font><font style="vertical-align: inherit;">Il s'est avéré, encore une fois, heureusement, que grâce à l'abstraction pour le programmeur, tous les registres du microcontrôleur sont assez accessibles, bien qu'ils ne soient pas explicitement déclarés. </font><font style="vertical-align: inherit;">Déjà mieux. </font><font style="vertical-align: inherit;">Par exemple, vous pouvez vérifier que nous avons une vitesse d'horloge en exécutant ceci (pour lequel j'ai dû regarder les fiches techniques et creuser assez bien mbed):</font></font><br>
<br>
<pre><code class="cpp hljs">  RCC_OscInitTypeDef str;<font></font>
  RCC_ClkInitTypeDef clk;<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"SystemCoreClock = %d Hz\n\r"</span></span>, HAL_RCC_GetSysClockFreq());<font></font>
    <font></font>
    HAL_RCC_GetOscConfig(&amp;str);<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"-&gt;HSIState %d\n\r"</span></span>, str.HSIState);<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"-&gt;PLL.PLLState %d\n\r"</span></span>, str.PLL.PLLState);<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"-&gt;PLL.PLLSource %d\n\r"</span></span>, str.PLL.PLLSource);<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"-&gt;PLL.PLLMUL %d\n\r"</span></span>, str.PLL.PLLMUL);<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"-&gt;PLL.PREDIV %d\n\r"</span></span>, str.PLL.PREDIV);<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n\r"</span></span>);<font></font>
    <font></font>
    HAL_RCC_GetClockConfig(&amp;clk, &amp;flat);<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"ClockType %d\n\r"</span></span>, clk.ClockType);<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"SYSCLKSource %d\n\r"</span></span>, clk.SYSCLKSource );<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"AHBCLKDivider  %d\n\r"</span></span>, clk.AHBCLKDivider );<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"APB1CLKDivider %d\n\r"</span></span>, clk.APB1CLKDivider );<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout s'est bien passé avec la fréquence, elle était de 48 MHz, comme prévu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, creusez plus loin. </font><font style="vertical-align: inherit;">Nous essayons de connecter un timer au lieu de wait_ms ():</font></font><br>
<br>
<pre><code class="cpp hljs">   Timer timer;<font></font>
    timer.start();<font></font>
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) {<font></font>
        myled ^= <span class="hljs-number"><span class="hljs-number">1</span></span>;<font></font>
        t1 = timer.read_ms();<font></font>
        t2 = timer.read_ms();<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (t2 - t1 &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>)<font></font>
        {<font></font>
            t2 = timer.read_ms();<font></font>
        }<font></font>
    }<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est beau, non? Mais la LED clignote toujours 5 fois plus vite que souhaité ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'accord, nous creusons encore plus profondément et voyons ce que nous avons derrière le minuteur magique, qui, comme la documentation le promet, peut être créé en toute quantité, quel que soit le nombre de minuteurs matériels. microcontrôleur. Cool, ouais ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et dans le cas du STM F030, la minuterie matérielle du contrôleur TIM1 est cachée derrière, programmée pour compter les ticks en microsecondes. Et sur cette base, tout le reste a déjà été construit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, il fait déjà chaud. Rappelez-vous, j'ai dit que tous les registres sont disponibles? Nous examinons les éléments suivants:</font></font><br>
<br>
<pre><code class="cpp hljs">pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"PSC: %d\n\r"</span></span>, TIM1-&gt;PSC);
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voila! Cela met fin à l'enquête sur qui est à blâmer: le numéro 7 est envoyé à la console. Dans le registre PSC (scribe? Est-ce vraiment juste une coïncidence?) Il y a une valeur, lorsque le minuteur va générer une interruption et recommencer à compter. Et sur cette interruption et le compteur de microsecondes est raccroché. Et pour qu’à une fréquence de 48 MHz, l’interruption se produise une fois par microseconde, il ne devrait pas y en avoir du tout 7, mais 47. Et 7 sont arrivés, très probablement, au tout premier stade du chargement du microcontrôleur, car il commence à 8 MHz, puis réaccorde la PLL pour que la fréquence soit multipliée par 6, donnant les 48 MHz souhaités. Et il semble que la minuterie s'initialise trop tôt ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qui est à blâmer, bien sûr. Mais que faire? Les fouilles du cadre ont conduit aux chaînes d'appels suivantes:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Premièrement: SetSysClock_PLL_HSI () -&gt; HAL_RCC_OscConfig (), HAL_RCC_ClockConfig () -&gt; HAL_InitTick () - lors du changement de fréquence, appelez la fonction qui définit le tick de microseconde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deuxièmement: HAL_Init () -&gt; HAL_InitTick () -&gt; HAL_TIM_Base_Init () -&gt; TIM_Base_SetConfig () -&gt; TIMx-&gt; PSC - appelé depuis l'une des fonctions les plus globales, HAL_InitTick écrit la valeur requise dans le registre PSC, en fonction de l'horloge actuelle fréquences ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui reste un mystère pour moi, c'est que c'est pour la famille STM F0 que la deuxième chaîne n'est pas appelée. Je n'ai trouvé aucun appel à la fonction HAL_Init ()! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, si vous regardez l'implémentation de HAL_InitTick (), alors au tout début il y aura les lignes suivantes:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ticker_inited=<span class="hljs-number"><span class="hljs-number">0</span></span>;  
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ticker_inited)<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_OK;<font></font>
    ticker_inited=<span class="hljs-number"><span class="hljs-number">1</span></span>;
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Appelez cette fonction une seule fois. Autrement dit, vous pouvez l'appeler autant de fois que vous le souhaitez, mais elle ne fera rien pour tous les appels ultérieurs. Et le fait que le framework l'appelle au cas où les changements de fréquence d'horloge sont inutiles ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'étais trop paresseux pour reconstruire la bibliothèque, donc la correction a pris cette forme: la première ligne de la fonction principale était la suivante:</font></font><br>
<br>
<pre><code class="cpp hljs">TIM1-&gt;PSC = (SystemCoreClock / <span class="hljs-number"><span class="hljs-number">1000000</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>;
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après cela, la LED a finalement commencé à clignoter avec la fréquence correcte de 1 Hz ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je me demande à quelle étape une personne hypothétique arrêterait que les spécialistes du marketing mbed ont convaincu d'essayer de rendre la programmation des microcontrôleurs si facile à partir de zéro? S'il n'a jamais rencontré de microcontrôleurs auparavant? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'accord, si je ne suis pas très fatigué, nous allons de l'avant. Faire clignoter une LED est bon, mais pas intéressant. Je veux quelque chose de plus. Le capteur de température DS1820 a été trouvé à partir d'un plus grand, et la bibliothèque terminée pour lui a été googlé. Facile à utiliser, cachant la complexité de travailler avec ce capteur à l'intérieur. Il suffit d'écrire quelque chose comme</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"DS1820.h"</span></span></span></span>
DS1820 probe[<span class="hljs-number"><span class="hljs-number">1</span></span>] = {D4}; <span class="hljs-comment"><span class="hljs-comment">// D4 –  ,    </span></span>
probe[<span class="hljs-number"><span class="hljs-number">0</span></span>].convert_temperature(DS1820::all_devices);
<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = probe[<span class="hljs-number"><span class="hljs-number">0</span></span>].temperature(<span class="hljs-string"><span class="hljs-string">'c'</span></span>);
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que pensez-vous qu'il s'est passé après la compilation et le lancement? Correctement. Ça n'a pas marché :) Des </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
abstractions qui fuient, oui. Eh bien, une autre étude passionnante des internes mbed nous attend, semble-t-il. Et les détails du capteur lui-même. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le capteur est très intéressant. Avec son interface numérique. En une ligne, c'est-à-dire fonctionne en mode semi-duplex. Le contrôleur initie l'échange de données, le capteur envoie une séquence de bits en réponse. Surtout pour de tels cas, le framework mbed a la classe DigitalInOut, avec laquelle vous pouvez changer la direction de son travail sur la broche GPIO à la volée. Quelque chose comme ça:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> DS1820::onewire_bit_in(DigitalInOut *pin) {
    <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> answer;<font></font>
    pin-&gt;output();<font></font>
    pin-&gt;write(<span class="hljs-number"><span class="hljs-number">0</span></span>);<font></font>
    wait_us(<span class="hljs-number"><span class="hljs-number">3</span></span>);                 <font></font>
    pin-&gt;input();<font></font>
    wait_us(<span class="hljs-number"><span class="hljs-number">10</span></span>); <font></font>
    answer = pin-&gt;read();<font></font>
    wait_us(<span class="hljs-number"><span class="hljs-number">45</span></span>); 
    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> answer;<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le contrôleur envoie une impulsion «1 -&gt; 0 -&gt; 1» au capteur, qui est un signal pour qu'il envoie un bit en réponse. Qu'est-ce qui pourrait ne pas fonctionner ici? Voici une partie de la fiche technique du capteur: </font></font><br>
<br>
<img src="https://habrastorage.org/files/135/495/6dc/1354956dcab04ddab94c48a2e49a3586.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, après avoir envoyé une impulsion au capteur, afin de lire le bit, nous avons jusqu'à 15 microsecondes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous connectons l'oscilloscope et voyons que le capteur s'envoie des bits, comme indiqué dans la fiche technique. Mais ici, le contrôleur lit les ordures. Quelle pourrait être la raison? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n’écrirai pas grand-chose sur la façon dont j’en suis venu à exécuter ce code:</font></font><br>
<br>
<pre><code class="cpp hljs">    pin-&gt;output();<font></font>
    t1 = timer.read_us();<font></font>
    pin-&gt;input();<font></font>
    t4 = timer.read_us();<font></font>
    pc.<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Time: %d us\n\r"</span></span>, t4-t1);
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, qui devine, sans autre lecture, combien de temps sur un microcontrôleur avec une fréquence d'horloge de 48 MHz il faut pour changer la direction d'une broche GPIO (en fait, c'est UNE écriture dans le registre, si cela), si cela se fait en utilisant le cadre mbed écrit en C ++ en utilisant une couche indépendante du fer? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 microsecondes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et pour lire la réponse du capteur, nous en avons jusqu'à 15. Et même si nous supprimons complètement wait_us (10) du code ci-dessus, la commande answer = pin-&gt; read (); prend également un certain temps plus de 2 microsecondes. De quoi ne pas avoir le temps de lire la réponse.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heureusement, il a été possible d'envoyer une impulsion à la STM sans changer la direction du GPIO. En mode d'entrée, lorsque vous connectez la résistance PullDown intégrée, l'effet est le même. Et encore une fois, heureusement, appeler pin-&gt; mode (PullUp) au lieu de pin-&gt; input () ne nécessite que 6 microsecondes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De quoi avoir le temps de lire la réponse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et enfin, un autre trou dans l'abstraction. Après que le DS1820 a fonctionné, le capteur suivant qui est venu à la main était le DHT21, un capteur qui mesure à la fois la température et l'humidité. Également avec une interface à 1 fil, mais cette fois une réponse de codage avec une durée d'impulsion. Il semblerait que la solution évidente serait de suspendre cette ligne à l'interruption d'entrée GPIO, ce qui facilite la mesure de la durée d'impulsion. Et il y a même une classe en mbed pour ça. Et cela fonctionne même comme documenté.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais le problème est que le capteur fonctionne également en semi-duplex. Et pour qu'il commence à transmettre des données, il doit envoyer une impulsion "1 -&gt; 0 -&gt; 1" comme dans l'exemple ci-dessus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et ici, mbed ne le permet pas. Ou vous déclarez le port comme DigitalInOut, mais vous ne pouvez alors pas utiliser d'interruptions. Ou vous déclarez le port comme InterruptIn, mais vous ne pouvez rien lui envoyer. Malheureusement, l'astuce PullDown n'a pas fonctionné ici. le capteur a un PullUp intégré, et le microcontrôleur PullDown intégré n'est pas suffisant pour tirer une broche à 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai donc dû faire un cycle d'interrogation de ligne beaucoup moins beau. Bien sûr, tout a fonctionné comme ça, mais cela n'a pas fonctionné à merveille. Ce qui ne serait pas un problème d'accès direct aux registres ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est ici. </font><font style="vertical-align: inherit;">Une tentative de faire une abstraction pour que n'importe qui puisse immédiatement commencer à programmer des microcontrôleurs dignes. </font><font style="vertical-align: inherit;">Beaucoup de choses sont vraiment très simplifiées et fonctionnent même. </font><font style="vertical-align: inherit;">Mais, comme toute abstraction de haut niveau, cette abstraction est également pleine de trous. </font><font style="vertical-align: inherit;">Et en cas de collision avec l'un des nombreux trous, il faut descendre du ciel à la terre.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr387299/">https://habr.com/ru/post/fr387299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr387289/index.html">Adobe a présenté son premier éditeur vidéo pour Android</a></li>
<li><a href="../fr387291/index.html">Matériau superabsorbant comme outil de réponse aux déversements d'hydrocarbures</a></li>
<li><a href="../fr387293/index.html">Le seuil du commerce électronique en franchise de droits peut être relevé. Ou pas?</a></li>
<li><a href="../fr387295/index.html">Ларс Ларссон и ноутбук Dell путешествуют по Средней Азии</a></li>
<li><a href="../fr387297/index.html">Знакомьтесь, это торговый работник робот Tally</a></li>
<li><a href="../fr387305/index.html">Ouverture de la salle de conférence scientifique populaire Mise en place le 5 décembre</a></li>
<li><a href="../fr387307/index.html">Que se passera-t-il si nous combinons l'informatique et la médecine du sport?</a></li>
<li><a href="../fr387309/index.html">Comment l'impression 3D modifie les prothèses des membres</a></li>
<li><a href="../fr387311/index.html">Comment cuisiner une dinde festive sur l'ISS?</a></li>
<li><a href="../fr387313/index.html">Le plus ancien musée technique d'Europe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>