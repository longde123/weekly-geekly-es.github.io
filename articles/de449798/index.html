<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêç üëéüèº üßõüèΩ Turmverteidigung in Einheit schaffen, Teil 1 üèöÔ∏è üë©‚Äç‚öïÔ∏è üìá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Feld 


- Erstellen eines Kachelfelds. 
- Suchpfade mit der Breitensuche. 
- Implementieren Sie die Unterst√ºtzung f√ºr leere und Endkacheln sowie W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Turmverteidigung in Einheit schaffen, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449798/"><h1>  Das Feld </h1><br><ul><li>  Erstellen eines Kachelfelds. </li><li>  Suchpfade mit der Breitensuche. </li><li>  Implementieren Sie die Unterst√ºtzung f√ºr leere und Endkacheln sowie Wandkacheln. </li><li>  Bearbeiten von Inhalten im Spielemodus. </li><li>  Optionale Anzeige von Rasterfeldern und Pfaden. </li></ul><br>  Dies ist der erste Teil einer Reihe von Tutorials zum Erstellen eines einfachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tower Defense-</a> Spiels.  In diesem Teil werden wir √ºberlegen, ein Spielfeld zu schaffen, einen Weg zu finden und endg√ºltige Kacheln und W√§nde zu platzieren. <br><br>  Das Tutorial wurde in Unity 2018.3.0f2 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3d/ae4/591/c3dae459169a0a7f0ce240763b91d55c.jpg"></div><br>  <i>Ein Feld, das zur Verwendung in einem Tower Defense-Genre-Kachelspiel bereit ist.</i> <br><br><h2>  Tower Defense-Spiel </h2><br>  Tower Defense ist ein Genre, in dem es das Ziel des Spielers ist, Massen von Feinden zu zerst√∂ren, bis sie ihren Endpunkt erreichen.  Der Spieler erreicht sein Ziel, indem er T√ºrme baut, die Feinde angreifen.  Dieses Genre hat viele Variationen.  Wir werden ein Spiel mit einem Kachelfeld erstellen.  Gegner bewegen sich √ºber das Spielfeld in Richtung ihres Endpunkts und der Spieler schafft Hindernisse f√ºr sie. <br><a name="habracut"></a><br>  Ich gehe davon aus, dass Sie bereits eine Reihe von Tutorials zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten von Objekten studiert haben</a> . <br><br><h3>  Das Feld </h3><br>  Das Spielfeld ist der wichtigste Teil des Spiels, daher werden wir es zuerst erstellen.  Dies ist ein Spielobjekt mit einer eigenen Komponente <code>GameBoard</code> , die durch Festlegen der Gr√∂√üe in zwei Dimensionen initialisiert werden kann, f√ºr die wir den Wert von <code>Vector2Int</code> .  Das Feld sollte mit jeder Gr√∂√üe funktionieren, aber wir werden die Gr√∂√üe woanders ausw√§hlen, also werden wir eine gemeinsame <code>Initialize</code> daf√ºr erstellen. <br><br>  Zus√§tzlich visualisieren wir das Feld mit einem Viereck, das die Erde bezeichnet.  Wir werden das Feldobjekt selbst nicht zu einem Viereck machen, sondern ihm ein untergeordnetes Quad-Objekt hinzuf√ºgen.  Nach der Initialisierung werden wir die XY-Skala der Erde gleich der Gr√∂√üe des Feldes machen.  Das hei√üt, jede Fliese hat eine Gr√∂√üe von einer quadratischen Ma√üeinheit f√ºr den Motor. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform ground = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Vector2Int size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Warum explizit den Standardwert festlegen?</b> <div class="spoiler_text">  Die Idee ist, dass alles, was √ºber den Unity-Editor anpassbar ist, √ºber serialisierte versteckte Felder zug√§nglich ist.  Diese Felder m√ºssen nur im Inspektor ge√§ndert werden.  Leider zeigt der Unity-Editor st√§ndig eine Compiler-Warnung an, dass der Wert niemals zugewiesen wird.  Wir k√∂nnen diese Warnung unterdr√ºcken, indem wir den Standardwert f√ºr das Feld explizit festlegen.  Sie k√∂nnen auch <code>null</code> zuweisen, aber ich habe es so gemacht, dass explizit gezeigt wird, dass wir einfach den Standardwert verwenden, der kein echter Verweis auf Masse ist, also verwenden wir <code>default</code> . </div></div><br>  Erstellen Sie ein Feldobjekt in einer neuen Szene und f√ºgen Sie ein untergeordnetes Quad mit einem Material hinzu, das wie Erde aussieht.  Da wir ein einfaches Prototypenspiel erstellen, wird ein einheitliches gr√ºnes Material ausreichen.  Drehen Sie das Quad um 90 ¬∞ entlang der X-Achse, so dass es auf der XZ-Ebene liegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/9b8/9af/db99b89afcc551541f1f6adbe4816e54.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/f7c/77d/fa8f7c77d6697bca5e3c8823f5adcd86.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/467/015/f2a467015b8eefc8ca956eaec61d50dc.png"></div><br>  <i>Spielfeld.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Warum positionieren Sie das Spiel nicht auf der XY-Ebene?</b> <div class="spoiler_text">  Obwohl das Spiel im 2D-Raum stattfinden wird, werden wir es in 3D rendern, mit 3D-Feinden und einer Kamera, die relativ zu einem bestimmten Punkt bewegt werden kann.  Die XZ-Ebene ist hierf√ºr bequemer und entspricht der Standard-Skybox-Ausrichtung f√ºr die Umgebungsbeleuchtung. </div></div><br><h3>  Das Spiel </h3><br>  Erstellen Sie als N√§chstes eine <code>Game</code> , die f√ºr das gesamte Spiel verantwortlich ist.  In diesem Stadium bedeutet dies, dass das Feld initialisiert wird.  Wir machen die Gr√∂√üe einfach √ºber den Inspektor anpassbar und zwingen die Komponente, das Feld beim Aufwachen zu initialisieren.  Verwenden wir die Standardgr√∂√üe 11 √ó 11. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Game</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Vector2Int boardSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); [SerializeField] GameBoard board = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize); } }</code> </pre> <br>  Feldgr√∂√üen k√∂nnen nur positiv sein und es macht wenig Sinn, ein Feld mit einer einzigen Kachel zu erstellen.  Begrenzen wir also das Minimum auf 2 √ó 2.  Dies kann durch Hinzuf√ºgen der <code>OnValidate</code> Methode erfolgen, wodurch die Mindestwerte zwangsweise begrenzt werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnValidate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.x &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.x = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.y &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wann wird Onvalidate aufgerufen?</b> <div class="spoiler_text">  Wenn es vorhanden ist, ruft der Unity-Editor es nach dem √Ñndern f√ºr die Komponenten auf.  Einschlie√ülich beim Hinzuf√ºgen zum Spielobjekt, nach dem Laden der Szene, nach dem erneuten Kompilieren, nach dem √Ñndern im Editor, nach dem Abbrechen / erneuten Versuchen und nach dem Zur√ºcksetzen der Komponente. <br><br>  <code>OnValidate</code> ist die einzige Stelle im Code, an der Sie Komponentenkonfigurationsfeldern Werte zuweisen k√∂nnen. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/15d/efd/7ae15defd1e838186f922fc30d346b17.png"></div><br>  <i>Spielobjekt.</i> <br><br>  Wenn Sie jetzt den Spielmodus starten, erhalten wir ein Feld mit der richtigen Gr√∂√üe.  Positionieren Sie die Kamera w√§hrend des Spiels so, dass das gesamte Brett sichtbar ist, kopieren Sie die Transformationskomponente, verlassen Sie den Spielmodus und f√ºgen Sie die Werte der Komponente ein.  Bei einem 11 √ó 11-Feld am Ursprung k√∂nnen Sie die Kamera in Position (0,10,0) positionieren und um 90 ¬∞ entlang der X-Achse drehen, um eine bequeme Ansicht von oben zu erhalten. Wir lassen die Kamera in dieser festen Position, aber es ist m√∂glich √§ndere es in der Zukunft. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/45c/421/eb545c421fdca09acf1258a2fac9e183.png"></div><br>  <i>Kamera √ºber dem Feld.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Wie kopiere ich Komponentenwerte und f√ºge sie ein?</b> <div class="spoiler_text">  √úber das Dropdown-Men√º, das angezeigt wird, wenn Sie auf die Schaltfl√§che mit dem Zahnrad in der oberen rechten Ecke der Komponente klicken. </div></div><br><h3>  Fertighausfliese </h3><br>  Das Feld besteht aus quadratischen Kacheln.  Feinde k√∂nnen sich von Kachel zu Kachel bewegen und die Kanten √ºberqueren, jedoch nicht diagonal.  Die Bewegung erfolgt immer zum n√§chsten Endpunkt.  Bezeichnen wir grafisch die Bewegungsrichtung entlang der Kachel mit einem Pfeil.  Sie k√∂nnen die Pfeilstruktur <a href="">hier</a> herunterladen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/l6/os/tfl6oszqhi93v6aqlllrp1yuhli.png"></div><br>  <i>Pfeil auf einem schwarzen Hintergrund.</i> <br><br>  Platzieren Sie die Pfeilstruktur in Ihrem Projekt und aktivieren Sie die Option <em>Alpha als Transparenz</em> .  Erstellen Sie dann ein Material f√ºr den Pfeil, das das Standardmaterial sein kann, f√ºr das der Ausschnittmodus ausgew√§hlt ist, und w√§hlen Sie den Pfeil als Haupttextur aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/2d6/56c/bfb2d656c07931b8f59ef11715eee93b.png"></div><br>  <i>Pfeilmaterial.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Warum den Cutout-Render-Modus verwenden?</b> <div class="spoiler_text">  Sie k√∂nnen den Pfeil mithilfe der Standard-Unity-Rendering-Pipeline verdecken. </div></div><br>  Um jedes Pl√§ttchen im Spiel zu kennzeichnen, verwenden wir das Spielobjekt.  Jeder von ihnen hat ein eigenes Quad mit Pfeilmaterial, genau wie das Feld ein Quad aus Erde hat.  Wir werden der GameTile-Komponente auch Kacheln mit einem Link zu ihrem Pfeil hinzuf√ºgen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTile</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform arrow = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }</code> </pre> <br>  Erstellen Sie ein Kachelobjekt und verwandeln Sie es in ein Fertighaus.  Die Fliesen sind bodenb√ºndig. Heben Sie den Pfeil daher etwas an, um Probleme mit der Tiefe beim Rendern zu vermeiden.  Verkleinern Sie auch ein wenig, damit zwischen benachbarten Pfeilen wenig Platz ist.  Ein Y-Versatz von 0,001 und eine Skala von 0,8, die f√ºr alle Achsen gleich ist, reichen aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/02b/6d8/f1202b6d8f8f33593bf56ef0d8665537.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/964/1ac/a4b/9641aca4b874f48c3765af10e2c83157.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/7a3/c9f/df77a3c9f539083eab845be6b9c62919.png"></div><br>  <i>Fertighausfliese.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Wo ist die vorgefertigte Kachelhierarchie?</b> <div class="spoiler_text">  Sie k√∂nnen den Fertighaus-Bearbeitungsmodus √∂ffnen, indem Sie auf das Fertighaus doppelklicken oder das Fertighaus ausw√§hlen und im Inspektor auf die Schaltfl√§che Fertighaus √∂ffnen klicken.  Sie k√∂nnen den vorgefertigten Bearbeitungsmodus verlassen, indem Sie auf die Schaltfl√§che mit einem Pfeil in der oberen linken Ecke der Hierarchie√ºberschrift klicken. </div></div><br>  Beachten Sie, dass die Kacheln selbst keine Spielobjekte sein m√ºssen.  Sie werden nur ben√∂tigt, um den Status des Feldes zu verfolgen.  Wir k√∂nnten den gleichen Ansatz wie f√ºr das Verhalten in der Tutorials-Reihe " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektverwaltung"</a> verwenden.  Aber in den fr√ºhen Stadien einfacher Spiele oder Prototypen von Spielobjekten sind wir ziemlich gl√ºcklich.  Dies kann in Zukunft ge√§ndert werden. <br><br><h3>  Wir haben Fliesen </h3><br>  Um Kacheln zu erstellen, muss das <code>GameBoard</code> einen Link zum Kachelfertigteil haben. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTile tilePrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/6c2/044/3636c204442368c58858152a7c3efee2.png"></div><br>  <i>Link zur Fertighauskachel.</i> <br><br>  Anschlie√üend kann er seine Instanzen mithilfe einer Doppelschleife √ºber zwei Rasterdimensionen erstellen.  Obwohl die Gr√∂√üe als X und Y ausgedr√ºckt wird, ordnen wir die Kacheln in der XZ-Ebene sowie im Feld selbst an.  Da das Feld relativ zum Ursprung zentriert ist, m√ºssen wir die entsprechende Gr√∂√üe minus eins geteilt durch zwei von den Komponenten der Kachelposition subtrahieren.  Bitte beachten Sie, dass dies eine Gleitkommadivision sein muss, da dies sonst bei geraden Gr√∂√üen nicht funktioniert. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2( (size.x - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, (size.y - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++) { GameTile tile = Instantiate(tilePrefab); tile.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); tile.transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( x - offset.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, y - offset.y ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/391/265/640/391265640fe99dd10be005de76ce93f3.png"></div><br>  <i>Instanzen von Kacheln erstellt.</i> <br><br>  Sp√§ter ben√∂tigen wir Zugriff auf diese Kacheln, damit wir sie in einem Array verfolgen k√∂nnen.  Wir brauchen keine Liste, da sich die Gr√∂√üe des Feldes nach der Initialisierung nicht √§ndert. <br><br><pre> <code class="cs hljs"> GameTile[] tiles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { GameTile tile = tiles[i] = Instantiate(tilePrefab); ‚Ä¶ } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wie funktioniert diese Aufgabe?</b> <div class="spoiler_text">  Dies ist eine verkn√ºpfte Aufgabe.  In diesem Fall bedeutet dies, dass wir sowohl dem Array-Element als auch der lokalen Variablen einen Link zur Kachelinstanz zuweisen.  Diese Vorg√§nge entsprechen dem unten gezeigten Code. <br><br><pre> <code class="cs hljs">GameTile t = Instantiate(tilePrefab); tiles[i] = t; GameTile tile = t;</code> </pre> </div></div><br><h2>  Suche nach einem Weg </h2><br>  Zu diesem Zeitpunkt hat jede Kachel einen Pfeil, aber alle zeigen in die positive Richtung der Z-Achse, die wir als Norden interpretieren werden.  Der n√§chste Schritt besteht darin, die richtige Richtung f√ºr die Kachel zu bestimmen.  Wir tun dies, indem wir den Weg finden, dem die Feinde bis zum Endpunkt folgen m√ºssen. <br><br><h3>  Fliesen Nachbarn </h3><br>  Die Wege verlaufen von Fliese zu Fliese im Norden, Osten, S√ºden oder Westen.  Um die Suche zu vereinfachen, <code>GameTile</code> Track-Links zu den vier Nachbarn. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west;</code> </pre> <br>  Die Beziehungen zwischen den Nachbarn sind symmetrisch.  Wenn das Pl√§ttchen der √∂stliche Nachbar des zweiten Pl√§ttchens ist, ist das zweite der westliche Nachbar des ersten Pl√§ttchens.  F√ºgen Sie <code>GameTile</code> eine allgemeine statische Methode <code>GameTile</code> , um diese Beziehung zwischen zwei Kacheln zu definieren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Warum eine statische Methode verwenden?</b> <div class="spoiler_text">  Wir k√∂nnen es zu einer Instanzmethode mit einem einzelnen Parameter machen, und in diesem Fall nennen wir es <code>eastTile.MakeEastWestNeighbors(westTile)</code> oder so √§hnlich.  In F√§llen, in denen nicht klar ist, auf welche Kacheln die Methode aufgerufen werden soll, ist es besser, statische Methoden zu verwenden.  Beispiele sind die <code>Distance</code> und <code>Dot</code> Methoden der <code>Vector3</code> Klasse. </div></div><br>  Einmal verbunden, sollte es sich nie √§ndern.  In diesem Fall haben wir einen Fehler im Code gemacht.  Sie k√∂nnen dies √ºberpr√ºfen, indem Sie beide Links vergleichen, bevor Sie <code>null</code> Werte zuweisen, und einen Fehler anzeigen, wenn dieser falsch ist.  Sie k√∂nnen hierf√ºr die <code>Debug.Assert</code> Methode verwenden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( west.east == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; east.west == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Was macht Debug.Assert?</b> <div class="spoiler_text">  Wenn das erste Argument <code>false</code> , wird ein Bedingungsfehler angezeigt, wobei das zweite Argument verwendet wird, wenn es angegeben ist.  Ein solcher Aufruf ist nur in Test-Builds enthalten, nicht jedoch in Release-Builds.  Daher ist dies eine gute M√∂glichkeit, w√§hrend des Entwicklungsprozesses √úberpr√ºfungen hinzuzuf√ºgen, die sich nicht auf die endg√ºltige Version auswirken. </div></div><br>  F√ºgen Sie eine √§hnliche Methode hinzu, um Beziehungen zwischen den n√∂rdlichen und s√ºdlichen Nachbarn herzustellen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeNorthSouthNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile north, GameTile south</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( south.north == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; north.south == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); south.north = north; north.south = south; }</code> </pre> <br>  Wir k√∂nnen diese Beziehung herstellen, wenn wir Kacheln in <code>GameBoard.Initialize</code> .  Wenn die X-Koordinate gr√∂√üer als Null ist, k√∂nnen wir eine Ost-West-Beziehung zwischen der aktuellen und der vorherigen Kachel herstellen.  Wenn die Y-Koordinate gr√∂√üer als Null ist, k√∂nnen wir eine Nord-S√ºd-Beziehung zwischen der aktuellen Kachel und der Kachel aus der vorherigen Zeile erstellen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeEastWestNeighbors(tile, tiles[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeNorthSouthNeighbors(tile, tiles[i - size.x]); } } }</code> </pre> <br>  Beachten Sie, dass die Kacheln an den Feldr√§ndern keine vier Nachbarn haben.  Ein oder zwei Nachbarreferenzen bleiben <code>null</code> . <br><br><h3>  Entfernung und Richtung </h3><br>  Wir werden nicht alle Feinde zwingen, st√§ndig nach dem Weg zu suchen.  Dies muss nur einmal pro Kachel durchgef√ºhrt werden.  Dann k√∂nnen die Feinde von dem Pl√§ttchen, auf dem sie sich befinden, anfordern, wohin sie sich bewegen m√∂chten.  Wir werden diese Informationen in <code>GameTile</code> speichern, indem wir einen Link zur n√§chsten <code>GameTile</code> hinzuf√ºgen.  Au√üerdem speichern wir die Entfernung zum Endpunkt, ausgedr√ºckt als Anzahl der Kacheln, die besucht werden m√ºssen, bevor der Feind den Endpunkt erreicht.  F√ºr Feinde sind diese Informationen nutzlos, aber wir werden sie verwenden, um die k√ºrzesten Wege zu finden. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west, nextOnPath; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br>  Jedes Mal, wenn wir entscheiden, dass wir nach Pfaden suchen m√ºssen, m√ºssen wir die Pfaddaten initialisieren.  Bis der Pfad gefunden ist, gibt es kein n√§chstes Pl√§ttchen und die Entfernung kann als unendlich angesehen werden.  Wir k√∂nnen uns dies als den maximal m√∂glichen ganzzahligen Wert von <code>int.MaxValue</code> .  F√ºgen Sie eine generische <code>ClearPath</code> Methode hinzu, um das <code>GameTile</code> auf diesen Status zur√ºckzusetzen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Pfade k√∂nnen nur durchsucht werden, wenn wir einen Endpunkt haben.  Dies bedeutet, dass die Kachel zum Endpunkt werden muss.  Eine solche Kachel hat einen Abstand von Null und nicht die letzte Kachel, da der Pfad darauf endet.  F√ºgen Sie eine generische Methode hinzu, die eine Kachel in einen Endpunkt verwandelt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Letztendlich sollten sich alle Kacheln in einen Pfad verwandeln, damit ihre Entfernung nicht mehr <code>int.MaxValue</code> .  F√ºgen Sie eine praktische Getter-Eigenschaft hinzu, um zu √ºberpr√ºfen, ob die Kachel derzeit einen Pfad hat. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath =&gt; distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wie funktioniert diese Eigenschaft?</b> <div class="spoiler_text">  Dies ist ein verk√ºrzter Eintrag f√ºr eine Getter-Eigenschaft, die nur einen Ausdruck enth√§lt.  Dies entspricht dem unten gezeigten Code. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } }</code> </pre> <br>  Der Pfeiloperator <code>=&gt;</code> kann auch einzeln f√ºr den Getter und Setter von Eigenschaften, f√ºr die K√∂rper von Methoden, Konstruktoren und an einigen anderen Stellen verwendet werden. </div></div><br><h3>  Wir wachsen einen Weg </h3><br>  Wenn wir ein Pl√§ttchen mit einem Pfad haben, k√∂nnen wir es einen Pfad zu einem seiner Nachbarn wachsen lassen.  Anf√§nglich ist das einzige Pl√§ttchen mit dem Pfad der Endpunkt. Wir beginnen also bei Null und erh√∂hen ihn von hier aus, wobei wir uns in die entgegengesetzte Richtung zur Bewegung der Feinde bewegen.  Das hei√üt, alle unmittelbaren Nachbarn des Endpunkts haben einen Abstand von 1, und alle Nachbarn dieser Kacheln haben einen Abstand von 2 usw. <br><br>  F√ºgen Sie eine versteckte <code>GameTile</code> Methode hinzu, um den Pfad zu einem seiner Nachbarn zu vergr√∂√üern, der √ºber den Parameter angegeben wird.  Die Entfernung zum Nachbarn ist eins mehr als die aktuelle Kachel, und der Pfad des Nachbarn gibt die aktuelle Kachel an.  Diese Methode sollte nur f√ºr Kacheln aufgerufen werden, die bereits einen Pfad haben. √úberpr√ºfen wir dies also mit assert. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  Die Idee ist, dass wir diese Methode einmal f√ºr jeden der vier Nachbarn der Kachel aufrufen.  Da einige dieser Links <code>null</code> , √ºberpr√ºfen wir dies und stoppen gegebenenfalls die Ausf√ºhrung.  Wenn ein Nachbar bereits einen Pfad hat, sollten wir au√üerdem nichts tun und auch damit aufh√∂ren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  Die Art <code>GameTile</code> Weise, wie <code>GameTile</code> seine Nachbarn verfolgt, ist dem Rest des Codes unbekannt.  Daher ist <code>GrowPathTo</code> ausgeblendet.  Wir werden allgemeine Methoden hinzuf√ºgen, die die Kachel <code>GrowPathTo</code> ihren Pfad in eine bestimmte Richtung zu erweitern, indem <code>GrowPathTo</code> indirekt <code>GrowPathTo</code> aufrufen.  Der Code, der im gesamten Feld sucht, sollte jedoch verfolgen, welche Kacheln besucht wurden.  Daher wird es einen Nachbarn oder <code>null</code> wenn die Ausf√ºhrung beendet wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor; }</code> </pre> <br>  F√ºgen Sie nun Methoden zum Wachsen von Pfaden in bestimmte Richtungen hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west);</code> </pre> <br><h3>  Breite Suche </h3><br>  <code>GameBoard</code> muss <code>GameBoard</code> dass alle Kacheln die richtigen <code>GameBoard</code> enthalten.  Wir tun dies, indem wir eine Breitensuche durchf√ºhren.  Beginnen wir mit der Endpunktkachel und erweitern dann den Pfad zu den Nachbarn, dann zu den Nachbarn dieser Kacheln und so weiter.  Mit jedem Schritt erh√∂ht sich der Abstand um eins, und die Pfade wachsen nie in Richtung der Kacheln, die bereits Pfade haben.  Dadurch wird sichergestellt, dass alle Kacheln auf dem k√ºrzesten Weg zum Endpunkt zeigen. <br><br><div class="spoiler">  <b class="spoiler_title">Was ist mit einem Pfad mit A *?</b> <div class="spoiler_text">  Der A <sup>*</sup> -Algorithmus ist die evolution√§re Entwicklung der Breitensuche.  Es ist n√ºtzlich, wenn wir nach dem einzig k√ºrzesten Weg suchen.  Wir brauchen aber die k√ºrzesten Wege, deshalb bietet A <sup>*</sup> keine Vorteile.  Beispiele f√ºr die Breitensuche und A <sup>*</sup> in einem Sechseckraster mit Animation finden Sie in der Reihe von Tutorials zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sechseckkarten</a> . </div></div><br>  Um die Suche durchzuf√ºhren, m√ºssen wir die Kacheln verfolgen, die wir dem Pfad hinzugef√ºgt haben, von denen wir den Pfad jedoch noch nicht vergr√∂√üert haben.  Diese Sammlung von Kacheln wird oft als Suchgrenze bezeichnet.  Es ist wichtig, dass die Kacheln in derselben Reihenfolge verarbeitet werden, in der sie dem Rahmen hinzugef√ºgt werden. Verwenden Sie daher die <code>Queue</code> .  Sp√§ter m√ºssen wir die Suche mehrmals durchf√ºhren, also legen wir sie als Feld des <code>GameBoard</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ Queue&lt;GameTile&gt; searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;GameTile&gt;(); ‚Ä¶ }</code> </pre> <br>  Damit der Status des Spielfelds immer wahr ist, m√ºssen wir die Pfade am Ende von <code>Initialize</code> , aber den Code in eine separate <code>FindPaths</code> Methode <code>FindPaths</code> .  Zuerst m√ºssen Sie den Pfad aller Kacheln l√∂schen, dann eine Kachel zum Endpunkt machen und sie dem Rand hinzuf√ºgen.  Lassen Sie uns zuerst die erste Kachel ausw√§hlen.  Da <code>tiles</code> ein Array sind, k√∂nnen wir die <code>foreach</code> ohne Angst vor Speicherverschmutzung zu haben.  Wenn wir sp√§ter von einem Array zu einer Liste wechseln, m√ºssen wir auch die <code>foreach</code> Schleifen durch <code>for</code> Schleifen ersetzen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ FindPaths(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Als n√§chstes m√ºssen wir ein Pl√§ttchen von der Grenze nehmen und einen Pfad zu allen Nachbarn aufbauen und sie alle zur Grenze hinzuf√ºgen.  Zuerst ziehen wir nach Norden, dann nach Osten, S√ºden und schlie√ülich nach Westen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Wir wiederholen diese Phase, w√§hrend sich Kacheln in der Grenze befinden. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Das Wachsen eines Pfades f√ºhrt uns nicht immer zu einem neuen Pl√§ttchen.  Vor dem Hinzuf√ºgen zur Warteschlange m√ºssen wir den Wert auf <code>null</code> pr√ºfen, aber wir k√∂nnen die Pr√ºfung auf <code>null</code> bis nach der Ausgabe aus der Warteschlange verschieben. <br><br><pre> <code class="cs hljs"> GameTile tile = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br><h3>  Zeigen Sie die Pfade an </h3><br>  Jetzt haben wir ein Feld mit den richtigen Pfaden, aber bisher sehen wir dies nicht.  Sie m√ºssen die Pfeile so konfigurieren, dass sie entlang des Pfads durch ihre Kacheln zeigen.  Dies kann durch Drehen erfolgen.  Da diese <code>GameTile</code> immer gleich sind, f√ºgen wir dem <code>GameTile</code> ein statisches <code>Quaternion</code> Feld f√ºr jede der Richtungen hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion northRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), eastRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), southRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), westRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>);</code> </pre> <br>  <code>ShowPath</code> auch die allgemeine <code>ShowPath</code> Methode hinzu.  Wenn der Abstand Null ist, ist die Kachel der Endpunkt und es gibt nichts, auf das Sie zeigen k√∂nnen. Deaktivieren Sie daher den Pfeil.  Andernfalls aktivieren Sie den Pfeil und stellen Sie seine Drehung ein.  Die gew√ºnschte Richtung kann durch Vergleichen von <code>nextOnPath</code> mit seinen Nachbarn bestimmt werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance == <span class="hljs-number"><span class="hljs-number">0</span></span>) { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); arrow.localRotation = nextOnPath == north ? northRotation : nextOnPath == east ? eastRotation : nextOnPath == south ? southRotation : westRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie diese Methode am Ende f√ºr alle Kacheln auf </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/4fe/4d5/b2d4fe4d511b4e729910ea78b267f268.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wege gefunden.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum verwandeln wir den Pfeil nicht direkt in GrowPathTo?</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trennung der Logik und Visualisierung der Suche. </font><font style="vertical-align: inherit;">Sp√§ter werden wir die Visualisierung deaktivieren. </font><font style="vertical-align: inherit;">Wenn die Pfeile nicht angezeigt werden, m√ºssen wir sie nicht jedes Mal drehen, wenn wir anrufen </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suchpriorit√§t √§ndern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellt sich heraus, dass, wenn der Endpunkt die s√ºdwestliche Ecke ist, alle Pfade genau nach Westen verlaufen, bis sie den Rand des Feldes erreichen, wonach sie nach S√ºden abbiegen. </font><font style="vertical-align: inherit;">Hier stimmt alles, denn es gibt wirklich keine k√ºrzeren Wege zum Endpunkt, weil diagonale Bewegungen unm√∂glich sind. </font><font style="vertical-align: inherit;">Es gibt jedoch viele andere k√ºrzeste Wege, die sch√∂ner aussehen k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um besser zu verstehen, warum solche Pfade gefunden werden, verschieben Sie den Endpunkt in die Mitte der Karte. </font><font style="vertical-align: inherit;">Bei einer ungeraden Feldgr√∂√üe ist es nur eine Kachel in der Mitte des Arrays.</font></font><br><br><pre> <code class="cs hljs"> tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d3/d09/d78/6d3d09d7844fbe6a4aaf4618449598de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endpunkt in der Mitte.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Ergebnis erscheint logisch, wenn Sie sich daran erinnern, wie die Suche funktioniert. Da wir Nachbarn in der Nordost-S√ºdwest-Ordnung hinzuf√ºgen, hat der Norden die h√∂chste Priorit√§t. Da wir die Suche in umgekehrter Reihenfolge durchf√ºhren, bedeutet dies, dass wir zuletzt nach S√ºden gefahren sind. Deshalb zeigen nur wenige Pfeile nach S√ºden und viele nach Osten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen das Ergebnis √§ndern, indem Sie die Priorit√§ten der Anweisungen festlegen. Lassen Sie uns nach Osten und S√ºden tauschen. Wir m√ºssen also die Nord-S√ºd- und Ost-West-Symmetrie erhalten.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest())</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/2c7/0b7/a9a2c70b7d7d178b041f30c11d256ad3.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Suchreihenfolge ist Nord-S√ºd-Ost-West. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sieht h√ºbscher aus, aber es ist besser, wenn die Wege ihre Richtung √§ndern und sich einer diagonalen Bewegung n√§hern, bei der es nat√ºrlich aussieht. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies tun, indem wir die Suchpriorit√§ten benachbarter Kacheln in einem Schachbrettmuster umkehren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt herauszufinden, welche Art von Kachel wir w√§hrend der Suche verarbeiten, f√ºgen wir der </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Eigenschaft hinzu, die angibt, ob die aktuelle Kachel eine Alternative ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsAlternative { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Eigenschaft in setzen </font></font><code>GameBoard.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Markieren Sie zuerst die Kacheln als Alternative, wenn ihre X-Koordinate gerade ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht die Operation (x &amp; 1) == 0?</font></font></b> <div class="spoiler_text">   ‚Äî     (AND).            .       1,       1.  10101010  00001111   00001010. <br><br>       .      0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,       . <br><br>    AND  ,  ,    .    ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens √§ndern wir das Vorzeichen des Ergebnisses, wenn ihre Y-Koordinate gerade ist. </font><font style="vertical-align: inherit;">Also werden wir ein Schachmuster erstellen.</font></font><br><br><pre> <code class="cs hljs"> tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((y &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { tile.IsAlternative = !tile.IsAlternative; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir die gleiche Reihenfolge wie die Suche nach alternativer Kachel halten, aber es zur√ºck zu allen anderen Fliesen zu machen. </font><font style="vertical-align: inherit;">Dies erzwingt den Weg zur diagonalen Bewegung und erzeugt Zickzackbewegungen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.IsAlternative) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Enqueue(tile.GrowPathWest()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathNorth()); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b43/e3a/d63/b43e3ad6370a6b552073b4f0b4cf0e8b.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable Suchreihenfolge.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fliesen wechseln </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt sind alle Kacheln leer. </font><font style="vertical-align: inherit;">Eine Kachel wird als Endpunkt verwendet, aber zus√§tzlich zum Fehlen eines sichtbaren Pfeils sieht sie genauso aus wie alle anderen. </font><font style="vertical-align: inherit;">Wir werden die M√∂glichkeit hinzuf√ºgen, Kacheln zu √§ndern, indem wir Objekte darauf platzieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kachelinhalt </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kachelobjekte selbst sind einfach eine M√∂glichkeit, Kachelinformationen zu verfolgen. </font><font style="vertical-align: inherit;">Wir √§ndern diese Objekte nicht direkt. </font><font style="vertical-align: inherit;">F√ºgen Sie stattdessen separaten Inhalt hinzu und platzieren Sie ihn auf dem Feld. </font><font style="vertical-align: inherit;">Im Moment k√∂nnen wir zwischen leeren Kacheln und Endpunktkacheln unterscheiden. </font><font style="vertical-align: inherit;">Erstellen Sie eine Aufz√§hlung, um diese F√§lle anzuzeigen </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie als N√§chstes einen Komponententyp </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem Sie den Inhaltstyp √ºber den Inspektor festlegen k√∂nnen. Der Zugriff darauf erfolgt √ºber eine gemeinsame Getter-Eigenschaft.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] GameTileContentType type = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentType Type =&gt; type; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anschlie√üend erstellen wir Fertigh√§user f√ºr zwei Inhaltstypen, von denen jeder eine Komponente </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem entsprechenden angegebenen Typ enth√§lt. </font><font style="vertical-align: inherit;">Verwenden wir einen blau abgeflachten W√ºrfel, um Endpunktkacheln zu bestimmen. </font><font style="vertical-align: inherit;">Da es fast flach ist, braucht er keinen Collider. </font><font style="vertical-align: inherit;">Verwenden Sie ein leeres Spielobjekt, um leere Inhalte vorzufertigen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f55/25d/8db/f5525d8db707ff187e17ce96a11d86ae.png" width="320" height="262" alt="Ziel"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/463/e19/c6f463e198abca6134b7bc74d3207833.png" width="320" height="176" alt="leer"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertigh√§user des Endpunkts und leerer Inhalte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir geben das Inhaltsobjekt an die leeren Kacheln weiter, da dann alle Kacheln immer den Inhalt haben, was bedeutet, dass wir die Links zu den Inhalten nicht auf Gleichheit √ºberpr√ºfen m√ºssen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhaltsfabrik </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Inhalt bearbeitbar zu machen, erstellen wir hierf√ºr auch eine Factory, die denselben Ansatz wie im Tutorial zur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objektverwaltung verwendet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sie </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den √úberblick √ºber Ihre urspr√ºngliche Fabrik behalten m√ºssen, die nur einmal eingestellt werden sollte, und sich in der Methode an die Fabrik zur√ºcksenden m√ºssen </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory originFactory; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies setzt die Existenz voraus </font></font><code>GameTileContentFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, daher erstellen wir daf√ºr einen skriptf√§higen Objekttyp mit der erforderlichen Methode </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In dieser Phase werden wir uns nicht mit der Schaffung einer voll funktionsf√§higen Fabrik befassen, die den Inhalt nutzt, also werden wir daf√ºr sorgen, dass der Inhalt einfach zerst√∂rt wird. </font><font style="vertical-align: inherit;">Sp√§ter ist es m√∂glich, die Wiederverwendung von Objekten zur Fabrik hinzuzuf√ºgen, ohne den Rest des Codes zu √§ndern.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent content</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(content.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(content.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Factory eine versteckte Methode </font><font style="vertical-align: inherit;">mit einem Fertighaus als Parameter hinzu. </font><font style="vertical-align: inherit;">Hier √ºberspringen wir wieder die Wiederverwendung von Objekten. </font><font style="vertical-align: inherit;">Er erstellt eine Instanz des Objekts, legt seine urspr√ºngliche Fabrik fest, verschiebt es in die Fabrikszene und gibt es zur√ºck.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent prefab</span></span></span><span class="hljs-function">)</span></span> { GameTileContent instance = Instantiate(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; MoveToFactoryScene(instance.gameObject); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Instanz wurde in die Factory-Content-Szene verschoben, die bei Bedarf erstellt werden kann. </font><font style="vertical-align: inherit;">Wenn wir uns im Editor befinden, m√ºssen wir vor dem Erstellen einer Szene √ºberpr√ºfen, ob sie vorhanden ist, falls wir sie w√§hrend eines hei√üen Neustarts aus den Augen verlieren.</font></font><br><br><pre> <code class="cs hljs"> Scene contentScene; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveToFactoryScene</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { contentScene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { contentScene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentScene = SceneManager.CreateScene(name); } } SceneManager.MoveGameObjectToScene(o, contentScene); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir haben nur zwei Arten von Inhalten, also f√ºgen Sie einfach zwei vorgefertigte Konfigurationsfelder f√ºr sie hinzu. </font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent destinationPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] GameTileContent emptyPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Letzte, was getan werden muss, damit die Factory funktioniert, ist das Erstellen einer allgemeinen Methode </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Parameter </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der eine Instanz des entsprechenden Fertighauses empf√§ngt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es obligatorisch, jeder Kachel eine separate Instanz leeren Inhalts hinzuzuf√ºgen?</font></font></b> <div class="spoiler_text">       ,               .         .  ,        - , , , ,    .     ,       .     ,        ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lassen Sie uns ein Factory-Asset erstellen und seine Links zu Fertigh√§usern konfigurieren. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7eb/75f/1cd/7eb75f1cd4bed3c72ffd7f0c42b69cbe.png" width="320" height="106"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhaltsfabrik </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und dann den </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zur Fabrik weitergeben.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContentFactory tileContentFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/d6a/506/b12d6a5067fa91177dbed14a876f8b3d.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spiel mit einer Fabrik.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine Fliese antippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Feld zu √§ndern, m√ºssen wir in der Lage sein, eine Kachel auszuw√§hlen. Wir werden es im Spielemodus erm√∂glichen. Wir werden einen Strahl in die Szene an der Stelle senden, an der der Spieler auf das Spielfenster geklickt hat. Wenn sich der Strahl mit dem Pl√§ttchen schneidet, hat der Spieler es ber√ºhrt, dh es muss ge√§ndert werden. </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºbernimmt die Eingabe des Spielers, ist jedoch daf√ºr verantwortlich zu bestimmen, welches Pl√§ttchen der Spieler ber√ºhrt hat </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht alle Strahlen schneiden sich mit der Kachel, daher erhalten wir manchmal nichts. Daher f√ºgen wir der </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode hinzu </font></font><code>GetTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die immer immer anf√§nglich zur√ºckgibt </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dies bedeutet, dass die Kachel nicht gefunden wurde).</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um festzustellen, ob ein Strahl eine Kachel √ºberschritten hat, m√ºssen wir </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Strahl als Argument angeben. </font><font style="vertical-align: inherit;">Es gibt Informationen dar√ºber zur√ºck, ob es eine Kreuzung gab. </font><font style="vertical-align: inherit;">Wenn ja, k√∂nnen wir die Kachel zur√ºckgeben, obwohl wir noch nicht wissen, welche, also werden wir sie vorerst zur√ºckgeben </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryGetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um herauszufinden, ob es eine Kreuzung mit einer Kachel gab, ben√∂tigen wir weitere Informationen √ºber die Kreuzung. </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann diese Informationen mit dem zweiten Parameter bereitstellen </font></font><code>RaycastHit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist der Ausgabeparameter, der durch das Wort </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">davor </font><font style="vertical-align: inherit;">angezeigt wird </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies bedeutet, dass ein Methodenaufruf der Variablen, die wir an sie √ºbergeben, einen Wert zuweisen kann.</font></font><br><br><pre> <code class="cs hljs"> RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir k√∂nnen die Deklaration der Variablen einbetten, die f√ºr die Ausgabeparameter verwendet werden. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist uns egal, mit welchem ‚Äã‚ÄãCollider die Kreuzung aufgetreten ist, wir verwenden nur die XZ-Kreuzungsposition, um die Kachel zu bestimmen. </font><font style="vertical-align: inherit;">Wir erhalten die Koordinaten der Kachel, indem wir den Koordinaten des Schnittpunkts die halbe Gr√∂√üe des Feldes hinzuf√ºgen und dann die Ergebnisse in ganzzahlige Werte konvertieren. </font><font style="vertical-align: inherit;">Der endg√ºltige Kachelindex ist die X-Koordinate plus die Y-Koordinate multipliziert mit der Feldbreite.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist jedoch nur m√∂glich, wenn die Koordinaten der Kachel innerhalb des Feldes liegen. Wir werden dies √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Ist dies nicht der Fall, wird die Kachel nicht zur√ºckgegeben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; size.x &amp;&amp; y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y &lt; size.y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhalts√§nderung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Eigenschaft </font><font style="vertical-align: inherit;">hinzu, damit Sie den Inhalt der Kachel √§ndern k√∂nnen </font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sein Getter gibt einfach den Inhalt zur√ºck, und der Setter verwirft den vorherigen Inhalt, falls vorhanden, und platziert den neuen Inhalt.</font></font><br><br><pre> <code class="cs hljs"> GameTileContent content; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContent Content { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; content; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { content.Recycle(); } content = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; content.transform.localPosition = transform.localPosition; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist der einzige Ort, an dem Sie den Inhalt √ºberpr√ºfen m√ºssen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da wir anfangs keinen Inhalt haben. </font><font style="vertical-align: inherit;">Um dies zu gew√§hrleisten, f√ºhren wir assert aus, damit der Setter nicht mit aufgerufen wird </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Null assigned to content!"</span></span>); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und schlie√ülich brauchen wir eine Spielereingabe. </font><font style="vertical-align: inherit;">Das Konvertieren eines Mausklicks in einen Strahl kann durch Aufrufen </font></font><code>ScreenPointToRay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit </font></font><code>Input.mousePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Argument erfolgen. </font><font style="vertical-align: inherit;">Der Anruf muss f√ºr die Hauptkamera get√§tigt werden, auf die √ºber zugegriffen werden kann </font></font><code>Camera.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu die Eigenschaft c hinzu </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> Ray TouchRay =&gt; Camera.main.ScreenPointToRay(Input.mousePosition);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anschlie√üend f√ºgen wir eine Methode hinzu </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit der √ºberpr√ºft wird, ob w√§hrend des Upgrades die Hauptmaus-Taste gedr√ºckt wurde. </font><font style="vertical-align: inherit;">Rufen Sie dazu </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit Null als Argument auf. </font><font style="vertical-align: inherit;">Wenn die Taste gedr√ºckt wurde, verarbeiten wir die Ber√ºhrung des Spielers, dh wir nehmen das Pl√§ttchen vom Feld und legen den Endpunkt als Inhalt fest, wobei wir es ab Werk nehmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { tile.Content = tileContentFactory.Get(GameTileContentType.Destination); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen wir jede Kachel durch Dr√ºcken des Cursors in einen Endpunkt verwandeln. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/f15/da3/99af15da39bfc08cb8886b98e0ae15df.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrere Endpunkte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld richtig machen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir Kacheln in Endpunkte verwandeln k√∂nnen, hat dies bisher keine Auswirkungen auf die Pfade. </font><font style="vertical-align: inherit;">Au√üerdem haben wir noch keinen leeren Inhalt f√ºr Kacheln festgelegt. </font><font style="vertical-align: inherit;">Die Richtigkeit und Integrit√§t des Feldes zu wahren </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">ist eine Aufgabe </font><font style="vertical-align: inherit;">. Geben wir ihm also die Verantwortung, den Inhalt der Kachel festzulegen. </font><font style="vertical-align: inherit;">Um dies zu implementieren, geben wir ihm √ºber seine Methode einen Link zur Content Factory </font></font><code>Intialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verwenden ihn, um allen Kacheln eine Instanz leeren Inhalts zu geben.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory contentFactory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contentFactory = contentFactory; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ tile.Content = contentFactory.Get(GameTileContentType.Empty); } } FindPaths(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt muss ich </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meine Fabrik auf das Feld verlegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht ein Game Factory-Feld zum GameBoard hinzuf√ºgen?</font></font></b> <div class="spoiler_text">   ,    ,   .        ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir jetzt mehrere Endpunkte haben, √§ndern wir diese </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass sie </font></font><code>BecomeDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jeweils aufgerufen werden und alle an der Grenze hinzugef√ºgt werden. </font><font style="vertical-align: inherit;">Und das ist alles, was Sie brauchen, um mehrere Endpunkte zu unterst√ºtzen. </font><font style="vertical-align: inherit;">Alle anderen Kacheln werden wie gewohnt gel√∂scht. </font><font style="vertical-align: inherit;">Dann l√∂schen wir den fest eingestellten Endpunkt in der Mitte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.BecomeDestination(); searchFrontier.Enqueue(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.ClearPath(); } } <span class="hljs-comment"><span class="hljs-comment">//tiles[tiles.Length / 2].BecomeDestination(); //searchFrontier.Enqueue(tiles[tiles.Length / 2]); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jedoch Kacheln in Endpunkte verwandeln k√∂nnen, sollten wir in der Lage sein, den umgekehrten Vorgang auszuf√ºhren und Endpunkte in leere Kacheln umzuwandeln. </font><font style="vertical-align: inherit;">Aber dann k√∂nnen wir ein Feld ohne Endpunkte bekommen. </font><font style="vertical-align: inherit;">In diesem Fall kann </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seine Aufgabe nicht ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">Dies geschieht, wenn der Rand nach der Pfadinitialisierung f√ºr alle Zellen leer ist. </font><font style="vertical-align: inherit;">Wir bezeichnen dies als einen ung√ºltigen Zustand des Feldes, </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der die Ausf√ºhrung </font><font style="vertical-align: inherit;">zur√ºckgibt </font><font style="vertical-align: inherit;">und abschlie√üt. </font><font style="vertical-align: inherit;">Andernfalls kehren Sie am Ende zur√ºck </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg, Unterst√ºtzung f√ºr das Entfernen von Endpunkten zu implementieren, sodass es sich um eine Switch-Operation handelt. Durch Klicken auf die leeren Kacheln werden sie in Endpunkte umgewandelt, und durch Klicken auf die Endpunkte werden sie gel√∂scht. Jetzt wird der Inhalt ge√§ndert </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und wir geben ihm eine allgemeine Methode, </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deren Parameter die Kachel ist. Wenn die Kachel der Endpunkt ist, machen Sie sie leer und rufen Sie auf </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ansonsten machen wir es zum Endpunkt und nennen es auch </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hinzuf√ºgen eines Endpunkts kann niemals einen ung√ºltigen Feldstatus erzeugen, und das L√∂schen eines Endpunkts kann dies. </font><font style="vertical-align: inherit;">Daher werden wir pr√ºfen, ob die Ausf√ºhrung erfolgreich war, </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nachdem wir die Kachel leer gemacht haben. </font><font style="vertical-align: inherit;">Wenn nicht, brechen Sie die √Ñnderung ab, drehen Sie die Kachel zur√ºck zum Endpunkt und rufen Sie erneut </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf, um zum vorherigen korrekten Status zur√ºckzukehren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann die Validierung effizienter gestaltet werden?</font></font></b> <div class="spoiler_text">      ,      .           ,   .  ,          .        <code>FindPaths</code> ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen wir </font><font style="vertical-align: inherit;">am Ende </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit der zentralen Kachel als Argument aufrufen, anstatt explizit aufzurufen </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist das einzige Mal, dass wir mit einem ung√ºltigen Feldstatus beginnen, aber wir werden garantiert mit dem richtigen Status enden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//FindPaths(); ToggleDestination(tiles[tiles.Length / 2]); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich erzwingen wir den </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufruf, </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anstatt den Inhalt der Kachel selbst festzulegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tile.Content = //tileContentFactory.Get(GameTileContentType.Destination); board.ToggleDestination(tile); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/685/8a9/8326858a93b938353376ff97259df1a7.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrere Endpunkte mit korrekten Pfaden.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sollten wir Game nicht verbieten, den Inhalt der Kachel direkt festzulegen?</font></font></b> <div class="spoiler_text">   .       .       ,   <code>Game</code>             .    ,      . </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die W√§nde </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ziel der Turmverteidigung ist es, zu verhindern, dass Feinde den Endpunkt erreichen. </font><font style="vertical-align: inherit;">Dieses Ziel wird auf zwei Arten erreicht. </font><font style="vertical-align: inherit;">Erstens t√∂ten wir sie und zweitens verlangsamen wir sie, damit mehr Zeit bleibt, sie zu t√∂ten. </font><font style="vertical-align: inherit;">Auf dem Kachelfeld kann die Zeit verl√§ngert werden, wodurch sich die Entfernung erh√∂ht, die Feinde ben√∂tigen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem Hindernisse auf dem Feld platziert werden. </font><font style="vertical-align: inherit;">Normalerweise sind dies T√ºrme, die auch Feinde t√∂ten, aber in diesem Tutorial beschr√§nken wir uns nur auf Mauern.</font></font><br><br><h3>  Inhalt </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde sind eine andere Art von Inhalten. F√ºgen wir </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ihnen also ein Element hinzu.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie dann das Wandfertigteil. </font><font style="vertical-align: inherit;">Dieses Mal erstellen wir ein Spielobjekt mit dem Inhalt der Kachel und f√ºgen einen untergeordneten W√ºrfel hinzu, der sich oben auf dem Feld befindet und die gesamte Kachel ausf√ºllt. </font><font style="vertical-align: inherit;">Machen Sie es eine halbe Einheit hoch und speichern Sie den Collider, da die W√§nde einen Teil der dahinter liegenden Fliesen optisch √ºberlappen k√∂nnen. </font><font style="vertical-align: inherit;">Wenn ein Spieler eine Wand ber√ºhrt, beeinflusst er daher das entsprechende Pl√§ttchen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a33/779/1d3a33779b0c4d49f8ab4fed3d8abd20.png" width="320" height="176" alt="Wurzel"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/b5c/9f6/431b5c9f65000bab15dd9e1eed14696d.png" width="320" height="226" alt="W√ºrfel"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6b/875/3b2/e6b8753b2e9b954b55a4a3a6e0154560.png" width="225" height="60" alt="Fertighaus"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighaus. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie das Wandfertigteil sowohl im Code als auch im Inspektor zur Fabrik hinzu.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent wallPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/eaa/50f/262eaa50f1bf4f80b2d2861d6232368b.png" width="320" height="80"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabrik mit vorgefertigter Wand.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> W√§nde ein- und ausschalten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Ein / Aus-Methode der W√§nde hinzu, wie wir es f√ºr den Endpunkt getan haben. </font><font style="vertical-align: inherit;">Zun√§chst werden wir den falschen Status des Feldes nicht √ºberpr√ºfen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Wall); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bieten Unterst√ºtzung f√ºr das Umschalten nur zwischen leeren Kacheln und Wandkacheln, sodass W√§nde Endpunkte nicht direkt ersetzen k√∂nnen. </font><font style="vertical-align: inherit;">Daher erstellen wir nur dann eine Wand, wenn die Kachel leer ist. </font><font style="vertical-align: inherit;">Au√üerdem sollten die W√§nde die Suche nach dem Pfad blockieren. </font><font style="vertical-align: inherit;">Aber jedes Pl√§ttchen muss einen Pfad zum Endpunkt haben, sonst bleiben die Feinde stecken. </font><font style="vertical-align: inherit;">Dazu m√ºssen wir erneut die Validierung verwenden </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die √Ñnderungen verwerfen, wenn sie einen falschen Feldstatus erstellt haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Wall); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ein- und Ausschalten von W√§nden wird viel h√§ufiger verwendet als das Ein- und Ausschalten von Endpunkten. Daher werden wir das Umschalten von W√§nden zum </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptanliegen machen. </font><font style="vertical-align: inherit;">Die Endpunkte k√∂nnen durch eine zus√§tzliche Ber√ºhrung (normalerweise die rechte Maustaste) umgeschaltet werden, die durch √úbergabe an einen </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert von 1 </font><font style="vertical-align: inherit;">erkannt werden kann </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { HandleAlternativeTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleDestination(tile); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleWall(tile); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d62/e45/4e9/d62e454e94a659dd9da841a915a93dac.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir die W√§nde.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum bekomme ich gro√üe L√ºcken zwischen den Schatten diagonal benachbarter W√§nde?</font></font></b> <div class="spoiler_text">  ,          ,    ,   .   ,   ,  far clipping plane      . ,   far plane  20      .  ,         MSAA,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen wir au√üerdem sicher, dass Endpunkte W√§nde nicht direkt ersetzen k√∂nnen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pfadsuchensperre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die W√§nde die Suche nach dem Pfad blockieren, m√ºssen wir dem Suchrahmen keine Kacheln mit W√§nden hinzuf√ºgen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem gezwungen wird, </font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keine Fliesen mit W√§nden zur√ºckzugeben. </font><font style="vertical-align: inherit;">Der Pfad sollte jedoch immer noch in Richtung der Wand wachsen, damit alle Kacheln auf dem Feld einen Pfad haben. </font><font style="vertical-align: inherit;">Dies ist notwendig, da es m√∂glich ist, dass ein Pl√§ttchen mit Feinden pl√∂tzlich zu einer Wand wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen, dass alle Kacheln einen Pfad haben, </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√ºssen </font><font style="vertical-align: inherit;">sie </font><font style="vertical-align: inherit;">diesen nach Abschluss der Suche √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Ist dies nicht der Fall, ist der Status des Feldes ung√ºltig und muss zur√ºckgegeben werden </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es ist nicht erforderlich, die Pfadvisualisierung f√ºr ung√ºltige Zust√§nde zu aktualisieren, da das Feld zum vorherigen Zustand zur√ºckkehrt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tile.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/ff2/c3e/cc3ff2c3e52a087d9fa757d5760623d6.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§nde beeinflussen den Weg. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen, dass die W√§nde tats√§chlich die richtigen Wege haben, m√ºssen Sie die W√ºrfel durchscheinend machen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9b/2f6/70c/d9b2f670c9bcf0fc568c1484750c2e77.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transparente W√§nde. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass das Erfordernis der Richtigkeit aller Pfade nicht zul√§sst, dass W√§nde einen Teil des Feldes einschlie√üen, in dem es keinen Endpunkt gibt. </font><font style="vertical-align: inherit;">Wir k√∂nnen die Karte teilen, aber nur, wenn in jedem Teil mindestens ein Endpunkt vorhanden ist. </font><font style="vertical-align: inherit;">Au√üerdem muss jede Wand an eine leere Kachel oder einen leeren Endpunkt angrenzen, da sie sonst keinen Pfad haben kann. </font><font style="vertical-align: inherit;">Zum Beispiel ist es unm√∂glich, einen festen Block aus 3 √ó 3 W√§nden herzustellen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versteck den Weg </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch die Visualisierung der Pfade k√∂nnen wir sehen, wie die Pfadsuche funktioniert, und sicherstellen, dass sie tats√§chlich korrekt ist. </font><font style="vertical-align: inherit;">Aber es muss dem Spieler nicht gezeigt werden oder zumindest nicht unbedingt. </font><font style="vertical-align: inherit;">Lassen Sie uns daher die M√∂glichkeit bieten, die Pfeile auszuschalten. </font><font style="vertical-align: inherit;">Dies kann durch Hinzuf√ºgen zur </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Methode erfolgen </font></font><code>HidePath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bei der der Pfeil einfach deaktiviert wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HidePath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Pfadzuordnungsstatus ist Teil des Feldstatus. </font><font style="vertical-align: inherit;">F√ºgen Sie </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Standard </font><font style="vertical-align: inherit;">ein </font><font style="vertical-align: inherit;">boolesches Feld hinzu, das </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Status entspricht, sowie eine gemeinsame Eigenschaft als Getter und Setter. </font><font style="vertical-align: inherit;">Der Setter muss Pfade auf allen Kacheln ein- oder ausblenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowPaths { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showPaths; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showPaths = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.HidePath(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sollte die Methode </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur dann aktualisierte Pfade anzeigen, wenn das Rendern aktiviert ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardm√§√üig ist die Pfadvisualisierung deaktiviert. </font><font style="vertical-align: inherit;">Schalten Sie den Pfeil in der Kachelfertigung aus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5a/c71/802/a5ac718028d1bb41c145dfabba9051e1.png" width="320" height="44"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Fertighauspfeil ist standardm√§√üig inaktiv. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen es so, dass es </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Visualisierungsstatus √§ndert, wenn eine Taste gedr√ºckt wird. </font><font style="vertical-align: inherit;">Es w√§re logisch, die P-Taste zu verwenden, aber es ist auch ein Hotkey zum Aktivieren / Deaktivieren des Spielemodus im Unity-Editor. </font><font style="vertical-align: inherit;">Infolgedessen wechselt die Visualisierung, wenn der Hotkey zum Verlassen des Spielemodus verwendet wird, was nicht sehr gut aussieht. </font><font style="vertical-align: inherit;">Verwenden wir also die V-Taste (kurz f√ºr Visualisierung).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/a96/15c/a9ca9615c10cdab502f1769443ad6b38.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine Pfeile.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rasteranzeige </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Pfeile ausgeblendet sind, wird es schwierig, die Position jeder Kachel zu erkennen. </font><font style="vertical-align: inherit;">F√ºgen wir die Gitterlinien hinzu. </font><font style="vertical-align: inherit;">Laden Sie </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daher</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textur mit einem quadratischen Grenze Netz , </font><font style="vertical-align: inherit;">die als eine einzelne Fliese Kontur verwendet werden k√∂nnen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/e98/483/4c1e984836babfc368136b83ac2b195b.png" width="128" height="128"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maschentextur.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden diese Textur nicht einzeln zu jeder Fliese hinzuf√ºgen, sondern auf den Boden auftragen. Wir werden dieses Raster jedoch optional machen sowie die Visualisierung von Pfaden. Daher werden wir </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Konfigurationsfeld </font><font style="vertical-align: inherit;">hinzuf√ºgen </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und eine Netztextur daf√ºr ausw√§hlen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Texture2D gridTexture = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed4/99a/28e/ed499a28e82a3328c010a71ba1085316.png" width="320" height="94"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld mit Netzstruktur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie ein weiteres boolesches Feld und eine Eigenschaft hinzu, um den Status der Rastervisualisierung zu steuern. </font><font style="vertical-align: inherit;">In diesem Fall muss der Setter das Material der Erde √§ndern, was durch Aufrufen der </font></font><code>GetComponent&lt;MeshRenderer&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erde und Zugriff auf die Eigenschaft des </font></font><code>material</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisses </font><font style="vertical-align: inherit;">implementiert werden kann </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn das Raster angezeigt werden muss, weisen wir die </font></font><code>mainTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rastertextur </font><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Materialeigenschaft zu. </font><font style="vertical-align: inherit;">Andernfalls weisen Sie es ihm zu </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beachten Sie, dass beim √Ñndern der Textur des Materials Duplikate der Materialinstanz erstellt werden, sodass diese unabh√§ngig vom Materialelement wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showGrid, showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowGrid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showGrid; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showGrid = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Material m = ground.GetComponent&lt;MeshRenderer&gt;().material; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m.mainTexture = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Visualisierung des Gitters mit der G-Taste umschalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.G)) { board.ShowGrid = !board.ShowGrid; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie au√üerdem die Standard-Netzvisualisierung hinzu </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b04/145/190/b04145190e5d8f15972f25374d7f5813.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unskaliertes Gitter. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir eine Grenze um das gesamte Feld. </font><font style="vertical-align: inherit;">Es passt zur Textur, aber das brauchen wir nicht. </font><font style="vertical-align: inherit;">Wir m√ºssen die Haupttextur des Materials so skalieren, dass sie der Gr√∂√üe des Gitters entspricht. </font><font style="vertical-align: inherit;">Sie k√∂nnen dies tun, indem Sie die </font></font><code>SetTextureScale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materialmethode mit dem Namen der Textur-Eigenschaft ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und der zweidimensionalen Gr√∂√üe </font><em><font style="vertical-align: inherit;">aufrufen</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir k√∂nnen direkt die Gr√∂√üe des Feldes verwenden, das indirekt in einen Wert umgewandelt wird </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; m.SetTextureScale(<span class="hljs-string"><span class="hljs-string">"_MainTex"</span></span>, size); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d2a/b85/edbd2ab858e40a61d5f89452a8809b33.png" width="230" height="230" alt="ohne"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/91a/ae5/8bd91aae589309dbd64994bb10a935a9.png" width="230" height="230" alt="mit"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skaliertes Raster mit ein- und ausgeschalteter Pfadvisualisierung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir also ein funktionierendes Feld f√ºr ein Kachelspiel des Tower Defense-Genres. </font><font style="vertical-align: inherit;">Im n√§chsten Tutorial werden wir Feinde hinzuf√ºgen. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pdf</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449798/">https://habr.com/ru/post/de449798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449784/index.html">In welchen F√§llen lohnt es sich, Django zu verwenden (und in welchen F√§llen ist es nicht notwendig)</a></li>
<li><a href="../de449788/index.html">Brave Browser stellt eine belohnungsbasierte Werbeplattform vor</a></li>
<li><a href="../de449790/index.html">Produktentwicklung Visual Aid: Design</a></li>
<li><a href="../de449794/index.html">Adaptive Antennenarrays: Wie funktioniert es? (Grundlagen)</a></li>
<li><a href="../de449796/index.html">√úber ein M√§dchen</a></li>
<li><a href="../de449802/index.html">Karriereprogrammierer. Teil 1. Das erste Programm</a></li>
<li><a href="../de449804/index.html">√úberblick √ºber die Anti-Aging-Therapie f√ºr Biohacker</a></li>
<li><a href="../de449806/index.html">Karriereprogrammierer. Teil 2. Schule oder Selbstbildung</a></li>
<li><a href="../de449808/index.html">Positive Hack Days 9 Experiment: Wie kritisches Denken in Leben und Arbeiten hilft</a></li>
<li><a href="../de449814/index.html">Windows XP ist jetzt endlich offiziell tot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>