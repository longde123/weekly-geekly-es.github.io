<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐍 👎🏼 🧛🏽 Turmverteidigung in Einheit schaffen, Teil 1 🏚️ 👩‍⚕️ 📇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Feld 


- Erstellen eines Kachelfelds. 
- Suchpfade mit der Breitensuche. 
- Implementieren Sie die Unterstützung für leere und Endkacheln sowie W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Turmverteidigung in Einheit schaffen, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449798/"><h1>  Das Feld </h1><br><ul><li>  Erstellen eines Kachelfelds. </li><li>  Suchpfade mit der Breitensuche. </li><li>  Implementieren Sie die Unterstützung für leere und Endkacheln sowie Wandkacheln. </li><li>  Bearbeiten von Inhalten im Spielemodus. </li><li>  Optionale Anzeige von Rasterfeldern und Pfaden. </li></ul><br>  Dies ist der erste Teil einer Reihe von Tutorials zum Erstellen eines einfachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tower Defense-</a> Spiels.  In diesem Teil werden wir überlegen, ein Spielfeld zu schaffen, einen Weg zu finden und endgültige Kacheln und Wände zu platzieren. <br><br>  Das Tutorial wurde in Unity 2018.3.0f2 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3d/ae4/591/c3dae459169a0a7f0ce240763b91d55c.jpg"></div><br>  <i>Ein Feld, das zur Verwendung in einem Tower Defense-Genre-Kachelspiel bereit ist.</i> <br><br><h2>  Tower Defense-Spiel </h2><br>  Tower Defense ist ein Genre, in dem es das Ziel des Spielers ist, Massen von Feinden zu zerstören, bis sie ihren Endpunkt erreichen.  Der Spieler erreicht sein Ziel, indem er Türme baut, die Feinde angreifen.  Dieses Genre hat viele Variationen.  Wir werden ein Spiel mit einem Kachelfeld erstellen.  Gegner bewegen sich über das Spielfeld in Richtung ihres Endpunkts und der Spieler schafft Hindernisse für sie. <br><a name="habracut"></a><br>  Ich gehe davon aus, dass Sie bereits eine Reihe von Tutorials zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten von Objekten studiert haben</a> . <br><br><h3>  Das Feld </h3><br>  Das Spielfeld ist der wichtigste Teil des Spiels, daher werden wir es zuerst erstellen.  Dies ist ein Spielobjekt mit einer eigenen Komponente <code>GameBoard</code> , die durch Festlegen der Größe in zwei Dimensionen initialisiert werden kann, für die wir den Wert von <code>Vector2Int</code> .  Das Feld sollte mit jeder Größe funktionieren, aber wir werden die Größe woanders auswählen, also werden wir eine gemeinsame <code>Initialize</code> dafür erstellen. <br><br>  Zusätzlich visualisieren wir das Feld mit einem Viereck, das die Erde bezeichnet.  Wir werden das Feldobjekt selbst nicht zu einem Viereck machen, sondern ihm ein untergeordnetes Quad-Objekt hinzufügen.  Nach der Initialisierung werden wir die XY-Skala der Erde gleich der Größe des Feldes machen.  Das heißt, jede Fliese hat eine Größe von einer quadratischen Maßeinheit für den Motor. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform ground = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Vector2Int size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Warum explizit den Standardwert festlegen?</b> <div class="spoiler_text">  Die Idee ist, dass alles, was über den Unity-Editor anpassbar ist, über serialisierte versteckte Felder zugänglich ist.  Diese Felder müssen nur im Inspektor geändert werden.  Leider zeigt der Unity-Editor ständig eine Compiler-Warnung an, dass der Wert niemals zugewiesen wird.  Wir können diese Warnung unterdrücken, indem wir den Standardwert für das Feld explizit festlegen.  Sie können auch <code>null</code> zuweisen, aber ich habe es so gemacht, dass explizit gezeigt wird, dass wir einfach den Standardwert verwenden, der kein echter Verweis auf Masse ist, also verwenden wir <code>default</code> . </div></div><br>  Erstellen Sie ein Feldobjekt in einer neuen Szene und fügen Sie ein untergeordnetes Quad mit einem Material hinzu, das wie Erde aussieht.  Da wir ein einfaches Prototypenspiel erstellen, wird ein einheitliches grünes Material ausreichen.  Drehen Sie das Quad um 90 ° entlang der X-Achse, so dass es auf der XZ-Ebene liegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/9b8/9af/db99b89afcc551541f1f6adbe4816e54.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/f7c/77d/fa8f7c77d6697bca5e3c8823f5adcd86.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/467/015/f2a467015b8eefc8ca956eaec61d50dc.png"></div><br>  <i>Spielfeld.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Warum positionieren Sie das Spiel nicht auf der XY-Ebene?</b> <div class="spoiler_text">  Obwohl das Spiel im 2D-Raum stattfinden wird, werden wir es in 3D rendern, mit 3D-Feinden und einer Kamera, die relativ zu einem bestimmten Punkt bewegt werden kann.  Die XZ-Ebene ist hierfür bequemer und entspricht der Standard-Skybox-Ausrichtung für die Umgebungsbeleuchtung. </div></div><br><h3>  Das Spiel </h3><br>  Erstellen Sie als Nächstes eine <code>Game</code> , die für das gesamte Spiel verantwortlich ist.  In diesem Stadium bedeutet dies, dass das Feld initialisiert wird.  Wir machen die Größe einfach über den Inspektor anpassbar und zwingen die Komponente, das Feld beim Aufwachen zu initialisieren.  Verwenden wir die Standardgröße 11 × 11. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Game</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Vector2Int boardSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); [SerializeField] GameBoard board = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize); } }</code> </pre> <br>  Feldgrößen können nur positiv sein und es macht wenig Sinn, ein Feld mit einer einzigen Kachel zu erstellen.  Begrenzen wir also das Minimum auf 2 × 2.  Dies kann durch Hinzufügen der <code>OnValidate</code> Methode erfolgen, wodurch die Mindestwerte zwangsweise begrenzt werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnValidate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.x &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.x = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.y &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wann wird Onvalidate aufgerufen?</b> <div class="spoiler_text">  Wenn es vorhanden ist, ruft der Unity-Editor es nach dem Ändern für die Komponenten auf.  Einschließlich beim Hinzufügen zum Spielobjekt, nach dem Laden der Szene, nach dem erneuten Kompilieren, nach dem Ändern im Editor, nach dem Abbrechen / erneuten Versuchen und nach dem Zurücksetzen der Komponente. <br><br>  <code>OnValidate</code> ist die einzige Stelle im Code, an der Sie Komponentenkonfigurationsfeldern Werte zuweisen können. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/15d/efd/7ae15defd1e838186f922fc30d346b17.png"></div><br>  <i>Spielobjekt.</i> <br><br>  Wenn Sie jetzt den Spielmodus starten, erhalten wir ein Feld mit der richtigen Größe.  Positionieren Sie die Kamera während des Spiels so, dass das gesamte Brett sichtbar ist, kopieren Sie die Transformationskomponente, verlassen Sie den Spielmodus und fügen Sie die Werte der Komponente ein.  Bei einem 11 × 11-Feld am Ursprung können Sie die Kamera in Position (0,10,0) positionieren und um 90 ° entlang der X-Achse drehen, um eine bequeme Ansicht von oben zu erhalten. Wir lassen die Kamera in dieser festen Position, aber es ist möglich ändere es in der Zukunft. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/45c/421/eb545c421fdca09acf1258a2fac9e183.png"></div><br>  <i>Kamera über dem Feld.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Wie kopiere ich Komponentenwerte und füge sie ein?</b> <div class="spoiler_text">  Über das Dropdown-Menü, das angezeigt wird, wenn Sie auf die Schaltfläche mit dem Zahnrad in der oberen rechten Ecke der Komponente klicken. </div></div><br><h3>  Fertighausfliese </h3><br>  Das Feld besteht aus quadratischen Kacheln.  Feinde können sich von Kachel zu Kachel bewegen und die Kanten überqueren, jedoch nicht diagonal.  Die Bewegung erfolgt immer zum nächsten Endpunkt.  Bezeichnen wir grafisch die Bewegungsrichtung entlang der Kachel mit einem Pfeil.  Sie können die Pfeilstruktur <a href="">hier</a> herunterladen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/l6/os/tfl6oszqhi93v6aqlllrp1yuhli.png"></div><br>  <i>Pfeil auf einem schwarzen Hintergrund.</i> <br><br>  Platzieren Sie die Pfeilstruktur in Ihrem Projekt und aktivieren Sie die Option <em>Alpha als Transparenz</em> .  Erstellen Sie dann ein Material für den Pfeil, das das Standardmaterial sein kann, für das der Ausschnittmodus ausgewählt ist, und wählen Sie den Pfeil als Haupttextur aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/2d6/56c/bfb2d656c07931b8f59ef11715eee93b.png"></div><br>  <i>Pfeilmaterial.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Warum den Cutout-Render-Modus verwenden?</b> <div class="spoiler_text">  Sie können den Pfeil mithilfe der Standard-Unity-Rendering-Pipeline verdecken. </div></div><br>  Um jedes Plättchen im Spiel zu kennzeichnen, verwenden wir das Spielobjekt.  Jeder von ihnen hat ein eigenes Quad mit Pfeilmaterial, genau wie das Feld ein Quad aus Erde hat.  Wir werden der GameTile-Komponente auch Kacheln mit einem Link zu ihrem Pfeil hinzufügen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTile</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform arrow = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }</code> </pre> <br>  Erstellen Sie ein Kachelobjekt und verwandeln Sie es in ein Fertighaus.  Die Fliesen sind bodenbündig. Heben Sie den Pfeil daher etwas an, um Probleme mit der Tiefe beim Rendern zu vermeiden.  Verkleinern Sie auch ein wenig, damit zwischen benachbarten Pfeilen wenig Platz ist.  Ein Y-Versatz von 0,001 und eine Skala von 0,8, die für alle Achsen gleich ist, reichen aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/02b/6d8/f1202b6d8f8f33593bf56ef0d8665537.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/964/1ac/a4b/9641aca4b874f48c3765af10e2c83157.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/7a3/c9f/df77a3c9f539083eab845be6b9c62919.png"></div><br>  <i>Fertighausfliese.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Wo ist die vorgefertigte Kachelhierarchie?</b> <div class="spoiler_text">  Sie können den Fertighaus-Bearbeitungsmodus öffnen, indem Sie auf das Fertighaus doppelklicken oder das Fertighaus auswählen und im Inspektor auf die Schaltfläche Fertighaus öffnen klicken.  Sie können den vorgefertigten Bearbeitungsmodus verlassen, indem Sie auf die Schaltfläche mit einem Pfeil in der oberen linken Ecke der Hierarchieüberschrift klicken. </div></div><br>  Beachten Sie, dass die Kacheln selbst keine Spielobjekte sein müssen.  Sie werden nur benötigt, um den Status des Feldes zu verfolgen.  Wir könnten den gleichen Ansatz wie für das Verhalten in der Tutorials-Reihe " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektverwaltung"</a> verwenden.  Aber in den frühen Stadien einfacher Spiele oder Prototypen von Spielobjekten sind wir ziemlich glücklich.  Dies kann in Zukunft geändert werden. <br><br><h3>  Wir haben Fliesen </h3><br>  Um Kacheln zu erstellen, muss das <code>GameBoard</code> einen Link zum Kachelfertigteil haben. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTile tilePrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/6c2/044/3636c204442368c58858152a7c3efee2.png"></div><br>  <i>Link zur Fertighauskachel.</i> <br><br>  Anschließend kann er seine Instanzen mithilfe einer Doppelschleife über zwei Rasterdimensionen erstellen.  Obwohl die Größe als X und Y ausgedrückt wird, ordnen wir die Kacheln in der XZ-Ebene sowie im Feld selbst an.  Da das Feld relativ zum Ursprung zentriert ist, müssen wir die entsprechende Größe minus eins geteilt durch zwei von den Komponenten der Kachelposition subtrahieren.  Bitte beachten Sie, dass dies eine Gleitkommadivision sein muss, da dies sonst bei geraden Größen nicht funktioniert. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2( (size.x - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, (size.y - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++) { GameTile tile = Instantiate(tilePrefab); tile.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); tile.transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( x - offset.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, y - offset.y ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/391/265/640/391265640fe99dd10be005de76ce93f3.png"></div><br>  <i>Instanzen von Kacheln erstellt.</i> <br><br>  Später benötigen wir Zugriff auf diese Kacheln, damit wir sie in einem Array verfolgen können.  Wir brauchen keine Liste, da sich die Größe des Feldes nach der Initialisierung nicht ändert. <br><br><pre> <code class="cs hljs"> GameTile[] tiles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { … tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { GameTile tile = tiles[i] = Instantiate(tilePrefab); … } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wie funktioniert diese Aufgabe?</b> <div class="spoiler_text">  Dies ist eine verknüpfte Aufgabe.  In diesem Fall bedeutet dies, dass wir sowohl dem Array-Element als auch der lokalen Variablen einen Link zur Kachelinstanz zuweisen.  Diese Vorgänge entsprechen dem unten gezeigten Code. <br><br><pre> <code class="cs hljs">GameTile t = Instantiate(tilePrefab); tiles[i] = t; GameTile tile = t;</code> </pre> </div></div><br><h2>  Suche nach einem Weg </h2><br>  Zu diesem Zeitpunkt hat jede Kachel einen Pfeil, aber alle zeigen in die positive Richtung der Z-Achse, die wir als Norden interpretieren werden.  Der nächste Schritt besteht darin, die richtige Richtung für die Kachel zu bestimmen.  Wir tun dies, indem wir den Weg finden, dem die Feinde bis zum Endpunkt folgen müssen. <br><br><h3>  Fliesen Nachbarn </h3><br>  Die Wege verlaufen von Fliese zu Fliese im Norden, Osten, Süden oder Westen.  Um die Suche zu vereinfachen, <code>GameTile</code> Track-Links zu den vier Nachbarn. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west;</code> </pre> <br>  Die Beziehungen zwischen den Nachbarn sind symmetrisch.  Wenn das Plättchen der östliche Nachbar des zweiten Plättchens ist, ist das zweite der westliche Nachbar des ersten Plättchens.  Fügen Sie <code>GameTile</code> eine allgemeine statische Methode <code>GameTile</code> , um diese Beziehung zwischen zwei Kacheln zu definieren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Warum eine statische Methode verwenden?</b> <div class="spoiler_text">  Wir können es zu einer Instanzmethode mit einem einzelnen Parameter machen, und in diesem Fall nennen wir es <code>eastTile.MakeEastWestNeighbors(westTile)</code> oder so ähnlich.  In Fällen, in denen nicht klar ist, auf welche Kacheln die Methode aufgerufen werden soll, ist es besser, statische Methoden zu verwenden.  Beispiele sind die <code>Distance</code> und <code>Dot</code> Methoden der <code>Vector3</code> Klasse. </div></div><br>  Einmal verbunden, sollte es sich nie ändern.  In diesem Fall haben wir einen Fehler im Code gemacht.  Sie können dies überprüfen, indem Sie beide Links vergleichen, bevor Sie <code>null</code> Werte zuweisen, und einen Fehler anzeigen, wenn dieser falsch ist.  Sie können hierfür die <code>Debug.Assert</code> Methode verwenden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( west.east == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; east.west == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Was macht Debug.Assert?</b> <div class="spoiler_text">  Wenn das erste Argument <code>false</code> , wird ein Bedingungsfehler angezeigt, wobei das zweite Argument verwendet wird, wenn es angegeben ist.  Ein solcher Aufruf ist nur in Test-Builds enthalten, nicht jedoch in Release-Builds.  Daher ist dies eine gute Möglichkeit, während des Entwicklungsprozesses Überprüfungen hinzuzufügen, die sich nicht auf die endgültige Version auswirken. </div></div><br>  Fügen Sie eine ähnliche Methode hinzu, um Beziehungen zwischen den nördlichen und südlichen Nachbarn herzustellen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeNorthSouthNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile north, GameTile south</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( south.north == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; north.south == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); south.north = north; north.south = south; }</code> </pre> <br>  Wir können diese Beziehung herstellen, wenn wir Kacheln in <code>GameBoard.Initialize</code> .  Wenn die X-Koordinate größer als Null ist, können wir eine Ost-West-Beziehung zwischen der aktuellen und der vorherigen Kachel herstellen.  Wenn die Y-Koordinate größer als Null ist, können wir eine Nord-Süd-Beziehung zwischen der aktuellen Kachel und der Kachel aus der vorherigen Zeile erstellen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeEastWestNeighbors(tile, tiles[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeNorthSouthNeighbors(tile, tiles[i - size.x]); } } }</code> </pre> <br>  Beachten Sie, dass die Kacheln an den Feldrändern keine vier Nachbarn haben.  Ein oder zwei Nachbarreferenzen bleiben <code>null</code> . <br><br><h3>  Entfernung und Richtung </h3><br>  Wir werden nicht alle Feinde zwingen, ständig nach dem Weg zu suchen.  Dies muss nur einmal pro Kachel durchgeführt werden.  Dann können die Feinde von dem Plättchen, auf dem sie sich befinden, anfordern, wohin sie sich bewegen möchten.  Wir werden diese Informationen in <code>GameTile</code> speichern, indem wir einen Link zur nächsten <code>GameTile</code> hinzufügen.  Außerdem speichern wir die Entfernung zum Endpunkt, ausgedrückt als Anzahl der Kacheln, die besucht werden müssen, bevor der Feind den Endpunkt erreicht.  Für Feinde sind diese Informationen nutzlos, aber wir werden sie verwenden, um die kürzesten Wege zu finden. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west, nextOnPath; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br>  Jedes Mal, wenn wir entscheiden, dass wir nach Pfaden suchen müssen, müssen wir die Pfaddaten initialisieren.  Bis der Pfad gefunden ist, gibt es kein nächstes Plättchen und die Entfernung kann als unendlich angesehen werden.  Wir können uns dies als den maximal möglichen ganzzahligen Wert von <code>int.MaxValue</code> .  Fügen Sie eine generische <code>ClearPath</code> Methode hinzu, um das <code>GameTile</code> auf diesen Status zurückzusetzen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Pfade können nur durchsucht werden, wenn wir einen Endpunkt haben.  Dies bedeutet, dass die Kachel zum Endpunkt werden muss.  Eine solche Kachel hat einen Abstand von Null und nicht die letzte Kachel, da der Pfad darauf endet.  Fügen Sie eine generische Methode hinzu, die eine Kachel in einen Endpunkt verwandelt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Letztendlich sollten sich alle Kacheln in einen Pfad verwandeln, damit ihre Entfernung nicht mehr <code>int.MaxValue</code> .  Fügen Sie eine praktische Getter-Eigenschaft hinzu, um zu überprüfen, ob die Kachel derzeit einen Pfad hat. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath =&gt; distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wie funktioniert diese Eigenschaft?</b> <div class="spoiler_text">  Dies ist ein verkürzter Eintrag für eine Getter-Eigenschaft, die nur einen Ausdruck enthält.  Dies entspricht dem unten gezeigten Code. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } }</code> </pre> <br>  Der Pfeiloperator <code>=&gt;</code> kann auch einzeln für den Getter und Setter von Eigenschaften, für die Körper von Methoden, Konstruktoren und an einigen anderen Stellen verwendet werden. </div></div><br><h3>  Wir wachsen einen Weg </h3><br>  Wenn wir ein Plättchen mit einem Pfad haben, können wir es einen Pfad zu einem seiner Nachbarn wachsen lassen.  Anfänglich ist das einzige Plättchen mit dem Pfad der Endpunkt. Wir beginnen also bei Null und erhöhen ihn von hier aus, wobei wir uns in die entgegengesetzte Richtung zur Bewegung der Feinde bewegen.  Das heißt, alle unmittelbaren Nachbarn des Endpunkts haben einen Abstand von 1, und alle Nachbarn dieser Kacheln haben einen Abstand von 2 usw. <br><br>  Fügen Sie eine versteckte <code>GameTile</code> Methode hinzu, um den Pfad zu einem seiner Nachbarn zu vergrößern, der über den Parameter angegeben wird.  Die Entfernung zum Nachbarn ist eins mehr als die aktuelle Kachel, und der Pfad des Nachbarn gibt die aktuelle Kachel an.  Diese Methode sollte nur für Kacheln aufgerufen werden, die bereits einen Pfad haben. Überprüfen wir dies also mit assert. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  Die Idee ist, dass wir diese Methode einmal für jeden der vier Nachbarn der Kachel aufrufen.  Da einige dieser Links <code>null</code> , überprüfen wir dies und stoppen gegebenenfalls die Ausführung.  Wenn ein Nachbar bereits einen Pfad hat, sollten wir außerdem nichts tun und auch damit aufhören. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  Die Art <code>GameTile</code> Weise, wie <code>GameTile</code> seine Nachbarn verfolgt, ist dem Rest des Codes unbekannt.  Daher ist <code>GrowPathTo</code> ausgeblendet.  Wir werden allgemeine Methoden hinzufügen, die die Kachel <code>GrowPathTo</code> ihren Pfad in eine bestimmte Richtung zu erweitern, indem <code>GrowPathTo</code> indirekt <code>GrowPathTo</code> aufrufen.  Der Code, der im gesamten Feld sucht, sollte jedoch verfolgen, welche Kacheln besucht wurden.  Daher wird es einen Nachbarn oder <code>null</code> wenn die Ausführung beendet wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor; }</code> </pre> <br>  Fügen Sie nun Methoden zum Wachsen von Pfaden in bestimmte Richtungen hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west);</code> </pre> <br><h3>  Breite Suche </h3><br>  <code>GameBoard</code> muss <code>GameBoard</code> dass alle Kacheln die richtigen <code>GameBoard</code> enthalten.  Wir tun dies, indem wir eine Breitensuche durchführen.  Beginnen wir mit der Endpunktkachel und erweitern dann den Pfad zu den Nachbarn, dann zu den Nachbarn dieser Kacheln und so weiter.  Mit jedem Schritt erhöht sich der Abstand um eins, und die Pfade wachsen nie in Richtung der Kacheln, die bereits Pfade haben.  Dadurch wird sichergestellt, dass alle Kacheln auf dem kürzesten Weg zum Endpunkt zeigen. <br><br><div class="spoiler">  <b class="spoiler_title">Was ist mit einem Pfad mit A *?</b> <div class="spoiler_text">  Der A <sup>*</sup> -Algorithmus ist die evolutionäre Entwicklung der Breitensuche.  Es ist nützlich, wenn wir nach dem einzig kürzesten Weg suchen.  Wir brauchen aber die kürzesten Wege, deshalb bietet A <sup>*</sup> keine Vorteile.  Beispiele für die Breitensuche und A <sup>*</sup> in einem Sechseckraster mit Animation finden Sie in der Reihe von Tutorials zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sechseckkarten</a> . </div></div><br>  Um die Suche durchzuführen, müssen wir die Kacheln verfolgen, die wir dem Pfad hinzugefügt haben, von denen wir den Pfad jedoch noch nicht vergrößert haben.  Diese Sammlung von Kacheln wird oft als Suchgrenze bezeichnet.  Es ist wichtig, dass die Kacheln in derselben Reihenfolge verarbeitet werden, in der sie dem Rahmen hinzugefügt werden. Verwenden Sie daher die <code>Queue</code> .  Später müssen wir die Suche mehrmals durchführen, also legen wir sie als Feld des <code>GameBoard</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … Queue&lt;GameTile&gt; searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;GameTile&gt;(); … }</code> </pre> <br>  Damit der Status des Spielfelds immer wahr ist, müssen wir die Pfade am Ende von <code>Initialize</code> , aber den Code in eine separate <code>FindPaths</code> Methode <code>FindPaths</code> .  Zuerst müssen Sie den Pfad aller Kacheln löschen, dann eine Kachel zum Endpunkt machen und sie dem Rand hinzufügen.  Lassen Sie uns zuerst die erste Kachel auswählen.  Da <code>tiles</code> ein Array sind, können wir die <code>foreach</code> ohne Angst vor Speicherverschmutzung zu haben.  Wenn wir später von einem Array zu einer Liste wechseln, müssen wir auch die <code>foreach</code> Schleifen durch <code>for</code> Schleifen ersetzen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { … FindPaths(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Als nächstes müssen wir ein Plättchen von der Grenze nehmen und einen Pfad zu allen Nachbarn aufbauen und sie alle zur Grenze hinzufügen.  Zuerst ziehen wir nach Norden, dann nach Osten, Süden und schließlich nach Westen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Wir wiederholen diese Phase, während sich Kacheln in der Grenze befinden. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Das Wachsen eines Pfades führt uns nicht immer zu einem neuen Plättchen.  Vor dem Hinzufügen zur Warteschlange müssen wir den Wert auf <code>null</code> prüfen, aber wir können die Prüfung auf <code>null</code> bis nach der Ausgabe aus der Warteschlange verschieben. <br><br><pre> <code class="cs hljs"> GameTile tile = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br><h3>  Zeigen Sie die Pfade an </h3><br>  Jetzt haben wir ein Feld mit den richtigen Pfaden, aber bisher sehen wir dies nicht.  Sie müssen die Pfeile so konfigurieren, dass sie entlang des Pfads durch ihre Kacheln zeigen.  Dies kann durch Drehen erfolgen.  Da diese <code>GameTile</code> immer gleich sind, fügen wir dem <code>GameTile</code> ein statisches <code>Quaternion</code> Feld für jede der Richtungen hinzu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion northRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), eastRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), southRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), westRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>);</code> </pre> <br>  <code>ShowPath</code> auch die allgemeine <code>ShowPath</code> Methode hinzu.  Wenn der Abstand Null ist, ist die Kachel der Endpunkt und es gibt nichts, auf das Sie zeigen können. Deaktivieren Sie daher den Pfeil.  Andernfalls aktivieren Sie den Pfeil und stellen Sie seine Drehung ein.  Die gewünschte Richtung kann durch Vergleichen von <code>nextOnPath</code> mit seinen Nachbarn bestimmt werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance == <span class="hljs-number"><span class="hljs-number">0</span></span>) { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); arrow.localRotation = nextOnPath == north ? northRotation : nextOnPath == east ? eastRotation : nextOnPath == south ? southRotation : westRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie diese Methode am Ende für alle Kacheln auf </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/4fe/4d5/b2d4fe4d511b4e729910ea78b267f268.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wege gefunden.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum verwandeln wir den Pfeil nicht direkt in GrowPathTo?</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trennung der Logik und Visualisierung der Suche. </font><font style="vertical-align: inherit;">Später werden wir die Visualisierung deaktivieren. </font><font style="vertical-align: inherit;">Wenn die Pfeile nicht angezeigt werden, müssen wir sie nicht jedes Mal drehen, wenn wir anrufen </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suchpriorität ändern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellt sich heraus, dass, wenn der Endpunkt die südwestliche Ecke ist, alle Pfade genau nach Westen verlaufen, bis sie den Rand des Feldes erreichen, wonach sie nach Süden abbiegen. </font><font style="vertical-align: inherit;">Hier stimmt alles, denn es gibt wirklich keine kürzeren Wege zum Endpunkt, weil diagonale Bewegungen unmöglich sind. </font><font style="vertical-align: inherit;">Es gibt jedoch viele andere kürzeste Wege, die schöner aussehen können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um besser zu verstehen, warum solche Pfade gefunden werden, verschieben Sie den Endpunkt in die Mitte der Karte. </font><font style="vertical-align: inherit;">Bei einer ungeraden Feldgröße ist es nur eine Kachel in der Mitte des Arrays.</font></font><br><br><pre> <code class="cs hljs"> tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d3/d09/d78/6d3d09d7844fbe6a4aaf4618449598de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endpunkt in der Mitte.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Ergebnis erscheint logisch, wenn Sie sich daran erinnern, wie die Suche funktioniert. Da wir Nachbarn in der Nordost-Südwest-Ordnung hinzufügen, hat der Norden die höchste Priorität. Da wir die Suche in umgekehrter Reihenfolge durchführen, bedeutet dies, dass wir zuletzt nach Süden gefahren sind. Deshalb zeigen nur wenige Pfeile nach Süden und viele nach Osten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können das Ergebnis ändern, indem Sie die Prioritäten der Anweisungen festlegen. Lassen Sie uns nach Osten und Süden tauschen. Wir müssen also die Nord-Süd- und Ost-West-Symmetrie erhalten.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest())</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/2c7/0b7/a9a2c70b7d7d178b041f30c11d256ad3.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Suchreihenfolge ist Nord-Süd-Ost-West. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sieht hübscher aus, aber es ist besser, wenn die Wege ihre Richtung ändern und sich einer diagonalen Bewegung nähern, bei der es natürlich aussieht. </font><font style="vertical-align: inherit;">Wir können dies tun, indem wir die Suchprioritäten benachbarter Kacheln in einem Schachbrettmuster umkehren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt herauszufinden, welche Art von Kachel wir während der Suche verarbeiten, fügen wir der </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Eigenschaft hinzu, die angibt, ob die aktuelle Kachel eine Alternative ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsAlternative { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Eigenschaft in setzen </font></font><code>GameBoard.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Markieren Sie zuerst die Kacheln als Alternative, wenn ihre X-Koordinate gerade ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht die Operation (x &amp; 1) == 0?</font></font></b> <div class="spoiler_text">   —     (AND).            .       1,       1.  10101010  00001111   00001010. <br><br>       .      0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,       . <br><br>    AND  ,  ,    .    ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens ändern wir das Vorzeichen des Ergebnisses, wenn ihre Y-Koordinate gerade ist. </font><font style="vertical-align: inherit;">Also werden wir ein Schachmuster erstellen.</font></font><br><br><pre> <code class="cs hljs"> tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((y &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { tile.IsAlternative = !tile.IsAlternative; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir die gleiche Reihenfolge wie die Suche nach alternativer Kachel halten, aber es zurück zu allen anderen Fliesen zu machen. </font><font style="vertical-align: inherit;">Dies erzwingt den Weg zur diagonalen Bewegung und erzeugt Zickzackbewegungen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.IsAlternative) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Enqueue(tile.GrowPathWest()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathNorth()); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b43/e3a/d63/b43e3ad6370a6b552073b4f0b4cf0e8b.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable Suchreihenfolge.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fliesen wechseln </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt sind alle Kacheln leer. </font><font style="vertical-align: inherit;">Eine Kachel wird als Endpunkt verwendet, aber zusätzlich zum Fehlen eines sichtbaren Pfeils sieht sie genauso aus wie alle anderen. </font><font style="vertical-align: inherit;">Wir werden die Möglichkeit hinzufügen, Kacheln zu ändern, indem wir Objekte darauf platzieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kachelinhalt </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kachelobjekte selbst sind einfach eine Möglichkeit, Kachelinformationen zu verfolgen. </font><font style="vertical-align: inherit;">Wir ändern diese Objekte nicht direkt. </font><font style="vertical-align: inherit;">Fügen Sie stattdessen separaten Inhalt hinzu und platzieren Sie ihn auf dem Feld. </font><font style="vertical-align: inherit;">Im Moment können wir zwischen leeren Kacheln und Endpunktkacheln unterscheiden. </font><font style="vertical-align: inherit;">Erstellen Sie eine Aufzählung, um diese Fälle anzuzeigen </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie als Nächstes einen Komponententyp </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem Sie den Inhaltstyp über den Inspektor festlegen können. Der Zugriff darauf erfolgt über eine gemeinsame Getter-Eigenschaft.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] GameTileContentType type = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentType Type =&gt; type; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anschließend erstellen wir Fertighäuser für zwei Inhaltstypen, von denen jeder eine Komponente </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem entsprechenden angegebenen Typ enthält. </font><font style="vertical-align: inherit;">Verwenden wir einen blau abgeflachten Würfel, um Endpunktkacheln zu bestimmen. </font><font style="vertical-align: inherit;">Da es fast flach ist, braucht er keinen Collider. </font><font style="vertical-align: inherit;">Verwenden Sie ein leeres Spielobjekt, um leere Inhalte vorzufertigen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f55/25d/8db/f5525d8db707ff187e17ce96a11d86ae.png" width="320" height="262" alt="Ziel"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/463/e19/c6f463e198abca6134b7bc74d3207833.png" width="320" height="176" alt="leer"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighäuser des Endpunkts und leerer Inhalte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir geben das Inhaltsobjekt an die leeren Kacheln weiter, da dann alle Kacheln immer den Inhalt haben, was bedeutet, dass wir die Links zu den Inhalten nicht auf Gleichheit überprüfen müssen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhaltsfabrik </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Inhalt bearbeitbar zu machen, erstellen wir hierfür auch eine Factory, die denselben Ansatz wie im Tutorial zur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objektverwaltung verwendet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sie </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Überblick über Ihre ursprüngliche Fabrik behalten müssen, die nur einmal eingestellt werden sollte, und sich in der Methode an die Fabrik zurücksenden müssen </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory originFactory; … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies setzt die Existenz voraus </font></font><code>GameTileContentFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, daher erstellen wir dafür einen skriptfähigen Objekttyp mit der erforderlichen Methode </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In dieser Phase werden wir uns nicht mit der Schaffung einer voll funktionsfähigen Fabrik befassen, die den Inhalt nutzt, also werden wir dafür sorgen, dass der Inhalt einfach zerstört wird. </font><font style="vertical-align: inherit;">Später ist es möglich, die Wiederverwendung von Objekten zur Fabrik hinzuzufügen, ohne den Rest des Codes zu ändern.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent content</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(content.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(content.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Factory eine versteckte Methode </font><font style="vertical-align: inherit;">mit einem Fertighaus als Parameter hinzu. </font><font style="vertical-align: inherit;">Hier überspringen wir wieder die Wiederverwendung von Objekten. </font><font style="vertical-align: inherit;">Er erstellt eine Instanz des Objekts, legt seine ursprüngliche Fabrik fest, verschiebt es in die Fabrikszene und gibt es zurück.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent prefab</span></span></span><span class="hljs-function">)</span></span> { GameTileContent instance = Instantiate(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; MoveToFactoryScene(instance.gameObject); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Instanz wurde in die Factory-Content-Szene verschoben, die bei Bedarf erstellt werden kann. </font><font style="vertical-align: inherit;">Wenn wir uns im Editor befinden, müssen wir vor dem Erstellen einer Szene überprüfen, ob sie vorhanden ist, falls wir sie während eines heißen Neustarts aus den Augen verlieren.</font></font><br><br><pre> <code class="cs hljs"> Scene contentScene; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveToFactoryScene</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { contentScene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { contentScene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentScene = SceneManager.CreateScene(name); } } SceneManager.MoveGameObjectToScene(o, contentScene); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir haben nur zwei Arten von Inhalten, also fügen Sie einfach zwei vorgefertigte Konfigurationsfelder für sie hinzu. </font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent destinationPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] GameTileContent emptyPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Letzte, was getan werden muss, damit die Factory funktioniert, ist das Erstellen einer allgemeinen Methode </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Parameter </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der eine Instanz des entsprechenden Fertighauses empfängt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist es obligatorisch, jeder Kachel eine separate Instanz leeren Inhalts hinzuzufügen?</font></font></b> <div class="spoiler_text">       ,               .         .  ,        - , , , ,    .     ,       .     ,        ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lassen Sie uns ein Factory-Asset erstellen und seine Links zu Fertighäusern konfigurieren. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7eb/75f/1cd/7eb75f1cd4bed3c72ffd7f0c42b69cbe.png" width="320" height="106"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhaltsfabrik </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und dann den </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zur Fabrik weitergeben.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContentFactory tileContentFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/d6a/506/b12d6a5067fa91177dbed14a876f8b3d.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spiel mit einer Fabrik.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine Fliese antippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Feld zu ändern, müssen wir in der Lage sein, eine Kachel auszuwählen. Wir werden es im Spielemodus ermöglichen. Wir werden einen Strahl in die Szene an der Stelle senden, an der der Spieler auf das Spielfenster geklickt hat. Wenn sich der Strahl mit dem Plättchen schneidet, hat der Spieler es berührt, dh es muss geändert werden. </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">übernimmt die Eingabe des Spielers, ist jedoch dafür verantwortlich zu bestimmen, welches Plättchen der Spieler berührt hat </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht alle Strahlen schneiden sich mit der Kachel, daher erhalten wir manchmal nichts. Daher fügen wir der </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode hinzu </font></font><code>GetTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die immer immer anfänglich zurückgibt </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dies bedeutet, dass die Kachel nicht gefunden wurde).</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um festzustellen, ob ein Strahl eine Kachel überschritten hat, müssen wir </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Strahl als Argument angeben. </font><font style="vertical-align: inherit;">Es gibt Informationen darüber zurück, ob es eine Kreuzung gab. </font><font style="vertical-align: inherit;">Wenn ja, können wir die Kachel zurückgeben, obwohl wir noch nicht wissen, welche, also werden wir sie vorerst zurückgeben </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryGetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um herauszufinden, ob es eine Kreuzung mit einer Kachel gab, benötigen wir weitere Informationen über die Kreuzung. </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann diese Informationen mit dem zweiten Parameter bereitstellen </font></font><code>RaycastHit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist der Ausgabeparameter, der durch das Wort </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">davor </font><font style="vertical-align: inherit;">angezeigt wird </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies bedeutet, dass ein Methodenaufruf der Variablen, die wir an sie übergeben, einen Wert zuweisen kann.</font></font><br><br><pre> <code class="cs hljs"> RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir können die Deklaration der Variablen einbetten, die für die Ausgabeparameter verwendet werden. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist uns egal, mit welchem ​​Collider die Kreuzung aufgetreten ist, wir verwenden nur die XZ-Kreuzungsposition, um die Kachel zu bestimmen. </font><font style="vertical-align: inherit;">Wir erhalten die Koordinaten der Kachel, indem wir den Koordinaten des Schnittpunkts die halbe Größe des Feldes hinzufügen und dann die Ergebnisse in ganzzahlige Werte konvertieren. </font><font style="vertical-align: inherit;">Der endgültige Kachelindex ist die X-Koordinate plus die Y-Koordinate multipliziert mit der Feldbreite.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist jedoch nur möglich, wenn die Koordinaten der Kachel innerhalb des Feldes liegen. Wir werden dies überprüfen. </font><font style="vertical-align: inherit;">Ist dies nicht der Fall, wird die Kachel nicht zurückgegeben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; size.x &amp;&amp; y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y &lt; size.y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhaltsänderung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Eigenschaft </font><font style="vertical-align: inherit;">hinzu, damit Sie den Inhalt der Kachel ändern können </font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sein Getter gibt einfach den Inhalt zurück, und der Setter verwirft den vorherigen Inhalt, falls vorhanden, und platziert den neuen Inhalt.</font></font><br><br><pre> <code class="cs hljs"> GameTileContent content; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContent Content { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; content; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { content.Recycle(); } content = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; content.transform.localPosition = transform.localPosition; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist der einzige Ort, an dem Sie den Inhalt überprüfen müssen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da wir anfangs keinen Inhalt haben. </font><font style="vertical-align: inherit;">Um dies zu gewährleisten, führen wir assert aus, damit der Setter nicht mit aufgerufen wird </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Null assigned to content!"</span></span>); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und schließlich brauchen wir eine Spielereingabe. </font><font style="vertical-align: inherit;">Das Konvertieren eines Mausklicks in einen Strahl kann durch Aufrufen </font></font><code>ScreenPointToRay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit </font></font><code>Input.mousePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Argument erfolgen. </font><font style="vertical-align: inherit;">Der Anruf muss für die Hauptkamera getätigt werden, auf die über zugegriffen werden kann </font></font><code>Camera.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fügen Sie dazu die Eigenschaft c hinzu </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> Ray TouchRay =&gt; Camera.main.ScreenPointToRay(Input.mousePosition);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anschließend fügen wir eine Methode hinzu </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit der überprüft wird, ob während des Upgrades die Hauptmaus-Taste gedrückt wurde. </font><font style="vertical-align: inherit;">Rufen Sie dazu </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit Null als Argument auf. </font><font style="vertical-align: inherit;">Wenn die Taste gedrückt wurde, verarbeiten wir die Berührung des Spielers, dh wir nehmen das Plättchen vom Feld und legen den Endpunkt als Inhalt fest, wobei wir es ab Werk nehmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { tile.Content = tileContentFactory.Get(GameTileContentType.Destination); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt können wir jede Kachel durch Drücken des Cursors in einen Endpunkt verwandeln. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/f15/da3/99af15da39bfc08cb8886b98e0ae15df.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrere Endpunkte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld richtig machen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir Kacheln in Endpunkte verwandeln können, hat dies bisher keine Auswirkungen auf die Pfade. </font><font style="vertical-align: inherit;">Außerdem haben wir noch keinen leeren Inhalt für Kacheln festgelegt. </font><font style="vertical-align: inherit;">Die Richtigkeit und Integrität des Feldes zu wahren </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">ist eine Aufgabe </font><font style="vertical-align: inherit;">. Geben wir ihm also die Verantwortung, den Inhalt der Kachel festzulegen. </font><font style="vertical-align: inherit;">Um dies zu implementieren, geben wir ihm über seine Methode einen Link zur Content Factory </font></font><code>Intialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verwenden ihn, um allen Kacheln eine Instanz leeren Inhalts zu geben.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory contentFactory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contentFactory = contentFactory; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … tile.Content = contentFactory.Get(GameTileContentType.Empty); } } FindPaths(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt muss ich </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meine Fabrik auf das Feld verlegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum nicht ein Game Factory-Feld zum GameBoard hinzufügen?</font></font></b> <div class="spoiler_text">   ,    ,   .        ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir jetzt mehrere Endpunkte haben, ändern wir diese </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass sie </font></font><code>BecomeDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jeweils aufgerufen werden und alle an der Grenze hinzugefügt werden. </font><font style="vertical-align: inherit;">Und das ist alles, was Sie brauchen, um mehrere Endpunkte zu unterstützen. </font><font style="vertical-align: inherit;">Alle anderen Kacheln werden wie gewohnt gelöscht. </font><font style="vertical-align: inherit;">Dann löschen wir den fest eingestellten Endpunkt in der Mitte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.BecomeDestination(); searchFrontier.Enqueue(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.ClearPath(); } } <span class="hljs-comment"><span class="hljs-comment">//tiles[tiles.Length / 2].BecomeDestination(); //searchFrontier.Enqueue(tiles[tiles.Length / 2]); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jedoch Kacheln in Endpunkte verwandeln können, sollten wir in der Lage sein, den umgekehrten Vorgang auszuführen und Endpunkte in leere Kacheln umzuwandeln. </font><font style="vertical-align: inherit;">Aber dann können wir ein Feld ohne Endpunkte bekommen. </font><font style="vertical-align: inherit;">In diesem Fall kann </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seine Aufgabe nicht ausgeführt werden. </font><font style="vertical-align: inherit;">Dies geschieht, wenn der Rand nach der Pfadinitialisierung für alle Zellen leer ist. </font><font style="vertical-align: inherit;">Wir bezeichnen dies als einen ungültigen Zustand des Feldes, </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der die Ausführung </font><font style="vertical-align: inherit;">zurückgibt </font><font style="vertical-align: inherit;">und abschließt. </font><font style="vertical-align: inherit;">Andernfalls kehren Sie am Ende zurück </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg, Unterstützung für das Entfernen von Endpunkten zu implementieren, sodass es sich um eine Switch-Operation handelt. Durch Klicken auf die leeren Kacheln werden sie in Endpunkte umgewandelt, und durch Klicken auf die Endpunkte werden sie gelöscht. Jetzt wird der Inhalt geändert </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und wir geben ihm eine allgemeine Methode, </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deren Parameter die Kachel ist. Wenn die Kachel der Endpunkt ist, machen Sie sie leer und rufen Sie auf </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ansonsten machen wir es zum Endpunkt und nennen es auch </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hinzufügen eines Endpunkts kann niemals einen ungültigen Feldstatus erzeugen, und das Löschen eines Endpunkts kann dies. </font><font style="vertical-align: inherit;">Daher werden wir prüfen, ob die Ausführung erfolgreich war, </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nachdem wir die Kachel leer gemacht haben. </font><font style="vertical-align: inherit;">Wenn nicht, brechen Sie die Änderung ab, drehen Sie die Kachel zurück zum Endpunkt und rufen Sie erneut </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf, um zum vorherigen korrekten Status zurückzukehren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann die Validierung effizienter gestaltet werden?</font></font></b> <div class="spoiler_text">      ,      .           ,   .  ,          .        <code>FindPaths</code> ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können wir </font><font style="vertical-align: inherit;">am Ende </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit der zentralen Kachel als Argument aufrufen, anstatt explizit aufzurufen </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist das einzige Mal, dass wir mit einem ungültigen Feldstatus beginnen, aber wir werden garantiert mit dem richtigen Status enden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-comment"><span class="hljs-comment">//FindPaths(); ToggleDestination(tiles[tiles.Length / 2]); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich erzwingen wir den </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufruf, </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anstatt den Inhalt der Kachel selbst festzulegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tile.Content = //tileContentFactory.Get(GameTileContentType.Destination); board.ToggleDestination(tile); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/685/8a9/8326858a93b938353376ff97259df1a7.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrere Endpunkte mit korrekten Pfaden.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sollten wir Game nicht verbieten, den Inhalt der Kachel direkt festzulegen?</font></font></b> <div class="spoiler_text">   .       .       ,   <code>Game</code>             .    ,      . </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Wände </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ziel der Turmverteidigung ist es, zu verhindern, dass Feinde den Endpunkt erreichen. </font><font style="vertical-align: inherit;">Dieses Ziel wird auf zwei Arten erreicht. </font><font style="vertical-align: inherit;">Erstens töten wir sie und zweitens verlangsamen wir sie, damit mehr Zeit bleibt, sie zu töten. </font><font style="vertical-align: inherit;">Auf dem Kachelfeld kann die Zeit verlängert werden, wodurch sich die Entfernung erhöht, die Feinde benötigen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem Hindernisse auf dem Feld platziert werden. </font><font style="vertical-align: inherit;">Normalerweise sind dies Türme, die auch Feinde töten, aber in diesem Tutorial beschränken wir uns nur auf Mauern.</font></font><br><br><h3>  Inhalt </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände sind eine andere Art von Inhalten. Fügen wir </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ihnen also ein Element hinzu.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie dann das Wandfertigteil. </font><font style="vertical-align: inherit;">Dieses Mal erstellen wir ein Spielobjekt mit dem Inhalt der Kachel und fügen einen untergeordneten Würfel hinzu, der sich oben auf dem Feld befindet und die gesamte Kachel ausfüllt. </font><font style="vertical-align: inherit;">Machen Sie es eine halbe Einheit hoch und speichern Sie den Collider, da die Wände einen Teil der dahinter liegenden Fliesen optisch überlappen können. </font><font style="vertical-align: inherit;">Wenn ein Spieler eine Wand berührt, beeinflusst er daher das entsprechende Plättchen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a33/779/1d3a33779b0c4d49f8ab4fed3d8abd20.png" width="320" height="176" alt="Wurzel"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/b5c/9f6/431b5c9f65000bab15dd9e1eed14696d.png" width="320" height="226" alt="Würfel"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6b/875/3b2/e6b8753b2e9b954b55a4a3a6e0154560.png" width="225" height="60" alt="Fertighaus"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighaus. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie das Wandfertigteil sowohl im Code als auch im Inspektor zur Fabrik hinzu.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent wallPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/eaa/50f/262eaa50f1bf4f80b2d2861d6232368b.png" width="320" height="80"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabrik mit vorgefertigter Wand.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wände ein- und ausschalten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Ein / Aus-Methode der Wände hinzu, wie wir es für den Endpunkt getan haben. </font><font style="vertical-align: inherit;">Zunächst werden wir den falschen Status des Feldes nicht überprüfen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Wall); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bieten Unterstützung für das Umschalten nur zwischen leeren Kacheln und Wandkacheln, sodass Wände Endpunkte nicht direkt ersetzen können. </font><font style="vertical-align: inherit;">Daher erstellen wir nur dann eine Wand, wenn die Kachel leer ist. </font><font style="vertical-align: inherit;">Außerdem sollten die Wände die Suche nach dem Pfad blockieren. </font><font style="vertical-align: inherit;">Aber jedes Plättchen muss einen Pfad zum Endpunkt haben, sonst bleiben die Feinde stecken. </font><font style="vertical-align: inherit;">Dazu müssen wir erneut die Validierung verwenden </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Änderungen verwerfen, wenn sie einen falschen Feldstatus erstellt haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Wall); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ein- und Ausschalten von Wänden wird viel häufiger verwendet als das Ein- und Ausschalten von Endpunkten. Daher werden wir das Umschalten von Wänden zum </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptanliegen machen. </font><font style="vertical-align: inherit;">Die Endpunkte können durch eine zusätzliche Berührung (normalerweise die rechte Maustaste) umgeschaltet werden, die durch Übergabe an einen </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert von 1 </font><font style="vertical-align: inherit;">erkannt werden kann </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { HandleAlternativeTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleDestination(tile); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleWall(tile); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d62/e45/4e9/d62e454e94a659dd9da841a915a93dac.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir die Wände.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum bekomme ich große Lücken zwischen den Schatten diagonal benachbarter Wände?</font></font></b> <div class="spoiler_text">  ,          ,    ,   .   ,   ,  far clipping plane      . ,   far plane  20      .  ,         MSAA,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen wir außerdem sicher, dass Endpunkte Wände nicht direkt ersetzen können. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pfadsuchensperre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit die Wände die Suche nach dem Pfad blockieren, müssen wir dem Suchrahmen keine Kacheln mit Wänden hinzufügen. </font><font style="vertical-align: inherit;">Dies kann erreicht werden, indem gezwungen wird, </font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keine Fliesen mit Wänden zurückzugeben. </font><font style="vertical-align: inherit;">Der Pfad sollte jedoch immer noch in Richtung der Wand wachsen, damit alle Kacheln auf dem Feld einen Pfad haben. </font><font style="vertical-align: inherit;">Dies ist notwendig, da es möglich ist, dass ein Plättchen mit Feinden plötzlich zu einer Wand wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen, dass alle Kacheln einen Pfad haben, </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">müssen </font><font style="vertical-align: inherit;">sie </font><font style="vertical-align: inherit;">diesen nach Abschluss der Suche überprüfen. </font><font style="vertical-align: inherit;">Ist dies nicht der Fall, ist der Status des Feldes ungültig und muss zurückgegeben werden </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es ist nicht erforderlich, die Pfadvisualisierung für ungültige Zustände zu aktualisieren, da das Feld zum vorherigen Zustand zurückkehrt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tile.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/ff2/c3e/cc3ff2c3e52a087d9fa757d5760623d6.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wände beeinflussen den Weg. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen, dass die Wände tatsächlich die richtigen Wege haben, müssen Sie die Würfel durchscheinend machen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9b/2f6/70c/d9b2f670c9bcf0fc568c1484750c2e77.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transparente Wände. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass das Erfordernis der Richtigkeit aller Pfade nicht zulässt, dass Wände einen Teil des Feldes einschließen, in dem es keinen Endpunkt gibt. </font><font style="vertical-align: inherit;">Wir können die Karte teilen, aber nur, wenn in jedem Teil mindestens ein Endpunkt vorhanden ist. </font><font style="vertical-align: inherit;">Außerdem muss jede Wand an eine leere Kachel oder einen leeren Endpunkt angrenzen, da sie sonst keinen Pfad haben kann. </font><font style="vertical-align: inherit;">Zum Beispiel ist es unmöglich, einen festen Block aus 3 × 3 Wänden herzustellen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versteck den Weg </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch die Visualisierung der Pfade können wir sehen, wie die Pfadsuche funktioniert, und sicherstellen, dass sie tatsächlich korrekt ist. </font><font style="vertical-align: inherit;">Aber es muss dem Spieler nicht gezeigt werden oder zumindest nicht unbedingt. </font><font style="vertical-align: inherit;">Lassen Sie uns daher die Möglichkeit bieten, die Pfeile auszuschalten. </font><font style="vertical-align: inherit;">Dies kann durch Hinzufügen zur </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Methode erfolgen </font></font><code>HidePath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bei der der Pfeil einfach deaktiviert wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HidePath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Pfadzuordnungsstatus ist Teil des Feldstatus. </font><font style="vertical-align: inherit;">Fügen Sie </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Standard </font><font style="vertical-align: inherit;">ein </font><font style="vertical-align: inherit;">boolesches Feld hinzu, das </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Status entspricht, sowie eine gemeinsame Eigenschaft als Getter und Setter. </font><font style="vertical-align: inherit;">Der Setter muss Pfade auf allen Kacheln ein- oder ausblenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowPaths { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showPaths; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showPaths = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.HidePath(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sollte die Methode </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur dann aktualisierte Pfade anzeigen, wenn das Rendern aktiviert ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardmäßig ist die Pfadvisualisierung deaktiviert. </font><font style="vertical-align: inherit;">Schalten Sie den Pfeil in der Kachelfertigung aus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5a/c71/802/a5ac718028d1bb41c145dfabba9051e1.png" width="320" height="44"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Fertighauspfeil ist standardmäßig inaktiv. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen es so, dass es </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Visualisierungsstatus ändert, wenn eine Taste gedrückt wird. </font><font style="vertical-align: inherit;">Es wäre logisch, die P-Taste zu verwenden, aber es ist auch ein Hotkey zum Aktivieren / Deaktivieren des Spielemodus im Unity-Editor. </font><font style="vertical-align: inherit;">Infolgedessen wechselt die Visualisierung, wenn der Hotkey zum Verlassen des Spielemodus verwendet wird, was nicht sehr gut aussieht. </font><font style="vertical-align: inherit;">Verwenden wir also die V-Taste (kurz für Visualisierung).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/a96/15c/a9ca9615c10cdab502f1769443ad6b38.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine Pfeile.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rasteranzeige </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Pfeile ausgeblendet sind, wird es schwierig, die Position jeder Kachel zu erkennen. </font><font style="vertical-align: inherit;">Fügen wir die Gitterlinien hinzu. </font><font style="vertical-align: inherit;">Laden Sie </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daher</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textur mit einem quadratischen Grenze Netz , </font><font style="vertical-align: inherit;">die als eine einzelne Fliese Kontur verwendet werden können.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/e98/483/4c1e984836babfc368136b83ac2b195b.png" width="128" height="128"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maschentextur.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden diese Textur nicht einzeln zu jeder Fliese hinzufügen, sondern auf den Boden auftragen. Wir werden dieses Raster jedoch optional machen sowie die Visualisierung von Pfaden. Daher werden wir </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Konfigurationsfeld </font><font style="vertical-align: inherit;">hinzufügen </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und eine Netztextur dafür auswählen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Texture2D gridTexture = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed4/99a/28e/ed499a28e82a3328c010a71ba1085316.png" width="320" height="94"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld mit Netzstruktur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie ein weiteres boolesches Feld und eine Eigenschaft hinzu, um den Status der Rastervisualisierung zu steuern. </font><font style="vertical-align: inherit;">In diesem Fall muss der Setter das Material der Erde ändern, was durch Aufrufen der </font></font><code>GetComponent&lt;MeshRenderer&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erde und Zugriff auf die Eigenschaft des </font></font><code>material</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisses </font><font style="vertical-align: inherit;">implementiert werden kann </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn das Raster angezeigt werden muss, weisen wir die </font></font><code>mainTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rastertextur </font><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Materialeigenschaft zu. </font><font style="vertical-align: inherit;">Andernfalls weisen Sie es ihm zu </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Beachten Sie, dass beim Ändern der Textur des Materials Duplikate der Materialinstanz erstellt werden, sodass diese unabhängig vom Materialelement wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showGrid, showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowGrid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showGrid; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showGrid = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Material m = ground.GetComponent&lt;MeshRenderer&gt;().material; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m.mainTexture = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Visualisierung des Gitters mit der G-Taste umschalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.G)) { board.ShowGrid = !board.ShowGrid; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie außerdem die Standard-Netzvisualisierung hinzu </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b04/145/190/b04145190e5d8f15972f25374d7f5813.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unskaliertes Gitter. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir eine Grenze um das gesamte Feld. </font><font style="vertical-align: inherit;">Es passt zur Textur, aber das brauchen wir nicht. </font><font style="vertical-align: inherit;">Wir müssen die Haupttextur des Materials so skalieren, dass sie der Größe des Gitters entspricht. </font><font style="vertical-align: inherit;">Sie können dies tun, indem Sie die </font></font><code>SetTextureScale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materialmethode mit dem Namen der Textur-Eigenschaft ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und der zweidimensionalen Größe </font><em><font style="vertical-align: inherit;">aufrufen</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir können direkt die Größe des Feldes verwenden, das indirekt in einen Wert umgewandelt wird </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; m.SetTextureScale(<span class="hljs-string"><span class="hljs-string">"_MainTex"</span></span>, size); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d2a/b85/edbd2ab858e40a61d5f89452a8809b33.png" width="230" height="230" alt="ohne"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/91a/ae5/8bd91aae589309dbd64994bb10a935a9.png" width="230" height="230" alt="mit"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skaliertes Raster mit ein- und ausgeschalteter Pfadvisualisierung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt haben wir also ein funktionierendes Feld für ein Kachelspiel des Tower Defense-Genres. </font><font style="vertical-align: inherit;">Im nächsten Tutorial werden wir Feinde hinzufügen. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pdf</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449798/">https://habr.com/ru/post/de449798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449784/index.html">In welchen Fällen lohnt es sich, Django zu verwenden (und in welchen Fällen ist es nicht notwendig)</a></li>
<li><a href="../de449788/index.html">Brave Browser stellt eine belohnungsbasierte Werbeplattform vor</a></li>
<li><a href="../de449790/index.html">Produktentwicklung Visual Aid: Design</a></li>
<li><a href="../de449794/index.html">Adaptive Antennenarrays: Wie funktioniert es? (Grundlagen)</a></li>
<li><a href="../de449796/index.html">Über ein Mädchen</a></li>
<li><a href="../de449802/index.html">Karriereprogrammierer. Teil 1. Das erste Programm</a></li>
<li><a href="../de449804/index.html">Überblick über die Anti-Aging-Therapie für Biohacker</a></li>
<li><a href="../de449806/index.html">Karriereprogrammierer. Teil 2. Schule oder Selbstbildung</a></li>
<li><a href="../de449808/index.html">Positive Hack Days 9 Experiment: Wie kritisches Denken in Leben und Arbeiten hilft</a></li>
<li><a href="../de449814/index.html">Windows XP ist jetzt endlich offiziell tot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>