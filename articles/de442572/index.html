<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞üèæ üë©üèΩ‚Äçüè´ üéÄ Verwenden des Datapath Config Tools ü§ûüèª üë®‚ÄçüöÄ üìí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir m√ºssen den vorletzten Schritt in der praktischen Entwicklung der Arbeit mit UDB machen. Heute werden wir nicht mit dem automatisierten UDB-Editor ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden des Datapath Config Tools</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442572/"><img src="https://habrastorage.org/webt/fu/yo/23/fuyo230rbfhla_li8ryzzngttlw.jpeg"><br><br>  Wir m√ºssen den vorletzten Schritt in der praktischen Entwicklung der Arbeit mit UDB machen.  Heute werden wir nicht mit dem automatisierten UDB-Editor entwickeln, sondern im halbmanuellen Modus mit dem Datapath Config Tool.  Eine sehr gute Hilfe bei der Beherrschung dieses Tools ist AN82156 - PSoC 3, PSoC 4 und PSoC 5LP - Entwerfen von PSoC Creator-Komponenten mit UDB-Datenpfaden.  Eigentlich habe ich es selbst studiert. <br><a name="habracut"></a><br>  Vielleicht hat jemand beim Lesen unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzungen der Dokumentation zu UDB</a> versucht, das Wissen von dort in die Praxis umzusetzen, und festgestellt, dass nicht alle in den Ver√∂ffentlichungen beschriebenen Funktionen im UDB-Editor verf√ºgbar sind.  Dies liegt an der Tatsache, dass die Entwickler einige besonders umst√§ndliche Mechanismen nicht in den UDB-Editor eingef√ºgt haben.  Die Autoren von AN82156 argumentieren, dass Sie √ºber den UDB-Editor Folgendes nicht tun k√∂nnen: <br><br><ul><li>  parallele Dateneingabe und -ausgabe organisieren; </li><li>  dynamisches FIFO-Management organisieren; </li><li>  Implementieren der Umkehrung des FIFO-Taktsignals; </li><li>  Implementieren Sie die CRC-Funktion. </li><li>  Implementieren Sie die PRS-Funktion. </li><li>  die Wahl der eingehenden √úbertragung implementieren; </li><li>  Implementieren Sie eine dynamische eingehende Migration. </li></ul><br>  Ich selbst m√∂chte hinzuf√ºgen, dass ich nicht herausgefunden habe, wie die Permutation von Knabbereien im UDB-Editor implementiert werden kann. <br><br>  Wenn diese Funktionen im Projekt ben√∂tigt werden, m√ºssen Sie Ihren eigenen Verilog-Code erstellen.  Ich habe speziell das Wort "erstellen" anstelle von "schreiben" verwendet.  Die Kenntnis dieser Programmiersprache reicht auf Leseebene aus.  Ich meine, Sie m√ºssen verstehen, welches Design f√ºr was ben√∂tigt wird.  Es ist immer n√ºtzlich, von Grund auf neu schreiben zu k√∂nnen, aber diese F√§higkeit ist f√ºr das, was in diesem Artikel vorgestellt wird, nicht erforderlich. <br><br>  Als l√∂sbares Problem habe ich einen halbsynthetischen Fall gew√§hlt.  Im Allgemeinen habe ich mich entschlossen, einige Daten an den parallelen Anschluss auszugeben, und insbesondere hat das Text-LCD einen parallelen Anschluss.  Ich habe es vor drei Jahren aus dem MZ3D 3D-Drucker gezogen, als ich letzteres auf STM32 transplantiert habe.  Daher ist der Fall halbsynthetisch: Heutzutage haben solche Indikatoren normalerweise einen I2C-Eingang und m√ºssen im wirklichen Leben nicht √ºber einen Stapel von Dr√§hten verbunden werden.  Moderne LCDs verf√ºgen jedoch auch √ºber parallele Anschl√ºsse, sodass jeder das Experiment wiederholen kann. <br><br>  Betrachten Sie das von reprap.org √ºbernommene Schema zum Umschalten der Anzeige (dies war nicht einfach, mein Provider blockiert diese Site sowie eine Reihe anderer technischer Websites und motiviert sie damit, dass sie auf derselben IP-Adresse wie eine blockierte Person leben). <br><br><img src="https://habrastorage.org/webt/0x/th/ry/0xthryzxadx_9guzmhdyhrxnzty.png"><br><br>  Tolles Layout!  Erstens muss ich nicht √ºber das Lesen nachdenken: Daten auf dem LCD k√∂nnen nur geschrieben werden (die R / W-Leitung ist geerdet und am Stecker nicht verf√ºgbar).  Zweitens liegen die Daten in einem 4-Bit-Format vor, was bedeutet, dass wir nicht nur die parallele Ausgabe berechnen, sondern auch die Funktion der Nibble-Permutationsfunktion √ºberpr√ºfen k√∂nnen. <br><br><h2>  Projekterstellung </h2><br>  Starten Sie also PSoC Creator und w√§hlen Sie <b>Datei-&gt; Neu-&gt; Projekt</b> : <br><br><img src="https://habrastorage.org/webt/pv/ma/tv/pvmatvfviveyo4fa822osy45p2c.png"><br><br>  Als n√§chstes w√§hle ich mein Steckbrett: <br><br><img src="https://habrastorage.org/webt/dv/st/hi/dvsthib82j6ynrdxc0sk-5j20nk.png"><br><br>  Als n√§chstes ist das leere Diagramm: <br><br><img src="https://habrastorage.org/webt/oi/fx/vv/oifxvvsf0qye7j-mdyoxmbfux4q.png"><br><br>  Ich werde das Projekt <b>LCDTest2 nennen</b> : <br><br><img src="https://habrastorage.org/webt/qs/3f/rl/qs3frlgxrnzqzqrzzfryptvjfqq.png"><br><br>  Wechseln Sie nun wie zuvor zur Registerkarte <b>Komponenten</b> : <br><br><img src="https://habrastorage.org/webt/wq/nb/bo/wqnbboubijieyovk7akrat6piik.png"><br><br>  Nachdem Sie das Projekt ausgew√§hlt haben, dr√ºcken Sie die rechte Maustaste und w√§hlen <b>Sie dann Komponentenelement hinzuf√ºgen</b> . <br><br><img src="https://habrastorage.org/webt/hi/fu/hv/hifuhvearnltnfz2dvmhwtzgw4o.png"><br><br>  Und hier m√ºssen Sie den <b>Symbol-Assistenten</b> ausw√§hlen.  Geben Sie einen Namen ... Nun, sagen wir <b>LCD4bit</b> . <br><br><img src="https://habrastorage.org/webt/59/f0/g3/59f0g3lya8ado4kcxgj6lcsxggk.png"><br><br>  Ich habe dem Symbol folgende Ports zugewiesen: <br><br><img src="https://habrastorage.org/webt/6a/jr/uo/6ajruo1io2jusjunhameiumtb20.png"><br><br>  <b>clk</b> ist der Takteingang.  Ports mit einem LCD-Pr√§fix sind Standard-LCD-Ports.  <b>hungrige</b> Ausg√§nge, die der DMA-Einheit mitteilen, dass im FIFO freier Speicherplatz vorhanden ist, wurden in einem Artikel √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Steuerung von RGB-LEDs</a> er√∂rtert.  Klicken Sie auf OK, um den Charakter zu erhalten. <br><br><img src="https://habrastorage.org/webt/ze/fq/5z/zefq5z65eq0i4mq21y2d3jip7t4.png"><br><br>  Basierend auf diesem Symbol sollte nun eine Verilog-Vorlage generiert werden.  Klicken Sie mit der rechten Maustaste in der N√§he des Symbols und w√§hlen <b>Sie</b> im Kontextmen√º die <b>Option Verilog generieren</b> . <br><br><img src="https://habrastorage.org/webt/h9/k7/oo/h9k7oogp_wqsdfugdg-8bdr_hru.png"><br><br>  Wir haben die in der folgenden Abbildung gezeigte Vorlage (in Textform macht sie noch keinen Sinn): <br><br><img src="https://habrastorage.org/webt/ax/t9/k-/axt9k-s-zfi2kfd7qdz9pe-zlqq.png"><br><br>  Wir haben ein Modul und einige Abschnitte erstellt.  Sie haben Datapath jedoch noch nicht erstellt.  Um es hinzuzuf√ºgen, gehen Sie zum Projektbaum, w√§hlen Sie die Datei <b>LCD4bit.v aus</b> , dr√ºcken Sie die rechte Maustaste und w√§hlen Sie das <b>Datapath Config Tool</b> im <b>angezeigten</b> Kontextmen√º: <br><br><img src="https://habrastorage.org/webt/z2/1g/5w/z21g5wom4_-yq_nmcjlhvb3irg0.png"><br><br>  Vor uns √∂ffnet sich ein Fenster, das ich vorerst nur teilweise zeigen werde: <br><br><img src="https://habrastorage.org/webt/m0/fz/9i/m0fz9idl6xt5rimcittxpme2iea.png"><br><br>  Bitte lieben und bevorzugen, Datapath Editor.  Es enth√§lt alle Bits, die in der √úbersetzung der propriet√§ren Dokumentation beschrieben wurden.  Aber es gibt so viele dieser Teile, dass ich ihn in den fr√ºhen Tagen ansah, aber Angst hatte, irgendetwas zu tun.  Schau, schau und geh raus.  Und erst nach einiger Zeit, als er sich daran gew√∂hnt hatte, versuchte er etwas zu tun.  Deshalb habe ich nur einen Teil des Fensters mitgebracht.  Warum alle vorzeitig erschrecken?  In der Zwischenzeit m√ºssen wir nur einen Datenpfad erstellen, also w√§hlen wir den Men√ºpunkt <b>Bearbeiten-&gt; Neuer Datenpfad</b> : <br><br><img src="https://habrastorage.org/webt/-n/dx/vj/-ndxvjk_wrpdjucuq0_c3jcqfai.png"><br><br>  Welche Option k√∂nnen Sie im angezeigten Dialogfeld ausw√§hlen? <br><br><img src="https://habrastorage.org/webt/wf/ma/kf/wfmakfepho5l4h4nxffpua7wgok.png"><br><br>  Die Frage ist etwas ernster als es scheint.  Lassen Sie mich sogar den n√§chsten Absatz hervorheben, damit niemand erwischt wird (ich habe mich selbst erwischt, und dann habe ich im Netzwerk Fragen von denen gesehen, die ich erhalten habe, und niemand hat sie wirklich beantwortet, und die Antwort ist in <b>AN82156</b> , Sie m√ºssen sie nur diagonal lesen, wie es dort steht kurze unauff√§llige Phrase). <br><blockquote>  Wenn Sie mit parallelen Daten arbeiten m√∂chten, m√ºssen Sie auf jeden Fall die Option CY_PSOC3_DP w√§hlen.  Keine andere Option enth√§lt Ports zum Verbinden paralleler Daten. </blockquote>  Also.  Lassen Sie die Instanz LCD_DP hei√üen: <br><br><img src="https://habrastorage.org/webt/tf/a3/hs/tfa3hsi-mu2ljvyeukwmprwlm_4.png"><br><br>  Klicken Sie auf OK und schlie√üen Sie das <b>Datapath Config Tool</b> , um das Ergebnis zu speichern.  Wir werden sp√§ter hierher zur√ºckkommen. <br><br>  Unser Verilog-Code wurde erweitert.  Jetzt hat es Datapath.  Sein Anfang ist v√∂llig unlesbar.  Es ist nicht be√§ngstigend, es wird vom <b>Datapath Config Tool</b> konfiguriert. <br><br><img src="https://habrastorage.org/webt/tz/d9/ur/tzd9urfa66hsfic2w9gsn6tkysu.png"><br><br>  Und wir werden das Ende der Datenpfadbeschreibung regieren.  Unsere Seite sieht so aus <div class="spoiler">  <b class="spoiler_title">(Ab diesem Punkt ist es sinnvoll, alles in Textform zu bringen).</b> <div class="spoiler_text"><pre><code class="plaintext hljs">)) LCD_DP( /* input */ .reset(1'b0), /* input */ .clk(1'b0), /* input [02:00] */ .cs_addr(3'b0), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0), /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(), /* output */ .f0_blk_stat(), /* output */ .f1_bus_stat(), /* output */ .f1_blk_stat(), /* input */ .ci(1'b0), // Carry in from previous stage /* output */ .co(), // Carry out to next stage /* input */ .sir(1'b0), // Shift in from right side /* output */ .sor(), // Shift out to right side /* input */ .sil(1'b0), // Shift in from left side /* output */ .sol(), // Shift out to left side /* input */ .msbi(1'b0), // MSB chain in /* output */ .msbo(), // MSB chain out /* input [01:00] */ .cei(2'b0), // Compare equal in from prev stage /* output [01:00] */ .ceo(), // Compare equal out to next stage /* input [01:00] */ .cli(2'b0), // Compare less than in from prv stage /* output [01:00] */ .clo(), // Compare less than out to next stage /* input [01:00] */ .zi(2'b0), // Zero detect in from previous stage /* output [01:00] */ .zo(), // Zero detect out to next stage /* input [01:00] */ .fi(2'b0), // 0xFF detect in from previous stage /* output [01:00] */ .fo(), // 0xFF detect out to next stage /* input [01:00] */ .capi(2'b0), // Software capture from previous stage /* output [01:00] */ .capo(), // Software capture to next stage /* input */ .cfbi(1'b0), // CRC Feedback in from previous stage /* output */ .cfbo(), // CRC Feedback out to next stage /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po() // Parallel data port );</code> </pre> <br></div></div><br>  Be√§ngstigend  Jetzt werden wir herausfinden, was was ist - es wird aufh√∂ren, be√§ngstigend zu sein.  Tats√§chlich gibt es in diesem Text drei verschiedene Gruppen.  Erinnern wir uns an die √úbersetzung der Dokumentation.  Wie sah der Datenpfad auf dem Bild aus?  Ich werde in der Abbildung sofort die Orte vermerken, zu denen die Gruppen ‚Äû1‚Äú, ‚Äû2‚Äú und ‚Äû3‚Äú geh√∂ren. <br><br><img src="https://habrastorage.org/webt/ji/xe/5x/jixe5x_fxqpx6kgybrjmakagpw4.png"><br><br>  Tats√§chlich sind die Eingaben die erste Gruppe von Ports im Verilog-Code.  Vergleichen Sie die Namen am Ausgang des Eingangsmultiplexers (in der Abbildung ‚Äû1‚Äú) und die Namen der Signale im Code. <br><br>  Jetzt sind alle Eing√§nge Null.  Wir m√ºssen den Takteingang anschlie√üen und k√∂nnen bis zu sechs Eingangsleitungen weiterleiten, wie dies im UDB-Editor geschehen ist.  Diese Eingaben sind: <br><br><pre> <code class="plaintext hljs"> /* input */ .reset(1'b0), /* input */ .clk(1'b0), /* input [02:00] */ .cs_addr(3'b0), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0),</code> </pre><br>  Die zweite Gruppe sind die Ausg√§nge.  Die Namen im Code stimmen auch mit den Namen der Eing√§nge des Ausgangsmultiplexers "2" √ºberein: <br><br><pre> <code class="plaintext hljs"> /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(), /* output */ .f0_blk_stat(), /* output */ .f1_bus_stat(), /* output */ .f1_blk_stat(),</code> </pre><br>  Nur die angegebene Datapath-Art hat die dritte Gruppe (die anderen haben keine, daher gibt es keine parallelen Daten).  Dies sind interne Datenpfadsignale, √ºber die Sie unabh√§ngig voneinander verketten oder andere n√ºtzliche Aktionen ausf√ºhren k√∂nnen.  Die Namen im Code stimmen auch mit den Namen der in der Figur verstreuten internen Signale √ºberein.  Wir geben durch einen von ihnen (der letzte in der Liste, sein Name ist <b>po</b> ) parallele Daten direkt an die Beine des Chips aus. <br><br><pre> <code class="plaintext hljs"> /* input */ .ci(1'b0), // Carry in from previous stage /* output */ .co(), // Carry out to next stage /* input */ .sir(1'b0), // Shift in from right side /* output */ .sor(), // Shift out to right side /* input */ .sil(1'b0), // Shift in from left side /* output */ .sol(), // Shift out to left side /* input */ .msbi(1'b0), // MSB chain in /* output */ .msbo(), // MSB chain out /* input [01:00] */ .cei(2'b0), // Compare equal in from prev stage /* output [01:00] */ .ceo(), // Compare equal out to next stage /* input [01:00] */ .cli(2'b0), // Compare less than in from prv stage /* output [01:00] */ .clo(), // Compare less than out to next stage /* input [01:00] */ .zi(2'b0), // Zero detect in from previous stage /* output [01:00] */ .zo(), // Zero detect out to next stage /* input [01:00] */ .fi(2'b0), // 0xFF detect in from previous stage /* output [01:00] */ .fo(), // 0xFF detect out to next stage /* input [01:00] */ .capi(2'b0), // Software capture from previous stage /* output [01:00] */ .capo(), // Software capture to next stage /* input */ .cfbi(1'b0), // CRC Feedback in from previous stage /* output */ .cfbo(), // CRC Feedback out to next stage /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po() // Parallel data port );</code> </pre><br>  Also.  W√§hrend wir arbeiten, m√ºssen wir einige dieser Ein- und Ausg√§nge mit unseren eigenen Entit√§ten verbinden, und der Rest - lassen Sie sie einfach in der Form, in der wir sie erstellt haben. <br><br><h2>  Verwenden des UDB-Editors als Referenz </h2><br>  Und jetzt haben wir eine L√ºcke, wir wissen, wo und was wir schreiben m√ºssen.  Es bleibt zu verstehen, was genau wir dort eingeben werden.  Es kam vor, dass ich die Verilog-Sprache nicht jeden Tag verwende. Im Allgemeinen erinnere ich mich an alles, und das Schreiben von Grund auf ist f√ºr mich immer eine stressige Situation.  Wenn das Projekt bereits l√§uft, wird alles in Erinnerung behalten, aber wenn ich nach ein paar Monaten Inaktivit√§t etwas von vorne anfange, erinnere ich mich nat√ºrlich nicht mehr an die Syntaxdetails dieser bestimmten Sprache.  Daher schlage ich vor, die Entwicklungsumgebung zu bitten, uns zu helfen. <br><br>  Der UDB-Editor zur Selbst√ºberwachung erstellt Verilog-Code.  Wir nutzen die Tatsache, dass Komponenten, die nicht an der Hauptschaltung beteiligt sind, nicht kompiliert werden, sodass wir im UDB-Editor eine Hilfskomponente erstellen k√∂nnen, die nicht in den Ausgabecode gelangt.  Wir werden dort einen Automaten zeichnen, die Ein- und Ausg√§nge von Datapath grob anpassen und dann einfach den automatisch generierten Text in unser Verilog-Modul √ºbertragen und alles kreativ √§ndern.  Dies ist viel einfacher, als sich die Details der Verilog-Syntax zu merken und alles von Grund auf neu zu schreiben (obwohl jeder, der Verilog st√§ndig verwendet, nat√ºrlich einfacher von Grund auf neu schreiben kann: Die kreative Fertigstellung ist, wie wir bald sehen werden, einfach, erfordert jedoch Zeit). <br><br>  Also fangen wir an, eine Hilfskomponente herzustellen.  Mit der √ºblichen Handbewegung f√ºgen wir dem Projekt ein neues Element hinzu: <br><br><img src="https://habrastorage.org/webt/to/d2/fg/tod2fgx1opcdho2edizges-vr3q.png"><br><br>  Dies wird ein UDB-Dokument sein, nennen wir es <b>UDBhelper</b> : <br><br><img src="https://habrastorage.org/webt/j3/wt/iu/j3wtiuj2htdr-ct4f7m_3z497oi.png"><br><br>  Es ist Zeit, √ºber die Maschine nachzudenken, die wir auf dem erstellten Blatt platzieren werden.  Dazu m√ºssen wir uns √ºberlegen, welches Zeitdiagramm wir damit erstellen sollen: <br><br><img src="https://habrastorage.org/webt/rh/zj/da/rhzjdasl8ioia8n8okjuuaieft4.png"><br><br><img src="https://habrastorage.org/webt/dy/3a/0z/dy3a0zmkacoa4tvgaugebovdhqy.png"><br><br>  Also.  Zuerst m√ºssen Sie das RS-Signal einstellen (da R / W in der Hardware auf Null gel√∂tet ist).  Warten Sie als n√§chstes auf tAS, erh√∂hen Sie dann das Signal E und stellen Sie die Daten ein (die Dateneinstellung in Bezug auf die positive Flanke E ist nicht begrenzt).  Die Daten m√ºssen mindestens tDSW auf dem Bus sein, danach muss das Signal E gel√∂scht werden. Die Daten m√ºssen mindestens tDHW und mindestens tAH RS auf dem Bus bleiben. <br><br>  RS ist das Befehls- oder Datenflag.  Wenn RS Null ist, wird ein Befehl geschrieben, wenn es Eins ist, werden Daten geschrieben. <br><br>  Ich schlage vor, Befehle √ºber <b>FIFO0</b> und Daten √ºber <b>FIFO1 zu senden</b> .  Dies widerspricht im Rahmen der aktuellen Aufgabe nichts.  Dann hat die von mir vorgeschlagene endliche Zustandsmaschine die folgende Form: <br><br><img src="https://habrastorage.org/webt/jn/6y/6j/jn6y6jnzllwbwgmslak7nif1xmu.png"><br><br>  Im <b>Ruhezustand</b> befindet sich die Maschine noch in keinen FIFO-Daten.  Wenn Daten in <b>FIFO0</b> erschienen <b>sind</b> , gehen sie zu <b>LoadF0</b> , wo sie in Zukunft Daten von <b>FIFO0</b> nach A0 empfangen. <br><br>  W√§hrend die Befehle √ºbertragen werden, sollten die Daten nicht gesendet werden.  Daher hat die Bedingung zum Empfangen von Daten eine niedrigere Priorit√§t als die Bedingung zum Empfangen von Befehlen. <br><br><img src="https://habrastorage.org/webt/og/gn/fl/oggnfl3tcjcxa8pzu64qcj3yzpa.png"><br><br>  Daten werden in A1 im Zustand <b>LoadF1 empfangen</b> (von <b>FIFO1 k√∂nnen</b> sie nur zum Register A1 und nicht zum Register A0 gehen), und dann werden sie im Zustand <b>A1toA0</b> von A1 nach A0 <b>kopiert</b> . <br><br>  Wie auch immer wir zum Punkt der Konvergenz der Pfeile gehen, wir haben Daten in A0.  Sie werden bereits an die parallele Schnittstelle ausgegeben.  Wir <b>spannen</b> E (im Zustand <b>E_UP1</b> ), lassen E fallen (im Zustand <b>E_DOWN1</b> ).  Als n√§chstes haben wir einen Zustand zum Austauschen von Knabbereien ( <b>SWAP</b> ), wonach E wieder ansteigt ( <b>E_UP2</b> ).  In diesem Zusammenhang habe ich acht Zust√§nde ersch√∂pft, die in drei Bits codiert werden k√∂nnen.  Und wir erinnern uns, dass der dynamische Konfigurations-RAM von Datapath nur drei Adresseneing√§nge hat.  Einige Tricks k√∂nnten angewendet werden, aber der Artikel ist bereits gro√ü.  Daher werden wir E erst zum zweiten Mal in den <b>Ruhezustand</b> versetzen.  Dann reichen uns acht Staaten v√∂llig aus. <br><br>  Wir setzen auch Datapath auf das Blatt und weisen seine Ein- und Ausg√§nge auf eine Weise zu, die in den vorherigen Artikeln bekannt ist.  Hier sind die Eingaben: <br><br><img src="https://habrastorage.org/webt/ct/fn/0j/ctfn0jvexwfycfrdovbnatwv7ze.png"><br><br>  Hier sind die Ausg√§nge: <br><br><img src="https://habrastorage.org/webt/ct/mj/gd/ctmjgdzfvx-mz8qnzwbp6undlau.png"><br><br>  Nichts Neues, alles wurde bereits in fr√ºheren Artikeln des Zyklus beschrieben.  Wir haben also eine L√ºcke, auf deren Grundlage wir etwas Eigenes tun k√∂nnen.  Um sicherzustellen, dass alles l√§uft, m√ºssen wir unser System auf die oberste Ebene des Projekts bringen, sonst werden keine Fehler gefunden.  Und in den ersten Experimenten ohne Fehler wird nicht funktionieren.  Deshalb werden wir noch eine Hilfsaktion durchf√ºhren. <br><br>  Die Beschreibung, wie die Schaltung hergestellt wird, geht √ºber die Beschreibung der Arbeit mit UDB hinaus.  Ich zeige Ihnen nur, welche Schaltung ich habe.  Es gibt nur eine DMA-Einheit: Wenn Sie Befehle an das LCD senden, m√ºssen Sie gro√üen Pausen standhalten, sodass dies programmgesteuert noch einfacher ist.  F√ºr andere Anwendungen k√∂nnen Sie den zweiten DMA-Block einfach analog mit dem Signal <b>hung00 setzen</b> . <br><br><img src="https://habrastorage.org/webt/mz/zd/g8/mzzdg80tinx_ffjjigxypmehj0w.png"><br><br>  Um den Zeitrahmen genau einzuhalten, habe ich eine Taktfrequenz von einem Megahertz gew√§hlt.  Es w√§re m√∂glich, eine Frequenz und h√∂her zu nehmen, aber die Daten werden unter Bedingungen hoher Interferenz √ºber lange Dr√§hte √ºbertragen, daher ist es besser, sich die Zeit zu nehmen, um die Daten vor und nach dem Gate mit einem Rand einzustellen.  Wenn jemand meine Experimente auf demselben Steckbrett wiederholt - verwenden Sie nicht Port P3.2: Ein Kondensator ist an dieses Bein auf der Platine gel√∂tet.  Ich habe eine halbe Stunde lang get√∂tet, bis ich herausgefunden habe, warum ich keinen Impuls E gebildet habe, den ich zuerst dort verbunden habe.  Ich warf es auf P3.1 - alles funktionierte sofort.  Mein Datenbus geht zu P3.7-P3.4, RS geht zu P3.3, also ging E urspr√ºnglich zu P3.2 ... <br><br>  Bitte sch√∂n.  Wenn Sie nun versuchen, das Projekt zu kompilieren, erhalten wir vollst√§ndig vorhersehbare Fehler <br><br><img src="https://habrastorage.org/webt/az/tm/fb/aztmfbvzsl52ghanjovqpva5_7o.png"><br><br>  Das System versucht also, etwas zu sammeln.  Aber sie hat immer noch nichts zu sammeln.  Wir fahren fort, den Code zu kopieren.  Wechseln Sie dazu im UDB-Editor zur Registerkarte Verilog (diese Registerkarte befindet sich unter dem Fenster mit dem Blatt UDB-Editor): <br><br><img src="https://habrastorage.org/webt/kg/tk/fy/kgtkfyn1tssdt4-cjydawzl7vnw.png"><br><br>  Was ist dort bekannt?  Ganz am Ende des Textes befindet sich der K√∂rper des Automaten.  Beginnen wir mit der Migration. <br><br><div class="spoiler">  <b class="spoiler_title">Platzieren Sie es auch unter Datapath:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== State Machine: SM ==================== */ always @ (posedge clock) begin : Idle_state_logic case(SM) Idle : begin if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; end end LoadF0 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Up1 ; end end E_Up1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Down1 ; end end E_Down1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= SWAP ; end end SWAP : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_UP2 ; end end E_UP2 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= Idle ; end end LoadF1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= A1toA0 ; end end A1toA0 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Up1 ; end end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  Oben befinden sich Deklarationen f√ºr diesen Code (Namen f√ºr Status, Ketten f√ºr Datapath, ein Register, das den Status eines Automaten codiert).  Wir √ºbertragen sie an die entsprechenden <div class="spoiler">  <b class="spoiler_title">Abschnitt unseres Codes:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== Wire and Register Declarations ==================== */ localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111; wire hungry0; wire F0empty; wire hungry1; wire F1empty; wire Datapath_1_d0_load; wire Datapath_1_d1_load; wire Datapath_1_f0_load; wire Datapath_1_f1_load; wire Datapath_1_route_si; wire Datapath_1_route_ci; wire [2:0] Datapath_1_select; reg [2:0] SM;</code> </pre><br></div></div><br>  Na und <br><br><div class="spoiler">  <b class="spoiler_title">Die Signalbindungsstelle ist √ºbertragbar:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== Assignment of Combinatorial Variables ==================== */ assign Datapath_1_d0_load = (1'b0); assign Datapath_1_d1_load = (1'b0); assign Datapath_1_f0_load = (1'b0); assign Datapath_1_f1_load = (1'b0); assign Datapath_1_route_si = (1'b0); assign Datapath_1_route_ci = (1'b0); assign Datapath_1_select[0] = (SM[0]); assign Datapath_1_select[1] = (SM[1]); assign Datapath_1_select[2] = (SM[2]);</code> </pre><br></div></div><br>  Es ist Zeit, Datapath anzuschlie√üen.  Aus dem UDB-Editor portierter Code eignet sich gut f√ºr die maschinelle Bearbeitung, jedoch nicht sehr gut f√ºr die manuelle Bearbeitung.  Dort werden Ketten erstellt, die an einem Ende mit den Datenpfadeingaben und am anderen mit Konstanten verbunden sind.  In dem vom <b>Datapath-Konfigurationstool</b> erstellten Code (der alles f√ºr die manuelle Arbeit erledigt) sind jedoch alle Eingaben bereits direkt mit <b>Nullkonstanten</b> verbunden.  Ich werde also nur die Zeilen verbinden, die keine Konstanten sind, aber alles, was mit der Weiterleitung von Konstanten zu tun hat, aus dem √ºbertragenen Text herausschneiden.  Die Verbindung stellte sich folgenderma√üen heraus (die Farbe hebt die Stellen hervor, die ich in Bezug auf die automatisch im Datapath-Konfigurationstool erstellten Stellen bearbeitet habe): <br><br><img src="https://habrastorage.org/webt/-3/gk/fd/-3gkfd3bhnnc7wygbr6wpqoscyo.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">)) LCD_DP( /* input */ .reset(1'b0), /* input */ .clk(clk), /* input [02:00] */ .cs_addr(SM), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0), /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(hungry0), /* output */ .f0_blk_stat(F0empty), /* output */ .f1_bus_stat(hungry1), /* output */ .f1_blk_stat(F1empty),</code> </pre><br></div></div><br>  Parallele Daten sind etwas komplizierter.  Datapath verf√ºgt √ºber einen 8-Bit-Port, von dem nur vier herausgebracht werden m√ºssen.  Deshalb starten wir den Hilfsstromkreis und verbinden nur die H√§lfte davon mit dem Ausgang: <br><br><pre> <code class="plaintext hljs">wire [7:0] tempBus; assign LCD_D = tempBus[7:4];</code> </pre><br>  Und verbinden Sie es so: <br><br><img src="https://habrastorage.org/webt/km/aq/_a/kmaq_abi2kkprp406kne413j5u0.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po( tempBus) // Parallel data port );</code> </pre><br></div></div><br>  Wir versuchen zu montieren (Shift + F6 oder √ºber den Men√ºpunkt <b>Build-&gt; Generate Application</b> ).  Wir bekommen den Fehler: <br><br><img src="https://habrastorage.org/webt/kw/ox/as/kwoxasreij4-snkxyvc63iqozxq.png"><br><br>  Wir haben die Ports <b>hungrig0</b> und <b>hungrig1</b> (die beim Erstellen der Komponente <b>angezeigt wurden</b> ) sowie Ketten mit demselben Namen (wurden beim Ziehen aus dem Beispiel <b>angezeigt</b> ).  Entfernen Sie einfach diese Ketten (verlassen Sie die Ports).  Und irgendwo ist das <b>Taktsignal</b> durchgesickert, und wir haben diese Schaltung namens <b>clk</b> . <br><br>  Nachdem wir alle unn√∂tigen Schaltkreise entfernt haben (diejenigen, die anf√§nglich Nullkonstanten in die Datenpfadeing√§nge geworfen haben, sowie <b>hungrig0</b> und <b>hungrig1</b> ), erhalten wir den folgenden Code f√ºr den Anfang unserer Datei: <br><br><pre> <code class="plaintext hljs">// Your code goes here /* ==================== Wire and Register Declarations ==================== */ localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111; wire F0empty; wire F1empty; reg [2:0] SM; /* ==================== Assignment of Combinatorial Variables ==================== */ wire [7:0] tempBus; assign LCD_D = tempBus[7:4];</code> </pre><br>  Und wenn ich die <b>Uhr</b> im K√∂rper der Maschine durch <b>clk</b> ersetze, werde ich gleichzeitig alle Zeilen wegwerfen, die f√ºr die automatische Generierung gut sind, aber bei manueller Bearbeitung nur Verwirrung stiften (alle Vergleiche, die ein bedingungsloses Ergebnis <b>WAHR ergeben,</b> und so weiter).  Insbesondere k√∂nnen Sie im folgenden Beispiel etwa die H√§lfte der Zeilen streichen (und einige <b>Anfang / Ende</b> sind optional, manchmal werden sie ben√∂tigt, da wir Aktionen hinzuf√ºgen, die ich hervorgehoben habe): <br><br><img src="https://habrastorage.org/webt/9s/e9/t1/9se9t15zkc1hux1qrpga3jbh7cm.png"><br><br>  Nach dem K√§mmen nach dem obigen Prinzip (und dem Ersetzen der <b>Uhr</b> durch <b>clk</b> ) bleibt ein solcher K√∂rper bestehen <br><br><div class="spoiler">  <b class="spoiler_title">(es ist k√ºrzer geworden, was bedeutet, dass es leichter zu lesen ist):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">always @ (posedge clk) begin : Idle_state_logic case(SM) Idle : begin if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; end end LoadF0 : begin SM &lt;= E_Up1 ; end E_Up1 : begin SM &lt;= E_Down1 ; end E_Down1 : begin SM &lt;= SWAP ; end SWAP : begin SM &lt;= E_UP2 ; end E_UP2 : begin SM &lt;= Idle ; end LoadF1 : begin SM &lt;= A1toA0 ; end A1toA0 : begin SM &lt;= E_Up1 ; end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  W√§hrend der Kompilierung wird uns nun mitgeteilt, dass die <b>Schaltkreise</b> <b>LCD_E</b> und <b>LCD_RS</b> nicht verbunden sind. <br><br>  Eigentlich ist das wahr: <br><br><img src="https://habrastorage.org/webt/cz/da/h7/czdah7nfkzmou2mr8-omzs_-hby.png"><br><br>  Es ist an der Zeit, der Zustandsmaschine Aktionen hinzuzuf√ºgen.  Wir werden die Deklarationen der Ports, die den nicht verbundenen Ketten entsprechen, durch <b>reg</b> ersetzen, da wir sie in den K√∂rper der Maschine schreiben werden (dies ist die Syntax der Verilog-Sprache. Wenn wir schreiben, sollten die Daten einklicken, daf√ºr ben√∂tigen wir einen Trigger und sie werden durch das Schl√ºsselwort <b>reg angegeben</b> ): <br><br><img src="https://habrastorage.org/webt/l5/vq/uj/l5vqujn7yirpf4dkorxzevy9ij4.png"><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module LCD4bit ( output hungry0, output hungry1, output [3:0] LCD_D, output reg LCD_E, output reg LCD_RS, input clk );</code> </pre><br></div></div><br>  Und f√ºllen Sie die Maschine mit Aktionen.  Ich habe die obige Logik bereits gesagt, als ich den √úbergangsgraphen des Automaten betrachtete, daher werde ich nur das Ergebnis zeigen: <br><br><img src="https://habrastorage.org/webt/ij/t1/5i/ijt15itzdfznooyvlgz0sjlk5t4.png"><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">always @ (posedge clk) begin : Idle_state_logic case(SM) Idle : begin LCD_E &lt;= 0; if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; LCD_RS &lt;= 0; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; LCD_RS &lt;= 1; end end LoadF0 : begin SM &lt;= E_Up1 ; end E_Up1 : begin SM &lt;= E_Down1 ; LCD_E &lt;= 1'b1; end E_Down1 : begin SM &lt;= SWAP ; LCD_E &lt;= 1'b0; end SWAP : begin SM &lt;= E_UP2 ; end E_UP2 : begin SM &lt;= Idle ; LCD_E &lt;= 1; end LoadF1 : begin SM &lt;= A1toA0 ; end A1toA0 : begin SM &lt;= E_Up1 ; end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  Ab diesem Moment beginnt das Projekt zusammenzubauen.  Aber er wird noch nicht arbeiten.  Bisher habe ich bekanntlich gesagt: "In diesem Zustand werden wir das Register vom FIFO laden", "In diesem Zustand wird A1 nach A0 kopiert", "In diesem Zustand werden die Knabbereien neu angeordnet".  Im Allgemeinen habe ich viel gesprochen, aber bisher wurden keine Ma√ünahmen ergriffen.  Es ist an der Zeit, sie zu erf√ºllen.  Wir schauen uns an, wie die Staaten verschl√ºsselt wurden: <br><br><pre> <code class="plaintext hljs">localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111;</code> </pre><br>  <b>√ñffnen Sie das Datapath-Konfigurationstool erneut</b> : <br><br><img src="https://habrastorage.org/webt/eh/oh/sz/ehohszogw7vzyiup9cjumf4b3ii.png"><br><br>  Beginnen Sie mit der <b>Bearbeitung der CFGRAM-</b> Zeilen.  Beachten Sie beim Bearbeiten das Datenpfad-Schema: <br><br><img src="https://habrastorage.org/webt/cz/xr/vu/czxrvuaul7vkqilrqinrgzpu1fy.png"><br><br>  Die roten Rahmen in der Abbildung unten (und die Pfeile in der Abbildung oben) Ich habe die korrigierten Bereiche (und den Datenpfad) f√ºr den Status <b>LoadF0</b> (Code 001, <b>dh Reg1</b> ) hervorgehoben.  Ich habe Kommentare auch manuell eingegeben.  Der Inhalt von F0 sollte in A0 sein <br><br><img src="https://habrastorage.org/webt/4z/zv/kh/4zzvkhchg55gnp-39oag_d-bkt8.png"><br><br>  Mit gr√ºnen Rahmen und Pfeilen habe ich die Einstellungen und den Pfad f√ºr den Zustand LoadF1 (Code 010 - <b>Reg2</b> ) <b>markiert</b> . <br><br>  Mit blauen Rahmen und Pfeilen habe ich die Einstellungen und den Pfad f√ºr den Zustand A1toA0 (Code 011 - <b>Reg3</b> ) <b>markiert</b> . <br><br>  Die lila Rahmen und Pfeile I markierten die Einstellungen und den Pfad f√ºr den Status von SWAP (Code 110 - <b>Reg6</b> ). <br><br>  Schlie√ülich zeigen die orangefarbenen Pfeile den parallelen Datenpfad.  Und f√ºr sie werden keine Ma√ünahmen ergriffen.  Sie kommen immer aus der <b>SRCA</b> .  Wir haben fast immer A0 als <b>SRCA</b> ausgew√§hlt: Die Daten stammen aus A0.  Um die Eingabedaten umzuleiten, m√ºssten wir viele Hilfsaktionen ausf√ºhren, aber wir akzeptieren keine Daten. <b>Daher</b> ben√∂tigen wir diese Aktionen hier nicht und jeder findet seine Liste in <b>AN82156</b> .  Wir m√ºssen auch keine statischen Datenpfadeinstellungen bearbeiten. Schlie√üen Sie daher das <b>Datenpfad-Konfigurationstool</b> . <br><br>  Das ist alles.  Konzipierte Hardware fertiggestellt.  Erste Schritte bei der Entwicklung von C-Code.  <b>Wechseln</b> Sie dazu zur Registerkarte <b>Quelle</b> und bearbeiten Sie die Datei <b>main.c.</b> <br><br><img src="https://habrastorage.org/webt/fp/ia/7s/fpia7s4zyzaxy8mzmqxktib-obw.png"><br><br>  Die regelm√§√üige LCD-Initialisierung und die Ausgabe von ABC-Zeichen sehen folgenderma√üen aus (ich erinnere Sie daran, dass die Befehle an <b>FIFO0</b> gehen, die Dokumentation Pausen zwischen den Teams einf√ºgen muss und die Daten an <b>FIFO1 gehen</b> , ich habe nichts √ºber die Pausen zwischen den Daten gefunden): <br><br><pre> <code class="plaintext hljs"> volatile uint8_t* pFIFO0 = (uint8_t*) LCD4bit_1_LCD_DP__F0_REG; volatile uint8_t* pFIFO1 = (uint8_t*) LCD4bit_1_LCD_DP__F1_REG; pFIFO0[0] = 0x33; CyDelay (5); pFIFO0[0] = 0x33; CyDelay (100); pFIFO0[0] = 0x33; CyDelay (5); pFIFO0[0] = 0x20; CyDelay (5); pFIFO0[0] = 0x0C; //   CyDelay (50); pFIFO0[0] = 0x01; //   CyDelay (50); pFIFO1[0] = 'A'; pFIFO1[0] = 'B'; pFIFO1[0] = 'C';</code> </pre><br>  Was?  Warum wird nur das erste Zeichen auf dem Bildschirm angezeigt? <br><br><img src="https://habrastorage.org/webt/3g/tq/sr/3gtqsrr050bqbhaqi2ke9g1pg0w.png"><br><br>  Und wenn Sie Verz√∂gerungen zwischen der Datenausgabe hinzuf√ºgen, ist alles in Ordnung: <br><br><img src="https://habrastorage.org/webt/3b/he/2a/3bhe2a1_ioou2gktkqfzydumrne.png"><br><br>  Das Oszilloskop hat nicht gen√ºgend Kan√§le f√ºr solche Arbeiten.  Wir √ºberpr√ºfen die Arbeit an einem logischen Analysator.  Der Prozess der Datenaufzeichnung ist wie folgt. <br><br><img src="https://habrastorage.org/webt/yr/y_/_j/yry__jhgasihbzmmrrr2cnsylaq.png"><br><br>  Alle Daten sind vorhanden (drei Paketpaare).  Die Zeit f√ºr die Installation und das Einrasten von Daten wird in ausreichendem Umfang zugewiesen.  Im Allgemeinen wird aus Sicht der Zeitdiagramme alles richtig gemacht.  Das wissenschaftliche Problem ist gel√∂st, die gew√ºnschten Zeitdiagramme werden erstellt.  Hier ist Engineering - nein.  Der Grund daf√ºr ist die Langsamkeit des im LCD installierten Prozessors.  F√ºgen Sie zwischen den Bytes Verz√∂gerungen hinzu. <br><br>  Wir werden Verz√∂gerungen mit einem 7-Bit-Z√§hler bilden und gleichzeitig trainieren, ihn einem solchen System hinzuzuf√ºgen.  Lassen Sie uns nicht weniger als eine bestimmte Zeit im Ruhezustand sein, und ein Sieben-Bit-Z√§hler misst diese Zeit f√ºr uns.  Und wieder werden wir nicht schreiben, sondern Code erstellen.  Daher gehen wir erneut zur Hilfskomponente des UDB-Editors und f√ºgen dem Arbeitsblatt einen Z√§hler hinzu, wobei die Parameter wie folgt festgelegt werden: <br><br><img src="https://habrastorage.org/webt/gq/8c/qw/gq8cqwl0liu7mv9gpgm8-wngom0.png"><br><br>  Dieser Z√§hler funktioniert immer ( <b>Enable ist</b> auf 1 gesetzt).  Es wird jedoch geladen, wenn sich die Maschine im Zustand <b>E_UP2 befindet</b> (danach fallen wir sofort in den <b>Ruhezustand</b> ).  Die Zeile <b>Count7_1_tc wird</b> auf 1 erh√∂ht, wenn der Z√§hler auf Null z√§hlt. <b>Dies ist</b> eine zus√§tzliche Bedingung f√ºr das Verlassen des <b>Ruhezustands</b> .  Die Abbildung enth√§lt auch den Wert des Zeitraums, den wir jedoch nicht im Verilog-Code finden.  Es muss in den C-Code eingegeben werden.  Zuerst √ºbertragen wir den automatisch generierten Verilog-Code, indem wir zur Registerkarte Verilog wechseln.  Zun√§chst sollte der Z√§hler verbunden werden (wir sehen diesen Code am Anfang der Datei und verschieben ihn auch an den Anfang): <br><br><pre> <code class="plaintext hljs">`define CY_BLK_DIR "$CYPRESS_DIR\..\psoc\content\CyComponentLibrary\CyComponentLibrary.cylib\Count7_v1_0" `include "$CYPRESS_DIR\..\psoc\content\CyComponentLibrary\CyComponentLibrary.cylib\Count7_v1_0\Count7_v1_0.v"</code> </pre><br>  Wie die kreative Verfeinerung von Linien und Konstanten durchgef√ºhrt wird, wurde bereits beschrieben, daher zeige ich nur das Ergebnis.  Hier sind die Ketten und Zuweisungen, die als Ergebnis hinzugef√ºgt wurden (die restlichen Konstanten, also habe ich sie weggeworfen): <br><br><pre> <code class="plaintext hljs">wire Count7_1_load; wire Count7_1_tc; assign Count7_1_load = (SM==E_UP2);</code> </pre><br>  Und hier ist der Z√§hler selbst, der am Ende der Datei platziert ist.  Alle Konstanten werden Ports direkt in dieser Deklaration zugewiesen: <br><br><pre> <code class="plaintext hljs"> Count7_v1_0 Count7_1 ( .en(1'b1), .load(Count7_1_load), .clock(clk), .reset(1'b0), .cnt(), .tc(Count7_1_tc)); defparam Count7_1.EnableSignal = 1; defparam Count7_1.LoadSignal = 1;</code> </pre><br>  Damit dieser Z√§hler funktioniert, f√ºgen wir automatisch eine zus√§tzliche Bedingung hinzu, um den <b>Ruhezustand zu</b> beenden: <br><br><img src="https://habrastorage.org/webt/pc/it/pd/pcitpdmqenlvq8pblarf3uh5h84.png"><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> case(SM) Idle : begin LCD_E &lt;= 0; if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; LCD_RS &lt;= 0; end else if (( !F1empty &amp;Count7_1_tc ) == 1'b1) begin SM &lt;= LoadF1 ; LCD_RS &lt;= 1; end end</code> </pre><br></div></div><br>  Die API f√ºr den auf diese Weise hinzugef√ºgten Z√§hler wird nicht erstellt, daher f√ºgen wir der <b>Hauptfunktion</b> zwei magische Linien hinzu, die ich im Bild und in der √Ñhnlichkeit mit dem, was ich in der API aus fr√ºheren Projekten gesehen habe, gebildet habe (die erste Zeile legt den geladenen Wert des Kontos fest, das gleiche Laden, die zweite startet den Z√§hler): <br><br><pre> <code class="plaintext hljs"> *((uint8_t*)LCD4bit_1_Count7_1_Counter7__PERIOD_REG) = 0x20; *((uint8_t*)LCD4bit_1_Count7_1_Counter7__CONTROL_AUX_CTL_REG) |= 0x20; // Start</code> </pre><br>  Der Analysator zeigt, dass im modifizierten Fall die Verz√∂gerung offensichtlich ist: <br><br><img src="https://habrastorage.org/webt/ui/ey/ax/uieyax5yt3f0kpkhyyoikiishmq.png"><br><br>  Das LCD hat auch alle drei Zeichen. <br><br>  Die programmatische Zeichenausgabe im wirklichen Leben ist jedoch nicht akzeptabel.  Wenn Sie sie nur zum FIFO hinzuf√ºgen, l√§uft sie √ºber.  Warten Sie, bis der FIFO leer ist - dies bedeutet gro√üe Verz√∂gerungen f√ºr den Prozessorkern.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Prozessor arbeitet mit einer Frequenz von 72 MHz und Daten werden f√ºr 7-8 Taktzyklen mit einer Frequenz von 1 MHz ausgegeben. </font><font style="vertical-align: inherit;">Daher muss der Text im wirklichen Leben mit DMA angezeigt werden. </font><font style="vertical-align: inherit;">Hier bietet sich das Prinzip ‚ÄûStarten und Vergessen‚Äú an. </font><font style="vertical-align: inherit;">Alle Verz√∂gerungen f√ºr das Zeitdiagramm werden von der UDB generiert, und der DMA-Controller bestimmt die Bereitschaft des FIFO, Daten an uns zu empfangen. </font><font style="vertical-align: inherit;">Der Prozessorkern muss nur eine Zeile im Speicher bilden und DMA konfigurieren. Danach kann er andere Aufgaben ausf√ºhren, ohne sich um die Ausgabe auf dem LCD k√ºmmern zu m√ºssen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie den folgenden Code hinzu:</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> static const char line[] = "This is a line"; /* Defines for DMA_D */ #define DMA_D_BYTES_PER_BURST 1 #define DMA_D_REQUEST_PER_BURST 1 /* Variable declarations for DMA_D */ /* Move these variable declarations to the top of the function */ uint8 DMA_D_Chan; uint8 DMA_D_TD[1]; /* DMA Configuration for DMA_D */ DMA_D_Chan = DMA_D_DmaInitialize(DMA_D_BYTES_PER_BURST, DMA_D_REQUEST_PER_BURST, HI16(line), HI16(LCD4bit_1_LCD_DP__F1_REG)); DMA_D_TD[0] = CyDmaTdAllocate(); CyDmaTdSetConfiguration(DMA_D_TD[0], sizeof(line)-1, CY_DMA_DISABLE_TD, CY_DMA_TD_INC_SRC_ADR); CyDmaTdSetAddress(DMA_D_TD[0], LO16((uint32)line), LO16((uint32)LCD4bit_1_LCD_DP__F1_REG)); CyDmaChSetInitialTd(DMA_D_Chan, DMA_D_TD[0]); CyDmaChEnable(DMA_D_Chan, 1);</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf dem Bildschirm haben wir: </font></font><br><br><img src="https://habrastorage.org/webt/i7/ny/vi/i7nyvipk7tg8w_jdflryw2s39uk.png"><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei einem halbsynthetischen, aber realit√§tsnahen Beispiel haben wir beispielsweise den Codeentwicklungsmechanismus f√ºr UDB mithilfe eines alternativen Mechanismus beherrscht - dem Datapath Config Tool. </font><font style="vertical-align: inherit;">Dieser Mechanismus erm√∂glicht im Gegensatz zum UDB-Editor den Zugriff auf absolut alle UDB-Verwaltungsfunktionen. Die Arbeit damit ist jedoch komplizierter als mit dem UDB-Editor. </font><font style="vertical-align: inherit;">Die vom Autor des Artikels vorgeschlagene Methode erm√∂glicht es jedoch, Code nicht von Grund auf neu zu schreiben, sondern ihn einfach zu erstellen, wobei auf Hilfscode zur√ºckgegriffen wird, der vom selben UDB-Editor erstellt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das beim Schreiben des Artikels erhaltene Testprojekt kann hier √ºbernommen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442572/">https://habr.com/ru/post/de442572/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442560/index.html">Mash: Multithreading, Coroutinen, Async & Wait</a></li>
<li><a href="../de442562/index.html">So k√ºhlen Sie Ger√§te in einem Rechenzentrum - drei neue Technologien</a></li>
<li><a href="../de442566/index.html">Wie auf dem Mond: Reverse Engineering eines Hybrid-Operationsverst√§rkermoduls</a></li>
<li><a href="../de442568/index.html">Sicherheitswoche 10: Sicherheitsl√ºcken bei NVIDIA-Treibern</a></li>
<li><a href="../de442570/index.html">Sigma Regeln. Handwerk oder neuer Standard f√ºr SOC</a></li>
<li><a href="../de442574/index.html">Die Grundlage f√ºr eine verallgemeinerte Theorie neuronaler Netze wird geschaffen</a></li>
<li><a href="../de442576/index.html">Es lebe der Overclocker: Wie die Fl√ºssigkeitsk√ºhlung in Rechenzentren zu dominieren begann</a></li>
<li><a href="../de442578/index.html">Linux 5.0 Release</a></li>
<li><a href="../de442580/index.html">Reverse Engineering im Bin√§rformat am Beispiel von Korg .SNG-Dateien</a></li>
<li><a href="../de442582/index.html">Wie wir es mit Mobbing versucht haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>