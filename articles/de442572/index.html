<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏾 👩🏽‍🏫 🎀 Verwenden des Datapath Config Tools 🤞🏻 👨‍🚀 📒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir müssen den vorletzten Schritt in der praktischen Entwicklung der Arbeit mit UDB machen. Heute werden wir nicht mit dem automatisierten UDB-Editor ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden des Datapath Config Tools</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442572/"><img src="https://habrastorage.org/webt/fu/yo/23/fuyo230rbfhla_li8ryzzngttlw.jpeg"><br><br>  Wir müssen den vorletzten Schritt in der praktischen Entwicklung der Arbeit mit UDB machen.  Heute werden wir nicht mit dem automatisierten UDB-Editor entwickeln, sondern im halbmanuellen Modus mit dem Datapath Config Tool.  Eine sehr gute Hilfe bei der Beherrschung dieses Tools ist AN82156 - PSoC 3, PSoC 4 und PSoC 5LP - Entwerfen von PSoC Creator-Komponenten mit UDB-Datenpfaden.  Eigentlich habe ich es selbst studiert. <br><a name="habracut"></a><br>  Vielleicht hat jemand beim Lesen unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzungen der Dokumentation zu UDB</a> versucht, das Wissen von dort in die Praxis umzusetzen, und festgestellt, dass nicht alle in den Veröffentlichungen beschriebenen Funktionen im UDB-Editor verfügbar sind.  Dies liegt an der Tatsache, dass die Entwickler einige besonders umständliche Mechanismen nicht in den UDB-Editor eingefügt haben.  Die Autoren von AN82156 argumentieren, dass Sie über den UDB-Editor Folgendes nicht tun können: <br><br><ul><li>  parallele Dateneingabe und -ausgabe organisieren; </li><li>  dynamisches FIFO-Management organisieren; </li><li>  Implementieren der Umkehrung des FIFO-Taktsignals; </li><li>  Implementieren Sie die CRC-Funktion. </li><li>  Implementieren Sie die PRS-Funktion. </li><li>  die Wahl der eingehenden Übertragung implementieren; </li><li>  Implementieren Sie eine dynamische eingehende Migration. </li></ul><br>  Ich selbst möchte hinzufügen, dass ich nicht herausgefunden habe, wie die Permutation von Knabbereien im UDB-Editor implementiert werden kann. <br><br>  Wenn diese Funktionen im Projekt benötigt werden, müssen Sie Ihren eigenen Verilog-Code erstellen.  Ich habe speziell das Wort "erstellen" anstelle von "schreiben" verwendet.  Die Kenntnis dieser Programmiersprache reicht auf Leseebene aus.  Ich meine, Sie müssen verstehen, welches Design für was benötigt wird.  Es ist immer nützlich, von Grund auf neu schreiben zu können, aber diese Fähigkeit ist für das, was in diesem Artikel vorgestellt wird, nicht erforderlich. <br><br>  Als lösbares Problem habe ich einen halbsynthetischen Fall gewählt.  Im Allgemeinen habe ich mich entschlossen, einige Daten an den parallelen Anschluss auszugeben, und insbesondere hat das Text-LCD einen parallelen Anschluss.  Ich habe es vor drei Jahren aus dem MZ3D 3D-Drucker gezogen, als ich letzteres auf STM32 transplantiert habe.  Daher ist der Fall halbsynthetisch: Heutzutage haben solche Indikatoren normalerweise einen I2C-Eingang und müssen im wirklichen Leben nicht über einen Stapel von Drähten verbunden werden.  Moderne LCDs verfügen jedoch auch über parallele Anschlüsse, sodass jeder das Experiment wiederholen kann. <br><br>  Betrachten Sie das von reprap.org übernommene Schema zum Umschalten der Anzeige (dies war nicht einfach, mein Provider blockiert diese Site sowie eine Reihe anderer technischer Websites und motiviert sie damit, dass sie auf derselben IP-Adresse wie eine blockierte Person leben). <br><br><img src="https://habrastorage.org/webt/0x/th/ry/0xthryzxadx_9guzmhdyhrxnzty.png"><br><br>  Tolles Layout!  Erstens muss ich nicht über das Lesen nachdenken: Daten auf dem LCD können nur geschrieben werden (die R / W-Leitung ist geerdet und am Stecker nicht verfügbar).  Zweitens liegen die Daten in einem 4-Bit-Format vor, was bedeutet, dass wir nicht nur die parallele Ausgabe berechnen, sondern auch die Funktion der Nibble-Permutationsfunktion überprüfen können. <br><br><h2>  Projekterstellung </h2><br>  Starten Sie also PSoC Creator und wählen Sie <b>Datei-&gt; Neu-&gt; Projekt</b> : <br><br><img src="https://habrastorage.org/webt/pv/ma/tv/pvmatvfviveyo4fa822osy45p2c.png"><br><br>  Als nächstes wähle ich mein Steckbrett: <br><br><img src="https://habrastorage.org/webt/dv/st/hi/dvsthib82j6ynrdxc0sk-5j20nk.png"><br><br>  Als nächstes ist das leere Diagramm: <br><br><img src="https://habrastorage.org/webt/oi/fx/vv/oifxvvsf0qye7j-mdyoxmbfux4q.png"><br><br>  Ich werde das Projekt <b>LCDTest2 nennen</b> : <br><br><img src="https://habrastorage.org/webt/qs/3f/rl/qs3frlgxrnzqzqrzzfryptvjfqq.png"><br><br>  Wechseln Sie nun wie zuvor zur Registerkarte <b>Komponenten</b> : <br><br><img src="https://habrastorage.org/webt/wq/nb/bo/wqnbboubijieyovk7akrat6piik.png"><br><br>  Nachdem Sie das Projekt ausgewählt haben, drücken Sie die rechte Maustaste und wählen <b>Sie dann Komponentenelement hinzufügen</b> . <br><br><img src="https://habrastorage.org/webt/hi/fu/hv/hifuhvearnltnfz2dvmhwtzgw4o.png"><br><br>  Und hier müssen Sie den <b>Symbol-Assistenten</b> auswählen.  Geben Sie einen Namen ... Nun, sagen wir <b>LCD4bit</b> . <br><br><img src="https://habrastorage.org/webt/59/f0/g3/59f0g3lya8ado4kcxgj6lcsxggk.png"><br><br>  Ich habe dem Symbol folgende Ports zugewiesen: <br><br><img src="https://habrastorage.org/webt/6a/jr/uo/6ajruo1io2jusjunhameiumtb20.png"><br><br>  <b>clk</b> ist der Takteingang.  Ports mit einem LCD-Präfix sind Standard-LCD-Ports.  <b>hungrige</b> Ausgänge, die der DMA-Einheit mitteilen, dass im FIFO freier Speicherplatz vorhanden ist, wurden in einem Artikel über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Steuerung von RGB-LEDs</a> erörtert.  Klicken Sie auf OK, um den Charakter zu erhalten. <br><br><img src="https://habrastorage.org/webt/ze/fq/5z/zefq5z65eq0i4mq21y2d3jip7t4.png"><br><br>  Basierend auf diesem Symbol sollte nun eine Verilog-Vorlage generiert werden.  Klicken Sie mit der rechten Maustaste in der Nähe des Symbols und wählen <b>Sie</b> im Kontextmenü die <b>Option Verilog generieren</b> . <br><br><img src="https://habrastorage.org/webt/h9/k7/oo/h9k7oogp_wqsdfugdg-8bdr_hru.png"><br><br>  Wir haben die in der folgenden Abbildung gezeigte Vorlage (in Textform macht sie noch keinen Sinn): <br><br><img src="https://habrastorage.org/webt/ax/t9/k-/axt9k-s-zfi2kfd7qdz9pe-zlqq.png"><br><br>  Wir haben ein Modul und einige Abschnitte erstellt.  Sie haben Datapath jedoch noch nicht erstellt.  Um es hinzuzufügen, gehen Sie zum Projektbaum, wählen Sie die Datei <b>LCD4bit.v aus</b> , drücken Sie die rechte Maustaste und wählen Sie das <b>Datapath Config Tool</b> im <b>angezeigten</b> Kontextmenü: <br><br><img src="https://habrastorage.org/webt/z2/1g/5w/z21g5wom4_-yq_nmcjlhvb3irg0.png"><br><br>  Vor uns öffnet sich ein Fenster, das ich vorerst nur teilweise zeigen werde: <br><br><img src="https://habrastorage.org/webt/m0/fz/9i/m0fz9idl6xt5rimcittxpme2iea.png"><br><br>  Bitte lieben und bevorzugen, Datapath Editor.  Es enthält alle Bits, die in der Übersetzung der proprietären Dokumentation beschrieben wurden.  Aber es gibt so viele dieser Teile, dass ich ihn in den frühen Tagen ansah, aber Angst hatte, irgendetwas zu tun.  Schau, schau und geh raus.  Und erst nach einiger Zeit, als er sich daran gewöhnt hatte, versuchte er etwas zu tun.  Deshalb habe ich nur einen Teil des Fensters mitgebracht.  Warum alle vorzeitig erschrecken?  In der Zwischenzeit müssen wir nur einen Datenpfad erstellen, also wählen wir den Menüpunkt <b>Bearbeiten-&gt; Neuer Datenpfad</b> : <br><br><img src="https://habrastorage.org/webt/-n/dx/vj/-ndxvjk_wrpdjucuq0_c3jcqfai.png"><br><br>  Welche Option können Sie im angezeigten Dialogfeld auswählen? <br><br><img src="https://habrastorage.org/webt/wf/ma/kf/wfmakfepho5l4h4nxffpua7wgok.png"><br><br>  Die Frage ist etwas ernster als es scheint.  Lassen Sie mich sogar den nächsten Absatz hervorheben, damit niemand erwischt wird (ich habe mich selbst erwischt, und dann habe ich im Netzwerk Fragen von denen gesehen, die ich erhalten habe, und niemand hat sie wirklich beantwortet, und die Antwort ist in <b>AN82156</b> , Sie müssen sie nur diagonal lesen, wie es dort steht kurze unauffällige Phrase). <br><blockquote>  Wenn Sie mit parallelen Daten arbeiten möchten, müssen Sie auf jeden Fall die Option CY_PSOC3_DP wählen.  Keine andere Option enthält Ports zum Verbinden paralleler Daten. </blockquote>  Also.  Lassen Sie die Instanz LCD_DP heißen: <br><br><img src="https://habrastorage.org/webt/tf/a3/hs/tfa3hsi-mu2ljvyeukwmprwlm_4.png"><br><br>  Klicken Sie auf OK und schließen Sie das <b>Datapath Config Tool</b> , um das Ergebnis zu speichern.  Wir werden später hierher zurückkommen. <br><br>  Unser Verilog-Code wurde erweitert.  Jetzt hat es Datapath.  Sein Anfang ist völlig unlesbar.  Es ist nicht beängstigend, es wird vom <b>Datapath Config Tool</b> konfiguriert. <br><br><img src="https://habrastorage.org/webt/tz/d9/ur/tzd9urfa66hsfic2w9gsn6tkysu.png"><br><br>  Und wir werden das Ende der Datenpfadbeschreibung regieren.  Unsere Seite sieht so aus <div class="spoiler">  <b class="spoiler_title">(Ab diesem Punkt ist es sinnvoll, alles in Textform zu bringen).</b> <div class="spoiler_text"><pre><code class="plaintext hljs">)) LCD_DP( /* input */ .reset(1'b0), /* input */ .clk(1'b0), /* input [02:00] */ .cs_addr(3'b0), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0), /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(), /* output */ .f0_blk_stat(), /* output */ .f1_bus_stat(), /* output */ .f1_blk_stat(), /* input */ .ci(1'b0), // Carry in from previous stage /* output */ .co(), // Carry out to next stage /* input */ .sir(1'b0), // Shift in from right side /* output */ .sor(), // Shift out to right side /* input */ .sil(1'b0), // Shift in from left side /* output */ .sol(), // Shift out to left side /* input */ .msbi(1'b0), // MSB chain in /* output */ .msbo(), // MSB chain out /* input [01:00] */ .cei(2'b0), // Compare equal in from prev stage /* output [01:00] */ .ceo(), // Compare equal out to next stage /* input [01:00] */ .cli(2'b0), // Compare less than in from prv stage /* output [01:00] */ .clo(), // Compare less than out to next stage /* input [01:00] */ .zi(2'b0), // Zero detect in from previous stage /* output [01:00] */ .zo(), // Zero detect out to next stage /* input [01:00] */ .fi(2'b0), // 0xFF detect in from previous stage /* output [01:00] */ .fo(), // 0xFF detect out to next stage /* input [01:00] */ .capi(2'b0), // Software capture from previous stage /* output [01:00] */ .capo(), // Software capture to next stage /* input */ .cfbi(1'b0), // CRC Feedback in from previous stage /* output */ .cfbo(), // CRC Feedback out to next stage /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po() // Parallel data port );</code> </pre> <br></div></div><br>  Beängstigend  Jetzt werden wir herausfinden, was was ist - es wird aufhören, beängstigend zu sein.  Tatsächlich gibt es in diesem Text drei verschiedene Gruppen.  Erinnern wir uns an die Übersetzung der Dokumentation.  Wie sah der Datenpfad auf dem Bild aus?  Ich werde in der Abbildung sofort die Orte vermerken, zu denen die Gruppen „1“, „2“ und „3“ gehören. <br><br><img src="https://habrastorage.org/webt/ji/xe/5x/jixe5x_fxqpx6kgybrjmakagpw4.png"><br><br>  Tatsächlich sind die Eingaben die erste Gruppe von Ports im Verilog-Code.  Vergleichen Sie die Namen am Ausgang des Eingangsmultiplexers (in der Abbildung „1“) und die Namen der Signale im Code. <br><br>  Jetzt sind alle Eingänge Null.  Wir müssen den Takteingang anschließen und können bis zu sechs Eingangsleitungen weiterleiten, wie dies im UDB-Editor geschehen ist.  Diese Eingaben sind: <br><br><pre> <code class="plaintext hljs"> /* input */ .reset(1'b0), /* input */ .clk(1'b0), /* input [02:00] */ .cs_addr(3'b0), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0),</code> </pre><br>  Die zweite Gruppe sind die Ausgänge.  Die Namen im Code stimmen auch mit den Namen der Eingänge des Ausgangsmultiplexers "2" überein: <br><br><pre> <code class="plaintext hljs"> /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(), /* output */ .f0_blk_stat(), /* output */ .f1_bus_stat(), /* output */ .f1_blk_stat(),</code> </pre><br>  Nur die angegebene Datapath-Art hat die dritte Gruppe (die anderen haben keine, daher gibt es keine parallelen Daten).  Dies sind interne Datenpfadsignale, über die Sie unabhängig voneinander verketten oder andere nützliche Aktionen ausführen können.  Die Namen im Code stimmen auch mit den Namen der in der Figur verstreuten internen Signale überein.  Wir geben durch einen von ihnen (der letzte in der Liste, sein Name ist <b>po</b> ) parallele Daten direkt an die Beine des Chips aus. <br><br><pre> <code class="plaintext hljs"> /* input */ .ci(1'b0), // Carry in from previous stage /* output */ .co(), // Carry out to next stage /* input */ .sir(1'b0), // Shift in from right side /* output */ .sor(), // Shift out to right side /* input */ .sil(1'b0), // Shift in from left side /* output */ .sol(), // Shift out to left side /* input */ .msbi(1'b0), // MSB chain in /* output */ .msbo(), // MSB chain out /* input [01:00] */ .cei(2'b0), // Compare equal in from prev stage /* output [01:00] */ .ceo(), // Compare equal out to next stage /* input [01:00] */ .cli(2'b0), // Compare less than in from prv stage /* output [01:00] */ .clo(), // Compare less than out to next stage /* input [01:00] */ .zi(2'b0), // Zero detect in from previous stage /* output [01:00] */ .zo(), // Zero detect out to next stage /* input [01:00] */ .fi(2'b0), // 0xFF detect in from previous stage /* output [01:00] */ .fo(), // 0xFF detect out to next stage /* input [01:00] */ .capi(2'b0), // Software capture from previous stage /* output [01:00] */ .capo(), // Software capture to next stage /* input */ .cfbi(1'b0), // CRC Feedback in from previous stage /* output */ .cfbo(), // CRC Feedback out to next stage /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po() // Parallel data port );</code> </pre><br>  Also.  Während wir arbeiten, müssen wir einige dieser Ein- und Ausgänge mit unseren eigenen Entitäten verbinden, und der Rest - lassen Sie sie einfach in der Form, in der wir sie erstellt haben. <br><br><h2>  Verwenden des UDB-Editors als Referenz </h2><br>  Und jetzt haben wir eine Lücke, wir wissen, wo und was wir schreiben müssen.  Es bleibt zu verstehen, was genau wir dort eingeben werden.  Es kam vor, dass ich die Verilog-Sprache nicht jeden Tag verwende. Im Allgemeinen erinnere ich mich an alles, und das Schreiben von Grund auf ist für mich immer eine stressige Situation.  Wenn das Projekt bereits läuft, wird alles in Erinnerung behalten, aber wenn ich nach ein paar Monaten Inaktivität etwas von vorne anfange, erinnere ich mich natürlich nicht mehr an die Syntaxdetails dieser bestimmten Sprache.  Daher schlage ich vor, die Entwicklungsumgebung zu bitten, uns zu helfen. <br><br>  Der UDB-Editor zur Selbstüberwachung erstellt Verilog-Code.  Wir nutzen die Tatsache, dass Komponenten, die nicht an der Hauptschaltung beteiligt sind, nicht kompiliert werden, sodass wir im UDB-Editor eine Hilfskomponente erstellen können, die nicht in den Ausgabecode gelangt.  Wir werden dort einen Automaten zeichnen, die Ein- und Ausgänge von Datapath grob anpassen und dann einfach den automatisch generierten Text in unser Verilog-Modul übertragen und alles kreativ ändern.  Dies ist viel einfacher, als sich die Details der Verilog-Syntax zu merken und alles von Grund auf neu zu schreiben (obwohl jeder, der Verilog ständig verwendet, natürlich einfacher von Grund auf neu schreiben kann: Die kreative Fertigstellung ist, wie wir bald sehen werden, einfach, erfordert jedoch Zeit). <br><br>  Also fangen wir an, eine Hilfskomponente herzustellen.  Mit der üblichen Handbewegung fügen wir dem Projekt ein neues Element hinzu: <br><br><img src="https://habrastorage.org/webt/to/d2/fg/tod2fgx1opcdho2edizges-vr3q.png"><br><br>  Dies wird ein UDB-Dokument sein, nennen wir es <b>UDBhelper</b> : <br><br><img src="https://habrastorage.org/webt/j3/wt/iu/j3wtiuj2htdr-ct4f7m_3z497oi.png"><br><br>  Es ist Zeit, über die Maschine nachzudenken, die wir auf dem erstellten Blatt platzieren werden.  Dazu müssen wir uns überlegen, welches Zeitdiagramm wir damit erstellen sollen: <br><br><img src="https://habrastorage.org/webt/rh/zj/da/rhzjdasl8ioia8n8okjuuaieft4.png"><br><br><img src="https://habrastorage.org/webt/dy/3a/0z/dy3a0zmkacoa4tvgaugebovdhqy.png"><br><br>  Also.  Zuerst müssen Sie das RS-Signal einstellen (da R / W in der Hardware auf Null gelötet ist).  Warten Sie als nächstes auf tAS, erhöhen Sie dann das Signal E und stellen Sie die Daten ein (die Dateneinstellung in Bezug auf die positive Flanke E ist nicht begrenzt).  Die Daten müssen mindestens tDSW auf dem Bus sein, danach muss das Signal E gelöscht werden. Die Daten müssen mindestens tDHW und mindestens tAH RS auf dem Bus bleiben. <br><br>  RS ist das Befehls- oder Datenflag.  Wenn RS Null ist, wird ein Befehl geschrieben, wenn es Eins ist, werden Daten geschrieben. <br><br>  Ich schlage vor, Befehle über <b>FIFO0</b> und Daten über <b>FIFO1 zu senden</b> .  Dies widerspricht im Rahmen der aktuellen Aufgabe nichts.  Dann hat die von mir vorgeschlagene endliche Zustandsmaschine die folgende Form: <br><br><img src="https://habrastorage.org/webt/jn/6y/6j/jn6y6jnzllwbwgmslak7nif1xmu.png"><br><br>  Im <b>Ruhezustand</b> befindet sich die Maschine noch in keinen FIFO-Daten.  Wenn Daten in <b>FIFO0</b> erschienen <b>sind</b> , gehen sie zu <b>LoadF0</b> , wo sie in Zukunft Daten von <b>FIFO0</b> nach A0 empfangen. <br><br>  Während die Befehle übertragen werden, sollten die Daten nicht gesendet werden.  Daher hat die Bedingung zum Empfangen von Daten eine niedrigere Priorität als die Bedingung zum Empfangen von Befehlen. <br><br><img src="https://habrastorage.org/webt/og/gn/fl/oggnfl3tcjcxa8pzu64qcj3yzpa.png"><br><br>  Daten werden in A1 im Zustand <b>LoadF1 empfangen</b> (von <b>FIFO1 können</b> sie nur zum Register A1 und nicht zum Register A0 gehen), und dann werden sie im Zustand <b>A1toA0</b> von A1 nach A0 <b>kopiert</b> . <br><br>  Wie auch immer wir zum Punkt der Konvergenz der Pfeile gehen, wir haben Daten in A0.  Sie werden bereits an die parallele Schnittstelle ausgegeben.  Wir <b>spannen</b> E (im Zustand <b>E_UP1</b> ), lassen E fallen (im Zustand <b>E_DOWN1</b> ).  Als nächstes haben wir einen Zustand zum Austauschen von Knabbereien ( <b>SWAP</b> ), wonach E wieder ansteigt ( <b>E_UP2</b> ).  In diesem Zusammenhang habe ich acht Zustände erschöpft, die in drei Bits codiert werden können.  Und wir erinnern uns, dass der dynamische Konfigurations-RAM von Datapath nur drei Adresseneingänge hat.  Einige Tricks könnten angewendet werden, aber der Artikel ist bereits groß.  Daher werden wir E erst zum zweiten Mal in den <b>Ruhezustand</b> versetzen.  Dann reichen uns acht Staaten völlig aus. <br><br>  Wir setzen auch Datapath auf das Blatt und weisen seine Ein- und Ausgänge auf eine Weise zu, die in den vorherigen Artikeln bekannt ist.  Hier sind die Eingaben: <br><br><img src="https://habrastorage.org/webt/ct/fn/0j/ctfn0jvexwfycfrdovbnatwv7ze.png"><br><br>  Hier sind die Ausgänge: <br><br><img src="https://habrastorage.org/webt/ct/mj/gd/ctmjgdzfvx-mz8qnzwbp6undlau.png"><br><br>  Nichts Neues, alles wurde bereits in früheren Artikeln des Zyklus beschrieben.  Wir haben also eine Lücke, auf deren Grundlage wir etwas Eigenes tun können.  Um sicherzustellen, dass alles läuft, müssen wir unser System auf die oberste Ebene des Projekts bringen, sonst werden keine Fehler gefunden.  Und in den ersten Experimenten ohne Fehler wird nicht funktionieren.  Deshalb werden wir noch eine Hilfsaktion durchführen. <br><br>  Die Beschreibung, wie die Schaltung hergestellt wird, geht über die Beschreibung der Arbeit mit UDB hinaus.  Ich zeige Ihnen nur, welche Schaltung ich habe.  Es gibt nur eine DMA-Einheit: Wenn Sie Befehle an das LCD senden, müssen Sie großen Pausen standhalten, sodass dies programmgesteuert noch einfacher ist.  Für andere Anwendungen können Sie den zweiten DMA-Block einfach analog mit dem Signal <b>hung00 setzen</b> . <br><br><img src="https://habrastorage.org/webt/mz/zd/g8/mzzdg80tinx_ffjjigxypmehj0w.png"><br><br>  Um den Zeitrahmen genau einzuhalten, habe ich eine Taktfrequenz von einem Megahertz gewählt.  Es wäre möglich, eine Frequenz und höher zu nehmen, aber die Daten werden unter Bedingungen hoher Interferenz über lange Drähte übertragen, daher ist es besser, sich die Zeit zu nehmen, um die Daten vor und nach dem Gate mit einem Rand einzustellen.  Wenn jemand meine Experimente auf demselben Steckbrett wiederholt - verwenden Sie nicht Port P3.2: Ein Kondensator ist an dieses Bein auf der Platine gelötet.  Ich habe eine halbe Stunde lang getötet, bis ich herausgefunden habe, warum ich keinen Impuls E gebildet habe, den ich zuerst dort verbunden habe.  Ich warf es auf P3.1 - alles funktionierte sofort.  Mein Datenbus geht zu P3.7-P3.4, RS geht zu P3.3, also ging E ursprünglich zu P3.2 ... <br><br>  Bitte schön.  Wenn Sie nun versuchen, das Projekt zu kompilieren, erhalten wir vollständig vorhersehbare Fehler <br><br><img src="https://habrastorage.org/webt/az/tm/fb/aztmfbvzsl52ghanjovqpva5_7o.png"><br><br>  Das System versucht also, etwas zu sammeln.  Aber sie hat immer noch nichts zu sammeln.  Wir fahren fort, den Code zu kopieren.  Wechseln Sie dazu im UDB-Editor zur Registerkarte Verilog (diese Registerkarte befindet sich unter dem Fenster mit dem Blatt UDB-Editor): <br><br><img src="https://habrastorage.org/webt/kg/tk/fy/kgtkfyn1tssdt4-cjydawzl7vnw.png"><br><br>  Was ist dort bekannt?  Ganz am Ende des Textes befindet sich der Körper des Automaten.  Beginnen wir mit der Migration. <br><br><div class="spoiler">  <b class="spoiler_title">Platzieren Sie es auch unter Datapath:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== State Machine: SM ==================== */ always @ (posedge clock) begin : Idle_state_logic case(SM) Idle : begin if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; end end LoadF0 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Up1 ; end end E_Up1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Down1 ; end end E_Down1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= SWAP ; end end SWAP : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_UP2 ; end end E_UP2 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= Idle ; end end LoadF1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= A1toA0 ; end end A1toA0 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Up1 ; end end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  Oben befinden sich Deklarationen für diesen Code (Namen für Status, Ketten für Datapath, ein Register, das den Status eines Automaten codiert).  Wir übertragen sie an die entsprechenden <div class="spoiler">  <b class="spoiler_title">Abschnitt unseres Codes:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== Wire and Register Declarations ==================== */ localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111; wire hungry0; wire F0empty; wire hungry1; wire F1empty; wire Datapath_1_d0_load; wire Datapath_1_d1_load; wire Datapath_1_f0_load; wire Datapath_1_f1_load; wire Datapath_1_route_si; wire Datapath_1_route_ci; wire [2:0] Datapath_1_select; reg [2:0] SM;</code> </pre><br></div></div><br>  Na und <br><br><div class="spoiler">  <b class="spoiler_title">Die Signalbindungsstelle ist übertragbar:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== Assignment of Combinatorial Variables ==================== */ assign Datapath_1_d0_load = (1'b0); assign Datapath_1_d1_load = (1'b0); assign Datapath_1_f0_load = (1'b0); assign Datapath_1_f1_load = (1'b0); assign Datapath_1_route_si = (1'b0); assign Datapath_1_route_ci = (1'b0); assign Datapath_1_select[0] = (SM[0]); assign Datapath_1_select[1] = (SM[1]); assign Datapath_1_select[2] = (SM[2]);</code> </pre><br></div></div><br>  Es ist Zeit, Datapath anzuschließen.  Aus dem UDB-Editor portierter Code eignet sich gut für die maschinelle Bearbeitung, jedoch nicht sehr gut für die manuelle Bearbeitung.  Dort werden Ketten erstellt, die an einem Ende mit den Datenpfadeingaben und am anderen mit Konstanten verbunden sind.  In dem vom <b>Datapath-Konfigurationstool</b> erstellten Code (der alles für die manuelle Arbeit erledigt) sind jedoch alle Eingaben bereits direkt mit <b>Nullkonstanten</b> verbunden.  Ich werde also nur die Zeilen verbinden, die keine Konstanten sind, aber alles, was mit der Weiterleitung von Konstanten zu tun hat, aus dem übertragenen Text herausschneiden.  Die Verbindung stellte sich folgendermaßen heraus (die Farbe hebt die Stellen hervor, die ich in Bezug auf die automatisch im Datapath-Konfigurationstool erstellten Stellen bearbeitet habe): <br><br><img src="https://habrastorage.org/webt/-3/gk/fd/-3gkfd3bhnnc7wygbr6wpqoscyo.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">)) LCD_DP( /* input */ .reset(1'b0), /* input */ .clk(clk), /* input [02:00] */ .cs_addr(SM), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0), /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(hungry0), /* output */ .f0_blk_stat(F0empty), /* output */ .f1_bus_stat(hungry1), /* output */ .f1_blk_stat(F1empty),</code> </pre><br></div></div><br>  Parallele Daten sind etwas komplizierter.  Datapath verfügt über einen 8-Bit-Port, von dem nur vier herausgebracht werden müssen.  Deshalb starten wir den Hilfsstromkreis und verbinden nur die Hälfte davon mit dem Ausgang: <br><br><pre> <code class="plaintext hljs">wire [7:0] tempBus; assign LCD_D = tempBus[7:4];</code> </pre><br>  Und verbinden Sie es so: <br><br><img src="https://habrastorage.org/webt/km/aq/_a/kmaq_abi2kkprp406kne413j5u0.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po( tempBus) // Parallel data port );</code> </pre><br></div></div><br>  Wir versuchen zu montieren (Shift + F6 oder über den Menüpunkt <b>Build-&gt; Generate Application</b> ).  Wir bekommen den Fehler: <br><br><img src="https://habrastorage.org/webt/kw/ox/as/kwoxasreij4-snkxyvc63iqozxq.png"><br><br>  Wir haben die Ports <b>hungrig0</b> und <b>hungrig1</b> (die beim Erstellen der Komponente <b>angezeigt wurden</b> ) sowie Ketten mit demselben Namen (wurden beim Ziehen aus dem Beispiel <b>angezeigt</b> ).  Entfernen Sie einfach diese Ketten (verlassen Sie die Ports).  Und irgendwo ist das <b>Taktsignal</b> durchgesickert, und wir haben diese Schaltung namens <b>clk</b> . <br><br>  Nachdem wir alle unnötigen Schaltkreise entfernt haben (diejenigen, die anfänglich Nullkonstanten in die Datenpfadeingänge geworfen haben, sowie <b>hungrig0</b> und <b>hungrig1</b> ), erhalten wir den folgenden Code für den Anfang unserer Datei: <br><br><pre> <code class="plaintext hljs">// Your code goes here /* ==================== Wire and Register Declarations ==================== */ localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111; wire F0empty; wire F1empty; reg [2:0] SM; /* ==================== Assignment of Combinatorial Variables ==================== */ wire [7:0] tempBus; assign LCD_D = tempBus[7:4];</code> </pre><br>  Und wenn ich die <b>Uhr</b> im Körper der Maschine durch <b>clk</b> ersetze, werde ich gleichzeitig alle Zeilen wegwerfen, die für die automatische Generierung gut sind, aber bei manueller Bearbeitung nur Verwirrung stiften (alle Vergleiche, die ein bedingungsloses Ergebnis <b>WAHR ergeben,</b> und so weiter).  Insbesondere können Sie im folgenden Beispiel etwa die Hälfte der Zeilen streichen (und einige <b>Anfang / Ende</b> sind optional, manchmal werden sie benötigt, da wir Aktionen hinzufügen, die ich hervorgehoben habe): <br><br><img src="https://habrastorage.org/webt/9s/e9/t1/9se9t15zkc1hux1qrpga3jbh7cm.png"><br><br>  Nach dem Kämmen nach dem obigen Prinzip (und dem Ersetzen der <b>Uhr</b> durch <b>clk</b> ) bleibt ein solcher Körper bestehen <br><br><div class="spoiler">  <b class="spoiler_title">(es ist kürzer geworden, was bedeutet, dass es leichter zu lesen ist):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">always @ (posedge clk) begin : Idle_state_logic case(SM) Idle : begin if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; end end LoadF0 : begin SM &lt;= E_Up1 ; end E_Up1 : begin SM &lt;= E_Down1 ; end E_Down1 : begin SM &lt;= SWAP ; end SWAP : begin SM &lt;= E_UP2 ; end E_UP2 : begin SM &lt;= Idle ; end LoadF1 : begin SM &lt;= A1toA0 ; end A1toA0 : begin SM &lt;= E_Up1 ; end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  Während der Kompilierung wird uns nun mitgeteilt, dass die <b>Schaltkreise</b> <b>LCD_E</b> und <b>LCD_RS</b> nicht verbunden sind. <br><br>  Eigentlich ist das wahr: <br><br><img src="https://habrastorage.org/webt/cz/da/h7/czdah7nfkzmou2mr8-omzs_-hby.png"><br><br>  Es ist an der Zeit, der Zustandsmaschine Aktionen hinzuzufügen.  Wir werden die Deklarationen der Ports, die den nicht verbundenen Ketten entsprechen, durch <b>reg</b> ersetzen, da wir sie in den Körper der Maschine schreiben werden (dies ist die Syntax der Verilog-Sprache. Wenn wir schreiben, sollten die Daten einklicken, dafür benötigen wir einen Trigger und sie werden durch das Schlüsselwort <b>reg angegeben</b> ): <br><br><img src="https://habrastorage.org/webt/l5/vq/uj/l5vqujn7yirpf4dkorxzevy9ij4.png"><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module LCD4bit ( output hungry0, output hungry1, output [3:0] LCD_D, output reg LCD_E, output reg LCD_RS, input clk );</code> </pre><br></div></div><br>  Und füllen Sie die Maschine mit Aktionen.  Ich habe die obige Logik bereits gesagt, als ich den Übergangsgraphen des Automaten betrachtete, daher werde ich nur das Ergebnis zeigen: <br><br><img src="https://habrastorage.org/webt/ij/t1/5i/ijt15itzdfznooyvlgz0sjlk5t4.png"><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">always @ (posedge clk) begin : Idle_state_logic case(SM) Idle : begin LCD_E &lt;= 0; if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; LCD_RS &lt;= 0; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; LCD_RS &lt;= 1; end end LoadF0 : begin SM &lt;= E_Up1 ; end E_Up1 : begin SM &lt;= E_Down1 ; LCD_E &lt;= 1'b1; end E_Down1 : begin SM &lt;= SWAP ; LCD_E &lt;= 1'b0; end SWAP : begin SM &lt;= E_UP2 ; end E_UP2 : begin SM &lt;= Idle ; LCD_E &lt;= 1; end LoadF1 : begin SM &lt;= A1toA0 ; end A1toA0 : begin SM &lt;= E_Up1 ; end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  Ab diesem Moment beginnt das Projekt zusammenzubauen.  Aber er wird noch nicht arbeiten.  Bisher habe ich bekanntlich gesagt: "In diesem Zustand werden wir das Register vom FIFO laden", "In diesem Zustand wird A1 nach A0 kopiert", "In diesem Zustand werden die Knabbereien neu angeordnet".  Im Allgemeinen habe ich viel gesprochen, aber bisher wurden keine Maßnahmen ergriffen.  Es ist an der Zeit, sie zu erfüllen.  Wir schauen uns an, wie die Staaten verschlüsselt wurden: <br><br><pre> <code class="plaintext hljs">localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111;</code> </pre><br>  <b>Öffnen Sie das Datapath-Konfigurationstool erneut</b> : <br><br><img src="https://habrastorage.org/webt/eh/oh/sz/ehohszogw7vzyiup9cjumf4b3ii.png"><br><br>  Beginnen Sie mit der <b>Bearbeitung der CFGRAM-</b> Zeilen.  Beachten Sie beim Bearbeiten das Datenpfad-Schema: <br><br><img src="https://habrastorage.org/webt/cz/xr/vu/czxrvuaul7vkqilrqinrgzpu1fy.png"><br><br>  Die roten Rahmen in der Abbildung unten (und die Pfeile in der Abbildung oben) Ich habe die korrigierten Bereiche (und den Datenpfad) für den Status <b>LoadF0</b> (Code 001, <b>dh Reg1</b> ) hervorgehoben.  Ich habe Kommentare auch manuell eingegeben.  Der Inhalt von F0 sollte in A0 sein <br><br><img src="https://habrastorage.org/webt/4z/zv/kh/4zzvkhchg55gnp-39oag_d-bkt8.png"><br><br>  Mit grünen Rahmen und Pfeilen habe ich die Einstellungen und den Pfad für den Zustand LoadF1 (Code 010 - <b>Reg2</b> ) <b>markiert</b> . <br><br>  Mit blauen Rahmen und Pfeilen habe ich die Einstellungen und den Pfad für den Zustand A1toA0 (Code 011 - <b>Reg3</b> ) <b>markiert</b> . <br><br>  Die lila Rahmen und Pfeile I markierten die Einstellungen und den Pfad für den Status von SWAP (Code 110 - <b>Reg6</b> ). <br><br>  Schließlich zeigen die orangefarbenen Pfeile den parallelen Datenpfad.  Und für sie werden keine Maßnahmen ergriffen.  Sie kommen immer aus der <b>SRCA</b> .  Wir haben fast immer A0 als <b>SRCA</b> ausgewählt: Die Daten stammen aus A0.  Um die Eingabedaten umzuleiten, müssten wir viele Hilfsaktionen ausführen, aber wir akzeptieren keine Daten. <b>Daher</b> benötigen wir diese Aktionen hier nicht und jeder findet seine Liste in <b>AN82156</b> .  Wir müssen auch keine statischen Datenpfadeinstellungen bearbeiten. Schließen Sie daher das <b>Datenpfad-Konfigurationstool</b> . <br><br>  Das ist alles.  Konzipierte Hardware fertiggestellt.  Erste Schritte bei der Entwicklung von C-Code.  <b>Wechseln</b> Sie dazu zur Registerkarte <b>Quelle</b> und bearbeiten Sie die Datei <b>main.c.</b> <br><br><img src="https://habrastorage.org/webt/fp/ia/7s/fpia7s4zyzaxy8mzmqxktib-obw.png"><br><br>  Die regelmäßige LCD-Initialisierung und die Ausgabe von ABC-Zeichen sehen folgendermaßen aus (ich erinnere Sie daran, dass die Befehle an <b>FIFO0</b> gehen, die Dokumentation Pausen zwischen den Teams einfügen muss und die Daten an <b>FIFO1 gehen</b> , ich habe nichts über die Pausen zwischen den Daten gefunden): <br><br><pre> <code class="plaintext hljs"> volatile uint8_t* pFIFO0 = (uint8_t*) LCD4bit_1_LCD_DP__F0_REG; volatile uint8_t* pFIFO1 = (uint8_t*) LCD4bit_1_LCD_DP__F1_REG; pFIFO0[0] = 0x33; CyDelay (5); pFIFO0[0] = 0x33; CyDelay (100); pFIFO0[0] = 0x33; CyDelay (5); pFIFO0[0] = 0x20; CyDelay (5); pFIFO0[0] = 0x0C; //   CyDelay (50); pFIFO0[0] = 0x01; //   CyDelay (50); pFIFO1[0] = 'A'; pFIFO1[0] = 'B'; pFIFO1[0] = 'C';</code> </pre><br>  Was?  Warum wird nur das erste Zeichen auf dem Bildschirm angezeigt? <br><br><img src="https://habrastorage.org/webt/3g/tq/sr/3gtqsrr050bqbhaqi2ke9g1pg0w.png"><br><br>  Und wenn Sie Verzögerungen zwischen der Datenausgabe hinzufügen, ist alles in Ordnung: <br><br><img src="https://habrastorage.org/webt/3b/he/2a/3bhe2a1_ioou2gktkqfzydumrne.png"><br><br>  Das Oszilloskop hat nicht genügend Kanäle für solche Arbeiten.  Wir überprüfen die Arbeit an einem logischen Analysator.  Der Prozess der Datenaufzeichnung ist wie folgt. <br><br><img src="https://habrastorage.org/webt/yr/y_/_j/yry__jhgasihbzmmrrr2cnsylaq.png"><br><br>  Alle Daten sind vorhanden (drei Paketpaare).  Die Zeit für die Installation und das Einrasten von Daten wird in ausreichendem Umfang zugewiesen.  Im Allgemeinen wird aus Sicht der Zeitdiagramme alles richtig gemacht.  Das wissenschaftliche Problem ist gelöst, die gewünschten Zeitdiagramme werden erstellt.  Hier ist Engineering - nein.  Der Grund dafür ist die Langsamkeit des im LCD installierten Prozessors.  Fügen Sie zwischen den Bytes Verzögerungen hinzu. <br><br>  Wir werden Verzögerungen mit einem 7-Bit-Zähler bilden und gleichzeitig trainieren, ihn einem solchen System hinzuzufügen.  Lassen Sie uns nicht weniger als eine bestimmte Zeit im Ruhezustand sein, und ein Sieben-Bit-Zähler misst diese Zeit für uns.  Und wieder werden wir nicht schreiben, sondern Code erstellen.  Daher gehen wir erneut zur Hilfskomponente des UDB-Editors und fügen dem Arbeitsblatt einen Zähler hinzu, wobei die Parameter wie folgt festgelegt werden: <br><br><img src="https://habrastorage.org/webt/gq/8c/qw/gq8cqwl0liu7mv9gpgm8-wngom0.png"><br><br>  Dieser Zähler funktioniert immer ( <b>Enable ist</b> auf 1 gesetzt).  Es wird jedoch geladen, wenn sich die Maschine im Zustand <b>E_UP2 befindet</b> (danach fallen wir sofort in den <b>Ruhezustand</b> ).  Die Zeile <b>Count7_1_tc wird</b> auf 1 erhöht, wenn der Zähler auf Null zählt. <b>Dies ist</b> eine zusätzliche Bedingung für das Verlassen des <b>Ruhezustands</b> .  Die Abbildung enthält auch den Wert des Zeitraums, den wir jedoch nicht im Verilog-Code finden.  Es muss in den C-Code eingegeben werden.  Zuerst übertragen wir den automatisch generierten Verilog-Code, indem wir zur Registerkarte Verilog wechseln.  Zunächst sollte der Zähler verbunden werden (wir sehen diesen Code am Anfang der Datei und verschieben ihn auch an den Anfang): <br><br><pre> <code class="plaintext hljs">`define CY_BLK_DIR "$CYPRESS_DIR\..\psoc\content\CyComponentLibrary\CyComponentLibrary.cylib\Count7_v1_0" `include "$CYPRESS_DIR\..\psoc\content\CyComponentLibrary\CyComponentLibrary.cylib\Count7_v1_0\Count7_v1_0.v"</code> </pre><br>  Wie die kreative Verfeinerung von Linien und Konstanten durchgeführt wird, wurde bereits beschrieben, daher zeige ich nur das Ergebnis.  Hier sind die Ketten und Zuweisungen, die als Ergebnis hinzugefügt wurden (die restlichen Konstanten, also habe ich sie weggeworfen): <br><br><pre> <code class="plaintext hljs">wire Count7_1_load; wire Count7_1_tc; assign Count7_1_load = (SM==E_UP2);</code> </pre><br>  Und hier ist der Zähler selbst, der am Ende der Datei platziert ist.  Alle Konstanten werden Ports direkt in dieser Deklaration zugewiesen: <br><br><pre> <code class="plaintext hljs"> Count7_v1_0 Count7_1 ( .en(1'b1), .load(Count7_1_load), .clock(clk), .reset(1'b0), .cnt(), .tc(Count7_1_tc)); defparam Count7_1.EnableSignal = 1; defparam Count7_1.LoadSignal = 1;</code> </pre><br>  Damit dieser Zähler funktioniert, fügen wir automatisch eine zusätzliche Bedingung hinzu, um den <b>Ruhezustand zu</b> beenden: <br><br><img src="https://habrastorage.org/webt/pc/it/pd/pcitpdmqenlvq8pblarf3uh5h84.png"><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> case(SM) Idle : begin LCD_E &lt;= 0; if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; LCD_RS &lt;= 0; end else if (( !F1empty &amp;Count7_1_tc ) == 1'b1) begin SM &lt;= LoadF1 ; LCD_RS &lt;= 1; end end</code> </pre><br></div></div><br>  Die API für den auf diese Weise hinzugefügten Zähler wird nicht erstellt, daher fügen wir der <b>Hauptfunktion</b> zwei magische Linien hinzu, die ich im Bild und in der Ähnlichkeit mit dem, was ich in der API aus früheren Projekten gesehen habe, gebildet habe (die erste Zeile legt den geladenen Wert des Kontos fest, das gleiche Laden, die zweite startet den Zähler): <br><br><pre> <code class="plaintext hljs"> *((uint8_t*)LCD4bit_1_Count7_1_Counter7__PERIOD_REG) = 0x20; *((uint8_t*)LCD4bit_1_Count7_1_Counter7__CONTROL_AUX_CTL_REG) |= 0x20; // Start</code> </pre><br>  Der Analysator zeigt, dass im modifizierten Fall die Verzögerung offensichtlich ist: <br><br><img src="https://habrastorage.org/webt/ui/ey/ax/uieyax5yt3f0kpkhyyoikiishmq.png"><br><br>  Das LCD hat auch alle drei Zeichen. <br><br>  Die programmatische Zeichenausgabe im wirklichen Leben ist jedoch nicht akzeptabel.  Wenn Sie sie nur zum FIFO hinzufügen, läuft sie über.  Warten Sie, bis der FIFO leer ist - dies bedeutet große Verzögerungen für den Prozessorkern.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Prozessor arbeitet mit einer Frequenz von 72 MHz und Daten werden für 7-8 Taktzyklen mit einer Frequenz von 1 MHz ausgegeben. </font><font style="vertical-align: inherit;">Daher muss der Text im wirklichen Leben mit DMA angezeigt werden. </font><font style="vertical-align: inherit;">Hier bietet sich das Prinzip „Starten und Vergessen“ an. </font><font style="vertical-align: inherit;">Alle Verzögerungen für das Zeitdiagramm werden von der UDB generiert, und der DMA-Controller bestimmt die Bereitschaft des FIFO, Daten an uns zu empfangen. </font><font style="vertical-align: inherit;">Der Prozessorkern muss nur eine Zeile im Speicher bilden und DMA konfigurieren. Danach kann er andere Aufgaben ausführen, ohne sich um die Ausgabe auf dem LCD kümmern zu müssen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie den folgenden Code hinzu:</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> static const char line[] = "This is a line"; /* Defines for DMA_D */ #define DMA_D_BYTES_PER_BURST 1 #define DMA_D_REQUEST_PER_BURST 1 /* Variable declarations for DMA_D */ /* Move these variable declarations to the top of the function */ uint8 DMA_D_Chan; uint8 DMA_D_TD[1]; /* DMA Configuration for DMA_D */ DMA_D_Chan = DMA_D_DmaInitialize(DMA_D_BYTES_PER_BURST, DMA_D_REQUEST_PER_BURST, HI16(line), HI16(LCD4bit_1_LCD_DP__F1_REG)); DMA_D_TD[0] = CyDmaTdAllocate(); CyDmaTdSetConfiguration(DMA_D_TD[0], sizeof(line)-1, CY_DMA_DISABLE_TD, CY_DMA_TD_INC_SRC_ADR); CyDmaTdSetAddress(DMA_D_TD[0], LO16((uint32)line), LO16((uint32)LCD4bit_1_LCD_DP__F1_REG)); CyDmaChSetInitialTd(DMA_D_Chan, DMA_D_TD[0]); CyDmaChEnable(DMA_D_Chan, 1);</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf dem Bildschirm haben wir: </font></font><br><br><img src="https://habrastorage.org/webt/i7/ny/vi/i7nyvipk7tg8w_jdflryw2s39uk.png"><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei einem halbsynthetischen, aber realitätsnahen Beispiel haben wir beispielsweise den Codeentwicklungsmechanismus für UDB mithilfe eines alternativen Mechanismus beherrscht - dem Datapath Config Tool. </font><font style="vertical-align: inherit;">Dieser Mechanismus ermöglicht im Gegensatz zum UDB-Editor den Zugriff auf absolut alle UDB-Verwaltungsfunktionen. Die Arbeit damit ist jedoch komplizierter als mit dem UDB-Editor. </font><font style="vertical-align: inherit;">Die vom Autor des Artikels vorgeschlagene Methode ermöglicht es jedoch, Code nicht von Grund auf neu zu schreiben, sondern ihn einfach zu erstellen, wobei auf Hilfscode zurückgegriffen wird, der vom selben UDB-Editor erstellt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das beim Schreiben des Artikels erhaltene Testprojekt kann hier übernommen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442572/">https://habr.com/ru/post/de442572/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442560/index.html">Mash: Multithreading, Coroutinen, Async & Wait</a></li>
<li><a href="../de442562/index.html">So kühlen Sie Geräte in einem Rechenzentrum - drei neue Technologien</a></li>
<li><a href="../de442566/index.html">Wie auf dem Mond: Reverse Engineering eines Hybrid-Operationsverstärkermoduls</a></li>
<li><a href="../de442568/index.html">Sicherheitswoche 10: Sicherheitslücken bei NVIDIA-Treibern</a></li>
<li><a href="../de442570/index.html">Sigma Regeln. Handwerk oder neuer Standard für SOC</a></li>
<li><a href="../de442574/index.html">Die Grundlage für eine verallgemeinerte Theorie neuronaler Netze wird geschaffen</a></li>
<li><a href="../de442576/index.html">Es lebe der Overclocker: Wie die Flüssigkeitskühlung in Rechenzentren zu dominieren begann</a></li>
<li><a href="../de442578/index.html">Linux 5.0 Release</a></li>
<li><a href="../de442580/index.html">Reverse Engineering im Binärformat am Beispiel von Korg .SNG-Dateien</a></li>
<li><a href="../de442582/index.html">Wie wir es mit Mobbing versucht haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>