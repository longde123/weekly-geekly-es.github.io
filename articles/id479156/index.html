<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏪ 📅 🧑🏽 ESP32 + Arduino Core + FreeRTOS + Blynk = rumah dengan awal pikiran 🏑 📫 🦄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tujuan proyek 


 Entah bagaimana ternyata saya membangun rumah saya, sebuah kerangka. Dalam aul mewah saya tidak ada gas dan tidak diharapkan dalam w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ESP32 + Arduino Core + FreeRTOS + Blynk = rumah dengan awal pikiran</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479156/"><h2 id="celi-proekta">  Tujuan proyek </h2><br><p> Entah bagaimana ternyata saya membangun rumah saya, sebuah kerangka.  Dalam aul mewah saya tidak ada gas dan tidak diharapkan dalam waktu dekat, itu sebabnya saya memilih kerangka - yang lainnya, bagi saya, akan sangat mahal untuk memanaskan dengan listrik.  Yah, juga karena itu adalah salah satu teknologi termurah. <br>  Ok, saya melemparkan pipa ke sekitar rumah, menggantung baterai, sebuah ketel, rasanya hangat, tetapi ada sesuatu yang salah. </p><br><p>  Setelah mendengarkan diri sendiri, saya menyadari bahwa ini adalah kodok yang tidak saya sukai, bahwa ketika saya tidak di rumah (12-16 jam sehari), pemanasnya bekerja.  Dan itu mungkin tidak bekerja, nyalakan hanya sebelum kedatangan, karena kerangka memiliki sedikit kelembaman dan memungkinkan Anda untuk dengan cepat menaikkan suhu.  Situasi yang sama ketika suatu tempat lama meninggalkan rumah.  Nah, secara umum, berlari, memutar gagang boiler dengan perubahan suhu di jalan entah bagaimana tidak halal. </p><a name="habracut"></a><br><p>  Menjadi jelas bahwa tanpa otomatisasi, ketempat pun, boiler adalah yang paling sederhana, tetapi memiliki kontak untuk menghubungkan relai kontrol eksternal.  Tentu saja, Anda bisa langsung membeli boiler dengan semua fungsi yang diperlukan, tetapi bagi saya, boiler semacam itu entah bagaimana tidak manusiawi.  Ditambah lagi aku ingin jongkok dengan otak, kencing sesuatu untuk jiwa, belajar sedikit C, meskipun dalam versi Arduino. </p><br><p>  Sebenarnya tentang persyaratan: </p><br><ul><li>  kontrol suhu setpoint </li><li>  kontrol suhu pendingin tergantung pada suhu di luar ruangan atau secara manual </li><li>  zona waktu dengan pengaturan berbeda, lebih dingin di siang hari, lebih panas di malam hari </li><li>  mode otomatis, dengan transisi siang-malam otomatis </li><li>  mode manual, tanpa transisi otomatis, untuk akhir pekan </li><li>  mode non-otomatis, di mana Anda dapat secara manual mengatur suhu cairan pendingin dan menghidupkan / mematikan boiler </li><li>  kontrol pemanasan secara lokal, dari tombol dan layar dan melalui situs web / aplikasi mobile </li></ul><br><p>  Itu pada awalnya, dan kemudian saya menderita dan menambahkan: </p><br><ul><li>  kontrol lampu jalan (LED spotlight) </li><li>  sistem alarm berdasarkan sensor gerak, sirene dan lampu jalan </li><li>  mengukur energi yang dikonsumsi oleh boiler per hari / bulan / tahun + untuk setiap bulan dalam setahun </li><li>  mode alarm hanya dengan mem-flash lampu secara lambat </li><li>  mode pensinyalan dengan lampu berkedip cepat dan bunyi bip pendek dari sirene </li><li>  mode pensinyalan dengan lampu yang berkedip cepat dan suara sirene yang konstan </li></ul><br><p>  Tujuan artikel ini adalah untuk berbagi pengalaman, menggambarkan sesuatu dalam bahasa Rusia yang tidak dapat saya temukan di Internet.  Saya pikir artikel ini akan bermanfaat bagi pemula Arduino do-it-yourselfers yang sudah sedikit akrab dengan pemrograman, karena  hal-hal yang benar-benar mendasar yang tidak saya uraikan.  Saya mencoba menulis kode sejelas mungkin, saya harap saya berhasil. </p><br><h2 id="chto-bylo-v-nachale">  Apa yang ada di awal </h2><br><p>  Awalnya, proyek ini diimplementasikan pada sekelompok liar Arduino Nano + ESP8266, tetapi ESP bukan sebagai perisai, tetapi sebagai perangkat terpisah.  Kenapa begitu  Ya, karena saya sudah memiliki semua ini, tetapi tidak ada uang sama sekali dari kata itu, jadi saya tidak ingin membeli besi baru pada prinsipnya.  Mengapa ESP tidak seperti tameng?  Sekarang saya bahkan tidak ingat. </p><br><p>  Arduino mengarahkan semua proses karena memiliki jumlah GPIO yang diperlukan, dan ESP mengirim semua data ke server Blynk, karena ia tahu Internet dan tidak memiliki cukup GPIO.  Mereka menghubungkan diri mereka melalui UART, dan mengirim JSON dengan data satu sama lain.  Skema ini tidak biasa, tetapi bekerja selama satu tahun tanpa keluhan.  <a href="https://github.com/abashind/HomeHeater">Siapa pun yang</a> tertarik dapat melihat <a href="https://github.com/abashind/HomeHeater">codec</a> . </p><br><p>  Saya akan segera memesan, saya tidak terlalu ahli pada saat itu (dan bahkan sekarang saya ingin melakukannya dengan lebih baik), jadi lebih baik bagi wanita hamil dan anak-anak untuk tidak menonton.  Selain itu, semuanya ditulis dalam IDE Arduino, itu tidak akan diingat pada malam hari, yang sangat terbatas dalam hal refactoring, semuanya sangat primitif di sana. </p><br><h2 id="zhelezo">  Besi </h2><br><p>  Jadi, satu tahun telah berlalu, keuangan diizinkan untuk membeli ESP32 devkit v1, yang memiliki cukup GPIO, dapat mengakses Internet dan umumnya super controller.  Selain lelucon, saya sangat menyukainya di akhir pekerjaan. </p><br><p>  Daftar besi: </p><br><ul><li>  ESP32 devkit v1 noname China </li><li>  3 sensor suhu DS18B20, suhu di dalam rumah, di luar dan suhu pendingin di pipa </li><li>  blok 4 relay </li><li>  sensor pir HC-SR501 </li></ul><br><p>  Saya tidak akan menggambar skema, saya pikir semuanya akan jelas dari makro dengan nama pin. </p><br><h2 id="pochemu-freertos-i-arduino-core">  Mengapa FreeRTOS dan Arduino Core </h2><br><p>  Sekelompok perpustakaan ditulis di Arduino, khususnya Blynk yang sama, sehingga Anda tidak akan lepas dari Arduino Core. </p><br><p>  FreeRTOS karena memungkinkan Anda untuk mengatur pekerjaan sepotong kecil besi yang mirip dengan pekerjaan pengontrol industri lengkap.  Setiap tugas dapat dipindahkan ke tugasnya sendiri, dihentikan, dimulai, dibuat bila perlu, dihapus - semua ini jauh lebih fleksibel daripada menulis omong kosong panjang kode Arduino, ketika pada akhirnya semuanya dilakukan pada gilirannya dalam fungsi loop. </p><br><p>  Saat menggunakan FreeRTOS, setiap tugas akan dieksekusi pada waktu yang ditentukan secara ketat, jika hanya daya prosesor yang cukup.  Sebaliknya, di Arduino semua kode dieksekusi dalam satu fungsi, dalam satu utas, jika sesuatu melambat, sisa tugas akan tertunda.  Ini terutama terlihat ketika mengelola proses cepat, dalam proyek ini lampu senter yang berkedip dan bunyi sirene akan dibahas di bawah ini. </p><br><h2 id="pro-logiku">  Tentang logika </h2><br><h3 id="pro-freertos-taski">  Tentang tugas FreeRTOS </h3><br><p>  → Tautan ke <a href="https://github.com/abashind/home_auto_2019">seluruh codec proyek</a> </p><br><p>  Jadi, ketika menggunakan FreeRTOS, fungsi pengaturan memainkan peran fungsi utama, titik masuk ke aplikasi, tugas FreeRTOS (selanjutnya tugas) dibuat di dalamnya, fungsi loop tidak dapat digunakan sama sekali. </p><br><p>  Pertimbangkan tugas kecil untuk menghitung suhu cairan pendingin: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_water_temp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvParameters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (heating_mode == <span class="hljs-number"><span class="hljs-number">3</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_outside &gt; <span class="hljs-number"><span class="hljs-number">-20</span></span>) max_water_temp = <span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_outside &lt;= <span class="hljs-number"><span class="hljs-number">-20</span></span> &amp;&amp; temp_outside &gt; <span class="hljs-number"><span class="hljs-number">-25</span></span>) max_water_temp = <span class="hljs-number"><span class="hljs-number">65</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_outside &lt;= <span class="hljs-number"><span class="hljs-number">-25</span></span> &amp;&amp; temp_outside &gt; <span class="hljs-number"><span class="hljs-number">-30</span></span>) max_water_temp = <span class="hljs-number"><span class="hljs-number">70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_outside &lt;= <span class="hljs-number"><span class="hljs-number">-30</span></span>) max_water_temp = <span class="hljs-number"><span class="hljs-number">85</span></span>; } vTaskDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span> / portTICK_RATE_MS); } }</code> </pre> <br><p>  Dideklarasikan sebagai fungsi yang harus mengambil _void <code>pvParameters</code> , loop tanpa akhir diatur di dalam fungsi, saya gunakan <code>while (true)</code> . </p><br><p>  Perhitungan suhu sederhana <code>vTaskDelay(1000 / portTICK_RATE_MS)</code> (jika mode operasi memungkinkan) dan kemudian tugas tersebut di- <code>vTaskDelay(1000 / portTICK_RATE_MS)</code> oleh <code>vTaskDelay(1000 / portTICK_RATE_MS)</code> selama 1 detik.  Dalam mode ini, itu tidak memakan waktu CPU, variabel yang tugasnya bekerja, dengan kata lain, konteksnya, disimpan pada tumpukan untuk mengeluarkan mereka dari sana ketika saatnya tiba. </p><br><p>  Tugas selanjutnya harus dibuat dalam pengaturan.  Ini dilakukan dengan memanggil metode <code>xTaskCreate</code> : </p><br><p> <code>xTaskCreate(calculate_water_temp, "calculate_water_temp", 2048, NULL, 1, NULL);</code> </p> <br><p>  Ada banyak argumen, tetapi bagi kami, <em>calcul_water_temp</em> signifikan - nama fungsi yang berisi kode tugas dan 2048 adalah ukuran tumpukan dalam byte. </p><br><p>  Ukuran stack pada awalnya mengatur semua orang menjadi 1024 byte, kemudian saya menghitung metode yang diinginkan dengan mengetik, jika controller mulai jatuh dengan stack overflow (seperti yang dapat dilihat dari output di uart), saya hanya meningkatkan ukuran stack sebanyak 2 kali, jika tidak membantu, sebanyak 2 kali dan seterusnya sampai bekerja.  Tentu saja, ini tidak menghemat memori terlalu banyak, tetapi ESP32 sudah cukup, dalam kasus saya Anda tidak bisa repot dengan ini. </p><br><p>  Anda juga dapat menentukan pegangan untuk tugas - pegangan yang dengannya Anda dapat mengontrol tugas setelah pembuatan, misalnya - hapus.  Ini adalah NULL terakhir dalam contoh.  Pegangan dibuat seperti ini: </p><br><p> <code>TaskHandle_t slow_blink_handle;</code> </p> <br><p>  Selanjutnya, saat membuat tugas, pointer ke <code>xTaskCreate</code> dilewatkan ke parameter xTaskCreate: </p><br><p> <code>xTaskCreate(outside_lamp_blinks, "outside_lamp_blynk", 10000, (void *)1000, 1, &amp;slow_blink_handle);</code> </p> <br><p>  Dan jika kita ingin menghapus tugas, kita melakukan ini: </p><br><p> <code>vTaskDelete(slow_blink_handle);</code> </p> <br><p>  Cara ini digunakan dapat dilihat pada kode <code>panic_control</code> panic_control. </p><br><h3 id="pro-freertos-myuteksy">  FreeRTOS Mutex Pro </h3><br><p>  Mutex digunakan untuk menghilangkan konflik antara tugas saat mengakses sumber daya seperti uart, wifi, dll.  Dalam kasus saya, saya perlu mutex untuk wifi dan akses ke memori flash. </p><br><p>  Buat tautan ke mutex: </p><br><p> <code>SemaphoreHandle_t wifi_mutex;</code> </p> <br><p>  Dalam <code>setup</code> buat mutex: </p><br><p> <code>wifi_mutex = xSemaphoreCreateMutex();</code> </p> <br><p>  Lebih jauh, ketika kita membutuhkan akses ke sumber daya tugas, dibutuhkan mutex, dengan demikian membiarkan sisa tugas tahu bahwa sumber daya sibuk dan tidak perlu mencoba untuk bekerja dengannya: </p><br><p> <code>xSemaphoreTake(wifi_mutex, portMAX_DELAY);</code> </p> <br><p>  <code>portMAX_DELAY</code> - tunggu tanpa batas waktu sampai sumber daya dan mutex dibebaskan oleh tugas lain, selama ini tugas akan tidur. </p><br><p>  Setelah bekerja dengan sumber daya, kami memberikan mutex sehingga orang lain dapat menggunakannya: </p><br><p> <code>xSemaphoreGive(wifi_mutex);</code> </p> <br><p>  Anda dapat melihat kode lebih <code>send_data_to_blynk</code> dalam <code>send_data_to_blynk</code> send_data_to_blynk. </p><br><p>  Dalam praktiknya, tidak digunakannya mutex tidak terlihat selama pengoperasian controller, tetapi selama debug JTAG, kesalahan terus-menerus menghilang yang menghilang setelah menggunakan mutex. </p><br><h3 id="kratkoe-opisanie-tasok">  Deskripsi singkat tentang tasok </h3><br><p>  <code>get_temps</code> - menerima suhu dari sensor, setiap 30 detik, lebih sering tidak diperlukan. <br>  <code>get_time_task</code> - dapatkan waktu dari server NTP.  Sebelumnya, waktu datang dari modul RTC DS3231, tetapi mulai gagal setelah satu tahun bekerja, jadi saya memutuskan untuk membuangnya sama sekali.  Saya memutuskan bahwa bagi saya ini tidak memiliki konsekuensi khusus, terutama waktu mempengaruhi pergantian zona waktu pemanasan - siang atau malam.  Jika Internet menghilang selama pengoperasian controller, waktu akan membeku, zona waktu akan tetap sama.  Jika pengontrol mati dan setelah dihidupkan tidak ada Internet, maka waktu akan selalu 0:00:00 - mode pemanasan di malam hari. <br>  <code>calculate_water_temp</code> - dipertimbangkan di atas. <br>  <code>detect_pir_move</code> - menerima sinyal gerakan dari sensor HC-SR501.  Sensor membentuk unit logis + 3.3V ketika gerakan terdeteksi, yang dideteksi menggunakan <code>digitalRead</code> , omong-omong, pin untuk deteksi sensor ini harus ditarik hingga GND - <code>pinMode(pir_pin, INPUT_PULLDOWN);</code> <br>  <code>heating_control</code> - beralih mode pemanasan. <br>  <code>out_lamp_control</code> - kontrol lampu jalan. <br>  <code>panic_control</code> - kontrol sirene dan sorotan ketika gerakan terdeteksi.  Untuk membuat efek sirene dan lampu berkedip, tugas terpisah digunakan, <code>outside_lamp_blinks</code> dan <code>siren_beeps</code> .  Saat menggunakan FreeRTOS, flashing dan beep bekerja dengan sempurna, tepat pada interval yang ditentukan, tugas-tugas lain tidak mempengaruhi pekerjaan mereka, karena  mereka hidup dalam aliran yang terpisah.  FreeRTOS menjamin bahwa kode dalam tugas akan dieksekusi pada waktu yang ditentukan.  Ketika mengimplementasikan fungsi-fungsi ini dalam <code>loop</code> semuanya bekerja tidak begitu lancar, karena  dipengaruhi oleh eksekusi kode lain. <br>  <code>guard_control</code> - kontrol mode penjaga. <br>  <code>send_data_to_blynk</code> - mengirim data ke aplikasi Blynk. <br>  <code>run_blynk</code> - tugas untuk meluncurkan <code>Blynk.run()</code> seperti yang dipersyaratkan oleh manual untuk menggunakan Blynk.  Seperti yang saya pahami, ini diperlukan untuk mendapatkan data dari aplikasi ke controller.  Secara umum, <code>Blynk.run()</code> harus dalam satu <code>loop</code> , tetapi pada dasarnya saya tidak ingin meletakkan apa pun di sana dan menjadikannya tugas yang terpisah. <br>  <code>write_setting_to_pref</code> - rekam pengaturan dan mode operasi untuk menangkap mereka setelah reboot.  Tentang pref akan dijelaskan di bawah ini. <br>  <code>count_heated_hours</code> - menghitung waktu operasi boiler.  Saya melakukannya dengan sederhana, jika boiler dinyalakan pada saat peluncuran tugas (sekali setiap 30 detik), dalam memori flash nilai untuk kunci yang diinginkan bertambah satu. <br>  <code>send_heated_hours_to_app</code> - dalam tugas ini nilainya diekstraksi dan dikalikan dengan 0,00833 (1/120 jam), jam operasi yang diterima dari boiler dikirim ke aplikasi Blynk. <br>  <code>feed_watchdog</code> - feed Watchdog.  Saya harus menulis anjing penjaga, karena  setiap beberapa hari sekali controller bisa membeku.  Apa yang terhubung dengan tidak jelas, mungkin ada beberapa jenis gangguan dengan catu daya, tetapi menggunakan anjing penjaga memecahkan masalah ini.  Pengawas waktu 10 detik, tidak apa-apa jika controller tidak tersedia selama 10 detik. <br>  <code>heart_beat</code> - tugas dengan denyut nadi.  Ketika saya melewati controller, saya ingin tahu bahwa itu berfungsi dengan baik.  Karena  di papan saya tidak ada LED <code>Serial.begin(9600);</code> , saya harus menggunakan LED UART - instal <code>Serial.begin(9600);</code>  dan menulis string panjang di UART.  Ini bekerja dengan cukup baik. </p><br><h3 id="esp32-nvs-wear-leveling">  Leveling pemakaian ESP32 NVS </h3><br><p>  <em>Deskripsi berikut agak kasar, secara harfiah di jari, hanya untuk menyampaikan inti masalah.</em>  <em><a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html">Lebih detail</a></em> </p><br><p>  Arduino menggunakan memori EEPROM untuk menyimpan data dalam memori non-volatile.  Ini adalah memori kecil di mana setiap byte dapat ditulis dan dihapus secara terpisah, sedangkan memori flash hanya dihapus oleh sektor. </p><br><p>  Tidak ada EEPROM di ESP32, tetapi biasanya ada memori flash 4 Mb di mana Anda dapat membuat partisi untuk firmware pengontrol atau untuk menyimpan data pengguna.  Bagian untuk data pengguna ada beberapa jenis - NVS, FATFS, SPIFFS.  Itu harus dipilih berdasarkan pada tipe data yang dimaksudkan untuk merekam. </p><br><p>  Karena  semua data yang ditulis dalam proyek ini bertipe Int, saya memilih NVS - Penyimpanan Non-Volitile.  Jenis partisi ini sangat cocok untuk menyimpan data yang kecil dan sering kali ditimpa.  Untuk memahami alasannya, Anda harus masuk lebih jauh ke dalam organisasi NVS. </p><br><p>  Seperti EEPROM dan FLASH, ada batasan untuk menimpa data, byte dalam EEPROM dapat ditimpa dari 100.000 menjadi 1.000.000 kali, dan sektor FLASH adalah sama.  Jika kita menulis data satu detik sekali, maka kita mendapatkan 60 detik x 60 menit x 24 jam = 86.400 kali / hari.  Artinya, dalam mode ini, byte akan bertahan 11 hari, yang sedikit.  Setelah itu byte tidak akan tersedia untuk menulis dan membaca. </p><br><p>  Untuk mengatasi masalah ini, fungsi <code>update()</code> <code>put()</code> dari perpustakaan Arduino EEPROM hanya menulis data ketika itu berubah.  Artinya, Anda dapat menulis setiap detik beberapa pengaturan dan kode mode yang berubah sangat jarang. </p><br><p>  NVS menggunakan metode berbeda untuk mengendalikan leveling keausan.  Seperti disebutkan di atas, data dalam sektor flash dapat ditulis dalam bagian-bagian, tetapi hanya seluruh sektor yang dapat dihapus.  Oleh karena itu, perekaman data dalam NVS dilakukan dalam semacam jurnal, jurnal ini dibagi menjadi beberapa halaman, yang ditempatkan dalam satu sektor memori flash.  Data ditulis dalam pasangan kunci: nilai.  Bahkan, ini bahkan lebih mudah daripada dengan EEPROM, karena  bekerja dengan nama yang bermakna lebih mudah daripada dengan alamat di memori.  <strong>Pembaruan:</strong> panjang kunci tidak lebih dari 15 karakter! </p><br><p>  Jika Anda pertama kali menulis nilai <code>1</code> ke tombol kunci, dan kemudian menulis nilai <code>2</code> ke kunci yang sama, nilai pertama tidak akan dihapus, itu hanya akan ditandai sebagai dihapus (Dihapus), dan entri baru akan ditambahkan ke log: </p><br><p><img src="https://habrastorage.org/webt/pw/ri/of/pwriofnineuwy7bmctgzcngiqrk.jpeg"></p><br><p>  Jika Anda mencoba membaca data oleh <code>somekey</code> terakhir dari kunci ini akan dikembalikan.  Karena  Karena log adalah umum, nilai kunci yang berbeda disimpan di samping satu sama lain saat ditulis. </p><br><p>  Halaman memiliki status, Kosong - kosong, tanpa entri, Aktif - data saat ini sedang ditulis untuk itu, Penuh - penuh, Anda tidak dapat menulis untuk itu.  Segera setelah halaman kehabisan ruang, dia dari <br>  Aktif menjadi Penuh, dan halaman Kosong berikutnya menjadi Aktif. </p><br><p><img src="https://habrastorage.org/webt/6q/lz/ym/6qlzymofwdhy9ah2x-ekgpd23tq.jpeg"></p><br><p>  Sejauh yang saya mengerti dari dokumentasi di situs web Espressif dan berbagai forum, pembersihan halaman dimulai ketika halaman gratis berakhir.  Lebih tepatnya, menurut <a href="">ini</a> , penghapusan akan terjadi ketika hanya 1 halaman gratis yang tersisa. </p><br><p>  Jika halaman perlu dihapus, maka catatan saat ini (Tidak terhapus) dipindahkan ke halaman lain, dan halaman tersebut ditimpa. </p><br><p>  Dengan demikian, operasi write-erase untuk setiap halaman tertentu cukup langka, semakin banyak halaman - semakin jarang.  Berdasarkan ini, saya meningkatkan ukuran partisi NVS menjadi 1 MB, pada tingkat perekaman saya ini sudah cukup untuk 170 tahun, yang secara umum sudah cukup.  Tentang mengubah ukuran bagian NVS akan menjadi yang berikutnya. </p><br><p>  Untuk pekerjaan yang mudah dengan NVS, ESP32 untuk Arduino Core memiliki pustaka preferensi yang ditulis, cara bekerja dengannya ditulis di <a href="">sini</a> . </p><br><h3 id="nemnogo-o-visualgdb">  Sedikit tentang VisualGDB </h3><br><p>  Segera setelah saya mulai bekerja dengan Arduino IDE, saya langsung dikejutkan oleh fungsionalitas yang menyedihkan dibandingkan dengan Visual Studio.  Mereka mengatakan bahwa VS juga bukan air mancur, meskipun itu cocok untuk saya, tetapi menulis sesuatu lebih dari 50 baris dalam IDE Arduino sangat menyakitkan dan panjang.  Maka, muncul pertanyaan untuk memilih IDE untuk pengembangan.  Karena  Saya kenal dengan VS, saya menetap di <a href="https://visualgdb.com/tutorials/arduino/esp32/">VisualGDB</a> . </p><br><p>  Setelah Arduino IDE, pengembangan untuk ESP32 hanyalah surga.  Apa transisi ke definisi, pencarian panggilan dalam proyek dan kemampuan untuk mengubah nama variabel. </p><br><h3 id="izmenenie-tablicy-razdelov-esp32-pri-rabote-s-visualgdb">  Mengubah Tabel Partisi ESP32 dengan VisualGDB </h3><br><p>  Seperti disebutkan di atas, tabel dapat diubah dengan partisi ESP32, kami akan mempertimbangkan bagaimana hal ini dapat dilakukan. <br>  Tabel diedit sebagai file csv, secara default VisualGDB menulis tabel berikut: </p><br><pre> <code class="plaintext hljs">Name, Type, SubType, Offset, Size, Flags nvs, data, nvs, 0x9000, 0x5000, otadata, data, ota, 0xe000, 0x2000, app0, app, ota_0, 0x10000, 0x140000, app1, app, ota_1, 0x150000,0x140000, spiffs, data, spiffs, 0x290000,0x170000,</code> </pre> <br><p>  Di sini kita melihat bagian di bawah NVS, dua bagian untuk aplikasi, dan beberapa bagian lagi.  Dari nuansa, dapat dicatat bahwa app0 (aplikasi Anda) harus selalu ditulis pada offset 0x10000, mulai dari alamat nol, jika bootloader tidak akan mendeteksinya.  Juga, offset harus dipilih sehingga bagian tidak saling "tumpang tindih".  Tabel partisi itu sendiri ditulis dengan offset 0x8000.  Seperti yang Anda lihat, ukuran NVS dalam hal ini adalah 0x5000 - 20KB, yang tidak terlalu banyak. </p><br><p>  Saya memodifikasi tabel partisi sebagai berikut: </p><br><pre> <code class="plaintext hljs">Name, Type, SubType, Offset, Size, Flags app0, app, ota_0, 0x10000, 0x140000, nvs, data, nvs, , 1M, otadata, data, ota, , 0x2000, spiffs, data, spiffs, , 0x170000,</code> </pre><br><p>  Jangan lupa untuk menambahkan kisi sebelum Nama, jika Anda menggunakan tabel ini, Anda perlu baris ini untuk dianggap sebagai komentar. </p><br><p>  Seperti yang Anda lihat, ukuran NVS meningkat menjadi 1 MB.  Jika Anda tidak menentukan offset, maka bagian akan segera dimulai setelah yang sebelumnya, sehingga cukup untuk menunjukkan offset hanya untuk app0.  File CSV dapat diedit dalam notepad sebagai txt dan kemudian mengubah izin ke csv untuk file yang disimpan. </p><br><p>  Selanjutnya, tabel partisi harus dikonversi ke biner, karena  memasuki controller dalam bentuk ini.  Untuk melakukan ini, jalankan konverter: <br>  <code>c:\Users\userName\Documents\ArduinoData\packages\esp32\hardware\esp32\1.0.3\tools\gen_esp32part.exe part_table_name.csv part_table_name.bin</code> .  Parameter pertama adalah CSV Anda, parameter kedua adalah biner output. </p><br><p>  Biner yang dihasilkan harus dimasukkan ke dalam <code>c:\Users\userName\Documents\ArduinoData\packages\esp32\hardware\esp32\1.0.3\tools\partitions\part_table_name.csv</code> , setelah itu perlu ditentukan bahwa dialah yang diambil untuk membangun solusi, dan tidak ada tabel partisi default.  Anda dapat melakukan ini dengan menuliskan nama tabel Anda di file <code>c:\Users\userName\Documents\ArduinoData\packages\esp32\hardware\esp32\1.0.3\boards.txt</code> .  Dalam kasus saya, ini adalah <code>esp32doit-devkit-v1.build.partitions=part_table_name</code> <br>  Setelah manipulasi ini, VisualGDB saat membangun aplikasi akan mengambil persis tabel partisi Anda dan memasukkannya ke dalam <br>  <code>~project_folder_path\Output\board_name\Debug\project_name.ino.partitions.bin</code> , dari tempat itu sudah akan dituangkan ke dalam board. </p><br><h3 id="jtag-otladchik-cjmc-ft232h">  JTAG debugger CJMC-FT232H </h3><br><p>  Sejauh yang saya tahu, ini adalah debugger termurah yang dapat bekerja dengan ESP32, harganya sekitar 600 rubel, ada banyak dari mereka di Aliexpress. </p><br><p><img src="https://habrastorage.org/webt/gn/cu/gm/gncugmqpjnb1hbmj630nnegxjgq.jpeg"></p><br><p>  Ketika Anda menghubungkan debugger, Windows menginstalnya pada driver yang tidak sesuai yang perlu diubah menggunakan program Zadig, semuanya sederhana di sana, saya tidak akan menjelaskannya. </p><br><p>  Terhubung ke ESP32 devkit-v1 dengan cara berikut: <br>  FT232H - ESP32 <br>  AD0 - GPIO13 <br>  AD1 - GPIO12 <br>  AD2 - GPIO15 <br>  AD3 - GPIO14 <br>  Kemudian, di <code>Project -&gt; VisualGDB Project Properties</code> Anda perlu membuat pengaturan berikut: </p><br><p><img src="https://habrastorage.org/webt/eg/oi/7b/egoi7bhrpkjaprfvyz-jd9puccw.jpeg"></p><br><p>  Kemudian klik Test.  Kadang-kadang terjadi bahwa koneksi tidak dibuat pertama kali, proses tampaknya membeku, maka Anda perlu menyela dan mengulangi Tes.  Jika semuanya beres, proses pengujian koneksi membutuhkan waktu sekitar 5 detik. </p><br><p>  Saya biasanya menyusun proyek dan mengunggahnya melalui USB ke ESP32 itu sendiri (bukan melalui debugger), setelah itu saya mulai debugging menggunakan <code>Debug -&gt; Attach to Running Embedded Firmware</code> .  Dalam kode, Anda dapat mengatur breakpoints, lihat nilai-nilai variabel pada saat breakdown, dan di jendela <code>Debug -&gt; Windows -&gt; Threads</code> Anda bisa melihat kode FreeRTOS mana kode berhenti, yang berguna jika kesalahan terjadi selama debugging.  Fungsi-fungsi debugger ini cukup bagi saya untuk bekerja dengan nyaman. <br>  Ketika saya mulai bekerja dengan NVS, debugging terus-menerus terganggu oleh kesalahan yang tidak jelas.  Seperti yang saya pahami, ini karena debugger perlu membuat sesuatu seperti dump di bagian NVS default, tetapi pada saat ini NVS sudah digunakan oleh controller.  Tentu saja, ini dapat dielakkan dengan membuat 2 partisi NVS, satu dengan nama default untuk debugging, dan yang lainnya untuk kebutuhannya sendiri.  Tapi tidak ada yang rumit di sana, dalam kode yang ditambahkan, itu berfungsi pertama kali, jadi saya tidak memeriksanya. </p><br><h3 id="glyuki-esp32">  Gangguan ESP32 </h3><br><p>  Seperti perangkat apa pun dengan Aliexpress, papan ESP32 saya memiliki kesalahan sendiri yang tidak dijelaskan di mana pun.  Ketika dia tiba, saya memberi makan beberapa periferal yang bekerja pada I2C dari papan, tetapi setelah beberapa waktu, papan mulai reboot jika ada peralatan yang mengonsumsi atau bahkan hanya kapasitor yang terpasang pada kaki + 5V.  Mengapa demikian benar-benar tidak dapat dipahami. </p><br><p>  Sekarang saya menyalakan papan dari muatan Cina 0.7A, sensor ds18b20 dari kaki papan 3.3V, dan sensor relai dan gerak dari muatan lain 2A.  Kaki GND papan tentu saja terhubung ke pin GND dari sisa setrika.  Murah dan ceria adalah pilihan kami. </p><br><h3 id="o-rezultatah-proekta">  Tentang hasil proyek </h3><br><p>  Saya mendapat kesempatan untuk secara fleksibel mengontrol pemanasan di rumah, menghemat uang dan keringat yang didapat.  Saat ini, jika pemanasan mempertahankan 23 derajat sepanjang hari di -5 - -7 di luar, itu adalah sekitar 11 jam operasi boiler.  Jika pada siang hari mempertahankan 20 derajat dan menghangatkan hanya 23 di malam hari, maka ini sudah 9 jam pengoperasian boiler.  Kapasitas boiler adalah 6 kW, dengan harga kilowatt 2.2 rubel saat ini, ini adalah sekitar 26,4 rubel per hari.  Durasi musim pemanasan di daerah kami adalah 200 hari, suhu rata-rata di musim pemanasan hanya sekitar -5 derajat.  Jadi, kita mendapatkan penghematan sekitar 5000r untuk musim pemanasan. </p><br><p>  Biaya peralatan tidak melebihi 2000r, yaitu, biaya akan ditolak dalam beberapa bulan, belum lagi fakta bahwa sistem otomasi seperti itu akan menelan biaya setidaknya 20.000r.  Hal lain adalah bahwa saya menghabiskan sekitar satu minggu waktu kerja murni untuk menulis firmware dan debugging, tetapi dalam pekerjaan, misalnya, saya akhirnya menyadari apa pointer di C ++ dan mendapat banyak pengalaman lain (misalnya, pengalaman berjam-jam men-debug masalah-masalah kecil yang tidak dapat dipahami).  Dan pengalaman, seperti yang Anda tahu, sulit ditaksir terlalu tinggi. </p><br><p>  Cuplikan layar aplikasi seluler Blynk: </p><br><p><img src="https://habrastorage.org/webt/f8/a-/57/f8a-57tioype-tcgmjmodpagpwa.jpeg"></p><br><p><img src="https://habrastorage.org/webt/ez/3a/o3/ez3ao3_ht2lgjsbf9jvv_xcoksc.jpeg"></p><br><p><img src="https://habrastorage.org/webt/xi/xv/f-/xixvf-6pvrnw-2trm_toszimwrm.jpeg"></p><br><p>  Tentu saja, kode dalam proyek ini bukan sebuah mahakarya, tetapi saya menulisnya dalam kondisi kurangnya waktu dan berfokus terutama pada keterbacaan.  Tidak ada waktu untuk memperbaiki.  Secara umum, saya punya banyak alasan mengapa kode saya sangat menakutkan, tetapi ini adalah favorit saya, jadi saya akan memikirkannya, saya tidak akan mengembangkan topik lebih lanjut. </p><br><p>  Jika tulisan saya membantu seseorang, saya akan dengan senang hati.  Saya akan senang dengan komentar dan saran. </p><br><div class="spoiler">  <b class="spoiler_title">Daftar referensi</b> <div class="spoiler_text"><ol><li>  <a href="http://microsin.net/programming/ARM/freertos-part1.html">http://microsin.net/programming/ARM/freertos-part1.html</a> </li><li>  <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html">https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html</a> </li><li>  <a href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/partition-tables.html">https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/partition-tables.html</a> </li><li>  <a href="https://docs.blynk.cc/">https://docs.blynk.cc/</a> </li></ol><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479156/">https://habr.com/ru/post/id479156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479144/index.html">Apakah saya perlu mendaftarkan merek saya</a></li>
<li><a href="../id479146/index.html">Perbandingan alat pintas \ VPN</a></li>
<li><a href="../id479150/index.html">Robot pertanian semakin maju</a></li>
<li><a href="../id479152/index.html">Bereaksi dan Vue tanpa npm dan build</a></li>
<li><a href="../id479154/index.html">Masih bertengkar atau cukup?</a></li>
<li><a href="../id479158/index.html">7 prinsip dasar ITIL</a></li>
<li><a href="../id479162/index.html">Auroras di planet tata surya</a></li>
<li><a href="../id479164/index.html">Apa itu EEG dan mengapa itu perlu</a></li>
<li><a href="../id479166/index.html">Menulis modul kedaluwarsa capped Anda untuk tarantool</a></li>
<li><a href="../id479168/index.html">Cara membuat RESTful API on Symfony 5 + API Platform untuk proyek MODX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>