<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦 👨🏽‍🏫 👨🏻‍🔧 Comment rédiger un contrat intelligent pour ICO en 5 minutes 👶🏼 👩🏼‍🤝‍👩🏻 🤹🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! Dans cet article, je vais vous expliquer comment lancer un contrat de collecte d'argent intelligent pour votre ICO sur Ethereum en 5 m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment rédiger un contrat intelligent pour ICO en 5 minutes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414493/"><img src="https://habrastorage.org/webt/rv/6d/_c/rv6d_cyxk3ix-su6le9q4lyqntc.png"><br><br>  Bonjour à tous!  Dans cet article, je vais vous expliquer comment lancer un contrat de collecte d'argent intelligent pour votre ICO sur Ethereum en 5 minutes et plusieurs commandes dans le terminal.  Cet essai vous fera potentiellement économiser des dizaines de milliers de dollars américains, car n'importe quel programmeur - et pas un programmeur aussi - pourra lancer un contrat intelligent audité et sécurisé (au lieu de payer 15 000 $ - 75 000 $ pour le développement).  En bref, vous pouvez envoyer de l'argent à ce contrat intelligent et recevoir des jetons ERC20 pour cela.  On peut dire que cet article est un recueil de toute l'expérience que j'ai acquise en lançant une ICO pour mon projet. <br><br>  Sur Internet, ceux-ci sont déjà remplis d'articles sur les contrats intelligents, mais dès que vous commencez à en rédiger un, vous découvrez que les informations sont répétées partout, et il n'y a tout simplement pas de tutoriels sur la façon de tromper votre ERC20, ou ils sont déjà obsolètes.  Soit dit en passant, pour que cet article reste pertinent, je vais essayer d'indiquer les endroits potentiels où il peut devenir obsolète (et comment y remédier).  C'est parti! <br><a name="habracut"></a><br><h2>  Solidité </h2><br>  C'est le nom de la langue principale que l'équipe du kéfir a développée pour lancer des contrats intelligents.  Si vous êtes programmeur, passez simplement en revue la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation du langage</a> - c'est indécemment simple.  Soit dit en passant, ils ont rendu les choses simples, de sorte qu'il était plus difficile de se tromper en écrivant un contrat intelligent.  Donc, <b>absolument tout</b> programmeur, au moins au niveau junior, pourra le comprendre.  <b>Il ne sert à rien</b> de payer d'énormes sommes d'argent aux développeurs qui connaissent la solidité - il sera beaucoup moins cher de former un développeur existant. <br><br><h2>  Contrats intelligents </h2><br>  ... et tout ce que vous devez savoir à leur sujet.  Ignorez cette section si vous n'êtes pas programmeur.  Un contrat intelligent est un morceau de code.  En principe, il s'agit d'une classe de solidité (OOP, oui), qui a deux types de fonctions: à changement d'état et non à changement d'état.  Eh bien, pour exécuter des fonctions dans un contrat intelligent simplement en lui envoyant du kéfir, vous devez marquer comme <code>payable</code> cette fonction. <br><br>  State est un entrepôt de données, blockchain, EPT.  Les contrats peuvent changer la blockchain (état, stockage) - mais pour changer la blockchain, vous devez payer le kéfir aux mineurs.  La façon dont ils partageront le kéfir ne sera pas analysée dans le cadre de cet article.  Le paiement aux mineurs pour l'exécution d'un code à changement d'état s'appelle Gas.  Si quelqu'un de l'extérieur jette du kéfir à l'adresse d'un contrat intelligent avec un appel à une fonction marquée <code>payable</code> mais non marquée <code>Constant</code> , <code>View</code> ou <code>Pure</code> , le montant nécessaire de kéfir pour le paiement aux mineurs sera déduit du montant envoyé.  Généralement, dans les jetons ERC20, ce sont des fonctions qui distribuent l'expéditeur de jeton pour le kéfir ou transfèrent des jetons d'un détenteur de jeton à un autre. <br><br>  Et si vous marquez une fonction dans le contrat avec les mots <code>Constant</code> ou <code>View</code> (ils signifient la même chose, ils ne vous permettent que de lire l'état) ou <code>Pure</code> (la même chose, vous ne lisez même pas l'état), alors vous n'aurez même pas besoin de dépenser du kéfir pour cette fonction!  Je dirai même plus que ces fonctions n'ont pas besoin d'être appelées par des transactions - après tout, n'importe quel client de yaourt peut théoriquement l'exécuter à la maison - et personne n'a plus besoin de le savoir (après tout, rien n'est écrit dans la blockchain). <br><br>  Et il y a deux choses importantes dans la solidité: l'héritage multiple et les modificateurs de fonction.  Vous devez également les connaître. <br><br>  Le premier - juste des contrats peuvent être hérités simultanément de plusieurs classes telles que <code>TimedCrowdsale</code> , <code>CappedCrowdsale</code> , <code>MintedCrowdsale</code> , <code>Ownable</code> - en même temps, les fonctions des constructeurs sont également lancées l'une après l'autre - mais je l'expliquerai plus tard à titre d'exemple. <br><br>  La seconde est la possibilité de créer des fonctions qui seront ensuite insérées dans d'autres fonctions.  C'est comme une simple encapsulation, juste un peu plus flexible - c'est littéralement <b>un modèle de</b> fonction.  Lorsque vous créez un modificateur, vous écrivez le caractère spécial <code>_</code> où vous voulez dire le code d'une fonction utilisant ce modificateur.  Autrement dit, les modificateurs ne sont pas uniquement des fonctionnalités encapsulées qui renvoient une valeur;  il s'agit d'un modèle de fonction lorsque le code d'un modificateur est littéralement inséré dans une fonction utilisant ce modificateur. <br><br>  Passons à la pratique. <br><br><h2>  Environnement de cuisson </h2><br>  Si vous ne savez pas ce qu'est un terminal, lisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article ici</a> .  Si vous êtes sous Windows, définissez-vous un terminal via WLS.  Si vous connaissez déjà le terminal, continuons.  Aussi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mettez-vous</a> immédiatement Node.js - il sera nécessaire pour les prochaines étapes.  Il est préférable d'installer LTS, mais, en fait, cela ne fait aucune différence laquelle des versions modernes du nœud installer. <br><br>  La première chose que nous installons et démarrons immédiatement le processus de synchronisation des blocs est <code>geth</code> .  En bref, il s'agit d'un utilitaire écrit en Go qui nous permettra d'exécuter le nœud éther sur l'ordinateur local et de nous connecter aux réseaux de test et réels.  Vous pouvez installer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">via des programmes d'installation</a> , mais je vous recommande vivement de vous <code>geth</code> immédiatement dans Terminal, comme décrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Vous pouvez vérifier si vos normes <code>geth</code> sont <code>geth</code> exécutant la commande dans le terminal: <br><br><pre> <code class="bash hljs">geth version</code> </pre> <br>  Si vous avez craché la version geth - tout est ajouré, continuez le tutoriel.  Sinon - mauvais, correct;  il semble que vous devrez faire des ébats avec le terminal et votre système d'exploitation - mais ce n'est pas la première fois que vous le comprenez.  Comment installer geth, exécutez la commande dans le terminal: <br><br><pre> <code class="bash hljs">geth --testnet console</code> </pre> <br>  Cela lancera le processus de synchronisation de votre nœud avec le serveur de test, dont les blocs peuvent être consultés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Vous pouvez vérifier si vous vous êtes synchronisé avec le réseau dans la console <code>geth</code> en <code>geth</code> : <br><br><pre> <code class="bash hljs">eth.blockNumber <span class="hljs-comment"><span class="hljs-comment">#  0 —     eth.syncing #     false,    </span></span></code> </pre> <br>  Le processus de synchronisation m'a pris de 1 à 4 heures - quand comment.  De plus, en plus de la synchronisation des blocs, vous devrez également attendre la synchronisation des états - elle est souvent plus longue que la synchronisation des blocs.  Vous pouvez également utiliser les <code>geth</code> avec l'indicateur <code>--light</code> - puis la synchronisation dure de quelques secondes à une minute et vous pouvez toujours déployer des contrats. <br><br>  D'accord, nous avons installé le premier utilitaire - mettez le suivant.  Nous devons mettre un analogue de <code>geth</code> , seulement une simulation de chaîne de blocs très locale - <code>testrpc</code> .  Oui, nous avons <b>3 blockchains</b> : <br><br><ul><li>  <code>testrpc</code> - simulation de blockchain locale;  rapide, mais faux et stocké uniquement sur votre machine </li><li>  <code>geth --testnet</code> est déjà une véritable blockchain, mais vous ne perdrez pas d'argent où vous pouvez obtenir du kéfir et tester gratuitement toutes <code>geth --testnet</code> </li><li>  <code>geth</code> - mainnet, main, blockchain réel, kéfir réel;  le tout de façon adulte, les erreurs ici sont les pertes de kéfir réel </li></ul><br>  En conséquence, nous allons démarrer le contrat de test avec <code>testrpc</code> , puis l'installer dans <code>geth --testnet</code> , puis le télécharger directement dans <code>geth</code> . <br><br>  Nous <code>testrpc</code> en exécutant la commande suivante: <br><br><pre> <code class="bash hljs">npm install -g ethereumjs-testrpc</code> </pre> <br>  Eh bien, ou il monte immédiatement avec une truffe, car maintenant <code>testrpc</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous l'aile de truffe</a> et s'appelle <code>ganache-cli</code> .  Bien que le diable le sache, tout fonctionnait <code>testrpc</code> avec vanilla <code>testrpc</code> .  Et si ça marche, ne le touchez pas, comme on m'a enseigné à l'académie intergalactique.  Vous pouvez également l'exécuter pour vérifier l'installation en enregistrant la <code>truffle</code> dans la console, mais la blockchain de test est déjà synchronisée avec nous - ne le dérange pas. <br><br>  Eh bien, compris les chaînes de blocs?  Il y a maintenant des nœuds et le test est même synchronisé?  Nous mettons un utilitaire pratique pour travailler avec des contrats intelligents sur le kéfir - <code>truffle</code> , avec la commande suivante: <br><br><pre> <code class="bash hljs">npm install -g truffle truffle version <span class="hljs-comment"><span class="hljs-comment">#  ,  ,  </span></span></code> </pre> <br>  Truffle est un outil qui vous permet de conserver des contrats intelligents dans différents fichiers, d'importer d'autres fichiers et de compiler également votre code de contrat intelligent en un seul bytecode (illisible par une personne), il trouve automatiquement un <code>geth</code> cours d'exécution local (test et réel ) ou <code>testrpc</code> , déployez votre contrat intelligent sur ce réseau.  En outre, la vérification des erreurs dans votre code de contrat intelligent et les transactions récemment terminées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aident également au débogage</a> .  Masthead, en bref. <br><br>  À ce stade, vous devriez avoir installé: <code>testrpc</code> , <code>geth</code> , <code>truffle</code> - si l'un de ces éléments est manquant ou si la version ne crache pas sur la console sur demande, corrigez cela;  sinon vous ne réussirez pas. <br><br><blockquote>  De plus, j'ai lancé un simple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">script bash</a> qui va tout installer pour vous.  Appelé comme ceci: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">source</span></span> &lt;(curl -s https://raw.githubusercontent.com/backmeupplz/eth-installer/master/install.sh)</code> </pre> <br>  - mais je ne l'ai encore jamais testé, donc je ne suis pas sûr de ses performances.  Cependant, je serai heureux de tirer des demandes. </blockquote><br><h2>  Contrat Figash </h2><br>  Tout a déjà été inventé et écrit pour vous - c'est bien.  Un petit bruant sera tout de même - mais je vais essayer de le minimiser.  Nous utiliserons des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrats ERC20 prêts à l'emploi d'OpenZeppelin</a> - c'est maintenant la norme de l'industrie, ils ont passé l'audit, et en effet ils utilisent tous leur code.  Merci beaucoup pour votre contribution à l'open source. <br><br>  Faites un <code>cd</code> dans un dossier sûr, puis écrivez: <br><br><pre> <code class="bash hljs">mkdir contract &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> contract</code> </pre> <br>  Dans ce dossier, nous allons travailler.  Créez un talon ici pour notre contrat intelligent: <br><br><pre> <code class="bash hljs">truffle init</code> </pre> <br>  Trébucher, clairement.  Nous avons maintenant deux dossiers très importants dans lesquels nous allons grimper: les <code>contracts</code> et les <code>migrations</code> .  Le premier est le code de nos contrats, le second est le code de la truffe pour savoir quoi faire lors du déploiement de contrats sur la blockchain. <br><br>  Ensuite, nous devons prendre le code de contrat intelligent actuel de npm et, en fait, démarrer le projet lui-même: <br><br><pre> <code class="bash hljs">npm init -y <span class="hljs-comment"><span class="hljs-comment">#     ( -y) npm install -E openzeppelin-solidity #       ( -E)</span></span></code> </pre> <br>  Eh bien, le code des contrats intelligents d'OpenZeppelin est dans notre poche dans le dossier <code>node_modules/openzeppelin-solidity/contracts</code> .  Maintenant, nous allons dans le dossier principal des <code>contracts</code> , supprimons tous les fichiers et ajoutez les fichiers <code>MyToken.sol</code> et <code>MyCrowdsale.sol</code> - naturellement, vous <code>MyCrowdsale.sol</code> vos contrats différemment.  Le premier sera un contrat pour notre Token ERC20, et le second sera un contrat de notre ICO, qui acceptera le kéfir et distribuera <code>MyToken</code> gens.  Cet article peut être obsolète, mais vous pouvez toujours voir comment OpenZeppelin vous suggère de créer des contrats <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans leur référentiel</a> .  Voici à quoi <code>MyToken.sol</code> : <br><br><pre> <code class="javascript hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Imports import "../node_modules/openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol"; // Main token smart contract contract MyToken is MintableToken { string public constant name = "My Token"; string public constant symbol = "MTKN"; uint8 public constant decimals = 18; }</span></span></code> </pre> <br>  Bien - vous avez un contrat intelligent de votre propre jeton (changez simplement les noms dans les constantes)!  Vous pouvez voir quel <code>MintableToken</code> héritage il y a de <code>MintableToken</code> - mais tout est aussi simple que possible là-bas.  Il s'agit d'un jeton qui peut être émis (de l'anglais «Mint» - à mint), et seul le propriétaire a le droit de le délivrer, car le <code>MintableToken</code> est également hérité de <code>Ownable</code> .  De plus, <code>MintableToken</code> hérite également des classes de jetons ERC20 écrites par OpenZeppelin, dans lesquelles l'interface ERC20 est implémentée: <br><br><pre> <code class="javascript hljs">contract ERC20Basic { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">totalSupply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">balanceOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address who</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transfer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address to, uint256 value</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bool</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">event</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transfer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address indexed from, address indexed to, uint256 value</span></span></span><span class="hljs-function">); }</span></span></code> </pre> <br>  Oui, vous avez ici toute l'interface ERC20.  Est-ce difficile?  Je ne pense pas.  Il vous donne la possibilité de voir combien de jetons ont été émis, de vérifier le solde de l'adresse et de transférer des jetons vers une autre adresse en crachant un événement de transfert pour les clients de kéfir léger sur le réseau.  Et tout cela, vous obtenez gratuitement dans votre <code>MyToken.sol</code> grâce au travail d'OpenZeppelin - ils sont super. <br><br>  Et maintenant passons à la partie principale de notre ICO - nous devons accepter le kéfir et distribuer <code>MyToken</code> !  Voici à quoi ressemblera votre <code>MyCrowdsale.sol</code> : <br><br><pre> <code class="javascript hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Imports import "../node_modules/openzeppelin-solidity/contracts/crowdsale/emission/MintedCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/crowdsale/distribution/RefundableCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/crowdsale/validation/CappedCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol"; contract MyCrowdsale is CappedCrowdsale, RefundableCrowdsale, MintedCrowdsale { constructor( uint256 _openingTime, uint256 _closingTime, uint256 _rate, address _wallet, uint256 _cap, MintableToken _token, uint256 _goal ) public Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap) TimedCrowdsale(_openingTime, _closingTime) RefundableCrowdsale(_goal) { //   ,  ,    // ,     require(_goal &lt;= _cap); } }</span></span></code> </pre><br>  Tant bien que mal, qu'est-ce qui nous prend?  Quoi, les garçons, les contrats intelligents?  Notre vente publique de jetons hérite de trois des propriétés les plus populaires: elle a un capuchon rigide, qui ne peut plus être collecté;  capuchon souple, ne recueillant pas quels esters sont retournés;  heure de début et de fin de la vente de jetons.  En fait, que faut-il d'autre pour le bonheur? <br><br>  Les programmeurs, notez comment les constructeurs de plusieurs classes d'héritage sont organisés dans une rangée et obtenez des arguments du constructeur principal de <code>MyCrowdsale</code> .  De plus, nous vérifions que la touche fixe est plus haute que la touche programmable - Ales Gut!  Ne vous <code>MyCrowdsale</code> pas non <code>MyCrowdsale</code> paramètres <code>MyCrowdsale</code> constructeur <code>MyCrowdsale</code> - nous les passerons au stade du déploiement du contrat dans la truffe. <br><br>  C'est tout - vous avez des contrats prêts à l'emploi de votre propre jeton ERC20 et même un contrat intelligent ICO, qui est configuré selon votre désir et distribue vos jetons pour le kéfir.  En outre, il est pris en charge par tous les portefeuilles ERC20 - une erreur!  Passons aux tests manuels et au déploiement. <br><br><h2>  Migrations </h2><br>  Comme je l'ai dit plus tôt, nous allons tester séquentiellement sur trois réseaux de blockchain, mais le processus de test avec des stylos sera toujours le même.  Commençons par <code>testrpc</code> , puis passons à <code>geth --testnet</code> et continuons à <code>geth</code> .  Sou phares, nous venons d'écrire le code, essayons de le compiler.  Dans le dossier du projet, écrivez: <br><br><pre> <code class="bash hljs">truffle compile</code> </pre> <br>  Si tout est compilé sans problème, vous verrez le <code>build</code> , qui contiendra le krakozyab pour la truffe afin qu'il puisse intégrer le bytecode de vos contrats intelligents dans la blockchain.  Avant de déployer des contrats intelligents, nous devons dire à la truffe quoi faire.  Le déploiement truffier des contrats intelligents s'appelle la migration - eh bien, restons-en à cette terminologie.  Accédez à <code>migrations/1_initial_migration.js</code> et modifiez-le de la manière suivante: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = artifacts.require(<span class="hljs-string"><span class="hljs-string">"../contracts/MyToken.sol"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crowdsale = artifacts.require(<span class="hljs-string"><span class="hljs-string">"../contracts/MyCrowdsale.sol"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">deployer, network, accounts</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> openingTime = <span class="hljs-number"><span class="hljs-number">1514764800</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 15  2018 const closingTime = 1561939200; // 1  2019 const rate = new web3.BigNumber(1); // 1   1  const wallet = '0x281055afc982d96fab65b3a49cac8b878184cb16'; // - const cap = 200 * 1000000; //  const goal = 100 * 1000000; //  return deployer .then(() =&gt; { return deployer.deploy(token); }) .then(() =&gt; { return deployer.deploy( crowdsale, openingTime, closingTime, rate, wallet, cap, token.address, goal ); }) .then(() =&gt; { // Crowdsale    var tokenContract = web3.eth.contract(token.abi).at(token.address); web3.eth.defaultAccount = web3.eth.accounts[0]; tokenContract.transferOwnership(crowdsale.address); }); };</span></span></code> </pre> <br>  Il s'agit du même fichier qui sera utilisé par la truffe pour déployer les contrats.  Alors qu'est-ce qu'on fait ici?  Tout d'abord, nous avons demandé la compilation de <code>MyToken</code> et <code>MyCrowdsale</code> .  Ensuite, nous définissons les constantes avec tous les arguments de notre ICO - définissons les heures de début et de fin;  combien de jetons les gens recevront pour 1 vey de kéfir (0.000000000000000001 eth = 1 wei; la définition des <code>decimals</code> indique combien de commandes wei sont nécessaires pour obtenir 1 de vos tokens nouvellement fabriqués);  portefeuille, où viendra le kéfir obtenu de la vente;  capuchon dur et capuchon souple.  Veuillez noter que <code>openingTime</code> doit toujours être après l'heure du bloc actuel dans la blockchain - sinon votre contrat intelligent ne sera pas bloqué en raison de la vérification de la condition dans <code>TimedCrowdsale</code> .  J'ai marché sur ce rake, et les transactions échouées ne peuvent pas être débitées du tout.  Modifiez ces constantes comme vous le souhaitez. <br><br>  La prochaine étape est précisément le déploiement de contrats intelligents.  Rien d'intéressant ici: nous avons un objet <code>deployer</code> qui déploie des artefacts de contrat intelligent et y passe des arguments.  Notez que MyToken est <code>MyToken</code> premier, puis seulement <code>MyCrowdsale</code> - et l'adresse du premier est passée dans le second comme argument. <br><br>  Ensuite, la chose la plus intéressante est ce qu'ils n'écrivent ni dans la documentation ni dans les livres.  Lorsque vous créez un <code>MyToken</code> partir d'un portefeuille, ce portefeuille devient le propriétaire de <code>MyToken</code> dans la superclasse <code>Ownable</code> - la même chose se produit avec <code>MyCrowdsale</code> .  Si vous creusez profondément dans le <code>MintableToken</code> , vous pouvez voir que seul le <code>Owner</code> peut frapper des pièces!  Et qui est le propriétaire de <code>MyToken</code> ?  C'est vrai: l'adresse qui l'a bouleversé.  Et qui enverra les demandes de frappe de pièces?  Correct: contrat intelligent <code>MyCrowdsale</code> .  Permettez-moi de vous rappeler que l'adresse qui a créé <code>MyToken</code> et <code>MyCrowdsale</code> sont deux adresses différentes. <br><br>  Par conséquent, nous ajoutons la troisième étape de déploiement non orthodoxe, où l'adresse qui a défié les contrats ( <code>web3.eth.accounts[0]</code> ) appelle la fonction <code>transferOwnership</code> sur le contrat <code>MyToken</code> que <code>MyCrowdsale</code> possède <code>MyToken</code> et puisse frapper des pièces.  Et <code>MyCrowdsale</code> est toujours la propriété de <code>web3.eth.accounts[0]</code> - donc tout est groupé. <br><br><blockquote>  Remarque sur <code>web3.eth.accounts[0]</code> : lors du déploiement d'un contrat intelligent, assurez-vous que geth ou testrpc ont le bon portefeuille dans <code>web3.eth.accounts[0]</code> - ne perdez pas la clé privée, bien que cela ne vous nuise en aucune façon, mais du coup le propriétaire devra faire quelque chose plus tard, mais la clé n'est plus là? </blockquote><blockquote>  Dans <code>testrpc</code> , en règle générale, les comptes sont créés immédiatement au démarrage et ils sont immédiatement déverrouillés;  cependant, sur un test et une véritable blockchain aérienne, cela vaut la peine de créer un compte via <code>personal.newAccount()</code> - puis réapprovisionnez cette adresse via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Faucet</a> sur la blockchain de test ou le vrai kéfir sur la vraie blockchain.  Ne perdez pas votre mot de passe et vos clés privées. </blockquote><blockquote>  En outre, vous pouvez ajouter un portefeuille existant à vos comptes en appelant <code>web3.personal.importRawKey('pvt_key', 'password')</code> , mais pour cela, vous devez appeler <code>geth</code> avec le paramètre supplémentaire <code>--rpcapi="db,eth,net,web3,personal,web3"</code> .  Je pense que vous comprendrez. </blockquote><br><h2>  Test et déploiement </h2><br>  Oui, les contrats sont prêts, les migrations sont écrites, il ne reste plus qu'à déployer et vérifier.  <code>geth</code> (test et réel) et <code>testrpc</code> gérés de la même manière via la <code>truffle console</code> - je décrirai donc la méthode de vérification pour <code>testrpc</code> et vous dirai simplement comment activer <code>geth</code> après.  Et donc, nous lançons la blockchain locale de test du kéfir: <br><br><pre> <code class="bash hljs">testrpc</code> </pre> <br>  Hum ... c'est tout.  Vous simulez la blockchain de kéfir localement. <br><br><blockquote>  Et afin de déployer sur la blockchain de test ether, au lieu de cette commande, vous obtiendrez <code>geth --testnet --rpc</code> .  Et pour déployer sur la vraie chaîne de blocs d'éther, vous <code>geth --rpc</code> simplement <code>geth --rpc</code> .  Le drapeau <code>--rpc</code> nécessaire pour que la truffe puisse se connecter.  Les étapes de déploiement et de test suivantes sont plus ou moins les mêmes pour les trois types de blockchain.  La seule chose est qu'après avoir exécuté le test ou la vraie blockchain via <code>geth</code> , il commencera à synchroniser les blocs - et cela peut prendre jusqu'à 4-5 heures sur une bonne connexion Internet.  Une remarque à ce sujet figurait au tout début de l'article.  Avant de déployer des contrats intelligents, je recommande d'attendre la synchronisation complète.  De plus, la blockchain pèse entre 60 et 100 gigaoctets, alors préparez l'espace disque pour cela. </blockquote><blockquote>  Assurez-vous également que <code>web3.eth.accounts[0]</code> déverrouillé.  Vous pouvez généralement enregistrer <code>testrpc</code> dans la console, qui s'ouvre immédiatement, ou dans une fenêtre de terminal distincte dans la console, qui s'ouvre via la <code>geth console</code> : <code>eth.unlockAccount(eth.accounts[0], ",    ", 24*3600)</code> - cela débloquera votre compte, ce qui devrait créer un contrat intelligent </blockquote><br>  Maintenant, ouvrez une nouvelle fenêtre Terminal ( <code>testrpc</code> ne <code>testrpc</code> pas <code>testrpc</code> - cela devrait fonctionner) et écrivez-la dans le dossier du projet: <br><br><pre> <code class="bash hljs">truffle migrate --reset</code> </pre> <br>  Cette commande magique compilera un contrat intelligent (c'est-à-dire que vous n'avez pas besoin d'écrire une <code>truffle compile</code> chaque fois) et la déploiera sur le micro-serveur blockchain trouvé localement ouvert.  Il convient de noter que si <code>testrpc</code> fait instantanément, le test et les vraies chaînes de blocs incluront la transaction dans les prochains blocs beaucoup plus longtemps.  Après cela, vous devriez cracher quelque chose comme ça dans la console: <br><br><pre> <code class="bash hljs">Using network <span class="hljs-string"><span class="hljs-string">'development'</span></span>. Running migration: 1_initial_migration.js Running step... Replacing MyToken... ... 0x86a7090b0a279f8befc95b38fa8bee6918df30928dda0a3c48416454e2082b65 MyToken: 0x2dc35f255e56f06bd2935f5a49a0033548d85477 Replacing MyCrowdsale... ... 0xf0aab5d550f363478ac426dc2aff570302a576282c6c2c4e91205a7a3dea5d72 MyCrowdsale: 0xaac611907f12d5ebe89648d6459c1c81eca78151 ... 0x459303aa0b79be2dc2c8041dd48493f2d0e109fac19588f50c0ac664f34c7e30 Saving artifacts...</code> </pre> <br>  Je pense que vous avez déjà réalisé que la console vous a donné les adresses des contrats intelligents <code>MyToken</code> et <code>MyCrowdsale</code> .  C’est tout!  Le contrat intelligent est intégré dans la blockchain dont vous avez ouvert le micro-serveur.  Il ne reste plus qu'à vérifier que les jetons sont réellement distribués aux utilisateurs qui envoient du kéfir au contrat intelligent <code>MyCrowdsale</code> .  Nous écrivons ce qui suit dans le terminal pour entrer dans la console de truffe: <br><br><pre> <code class="bash hljs">truffle console</code> </pre> <br>  Nous écrivons ce qui suit dans la truffe maintenant (pas de commentaire seulement): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   - t="0x2dc35f255e56f06bd2935f5a49a0033548d85477" //     MyToken ="0xaac611907f12d5ebe89648d6459c1c81eca78151" //     MyCrowdsale //   - token=MyToken.at(t) crowdsale=MyCrowdsale.at(c) //       account=web3.eth.accounts[0] // ,      token.balanceOf(account) //   0 //    - web3.eth.sendTransaction({from: account, to:c, value: web3.toWei(0.1, 'ether'), gas: 900000})</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le cas de, </font></font><code>testrpc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez à nouveau vérifier immédiatement le solde de notre portefeuille, mais dans le cas du test et de la vraie blockchain, vous devez attendre que notre transaction soit incluse dans le bloc - généralement lorsque cela se produit, la truffe vous donne le numéro de transaction. </font><font style="vertical-align: inherit;">Tu as attendu? </font><font style="vertical-align: inherit;">Vérifiez à nouveau notre solde dans </font></font><code>MyToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,      token.balanceOf(account) //    </span></span></code> </pre> <br>  C'est tout!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testez d'abord votre contrat </font></font><code>testrpc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis </font></font><code>geth --testnet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis déployez-le </font></font><code>geth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vous avez donc lancé votre propre ICO! Et vous n'avez pas eu à dépenser des dizaines de kilobaks pour l'audit et le lancement. Gâcher ce que les gars d'OpenZeppelin nous ont fourni est en fait très difficile. Et lorsque vous l'utilisez </font></font><code>truffle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- c'est ainsi que le développement solidaire se transforme généralement en conte de fées. Eh bien, sauf dans les cas où les transactions sont inversées lors de l'exécution d'un contrat intelligent - débutez leur enfer. Mais le débogage des contrats intelligents mérite vraiment un article séparé.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci beaucoup d'avoir lu jusqu'à la fin de cet article! Si j'ai réussi à vous faire gagner du temps ou de l'argent, ou si vous avez appris quelque chose de nouveau grâce à cet article, j'en serai très heureux. Je serais également très reconnaissant si vous partagez cet article avec vos amis ou connaissances qui souhaitent mener une ICO - économisez 75 000 $ pour les sous-programmeurs qui aspirent de l'argent du marché de la cryptographie comme les parasites, copiant-collant les mêmes 25 lignes de code . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonne chance pour développer des contrats intelligents! Vous avez encore des questions? Je vous le demande dans les commentaires - je serai ravi de tout répondre et d’essayer de résoudre les problèmes.</font></font><br><br><h2>  Bonus </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais que se passe-t-il si vous souhaitez changer la logique selon laquelle le prix d'achat des jetons est considéré? </font><font style="vertical-align: inherit;">Bien sûr, vous pouvez le changer correctement </font></font><code>rate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou utiliser l'une des classes de contrats d'OpenZeppelin, mais que se passe-t-il si vous voulez quelque chose d'encore plus perverti? </font><font style="vertical-align: inherit;">Dans un contrat intelligent, vous pouvez remplacer la fonction </font></font><code>getTokenAmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme suit:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_getTokenAmount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256 _weiAmount</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (block.timestamp &lt; <span class="hljs-number"><span class="hljs-number">1533081600</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// August 1st, 2018 rate = rate * 4; } else if (block.timestamp &lt; 1546300800) { // January 1st, 2019 rate = rate * 2; } return _weiAmount.mul(rate); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En général, cela peut rendre le prix du jeton dépendant du moment de l'achat - plus loin dans la forêt, plus les jetons sont chers. </font><font style="vertical-align: inherit;">N'ayez pas peur d'expérimenter et de réécrire certaines des fonctionnalités des contrats intelligents - c'est amusant!</font></font><br><br><img src="https://habrastorage.org/webt/3a/mp/lk/3amplkx2fhpeplqauietmgshkc8.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414493/">https://habr.com/ru/post/fr414493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414481/index.html">Le quiz PHP de vendredi: quelques aventures du programmeur Brad, une séquence étrange et des prix</a></li>
<li><a href="../fr414483/index.html">Tapez Safe SQL sur Kotlin</a></li>
<li><a href="../fr414485/index.html">GNMT, échec épique ou subtilités de la traduction automatique</a></li>
<li><a href="../fr414487/index.html">Un rare représentant du type force brute: l'histoire d'une attaque</a></li>
<li><a href="../fr414489/index.html">Les États-Unis envisagent de s'attaquer sérieusement à la question des débris spatiaux</a></li>
<li><a href="../fr414495/index.html">toString: grand et terrible</a></li>
<li><a href="../fr414497/index.html">API Consulo UI de l'idée au prototype</a></li>
<li><a href="../fr414499/index.html">Rapport du Club de Rome 2018, chapitre 1.1.3: «Un monde vide contre une paix totale»</a></li>
<li><a href="../fr414501/index.html">Rapport 2018 du Club de Rome, chapitre 3.11: «Réformes du secteur financier»</a></li>
<li><a href="../fr414503/index.html">Intel NUC Hades Canyon avec AMD Vega Graphics - VR ou pas VR?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>