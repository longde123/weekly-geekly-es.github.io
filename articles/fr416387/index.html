<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèø üìô ü§öüèæ Shrimp: redimensionnez et partagez des images HTTP dans C ++ moderne avec ImageMagic ++, SObjectizer et RESTinio üèë üçå üóΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©face 
 Notre petite √©quipe d√©veloppe deux outils OpenSource pour les d√©veloppeurs C ++ - le framework d' acteur SObjectizer et le serveur HTTP int√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shrimp: redimensionnez et partagez des images HTTP dans C ++ moderne avec ImageMagic ++, SObjectizer et RESTinio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416387/"><img src="https://habrastorage.org/webt/c8/es/x7/c8esx7a-blzv0brvoyng2drgdeq.jpeg"><br><br><h1>  Pr√©face </h1><br>  Notre petite √©quipe d√©veloppe deux outils OpenSource pour les d√©veloppeurs C ++ - le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">framework d'</a> acteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> et le serveur HTTP int√©gr√© RESTinio.  Cependant, nous rencontrons r√©guli√®rement quelques questions non triviales: <br><br><ul><li>  quelles fonctionnalit√©s ajouter √† la biblioth√®que et lesquelles laisser ¬´par dessus bord¬ª? </li><li>  comment d√©montrer clairement les fa√ßons "id√©ologiquement correctes" d'utiliser la biblioth√®que? </li></ul><br>  C'est bien lorsque les r√©ponses √† de telles questions apparaissent lors de l'utilisation de nos d√©veloppements dans des projets r√©els, lorsque les d√©veloppeurs viennent nous voir avec leurs plaintes ou leur liste de souhaits.  En raison de la satisfaction des souhaits des utilisateurs, nous remplissons nos outils de fonctionnalit√©s dict√©es par la vie elle-m√™me et non ¬´aspir√©es du doigt¬ª. <br><br>  Mais l'information nous parvient loin de tous les probl√®mes et difficult√©s auxquels les utilisateurs sont confront√©s.  Et nous ne pouvons pas toujours utiliser les informations re√ßues, et en particulier les exemples de code, dans nos documents publics. <br><br>  Par cons√©quent, nous pensons parfois de petits probl√®mes pour nous-m√™mes, que nous sommes oblig√©s de transformer des d√©veloppeurs d'outils en utilisateurs.  Cela nous permet de regarder nos propres outils avec des yeux diff√©rents et de comprendre par nous-m√™mes ce qui est bon, ce qui ne l'est pas, ce qui manque et ce qui est trop. <br><br>  Aujourd'hui, nous voulons parler d'une telle "petite" t√¢che, dans laquelle SObjectizer et RESTinio se sont naturellement rencontr√©s. <br><br><h1>  Mise √† l'√©chelle et distribution des images.  Pourquoi exactement √ßa? </h1><br>  Comme petite t√¢che de d√©monstration pour nous-m√™mes, nous avons choisi un serveur HTTP qui distribue des images √† l'√©chelle sur demande.  Vous mettez les images dans un certain r√©pertoire, d√©marrez le serveur HTTP, lui faites une requ√™te de la forme: <br><a name="habracut"></a><br><pre><code class="bash hljs">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  et en retour, vous obtenez une image mise √† l'√©chelle √† 1920 pixels sur le long c√¥t√©. <br><br>  Le choix s'est port√© sur cette t√¢che car elle illustre parfaitement les sc√©narios pour lesquels nous avons commenc√© √† d√©velopper RESTinio √† un moment donn√©: il existe un code de longue dur√©e et d√©bogu√© en C ou C ++ auquel vous devez attacher une entr√©e HTTP et commencer √† r√©pondre aux demandes entrantes.  Dans le m√™me temps, ce qui est important, le traitement de la demande par l'application peut prendre un temps consid√©rable et il n'est donc pas rentable d'extraire le code d'application directement dans le contexte d'E / S.  Le serveur HTTP doit √™tre asynchrone: accepter et analyser la demande HTTP, donner la demande analys√©e quelque part pour un traitement ult√©rieur de l'application, passer √† la maintenance de la demande HTTP suivante, revenir au retour de la r√©ponse √† la demande HTTP lorsque cette r√©ponse est pr√©par√©e par quelqu'un. <br><br>  C'est exactement ce qui se passe lors du traitement des demandes de mise √† l'√©chelle des images.  Un serveur HTTP est capable de faire son travail direct (c'est-√†-dire lire des donn√©es, analyser une requ√™te HTTP) en une fraction de milliseconde.  Mais la mise √† l'√©chelle d'une image peut prendre des dizaines, des centaines, voire des milliers de millisecondes. <br><br>  Et comme la mise √† l'√©chelle d'une image peut prendre beaucoup de temps, vous devez vous assurer que le serveur HTTP peut continuer √† fonctionner pendant la mise √† l'√©chelle de l'image.  Pour ce faire, nous devons r√©partir le travail du serveur HTTP et la mise √† l'√©chelle des images dans diff√©rents contextes de travail.  Dans le cas simple, il s'agira de diff√©rents fils de travail.  Eh bien, puisque nous vivons dans des processeurs multic≈ìurs, nous aurons plusieurs threads de travail.  Certains d'entre eux serviront des requ√™tes HTTP, d'autres fonctionneront avec des images. <br><br>  Il s'av√®re que pour distribuer des images √©volutives via HTTP, nous devons r√©utiliser le code C / C ++ √©crit et fonctionnel (dans ce cas, ImageMagic ++), et servir les requ√™tes HTTP de mani√®re asynchrone, et effectuer le traitement des requ√™tes par application dans plusieurs workflows.  Une excellente t√¢che pour RESTinio et SObjectizer, comme il nous a sembl√©. <br><br>  Et nous avons d√©cid√© de nommer notre projet de d√©monstration de crevettes. <br><br><h1>  Crevettes telles quelles </h1><br><h2>  Que fait la crevette? </h2><br>  Shrimp s'ex√©cute comme une application console, s'ouvre et √©coute sur le port sp√©cifi√©, re√ßoit et traite les requ√™tes HTTP GET du formulaire: <br><br><pre> <code class="hljs xml">/<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">image</span></span></span><span class="hljs-tag">&gt;</span></span>.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ext</span></span></span><span class="hljs-tag">&gt;</span></span> /<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">image</span></span></span><span class="hljs-tag">&gt;</span></span>.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ext</span></span></span><span class="hljs-tag">&gt;</span></span>?op=resize&amp;<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">side</span></span></span><span class="hljs-tag">&gt;</span></span>=<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  O√π: <br><br><ul><li>  image est le nom du fichier image √† mettre √† l'√©chelle.  Par exemple, my_picture ou DSCF0069; </li><li>  ext est l'une des extensions prises en charge par shrimp (jpg, jpeg, png ou gif); </li><li>  c√¥t√© indique le c√¥t√© pour lequel la taille est d√©finie.  Il peut avoir une valeur de largeur, dans ce cas, l'image est mise √† l'√©chelle de sorte que la largeur r√©sultante soit √©gale √† la valeur sp√©cifi√©e, la hauteur de l'image est automatiquement s√©lectionn√©e tout en conservant le rapport d'aspect.  Ou la valeur de la hauteur, dans ce cas, la mise √† l'√©chelle se produit en hauteur.  Soit max, dans ce cas le c√¥t√© long est limit√©, et la crevette elle-m√™me d√©termine si le c√¥t√© long est en hauteur ou en largeur; </li><li>  valeur est la taille √† laquelle la mise √† l'√©chelle se produit. </li></ul><br>  Si seul le nom du fichier est sp√©cifi√© dans l'URL, sans l'op√©ration de redimensionnement, shrimp renvoie simplement l'image d'origine dans la r√©ponse.  Si l'op√©ration de redimensionnement est sp√©cifi√©e, shrimp modifie la taille de l'image demand√©e et donne la version √† l'√©chelle. <br><br>  Dans le m√™me temps, la crevette garde en m√©moire un cache d'images √† l'√©chelle.  Si une image est demand√©e √† plusieurs reprises avec les m√™mes param√®tres de redimensionnement, qui sont d√©j√† dans le cache, la valeur du cache est retourn√©e.  S'il n'y a pas d'image dans le cache, alors l'image est lue sur le disque, mise √† l'√©chelle, stock√©e dans le cache et renvoy√©e en r√©ponse. <br><br>  Le cache est effac√© p√©riodiquement.  Les images qui ont v√©cu dans le cache pendant plus d'une heure depuis le dernier acc√®s √† celles-ci sont expuls√©es.  De plus, les images les plus anciennes sont jet√©es hors du cache si le cache d√©passe sa taille maximale (dans un projet de d√©monstration, il est de 100 Mo). <br><br>  Nous avons pr√©par√© une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page</a> sur laquelle chacun peut exp√©rimenter la crevette: <br><br><img src="https://habrastorage.org/webt/uv/vr/-q/uvvr-qtt1xovbi_k-ieoyrpvq-y.jpeg"><br><br>  Sur cette page, vous pouvez d√©finir la taille de l'image et cliquer sur "Redimensionner".  Deux demandes seront faites au serveur de crevettes avec les m√™mes param√®tres.  Tr√®s probablement, la premi√®re demande sera unique (c'est-√†-dire qu'il n'y aura pas encore de cache avec de tels param√®tres de redimensionnement dans le cache), donc la premi√®re demande prendra un certain temps pour redimensionner r√©ellement l'image.  Et la deuxi√®me demande, tr√®s probablement, trouvera l'image d√©j√† mise √† l'√©chelle dans le cache et la donnera imm√©diatement. <br><br>  Il est possible de juger si une image est donn√©e √† partir du cache ou si elle a vraiment √©t√© mise √† l'√©chelle par le texte sous l'image.  Par exemple, le texte ¬´Transform√© (114,0 ms)¬ª indique que l'image a √©t√© mise √† l'√©chelle et que l'op√©ration de zoom a pris 114 millisecondes. <br><br><h2>  Comment les crevettes le font-elles? </h2><br>  Shrimp est une application multithread qui ex√©cute trois groupes de threads de travail: <br><br><ol><li>  Pool de threads de travail ex√©cutant le serveur HTTP.  Sur ce pool, de nouvelles connexions sont servies, les demandes entrantes sont re√ßues et analys√©es, les r√©ponses sont g√©n√©r√©es et envoy√©es.  Le serveur HTTP est impl√©ment√© via la biblioth√®que RESTinio. </li><li>  Un thread de travail distinct sur lequel s'ex√©cute l'agent transform_manager SObjectizer.  Cet agent traite les demandes re√ßues du serveur HTTP et g√®re un cache d'images mises √† l'√©chelle. </li><li>  Pool de threads sur lequel les agents SObjectizer travaillent sur les transformateurs.  Ils effectuent la mise √† l'√©chelle r√©elle des images √† l'aide d'ImageMagic ++. </li></ol><br>  Il s'av√®re que le sch√©ma de travail suivant: <br><br><img src="https://habrastorage.org/webt/ns/ov/sj/nsovsjushv0zxasu_cq3ur0dy6m.png"><br><br>  Le serveur HTTP accepte la demande entrante, l'analyse et v√©rifie l'exactitude.  Si cette demande ne n√©cessite pas d'op√©ration de redimensionnement, le serveur HTTP lui-m√™me traite la demande via l'op√©ration <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sendfile</a> .  Si la demande n√©cessite une op√©ration de redimensionnement, la demande est envoy√©e de mani√®re asynchrone √† l'agent transform_manager. <br><br>  L'agent transform_manager re√ßoit les demandes du serveur HTTP et v√©rifie la pr√©sence d'images d√©j√† mises √† l'√©chelle dans le cache.  S'il y a une image dans le cache, transform_manager g√©n√®re imm√©diatement une r√©ponse pour le serveur HTTP.  S'il n'y a pas d'image, transform_manager envoie une demande de mise √† l'√©chelle de l'image √† l'un des agents du transformateur.  Lorsque le r√©sultat de la mise √† l'√©chelle provient du transformateur, le r√©sultat est stock√© dans le cache et une r√©ponse est g√©n√©r√©e pour le serveur HTTP. <br><br>  L'agent transformateur re√ßoit les demandes de transform_manager, les traite et renvoie le r√©sultat de la transformation √† l'agent transform_manager. <br><br><h2>  Qu'est-ce que les crevettes ont sous le capot? </h2><br>  Le code source de la version la plus minimale de shrimp d√©crite dans cet article se trouve dans ce r√©f√©rentiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shrimp-demo sur BitBucket</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur GitHub</a> . <br><br>  Il y a beaucoup de code, bien que, dans la plupart des cas, dans cette version de shrimp, le code soit assez trivial.  Cependant, il est logique de se concentrer sur certains aspects de la mise en ≈ìuvre. <br><br><h3>  Utilisation de C ++ 17 et des versions de compilateur les plus r√©centes </h3><br>  Dans l'impl√©mentation de shrimp, nous avons d√©cid√© d'utiliser C ++ 17 et les derni√®res versions des compilateurs, en particulier GCC 7.3 et 8.1.  Le projet est fortement de recherche.  Par cons√©quent, la connaissance pratique de C ++ 17 dans le cadre d'un tel projet est naturelle et autoris√©e.  Alors que dans les d√©veloppements plus banals ax√©s sur les applications industrielles pratiques ici et maintenant, nous sommes oblig√©s de revenir sur des compilateurs plut√¥t anciens et d'utiliser peut-√™tre C ++ 14, ou m√™me juste un sous-ensemble de C ++ 11. <br><br>  Je dois dire que C ++ 17 fait bonne impression.  Il semble que nous n'ayons pas utilis√© autant d'innovations de la dix-septi√®me norme dans le code de la crevette, mais elles ont eu un effet positif: l'attribut [[nodiscard]], std :: optional / std :: variant / std :: filesystem directement " out of the box ¬ª, et non √† partir de d√©pendances externes, de liaisons structur√©es, si constexpr, la possibilit√© d'assembler visiteur pour lambdas pour std :: visit ... Individuellement, ce sont toutes des bagatelles, mais ensemble, elles produisent un puissant effet cumulatif. <br><br>  Donc, le premier r√©sultat utile que nous avons obtenu lors du d√©veloppement de crevettes: C ++ 17 vaut la peine d'y passer. <br><br><h3>  Serveur HTTP utilisant les outils RESTinio </h3><br>  Peut-√™tre que la partie la plus simple de shrimp s'est av√©r√©e √™tre le serveur HTTP et le gestionnaire de requ√™tes HTTP GET ( <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/v0.2/dev/shrimp/">http_server.hpp</a> et <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/v0.2/dev/shrimp/">http_server.cpp</a> ). <br><br><h4>  Recevoir et envoyer les demandes entrantes </h4><br>  Essentiellement, toute la logique de base du serveur HTTP shrimp est concentr√©e dans cette fonction: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_transform_op_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">app_params_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; app_params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_get( <span class="hljs-string"><span class="hljs-string">R"(/:path(.*)\.:ext(.{3,4}))"</span></span>, restinio::path2regex::<span class="hljs-keyword"><span class="hljs-keyword">options_t</span></span>{}.strict( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ), [req_handler_mbox, &amp;app_params]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;header().path() ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> opt_image_format = image_format_from_extension( params[ <span class="hljs-string"><span class="hljs-string">"ext"</span></span> ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !opt_image_format ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;header().query().empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ), *opt_image_format ); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-string"><span class="hljs-string">"resize"</span></span> != restinio::value_or( qp, <span class="hljs-string"><span class="hljs-string">"op"</span></span>sv, <span class="hljs-string"><span class="hljs-string">""</span></span>sv ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } handle_resize_op_request( req_handler_mbox, *opt_image_format, qp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  Cette fonction pr√©pare le gestionnaire de requ√™tes HTTP GET √† l'aide du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">routeur</a> RESTinio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ExpressJS</a> .  Lorsque le serveur HTTP re√ßoit une demande GET, dont l'URL tombe sous l'expression r√©guli√®re donn√©e, la fonction lambda sp√©cifi√©e est appel√©e. <br><br>  Cette fonction lambda effectue quelques v√©rifications simples sur l'exactitude de la demande, mais dans l'ensemble, son travail se r√©sume √† un choix simple: si le redimensionnement n'est pas d√©fini, l'image demand√©e sera retourn√©e dans sa forme d'origine en utilisant un syst√®me d'envoi efficace.  Si le mode de redimensionnement est d√©fini, un message est g√©n√©r√© et envoy√© √† l'agent transform_manager: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_resize_op_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; req_handler_mbox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_format_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> image_format, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_string_params_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; qp, restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req )</span></span></span><span class="hljs-function"> </span></span>{ try_to_handle_request( [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> op_params = transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span>::make( restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"width"</span></span> ), restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"height"</span></span> ), restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"max"</span></span> ) ); transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_constraints_t</span></span>{}.check( op_params ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> image_path{ req-&gt;header().path() }; so_5::send&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt;&gt;( req_handler_mbox, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image_path), image_format, op_params ); }, req ); }</code> </pre> <br>  Il s'av√®re que le serveur HTTP, apr√®s avoir accept√© la demande de redimensionnement, la transmet √† l'agent transform_manager via un message asynchrone et continue de servir d'autres demandes. <br><br><h4>  Partage de fichiers avec sendfile </h4><br>  Si le serveur HTTP d√©tecte une demande pour l'image d'origine, sans l'op√©ration de redimensionnement, le serveur envoie imm√©diatement cette image via l'op√©ration sendfile.  Le code principal associ√© √† ceci est le suivant (le code complet de cette fonction peut √™tre trouv√© <a href="">dans le r√©f√©rentiel</a> ): <br><br><pre> <code class="cpp hljs">[[nodiscard]] restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handling_status_t</span></span> serve_as_regular_file( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; root_dir, restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> image_format ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> full_path = make_full_path( root_dir, req-&gt;header().path() ); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sf = restinio::sendfile( full_path ); ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set_common_header_fields_for_image_resp( file_stat.st_mtim.tv_sec, resp ) .append_header( restinio::http_field::content_type, image_content_type_from_img_format( image_format ) ) .append_header( http_header::shrimp_image_src, image_src_to_str( http_header::<span class="hljs-keyword"><span class="hljs-keyword">image_src_t</span></span>::sendfile ) ) .set_body( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( sf ) ) .done(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_404_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); }</code> </pre> <br>  Le point cl√© ici est d'appeler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">restinio :: sendfile ()</a> , puis de passer la valeur retourn√©e par cette fonction √† set_body (). <br><br>  La fonction restinio :: sendfile () cr√©e une op√©ration de t√©l√©chargement de fichier √† l'aide de l'API syst√®me.  Lorsque cette op√©ration est pass√©e √† set_body (), RESTinio comprend que le contenu du fichier sp√©cifi√© dans restinio :: sendfile () sera utilis√© pour le corps de la r√©ponse HTTP.  Il utilise ensuite l'API syst√®me pour √©crire le contenu de ce fichier dans le socket TCP. <br><br><h3>  Impl√©mentation du cache d'images </h3><br>  L'agent transform_manager stocke le cache des images converties, o√π les images sont plac√©es apr√®s la mise √† l'√©chelle.  Ce cache est un simple conteneur self-made qui donne acc√®s √† son contenu de deux mani√®res: <br><br><ol><li>  En recherchant un √©l√©ment par cl√© (similaire √† la fa√ßon dont cela se produit dans les conteneurs standard std :: map et std :: unordered_map). </li><li>  En acc√©dant √† l'√©l√©ment de cache le plus ancien. </li></ol><br>  La premi√®re m√©thode d'acc√®s est utilis√©e lorsque nous devons v√©rifier la disponibilit√© de l'image dans le cache.  La seconde est lorsque nous supprimons les plus anciennes images du cache. <br><br>  Nous n'avons pas commenc√© √† chercher quelque chose de pr√™t √† ces fins sur Internet.  Probablement Boost.MultiIndex conviendrait parfaitement ici.  Mais je ne voulais pas faire glisser Boost juste pour le plaisir de MultiIndex, nous avons donc fait <a href="">notre impl√©mentation triviale</a> litt√©ralement √† genoux.  Cela semble fonctionner;) <br><br><h3>  File d'attente des demandes en attente dans transform_manager </h3><br>  L'agent transform_manager, malgr√© sa taille plut√¥t d√©cente (un <a href="">fichier hpp d'</a> environ 250 lignes et un <a href="">fichier cpp d'</a> environ 270 lignes), dans notre impl√©mentation la plus simple de shrimp, s'est av√©r√© plut√¥t trivial, √† notre avis. <br><br>  L'une des choses qui contribue de mani√®re significative √† la complexit√© et √† la quantit√© de code d'agent est la pr√©sence non seulement d'un cache d'images transform√©es dans transform_manager, mais √©galement de files d'attente de demandes en attente. <br><br>  Nous avons un nombre limit√© d'agents transformateurs (en principe, leur nombre devrait correspondre approximativement au nombre de c≈ìurs de traitement disponibles).  Si plus de demandes arrivent simultan√©ment qu'il n'y a de transformateurs libres, nous pouvons alors imm√©diatement r√©pondre n√©gativement √† la demande ou mettre la demande en file d'attente.  Et puis retirez-le de la file d'attente lorsqu'un transformateur libre appara√Æt. <br><br>  Dans shrimp, nous utilisons une file d'attente de requ√™tes en attente, qui est d√©finie comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pending_request_t</span></span></span><span class="hljs-class"> {</span></span> transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> m_key; <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; m_cmd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::steady_clock::time_point m_stored_at; <span class="hljs-keyword"><span class="hljs-keyword">pending_request_t</span></span>( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::steady_clock::time_point stored_at ) : m_key{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(key) } , m_cmd{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) } , m_stored_at{ stored_at } {} }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pending_request_queue_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">pending_request_t</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">pending_request_queue_t</span></span> m_pending_requests; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_pending_requests{ <span class="hljs-number"><span class="hljs-number">64u</span></span> };</code> </pre> <br>  D√®s r√©ception de la demande, nous la mettons en file d'attente avec fixation de l'heure de r√©ception de la demande.  Ensuite, nous v√©rifions p√©riodiquement si le d√©lai d'expiration de cette demande a expir√©.  En effet, en principe, il peut arriver qu'un ensemble de demandes ¬´lourdes¬ª arrive plus t√¥t, dont le traitement prend trop de temps.  Il est faux d'attendre sans fin qu'un transformateur libre apparaisse, il est pr√©f√©rable d'envoyer une r√©ponse n√©gative au client apr√®s un certain temps, ce qui signifie que le service est maintenant surcharg√©. <br><br>  Il existe √©galement une limite de taille pour la file d'attente des demandes en attente.  Si la file d'attente a d√©j√† atteint sa taille maximale, nous refusons imm√©diatement de traiter la demande et informons le client que nous sommes surcharg√©s. <br><br>  Il y a un point important li√© √† la file d'attente des demandes en attente, sur lequel nous nous concentrerons dans la conclusion de l'article. <br><br><h4>  Tapez sobj_shptr_t et r√©utilisez les instances de message </h4><br>  En d√©terminant le type de la file d'attente des requ√™tes en attente, ainsi que dans les signatures de certaines m√©thodes de transform_manager, vous pouvez voir l'utilisation du type sobj_shptr_t.  Il est logique de s'attarder plus en d√©tail sur son type et pourquoi il est utilis√©. <br><br>  L'essentiel, c'est que transform_manager re√ßoit une demande du serveur HTTP sous la forme d'un message resize_request_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_http_req; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_image; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_image_format; transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>( restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> http_req, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> image, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> image_format, transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_http_req{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(http_req) } , m_image{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image) } , m_image_format{ image_format } , m_params{ params } {} };</code> </pre> <br>  et nous devons faire quelque chose pour stocker ces informations dans la file d'attente des demandes en attente.  Par exemple, vous pouvez cr√©er une nouvelle instance de resize_request_t et y d√©placer les valeurs du message re√ßu. <br><br>  Et vous vous souvenez que le message lui-m√™me dans SObjectizer est un objet cr√©√© dynamiquement.  Et pas un simple objet, mais avec un compteur de liens √† l'int√©rieur.  Et que dans SObjectizer il existe un type sp√©cial de pointeur intelligent pour de tels objets - intrusive_ptr_t. <br><br>  C'est-√†-dire  nous ne pouvons pas faire une copie de resize_request_t pour la file d'attente des demandes en attente, mais nous pouvons simplement mettre dans cette file d'attente un pointeur intelligent vers une instance existante de resize_request_t.  Ce que nous faisons.  Et pour ne pas √©crire partout le nom plut√¥t exotique so_5 :: intrusive_ptr_t, on entre dans notre alias: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span> = so_5::<span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;T&gt;;</code> </pre><br><h3>  R√©ponses asynchrones aux clients </h3><br>  Nous avons dit que les requ√™tes HTTP sont trait√©es de mani√®re asynchrone.  Et nous avons montr√© ci-dessus comment le serveur HTTP envoie une requ√™te √† l'agent transform_manager avec un message asynchrone.  Mais qu'advient-il des r√©ponses aux requ√™tes HTTP? <br><br>  Les r√©ponses sont √©galement servies de mani√®re asynchrone.  Par exemple, dans le code transform_manager, vous pouvez voir ce qui suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_failed_resize( <span class="hljs-keyword"><span class="hljs-keyword">failed_resize_t</span></span> &amp; <span class="hljs-comment"><span class="hljs-comment">/*result*/</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { do_404_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req) ); }</code> </pre> <br>  Ce code g√©n√®re une r√©ponse n√©gative √† la demande HTTP dans le cas o√π l'image n'a pas pu √™tre mise √† l'√©chelle pour une raison quelconque.  La r√©ponse est g√©n√©r√©e dans la fonction d'aide do_404_response, dont le code peut √™tre repr√©sent√© comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_404_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resp = req-&gt;create_response( <span class="hljs-number"><span class="hljs-number">404</span></span>, <span class="hljs-string"><span class="hljs-string">"Not Found"</span></span> ); resp.append_header( restinio::<span class="hljs-keyword"><span class="hljs-keyword">http_field_t</span></span>::server, <span class="hljs-string"><span class="hljs-string">"Shrimp draft server"</span></span> ); resp.append_header_date_field(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;header().should_keep_alive() ) resp.connection_keep_alive(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> resp.connection_close(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resp.done(); }</code> </pre> <br>  Le premier point cl√© de do_404_response () est que cette fonction est appel√©e sur le contexte de travail de l'agent transform_manager, et non sur le contexte de travail du serveur HTTP. <br><br>  Le deuxi√®me point cl√© est l'appel √† la m√©thode done () sur l'objet resp enti√®rement form√©.  Toute la magie asynchrone avec une r√©ponse HTTP se produit ici.  La m√©thode done () prend toutes les informations pr√©par√©es dans resp et les envoie de mani√®re asynchrone au serveur HTTP.  C'est-√†-dire  un retour de do_404_response () se produira imm√©diatement apr√®s la mise en file d'attente du contenu de l'objet resp par le serveur HTTP. <br><br>  Le serveur HTTP dans son contexte de travail d√©tectera la pr√©sence d'une nouvelle r√©ponse HTTP et commencera √† prendre les mesures n√©cessaires pour envoyer la r√©ponse au client appropri√©. <br><br><h3>  Tapez datasizable_blob_t </h3><br>  Un autre petit point qui a du sens √† clarifier, car il est probablement incompr√©hensible sans comprendre les subtilit√©s de RESTinio.  Nous parlons de la pr√©sence, √† premi√®re vue, d'un type √©trange de datasizeable_blob_t, d√©fini comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">datasizable_blob_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt; <span class="hljs-keyword"><span class="hljs-keyword">datasizable_blob_t</span></span> &gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_blob.data(); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_blob.length(); } Magick::Blob m_blob; <span class="hljs-comment"><span class="hljs-comment">//! Value for `Last-Modified` http header field. const std::time_t m_last_modified_at{ std::time( nullptr ) }; };</span></span></code> </pre> <br>  Afin d'expliquer pourquoi ce type est n√©cessaire, vous devez montrer comment une r√©ponse HTTP est form√©e avec une image transform√©e: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve_transformed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">datasizable_blob_shared_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> blob, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_format_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> img_format, http_header::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_src_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> image_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">header_fields_list_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header_fields )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resp = req-&gt;create_response(); set_common_header_fields_for_image_resp( blob-&gt;m_last_modified_at, resp ) .append_header( restinio::http_field::content_type, image_content_type_from_img_format( img_format ) ) .append_header( http_header::shrimp_image_src, image_src_to_str( image_src ) ) .set_body( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( blob ) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; hf : header_fields ) { resp.append_header( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( hf.m_name ), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( hf.m_value ) ); } resp.done(); }</code> </pre> <br>  Nous pr√™tons attention √† l'appel √† set_body (): un pointeur intelligent vers l'instance datasizable_blob_t y est envoy√© directement.  Pourquoi? <br><br>  Le fait est que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RESTinio prend en charge plusieurs options pour former le corps d'une r√©ponse HTTP</a> .  Le plus simple est de passer une instance de type std :: string √† set_body () et RESTinio enregistrera la valeur de cette cha√Æne √† l'int√©rieur de l'objet resp. <br><br>  Mais il y a des moments o√π la valeur de set_body () doit √™tre r√©utilis√©e dans plusieurs r√©ponses √† la fois.  Par exemple, dans crevette, cela se produit lorsque la crevette re√ßoit plusieurs demandes identiques de transformation de la m√™me image.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, il n'est pas rentable de copier la m√™me valeur dans chaque r√©ponse. </font><font style="vertical-align: inherit;">Par cons√©quent, dans RESTinio, il existe une variante set_body () de la forme:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; body)</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais dans ce cas, une limitation importante est impos√©e au type T: il doit contenir les m√©thodes public data () et size (), qui sont n√©cessaires pour que RESTinio puisse acc√©der au contenu de la r√©ponse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'image mise √† l'√©chelle dans la crevette est stock√©e en tant qu'objet Magick :: Blob. </font><font style="vertical-align: inherit;">Il existe une m√©thode de donn√©es dans le type Magic :: Blob, mais il n'y a pas de m√©thode size (), mais il existe une m√©thode length (). </font><font style="vertical-align: inherit;">Par cons√©quent, nous avions besoin de la classe wrapper datasizable_blob_t, qui fournit √† RESTinio l'interface n√©cessaire pour acc√©der √† la valeur de Magick :: Blob.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Messages p√©riodiques dans transform_manager </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'agent transform_manager doit faire plusieurs choses de temps en temps: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tirez des images qui ont √©t√© dans le cache depuis trop longtemps √† partir du cache. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contr√¥ler le temps pass√© par les requ√™tes dans la file d'attente des transformateurs libres. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'agent transform_manager effectue ces actions via des messages p√©riodiques. </font><font style="vertical-align: inherit;">Il ressemble √† ceci. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, les types de signaux qui seront utilis√©s comme messages p√©riodiques sont d√©termin√©s:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clear_cache_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">check_pending_requests_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, l'agent est abonn√©, y compris ces signaux: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::so_define_agent() { so_subscribe_self() .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_resize_request ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_resize_result ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_clear_cache ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_check_pending_requests ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_clear_cache( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">clear_cache_t</span></span>&gt; ) {...} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_check_pending_requests( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">check_pending_requests_t</span></span>&gt; ) {...}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√¢ce √† l'abonnement, SObjectizer appellera le gestionnaire souhait√© lorsque l'agent recevra le signal correspondant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et il ne reste plus qu'√† ex√©cuter des messages p√©riodiques au d√©marrage de l'agent:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::so_evt_start() { m_clear_cache_timer = so_5::send_periodic&lt;<span class="hljs-keyword"><span class="hljs-keyword">clear_cache_t</span></span>&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, clear_cache_period, clear_cache_period ); m_check_pending_timer = so_5::send_periodic&lt;<span class="hljs-keyword"><span class="hljs-keyword">check_pending_requests_t</span></span>&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, check_pending_period, check_pending_period ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le point cl√© ici est de sauvegarder timer_id, qui sont retourn√©s par les fonctions send_periodic (). </font><font style="vertical-align: inherit;">Apr√®s tout, un signal p√©riodique ne viendra que tant que son timer_id est vivant. </font><font style="vertical-align: inherit;">Par cons√©quent, si la valeur de retour de send_periodic () n'est pas enregistr√©e, l'envoi d'un message p√©riodique sera imm√©diatement annul√©. </font><font style="vertical-align: inherit;">Par cons√©quent, la classe a_transform_manager_t a les attributs suivants:</font></font><br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> m_clear_cache_timer; so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> m_check_pending_timer;</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fin de la premi√®re partie </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aujourd'hui, nous avons pr√©sent√© au lecteur la mise en ≈ìuvre la plus simple et la plus minimaliste des crevettes. Cette impl√©mentation est suffisante pour montrer comment RESTinio et SObjectizer peuvent √™tre utilis√©s ensemble pour quelque chose de plus ou moins comme une vraie t√¢che, plut√¥t qu'un simple HelloWorld. Mais il pr√©sente un certain nombre de d√©fauts graves. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, dans l'agent transform_manager, il y a une certaine v√©rification de l'unicit√© de la demande. Mais cela ne fonctionne que si l'image transform√©e est d√©j√† dans le cache. S'il n'y a pas encore d'image dans le cache et en m√™me temps deux demandes identiques viennent pour la m√™me image, alors ces deux demandes seront envoy√©es pour traitement. Ce qui n'est pas bon. Il serait correct de ne traiter qu'un seul d'entre eux et de reporter le second jusqu'√† ce que le traitement du premier soit termin√©.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un tel contr√¥le plus avanc√© sur l'unicit√© des requ√™tes conduirait √† un code transform_manager beaucoup plus complexe et volumineux. Par cons√©quent, nous n'avons pas commenc√© √† le mettre en ≈ìuvre imm√©diatement, mais avons d√©cid√© d'emprunter la voie de l'√©volution - du simple au complexe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, la version la plus simple de la crevette est une ¬´bo√Æte noire¬ª qui ne montre aucun signe de son travail. Ce qui n'est pas tr√®s pratique √† la fois pendant les tests et pendant le fonctionnement. Par cons√©quent, dans le bon sens, les crevettes devraient √©galement ajouter une exploitation foresti√®re. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous essaierons d'√©liminer ces d√©fauts et quelques autres de la toute premi√®re version de la crevette dans les futures versions et de les d√©crire dans les prochains articles. Alors restez √† l'√©coute.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si quelqu'un a des questions sur la logique de la crevette, RESTinio ou SObjectizer, nous serons heureux de r√©pondre dans les commentaires. </font><font style="vertical-align: inherit;">De plus, la crevette elle-m√™me est un projet de d√©monstration, mais si quelqu'un s'int√©resse √† sa fonctionnalit√© et souhaite voir dans la crevette autre chose que l'op√©ration de redimensionnement, faites-le nous savoir, nous serons heureux d'√©couter toutes les id√©es constructives .</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416387/">https://habr.com/ru/post/fr416387/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416375/index.html">Bases de JavaScript pour les d√©butants</a></li>
<li><a href="../fr416377/index.html">Nous devenons des assistants en programmation. Partie 1</a></li>
<li><a href="../fr416379/index.html">Neurobugurt. Comment nous avons appris au r√©seau neuronal √† inventer des m√®mes un an plus t√¥t que Stanford</a></li>
<li><a href="../fr416381/index.html">Rapport du Club de Rome 2018, chapitre 3.13: philanthropie, investissement, crowdsourcing et blockchain</a></li>
<li><a href="../fr416385/index.html">Si la corr√©lation ressort √† 100%, alors quelque part une erreur s'est gliss√©e quelque part: l'exp√©rience de stage chez Rambler Group</a></li>
<li><a href="../fr416391/index.html">Optimisation du placement des machines virtuelles sur les serveurs</a></li>
<li><a href="../fr416393/index.html">Conf√©rence IIDF: les entreprises ne sont pas contre les startups</a></li>
<li><a href="../fr416397/index.html">Nous automatisons les tests d'interface des applications Android en utilisant le mod√®le d'objet de page</a></li>
<li><a href="../fr416399/index.html">Comment nous avons analys√© les avis sur les applications mobiles √† l'aide de l'apprentissage automatique</a></li>
<li><a href="../fr416401/index.html">Blender: mod√®le 3D d'une puce pour se connecter √† la biblioth√®que KiCad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>