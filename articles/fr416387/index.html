<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏿 📙 🤚🏾 Shrimp: redimensionnez et partagez des images HTTP dans C ++ moderne avec ImageMagic ++, SObjectizer et RESTinio 🏑 🍌 🗽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Préface 
 Notre petite équipe développe deux outils OpenSource pour les développeurs C ++ - le framework d' acteur SObjectizer et le serveur HTTP inté...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shrimp: redimensionnez et partagez des images HTTP dans C ++ moderne avec ImageMagic ++, SObjectizer et RESTinio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416387/"><img src="https://habrastorage.org/webt/c8/es/x7/c8esx7a-blzv0brvoyng2drgdeq.jpeg"><br><br><h1>  Préface </h1><br>  Notre petite équipe développe deux outils OpenSource pour les développeurs C ++ - le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">framework d'</a> acteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> et le serveur HTTP intégré RESTinio.  Cependant, nous rencontrons régulièrement quelques questions non triviales: <br><br><ul><li>  quelles fonctionnalités ajouter à la bibliothèque et lesquelles laisser «par dessus bord»? </li><li>  comment démontrer clairement les façons "idéologiquement correctes" d'utiliser la bibliothèque? </li></ul><br>  C'est bien lorsque les réponses à de telles questions apparaissent lors de l'utilisation de nos développements dans des projets réels, lorsque les développeurs viennent nous voir avec leurs plaintes ou leur liste de souhaits.  En raison de la satisfaction des souhaits des utilisateurs, nous remplissons nos outils de fonctionnalités dictées par la vie elle-même et non «aspirées du doigt». <br><br>  Mais l'information nous parvient loin de tous les problèmes et difficultés auxquels les utilisateurs sont confrontés.  Et nous ne pouvons pas toujours utiliser les informations reçues, et en particulier les exemples de code, dans nos documents publics. <br><br>  Par conséquent, nous pensons parfois de petits problèmes pour nous-mêmes, que nous sommes obligés de transformer des développeurs d'outils en utilisateurs.  Cela nous permet de regarder nos propres outils avec des yeux différents et de comprendre par nous-mêmes ce qui est bon, ce qui ne l'est pas, ce qui manque et ce qui est trop. <br><br>  Aujourd'hui, nous voulons parler d'une telle "petite" tâche, dans laquelle SObjectizer et RESTinio se sont naturellement rencontrés. <br><br><h1>  Mise à l'échelle et distribution des images.  Pourquoi exactement ça? </h1><br>  Comme petite tâche de démonstration pour nous-mêmes, nous avons choisi un serveur HTTP qui distribue des images à l'échelle sur demande.  Vous mettez les images dans un certain répertoire, démarrez le serveur HTTP, lui faites une requête de la forme: <br><a name="habracut"></a><br><pre><code class="bash hljs">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  et en retour, vous obtenez une image mise à l'échelle à 1920 pixels sur le long côté. <br><br>  Le choix s'est porté sur cette tâche car elle illustre parfaitement les scénarios pour lesquels nous avons commencé à développer RESTinio à un moment donné: il existe un code de longue durée et débogué en C ou C ++ auquel vous devez attacher une entrée HTTP et commencer à répondre aux demandes entrantes.  Dans le même temps, ce qui est important, le traitement de la demande par l'application peut prendre un temps considérable et il n'est donc pas rentable d'extraire le code d'application directement dans le contexte d'E / S.  Le serveur HTTP doit être asynchrone: accepter et analyser la demande HTTP, donner la demande analysée quelque part pour un traitement ultérieur de l'application, passer à la maintenance de la demande HTTP suivante, revenir au retour de la réponse à la demande HTTP lorsque cette réponse est préparée par quelqu'un. <br><br>  C'est exactement ce qui se passe lors du traitement des demandes de mise à l'échelle des images.  Un serveur HTTP est capable de faire son travail direct (c'est-à-dire lire des données, analyser une requête HTTP) en une fraction de milliseconde.  Mais la mise à l'échelle d'une image peut prendre des dizaines, des centaines, voire des milliers de millisecondes. <br><br>  Et comme la mise à l'échelle d'une image peut prendre beaucoup de temps, vous devez vous assurer que le serveur HTTP peut continuer à fonctionner pendant la mise à l'échelle de l'image.  Pour ce faire, nous devons répartir le travail du serveur HTTP et la mise à l'échelle des images dans différents contextes de travail.  Dans le cas simple, il s'agira de différents fils de travail.  Eh bien, puisque nous vivons dans des processeurs multicœurs, nous aurons plusieurs threads de travail.  Certains d'entre eux serviront des requêtes HTTP, d'autres fonctionneront avec des images. <br><br>  Il s'avère que pour distribuer des images évolutives via HTTP, nous devons réutiliser le code C / C ++ écrit et fonctionnel (dans ce cas, ImageMagic ++), et servir les requêtes HTTP de manière asynchrone, et effectuer le traitement des requêtes par application dans plusieurs workflows.  Une excellente tâche pour RESTinio et SObjectizer, comme il nous a semblé. <br><br>  Et nous avons décidé de nommer notre projet de démonstration de crevettes. <br><br><h1>  Crevettes telles quelles </h1><br><h2>  Que fait la crevette? </h2><br>  Shrimp s'exécute comme une application console, s'ouvre et écoute sur le port spécifié, reçoit et traite les requêtes HTTP GET du formulaire: <br><br><pre> <code class="hljs xml">/<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">image</span></span></span><span class="hljs-tag">&gt;</span></span>.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ext</span></span></span><span class="hljs-tag">&gt;</span></span> /<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">image</span></span></span><span class="hljs-tag">&gt;</span></span>.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ext</span></span></span><span class="hljs-tag">&gt;</span></span>?op=resize&amp;<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">side</span></span></span><span class="hljs-tag">&gt;</span></span>=<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Où: <br><br><ul><li>  image est le nom du fichier image à mettre à l'échelle.  Par exemple, my_picture ou DSCF0069; </li><li>  ext est l'une des extensions prises en charge par shrimp (jpg, jpeg, png ou gif); </li><li>  côté indique le côté pour lequel la taille est définie.  Il peut avoir une valeur de largeur, dans ce cas, l'image est mise à l'échelle de sorte que la largeur résultante soit égale à la valeur spécifiée, la hauteur de l'image est automatiquement sélectionnée tout en conservant le rapport d'aspect.  Ou la valeur de la hauteur, dans ce cas, la mise à l'échelle se produit en hauteur.  Soit max, dans ce cas le côté long est limité, et la crevette elle-même détermine si le côté long est en hauteur ou en largeur; </li><li>  valeur est la taille à laquelle la mise à l'échelle se produit. </li></ul><br>  Si seul le nom du fichier est spécifié dans l'URL, sans l'opération de redimensionnement, shrimp renvoie simplement l'image d'origine dans la réponse.  Si l'opération de redimensionnement est spécifiée, shrimp modifie la taille de l'image demandée et donne la version à l'échelle. <br><br>  Dans le même temps, la crevette garde en mémoire un cache d'images à l'échelle.  Si une image est demandée à plusieurs reprises avec les mêmes paramètres de redimensionnement, qui sont déjà dans le cache, la valeur du cache est retournée.  S'il n'y a pas d'image dans le cache, alors l'image est lue sur le disque, mise à l'échelle, stockée dans le cache et renvoyée en réponse. <br><br>  Le cache est effacé périodiquement.  Les images qui ont vécu dans le cache pendant plus d'une heure depuis le dernier accès à celles-ci sont expulsées.  De plus, les images les plus anciennes sont jetées hors du cache si le cache dépasse sa taille maximale (dans un projet de démonstration, il est de 100 Mo). <br><br>  Nous avons préparé une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page</a> sur laquelle chacun peut expérimenter la crevette: <br><br><img src="https://habrastorage.org/webt/uv/vr/-q/uvvr-qtt1xovbi_k-ieoyrpvq-y.jpeg"><br><br>  Sur cette page, vous pouvez définir la taille de l'image et cliquer sur "Redimensionner".  Deux demandes seront faites au serveur de crevettes avec les mêmes paramètres.  Très probablement, la première demande sera unique (c'est-à-dire qu'il n'y aura pas encore de cache avec de tels paramètres de redimensionnement dans le cache), donc la première demande prendra un certain temps pour redimensionner réellement l'image.  Et la deuxième demande, très probablement, trouvera l'image déjà mise à l'échelle dans le cache et la donnera immédiatement. <br><br>  Il est possible de juger si une image est donnée à partir du cache ou si elle a vraiment été mise à l'échelle par le texte sous l'image.  Par exemple, le texte «Transformé (114,0 ms)» indique que l'image a été mise à l'échelle et que l'opération de zoom a pris 114 millisecondes. <br><br><h2>  Comment les crevettes le font-elles? </h2><br>  Shrimp est une application multithread qui exécute trois groupes de threads de travail: <br><br><ol><li>  Pool de threads de travail exécutant le serveur HTTP.  Sur ce pool, de nouvelles connexions sont servies, les demandes entrantes sont reçues et analysées, les réponses sont générées et envoyées.  Le serveur HTTP est implémenté via la bibliothèque RESTinio. </li><li>  Un thread de travail distinct sur lequel s'exécute l'agent transform_manager SObjectizer.  Cet agent traite les demandes reçues du serveur HTTP et gère un cache d'images mises à l'échelle. </li><li>  Pool de threads sur lequel les agents SObjectizer travaillent sur les transformateurs.  Ils effectuent la mise à l'échelle réelle des images à l'aide d'ImageMagic ++. </li></ol><br>  Il s'avère que le schéma de travail suivant: <br><br><img src="https://habrastorage.org/webt/ns/ov/sj/nsovsjushv0zxasu_cq3ur0dy6m.png"><br><br>  Le serveur HTTP accepte la demande entrante, l'analyse et vérifie l'exactitude.  Si cette demande ne nécessite pas d'opération de redimensionnement, le serveur HTTP lui-même traite la demande via l'opération <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sendfile</a> .  Si la demande nécessite une opération de redimensionnement, la demande est envoyée de manière asynchrone à l'agent transform_manager. <br><br>  L'agent transform_manager reçoit les demandes du serveur HTTP et vérifie la présence d'images déjà mises à l'échelle dans le cache.  S'il y a une image dans le cache, transform_manager génère immédiatement une réponse pour le serveur HTTP.  S'il n'y a pas d'image, transform_manager envoie une demande de mise à l'échelle de l'image à l'un des agents du transformateur.  Lorsque le résultat de la mise à l'échelle provient du transformateur, le résultat est stocké dans le cache et une réponse est générée pour le serveur HTTP. <br><br>  L'agent transformateur reçoit les demandes de transform_manager, les traite et renvoie le résultat de la transformation à l'agent transform_manager. <br><br><h2>  Qu'est-ce que les crevettes ont sous le capot? </h2><br>  Le code source de la version la plus minimale de shrimp décrite dans cet article se trouve dans ce référentiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shrimp-demo sur BitBucket</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur GitHub</a> . <br><br>  Il y a beaucoup de code, bien que, dans la plupart des cas, dans cette version de shrimp, le code soit assez trivial.  Cependant, il est logique de se concentrer sur certains aspects de la mise en œuvre. <br><br><h3>  Utilisation de C ++ 17 et des versions de compilateur les plus récentes </h3><br>  Dans l'implémentation de shrimp, nous avons décidé d'utiliser C ++ 17 et les dernières versions des compilateurs, en particulier GCC 7.3 et 8.1.  Le projet est fortement de recherche.  Par conséquent, la connaissance pratique de C ++ 17 dans le cadre d'un tel projet est naturelle et autorisée.  Alors que dans les développements plus banals axés sur les applications industrielles pratiques ici et maintenant, nous sommes obligés de revenir sur des compilateurs plutôt anciens et d'utiliser peut-être C ++ 14, ou même juste un sous-ensemble de C ++ 11. <br><br>  Je dois dire que C ++ 17 fait bonne impression.  Il semble que nous n'ayons pas utilisé autant d'innovations de la dix-septième norme dans le code de la crevette, mais elles ont eu un effet positif: l'attribut [[nodiscard]], std :: optional / std :: variant / std :: filesystem directement " out of the box », et non à partir de dépendances externes, de liaisons structurées, si constexpr, la possibilité d'assembler visiteur pour lambdas pour std :: visit ... Individuellement, ce sont toutes des bagatelles, mais ensemble, elles produisent un puissant effet cumulatif. <br><br>  Donc, le premier résultat utile que nous avons obtenu lors du développement de crevettes: C ++ 17 vaut la peine d'y passer. <br><br><h3>  Serveur HTTP utilisant les outils RESTinio </h3><br>  Peut-être que la partie la plus simple de shrimp s'est avérée être le serveur HTTP et le gestionnaire de requêtes HTTP GET ( <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/v0.2/dev/shrimp/">http_server.hpp</a> et <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/v0.2/dev/shrimp/">http_server.cpp</a> ). <br><br><h4>  Recevoir et envoyer les demandes entrantes </h4><br>  Essentiellement, toute la logique de base du serveur HTTP shrimp est concentrée dans cette fonction: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_transform_op_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">app_params_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; app_params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_get( <span class="hljs-string"><span class="hljs-string">R"(/:path(.*)\.:ext(.{3,4}))"</span></span>, restinio::path2regex::<span class="hljs-keyword"><span class="hljs-keyword">options_t</span></span>{}.strict( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ), [req_handler_mbox, &amp;app_params]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;header().path() ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> opt_image_format = image_format_from_extension( params[ <span class="hljs-string"><span class="hljs-string">"ext"</span></span> ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !opt_image_format ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;header().query().empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ), *opt_image_format ); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-string"><span class="hljs-string">"resize"</span></span> != restinio::value_or( qp, <span class="hljs-string"><span class="hljs-string">"op"</span></span>sv, <span class="hljs-string"><span class="hljs-string">""</span></span>sv ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } handle_resize_op_request( req_handler_mbox, *opt_image_format, qp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  Cette fonction prépare le gestionnaire de requêtes HTTP GET à l'aide du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">routeur</a> RESTinio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ExpressJS</a> .  Lorsque le serveur HTTP reçoit une demande GET, dont l'URL tombe sous l'expression régulière donnée, la fonction lambda spécifiée est appelée. <br><br>  Cette fonction lambda effectue quelques vérifications simples sur l'exactitude de la demande, mais dans l'ensemble, son travail se résume à un choix simple: si le redimensionnement n'est pas défini, l'image demandée sera retournée dans sa forme d'origine en utilisant un système d'envoi efficace.  Si le mode de redimensionnement est défini, un message est généré et envoyé à l'agent transform_manager: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_resize_op_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; req_handler_mbox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_format_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> image_format, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_string_params_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; qp, restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req )</span></span></span><span class="hljs-function"> </span></span>{ try_to_handle_request( [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> op_params = transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span>::make( restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"width"</span></span> ), restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"height"</span></span> ), restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"max"</span></span> ) ); transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_constraints_t</span></span>{}.check( op_params ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> image_path{ req-&gt;header().path() }; so_5::send&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt;&gt;( req_handler_mbox, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image_path), image_format, op_params ); }, req ); }</code> </pre> <br>  Il s'avère que le serveur HTTP, après avoir accepté la demande de redimensionnement, la transmet à l'agent transform_manager via un message asynchrone et continue de servir d'autres demandes. <br><br><h4>  Partage de fichiers avec sendfile </h4><br>  Si le serveur HTTP détecte une demande pour l'image d'origine, sans l'opération de redimensionnement, le serveur envoie immédiatement cette image via l'opération sendfile.  Le code principal associé à ceci est le suivant (le code complet de cette fonction peut être trouvé <a href="">dans le référentiel</a> ): <br><br><pre> <code class="cpp hljs">[[nodiscard]] restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handling_status_t</span></span> serve_as_regular_file( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; root_dir, restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> image_format ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> full_path = make_full_path( root_dir, req-&gt;header().path() ); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sf = restinio::sendfile( full_path ); ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set_common_header_fields_for_image_resp( file_stat.st_mtim.tv_sec, resp ) .append_header( restinio::http_field::content_type, image_content_type_from_img_format( image_format ) ) .append_header( http_header::shrimp_image_src, image_src_to_str( http_header::<span class="hljs-keyword"><span class="hljs-keyword">image_src_t</span></span>::sendfile ) ) .set_body( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( sf ) ) .done(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_404_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); }</code> </pre> <br>  Le point clé ici est d'appeler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">restinio :: sendfile ()</a> , puis de passer la valeur retournée par cette fonction à set_body (). <br><br>  La fonction restinio :: sendfile () crée une opération de téléchargement de fichier à l'aide de l'API système.  Lorsque cette opération est passée à set_body (), RESTinio comprend que le contenu du fichier spécifié dans restinio :: sendfile () sera utilisé pour le corps de la réponse HTTP.  Il utilise ensuite l'API système pour écrire le contenu de ce fichier dans le socket TCP. <br><br><h3>  Implémentation du cache d'images </h3><br>  L'agent transform_manager stocke le cache des images converties, où les images sont placées après la mise à l'échelle.  Ce cache est un simple conteneur self-made qui donne accès à son contenu de deux manières: <br><br><ol><li>  En recherchant un élément par clé (similaire à la façon dont cela se produit dans les conteneurs standard std :: map et std :: unordered_map). </li><li>  En accédant à l'élément de cache le plus ancien. </li></ol><br>  La première méthode d'accès est utilisée lorsque nous devons vérifier la disponibilité de l'image dans le cache.  La seconde est lorsque nous supprimons les plus anciennes images du cache. <br><br>  Nous n'avons pas commencé à chercher quelque chose de prêt à ces fins sur Internet.  Probablement Boost.MultiIndex conviendrait parfaitement ici.  Mais je ne voulais pas faire glisser Boost juste pour le plaisir de MultiIndex, nous avons donc fait <a href="">notre implémentation triviale</a> littéralement à genoux.  Cela semble fonctionner;) <br><br><h3>  File d'attente des demandes en attente dans transform_manager </h3><br>  L'agent transform_manager, malgré sa taille plutôt décente (un <a href="">fichier hpp d'</a> environ 250 lignes et un <a href="">fichier cpp d'</a> environ 270 lignes), dans notre implémentation la plus simple de shrimp, s'est avéré plutôt trivial, à notre avis. <br><br>  L'une des choses qui contribue de manière significative à la complexité et à la quantité de code d'agent est la présence non seulement d'un cache d'images transformées dans transform_manager, mais également de files d'attente de demandes en attente. <br><br>  Nous avons un nombre limité d'agents transformateurs (en principe, leur nombre devrait correspondre approximativement au nombre de cœurs de traitement disponibles).  Si plus de demandes arrivent simultanément qu'il n'y a de transformateurs libres, nous pouvons alors immédiatement répondre négativement à la demande ou mettre la demande en file d'attente.  Et puis retirez-le de la file d'attente lorsqu'un transformateur libre apparaît. <br><br>  Dans shrimp, nous utilisons une file d'attente de requêtes en attente, qui est définie comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pending_request_t</span></span></span><span class="hljs-class"> {</span></span> transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> m_key; <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; m_cmd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::steady_clock::time_point m_stored_at; <span class="hljs-keyword"><span class="hljs-keyword">pending_request_t</span></span>( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::steady_clock::time_point stored_at ) : m_key{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(key) } , m_cmd{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) } , m_stored_at{ stored_at } {} }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pending_request_queue_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">pending_request_t</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">pending_request_queue_t</span></span> m_pending_requests; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_pending_requests{ <span class="hljs-number"><span class="hljs-number">64u</span></span> };</code> </pre> <br>  Dès réception de la demande, nous la mettons en file d'attente avec fixation de l'heure de réception de la demande.  Ensuite, nous vérifions périodiquement si le délai d'expiration de cette demande a expiré.  En effet, en principe, il peut arriver qu'un ensemble de demandes «lourdes» arrive plus tôt, dont le traitement prend trop de temps.  Il est faux d'attendre sans fin qu'un transformateur libre apparaisse, il est préférable d'envoyer une réponse négative au client après un certain temps, ce qui signifie que le service est maintenant surchargé. <br><br>  Il existe également une limite de taille pour la file d'attente des demandes en attente.  Si la file d'attente a déjà atteint sa taille maximale, nous refusons immédiatement de traiter la demande et informons le client que nous sommes surchargés. <br><br>  Il y a un point important lié à la file d'attente des demandes en attente, sur lequel nous nous concentrerons dans la conclusion de l'article. <br><br><h4>  Tapez sobj_shptr_t et réutilisez les instances de message </h4><br>  En déterminant le type de la file d'attente des requêtes en attente, ainsi que dans les signatures de certaines méthodes de transform_manager, vous pouvez voir l'utilisation du type sobj_shptr_t.  Il est logique de s'attarder plus en détail sur son type et pourquoi il est utilisé. <br><br>  L'essentiel, c'est que transform_manager reçoit une demande du serveur HTTP sous la forme d'un message resize_request_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_http_req; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_image; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_image_format; transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>( restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> http_req, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> image, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> image_format, transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_http_req{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(http_req) } , m_image{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image) } , m_image_format{ image_format } , m_params{ params } {} };</code> </pre> <br>  et nous devons faire quelque chose pour stocker ces informations dans la file d'attente des demandes en attente.  Par exemple, vous pouvez créer une nouvelle instance de resize_request_t et y déplacer les valeurs du message reçu. <br><br>  Et vous vous souvenez que le message lui-même dans SObjectizer est un objet créé dynamiquement.  Et pas un simple objet, mais avec un compteur de liens à l'intérieur.  Et que dans SObjectizer il existe un type spécial de pointeur intelligent pour de tels objets - intrusive_ptr_t. <br><br>  C'est-à-dire  nous ne pouvons pas faire une copie de resize_request_t pour la file d'attente des demandes en attente, mais nous pouvons simplement mettre dans cette file d'attente un pointeur intelligent vers une instance existante de resize_request_t.  Ce que nous faisons.  Et pour ne pas écrire partout le nom plutôt exotique so_5 :: intrusive_ptr_t, on entre dans notre alias: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span> = so_5::<span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;T&gt;;</code> </pre><br><h3>  Réponses asynchrones aux clients </h3><br>  Nous avons dit que les requêtes HTTP sont traitées de manière asynchrone.  Et nous avons montré ci-dessus comment le serveur HTTP envoie une requête à l'agent transform_manager avec un message asynchrone.  Mais qu'advient-il des réponses aux requêtes HTTP? <br><br>  Les réponses sont également servies de manière asynchrone.  Par exemple, dans le code transform_manager, vous pouvez voir ce qui suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_failed_resize( <span class="hljs-keyword"><span class="hljs-keyword">failed_resize_t</span></span> &amp; <span class="hljs-comment"><span class="hljs-comment">/*result*/</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { do_404_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req) ); }</code> </pre> <br>  Ce code génère une réponse négative à la demande HTTP dans le cas où l'image n'a pas pu être mise à l'échelle pour une raison quelconque.  La réponse est générée dans la fonction d'aide do_404_response, dont le code peut être représenté comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_404_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resp = req-&gt;create_response( <span class="hljs-number"><span class="hljs-number">404</span></span>, <span class="hljs-string"><span class="hljs-string">"Not Found"</span></span> ); resp.append_header( restinio::<span class="hljs-keyword"><span class="hljs-keyword">http_field_t</span></span>::server, <span class="hljs-string"><span class="hljs-string">"Shrimp draft server"</span></span> ); resp.append_header_date_field(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;header().should_keep_alive() ) resp.connection_keep_alive(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> resp.connection_close(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resp.done(); }</code> </pre> <br>  Le premier point clé de do_404_response () est que cette fonction est appelée sur le contexte de travail de l'agent transform_manager, et non sur le contexte de travail du serveur HTTP. <br><br>  Le deuxième point clé est l'appel à la méthode done () sur l'objet resp entièrement formé.  Toute la magie asynchrone avec une réponse HTTP se produit ici.  La méthode done () prend toutes les informations préparées dans resp et les envoie de manière asynchrone au serveur HTTP.  C'est-à-dire  un retour de do_404_response () se produira immédiatement après la mise en file d'attente du contenu de l'objet resp par le serveur HTTP. <br><br>  Le serveur HTTP dans son contexte de travail détectera la présence d'une nouvelle réponse HTTP et commencera à prendre les mesures nécessaires pour envoyer la réponse au client approprié. <br><br><h3>  Tapez datasizable_blob_t </h3><br>  Un autre petit point qui a du sens à clarifier, car il est probablement incompréhensible sans comprendre les subtilités de RESTinio.  Nous parlons de la présence, à première vue, d'un type étrange de datasizeable_blob_t, défini comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">datasizable_blob_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt; <span class="hljs-keyword"><span class="hljs-keyword">datasizable_blob_t</span></span> &gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_blob.data(); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_blob.length(); } Magick::Blob m_blob; <span class="hljs-comment"><span class="hljs-comment">//! Value for `Last-Modified` http header field. const std::time_t m_last_modified_at{ std::time( nullptr ) }; };</span></span></code> </pre> <br>  Afin d'expliquer pourquoi ce type est nécessaire, vous devez montrer comment une réponse HTTP est formée avec une image transformée: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve_transformed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">datasizable_blob_shared_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> blob, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_format_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> img_format, http_header::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_src_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> image_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">header_fields_list_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header_fields )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resp = req-&gt;create_response(); set_common_header_fields_for_image_resp( blob-&gt;m_last_modified_at, resp ) .append_header( restinio::http_field::content_type, image_content_type_from_img_format( img_format ) ) .append_header( http_header::shrimp_image_src, image_src_to_str( image_src ) ) .set_body( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( blob ) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; hf : header_fields ) { resp.append_header( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( hf.m_name ), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( hf.m_value ) ); } resp.done(); }</code> </pre> <br>  Nous prêtons attention à l'appel à set_body (): un pointeur intelligent vers l'instance datasizable_blob_t y est envoyé directement.  Pourquoi? <br><br>  Le fait est que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RESTinio prend en charge plusieurs options pour former le corps d'une réponse HTTP</a> .  Le plus simple est de passer une instance de type std :: string à set_body () et RESTinio enregistrera la valeur de cette chaîne à l'intérieur de l'objet resp. <br><br>  Mais il y a des moments où la valeur de set_body () doit être réutilisée dans plusieurs réponses à la fois.  Par exemple, dans crevette, cela se produit lorsque la crevette reçoit plusieurs demandes identiques de transformation de la même image.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, il n'est pas rentable de copier la même valeur dans chaque réponse. </font><font style="vertical-align: inherit;">Par conséquent, dans RESTinio, il existe une variante set_body () de la forme:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; body)</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais dans ce cas, une limitation importante est imposée au type T: il doit contenir les méthodes public data () et size (), qui sont nécessaires pour que RESTinio puisse accéder au contenu de la réponse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'image mise à l'échelle dans la crevette est stockée en tant qu'objet Magick :: Blob. </font><font style="vertical-align: inherit;">Il existe une méthode de données dans le type Magic :: Blob, mais il n'y a pas de méthode size (), mais il existe une méthode length (). </font><font style="vertical-align: inherit;">Par conséquent, nous avions besoin de la classe wrapper datasizable_blob_t, qui fournit à RESTinio l'interface nécessaire pour accéder à la valeur de Magick :: Blob.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Messages périodiques dans transform_manager </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'agent transform_manager doit faire plusieurs choses de temps en temps: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tirez des images qui ont été dans le cache depuis trop longtemps à partir du cache. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contrôler le temps passé par les requêtes dans la file d'attente des transformateurs libres. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'agent transform_manager effectue ces actions via des messages périodiques. </font><font style="vertical-align: inherit;">Il ressemble à ceci. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, les types de signaux qui seront utilisés comme messages périodiques sont déterminés:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clear_cache_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">check_pending_requests_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, l'agent est abonné, y compris ces signaux: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::so_define_agent() { so_subscribe_self() .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_resize_request ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_resize_result ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_clear_cache ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_check_pending_requests ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_clear_cache( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">clear_cache_t</span></span>&gt; ) {...} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_check_pending_requests( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">check_pending_requests_t</span></span>&gt; ) {...}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grâce à l'abonnement, SObjectizer appellera le gestionnaire souhaité lorsque l'agent recevra le signal correspondant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et il ne reste plus qu'à exécuter des messages périodiques au démarrage de l'agent:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::so_evt_start() { m_clear_cache_timer = so_5::send_periodic&lt;<span class="hljs-keyword"><span class="hljs-keyword">clear_cache_t</span></span>&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, clear_cache_period, clear_cache_period ); m_check_pending_timer = so_5::send_periodic&lt;<span class="hljs-keyword"><span class="hljs-keyword">check_pending_requests_t</span></span>&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, check_pending_period, check_pending_period ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le point clé ici est de sauvegarder timer_id, qui sont retournés par les fonctions send_periodic (). </font><font style="vertical-align: inherit;">Après tout, un signal périodique ne viendra que tant que son timer_id est vivant. </font><font style="vertical-align: inherit;">Par conséquent, si la valeur de retour de send_periodic () n'est pas enregistrée, l'envoi d'un message périodique sera immédiatement annulé. </font><font style="vertical-align: inherit;">Par conséquent, la classe a_transform_manager_t a les attributs suivants:</font></font><br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> m_clear_cache_timer; so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> m_check_pending_timer;</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fin de la première partie </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aujourd'hui, nous avons présenté au lecteur la mise en œuvre la plus simple et la plus minimaliste des crevettes. Cette implémentation est suffisante pour montrer comment RESTinio et SObjectizer peuvent être utilisés ensemble pour quelque chose de plus ou moins comme une vraie tâche, plutôt qu'un simple HelloWorld. Mais il présente un certain nombre de défauts graves. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, dans l'agent transform_manager, il y a une certaine vérification de l'unicité de la demande. Mais cela ne fonctionne que si l'image transformée est déjà dans le cache. S'il n'y a pas encore d'image dans le cache et en même temps deux demandes identiques viennent pour la même image, alors ces deux demandes seront envoyées pour traitement. Ce qui n'est pas bon. Il serait correct de ne traiter qu'un seul d'entre eux et de reporter le second jusqu'à ce que le traitement du premier soit terminé.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un tel contrôle plus avancé sur l'unicité des requêtes conduirait à un code transform_manager beaucoup plus complexe et volumineux. Par conséquent, nous n'avons pas commencé à le mettre en œuvre immédiatement, mais avons décidé d'emprunter la voie de l'évolution - du simple au complexe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, la version la plus simple de la crevette est une «boîte noire» qui ne montre aucun signe de son travail. Ce qui n'est pas très pratique à la fois pendant les tests et pendant le fonctionnement. Par conséquent, dans le bon sens, les crevettes devraient également ajouter une exploitation forestière. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous essaierons d'éliminer ces défauts et quelques autres de la toute première version de la crevette dans les futures versions et de les décrire dans les prochains articles. Alors restez à l'écoute.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si quelqu'un a des questions sur la logique de la crevette, RESTinio ou SObjectizer, nous serons heureux de répondre dans les commentaires. </font><font style="vertical-align: inherit;">De plus, la crevette elle-même est un projet de démonstration, mais si quelqu'un s'intéresse à sa fonctionnalité et souhaite voir dans la crevette autre chose que l'opération de redimensionnement, faites-le nous savoir, nous serons heureux d'écouter toutes les idées constructives .</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">À suivre ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416387/">https://habr.com/ru/post/fr416387/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416375/index.html">Bases de JavaScript pour les débutants</a></li>
<li><a href="../fr416377/index.html">Nous devenons des assistants en programmation. Partie 1</a></li>
<li><a href="../fr416379/index.html">Neurobugurt. Comment nous avons appris au réseau neuronal à inventer des mèmes un an plus tôt que Stanford</a></li>
<li><a href="../fr416381/index.html">Rapport du Club de Rome 2018, chapitre 3.13: philanthropie, investissement, crowdsourcing et blockchain</a></li>
<li><a href="../fr416385/index.html">Si la corrélation ressort à 100%, alors quelque part une erreur s'est glissée quelque part: l'expérience de stage chez Rambler Group</a></li>
<li><a href="../fr416391/index.html">Optimisation du placement des machines virtuelles sur les serveurs</a></li>
<li><a href="../fr416393/index.html">Conférence IIDF: les entreprises ne sont pas contre les startups</a></li>
<li><a href="../fr416397/index.html">Nous automatisons les tests d'interface des applications Android en utilisant le modèle d'objet de page</a></li>
<li><a href="../fr416399/index.html">Comment nous avons analysé les avis sur les applications mobiles à l'aide de l'apprentissage automatique</a></li>
<li><a href="../fr416401/index.html">Blender: modèle 3D d'une puce pour se connecter à la bibliothèque KiCad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>