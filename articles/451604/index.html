<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•à üå™Ô∏è üõ°Ô∏è Este art√≠culo tiene demasiada agua. üë©üèæ‚Äçüî¨ üéØ üóëÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúEstamos comenzando a desarrollar un nuevo juego, y necesitamos agua fr√≠a. ¬øPuedes hacer esto? 


 - me pregunt√≥ "S√≠, no hay duda! Por supuesto que pu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Este art√≠culo tiene demasiada agua.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451604/">  ‚ÄúEstamos comenzando a desarrollar un nuevo juego, y necesitamos agua fr√≠a.  ¬øPuedes hacer esto? <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iilqtDkeIBE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - me pregunt√≥  "S√≠, no hay duda!  Por supuesto que puedo ‚Äîrespond√≠, pero mi voz temblaba traidoramente.  ‚Äú¬øY tambi√©n en Unity?‚Äù, Y me qued√≥ claro que hab√≠a mucho trabajo por delante. <br><a name="habracut"></a><br>  Entonces, un poco de agua.  Hasta ese momento no hab√≠a visto Unity, exactamente como C #, as√≠ que decid√≠ hacer un prototipo de las herramientas que conoc√≠a: C ++ y DX9.  Lo que sab√≠a y pod√≠a practicar en la pr√°ctica en ese momento eran las texturas de desplazamiento de las normales para formar la superficie y el mapeo de desplazamiento primitivo basado en ellas.  Inmediatamente fue necesario cambiar absolutamente todo.  Forma realista animada de la superficie del agua.  Sombreado (fuertemente) complicado.  Generaci√≥n de espuma.  Sistema LOD conectado a la c√°mara.  Comenc√© a buscar informaci√≥n en Internet sobre c√≥mo hacer todo esto. <br><br>  El primer punto, por supuesto, fue comprender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el Simulando el agua del oc√©ano</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jerry Tessendorf</a> . <br><br>  Los buscapersonas acad√©micos con un mont√≥n de f√≥rmulas abstrusas nunca me han dado mucho, as√≠ que despu√©s de un par de lecturas entend√≠ poco.  Los principios generales eran claros: cada cuadro se genera mediante un mapa de altura utilizando la Transformada r√°pida de Fourier, que, en funci√≥n del tiempo, cambia suavemente su forma para formar una superficie de agua realista.  Pero c√≥mo y qu√© contar no lo sab√≠a.  Poco a poco profundic√© en la sabidur√≠a de calcular FFT en sombreadores en D3D9, y el c√≥digo fuente con un art√≠culo en alg√∫n lugar en la naturaleza de Internet, que intent√© encontrar durante una hora, pero fue en vano (desafortunadamente), realmente me ayud√≥.  Se obtuvo el primer resultado (aterrador como una guerra nuclear): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tdfwF1R81O4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Comenzaron los √©xitos complacidos, y la transferencia de agua a Unity comenz√≥ con su finalizaci√≥n. <br><br>  Se presentaron varios requisitos de agua en el juego sobre las batallas navales: <br><br><ul><li>  Mirada realista.  Hermosos como escorzos cercanos y distantes, espuma din√°mica, dispersi√≥n, etc. </li><li>  Soporte para diversas condiciones clim√°ticas: calma, tormenta y condiciones intermedias.  Cambio de hora del d√≠a. </li><li>  F√≠sica de la flotabilidad de los barcos en una superficie simulada, objetos flotantes. </li><li>  Como el juego es multijugador, el agua deber√≠a ser la misma para todos los participantes en la batalla. </li><li>  Dibujo de la superficie: √°reas dibujadas del vuelo de los n√∫cleos de volea, espuma de la entrada de n√∫cleos en el agua. </li></ul><br><h3>  Geometr√≠a </h3><br>  Se decidi√≥ construir una estructura similar a un √°rbol cu√°druple, con un centro alrededor de la c√°mara, que se reconstruye discretamente cuando el observador se mueve.  ¬øPor qu√© discreto?  Si mueve la malla suavemente con la c√°mara o usa la reproyecci√≥n del espacio de la pantalla como en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Representaci√≥n de agua en tiempo real, presentando el concepto de cuadr√≠cula proyectada</a> , entonces, en los planes a largo plazo, debido a la resoluci√≥n insuficiente de la malla geom√©trica, los pol√≠gonos "saltar√°n" hacia arriba y abajo  Esto es muy llamativo.  La imagen es ondulante.  Para superar esto, uno debe aumentar considerablemente la resoluci√≥n del pol√≠gono de malla de agua, o "aplanar" la geometr√≠a a largas distancias, o construir y mover los pol√≠gonos para que estos cambios no sean visibles.  Nuestra agua es progresiva (jeje) y eleg√≠ el tercer camino.  Como en cualquier t√©cnica similar (especialmente familiar para todos los que crearon terreno en los juegos), debe deshacerse de las uniones en T en los bordes de las transiciones de los niveles de detalle.  Para resolver este problema, al principio se calculan 3 tipos de quads con par√°metros de teselaci√≥n dados: <br><br><img src="https://habrastorage.org/webt/al/df/nw/aldfnwtnd2iihq2np9juxe5lvjm.jpeg"><br><br>  El primer tipo es para aquellos quads que no son transiciones a detalles m√°s bajos.  Ning√∫n lado tiene un n√∫mero reducido de v√©rtices 2 veces menor.  El segundo tipo es para l√≠mite, pero no para quads angulares.  El tercer tipo son los cuadrantes de l√≠mites angulares.  La malla de agua final se construye girando y escalando estos tres tipos de mallas. <br><br>  As√≠ es como se ve un render con un color diferente de los niveles de agua LOD. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JycUZlod3xs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Los primeros cuadros muestran la conexi√≥n de dos niveles diferentes de detalle. <br><br>  El video como marco est√° lleno de quads de agua: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VldNrYKLb0w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  D√©jame recordarte que todo fue hace mucho tiempo (y no es cierto).  Ahora se puede hacer de manera m√°s √≥ptima y flexible directamente en la GPU (GPU Pro 5. Quadtrees en la GPU).  Y dibujar√° en una llamada de sorteo, y la teselaci√≥n puede aumentar los detalles. <br><br>  M√°s tarde, el proyecto se traslad√≥ a D3D11, pero las manos no alcanzaron la actualizaci√≥n de esta parte del render del oc√©ano. <br><br><h3>  Generaci√≥n de forma de onda </h3><br>  Para esto necesitamos la transformaci√≥n r√°pida de Fourier.  Para la resoluci√≥n seleccionada (necesaria) de la textura de la ola (llam√©mosle as√≠ por ahora, explicar√© qu√© datos se almacenan all√≠), preparamos los datos iniciales utilizando los par√°metros establecidos por los artistas (fuerza, direcci√≥n del viento, dependencia de la direcci√≥n del viento y otros).  Todo esto debe ser alimentado en las llamadas f√≥rmulas.  Espectro de Phillips  Modificamos los datos iniciales obtenidos para cada cuadro teniendo en cuenta el tiempo y realizamos FFT en ellos.  En la salida, obtenemos un mosaico de textura en todas las direcciones que contiene el desplazamiento de los v√©rtices de la malla plana.  ¬øPor qu√© no solo un mapa de altura?  Si almacena solo el desplazamiento en altura, el resultado ser√° una masa "burbujeante" poco realista, que solo se parece remotamente al mar: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2234r1xpuI8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Si consideramos los desplazamientos para las tres coordenadas, se generar√°n hermosas ondas realistas "afiladas": <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tFhKaV1u-AY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Una textura animada no es suficiente.  El mosaico es visible, no hay suficientes detalles en el futuro cercano.  Tomamos el algoritmo descrito y hacemos no una, sino 3 texturas generadas por fft.  El primero es grandes olas.  Establece la forma de onda b√°sica y se usa para la f√≠sica.  El segundo son las olas medianas.  Y finalmente, el m√°s peque√±o.  3 generadores FFT (la cuarta opci√≥n es la mezcla final): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/gqxbAOS4sGM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Los par√°metros de las capas se establecen independientemente uno del otro, y las texturas resultantes se mezclan en el sombreador de agua en la forma de onda final.  Paralelamente a los desplazamientos, tambi√©n se generan mapas normales de cada capa. <br><br>  La "uniformidad" del agua para todos los participantes en la batalla est√° garantizada por la sincronizaci√≥n de los par√°metros oce√°nicos al comienzo de la batalla.  El servidor transmite esta informaci√≥n a cada cliente. <br><br><h3>  Modelo de flotabilidad f√≠sica </h3><br>  Dado que era necesario hacer no solo una imagen hermosa, sino tambi√©n el comportamiento realista de los barcos.  Y tambi√©n teniendo en cuenta el hecho de que un mar tormentoso (grandes olas) deber√≠a estar presente en el juego, otra tarea que deb√≠a resolverse era garantizar la flotabilidad de los objetos en la superficie del mar generado.  Primero intent√© hacer que la GPU leyera la textura de la onda.  Pero, como r√°pidamente se hizo evidente que toda la f√≠sica del combate naval debe hacerse en el servidor, el mar, o m√°s bien, su primera capa, que establece la forma de onda, tambi√©n debe leerse en el servidor (y, lo m√°s probable, no es r√°pido y / o GPU compatible), se decidi√≥ escribir una copia funcional completa del generador GPU FFT en la CPU en forma de un complemento nativo de C ++ para Unity.  Yo mismo no implement√© el algoritmo FFT y lo us√© en la biblioteca Intel Performance Primitives (IPP).  Pero todo el enlace y el procesamiento posterior de los resultados lo hice yo, seguido de la optimizaci√≥n en el SSE y la paralelizaci√≥n por hilos.  Esto incluy√≥ la preparaci√≥n de la matriz de datos para el FFT de cada cuadro, y la conversi√≥n final de los valores calculados en un mapa de desplazamiento de onda. <br><br>  Hab√≠a otra caracter√≠stica interesante del algoritmo, que se basaba en los requisitos para la f√≠sica del agua.  Lo que se necesitaba era la funci√≥n de obtener r√°pidamente la altura de las olas en un punto dado del mundo.  Es l√≥gico, porque esta es la base para construir la flotabilidad de cualquier objeto.  Pero, dado que en la salida del procesador FFT obtenemos un mapa de desplazamiento, no un mapa de altura, la selecci√≥n habitual de la textura no nos dio la altura de la ola cuando fue necesario.  Para simplificar, considere la opci√≥n 2D: <br><br><img src="https://habrastorage.org/webt/u6/ec/pe/u6ecpek-vcazrjpgh4ygxwhon2g.jpeg"><br><br>  Para formar una onda, los texels (elementos de textura mostrados por l√≠neas verticales) contienen un vector (flechas) que establece el desplazamiento del v√©rtice de la malla plana (puntos azules) en la direcci√≥n de su posici√≥n final (la punta de la flecha).  Supongamos que tomamos estos datos e intentamos extraer de ellos la altura del agua en el punto de inter√©s para nosotros.  Por ejemplo, necesitamos saber la altura en hB.  Si tomamos el vector de texel tB, obtenemos un desplazamiento a un punto cerca de hC, que puede ser muy diferente de lo que necesitamos.  Hay dos opciones para resolver este problema: en cada solicitud de altura, verifique el conjunto de texels adyacentes hasta que encuentre uno que tenga un desplazamiento de la posici√≥n que nos interesa.  En nuestro ejemplo, encontramos que texel tA contiene el desplazamiento m√°s cercano.  Pero este enfoque no se puede llamar r√°pido.  Escanear el radio de texel no est√° claro qu√© tama√±o (y si el mar tempestuoso o la calma, los desplazamientos pueden variar mucho) puede llevar mucho tiempo. <br><br>  La segunda opci√≥n: despu√©s de calcular el mapa de desplazamiento, convi√©rtalo en un mapa de altura utilizando el enfoque de dispersi√≥n.  Esto significa que para cada vector de desplazamiento, escribimos la altura de la onda que establece en el punto donde se desplaza.  Esta ser√° una matriz de datos separada, que se utilizar√° para obtener la altura en el punto de inter√©s.  Usando nuestra ilustraci√≥n, la celda tB contendr√° la altura hB obtenida del vector tA ‚Üí hB.  Hay una caracter√≠stica m√°s.  La celda tA no contendr√° un valor v√°lido, ya que no hay ning√∫n vector que se mueva hacia ella.  Para llenar tales "agujeros", se hace un pasaje para llenarlos con valores vecinos. <br><br>  As√≠ es como se ve si realiza la visualizaci√≥n de los desplazamientos utilizando vectores (rojo - desplazamiento grande, verde - peque√±o): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uBk8F55lR74" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  El resto es simple.  El plano de la l√≠nea de flotaci√≥n condicional se establece para el barco.  En √©l, se determina una cuadr√≠cula rectangular de puntos de muestra, que define los lugares de aplicaci√≥n de las fuerzas que empujan fuera del agua hacia el barco.  Luego, para cada punto, verificamos si est√° debajo del agua o no utilizando el mapa de altura del agua descrito anteriormente.  Si el punto est√° debajo del agua, aplique la fuerza vertical hasta el casco f√≠sico del cuerpo en este punto, escalado por la distancia desde el punto hasta la superficie del agua.  Si est√° por encima del agua, entonces no hacemos nada, la gravedad har√° todo por nosotros.  De hecho, las f√≥rmulas all√≠ son un poco m√°s complicadas (todo para el ajuste fino del comportamiento del barco), pero el principio b√°sico es este.  En el siguiente video de visualizaci√≥n de flotabilidad, los cubos azules son las ubicaciones de las muestras, y las l√≠neas desde ellos hacia abajo son la magnitud de la fuerza que empuja fuera del agua. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mwNRIKbRdpQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  En la implementaci√≥n del servidor hay otro punto de optimizaci√≥n interesante.  No es necesario simular diferentes aguas para diferentes instancias de combate si pasan en las mismas condiciones clim√°ticas (los mismos par√°metros del simulador FFT).  Entonces, la decisi√≥n l√≥gica fue hacer un grupo de simuladores, a los cuales las unidades de combate satisfacen las solicitudes para obtener agua simulada con los par√°metros dados.  Si los par√°metros son los mismos en varias instancias, la misma agua volver√° a ellos.  Esto se implementa utilizando la API de archivo mapeado de Memor.  Cuando se crea el simulador FFT, da acceso a sus datos exportando descriptores de los bloques necesarios.  La instancia del servidor, en lugar de lanzar un simulador real, lanza un "dummy" que simplemente regala datos abiertos por estos descriptores.  Hubo algunos errores divertidos relacionados con esta funcionalidad.  Debido a los errores de recuento de referencias, el simulador se destruy√≥, pero el archivo mapeado de memoria est√° vivo mientras al menos un identificador est√° abierto.  Los datos dejaron de actualizarse (no hay simulador) y el agua se "detuvo". <br><br>  Del lado del cliente, necesitamos informaci√≥n sobre la forma de onda para calcular la penetraci√≥n de los n√∫cleos en la onda y reproducir los sistemas de part√≠culas y espuma.  El da√±o se calcula en el servidor y all√≠ tambi√©n es necesario determinar correctamente si el n√∫cleo se ha metido en el agua (la ola puede cerrar el barco, especialmente en tormentas).  Aqu√≠ ya es necesario hacer un seguimiento del mapa de altura por analog√≠a, como se hace en el mapeo de paralaje o los efectos SSAO. <br><br><h3>  Sombreado </h3><br>  En principio, como en otros lugares.  Las reflexiones, las refracciones, la dispersi√≥n del subsuelo se amasan astutamente, teniendo en cuenta la profundidad del fondo, tenemos en cuenta el efecto fresnel, consideramos el especular.  Consideramos la dispersi√≥n de crestas dependiendo de la posici√≥n del sol.  La espuma se genera de la siguiente manera: cree un "punto de espuma" en las crestas de las olas (use la altura como una m√©trica), luego aplique puntos reci√©n creados a los puntos de los cuadros anteriores mientras reduce su intensidad.  Por lo tanto, obtenemos una mancha de manchas de espuma en forma de cola a partir de una cresta de ola. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MyzFcwr641g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Usamos la textura de "manchas" obtenida como una m√°scara con la cual mezclamos las texturas de burbujas, manchas, etc. Obtenemos un patr√≥n din√°mico de espuma bastante realista en la superficie de las olas.  Esta m√°scara se crea para cada capa FFT (les recuerdo, tenemos 3 de ellas), y en la mezcla final, todas se mezclan. <br><br>  El video de arriba visualiza una m√°scara de espuma.  La primera y segunda capas.  Modifico los par√°metros del generador y el resultado es visible en la textura. <br><br>  Y un video de un mar tormentoso un poco torpe.  Aqu√≠ puede ver claramente la forma de onda, las capacidades del generador y la espuma: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MAPUbmV4BAA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Dibujo de agua </h3><br>  Imagen de uso: <br><br><img src="https://habrastorage.org/webt/zz/gz/1p/zzgz1pslmj1tg5si7o8mwnxqjye.jpeg"><br><br>  Utilizado para: <br><br><ul><li>  Marcadores, visualizaci√≥n de la zona de expansi√≥n de n√∫cleos. </li><li>  Dibuja espuma en el punto donde los n√∫cleos golpean el agua. </li><li>  Espumosa estela del barco </li><li>  Exprimir el agua debajo de la nave para eliminar el efecto de las olas que inundan la cubierta y la bodega inundada. </li></ul><br>  El caso base obvio es la textura proyectiva.  Fue implementado.  Pero hay requisitos adicionales.  Especies cercanas: jab√≥n debido a una resoluci√≥n insuficiente (puede aumentar, pero no infinitamente), y quiero que estos dibujos proyectivos en el agua sean muy visibles.  ¬øD√≥nde se resuelve el mismo problema?  As√≠ es, en las sombras (mapa de sombras).  ¬øC√≥mo se resuelve all√≠?  Derecha, mapas de sombras en cascada (divisi√≥n paralela).  Tambi√©n pondremos en servicio esta tecnolog√≠a y la aplicaremos a nuestra tarea.  Rompemos el tronco de la c√°mara en N (3-4 usualmente) subfusts.  Para cada uno, construimos un rect√°ngulo descriptivo en el plano horizontal.  Para cada uno de esos rect√°ngulos, construimos una matriz de proyecci√≥n ortogr√°fica y dibujamos todos los objetos de inter√©s para cada una de N c√°maras ortogr√°ficas.  Cada una de estas c√°maras se dibuja en una textura separada, y luego, en el sombreador del oc√©ano, las combinamos en una imagen proyectiva s√≥lida. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/etG8tddmbmk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  As√≠ que puse un enorme avi√≥n con una textura de bandera en el mar: <br><br><img src="https://habrastorage.org/webt/pd/uk/jr/pdukjrlnug2wu4debjrhlxbdxrc.jpeg"><br><br>  Esto es lo que contienen las divisiones: <br><br><img src="https://habrastorage.org/webt/ez/dw/nm/ezdwnm3u85dzpavd5iz8e2u9q2k.jpeg"><br><br>  Adem√°s de las im√°genes habituales, es necesario dibujar una m√°scara adicional de espuma (para los rastros de barcos y lugares de impacto de los n√∫cleos) exactamente de la misma manera, as√≠ como una m√°scara para exprimir el agua debajo de los barcos.  Estas son muchas c√°maras y muchos pasillos.  Al principio funcion√≥ tan fren√©ticamente, pero luego, despu√©s de cambiar a D3D11, usando la "propagaci√≥n" de la geometr√≠a en el sombreador geom√©trico y dibujando cada copia en un objetivo de renderizado separado a trav√©s de SV_RenderTergetArrayIndex, fue posible acelerar mucho este efecto. <br><br><h3>  Mejoras y actualizaciones </h3><br>  D3D11 es muy manos libres en muchos momentos.  Despu√©s de cambiar a √©l y a Unity 5, hice un generador FFT en los sombreadores de c√≥mputo.  Visualmente, nada ha cambiado, pero se ha vuelto un poco m√°s r√°pido.  La traducci√≥n del error de c√°lculo de la textura de los reflejos de una c√°mara separada de renderizado completo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la</a> tecnolog√≠a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Screen Space Planar Reflections</a> dio un buen impulso en el rendimiento.  Escrib√≠ sobre la optimizaci√≥n de los objetos de la superficie del agua arriba, pero mis manos no alcanzaron la transferencia de la malla a la GPU Quadtree. <br><br>  Mucho podr√≠a hacerse de manera m√°s √≥ptima y sencilla.  Por ejemplo, no cerca los jardines con un simulador de CPU, simplemente ejecute la opci√≥n GPU en un servidor con un dispositivo WARP (software) d3d.  Las matrices de datos all√≠ no son muy grandes. <br><br>  Bueno, en general, de alguna manera.  Cuando comenz√≥ el desarrollo, todo era moderno y genial.  Ahora ya est√° fuera de lugar en algunos lugares.  Hay m√°s materiales disponibles, incluso hay un an√°logo similar a github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crest</a> .  La mayor√≠a de los juegos que tienen mares utilizan un enfoque similar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451604/">https://habr.com/ru/post/451604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451594/index.html">Gu√≠a de informes de PHP Rusia 2019</a></li>
<li><a href="../451596/index.html">Cardenal gris .NET - John Galloway</a></li>
<li><a href="../451598/index.html">Unidad de hadas Hada m√°gica: DSL en C #</a></li>
<li><a href="../451600/index.html">C√≥mo escribir una carta de presentaci√≥n cuando busca trabajo en los EE. UU .: 7 consejos</a></li>
<li><a href="../451602/index.html">Estudiamos MITRE ATT & CK. Matrices m√≥viles: acceso a dispositivos. Parte 1</a></li>
<li><a href="../451606/index.html">Historia de Internet: decadencia, parte 2</a></li>
<li><a href="../451610/index.html">Semana de la seguridad 20: deshabilitar las extensiones de Firefox</a></li>
<li><a href="../451614/index.html">"Lo que estamos discutiendo en Rusia tambi√©n es relevante en Occidente": entrevista con Denis Neklyudov</a></li>
<li><a href="../451618/index.html">CampusInsight: del monitoreo de infraestructura al an√°lisis de la experiencia del usuario</a></li>
<li><a href="../451620/index.html">Autorizaci√≥n autom√°tica en la tarjeta Strava Heatmap</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>