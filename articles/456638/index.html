<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚ÄçüöÄ ‚úåüèª ü§ñ Comparando el mismo proyecto en Rust, Haskell, C ++, Python, Scala y OCaml üßíüèΩ üë©‚Äçüë©‚Äçüëß‚Äçüë¶ üëÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el √∫ltimo semestre de la universidad, eleg√≠ el curso del compilador CS444 . All√≠, cada grupo de 1-3 personas tuvo que escribir un compilador de un ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comparando el mismo proyecto en Rust, Haskell, C ++, Python, Scala y OCaml</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456638/"> En el √∫ltimo semestre de la universidad, eleg√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el curso del compilador CS444</a> .  All√≠, cada grupo de 1-3 personas tuvo que escribir un compilador de un subconjunto sustancial de Java en x86.  Idioma para elegir un grupo.  Esta fue una rara oportunidad para comparar implementaciones de grandes programas de la misma funcionalidad, escritos por programadores muy competentes en diferentes idiomas, y para comparar la diferencia en el dise√±o y la elecci√≥n del idioma.  Tal comparaci√≥n dio lugar a muchos pensamientos interesantes.  Tal comparaci√≥n controlada de idiomas rara vez se ve.  No es perfecto, pero es mucho mejor que la mayor√≠a de las historias subjetivas en las que se basan las opiniones de las personas sobre los lenguajes de programaci√≥n. <br><br>  Creamos nuestro compilador Rust, y primero lo compar√© con el proyecto del equipo Haskell.  Esperaba que su programa fuera mucho m√°s corto, pero result√≥ ser del mismo tama√±o o m√°s grande.  Lo mismo vale para OCaml.  Luego lo compar√© con el compilador de C ++, y all√≠ era bastante esperado que el compilador fuera aproximadamente un 30% m√°s grande, principalmente debido a los encabezados, la falta de tipos de suma y la coincidencia de patrones.  La siguiente comparaci√≥n fue con mi novia, que hizo el compilador por su cuenta en Python y us√≥ menos de la mitad del c√≥digo en comparaci√≥n con nosotros, debido al poder de la metaprogramaci√≥n y los tipos din√°micos.  Otro amigo ten√≠a un programa Scala m√°s peque√±o.  Lo que m√°s me sorprendi√≥ fue la comparaci√≥n con otro equipo que tambi√©n us√≥ Rust, pero resultaron tener tres veces m√°s c√≥digo debido a las diferentes decisiones de dise√±o.  Al final, ¬°la mayor diferencia en la cantidad de c√≥digo estaba dentro del mismo idioma! <br><a name="habracut"></a><br>  Explicar√© por qu√© considero que es una buena comparaci√≥n, proporcionar√© informaci√≥n sobre cada proyecto y explicar√© algunas razones para las diferencias en el tama√±o del compilador.  Tambi√©n sacar√© conclusiones de cada comparaci√≥n.  Si√©ntase libre de usar estos enlaces para ir a la secci√≥n de inter√©s: <br><br><h1>  Contenido </h1><br><ul><li>  ¬øPor qu√© lo encuentro significativo? <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√ìxido (base para la comparaci√≥n)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Haskell</a> : 1.0-1.6 tama√±os, dependiendo de c√≥mo cuente, por razones interesantes <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++</a> : 1.4 tama√±os por razones obvias <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Python</a> : ¬°tama√±o 0.5 debido a la metaprogramaci√≥n elegante! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rust (otro grupo)</a> : ¬°tres veces el tama√±o debido a un dise√±o diferente! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Scala</a> : 0.7 tama√±os <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OCaml</a> : 1.0-1.6 tama√±o dependiendo de c√≥mo cuente, similar a Haskell </li></ul><br><h1>  ¬øPor qu√© lo encuentro significativo? </h1><br>  Antes de decir que la cantidad de c√≥digo (compar√© cadenas y bytes) es una m√©trica terrible, quiero se√±alar que en este caso puede proporcionar una buena comprensi√≥n.  Al menos este es el ejemplo mejor controlado en el que diferentes equipos escriben el mismo gran programa del que he o√≠do o le√≠do. <br><br><ul><li>  Nadie (incluy√©ndome a m√≠) sab√≠a que medir√≠a este par√°metro, por lo que nadie intent√≥ reproducir las m√©tricas, todos intentaron terminar el proyecto de forma r√°pida y correcta. <br></li><li>  Todos (con la excepci√≥n del proyecto Python, que analizar√© m√°s adelante) implementaron el programa con el √∫nico prop√≥sito de pasar el mismo conjunto de pruebas automatizadas al mismo tiempo, por lo que los resultados no pueden ser distorsionados en gran medida por grupos que resuelven diferentes problemas. <br></li><li>  El proyecto se complet√≥ en unos pocos meses, con el equipo, y se supon√≠a que se expandir√≠a gradualmente y pasar√≠a las pruebas conocidas y desconocidas.  Esto significa que fue √∫til escribir c√≥digo limpio y claro. <br></li><li>  Adem√°s de pasar las pruebas del curso, el c√≥digo no se usar√° para nada m√°s, nadie lo leer√° y, al ser un compilador para un subconjunto limitado de Java en ensamblador de texto, no ser√° √∫til. <br></li><li>  No se permiten bibliotecas que no sean la biblioteca est√°ndar, y no hay ayudantes para el an√°lisis, incluso si est√°n en la biblioteca est√°ndar.  Esto significa que la comparaci√≥n no puede ser distorsionada por las poderosas bibliotecas de compilaci√≥n que solo tienen algunos comandos. <br></li><li>  No solo hubo pruebas p√∫blicas, sino tambi√©n secretas.  Comenzaron una vez despu√©s de la entrega final.  Esto significaba que hab√≠a un incentivo para escribir su propio c√≥digo de prueba y asegurarse de que el compilador sea confiable, correcto y maneje situaciones complejas de borde. <br></li><li>  Aunque todos los participantes son estudiantes, los considero programadores bastante competentes.  Cada uno de ellos realiz√≥ pr√°cticas durante al menos dos a√±os, principalmente en empresas de alta tecnolog√≠a, a veces incluso trabajando en compiladores.  Casi todos han estado programando durante 7-13 a√±os y son entusiastas que leen mucho en Internet fuera de sus cursos. <br></li><li>  El c√≥digo generado no se tuvo en cuenta, pero se tuvieron en cuenta los archivos de gram√°tica y el c√≥digo que gener√≥ el otro c√≥digo. </li></ul><br>  Por lo tanto, creo que la cantidad de c√≥digo proporciona una comprensi√≥n decente de cu√°nto esfuerzo se requerir√° para apoyar cada proyecto si fuera a largo plazo.  Creo que no demasiada diferencia entre los proyectos tambi√©n le permite refutar algunas declaraciones extraordinarias que le√≠, por ejemplo, que el compilador de Haskell tendr√° m√°s de la mitad del tama√±o de C ++ debido al lenguaje. <br><br><a name="1"></a><h1>  √ìxido (base para la comparaci√≥n) </h1><br>  Yo y uno de mis camaradas escribimos m√°s de 10 mil l√≠neas en Rust antes, y el tercer colega escribi√≥, quiz√°s, 500 l√≠neas en algunos hackatones.  Nuestro compilador sali√≥ en 6806 l√≠neas de <code>wc -l</code> , 5900 l√≠neas de fuente (sin espacios y comentarios) y 220 KB <code>wc -c</code> . <br><br>  Descubr√≠ que en otros proyectos estas proporciones se respetan m√°s o menos, con algunas excepciones, que se√±alar√©.  Para el resto del art√≠culo, cuando me refiero a cadenas o sumas, quiero decir <code>wc -l</code> , pero eso no importa (a menos que note la diferencia), y puede convertir con un coeficiente. <br><br>  Escrib√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otro art√≠culo describiendo nuestro dise√±o</a> , que pas√≥ todas las pruebas p√∫blicas y secretas.  Tambi√©n contiene algunas caracter√≠sticas adicionales que hicimos para divertirnos, no para aprobar las pruebas, que probablemente agregaron alrededor de 400 l√≠neas.  Tambi√©n tiene alrededor de 500 l√≠neas de nuestras pruebas unitarias. <br><br><a name="2"></a><h1>  Haskell </h1><br>  El equipo de Haskell incluy√≥ a dos de mis amigos que escribieron quiz√°s un par de miles de l√≠neas de Haskell cada uno, adem√°s de leer mucho contenido en l√≠nea sobre Haskell y otros lenguajes funcionales similares, como OCaml y Lean.  Ten√≠an otro compa√±ero de equipo a quien no conoc√≠a muy bien, pero parece que un programador fuerte us√≥ Haskell antes. <br><br>  Su compilador totaliz√≥ 9,750 l√≠neas de <code>wc -l</code> , 357 KB y 7777 l√≠neas de c√≥digo (SLOC).  Este equipo tambi√©n tiene las √∫nicas diferencias significativas entre estas proporciones: su compilador es 1.4 veces m√°s grande que el nuestro en filas, 1.3 veces en SLOC y 1.6 veces en bytes.  No implementaron ninguna funci√≥n adicional, pasaron el 100% de las pruebas p√∫blicas y secretas. <br><br>  Es importante tener en cuenta que la inclusi√≥n de pruebas afect√≥ a este equipo sobre todo.  Como se acercaron cuidadosamente a la exactitud del c√≥digo, incluyeron 1.600 l√≠neas de pruebas.  Capturaron varias situaciones l√≠mite que nuestro equipo no capt√≥, pero estos casos simplemente no fueron verificados por las pruebas del curso.  Entonces, sin pruebas en ambos lados (6.3 mil l√≠neas versus 8.1 mil l√≠neas) su compilador es solo un 30% m√°s que el nuestro. <br><br>  Aqu√≠ tiendo a los bytes como una medida m√°s razonable de comparaci√≥n de volumen, porque en un proyecto de Haskell, en promedio, hay l√≠neas m√°s largas, ya que no tiene una gran cantidad de l√≠neas de un par√©ntesis de cierre, y <code>rustfmt</code> no <code>rustfmt</code> cadenas de funci√≥n de una sola l√≠nea en varias l√≠neas. <br><br>  Despu√©s de hurgar con uno de mis compa√±eros de equipo, se nos ocurri√≥ la siguiente explicaci√≥n para esta diferencia: <br><br><ul><li>  Utilizamos un analizador l√©xico escrito a mano y un m√©todo de descenso recursivo, y utilizaron un generador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NFA</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DFA</a> y un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">analizador LR</a> , y luego un pase para convertir el √°rbol de an√°lisis a AST ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rbol de sintaxis abstracta</a> , representaci√≥n m√°s conveniente del c√≥digo).  Esto les dio significativamente m√°s c√≥digo: 2677 l√≠neas en comparaci√≥n con nuestro 1705, alrededor de 1000 l√≠neas m√°s. <br></li><li>  Utilizaron el fant√°stico AST gen√©rico, que pas√≥ a varios par√°metros de tipo a medida que se agregaba m√°s informaci√≥n en cada pasada.  Esta y m√°s funciones auxiliares para la reescritura probablemente explican por qu√© su c√≥digo AST es aproximadamente 500 l√≠neas m√°s largo que nuestra implementaci√≥n, donde recopilamos literales de estructura y mutamos los campos de <code>Option&lt;_&gt;</code> para agregar informaci√≥n a medida que avanzamos. <br></li><li>  Todav√≠a tienen alrededor de 400 l√≠neas de c√≥digo durante la generaci√≥n, que se asocian principalmente con la mayor abstracci√≥n necesaria para generar y combinar el c√≥digo de una manera puramente funcional, donde simplemente usamos l√≠neas de mutaci√≥n y escritura. </li></ul><br>  Estas diferencias m√°s pruebas explican todas las diferencias en volumen.  De hecho, nuestros archivos para constantes plegables y resoluci√≥n de contexto tienen un tama√±o muy cercano.  Pero a√∫n as√≠, hay alguna diferencia en los bytes debido a las l√≠neas m√°s largas: probablemente porque se necesita m√°s c√≥digo para reescribir todo el √°rbol en cada pasada. <br><br>  Como resultado, dejando de lado las decisiones de dise√±o, en mi opini√≥n, Rust y Haskell son igualmente expresivos, tal vez con una ligera ventaja Rust debido a la capacidad de usar f√°cilmente la mutaci√≥n cuando sea conveniente.  Tambi√©n fue interesante saber que mi elecci√≥n del m√©todo de descenso recursivo y el analizador l√©xico escrito a mano vali√≥ la pena: era un riesgo que contradec√≠a las recomendaciones e instrucciones del profesor, pero decid√≠ que era m√°s f√°cil y correcto. <br><br>  Los fan√°ticos de Haskell argumentar√°n que ese equipo probablemente no aprovech√≥ al m√°ximo Haskell, y si supieran mejor el idioma, podr√≠an haber hecho un proyecto con menos c√≥digo.  Estoy de acuerdo, alguien como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Edward Kmett</a> puede escribir el mismo compilador en una cantidad mucho menor.  De hecho, el equipo de mi amigo no us√≥ muchas abstracciones s√∫per avanzadas sofisticadas y bibliotecas combinadas elegantes como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lentes</a> .  Sin embargo, todo esto afecta la legibilidad del c√≥digo.  Todas las personas en el equipo son programadores experimentados, sab√≠an que Haskell era capaz de hacer cosas muy extra√±as, pero decidieron no usarlas porque decidieron que comprenderlas tomar√≠a m√°s tiempo del que ahorrar√≠an y har√≠a que el c√≥digo fuera m√°s dif√≠cil de entender para otros.  Esto parece un compromiso real, y la afirmaci√≥n de que Haskell es m√°gicamente adecuado para compiladores entra en algo como "Haskell requiere una habilidad extremadamente alta en la redacci√≥n de compiladores si no te importa el soporte de c√≥digo para personas que tampoco son muy expertas en Haskell". <br><br>  Tambi√©n es interesante notar que al comienzo de cada proyecto, el profesor dice que los estudiantes pueden usar cualquier idioma que se ejecute en un servidor universitario, pero advierte que los equipos en Haskell son diferentes del resto: tienen la mayor dispersi√≥n en las calificaciones.  Muchas personas sobreestiman sus habilidades y los equipos de Haskell tienen las mejores calificaciones, aunque a otros les va muy bien como a mis amigos. <br><br><a name="3"></a><h1>  C ++ </h1><br>  Luego habl√© con mi amigo del equipo de C ++.  Conoc√≠a solo a una persona en este equipo, pero C ++ se usa en varios cursos en nuestra universidad, por lo que probablemente todos en el equipo ten√≠an experiencia en C ++. <br><br>  Su proyecto consisti√≥ en 8733 l√≠neas y 280 KB, sin incluir el c√≥digo de prueba, pero incluyendo alrededor de 500 l√≠neas de funciones adicionales.  Lo que lo hace 1,4 veces m√°s grande que nuestro c√≥digo sin pruebas, que tambi√©n tiene alrededor de 500 l√≠neas de funciones adicionales.  Pasaron el 100% de las pruebas p√∫blicas, pero solo el 90% de las pruebas secretas.  Presumiblemente porque no implementaron los arreglos vtables elegantes requeridos por la especificaci√≥n, que ocupan quiz√°s 50-100 l√≠neas de c√≥digo. <br><br>  No profundic√© demasiado en estas diferencias de tama√±o.  Supongo que esto se debe principalmente a: <br><br><ul><li>  Utilizan el analizador LR y la reescritura de √°rboles en lugar del m√©todo de descenso recursivo. <br></li><li>  La falta de tipos de suma y comparaciones de patrones en C ++, que hemos utilizado ampliamente y que fueron muy √∫tiles. <br></li><li>  La necesidad de duplicar todas las firmas en los archivos de encabezado, que no es el caso en Rust. </li></ul><br>  Tambi√©n comparamos el tiempo de compilaci√≥n.  En mi computadora port√°til, la compilaci√≥n de depuraci√≥n limpia de nuestro compilador tarda 9.7 s, la versi√≥n limpia de 12.5 sy la compilaci√≥n incremental de depuraci√≥n de 3.5 s.  Mi amigo no ten√≠a los tiempos disponibles para su compilaci√≥n C ++ (usando make paralelo), pero dijo que los n√∫meros son similares, con la advertencia de que ponen implementaciones de muchas funciones peque√±as en los archivos de encabezado para reducir la duplicaci√≥n de firmas a costa de un tiempo m√°s largo (es decir por lo tanto, no puedo medir la sobrecarga de la l√≠nea neta en los archivos de encabezado). <br><br><a name="4"></a><h1>  Pit√≥n </h1><br>  Mi amigo, un muy buen programador, decidi√≥ hacer el proyecto solo en Python.  Tambi√©n implement√≥ caracter√≠sticas m√°s avanzadas (por diversi√≥n) que cualquier otro equipo, incluida una vista intermedia de SSA con asignaci√≥n de registros y otras optimizaciones.  Por otro lado, dado que funcion√≥ solo e implement√≥ muchas funciones adicionales, prest√≥ la menor atenci√≥n a la calidad del c√≥digo, por ejemplo, lanzando excepciones indiferenciadas para todos los errores (confiando en las trazas inversas para la depuraci√≥n) en lugar de implementar tipos de error y mensajes correspondientes, como nosotros <br><br>  Su compilador constaba de 4581 l√≠neas y pasaba todas las pruebas p√∫blicas y secretas.  Tambi√©n implement√≥ funciones m√°s avanzadas que cualquier otro comando, pero es dif√≠cil determinar cu√°nto c√≥digo adicional tom√≥, porque muchas de las funciones adicionales eran versiones m√°s potentes de cosas simples que todos necesitaban implementar, como plegar constantes y generar c√≥digo.  Las funciones adicionales son probablemente de 1000 a 2000 l√≠neas, al menos, as√≠ que estoy seguro de que su c√≥digo es al menos dos veces m√°s expresivo que el nuestro. <br><br>  Una gran parte de esta diferencia es probablemente la escritura din√°mica.  Solo en nuestros <code>ast.rs</code> 500 l√≠neas de definiciones de tipos y muchos m√°s tipos definidos en otra parte del compilador.  Tambi√©n siempre estamos limitados al sistema de tipos en s√≠.  Por ejemplo, necesitamos una infraestructura para agregar ergon√≥micamente nueva informaci√≥n al AST a medida que pasamos y accedemos a ella m√°s tarde.  Mientras est√© en Python, puede establecer nuevos campos en los nodos AST. <br><br>  Potente metaprogramaci√≥n tambi√©n explica parte de la diferencia.  Por ejemplo, aunque us√≥ un analizador LR en lugar de un m√©todo de descenso recursivo, en mi caso creo que tom√≥ menos c√≥digo porque en lugar de pasar por una reescritura de √°rbol, su gram√°tica LR inclu√≠a fragmentos de c√≥digo Python para construir el AST, que el generador podr√≠a convertir en funciones de Python usando <code>eval</code> .  Parte de la raz√≥n por la que no usamos el analizador LR es que construir un AST sin reescribir el √°rbol requerir√° mucha ceremonia (creando archivos Rust o macros de procedimiento) para asociar la gram√°tica con fragmentos de c√≥digo Rust. <br><br>  Otro ejemplo del poder de la metaprogramaci√≥n y la tipificaci√≥n din√°mica es el archivo <code>visit.rs</code> 400 l√≠neas, que es b√°sicamente un c√≥digo repetitivo repetitivo que implementa un visitante en un mont√≥n de estructuras AST.  En Python, esta puede ser una funci√≥n corta de aproximadamente 10 l√≠neas que introspectivamente recurrentemente examina los campos de un nodo AST y los visita (usando el atributo <code>__dict__</code> ). <br><br>  Como fan√°tico de Rust y de los lenguajes est√°ticamente escritos en general, me inclino a notar que el sistema de tipos es muy √∫til para prevenir errores y para el rendimiento.  La metaprogramaci√≥n inusual tambi√©n puede dificultar la comprensi√≥n del funcionamiento del c√≥digo.  Sin embargo, esta comparaci√≥n me sorprendi√≥ por el hecho de que no esperaba que la diferencia en la cantidad de c√≥digo fuera tan grande.  Si la diferencia en su conjunto est√° realmente cerca de tener que escribir el doble de c√≥digo, sigo pensando que Rust es un compromiso adecuado, pero a√∫n as√≠ la mitad de ese c√≥digo es un argumento, y en el futuro tiendo a hacer algo en Ruby / Python si solo necesita construir algo r√°pidamente solo, y luego tirarlo a la basura. <br><br><a name="5"></a><h1>  Rust (otro grupo) </h1><br>  La comparaci√≥n m√°s interesante para m√≠ fue con mi amigo, que tambi√©n estaba haciendo un proyecto en Rust con un compa√±ero de equipo (a quien no conoc√≠a).  Mi amigo tuvo una buena experiencia de Rust.  Contribuy√≥ al desarrollo del compilador Rust y ley√≥ mucho.  No s√© nada de su compa√±ero. <br><br>  Su proyecto consisti√≥ en 17.211 l√≠neas sin procesar, 15.000 l√≠neas de origen y 637 KB, sin incluir el c√≥digo de prueba y el c√≥digo generado.  No ten√≠a funciones adicionales, y solo pas√≥ 4 de 10 pruebas secretas y el 90% de las pruebas p√∫blicas para la generaci√≥n de c√≥digo, porque no ten√≠an suficiente tiempo antes de la fecha l√≠mite para implementar partes m√°s extra√±as de la especificaci√≥n.  ¬°Su programa es tres veces m√°s grande que el nuestro, escrito en el mismo idioma y con menos funcionalidad! <br><br>  Este resultado fue realmente sorprendente para m√≠ y eclips√≥ todas las diferencias entre los idiomas que he estudiado hasta ahora.  Por lo tanto, comparamos las listas de tama√±os de archivo <code>wc -l</code> , y tambi√©n verificamos c√≥mo cada uno de nosotros implement√≥ algunas cosas espec√≠ficas que dieron como resultado diferentes tama√±os de c√≥digo. <br><br>  Parece que todo se reduce a la adopci√≥n constante de varias decisiones de dise√±o.  Por ejemplo, su interfaz (an√°lisis l√©xico, an√°lisis, creaci√≥n de AST) toma 7597 l√≠neas contra nuestro 2164. Usaron el analizador l√©xico DFA y el analizador LALR (1), pero otros grupos hicieron cosas similares sin tanto c√≥digo.  Al mirar su archivo de eliminaci√≥n, not√© una serie de decisiones de dise√±o que eran diferentes a las nuestras: <br><br><ul><li>  Decidieron usar un √°rbol de an√°lisis completamente tipado en lugar de un √°rbol de an√°lisis est√°ndar, uniforme y basado en cadenas.  Esto probablemente requiri√≥ muchas m√°s definiciones de tipo y c√≥digo de conversi√≥n adicional en la etapa de an√°lisis o un analizador m√°s complejo. <br></li><li>  Utilizaron implementaciones de prueba tryfrom para convertir entre tipos de √°rbol de an√°lisis y tipos AST para validarlos.  Esto lleva a muchos bloques <code>impl</code> 10-20 l√≠neas.  Para hacer esto, utilizamos funciones que devuelven tipos de <code>Result</code> , lo que genera menos l√≠neas, y tambi√©n nos libera un poco de la estructura de tipos, simplificando la parametrizaci√≥n y la reutilizaci√≥n.  Algunas de las cosas que, para nosotros, eran ramas de <code>match</code> sola l√≠nea, ten√≠an bloques <code>impl</code> 10 l√≠neas. <br></li><li>  Nuestros tipos est√°n estructurados para reducir copiar y pegar.  Por ejemplo, utilizaron campos separados <code>is_abstract</code> , <code>is_native</code> e <code>is_static</code> , donde el c√≥digo de verificaci√≥n de restricciones tuvo que copiarse dos veces: una vez para m√©todos de tipo vac√≠o y otra para m√©todos con tipo de retorno, con ligeras modificaciones.  Si bien nuestro <code>void</code> era solo un tipo especial, se nos ocurri√≥ una taxonom√≠a de modificadores con <code>mode</code> y <code>visibility</code> que aplicaban restricciones de nivel de tipo, y se generaban errores de restricci√≥n por defecto para el operador de coincidencia, que traduc√≠a los conjuntos de modificadores en <code>mode</code> y <code>visibility</code> . </li></ul><br>  No mir√© el c√≥digo de los pases del an√°lisis de su compilador, pero tambi√©n son geniales.  Habl√© con mi amigo, y parece que no implementaron nada similar a la infraestructura de los visitantes, como la nuestra.  Supongo que, junto con algunas otras diferencias de dise√±o m√°s peque√±as, explica la diferencia de tama√±o de esta parte.  El visitante permite que nuestros pases de an√°lisis se centren solo en las partes del AST que necesitaban, en lugar de hacer coincidir el patr√≥n en toda la estructura del AST.  Esto ahorra mucho c√≥digo. <br><br>  Su parte para la generaci√≥n de c√≥digo consiste en 3594 l√≠neas, y la nuestra: 1560. Observ√© su c√≥digo y parece que casi toda la diferencia es que eligieron una estructura de datos intermedia para las instrucciones del ensamblador, donde solo usamos el formato de cadena para la salida del ensamblador directo. .  Ten√≠an que definir tipos y funciones de salida para todas las instrucciones usadas y tipos de operandos.  Tambi√©n significaba que las instrucciones de montaje del edificio tomaban m√°s c√≥digo.  Cuando ten√≠amos un operador de formato con instrucciones breves, como <code>mov ecx, [edx]</code> , necesitaban un operador <code>rustfmt</code> gigante, dividido en 6 l√≠neas, que constru√≠a una instrucci√≥n con un grupo de tipos anidados intermedios para operandos que incluyen hasta 6 niveles de par√©ntesis anidados.  Tambi√©n podr√≠amos generar bloques de instrucciones relacionadas, como un pre√°mbulo de funci√≥n, en una declaraci√≥n de formato √∫nico, donde ten√≠an que especificar la construcci√≥n completa para cada instrucci√≥n. <br><br>  Nuestro equipo estaba considerando usar una abstracci√≥n como la de ellos.  Era m√°s f√°cil poder generar un conjunto de texto o emitir directamente el c√≥digo de la m√°quina, sin embargo, este no era un requisito del curso.  Lo mismo podr√≠a hacerse con menos c√≥digo y un mejor rendimiento utilizando el <code>X86Writer</code> X86Writer con m√©todos como <code>push(reg: Register)</code> .  Tambi√©n tomamos en cuenta que esto podr√≠a simplificar la depuraci√≥n y las pruebas, pero nos dimos cuenta de que ver el ensamblador de texto generado es realmente m√°s f√°cil de leer y probar usando la prueba de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instant√°neas</a> , si inserta comentarios libremente.  Pero (aparentemente correctamente) predijimos que tomar√≠a mucho c√≥digo adicional, y no hab√≠a un beneficio real, dadas nuestras necesidades reales, por lo que no nos preocupamos. <br><br>  Es bueno comparar esto con la representaci√≥n intermedia que el equipo de C ++ us√≥ como una funci√≥n adicional, que solo les tom√≥ 500 l√≠neas adicionales.  Usaron una estructura muy simple (para definiciones de tipo simples y c√≥digo de compilaci√≥n) que usaba operaciones cercanas a lo que Java requer√≠a.  Esto significaba que su representaci√≥n intermedia era mucho m√°s peque√±a (y por lo tanto requer√≠a menos c√≥digo de compilaci√≥n) que el ensamblador resultante, ya que muchas operaciones de lenguaje, como llamadas y conversiones, se expandieron en muchas instrucciones de ensamblador.  Tambi√©n dicen que realmente ayud√≥ a la depuraci√≥n, ya que elimin√≥ mucha basura y mejor√≥ la legibilidad.  Una presentaci√≥n de nivel superior tambi√©n permiti√≥ hacer algunas optimizaciones simples en su representaci√≥n intermedia.  El equipo de C ++ ide√≥ un dise√±o realmente bueno que les hizo mucho m√°s bien con mucho menos c√≥digo. <br><br>  En general, parece que la raz√≥n com√∫n de la triple diferencia en volumen se debe a la adopci√≥n constante de varias decisiones de dise√±o, tanto grandes como peque√±as, en la direcci√≥n de m√°s c√≥digo.  Implementaron una serie de abstracciones, lo que no hicimos: agregaron m√°s c√≥digo y omitieron algunas de nuestras abstracciones, que reducen la cantidad de c√≥digo. <br><br>  Este resultado realmente me sorprendi√≥.  Sab√≠a que las decisiones de dise√±o son importantes, pero no habr√≠a adivinado de antemano que conducir√≠an a diferencias de este tama√±o, dado que solo examin√© a las personas que considero programadores competentes.  De todos los resultados de comparaci√≥n, este es el m√°s significativo para m√≠.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probablemente me ayud√≥ que le√≠ mucho sobre c√≥mo escribir compiladores antes de tomar este curso, para poder usar proyectos inteligentes que otras personas inventaron y descubrieron que funcionaban bien, como los visitantes de AST y el m√©todo de descenso recursivo, aunque no se les ense√±√≥ en nuestro curso</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo que realmente me hizo pensar es el costo de la abstracci√≥n. Las abstracciones pueden facilitar la expansi√≥n futura o proteger contra algunos tipos de errores, pero deben tenerse en cuenta, dado que puede obtener el triple de c√≥digo para comprender y refactorizar, el triple de lugares posibles para errores y menos tiempo para pruebas y m√°s desarrollo Nuestro curso de capacitaci√≥n era diferente del mundo real: sab√≠amos con certeza que nunca tocar√≠amos el c√≥digo despu√©s del desarrollo, esto elimina los beneficios de la abstracci√≥n proactiva. Sin embargo, si tuviera que elegir qu√© compilador ampliar con una funci√≥n arbitraria, que dir√°s m√°s tarde, elegir√≠a el nuestro, sin siquiera considerar mi familiaridad con √©l. Solo porque tiene mucho menos c√≥digo para entender, y podr√≠a elegir la mejor abstracci√≥n para los requisitos (p. Ej.representaci√≥n intermedia del comando C ++) cuando conozco los requisitos espec√≠ficos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adem√°s, en mi opini√≥n, se fortaleci√≥ la taxonom√≠a de las abstracciones: existen aquellas que reducen el c√≥digo, teniendo en cuenta solo los requisitos actuales, como nuestra plantilla de visitante, y hay abstracciones que agregan c√≥digo, pero proporcionan los beneficios de la extensibilidad, la depuraci√≥n o la correcci√≥n. </font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Scala </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n habl√© con un amigo que hizo un proyecto en Scala en el semestre anterior, pero el proyecto y las pruebas fueron exactamente iguales. </font><font style="vertical-align: inherit;">Su compilador consist√≠a en 4141 l√≠neas y ~ 160 KB de c√≥digo, sin contar las pruebas. </font><font style="vertical-align: inherit;">Pasaron 8 de 10 pruebas secretas y 100% pruebas abiertas y no implementaron ninguna funci√≥n adicional. </font><font style="vertical-align: inherit;">Por lo tanto, en comparaci√≥n con nuestras l√≠neas 5906 sin funciones y pruebas adicionales, su compilador es un 30% menor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uno de los peque√±os factores de dise√±o fue un enfoque diferente para el an√°lisis. El curso permiti√≥ el uso de una herramienta de l√≠nea de comando para el generador de tablas LR. Nadie lo us√≥ excepto este equipo. Esto les salv√≥ de tener que implementar el generador de tablas LR. Tambi√©n lograron evitar escribir gram√°tica LR con un script Python de 150 l√≠neas que borr√≥ la p√°gina web de gram√°tica Java que encontraron en Internet y la tradujo al formato de entrada del generador. Todav√≠a necesitaban hacer alg√∫n tipo de √°rbol en Scala, pero en general la etapa de an√°lisis ascendi√≥ a 1073 l√≠neas en comparaci√≥n con nuestra 1443, aunque nuestro m√©todo de descenso de gradiente aqu√≠ dio una ventaja en volumen en comparaci√≥n con todos los dem√°s equipos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El resto de su compilador tambi√©n era m√°s peque√±o que el nuestro, sin grandes diferencias obvias de dise√±o, aunque no profundic√© en el c√≥digo. </font><font style="vertical-align: inherit;">Sospecho que esto se debe a las diferencias en la expresividad de Scala y Rust. </font><font style="vertical-align: inherit;">Scala y Rust tienen caracter√≠sticas de programaci√≥n similares √∫tiles para compiladores, como la coincidencia de patrones, pero la memoria administrada de Scala guarda el c√≥digo necesario para que el verificador de pr√©stamos funcione en Rust. </font><font style="vertical-align: inherit;">Adem√°s, Scala tiene un az√∫car sint√°ctico m√°s variado que Rust.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OCaml </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como todos los miembros de nuestro equipo realizan una pasant√≠a en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jane Street</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (empresa comercializadora de tecnolog√≠a, aprox. Por persona), estaba especialmente interesado en ver el resultado de otros ex pasantes de Jane Street que eligieron OCaml para escribir el compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Su compilador ten√≠a 10.914 l√≠neas y 377 KB, incluida una peque√±a cantidad de c√≥digo de prueba y sin caracter√≠sticas adicionales. Pasaron 9/10 pruebas secretas y todas las pruebas p√∫blicas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que otros grupos, parece que la principal diferencia de tama√±o se debe al uso del analizador LR y la reescritura de √°rboles para el an√°lisis, as√≠ como la canalizaci√≥n de conversi√≥n regex-&gt; NFA-&gt; DFA para el an√°lisis l√©xico. Su interfaz (an√°lisis l√©xico, an√°lisis, construcci√≥n AST) es de 5548 l√≠neas, y la nuestra, 2164, con proporciones similares para bytes. Tambi√©n usaron las </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pruebas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para su analizador </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">con la expectativa de</font></a><font style="vertical-align: inherit;"> que fuera similar a nuestras pruebas de instant√°neas, que colocaban la salida esperada fuera del c√≥digo, por lo que sus pruebas de analizador hicieron ~ 600 l√≠neas del total, y las nuestras, alrededor de 200.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto deja 5366 l√≠neas para el resto del compilador (461 l√≠neas de las cuales son archivos de interfaz con declaraciones de tipo) y 4642 para nosotros, la diferencia es solo del 15%, si contamos sus archivos de interfaz, y casi del mismo tama√±o, si no cuenta. </font><font style="vertical-align: inherit;">Parece que, aparte de nuestras soluciones de dise√±o de an√°lisis, Rust y OCaml parecen igualmente expresivos, excepto que OCaml necesita archivos front-end y Rust no.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusi√≥n </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, estoy muy contento de haber hecho esta comparaci√≥n, aprend√≠ mucho y me sorprend√≠ muchas veces. </font><font style="vertical-align: inherit;">Creo que la conclusi√≥n general es que las decisiones de dise√±o son mucho m√°s importantes que el lenguaje, pero el lenguaje es importante porque le brinda herramientas para implementar diferentes dise√±os.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456638/">https://habr.com/ru/post/456638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456622/index.html">C√≥mo crear un sistema operativo certificado seg√∫n la protecci√≥n de clase I</a></li>
<li><a href="../456624/index.html">Herramientas √∫tiles de Python</a></li>
<li><a href="../456630/index.html">Presentaci√≥n de Airflow para administrar Spark Jobs en ivi: esperanzas y muletas</a></li>
<li><a href="../456632/index.html">Estamos construyendo el cuarto piso de plantillas C ++ en RESTinio. ¬øPor qu√© y c√≥mo?</a></li>
<li><a href="../456634/index.html">Recetas Nginx: CAS (Servicio de autorizaci√≥n central)</a></li>
<li><a href="../456640/index.html">An√°lisis del concurso de inteligencia competitiva en PHDays 9</a></li>
<li><a href="../456642/index.html">La primera graduaci√≥n del programa de Maestr√≠a Corporativa de JetBrains y la Universidad ITMO</a></li>
<li><a href="../456644/index.html">En Kickstarter aparece una impresora 3D de pol√≠meros fotogr√°ficos 3D de bajo costo.</a></li>
<li><a href="../456646/index.html">Indulgencia: c√≥mo deshacerse de la deuda para las tareas</a></li>
<li><a href="../456650/index.html">Elecci√≥n de un osciloscopio de bolsillo econ√≥mico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>