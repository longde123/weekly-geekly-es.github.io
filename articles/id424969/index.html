<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîú üßóüèº ‚õ©Ô∏è Panduan Node.js, Bagian 9: Bekerja dengan Sistem File üòñ üå≤ üéüÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini, di bagian kesembilan dari terjemahan tutorial Node.js, kita akan berbicara tentang bekerja dengan file. Secara khusus, kita akan berbicara t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan Node.js, Bagian 9: Bekerja dengan Sistem File</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424969/">  Hari ini, di bagian kesembilan dari terjemahan tutorial Node.js, kita akan berbicara tentang bekerja dengan file.  Secara khusus, kita akan berbicara tentang modul fs dan path - tentang deskriptor file, tentang path file, tentang mendapatkan informasi tentang file, tentang membaca dan menulisnya, tentang bekerja dengan direktori. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Kami menyarankan Anda untuk membaca] Bagian lain dari siklus ini</b> <div class="spoiler_text">  Bagian 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi Umum dan Memulai</a> <br>  Bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaScript, V8, beberapa trik pengembangan</a> <br>  Bagian 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hosting, REPL, bekerja dengan konsol, modul</a> <br>  Bagian 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm, package.json dan file package-lock.json</a> <br>  Bagian 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm dan npx</a> <br>  Bagian 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">loop acara, tumpukan panggilan, timer</a> <br>  Bagian 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman Asinkron</a> <br>  Bagian 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, Bagian 8: HTTP dan Protokol WebSocket</a> <br>  Bagian 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, bagian 9: bekerja dengan sistem file</a> <br>  Bagian 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, Bagian 10: Modul Standar, Streaming, Database, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF lengkap dari Node.js Guide</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Bekerja dengan deskriptor file di Node.js</font> </h2><br>  Sebelum Anda dapat berinteraksi dengan file yang terletak di sistem file server Anda, Anda perlu mendapatkan deskriptor file. <br><br>  Deskriptor dapat diperoleh dengan menggunakan metode asynchronous <code>open()</code> dari modul <code>fs</code> untuk membuka file: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.open(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, fd)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>fd -    })</code> </pre> <br>  Perhatikan parameter kedua, <code>r</code> , yang digunakan saat memanggil metode <code>fs.open()</code> .  Ini adalah flag yang memberi tahu sistem bahwa file sedang dibuka untuk dibaca.  Berikut adalah beberapa flag yang sering digunakan ketika bekerja dengan ini dan beberapa metode lain: <br><br><ul><li>  <code>r+</code> - buka file untuk membaca dan menulis. </li><li>  <code>w+</code> - buka file untuk membaca dan menulis dengan mengatur stream pointer ke awal file.  Jika file tidak ada, itu dibuat. </li><li>  <code>a</code> - buka file untuk ditulis dengan mengatur stream pointer ke akhir file.  Jika file tidak ada, itu dibuat. </li><li>  <code>a+</code> - - buka file untuk membaca dan menulis dengan mengatur stream pointer ke akhir file.  Jika file tidak ada, itu dibuat. </li></ul><br>  File dapat dibuka menggunakan metode sinkron <code>fs.openSync()</code> , yang alih-alih memberikan deskriptor file di callback, mengembalikannya: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fd = fs.openSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Setelah menerima deskriptor menggunakan salah satu metode di atas, Anda dapat melakukan operasi yang diperlukan dengannya. <br><br><h2>  <font color="#3AC1EF">File data</font> </h2><br>  Setiap file memiliki set data yang terkait dengannya, Anda dapat memeriksa data ini menggunakan Node.js.  Secara khusus, ini dapat dilakukan dengan menggunakan metode <code>stat()</code> dari modul <code>fs</code> . <br><br>  Metode ini disebut, meneruskan path ke file ke sana, dan setelah Node.js menerima informasi yang diperlukan tentang file, itu akan memanggil callback yang dilewatkan ke metode <code>stat()</code> .  Begini tampilannya: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.stat(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, stats)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      `<span class="javascript"><span class="javascript">stats</span></span>` })</code> </pre> <br>  Node.js memiliki kemampuan untuk mengambil informasi file secara sinkron.  Dengan pendekatan ini, utas utama diblokir sampai properti file diperoleh: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stats = fs.statSync (<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Informasi tentang file akan masuk ke dalam <code>stats</code> konstan.  Apa informasi ini?  Bahkan, objek yang sesuai memberi kita sejumlah besar properti dan metode yang berguna: <br><br><ul><li>  Metode <code>.isFile()</code> dan <code>.isDirectory()</code> masing-masing memungkinkan untuk mengetahui apakah file yang diselidiki adalah file atau direktori biasa. </li><li>  Metode <code>.isSymbolicLink()</code> memberi tahu Anda jika file adalah tautan simbolik. </li><li>  Ukuran file dapat ditemukan menggunakan properti <code>.size</code> . </li></ul><br>  Ada metode lain di sini, tetapi ini adalah yang paling banyak digunakan.  Berikut cara menggunakannya: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.stat(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, stats)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } stats.isFile() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">true</span></span> stats.isDirectory() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">false</span></span> stats.isSymbolicLink() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">false</span></span> stats.size <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">1024000</span></span> //= <span class="hljs-number"><span class="hljs-number">1</span></span>MB })</code> </pre> <br><h2>  <font color="#3AC1EF">File paths di Node.js dan modul path</font> </h2><br>  Jalur file adalah alamat tempat di sistem file tempat ia berada. <br><br>  Di Linux dan macOS, path mungkin terlihat seperti ini: <br><br><pre> <code class="hljs mel">/users/flavio/<span class="hljs-keyword"><span class="hljs-keyword">file</span></span>.txt</code> </pre> <br>  Di Windows, jalur tampak sedikit berbeda: <br><br><pre> <code class="hljs tex">C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">users</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">flavio</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span></span>.txt</code> </pre> <br>  Perbedaan dalam format jalur rekaman ketika menggunakan sistem operasi yang berbeda harus dicatat, mengingat sistem operasi yang digunakan untuk menggunakan server Node.js. <br><br>  Node.js memiliki modul <code>path</code> standar yang dirancang untuk bekerja dengan jalur file.  Sebelum menggunakan modul ini dalam suatu program, itu harus terhubung: <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Mendapatkan informasi jalur file</font> </h3><br>  Jika Anda memiliki path ke file, kemudian menggunakan kemampuan modul <code>path</code> , Anda bisa, dalam bentuk yang nyaman untuk persepsi dan pemrosesan lebih lanjut, cari tahu detail tentang path ini.  Ini terlihat seperti ini: <br><br><pre> <code class="hljs pgsql">const notes = <span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span> <span class="hljs-type"><span class="hljs-type">path</span></span>.dirname(notes) // /users/flavio <span class="hljs-type"><span class="hljs-type">path</span></span>.basename(notes) // notes.txt <span class="hljs-type"><span class="hljs-type">path</span></span>.extname(notes) // .txt</code> </pre> <br>  Di sini, di baris <code>notes</code> , jalur file disimpan.  Metode modul <code>path</code> berikut digunakan untuk menguraikan <code>path</code> : <br><br><ul><li>  <code>dirname()</code> - mengembalikan direktori induk file. </li><li>  <code>basename()</code> - mengembalikan nama file. </li><li>  <code>extname()</code> - mengembalikan ekstensi file. </li></ul><br>  Anda dapat mengetahui nama file tanpa ekstensi dengan memanggil metode <code>.basename()</code> dan meneruskannya argumen kedua yang mewakili ekstensi: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.basename(notes, <span class="hljs-type"><span class="hljs-type">path</span></span>.extname(notes)) //notes</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçBekerja dengan jalur file</font> </h3><br>  Beberapa bagian jalur dapat digabungkan menggunakan metode <code>path.join()</code> : <br><br><pre> <code class="hljs pgsql">const <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'flavio'</span></span> <span class="hljs-type"><span class="hljs-type">path</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-string"><span class="hljs-string">'notes.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span></code> </pre> <br>  Anda dapat menemukan path absolut ke file berdasarkan path relatif ke sana menggunakan metode <code>path.resolve()</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/Users/flavio/flavio.txt'</span></span>      </code> </pre> <br>  Dalam hal ini, Node.js cukup menambahkan <code>/flavio.txt</code> ke jalur yang mengarah ke direktori kerja saat ini.  Jika, saat memanggil metode ini, Anda meneruskan parameter lain yang mewakili jalur ke folder, metode menggunakannya sebagai basis untuk menentukan jalur absolut: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>, <span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'/Users/flavio/tmp/flavio.txt'</span></span>      </code> </pre> <br>  Jika jalur dilewati sebagai parameter pertama dimulai dengan garis miring, ini berarti bahwa itu adalah jalur absolut. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'/etc'</span></span>, <span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'/etc/flavio.txt'</span></span></code> </pre> <br>  Berikut adalah metode lain yang bermanfaat - <code>path.normalize()</code> .  Ini memungkinkan Anda untuk menemukan jalur nyata ke file menggunakan jalur yang berisi kualifikasi jalur relatif seperti titik ( <code>.</code> ), Dua poin ( <code>..</code> ), atau dua garis miring: <br><br><pre> <code class="hljs mel">path.<span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(<span class="hljs-string"><span class="hljs-string">'/users/flavio/..//test.txt'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// /users/test.txt</span></span></code> </pre> <br>  Metode <code>resolve()</code> dan <code>normalize()</code> tidak memeriksa keberadaan direktori.  Mereka hanya menemukan jalur berdasarkan data yang diberikan kepada mereka. <br><br><h2>  <font color="#3AC1EF">Membaca File di Node.js</font> </h2><br>  Cara termudah untuk membaca file di Node.js adalah dengan menggunakan metode <code>fs.readFile()</code> , meneruskannya path ke file dan callback, yang akan dipanggil dengan transfer data file (atau objek kesalahan) ke sana: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br>  Jika perlu, Anda dapat menggunakan versi sinkron dari metode ini - <code>fs.readFileSync()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Secara default, encoding <code>utf8</code> digunakan saat membaca file, tetapi encoding juga dapat diatur secara independen dengan mengirimkan parameter yang sesuai ke metode. <br><br>  Metode <code>fs.readFile()</code> dan <code>fs.readFileSync()</code> membaca seluruh isi file ke dalam memori.  Ini berarti bekerja dengan file besar menggunakan metode ini akan secara serius mempengaruhi konsumsi memori aplikasi Anda dan akan mempengaruhi kinerjanya.  Jika Anda perlu bekerja dengan file seperti itu, yang terbaik adalah menggunakan stream. <br><br><h2>  <font color="#3AC1EF">Menulis File ke Node.js</font> </h2><br>  Di Node.js, lebih mudah menulis file menggunakan metode <code>fs.writeFile()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> fs.writeFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content, (err) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  Ada juga versi sinkron dari metode yang sama - <code>fs.writeFileSync()</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = require(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = fs.writeFileSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content) <span class="hljs-comment"><span class="hljs-comment">//   } catch (err) { console.error(err) }</span></span></code> </pre> <br>  Metode-metode ini, secara default, mengganti konten file yang ada.  Anda dapat mengubah perilaku standar mereka menggunakan bendera yang sesuai: <br><br><pre> <code class="hljs coffeescript">fs.writeFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content, { flag: <span class="hljs-string"><span class="hljs-string">'a+'</span></span> }, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {})</code> </pre> <br>  Bendera dapat digunakan di sini, yang telah kami cantumkan di bagian deskriptor.  Detail tentang bendera dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  <font color="#3AC1EF">Lampirkan data ke file</font> </h2><br>  Metode <code>fs.appendFile()</code> (dan versi <code>fs.appendFileSync()</code> , <code>fs.appendFileSync()</code> ) mudah digunakan untuk melampirkan data ke akhir file: <br><br><pre> <code class="hljs coffeescript">const content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> fs.appendFile(<span class="hljs-string"><span class="hljs-string">'file.log'</span></span>, content, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>! })</code> </pre> <br><h2>  <font color="#3AC1EF">Tentang menggunakan utas</font> </h2><br>  Di atas, kami menjelaskan metode yang, saat menulis ke file, menulis seluruh jumlah data yang ditransfer ke dalamnya, setelah itu, jika versi sinkronnya digunakan, mereka mengembalikan kontrol ke program, dan jika versi asinkron digunakan, mereka memanggil panggilan balik.  Jika keadaan ini tidak sesuai dengan Anda, akan lebih baik menggunakan stream. <br><br><h2>  <font color="#3AC1EF">Bekerja dengan direktori di Node.js</font> </h2><br>  Modul <code>fs</code> menyediakan pengembang dengan banyak metode mudah yang dapat digunakan untuk bekerja dengan direktori. <br><br><h3>  <font color="#3AC1EF">‚ñçPeriksa keberadaan folder</font> </h3><br>  Untuk memeriksa apakah direktori tersebut ada dan apakah Node.js dapat mengaksesnya, dengan izin yang diberikan, Anda dapat menggunakan metode <code>fs.access()</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçBuat folder baru</font> </h3><br>  Untuk membuat folder baru, Anda dapat menggunakan metode <code>fs.mkdir()</code> dan <code>fs.mkdirSync()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folderName = <span class="hljs-string"><span class="hljs-string">'/Users/flavio/test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fs.existsSync(dir)){   fs.mkdirSync(dir) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçMembaca isi folder</font> </h3><br>  Untuk membaca konten folder, Anda dapat menggunakan metode <code>fs.readdir()</code> dan <code>fs.readdirSync()</code> .  Contoh ini membaca konten folder - yaitu, informasi tentang file dan subdirektori apa yang dikandungnya dan mengembalikan jalur relatifnya: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folderPath = <span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span> fs.readdirSync(folderPath)</code> </pre> <br>  Ini adalah bagaimana Anda bisa mendapatkan path lengkap ke file: <br><br><pre> <code class="hljs swift">fs.readdirSync(folderPath).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(fileName =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(folderPath, fileName) }</code> </pre> <br>  Hasil dapat disaring untuk mendapatkan hanya file dan dikecualikan dari output direktori: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isFile = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fs.lstatSync(fileName).isFile() } fs.readdirSync(folderPath).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.join(folderPath, fileName)).filter(isFile) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Ganti nama folder</font> </h3><br>  Anda dapat menggunakan metode <code>fs.rename()</code> dan <code>fs.renameSync()</code> untuk mengganti nama folder.  Parameter pertama adalah jalur folder saat ini, yang kedua adalah yang baru: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.rename(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/roger'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> })</code> </pre> <br>  Anda dapat mengganti nama folder menggunakan metode sinkron <code>fs.renameSync()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fs.renameSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/roger'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Hapus folder</font> </h3><br>  Untuk menghapus folder, Anda dapat menggunakan metode <code>fs.rmdir()</code> atau <code>fs.rmdirSync()</code> .  Perlu dicatat bahwa menghapus folder di mana ada sesuatu adalah tugas yang sedikit lebih rumit daripada menghapus folder kosong.  Jika Anda perlu menghapus folder tersebut, gunakan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fs-extra</a> , yang sangat populer dan didukung dengan baik.  Ini adalah pengganti untuk modul <code>fs</code> , memperluas kemampuannya. <br><br>  Metode <code>remove()</code> dari paket <code>fs-extra</code> dapat menghapus folder yang sudah memiliki sesuatu. <br><br>  Anda dapat menginstal modul ini sebagai berikut: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> fs-extra</code> </pre> <br>  Berikut ini adalah contoh penggunaannya: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs-extra'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folder = <span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span> fs.remove(folder, err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Metodenya dapat digunakan dalam bentuk janji: <br><br><pre> <code class="hljs coffeescript">fs.remove(folder).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> }).<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Konstruksi async / await juga dapat diterima: <br><br><pre> <code class="hljs matlab">async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fs</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span><span class="hljs-function">   // } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">catch</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">folder</span></span></span><span class="hljs-function"> = '/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Users</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flavio</span></span></span><span class="hljs-function">' </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Modul fs</font> </h2><br>  Di atas, kita telah menemukan beberapa metode modul <code>fs</code> yang digunakan ketika bekerja dengan sistem file.  Bahkan, mengandung banyak hal yang lebih bermanfaat.  Ingatlah bahwa itu tidak perlu diinstal, untuk menggunakannya dalam program, cukup untuk menghubungkannya: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>)</code> </pre> <br>  Setelah itu, Anda akan memiliki akses ke metodenya, di antaranya kami perhatikan berikut ini, beberapa di antaranya sudah Anda ketahui: <br><br><ul><li>  <code>fs.access()</code> : memeriksa keberadaan file dan kemampuan untuk mengaksesnya berdasarkan izin. </li><li>  <code>fs.appendFile()</code> : <code>fs.appendFile()</code> data ke file.  Jika file tidak ada, itu akan dibuat. </li><li>  <code>fs.chmod()</code> : mengubah izin untuk file yang diberikan.  Metode serupa: <code>fs.lchmod()</code> , <code>fs.fchmod()</code> . </li><li>  <code>fs.chown()</code> : mengubah pemilik dan grup untuk file yang diberikan.  Metode serupa: <code>fs.fchown()</code> , <code>fs.lchown()</code> . </li><li>  <code>fs.close()</code> : menutup deskriptor file. </li><li>  <code>fs.copyFile()</code> : menyalin file. </li><li>  <code>fs.createReadStream()</code> : membuat aliran untuk membaca file. </li><li>  <code>fs.createWriteStream()</code> : membuat aliran penulisan file. </li><li>  <code>fs.link()</code> : membuat tautan keras baru ke file. </li><li>  <code>fs.mkdir()</code> : membuat direktori baru. </li><li>  <code>fs.mkdtemp()</code> : membuat direktori sementara. </li><li>  <code>fs.open()</code> : membuka file. </li><li>  <code>fs.readdir()</code> : membaca isi direktori. </li><li>  <code>fs.readFile()</code> : membaca isi file.  Metode serupa: <code>fs.read()</code> . </li><li>  <code>fs.readlink()</code> : membaca nilai tautan simbolik. </li><li>  <code>fs.realpath()</code> : menyelesaikan jalur file relatif yang dibuat menggunakan karakter <code>.</code>  dan <code>..</code> , di jalur penuh. </li><li>  <code>fs.rename()</code> : mengganti nama file atau folder. </li><li>  <code>fs.rmdir()</code> : menghapus folder. </li><li>  <code>fs.stat()</code> : mengembalikan informasi file.  Metode serupa: <code>fs.fstat()</code> , <code>fs.lstat()</code> . </li><li>  <code>fs.symlink()</code> : membuat tautan simbolis baru ke file. </li><li>  <code>fs.truncate()</code> : memotong file dengan panjang yang ditentukan.  Metode serupa: <code>fs.ftruncate()</code> . </li><li>  <code>fs.unlink()</code> : menghapus file atau tautan simbolik. </li><li>  <code>fs.unwatchFile()</code> : menonaktifkan pemantauan perubahan file. </li><li>  <code>fs.utimes()</code> : mengubah timestamp file.  Metode serupa: <code>fs.futimes()</code> . </li><li>  <code>fs.watchFile()</code> : Mengaktifkan pemantauan perubahan file.  Metode serupa: <code>fs.watch()</code> . </li><li>  <code>fs.writeFile()</code> : menulis data ke file.  Metode serupa: <code>fs.write()</code> . </li></ul><br>  Fitur menarik dari modul <code>fs</code> adalah kenyataan bahwa semua metodenya, secara default, asinkron, tetapi ada juga versi sinkronnya, yang namanya diperoleh dengan menambahkan kata <code>Sync</code> ke nama metode asinkron. <br><br>  Sebagai contoh: <br><br><ul><li> <code>fs.rename()</code> </li> <li> <code>fs.renameSync()</code> </li> <li> <code>fs.write()</code> </li> <li> <code>fs.writeSync()</code> </li> </ul><br>  Menggunakan metode sinkron secara serius mempengaruhi cara kerja program. <br><br>  Node.js 10 menyediakan dukungan eksperimental untuk API berbasis janji ini. <br><br>  Jelajahi metode <code>fs.rename()</code> .  Ini adalah versi asinkron dari metode ini menggunakan callback: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.rename(<span class="hljs-string"><span class="hljs-string">'before.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'after.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> })</code> </pre> <br>  Saat menggunakan versi sinkronnya, konstruk <code>try/catch</code> digunakan untuk menangani kesalahan: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fs.renameSync(<span class="hljs-string"><span class="hljs-string">'before.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'after.json'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// } catch (err) { console.error(err) }</span></span></code> </pre> <br>  Perbedaan utama antara opsi-opsi ini untuk menggunakan metode ini adalah bahwa dalam kasus kedua, skrip akan diblokir sampai operasi file selesai. <br><br><h2>  <font color="#3AC1EF">Modul jalur</font> </h2><br>  Modul jalur, yang juga kami bicarakan beberapa fiturnya, berisi banyak alat bermanfaat yang memungkinkan Anda berinteraksi dengan sistem file.  Seperti yang telah disebutkan, Anda tidak perlu menginstalnya, karena itu adalah bagian dari Node.js.  Untuk menggunakannya, cukup menghubungkannya: <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>)</code> </pre> <br>  Properti <code>path.sep</code> dari modul ini menyediakan karakter yang digunakan untuk memisahkan segmen path ( <code>\</code> pada Windows dan <code>/</code> di Linux dan macOS), dan properti <code>path.delimiter</code> memberikan karakter yang digunakan untuk memisahkan beberapa path ( <code>;</code> pada Windows dan <code>:</code> di Linux) dan macOS). <br><br>  Mari kita pertimbangkan dan ilustrasikan beberapa metode modul <code>path</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçpath.basename ()</font> </h3><br>  Mengembalikan fragmen terakhir dari jalan.  Dengan meneruskan parameter kedua ke metode ini, Anda dapat menghapus ekstensi file. <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) //something <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something.txt'</span></span>) //something.txt <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'.txt'</span></span>) //something</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.dirname ()</font> </h3><br>  Mengembalikan bagian jalur yang mewakili nama direktori: <br><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).dirname(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/ /test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).dirname(<span class="hljs-string"><span class="hljs-string">'/test/something/file.txt'</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/ /test</span></span><span class="hljs-regexp"><span class="hljs-regexp">/something</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.extname ()</font> </h3><br>  Mengembalikan bagian jalur yang mewakili ekstensi file: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).extname(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) // <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).extname(<span class="hljs-string"><span class="hljs-string">'/test/something/file.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.isAbsolute ()</font> </h3><br>  Mengembalikan nilai true jika path absolut: <br><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).isAbsolute(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) // <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).isAbsolute(<span class="hljs-string"><span class="hljs-string">'./test/something'</span></span>) // <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.join ()</font> </h3><br>  Menghubungkan beberapa bagian jalan: <br><br><pre> <code class="hljs pgsql">const <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'flavio'</span></span> require(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-string"><span class="hljs-string">'notes.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.normalalize ()</font> </h3><br>  Mencoba mencari jalur nyata berdasarkan jalur yang berisi karakter yang digunakan untuk membangun jalur relatif seperti <code>.</code>  , <code>..</code> dan <code>//</code> : <br><br><pre> <code class="hljs mel">require(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(<span class="hljs-string"><span class="hljs-string">'/users/flavio/..//test.txt'</span></span>) <span class="hljs-comment"><span class="hljs-comment">///users/test.txt</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.parse ()</font> </h3><br>  Mengonversi jalur ke objek yang propertinya mewakili bagian individual jalur: <br><br><ul><li>  <code>root</code> : direktori root. </li><li>  <code>dir</code> : path file mulai dari direktori root </li><li>  <code>base</code> : nama file dan ekstensi. </li><li>  <code>name</code> : <code>name</code> file. </li><li>  <code>ext</code> : ekstensi file. </li></ul><br>  Berikut ini contoh menggunakan metode ini: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).parse(<span class="hljs-string"><span class="hljs-string">'/users/test.txt'</span></span>)</code> </pre> <br>  Sebagai hasil karyanya, objek berikut diperoleh: <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">root</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, dir: <span class="hljs-string"><span class="hljs-string">'/users'</span></span>, base: <span class="hljs-string"><span class="hljs-string">'test.txt'</span></span>, ext: <span class="hljs-string"><span class="hljs-string">'.txt'</span></span>, name: <span class="hljs-string"><span class="hljs-string">'test'</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.relative ()</font> </h3><br>  Dibawa, sebagai argumen, 2 cara.  Mengembalikan jalur relatif dari jalur pertama ke yang kedua, berdasarkan direktori kerja saat ini: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).relative(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'test.txt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).relative(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/flavio/something/test.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'something/test.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.resolve ()</font> </h3><br>  Menemukan jalur absolut berdasarkan jalur relatif yang dilewatkan ke sana: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/Users/flavio/flavio.txt'</span></span>      .</code> </pre> <br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Hari ini kita melihat modul <code>path</code> dan Node.js <code>fs</code> yang digunakan untuk bekerja dengan sistem file.  Pada bagian selanjutnya dari seri ini, di mana itu berakhir, kita akan membahas <code>os</code> , <code>events</code> , modul <code>http</code> , berbicara tentang bekerja dengan stream dan dengan sistem manajemen basis data di Node.js. <br><br>  <b>Pembaca yang budiman!</b>  Paket npm apa yang Anda gunakan saat bekerja dengan sistem file di Node.js? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424969/">https://habr.com/ru/post/id424969/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424957/index.html">Menghasilkan Gambar dari Teks Menggunakan AttnGAN</a></li>
<li><a href="../id424961/index.html">MTA-STS untuk Postfix</a></li>
<li><a href="../id424963/index.html">Pendanaan Zuckerberg: Alat Bangun untuk Sains Bersama</a></li>
<li><a href="../id424965/index.html">Bereaksi Pengembangan Aplikasi Menggunakan ReasonReact</a></li>
<li><a href="../id424967/index.html">Pintasan JavaScript untuk pemula</a></li>
<li><a href="../id424971/index.html">Habrokast "Sunset Manually" # 1. Mencoba mengatur lingkungan untuk mengembangkan mainan untuk Windows</a></li>
<li><a href="../id424973/index.html">Deteksi Wajah pada Video: Raspberry Pi dan Neural Compute Stick</a></li>
<li><a href="../id424975/index.html">Kedalaman SIEM: korelasi out-of-box. Bagian 2. Skema data sebagai refleksi dari model "dunia"</a></li>
<li><a href="../id424977/index.html">Belajar dari kesalahan: mengoptimalkan aplikasi di App Store dan Google Play</a></li>
<li><a href="../id424979/index.html">Elm Nyaman dan canggung. Http, Tugas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>