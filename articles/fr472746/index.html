<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏼 ↖️ 🤳🏾 Serveur de terminal pour administrateur; Pas un seul écart SSH 💠 🥃 👞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si votre travail nécessite de conserver un grand nombre de sessions SSH sur différents serveurs, vous savez probablement comment elles se cassent faci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serveur de terminal pour administrateur; Pas un seul écart SSH</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vdsina/blog/472746/"><img src="https://habrastorage.org/webt/1v/ds/rv/1vdsrvezwkf95vto5nk7lklaplq.png"><br><br>  Si votre travail nécessite de conserver un grand nombre de sessions SSH sur différents serveurs, vous savez probablement comment elles se cassent facilement lors du passage à un autre Wi-Fi ou lorsque Internet est temporairement perdu.  Mais que se passe-t-il si je vous dis que tous ces problèmes sont résolus depuis longtemps et que vous pouvez oublier les sessions interrompues et les reconnexions constantes? <br><br>  En ouvrant le couvercle de l'ordinateur portable, toutes mes dizaines de sessions SSH sont immédiatement accessibles et dans le même état que je les ai laissées.  Cet article décrit comment configurer un serveur Terminal Server pour un administrateur système.  L'utilisation d'un tel serveur vous permet d'oublier les sessions SSH interrompues, de vous reconnecter et de saisir constamment des mots de passe. <br><br><a name="habracut"></a><br><br><h2>  Configuration du serveur </h2><br>  L'idée est simple et clairement illustrée dans l'image du titre de l'article: nous conserverons toutes les connexions SSH sur un serveur terminal spécial.  Ce serveur sera notre point d'entrée pour gérer d'autres serveurs.  Dans le même temps, les serveurs finaux n'ont pas besoin de configurer ou d'installer de logiciels supplémentaires. <br>  Presque toutes les configurations conviennent à un serveur Terminal Server, mais il est préférable d'avoir plus de RAM pour stocker le journal de la console à l'intérieur de chaque session et de pouvoir faire défiler l'historique à tout moment et voir ce que vous avez fait sur le serveur de session il y a un mois.  Habituellement, 1 à 2 Go de mémoire suffisent. <br><br><h3>  Choix de distribution </h3><br>  Dans le serveur Terminal Server, la chose la plus importante est la disponibilité, car moins nous redémarrons, plus nos sessions SSH sont actives.  Par conséquent, nous choisissons la distribution LTS (Long Term Support) la plus conservatrice, par exemple, une branche Debian ou Ubuntu stable.  Nous configurons des mises à jour automatiques (mises à niveau sans assistance) afin qu'un redémarrage soudain des programmes ne soit pas une surprise. <br><br><h3>  Configuration du serveur SSH </h3><br>  Étant donné que le serveur de terminaux ouvrira l'accès à tous nos serveurs à la fois, il sera sûr de le sécuriser.  Pour ce faire, nous interdisons l'authentification avec des mots de passe, ne laissant que l'accès avec des clés, et nous interdisons également la connexion en tant que root. <br>  Vous devez d'abord créer un nouvel utilisateur dans le système. <br><br>  <b>/ etc / ssh / sshd_config</b> <br><pre><code class="bash hljs">..... <span class="hljs-comment"><span class="hljs-comment">#    root PermitRootLogin no #   ,   ChallengeResponseAuthentication no #   ,   PAM   UsePAM no ....</span></span></code> </pre> <br>  Une telle configuration est tout à fait suffisante pour se protéger contre l'énumération de masse des mots de passe, car le serveur SSH fermera simplement la connexion lors de la tentative de connexion avec un mot de passe.  Même avec un grand nombre de connexions, elles se fermeront assez rapidement sans créer de charge importante sur le serveur.  À mon avis, avec cette configuration, il n'est pas nécessaire d'installer des fonctionnalités de sécurité supplémentaires comme fail2ban. <br><br><blockquote>  Souvent, les administrateurs débutants dans leurs manuels conseillent de changer le port SSH et d'installer une sorte de port non standard comme <b>2222</b> au lieu de <b>22</b> .  À mon avis, c'est une mauvaise pratique qui n'ajoute aucune sécurité. <br><br><ul><li>  Cela ne vous permettra pas de vous protéger contre le craquage de mot de passe, car les scanners automatiques trouveront toujours SSH sur n'importe quel port et commenceront à marteler. </li><li>  Cela gâche si plusieurs personnes administrent le système et inventent chacune leurs propres ports.  Lorsqu'il existe des dizaines de ces systèmes, vous devez rechercher le scanner sur quel port le SSH est masqué cette fois. </li><li>  Cela rompt les restrictions de sécurité intégrées dans les programmes.  Par exemple, les navigateurs Web ne se connecteront pas au port 22 si vous le spécifiez explicitement dans HTTP, mais en même temps vous connectez à un autre port non standard.  Cela peut être utilisé pour déclencher des systèmes IDS / IPS DDoS. </li></ul><br></blockquote><br><br><h2>  Tmux - une seule fenêtre pour tout gouverner </h2><br>  Tmux est un programme incroyablement pratique pour gérer des terminaux virtuels, sans lequel je ne peux tout simplement pas imaginer mon travail.  Au début, cela semble déroutant et compliqué, mais si vous vous maîtrisez et apprenez à l'utiliser, vous ne pouvez plus le refuser. <br><br>  Pour ceux qui ne savent pas ce qu'est tmux, imaginez un navigateur Web à onglets, mais au lieu de sites, il y a des sessions de console.  Vous pouvez ouvrir un nombre infini d'onglets et exécuter dans chaque onglet votre programme.  En même temps, il s'exécute sur le serveur, et vous pouvez vous en déconnecter à tout moment, tandis que tous les onglets et programmes en cours d'exécution resteront à leur place et vous pourrez y revenir. <br><br>  Installez tmux s'il n'est pas déjà installé: <br><pre> <code class="bash hljs">apt install tmux</code> </pre><br>  Dans la terminologie tmux, un ensemble de fenêtres distinct est appelé une session.  Nous n'utiliserons qu'une seule session par défaut, donc nous n'utiliserons pas du tout les noms de session.  Mais il est important de savoir qu'il peut y en avoir plusieurs si nécessaire. <br><br>  Créez une nouvelle session: <br><pre> <code class="bash hljs">tmux new</code> </pre><br>  À ce moment, nous avons créé une nouvelle session avec une fenêtre et nous y sommes immédiatement connectés.  Vous pouvez voir la barre d'état verte qui apparaît ci-dessous.  Cela ressemble à une barre à onglets dans un navigateur.  Il affichera l'onglet actuel et les messages voisins, ainsi que les messages de service. <br><img src="https://habrastorage.org/webt/ug/zp/wx/ugzpwxra7ztlaklf98cydfdltd0.png"><br>  <sup><font color="999999">La barre d'état tmux affiche les noms des fenêtres (onglets)</font></sup> <br>  À ce stade, même si nous fermons la connexion SSH et nous nous reconnectons au serveur, notre session tmux en cours d'exécution restera dans le même état, avec tous les programmes en cours d'exécution, comme si nous la minimisions.  Essayons d'exécuter le programme <b>supérieur</b> dans la session tmux et déconnectons-nous de celle-ci.  Pour plus de clarté, fermez complètement la fenêtre du terminal et reconnectez-vous au serveur. <br><br>  Après vous être reconnecté au serveur, nous nous connecterons à notre session précédemment lancée: <br><pre> <code class="bash hljs">tmux attach</code> </pre><br>  Et assurez-vous que le programme en cours d'exécution continue de fonctionner.  À ce stade, il est important de comprendre le principe principal: après le démarrage de la session tmux, il reste à travailler en arrière-plan sur le serveur, que vous y soyez connecté ou non. <br><br><blockquote>  Étant donné que la session tmux permet plusieurs connexions simultanées, cela peut être utilisé pour la collaboration de plusieurs personnes sur le serveur pour voir la même console en temps réel.  Pour ce faire, tout le monde se connecte au même serveur sous le même compte et saisit tmux attach.  Là, vous pouvez discuter, directement sur la ligne de commande.  Nous l'utilisons souvent afin de ne pas se jeter le journal de la console dans le messager, mais de travailler immédiatement sur un terminal. <br></blockquote><br><br>  Tmux peut diviser une fenêtre en plusieurs (chaque fenêtre à l'intérieur d'un onglet est appelée volet), ce qui est pratique lorsque vous devez voir deux consoles en même temps.  Par exemple, dans une fenêtre, modifiez le script et dans une autre, consultez le journal. <br><img src="https://habrastorage.org/webt/mn/sv/3j/mnsv3jc9jejmb9r2yppcmdsg7y0.gif"><br>  <sup><font color="999999">tmux vous permet de créer plusieurs fenêtres à l'intérieur d'une seule et de les redimensionner</font></sup> <br><br>  Par défaut, <b>Ctrl + b est</b> utilisé pour contrôler tmux.  Après avoir appuyé sur cette touche de raccourci de contrôle, tmux s'attend à entrer la commande principale à partir d'une seule lettre. <br><br>  Voici les commandes de base: <br>  <b>Ctrl + b + c</b> - (créer) Créer une nouvelle fenêtre (onglet) <br>  <b>Ctrl + b + &lt;chiffre&gt;</b> - Déplacer vers le numéro de tabulation N, où le chiffre est une clé de 0 à 9. La numérotation des fenêtres commence à zéro. <br>  <b>Ctrl + b + x</b> - ferme la fenêtre actuelle.  Si la dernière fenêtre est fermée, la session tmux se terminera. <br>  <b>Ctrl + b + w</b> - affiche une liste de toutes les fenêtres que vous pouvez déplacer vers le haut et vers le bas avec les boutons du curseur et sélectionnez celle souhaitée en appuyant sur entrée. <br>  <b>Ctrl + b + "</b> - diviser la fenêtre en deux horizontalement et en créer une nouvelle <br>  <b>Ctrl + b +%</b> - diviser la fenêtre verticalement et en créer une nouvelle <br>  <b>Ctrl + b +,</b> - renommer la fenêtre courante <br>  <b>Ctrl + b + bas / haut / gauche / droite</b> - se déplacer dans le volet à l'intérieur de la fenêtre <br>  <b>Ctrl + b + page haut / page bas</b> - faites défiler vers le haut <br>  <b>Ctrl + b + /</b> - recherche par historique, comme dans vim ou moins <br><br>  Ce sont tous les raccourcis clavier dont j'avais besoin pendant 10 ans d'utilisation de tmux.  En fait, il y en a beaucoup plus, mais pour commencer, il vaut mieux s'y attarder. <br><br><h2>  Config Tmux </h2><br>  Je trouve la <b>touche de</b> raccourci <b>Ctrl + b</b> inconfortable, car il faut trop appuyer sur trois touches pour une action.  Le thème des configs tmux est un domaine distinct du goût, et chaque utilisateur expérimenté a sa propre vision de la façon de l'utiliser correctement et commodément.  Il y a même des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sélections d'</a> auteurs entières <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de configurations et de thèmes</a> pour tmux. <br><br>  Pour commencer, je donnerai un exemple de ma config qui, il me semble, résout toutes les difficultés qui empêchent le développement rapide de tmux.  La configuration se trouve dans le dossier d'accueil avec le nom <b>~ / .tmux.conf</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  ctrl+b    .   macbook        set-option -g prefix ` #     &lt;`&gt;  `+a bind-key a send-prefix #       set -g base-index 1 set-option -g base-index 1 setw -g pane-base-index 1 # Lowers the delay time between the prefix key and other keys - fixes pausing in vim set-option -sg escape-time 1 #     1000 .      set -g history-limit 1000 #    # default statusbar colors set-option -g status-fg white set-option -g status-bg default # default window title colors set-window-option -g window-status-fg default set-window-option -g window-status-bg default #        #------------------ # Respawn windows when PANE IS DEAD bind-key R respawn-window #   default   local new -d -s default -n local #     irc   irssi neww -d -n irc irssi #     superserver   ssh root@superserver.com neww -d -n superserver ssh root@superserver.com #     anotherserver   ssh root@123.123.123.123 neww -d -n superserver anotherserver root@123.123.123.123</span></span></code> </pre><br><br>  Cette configuration vous permet de créer automatiquement plusieurs fenêtres au démarrage, dans lesquelles les sessions SSH démarrent immédiatement.  Dans ce cas, il n'est pas nécessaire de créer manuellement une nouvelle session avec la commande <b>tmux new</b> , il suffit de toujours saisir <b>tmux attach</b> .  Si la session n'existait pas auparavant, elle sera créée. <br><br><h2>  Autostart tmux </h2><br>  Nous voulons que lors de la connexion à un serveur de terminaux, nous entrions immédiatement dans tmux, même si le serveur a été redémarré et que la session tmux a été fermée. <br><br>  Pour ce faire, ajoutez tmux à la fin du <b>fichier ~ / .bashrc</b> .  Il est important de se rappeler qu'une telle conception ne fonctionnera qu'avec la configuration ci-dessus. <br><pre> <code class="plaintext hljs">if [ ! "$TMUX" ]; then tmux attach fi if [ "$TMUX" ]; then export TERM=screen fi</code> </pre><br><br>  Cette condition simple signifie que si nous ne sommes pas dans tmux, nous y sommes connectés. <br><br>  Ceci termine la configuration tmux sur le serveur Terminal Server.  Désormais, pour chaque nouvelle connexion SSH, nous créerons une fenêtre séparée dans tmux.  Et même si la connexion au serveur Terminal Server est perdue, toutes les connexions SSH resteront actives. <br><br><h2>  Mosh - Plus de pauses </h2><br>  Nous devons maintenant fournir une connexion continue au serveur Terminal Server, qui sera toujours actif.  Même si nous avons fermé l'ordinateur portable pendant plusieurs jours et l'avons ouvert dans un autre réseau wifi, la connexion devrait être rétablie elle-même. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mosh</a> est un module complémentaire sur un serveur OpenSSH standard, qui vous permet d'oublier les déconnexions.  Mosh se connecte à l'aide de SSH standard, après quoi un canal UDP distinct est levé, qui est instantanément restauré après une pause, même si votre adresse IP externe est modifiée. <br>  Comme nous devons maintenir une connexion constante avec le serveur de terminaux, nous n'installerons mosh que sur le serveur et sur notre ordinateur de travail.  Dans le même temps, vous n'avez pas besoin d'installer quoi que ce soit sur les serveurs distants, car les connexions avec eux vivent déjà pour toujours dans tmux. <br><br>  Installez mosh sur le serveur: <br><pre> <code class="plaintext hljs">apt install mosh</code> </pre><br><br>  Installez mosh sur notre ordinateur de travail.  Il est disponible pour tous les principaux systèmes d'exploitation, mais le client natif est uniquement pour les systèmes d'exploitation de type Unix.  La version Windows est implémentée à l'aide de Cygwin ou de l'application Chrome. <br><br>  J'utilise macOS et j'installe mosh via le gestionnaire de paquets de brassage: <br><pre> <code class="plaintext hljs">brew install mosh</code> </pre><br><br>  Dans la plupart des cas, mosh ne nécessite pas de configuration supplémentaire et fonctionne dès la sortie de l'emballage.  Il suffit d'écrire mosh au lieu de la commande ssh: <br><pre> <code class="plaintext hljs">mosh user@my-server.com</code> </pre><br><br>  Pour les configurations non standard, la commande semble un peu plus compliquée.  Par exemple, si vous devez spécifier le port et le chemin de clé: <br><br><pre> <code class="plaintext hljs">mosh --ssh="ssh -p 2222 -i /path/to/ssh.key" user@my-server.com</code> </pre><br><br>  Mosh effectue l'authentification principale en tant que client SSH standard, autorisant le port standard 22. En même temps, le serveur mosh n'écoute initialement aucun port, et à part le démon OpenSSH d'origine, aucun port n'est ouvert sur le serveur.  Après la connexion via TCP, mosh s'exécute sur le serveur dans l'espace utilisateur et ouvre un tunnel supplémentaire via UDP. <br><br><img src="https://habrastorage.org/webt/oc/l4/vf/ocl4vfgwunbbtorsi_za-jc4_xq.png"><br>  <sup><font color="999999">Organigramme du protocole Mosh</font></sup> <br><br>  Maintenant, la session mosh en cours d'exécution sur le client sera toujours restaurée lorsque Internet apparaîtra.  Sur mon ordinateur portable, je garde une session ouverte pendant des mois sans redémarrer et je n'ai pas besoin de me connecter constamment au serveur Terminal Server, cela fonctionne toujours. <br><br>  Afin de ne pas entrer à chaque fois une commande de connexion longue au serveur Terminal Server, j'ai créé un alias de la commande de connexion à partir d'une seule lettre: <br><br><pre> <code class="plaintext hljs">alias t='mosh --ssh="ssh -p 443 -i /path/to/ssh.key" user@my-server.com'</code> </pre><br><br><h2>  Conclusion </h2><br><br>  Ce schéma simple vous permet d'économiser considérablement du temps et des nerfs, de ne pas perdre le résultat du travail lorsque SSH est cassé.  Je dois constamment voir comment les administrateurs novices commencent à se connecter à leurs serveurs à chaque fois et tuent les sessions SSH collantes. <br>  Cela peut sembler déroutant à première vue, mais je vous assure qu'une fois que vous vous maîtriserez et vous y habituerez, vous commencerez à regarder avec un regret condescendant ceux qui ont encore des connexions SSH rompues. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ud/xv/wf/udxvwfcz80j3nug11rxaguqelww.png"><br></a> <br><h3>  Abonnez-vous à notre développeur Instagram </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/e5/as/-l/e5as-ltfnotkemk2dsqngygimra.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472746/">https://habr.com/ru/post/fr472746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472726/index.html">Amélioration de l'immunité au bruit Arduino</a></li>
<li><a href="../fr472730/index.html">Ivanovo! Mitap en l'honneur du 10e anniversaire de Node.js</a></li>
<li><a href="../fr472736/index.html">Webinaire ouvert "Introduction à l'automatisation des tests d'applications mobiles sur Sélénium et Appium"</a></li>
<li><a href="../fr472738/index.html">Comment mettre à niveau un projet existant d'ASP.NET MVC vers ASP.NET Core. Guide pratique</a></li>
<li><a href="../fr472744/index.html">Le MRP ne fonctionne pas ... Quelle est l'alternative?</a></li>
<li><a href="../fr472748/index.html">Navigateur sémantique ou vie sans sites</a></li>
<li><a href="../fr472750/index.html">OK, ai-je vraiment besoin de Kubernetes?</a></li>
<li><a href="../fr472752/index.html">CSE: Kubernetes pour n'importe qui dans vCloud</a></li>
<li><a href="../fr472754/index.html">Comment parler anglais en un mois. 9 étapes simples et éprouvées</a></li>
<li><a href="../fr472758/index.html">Proposition: essayer - fonction intégrée de vérification des erreurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>