<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🎨 👩‍💼 👩🏽‍🍳 Effektive Zahlengenerierung in einem bestimmten Intervall 😌 👩‍✈️ 😛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die überwiegende Mehrheit meiner Beiträge zur Zufallszahlengenerierung befasste sich hauptsächlich mit den Eigenschaften verschiedener Generierungssch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Effektive Zahlengenerierung in einem bestimmten Intervall</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg" alt="Bild"></div><br>  Die überwiegende Mehrheit meiner Beiträge zur Zufallszahlengenerierung befasste sich hauptsächlich mit den Eigenschaften verschiedener Generierungsschemata.  Dies kann sich als unerwartet herausstellen, aber die Leistung des Randomisierungsalgorithmus hängt möglicherweise nicht vom gewählten Generierungsschema ab, sondern von anderen Faktoren.  In diesem Beitrag (der mich von einem ausgezeichneten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von Daniel Lemyr</a> inspiriert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hat</a> ) werden wir die Hauptgründe für den Rückgang der Leistung bei der Erzeugung von Zufallszahlen untersuchen, die häufig die Leistung der PRN-Engine überwiegen. <br><br>  Stellen Sie sich diese Situation vor: <br><br>  Als Hausaufgabe implementieren Juan und Sasha denselben zufälligen Algorithmus in C ++, der auf demselben Universitätscomputer und mit einem Datensatz ausgeführt wird.  Ihr Code ist nahezu identisch und unterscheidet sich nur in der Erzeugung von Zufallszahlen.  Juan hat es eilig für seinen Musikunterricht, also hat er sich einfach für den Wirbelwind von Mersenne entschieden.  Sasha hingegen verbrachte einige zusätzliche Stunden mit Nachforschungen.  Sasha führte Benchmarks für mehrere der schnellsten PRNGs durch, die er kürzlich von sozialen Netzwerken gelernt hatte, und wählte die schnellsten aus.  Während des Treffens war Sasha ungeduldig zu prahlen und fragte Juan: "Welches PRNG-System haben Sie verwendet?" <br><br>  "Ich persönlich habe gerade den Mersenne-Wirbel genommen - er ist in die Sprache eingebaut und scheint ziemlich gut zu funktionieren." <br><br>  "Ha!" Antwortete Sasha.  „Ich habe <code>jsf32</code> .  Es ist viel schneller als der alte und langsame Mersenne-Wirbelwind!  Mein Programm läuft in 3 Minuten 15 Sekunden! ” <br><br>  "Hmm, nicht schlecht, aber meiner schafft es in weniger als einer Minute", sagt Juan und zuckt die Achseln.  „Na dann muss ich zum Konzert gehen.  Kommst du mit mir? " <br><br>  "Nein", antwortet Sasha.  "Ich ... äh ... muss meinen Code noch einmal ansehen." <br><br>  Diese unangenehme fiktive Situation ist <em>nicht</em> besonders fiktiv;  es basiert auf realen Ergebnissen.  Wenn Ihr zufälliger Algorithmus nicht so schnell läuft, wie wir es möchten, und der Engpass in der Erzeugung von Zufallszahlen zu liegen scheint, liegt das Problem seltsamerweise möglicherweise nicht im Zufallszahlengenerator! <br><a name="habracut"></a><br><h3>  Einführung: Zufallszahlen in der Praxis </h3><br>  Die meisten modernen Zufallszahlengeneratoren hoher Qualität erzeugen Maschinenwörter, die mit Zufallsbits gefüllt sind, dh sie erzeugen normalerweise Zahlen im Intervall [0..2 <sup>32</sup> ) oder [0..2 <sup>64</sup> ).  In vielen Fällen benötigen Benutzer jedoch Zahlen in einem bestimmten Intervall. Um beispielsweise einen Würfel zu werfen oder eine zufällige Spielkarte auszuwählen, werden Zahlen in kleinen konstanten Intervallen benötigt.  Viele Algorithmen, von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mischen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reservoir-Sampling</a> bis hin zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">randomisierten binären Suchbäumen,</a> erfordern jedoch Zahlen aus anderen Intervallen. <br><br><h3>  Methoden </h3><br>  Wir werden uns viele verschiedene Methoden ansehen.  Um die Diskussion zu vereinfachen, werden anstelle von Zahlen im Intervall [ <em>i</em> .. <em>j</em> ) oder [ <em>i</em> .. <em>j</em> ] Zahlen im Intervall [0 .. <em>k</em> ) generiert.  Mit einem solchen Schema können wir beispielsweise Zahlen im Intervall [ <em>i</em> .. <em>j</em> ) erzeugen, indem wir <em>k</em> = <em>j</em> - <em>i setzen</em> , eine Zahl im Intervall [0 .. <em>k</em> ) erzeugen und dann <em>i</em> hinzufügen. <br><br><h4>  Integrierte C ++ - Tools </h4><br>  Viele Sprachen verfügen über integrierte Tools zum Abrufen einer Zufallszahl in einem bestimmten Intervall.  Um beispielsweise eine Karte mit 52 Karten in Skriptsprachen wie Perl und Python aus einem Deck zu entfernen, können Sie <code>int(rand(52))</code> bzw. <code>random.randint(0,52)</code> schreiben.  [Anmerkung  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">CryptoPirate-</a> Benutzer: <i>Es scheint mir hier ein Fehler zu sein, in Python generiert Randint (a, b) Zahlen von a nach b, einschließlich b.</i>  <i>Und da sich 52 Karten im Deck befinden und die erste "0" ist, sollte sie zufällig sein. Randint (0,51)</i> .] In C ++ können wir <code>uniform_int_distribution</code> gleiche <code>uniform_int_distribution</code> . <br><br>  C ++ - Code zur Implementierung dieses Ansatzes ist einfach: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt; dist(<span class="hljs-number"><span class="hljs-number">0</span></span>, range<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dist(rng); }</code> </pre> <br>  Normalerweise wird eine der unten beschriebenen Techniken in den integrierten Tools verwendet, aber die meisten Benutzer verwenden diese Tools einfach, ohne darüber nachzudenken, was „unter der Haube“ passiert, und glauben, dass diese Tools korrekt entworfen und recht effektiv sind.  In C ++ sind integrierte Tools komplexer, da sie mit ziemlich willkürlichen Generierungs-Engines arbeiten können sollten - ein Generator, der Werte im Bereich von -3 bis 17 erzeugt, kann durchaus gültig sein und mit <code>std::uniform_int_distribution</code> , um Zahlen in jedem Intervall zu erstellen. zum Beispiel [0..1000].  Das heißt, die integrierten C ++ - Tools sind für die meisten Fälle, in denen sie verwendet werden, zu kompliziert. <br><br><h4>  Der klassische Rest der Division (schief) </h4><br>  Gehen wir von einem stark vereinfachten zu einem zu vereinfachten Ansatz über. <br><br>  Als ich Programmieren studierte, generierten wir mit dem Restoperator Zahlen in dem Intervall (zum Beispiel, um eine Karte in einem Kartenspiel mit 52 Karten auszuwählen).  Um die Zahl im Intervall [0..52) zu erhalten, haben wir <code>rand() % 52</code> . <br><br>  In C ++ kann dieser Ansatz wie folgt implementiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rng() % range; }</code> </pre> <br>  Trotz der Einfachheit dieses Ansatzes zeigt es den Grund, warum das Abrufen von Zahlen im richtigen Intervall normalerweise eine langsame Aufgabe ist - es erfordert eine Division (um den vom <code>%</code> -Operator erhaltenen Rest zu berechnen).  Das Teilen ist normalerweise mindestens eine Größenordnung langsamer als andere arithmetische Operationen, so dass eine einzelne arithmetische Operation länger dauert als alle Arbeiten, die von einem schnellen PRNG ausgeführt werden. <br><br>  Neben der geringen Geschwindigkeit ist es aber auch <em>schief</em> .  Um zu verstehen, warum <code>rand() % 52</code> verzerrte Zahlen zurückgibt, nehmen wir an, dass <code>rand()</code> Zahlen im Intervall [0..2 <sup>32</sup> ) erstellt, und beachten Sie, dass 52 2 <sup>32 nicht</sup> vollständig teilt, sondern 82 595 524 mal mit dem Rest teilt 48. Das heißt, wenn wir <code>rand() % 52</code> , haben wir 82 595 525 Möglichkeiten, die ersten 48 Karten aus dem Stapel auszuwählen, und nur 82 595 524 Möglichkeiten, die letzten vier Karten auszuwählen.  Mit anderen Worten, es gibt einen Versatz von 0,00000121% gegenüber diesen letzten vier Karten (vielleicht sind dies Könige!).  Als ich Student war und Hausaufgaben über das Werfen von Würfeln oder das Zeichnen von Karten schrieb, kümmerte sich normalerweise niemand um so kleine Verzerrungen, aber mit zunehmendem Intervall wächst die Verzerrung linear.  Bei einem 32-Bit-PRNG hat ein begrenztes Intervall von weniger als 2 <sup>24</sup> einen Versatz von weniger als 0,5%, aber über 2 <sup>31 einen</sup> Versatz von 50% - einige Zahlen werden doppelt so oft zurückgegeben wie andere. <br><br>  In diesem Artikel werden wir hauptsächlich Techniken betrachten, die Strategien verwenden, um einen systematischen Fehler zu beseitigen. Es ist jedoch wahrscheinlich erwähnenswert, dass bei einem 64-Bit-PRNG der Versatzwert in normalen Anwendungen wahrscheinlich vernachlässigbar ist. <br><br>  Ein weiteres Problem kann sein, dass einige Generatoren schwache niedrige Bits haben.  Beispielsweise haben die GPRS-Familien Xoroshiro + und Xoshiro + niedrige Bits, die statistische Tests nicht bestehen.  Wenn wir <code>% 52</code> ausführen (weil 52 gerade ist), übergeben wir das niederwertige Bit direkt an den Ausgang. <br><br><h4>  Gleitkommazahlen multiplizieren (schief) </h4><br>  Eine andere übliche Technik ist die Verwendung eines PRNG, das Gleitkommazahlen im Intervall [0..1) mit der anschließenden Umwandlung dieser Zahlen in das gewünschte Intervall erzeugt.  Dieser Ansatz wird in Perl verwendet. Es wird <a href="">empfohlen,</a> <code>int(rand(10))</code> zu verwenden, um eine Ganzzahl im Intervall [0..10) zu generieren, indem eine Gleitkommazahl generiert und anschließend abgerundet wird. <br><br>  In C ++ ist dieser Ansatz folgendermaßen geschrieben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rng_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> zeroone = <span class="hljs-number"><span class="hljs-number">0x1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>p<span class="hljs-number"><span class="hljs-number">-32</span></span> * rng(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range * zeroone; }</code> </pre> <br>  (Beachten Sie, dass <code>0x1.0p-32</code> eine binäre Gleitkommakonstante für 2 <sup>-32 ist</sup> , mit der wir eine zufällige Ganzzahl im Intervall [0..2 <sup>32</sup> konvertieren), um sie im Einheitsintervall zu verdoppeln.  Stattdessen können wir eine solche Konvertierung mit <code>ldexp(rng(), -32)</code> , aber als ich diesen Ansatz <code>ldexp(rng(), -32)</code> , stellte sich heraus, dass er viel langsamer ist.) <br><br>  Dieser Ansatz ist genauso verzerrt wie der klassische Rest der Teilung, aber die Abweichung erscheint anders.  Wenn wir beispielsweise Zahlen im Intervall [0..52] auswählen würden, würden die Zahlen 0, 13, 26 und 39 einmal seltener vorkommen als andere. <br><br>  Diese Version ist bei Verallgemeinerung auf 64 Bit noch unangenehmer, da sie einen Gleitkommatyp erfordert, dessen Mantisse mindestens 64 Bit beträgt.  Auf x86-Computern mit Linux und macOS können wir <code>long double</code> , um die präziseren x86-Gleitkommazahlen mit einer 64-Bit-Mantisse zu nutzen. <code>long double</code> nicht universell auf alle Systeme portiert. In einigen Systemen entspricht <code>long double</code> <code>double</code> . <br><br>  Es gibt eine gute Seite - dieser Ansatz ist schneller als Restlösungen für PRNGs mit schwachen niedrigen Bits. <br><br><h4>  Ganzzahlige Multiplikation (schief) </h4><br>  Die Multiplikationsmethode kann eher an feste als an Gleitkomma-Arithmetik angepasst werden.  Tatsächlich multiplizieren wir ständig mit 2 <sup>32</sup> , <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br>  Es scheint, dass diese Version 64-Bit-Arithmetik erfordert. Auf x86-Prozessoren kompiliert ein guter Compiler diesen Code in einen 32-Bit- <code>mult</code> Befehl (der uns zwei 32-Bit-Ausgabewerte gibt, von denen einer der Rückgabewert ist).  Es ist zu erwarten, dass diese Version schnell ist, sie ist jedoch genau wie die Methode zum Multiplizieren von Gleitkommazahlen verzerrt. <br><br><h4>  Drop Division (kein Versatz) </h4><br>  Wir können das Gleitkomma-Multiplikationsschema in ein dividationsbasiertes Schema umwandeln.  Anstatt <code>x * range / 2**32</code> multiplizieren <code>x * range / 2**32</code> berechnen wir <code>x / (2**32 / range)</code> .  Da wir mit Ganzzahlarithmetik arbeiten, wird die Rundung in dieser Version anders ausgeführt und generiert manchmal Werte außerhalb des gewünschten Intervalls.  Wenn wir diese Werte verwerfen (z. B. entfernen und neue Werte generieren), erhalten wir als Ergebnis eine Technik ohne Verzerrungen. <br><br>  Wenn Sie beispielsweise eine Karte mit einem 32-Bit-PRNG herausziehen, können Sie eine 32-Bit-Zahl generieren und durch 2 32/52 = 82 595 524 teilen, um eine Karte auszuwählen.  Diese Technik funktioniert, wenn der Zufallswert aus dem 32-Bit-PRNG kleiner als 52 × 82595524 = 2 32/32 - 48 ist. Wenn der Zufallswert aus dem PRNR einer der letzten 48 Werte des oberen Teils des Generatorintervalls ist, müssen Sie ihn verwerfen und nach einem anderen suchen. <br><br>  Unser Code für diese Version verwendet einen Trick, bei dem 2 <sup>32</sup> durch den <code>range</code> ohne 64-Bit-Mathematik zu verwenden.  Für die direkte Berechnung von <code>2**32 / range</code> wir die Zahl 2 <sup>32 darstellen</sup> , die zu groß ist (um eins!), Um als 32-Bit-Ganzzahl dargestellt zu werden.  Stattdessen berücksichtigen wir, dass der unäre Negationsoperationsbereich für vorzeichenlose Ganzzahlen einen positiven Wert von 2 <sup>32</sup> berechnet - <code>range</code> ;  Wenn wir diesen Wert durch den <code>range</code> teilen, erhalten wir eine Antwort von weniger als <code>2**32 / range</code> . <br><br>  Daher sieht der C ++ - Code zum Generieren von Zahlen mithilfe von Division und Drop folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates divisor = 2**32 / range uint32_t divisor = ((-range) / range) + 1; if (divisor == 0) // overflow, it's really 2**32 return 0; for (;;) { uint32_t val = rng() / divisor; if (val &lt; range) return val; } }</span></span></code> </pre> <br>  Natürlich erfordert dieser Ansatz zwei langsame Operationen basierend auf der Division, die normalerweise langsamer sind als andere arithmetische Operationen, daher sollten Sie nicht erwarten, dass sie schnell sind. <br><br><h4>  Der Rest der Division (doppelt) ohne Verzerrungen - OpenBSD-Technik </h4><br>  Wir können auch den Drop-Ansatz verwenden, um den Versatz bei der klassischen Teilungsrestmethode zu beseitigen.  Im Beispiel mit Spielkarten müssen wir wieder 48 Werte fallen lassen.  In dieser Version werden die <em>ersten</em> 48 Werte (äquivalent) verworfen, anstatt die <em>letzten</em> 48 Werte zu verwerfen. <br><br>  Hier ist die Implementierung dieses Ansatzes in C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br>  Diese Technik entfernt den Versatz, erfordert jedoch zwei zeitaufwändige Teilungsvorgänge mit dem Rest jedes Ausgabewerts (und möglicherweise benötigen Sie einen internen Generator, um mehrere Zahlen zu erstellen).  Daher ist zu erwarten, dass die Methode ungefähr zweimal langsamer ist als der klassische Skew-Ansatz. <br><br>  <a href=""><code> arc4random_uniform</code> OpenBSD- <code> arc4random_uniform</code></a> (der auch unter OS X und iOS verwendet wird) verwendet diese Strategie. <br><br><h4>  Rest der Teilung (einzeln) ohne Versatz - Java-Methodik </h4><br>  Java verwendet einen anderen Ansatz zum Generieren einer Zahl in einem Intervall, in dem nur eine Restdivisionsoperation verwendet wird, mit Ausnahme relativ seltener Fälle, in denen das Ergebnis verworfen wird.  Code: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rng_t&amp; rng, uint32_t range)</span></span></span><span class="hljs-function"> </span></span>{ uint32_t x, r; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng(); r = x % range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x - r &gt; (-range)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br>  Um zu verstehen, warum diese Option funktioniert, müssen Sie ein wenig nachdenken.  Im Gegensatz zur vorherigen Version, die auf Residuen basiert und die Verzerrung beseitigt, indem ein Teil der niedrigsten Werte aus der internen Generierungsmaschine entfernt wird, filtert diese Version die Werte aus dem oberen Teil des Motorintervalls. <br><br><h4>  Skew Integer Multiplication - Lemira-Methode </h4><br>  Ähnlich wie wir die Vorspannung aus der Restdivisionsmethode entfernt haben, können wir die Vorspannung aus der Ganzzahlmultiplikationstechnik entfernen.  Diese Technik wurde von Lemyr erfunden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><h4>  Drop Bitmaske (kein Versatz) - Apple-Technik </h4><br>  Bei unserem letzten Ansatz werden Divisions- und Restvorgänge vollständig eliminiert.  Stattdessen wird eine einfache Maskierungsoperation verwendet, um eine Zufallszahl im Intervall [0..2 <sup><em>k</em></sup> ) zu erhalten, wobei <em>k</em> der kleinste Wert ist, so dass 2 <sup><em>k</em></sup> größer als das Intervall ist.  Wenn der Wert für unser Intervall zu groß ist, verwerfen wir ihn und versuchen, einen anderen zu erhalten.  Der Code wird unten angezeigt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = ~<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); --range; mask &gt;&gt;= __builtin_clz(range|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng() &amp; mask; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt; range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br>  Dieser Ansatz wurde von Apple übernommen, als (in der Version macOS Sierra) <a href="">eine eigene Überarbeitung</a> des <code>arc4random_uniform</code> Codes durchgeführt wurde. <br><br><h3>  Benchmarking grundlegender Techniken </h3><br>  Jetzt haben wir mehrere Ansätze, die bewertet werden können.  Wenn wir uns Sorgen über die Kosten eines einzelnen Geschäftsbereichs machen, wird das Benchmarking leider nicht trivial.  Kein Benchmark kann alle Faktoren berücksichtigen, die den Anwendungsbereich beeinflussen, und es gibt keine Garantie dafür, dass die beste Option für Ihre Anwendung mit Sicherheit die beste für meine ist. <br><br>  Wir verwenden drei Benchmarks und testen die Techniken mit vielen verschiedenen PRNGs. <br><br><h4>  Benchmark Large-Shuffle </h4><br>  Der wahrscheinlich offensichtlichste Maßstab ist das Mischen.  In diesem Benchmark simulieren wir das Mischen in großem Maßstab.  Um ein Array der Größe <em>N</em> zu sortieren <em>,</em> müssen wir Zahlen in den Intervallen [0 .. <em>N</em> ), [0 .. ( <em>N</em> -1)), ..., [0..1) generieren.  In diesem Benchmark nehmen wir an, dass <em>N</em> die maximal mögliche Zahl ist (für <code>uint32_t</code> es 2 <sup>32</sup> -1).  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; }</code> </pre> <br>  Beachten Sie, dass wir jede Zahl „verwenden“ und zur <code>sum</code> addieren (damit sie nicht durch Optimierung weggeworfen wird), aber keine Mischung durchführen, um uns auf die Erzeugung von Zahlen zu konzentrieren. <br><br>  Zum Testen der 64-Bit-Generierung haben wir einen ähnlichen Test, aber es ist unpraktisch, einen Test durchzuführen, der dem Mischen eines Arrays mit einer Größe von 2 <sup>64</sup> - 1 entspricht (da es viele tausend Jahre dauern wird, bis dieser größere Benchmark abgeschlossen ist).  Stattdessen kreuzen wir das gesamte 64-Bit-Intervall, generieren jedoch die gleiche Anzahl von Ausgabewerten wie im 32-Bit-Test.  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bound = (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(i)&lt;&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>) | i; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bval = bounded_rand(rng, bound ); assert(bval &lt; bound); sum += bval; }</code> </pre> <br><h5>  Mersenne-Wirbelergebnisse </h5><br>  Die unten gezeigten Ergebnisse zeigen die Leistung dieses Benchmarks für jede der Methoden, die wir bei Verwendung des Mersenne-Wirbels und beim Testen des 32-Bit-Codes (unter Verwendung von <code>std::mt19937</code> aus <code>libstdc++</code> ) und eines ähnlichen 64-Bit-Codes (unter Verwendung von <code>std:mt19937_64</code> aus <code>libstdc++</code> )  Das Ergebnis ist das geometrische Mittel von 15 Läufen mit unterschiedlichen Startwerten, das dann normalisiert wird, so dass die klassische Teilungsrestmethode eine einzige Laufzeit hat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/3eb/53f/b9f3eb53f894a14ac2698f44090b23a6.svg"></div><br>  Es scheint, dass wir klare Antworten zur Leistung haben - es scheint, dass Sie Techniken für ihre Perfektion entwickeln und sich fragen können, woran <code>libstdc++</code> Entwickler gedacht haben, als sie eine so schreckliche Implementierung für 32-Bit-Zahlen geschrieben haben.  Wie so oft beim Benchmarking ist die Situation jedoch komplizierter, als es aus diesen Ergebnissen hervorgeht.  Erstens besteht das Risiko, dass die Ergebnisse spezifisch für den Mersenne-Wirbel sind, sodass wir die vielen getesteten PRNGs erweitern werden.  Zweitens kann es ein subtiles Problem mit dem Benchmark selbst geben.  Lassen Sie uns zuerst die erste Frage behandeln. <br><br><h5>  Ergebnisse verschiedener PRNGs </h5><br>  Wir werden 32-Bit- <code>arc4_rand32</code> mit <code>arc4_rand32</code> , <code>chacha8r</code> , <code>gjrand32</code> , <code>jsf32</code> , <code>mt19937</code> , <code>pcg32</code> , <code>pcg32_fast</code> , <code>sfc32</code> , <code>splitmix32</code> , <code>xoroshiro64+</code> , <code>xorshift*64/32</code> <code>xoshiro128+</code> , <code>xoshiro128+</code> und <code>xoshiro128**</code> und 64-Bit- <code>gjrand64</code> <code>xoshiro128**</code> <code>jsf64</code> , <code>mcg128</code> , <code>mcg128_fast</code> , <code>mt19937_64</code> , <code>pcg64</code> , <code>pcg64_fast</code> , <code>sfc64</code> , <code>splitmix64</code> , <code>xoroshiro128+</code> , <code>xorshift*128/64</code> <code>xoshiro256+</code> , <code>xoshiro256+</code> und <code>xoshiro256*</code> .  Diese Kits geben uns einige langsame PRNs und viele sehr schnelle. <br><br>  Hier sind die Ergebnisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2dc/8c8/f1a/2dc8c8f1af9aa517a92260e7cbd3a73e.svg"></div><br>  Wir können die Hauptunterschiede zu den Ergebnissen mit dem Mersenne-Wirbel sehen.  Schnellere PRNGs verschieben das Gleichgewicht in Richtung des Begrenzungscodes, und daher wird der Unterschied zwischen den verschiedenen Ansätzen stärker, insbesondere im Fall von 64-Bit-PRNRs.  Mit einer größeren <code>libstc++</code> von <code>libstc++</code> scheint <code>libstc++</code> Implementierung nicht mehr so ​​schrecklich zu sein. <br><br><h5>  Schlussfolgerungen </h5><br>  In dieser Benchmark gewinnt der Ansatz, der auf Multiplikation mit Bias basiert, deutlich an Geschwindigkeit.  Es gibt viele Situationen, in denen die Grenzen im Verhältnis zur Größe des PRNG klein sind und die Leistung absolut kritisch ist.  In solchen Situationen ist es unwahrscheinlich, dass eine leichte Abweichung spürbare Auswirkungen hat, die PRNG-Geschwindigkeit jedoch.  Ein solches Beispiel ist Quicksort mit einem zufälligen Referenzpunkt.  Von den verzerrten Methoden sieht die Bitmaskentechnik vielversprechend aus. <br><br>  Bevor wir jedoch ernsthafte Schlussfolgerungen ziehen, müssen wir auf das große Problem dieses Benchmarks hinweisen - die meiste Zeit wird an sehr hohen Grenzen verbracht, was höchstwahrscheinlich großen Intervallen eine übermäßige Bedeutung beimisst.  Deshalb müssen wir zum zweiten Benchmark gehen. <br><br><h4>  Benchmark Small-Shuffle </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Benchmark ähnelt dem vorherigen, führt jedoch viel weniger „Array-Mixing“ (mehrere) durch. </font></font> Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mersenne-Wirbelergebnisse </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/d3b/4bd/6c5d3b4bdb5f2e45cd805a051d79ab9a.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ergebnisse verschiedener PRNGs </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/9ae/8c0/45a9ae8c040cb4d297fe82f00fa06e3c.svg"></div><br><h5>  Schlussfolgerungen </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Benchmark vermeidet eine zu starke Betonung großer Grenzen und spiegelt die realen Anwendungsfälle genauer wider, verwirft jedoch jetzt große Grenzen vollständig. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark für alle Intervalle </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Benchmark zielt darauf ab, die Nachteile der beiden vorherigen zu vermeiden. </font><font style="vertical-align: inherit;">Er führt Tests bei jeder Größe der Zweierpotenz durch, so dass jede Größe vorhanden ist, aber sein Einfluss wird nicht überschätzt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bit = <span class="hljs-number"><span class="hljs-number">1</span></span>; bit != <span class="hljs-number"><span class="hljs-number">0</span></span>; bit &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x1000000</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bound = bit | (i &amp; (bit - <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, bound); assert(bval &lt; bound); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mersenne-Wirbelergebnisse </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/65c/447/f3465c447f9b19b430bb43533a655c2f.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ergebnisse verschiedener PRNGs </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/c58/2a2/64bc582a2fde24fd0faedbeaabb9f64c.svg"></div><br><h5>  Schlussfolgerungen </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele unserer Ergebnisse bleiben unverändert. </font><font style="vertical-align: inherit;">Die Skew-Methode ist schnell, wenn wir den Fehler ertragen können, und das Bitmaskenschema scheint eine gute gemittelte Wahl zu sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir könnten dies beenden, wenn wir nicht zurückkehren, unseren Code kritisch betrachten und Änderungen daran vornehmen möchten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbesserungen vornehmen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Punkt erforderten alle Methoden zur Beseitigung von Versatz die Verwendung einer zusätzlichen Teilungsrestoperation, weshalb sie viel langsamer als Versatzmethoden durchgeführt werden. </font><font style="vertical-align: inherit;">Es wäre hilfreich, wenn wir diesen Vorteil reduzieren könnten.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnellerer Schwellenwert-Drop </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einige unserer Algorithmen haben Code, der einen Schwellenwert verwendet, zum Beispiel: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Anzahl im Vergleich zum PRNG-Ausgabeintervall klein ist, ist sie meistens </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viel größer als der</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schwellenwert. </font><font style="vertical-align: inherit;">Das heißt, wenn wir eine vorläufige Schätzung des Schwellenwerts hinzufügen können, die etwas höher sein kann, sparen wir den teuren Vorgang, den Rest der Division zu übernehmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der folgende Code behandelt diese Aufgabe:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> r = rng(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r &lt; t) r = rng(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r % range; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Änderung kann sowohl auf "Double Mod ohne Verzerrungen" (siehe oben) als auch auf "Integer Multiplication ohne Verzerrungen" angewendet werden. </font><font style="vertical-align: inherit;">Die Idee wurde von Lemir erfunden, der sie auf die zweite Methode anwendete (aber nicht auf die erste).</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Large-Shuffle-Benchmark-Ergebnisse </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Optimierung führt zu einer signifikanten Verbesserung der Ergebnisse des 64-Bit-Benchmarks (bei dem der Mod noch langsamer ist), verschlechtert jedoch die Leistung im 32-Bit-Benchmark geringfügig. </font><font style="vertical-align: inherit;">Trotz der Verbesserungen gewinnt die Bitmaskenmethode immer noch.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb4/61d/b52/bb461db52be4a7d983dd7f97844179c0.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Small-Shuffle-Benchmark-Ergebnisse </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits beschleunigt diese Änderung den Small-Shuffle-Benchmark sowohl für die Methode der ganzzahligen Multiplikation als auch für die Methode des doppelten Restes der Division erheblich. </font><font style="vertical-align: inherit;">In beiden Fällen verschiebt sich ihre Leistung ohne Verzerrungen näher an die Ergebnisse der Optionen. </font><font style="vertical-align: inherit;">Die Leistung der Doppelrestmethode (OpenBSD) entspricht jetzt fast der Leistung der Einzelrestmethode (Java).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/2bd/fe2/f072bdfe2660cf0f8789b124a8f02646.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark-Ergebnisse für alle Intervalle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir sehen eine ähnliche Verbesserung des Benchmarks für alle Intervalle. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/219/b1d/add/219b1daddfa6a55a2cb485b3ae774016.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es sieht so aus, als könnten wir einen neuen universellen Gewinner bekannt geben: eine optimierte Methode zum Multiplizieren von Lemire-Ganzzahlen ohne Verzerrung. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Division Restoptimierung </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalerweise </font></font><code>a % b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfordert </font><font style="vertical-align: inherit;">eine Berechnung </font><font style="vertical-align: inherit;">eine Division, aber in Situationen, in denen das </font></font><code>a &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis einfach ist </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und keine Division erforderlich ist. </font><font style="vertical-align: inherit;">Und wenn </font></font><code>a/2 &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ist das Ergebnis einfach </font></font><code>a - b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher statt zu rechnen</font></font><br><br><pre> <code class="cpp hljs">a %= b;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir können erfüllen </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) { a -= b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) a %= b; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Kosten für die Teilung sind so hoch, dass eine Erhöhung der Kosten für diesen komplexeren Code sich durch Zeitersparnis aufgrund fehlender Teilung rechtfertigen kann. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Large-Shuffle-Benchmark-Ergebnisse </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Hinzufügen dieser Optimierung werden die Ergebnisse des Large-Shuffle-Benchmarks erheblich verbessert. </font><font style="vertical-align: inherit;">Dies macht sich wiederum im 64-Bit-Code bemerkbar, bei dem die Übernahme des Restbetrags teurer ist. </font><font style="vertical-align: inherit;">Die Doppelrestmethode (OpenBSD-Stil) zeigt Versionen mit Optimierungen für nur eine Restoperation und für beide.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e1a/669/c56e1a669836477e46f870bd1bc7a6c9.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In diesem Benchmark ist die Bitmaske immer noch der Gewinner, aber die Grenze zwischen ihr und Lemiras Ansatz hat sich erheblich verengt. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Small-Shuffle-Benchmark-Ergebnisse </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hinzufügen dieser Optimierung erhöht nicht die Leistung des Small-Shuffle-Benchmarks, sodass die Frage nur bleibt, ob dadurch erhebliche Kosten entstehen. </font><font style="vertical-align: inherit;">In einigen Fällen nein, in anderen steigen die Kosten leicht an.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/4db/b65/6fa4dbb65b9a3f6c6f9e8ba4f7b455db.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark-Ergebnisse für alle Intervalle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im Benchmark für alle Intervalle sind die Änderungen ebenfalls gering. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/ae7/758/e0eae77583cc457a9e923540ad954257.svg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bonus: PRSP-Vergleichsergebnisse </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Hauptgrund für die Verwendung vieler PRNGs zum Testen von Nummernschemata in Intervallen bestand darin, eine versehentliche Verzerrung der Ergebnisse aufgrund der Besonderheiten des Betriebs einzelner PRNG-Schemata zu vermeiden. </font><font style="vertical-align: inherit;">Wir können jedoch dieselben Ergebnisse interner Tests verwenden, um die Generierungsschemata selbst zu vergleichen.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG mit 32-Bit-Ausgabe </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die folgende Grafik zeigt die Leistung verschiedener 32-Bit-Generierungsschemata, gemittelt für alle Methoden und fünfzehn Läufe, normalisiert auf die Leistung des 32-Bit-Mersenne-Wirbels: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einerseits bin ich froh zu sehen, dass es </font></font><code>pcg32_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirklich schnell ist - es wurde nur von einer kleinen Version von Xoroshiro besiegt (die keine statistischen Tests besteht). </font><font style="vertical-align: inherit;">Dies zeigt aber auch, warum ich mich wegen der Leistung moderner Hochleistungs-Universal-PRSPs selten aufrege - der Unterschied zwischen den verschiedenen Methoden ist sehr unbedeutend. </font><font style="vertical-align: inherit;">Insbesondere die Leistung der schnellsten vier Schaltkreise unterscheidet sich um weniger als 5%, und ich glaube, dass dies einfach durch „Rauschen“ verursacht wird.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG mit der Ausgabe von 64-Bit-Zahlen </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grafik zeigt die Leistung verschiedener 64-Bit-Generierungsschemata, gemittelt unter allen Techniken und fünfzehn Läufen, normalisiert auf die Leistung des 32-Bit-Mersenne-Wirbels. Es mag seltsam erscheinen, dass die Normalisierung mit dem 32-Bit-Mersenne-Wirbel durchgeführt wird, aber dies ermöglicht es uns, die zusätzlichen Kosten für die Verwendung der 64-Bit-Generierung in Fällen zu sehen, in denen die 32-Bit-Generierung ausreichend ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/16c/b24/92816cb249e7f76c4ed4e11c65f67475.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Ergebnisse bestätigen, dass es </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unglaublich schnell ist, aber die letzten vier Techniken unterscheiden sich wiederum nur um etwa 5%, sodass es schwierig ist, aus den schnellsten Methoden zu wählen. </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>pcg64_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">müssen langsamer sein </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da ihre Basisgeneratoren lineare kongruente 128-Bit-Generatoren (LCG) und multiplikative kongruente 128-Bit-Generatoren (MCG, MCG) sind. Trotz der Tatsache, dass sie nicht die schnellsten Techniken in diesem Satz sind, sind sie immer </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noch 20% schneller als der 64-Bit-Mersenne-Wirbel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber was vielleicht noch wichtiger ist, diese Ergebnisse zeigen auch, dass ein 64-Bit-PRNG normalerweise langsamer ist als ein 32-Bit-PRNG, wenn Sie keine 64-Bit-Ausgabe benötigen.</font></font><br><br><h3>  Schlussfolgerungen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An unseren Benchmarks können wir erkennen, dass der Übergang von standardmäßig verwendeten PRNGs (z. B. dem 32-Bit-Mersenne-Wirbel) zu schnelleren PRNPs die Ausführungszeit von Benchmarks um 45% reduzierte. </font><font style="vertical-align: inherit;">Der Übergang von der Standardmethode zum Ermitteln der Zahl im Intervall zu unserer schnellsten Methode ermöglichte es uns jedoch, die Benchmark-Zeit um etwa 66% zu reduzieren. </font><font style="vertical-align: inherit;">mit anderen Worten, bis zu einem Drittel der ursprünglichen Zeit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die schnellste Methode (ohne Verzerrungen) ist die Lemira-Methode (mit meiner zusätzlichen Optimierung). </font><font style="vertical-align: inherit;">Da ist er:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = -range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) { t -= range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) t %= range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t) { x = rng(); m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Verwendung der Lemira-Methode verbessert die Leistung der meisten randomisierten Algorithmen mehr als der Wechsel von einer Engine mit schneller Generation zu einer schnelleren. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anhänge: Testnotizen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Code aller Tests wird auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub veröffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Insgesamt habe ich 23 Methoden zur </font></font><code>bounded_rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung von 26 verschiedenen PRNs (13 32-Bit-PRNs und 13 64-Bit-PRNs) in zwei Compilern (GCC 8 und LLVM 6) </font><font style="vertical-align: inherit;">getestet </font><font style="vertical-align: inherit;">, wodurch ich jeweils 26 * 23 * 2 = 1196 ausführbare Dateien erhielt Davon wurde es mit denselben 15 Samen durchgeführt, was 1196 * 15 = 17.940 eindeutige Testläufe ergibt, in denen jeweils drei Benchmarks kombiniert werden. Grundsätzlich habe ich Tests auf einem 48-Kern-Computer mit vier 2,1-GHz-Xeon E7-4830v3-Prozessoren durchgeführt. Das Durchführen eines vollständigen Satzes von Tests dauerte etwas weniger als einen Monat Prozessorzeit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende kehren wir von der Einleitung des Artikels zur Situation zurück. Stellen Sie sich vor, Sasha </font></font><code>jsf32.STD-libc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und Juan -</font></font><code>mt19937.BIASED_FP_MULT_SCALE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In Benchmark 3 benötigt letzteres 69,6% weniger Zeit. </font><font style="vertical-align: inherit;">Das heißt, die Zeit von dieser fiktiven Situation basiert auf Daten aus der Realität.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455702/">https://habr.com/ru/post/de455702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455692/index.html">ASZP: Restyling oder Theater beginnen mit einem Kleiderbügel</a></li>
<li><a href="../de455694/index.html">Abrechnungsarchitektur der nächsten Generation: Übergang zu Tarantool</a></li>
<li><a href="../de455696/index.html">Der elektronische Zustand der Zukunft. Teil 2</a></li>
<li><a href="../de455698/index.html">Das Buch "Wie JavaScript funktioniert"</a></li>
<li><a href="../de455700/index.html">4 Tricks, die uns geholfen haben, das Frontend zu optimieren</a></li>
<li><a href="../de455710/index.html">Warum brauchen wir bei Leroy Merlin eine eigene russische Entwicklungsabteilung für 200 Mitarbeiter?</a></li>
<li><a href="../de455714/index.html">Exportieren Sie Google Forms automatisch mit IFTTT und Django nach Notion</a></li>
<li><a href="../de455716/index.html">15 Best Practices für die Bereitstellung von Business Intelligence-Software</a></li>
<li><a href="../de455720/index.html">Wie wir eine Benutzeroberfläche für Anzeigensysteme erstellen</a></li>
<li><a href="../de455722/index.html">Python verbraucht viel Speicher oder wie kann die Größe von Objekten reduziert werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>