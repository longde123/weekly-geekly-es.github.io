<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüé® üë©‚Äçüíº üë©üèΩ‚Äçüç≥ Effektive Zahlengenerierung in einem bestimmten Intervall üòå üë©‚Äç‚úàÔ∏è üòõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die √ºberwiegende Mehrheit meiner Beitr√§ge zur Zufallszahlengenerierung befasste sich haupts√§chlich mit den Eigenschaften verschiedener Generierungssch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Effektive Zahlengenerierung in einem bestimmten Intervall</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg" alt="Bild"></div><br>  Die √ºberwiegende Mehrheit meiner Beitr√§ge zur Zufallszahlengenerierung befasste sich haupts√§chlich mit den Eigenschaften verschiedener Generierungsschemata.  Dies kann sich als unerwartet herausstellen, aber die Leistung des Randomisierungsalgorithmus h√§ngt m√∂glicherweise nicht vom gew√§hlten Generierungsschema ab, sondern von anderen Faktoren.  In diesem Beitrag (der mich von einem ausgezeichneten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von Daniel Lemyr</a> inspiriert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hat</a> ) werden wir die Hauptgr√ºnde f√ºr den R√ºckgang der Leistung bei der Erzeugung von Zufallszahlen untersuchen, die h√§ufig die Leistung der PRN-Engine √ºberwiegen. <br><br>  Stellen Sie sich diese Situation vor: <br><br>  Als Hausaufgabe implementieren Juan und Sasha denselben zuf√§lligen Algorithmus in C ++, der auf demselben Universit√§tscomputer und mit einem Datensatz ausgef√ºhrt wird.  Ihr Code ist nahezu identisch und unterscheidet sich nur in der Erzeugung von Zufallszahlen.  Juan hat es eilig f√ºr seinen Musikunterricht, also hat er sich einfach f√ºr den Wirbelwind von Mersenne entschieden.  Sasha hingegen verbrachte einige zus√§tzliche Stunden mit Nachforschungen.  Sasha f√ºhrte Benchmarks f√ºr mehrere der schnellsten PRNGs durch, die er k√ºrzlich von sozialen Netzwerken gelernt hatte, und w√§hlte die schnellsten aus.  W√§hrend des Treffens war Sasha ungeduldig zu prahlen und fragte Juan: "Welches PRNG-System haben Sie verwendet?" <br><br>  "Ich pers√∂nlich habe gerade den Mersenne-Wirbel genommen - er ist in die Sprache eingebaut und scheint ziemlich gut zu funktionieren." <br><br>  "Ha!" Antwortete Sasha.  ‚ÄûIch habe <code>jsf32</code> .  Es ist viel schneller als der alte und langsame Mersenne-Wirbelwind!  Mein Programm l√§uft in 3 Minuten 15 Sekunden! ‚Äù <br><br>  "Hmm, nicht schlecht, aber meiner schafft es in weniger als einer Minute", sagt Juan und zuckt die Achseln.  ‚ÄûNa dann muss ich zum Konzert gehen.  Kommst du mit mir? " <br><br>  "Nein", antwortet Sasha.  "Ich ... √§h ... muss meinen Code noch einmal ansehen." <br><br>  Diese unangenehme fiktive Situation ist <em>nicht</em> besonders fiktiv;  es basiert auf realen Ergebnissen.  Wenn Ihr zuf√§lliger Algorithmus nicht so schnell l√§uft, wie wir es m√∂chten, und der Engpass in der Erzeugung von Zufallszahlen zu liegen scheint, liegt das Problem seltsamerweise m√∂glicherweise nicht im Zufallszahlengenerator! <br><a name="habracut"></a><br><h3>  Einf√ºhrung: Zufallszahlen in der Praxis </h3><br>  Die meisten modernen Zufallszahlengeneratoren hoher Qualit√§t erzeugen Maschinenw√∂rter, die mit Zufallsbits gef√ºllt sind, dh sie erzeugen normalerweise Zahlen im Intervall [0..2 <sup>32</sup> ) oder [0..2 <sup>64</sup> ).  In vielen F√§llen ben√∂tigen Benutzer jedoch Zahlen in einem bestimmten Intervall. Um beispielsweise einen W√ºrfel zu werfen oder eine zuf√§llige Spielkarte auszuw√§hlen, werden Zahlen in kleinen konstanten Intervallen ben√∂tigt.  Viele Algorithmen, von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mischen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reservoir-Sampling</a> bis hin zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">randomisierten bin√§ren Suchb√§umen,</a> erfordern jedoch Zahlen aus anderen Intervallen. <br><br><h3>  Methoden </h3><br>  Wir werden uns viele verschiedene Methoden ansehen.  Um die Diskussion zu vereinfachen, werden anstelle von Zahlen im Intervall [ <em>i</em> .. <em>j</em> ) oder [ <em>i</em> .. <em>j</em> ] Zahlen im Intervall [0 .. <em>k</em> ) generiert.  Mit einem solchen Schema k√∂nnen wir beispielsweise Zahlen im Intervall [ <em>i</em> .. <em>j</em> ) erzeugen, indem wir <em>k</em> = <em>j</em> - <em>i setzen</em> , eine Zahl im Intervall [0 .. <em>k</em> ) erzeugen und dann <em>i</em> hinzuf√ºgen. <br><br><h4>  Integrierte C ++ - Tools </h4><br>  Viele Sprachen verf√ºgen √ºber integrierte Tools zum Abrufen einer Zufallszahl in einem bestimmten Intervall.  Um beispielsweise eine Karte mit 52 Karten in Skriptsprachen wie Perl und Python aus einem Deck zu entfernen, k√∂nnen Sie <code>int(rand(52))</code> bzw. <code>random.randint(0,52)</code> schreiben.  [Anmerkung  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">CryptoPirate-</a> Benutzer: <i>Es scheint mir hier ein Fehler zu sein, in Python generiert Randint (a, b) Zahlen von a nach b, einschlie√ülich b.</i>  <i>Und da sich 52 Karten im Deck befinden und die erste "0" ist, sollte sie zuf√§llig sein. Randint (0,51)</i> .] In C ++ k√∂nnen wir <code>uniform_int_distribution</code> gleiche <code>uniform_int_distribution</code> . <br><br>  C ++ - Code zur Implementierung dieses Ansatzes ist einfach: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt; dist(<span class="hljs-number"><span class="hljs-number">0</span></span>, range<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dist(rng); }</code> </pre> <br>  Normalerweise wird eine der unten beschriebenen Techniken in den integrierten Tools verwendet, aber die meisten Benutzer verwenden diese Tools einfach, ohne dar√ºber nachzudenken, was ‚Äûunter der Haube‚Äú passiert, und glauben, dass diese Tools korrekt entworfen und recht effektiv sind.  In C ++ sind integrierte Tools komplexer, da sie mit ziemlich willk√ºrlichen Generierungs-Engines arbeiten k√∂nnen sollten - ein Generator, der Werte im Bereich von -3 bis 17 erzeugt, kann durchaus g√ºltig sein und mit <code>std::uniform_int_distribution</code> , um Zahlen in jedem Intervall zu erstellen. zum Beispiel [0..1000].  Das hei√üt, die integrierten C ++ - Tools sind f√ºr die meisten F√§lle, in denen sie verwendet werden, zu kompliziert. <br><br><h4>  Der klassische Rest der Division (schief) </h4><br>  Gehen wir von einem stark vereinfachten zu einem zu vereinfachten Ansatz √ºber. <br><br>  Als ich Programmieren studierte, generierten wir mit dem Restoperator Zahlen in dem Intervall (zum Beispiel, um eine Karte in einem Kartenspiel mit 52 Karten auszuw√§hlen).  Um die Zahl im Intervall [0..52) zu erhalten, haben wir <code>rand() % 52</code> . <br><br>  In C ++ kann dieser Ansatz wie folgt implementiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rng() % range; }</code> </pre> <br>  Trotz der Einfachheit dieses Ansatzes zeigt es den Grund, warum das Abrufen von Zahlen im richtigen Intervall normalerweise eine langsame Aufgabe ist - es erfordert eine Division (um den vom <code>%</code> -Operator erhaltenen Rest zu berechnen).  Das Teilen ist normalerweise mindestens eine Gr√∂√üenordnung langsamer als andere arithmetische Operationen, so dass eine einzelne arithmetische Operation l√§nger dauert als alle Arbeiten, die von einem schnellen PRNG ausgef√ºhrt werden. <br><br>  Neben der geringen Geschwindigkeit ist es aber auch <em>schief</em> .  Um zu verstehen, warum <code>rand() % 52</code> verzerrte Zahlen zur√ºckgibt, nehmen wir an, dass <code>rand()</code> Zahlen im Intervall [0..2 <sup>32</sup> ) erstellt, und beachten Sie, dass 52 2 <sup>32 nicht</sup> vollst√§ndig teilt, sondern 82 595 524 mal mit dem Rest teilt 48. Das hei√üt, wenn wir <code>rand() % 52</code> , haben wir 82 595 525 M√∂glichkeiten, die ersten 48 Karten aus dem Stapel auszuw√§hlen, und nur 82 595 524 M√∂glichkeiten, die letzten vier Karten auszuw√§hlen.  Mit anderen Worten, es gibt einen Versatz von 0,00000121% gegen√ºber diesen letzten vier Karten (vielleicht sind dies K√∂nige!).  Als ich Student war und Hausaufgaben √ºber das Werfen von W√ºrfeln oder das Zeichnen von Karten schrieb, k√ºmmerte sich normalerweise niemand um so kleine Verzerrungen, aber mit zunehmendem Intervall w√§chst die Verzerrung linear.  Bei einem 32-Bit-PRNG hat ein begrenztes Intervall von weniger als 2 <sup>24</sup> einen Versatz von weniger als 0,5%, aber √ºber 2 <sup>31 einen</sup> Versatz von 50% - einige Zahlen werden doppelt so oft zur√ºckgegeben wie andere. <br><br>  In diesem Artikel werden wir haupts√§chlich Techniken betrachten, die Strategien verwenden, um einen systematischen Fehler zu beseitigen. Es ist jedoch wahrscheinlich erw√§hnenswert, dass bei einem 64-Bit-PRNG der Versatzwert in normalen Anwendungen wahrscheinlich vernachl√§ssigbar ist. <br><br>  Ein weiteres Problem kann sein, dass einige Generatoren schwache niedrige Bits haben.  Beispielsweise haben die GPRS-Familien Xoroshiro + und Xoshiro + niedrige Bits, die statistische Tests nicht bestehen.  Wenn wir <code>% 52</code> ausf√ºhren (weil 52 gerade ist), √ºbergeben wir das niederwertige Bit direkt an den Ausgang. <br><br><h4>  Gleitkommazahlen multiplizieren (schief) </h4><br>  Eine andere √ºbliche Technik ist die Verwendung eines PRNG, das Gleitkommazahlen im Intervall [0..1) mit der anschlie√üenden Umwandlung dieser Zahlen in das gew√ºnschte Intervall erzeugt.  Dieser Ansatz wird in Perl verwendet. Es wird <a href="">empfohlen,</a> <code>int(rand(10))</code> zu verwenden, um eine Ganzzahl im Intervall [0..10) zu generieren, indem eine Gleitkommazahl generiert und anschlie√üend abgerundet wird. <br><br>  In C ++ ist dieser Ansatz folgenderma√üen geschrieben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rng_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> zeroone = <span class="hljs-number"><span class="hljs-number">0x1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>p<span class="hljs-number"><span class="hljs-number">-32</span></span> * rng(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range * zeroone; }</code> </pre> <br>  (Beachten Sie, dass <code>0x1.0p-32</code> eine bin√§re Gleitkommakonstante f√ºr 2 <sup>-32 ist</sup> , mit der wir eine zuf√§llige Ganzzahl im Intervall [0..2 <sup>32</sup> konvertieren), um sie im Einheitsintervall zu verdoppeln.  Stattdessen k√∂nnen wir eine solche Konvertierung mit <code>ldexp(rng(), -32)</code> , aber als ich diesen Ansatz <code>ldexp(rng(), -32)</code> , stellte sich heraus, dass er viel langsamer ist.) <br><br>  Dieser Ansatz ist genauso verzerrt wie der klassische Rest der Teilung, aber die Abweichung erscheint anders.  Wenn wir beispielsweise Zahlen im Intervall [0..52] ausw√§hlen w√ºrden, w√ºrden die Zahlen 0, 13, 26 und 39 einmal seltener vorkommen als andere. <br><br>  Diese Version ist bei Verallgemeinerung auf 64 Bit noch unangenehmer, da sie einen Gleitkommatyp erfordert, dessen Mantisse mindestens 64 Bit betr√§gt.  Auf x86-Computern mit Linux und macOS k√∂nnen wir <code>long double</code> , um die pr√§ziseren x86-Gleitkommazahlen mit einer 64-Bit-Mantisse zu nutzen. <code>long double</code> nicht universell auf alle Systeme portiert. In einigen Systemen entspricht <code>long double</code> <code>double</code> . <br><br>  Es gibt eine gute Seite - dieser Ansatz ist schneller als Restl√∂sungen f√ºr PRNGs mit schwachen niedrigen Bits. <br><br><h4>  Ganzzahlige Multiplikation (schief) </h4><br>  Die Multiplikationsmethode kann eher an feste als an Gleitkomma-Arithmetik angepasst werden.  Tats√§chlich multiplizieren wir st√§ndig mit 2 <sup>32</sup> , <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br>  Es scheint, dass diese Version 64-Bit-Arithmetik erfordert. Auf x86-Prozessoren kompiliert ein guter Compiler diesen Code in einen 32-Bit- <code>mult</code> Befehl (der uns zwei 32-Bit-Ausgabewerte gibt, von denen einer der R√ºckgabewert ist).  Es ist zu erwarten, dass diese Version schnell ist, sie ist jedoch genau wie die Methode zum Multiplizieren von Gleitkommazahlen verzerrt. <br><br><h4>  Drop Division (kein Versatz) </h4><br>  Wir k√∂nnen das Gleitkomma-Multiplikationsschema in ein dividationsbasiertes Schema umwandeln.  Anstatt <code>x * range / 2**32</code> multiplizieren <code>x * range / 2**32</code> berechnen wir <code>x / (2**32 / range)</code> .  Da wir mit Ganzzahlarithmetik arbeiten, wird die Rundung in dieser Version anders ausgef√ºhrt und generiert manchmal Werte au√üerhalb des gew√ºnschten Intervalls.  Wenn wir diese Werte verwerfen (z. B. entfernen und neue Werte generieren), erhalten wir als Ergebnis eine Technik ohne Verzerrungen. <br><br>  Wenn Sie beispielsweise eine Karte mit einem 32-Bit-PRNG herausziehen, k√∂nnen Sie eine 32-Bit-Zahl generieren und durch 2 32/52 = 82 595 524 teilen, um eine Karte auszuw√§hlen.  Diese Technik funktioniert, wenn der Zufallswert aus dem 32-Bit-PRNG kleiner als 52 √ó 82595524 = 2 32/32 - 48 ist. Wenn der Zufallswert aus dem PRNR einer der letzten 48 Werte des oberen Teils des Generatorintervalls ist, m√ºssen Sie ihn verwerfen und nach einem anderen suchen. <br><br>  Unser Code f√ºr diese Version verwendet einen Trick, bei dem 2 <sup>32</sup> durch den <code>range</code> ohne 64-Bit-Mathematik zu verwenden.  F√ºr die direkte Berechnung von <code>2**32 / range</code> wir die Zahl 2 <sup>32 darstellen</sup> , die zu gro√ü ist (um eins!), Um als 32-Bit-Ganzzahl dargestellt zu werden.  Stattdessen ber√ºcksichtigen wir, dass der un√§re Negationsoperationsbereich f√ºr vorzeichenlose Ganzzahlen einen positiven Wert von 2 <sup>32</sup> berechnet - <code>range</code> ;  Wenn wir diesen Wert durch den <code>range</code> teilen, erhalten wir eine Antwort von weniger als <code>2**32 / range</code> . <br><br>  Daher sieht der C ++ - Code zum Generieren von Zahlen mithilfe von Division und Drop folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates divisor = 2**32 / range uint32_t divisor = ((-range) / range) + 1; if (divisor == 0) // overflow, it's really 2**32 return 0; for (;;) { uint32_t val = rng() / divisor; if (val &lt; range) return val; } }</span></span></code> </pre> <br>  Nat√ºrlich erfordert dieser Ansatz zwei langsame Operationen basierend auf der Division, die normalerweise langsamer sind als andere arithmetische Operationen, daher sollten Sie nicht erwarten, dass sie schnell sind. <br><br><h4>  Der Rest der Division (doppelt) ohne Verzerrungen - OpenBSD-Technik </h4><br>  Wir k√∂nnen auch den Drop-Ansatz verwenden, um den Versatz bei der klassischen Teilungsrestmethode zu beseitigen.  Im Beispiel mit Spielkarten m√ºssen wir wieder 48 Werte fallen lassen.  In dieser Version werden die <em>ersten</em> 48 Werte (√§quivalent) verworfen, anstatt die <em>letzten</em> 48 Werte zu verwerfen. <br><br>  Hier ist die Implementierung dieses Ansatzes in C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br>  Diese Technik entfernt den Versatz, erfordert jedoch zwei zeitaufw√§ndige Teilungsvorg√§nge mit dem Rest jedes Ausgabewerts (und m√∂glicherweise ben√∂tigen Sie einen internen Generator, um mehrere Zahlen zu erstellen).  Daher ist zu erwarten, dass die Methode ungef√§hr zweimal langsamer ist als der klassische Skew-Ansatz. <br><br>  <a href=""><code> arc4random_uniform</code> OpenBSD- <code> arc4random_uniform</code></a> (der auch unter OS X und iOS verwendet wird) verwendet diese Strategie. <br><br><h4>  Rest der Teilung (einzeln) ohne Versatz - Java-Methodik </h4><br>  Java verwendet einen anderen Ansatz zum Generieren einer Zahl in einem Intervall, in dem nur eine Restdivisionsoperation verwendet wird, mit Ausnahme relativ seltener F√§lle, in denen das Ergebnis verworfen wird.  Code: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rng_t&amp; rng, uint32_t range)</span></span></span><span class="hljs-function"> </span></span>{ uint32_t x, r; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng(); r = x % range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x - r &gt; (-range)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br>  Um zu verstehen, warum diese Option funktioniert, m√ºssen Sie ein wenig nachdenken.  Im Gegensatz zur vorherigen Version, die auf Residuen basiert und die Verzerrung beseitigt, indem ein Teil der niedrigsten Werte aus der internen Generierungsmaschine entfernt wird, filtert diese Version die Werte aus dem oberen Teil des Motorintervalls. <br><br><h4>  Skew Integer Multiplication - Lemira-Methode </h4><br>  √Ñhnlich wie wir die Vorspannung aus der Restdivisionsmethode entfernt haben, k√∂nnen wir die Vorspannung aus der Ganzzahlmultiplikationstechnik entfernen.  Diese Technik wurde von Lemyr erfunden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><h4>  Drop Bitmaske (kein Versatz) - Apple-Technik </h4><br>  Bei unserem letzten Ansatz werden Divisions- und Restvorg√§nge vollst√§ndig eliminiert.  Stattdessen wird eine einfache Maskierungsoperation verwendet, um eine Zufallszahl im Intervall [0..2 <sup><em>k</em></sup> ) zu erhalten, wobei <em>k</em> der kleinste Wert ist, so dass 2 <sup><em>k</em></sup> gr√∂√üer als das Intervall ist.  Wenn der Wert f√ºr unser Intervall zu gro√ü ist, verwerfen wir ihn und versuchen, einen anderen zu erhalten.  Der Code wird unten angezeigt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = ~<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); --range; mask &gt;&gt;= __builtin_clz(range|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng() &amp; mask; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt; range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br>  Dieser Ansatz wurde von Apple √ºbernommen, als (in der Version macOS Sierra) <a href="">eine eigene √úberarbeitung</a> des <code>arc4random_uniform</code> Codes durchgef√ºhrt wurde. <br><br><h3>  Benchmarking grundlegender Techniken </h3><br>  Jetzt haben wir mehrere Ans√§tze, die bewertet werden k√∂nnen.  Wenn wir uns Sorgen √ºber die Kosten eines einzelnen Gesch√§ftsbereichs machen, wird das Benchmarking leider nicht trivial.  Kein Benchmark kann alle Faktoren ber√ºcksichtigen, die den Anwendungsbereich beeinflussen, und es gibt keine Garantie daf√ºr, dass die beste Option f√ºr Ihre Anwendung mit Sicherheit die beste f√ºr meine ist. <br><br>  Wir verwenden drei Benchmarks und testen die Techniken mit vielen verschiedenen PRNGs. <br><br><h4>  Benchmark Large-Shuffle </h4><br>  Der wahrscheinlich offensichtlichste Ma√üstab ist das Mischen.  In diesem Benchmark simulieren wir das Mischen in gro√üem Ma√üstab.  Um ein Array der Gr√∂√üe <em>N</em> zu sortieren <em>,</em> m√ºssen wir Zahlen in den Intervallen [0 .. <em>N</em> ), [0 .. ( <em>N</em> -1)), ..., [0..1) generieren.  In diesem Benchmark nehmen wir an, dass <em>N</em> die maximal m√∂gliche Zahl ist (f√ºr <code>uint32_t</code> es 2 <sup>32</sup> -1).  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; }</code> </pre> <br>  Beachten Sie, dass wir jede Zahl ‚Äûverwenden‚Äú und zur <code>sum</code> addieren (damit sie nicht durch Optimierung weggeworfen wird), aber keine Mischung durchf√ºhren, um uns auf die Erzeugung von Zahlen zu konzentrieren. <br><br>  Zum Testen der 64-Bit-Generierung haben wir einen √§hnlichen Test, aber es ist unpraktisch, einen Test durchzuf√ºhren, der dem Mischen eines Arrays mit einer Gr√∂√üe von 2 <sup>64</sup> - 1 entspricht (da es viele tausend Jahre dauern wird, bis dieser gr√∂√üere Benchmark abgeschlossen ist).  Stattdessen kreuzen wir das gesamte 64-Bit-Intervall, generieren jedoch die gleiche Anzahl von Ausgabewerten wie im 32-Bit-Test.  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bound = (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(i)&lt;&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>) | i; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bval = bounded_rand(rng, bound ); assert(bval &lt; bound); sum += bval; }</code> </pre> <br><h5>  Mersenne-Wirbelergebnisse </h5><br>  Die unten gezeigten Ergebnisse zeigen die Leistung dieses Benchmarks f√ºr jede der Methoden, die wir bei Verwendung des Mersenne-Wirbels und beim Testen des 32-Bit-Codes (unter Verwendung von <code>std::mt19937</code> aus <code>libstdc++</code> ) und eines √§hnlichen 64-Bit-Codes (unter Verwendung von <code>std:mt19937_64</code> aus <code>libstdc++</code> )  Das Ergebnis ist das geometrische Mittel von 15 L√§ufen mit unterschiedlichen Startwerten, das dann normalisiert wird, so dass die klassische Teilungsrestmethode eine einzige Laufzeit hat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/3eb/53f/b9f3eb53f894a14ac2698f44090b23a6.svg"></div><br>  Es scheint, dass wir klare Antworten zur Leistung haben - es scheint, dass Sie Techniken f√ºr ihre Perfektion entwickeln und sich fragen k√∂nnen, woran <code>libstdc++</code> Entwickler gedacht haben, als sie eine so schreckliche Implementierung f√ºr 32-Bit-Zahlen geschrieben haben.  Wie so oft beim Benchmarking ist die Situation jedoch komplizierter, als es aus diesen Ergebnissen hervorgeht.  Erstens besteht das Risiko, dass die Ergebnisse spezifisch f√ºr den Mersenne-Wirbel sind, sodass wir die vielen getesteten PRNGs erweitern werden.  Zweitens kann es ein subtiles Problem mit dem Benchmark selbst geben.  Lassen Sie uns zuerst die erste Frage behandeln. <br><br><h5>  Ergebnisse verschiedener PRNGs </h5><br>  Wir werden 32-Bit- <code>arc4_rand32</code> mit <code>arc4_rand32</code> , <code>chacha8r</code> , <code>gjrand32</code> , <code>jsf32</code> , <code>mt19937</code> , <code>pcg32</code> , <code>pcg32_fast</code> , <code>sfc32</code> , <code>splitmix32</code> , <code>xoroshiro64+</code> , <code>xorshift*64/32</code> <code>xoshiro128+</code> , <code>xoshiro128+</code> und <code>xoshiro128**</code> und 64-Bit- <code>gjrand64</code> <code>xoshiro128**</code> <code>jsf64</code> , <code>mcg128</code> , <code>mcg128_fast</code> , <code>mt19937_64</code> , <code>pcg64</code> , <code>pcg64_fast</code> , <code>sfc64</code> , <code>splitmix64</code> , <code>xoroshiro128+</code> , <code>xorshift*128/64</code> <code>xoshiro256+</code> , <code>xoshiro256+</code> und <code>xoshiro256*</code> .  Diese Kits geben uns einige langsame PRNs und viele sehr schnelle. <br><br>  Hier sind die Ergebnisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2dc/8c8/f1a/2dc8c8f1af9aa517a92260e7cbd3a73e.svg"></div><br>  Wir k√∂nnen die Hauptunterschiede zu den Ergebnissen mit dem Mersenne-Wirbel sehen.  Schnellere PRNGs verschieben das Gleichgewicht in Richtung des Begrenzungscodes, und daher wird der Unterschied zwischen den verschiedenen Ans√§tzen st√§rker, insbesondere im Fall von 64-Bit-PRNRs.  Mit einer gr√∂√üeren <code>libstc++</code> von <code>libstc++</code> scheint <code>libstc++</code> Implementierung nicht mehr so ‚Äã‚Äãschrecklich zu sein. <br><br><h5>  Schlussfolgerungen </h5><br>  In dieser Benchmark gewinnt der Ansatz, der auf Multiplikation mit Bias basiert, deutlich an Geschwindigkeit.  Es gibt viele Situationen, in denen die Grenzen im Verh√§ltnis zur Gr√∂√üe des PRNG klein sind und die Leistung absolut kritisch ist.  In solchen Situationen ist es unwahrscheinlich, dass eine leichte Abweichung sp√ºrbare Auswirkungen hat, die PRNG-Geschwindigkeit jedoch.  Ein solches Beispiel ist Quicksort mit einem zuf√§lligen Referenzpunkt.  Von den verzerrten Methoden sieht die Bitmaskentechnik vielversprechend aus. <br><br>  Bevor wir jedoch ernsthafte Schlussfolgerungen ziehen, m√ºssen wir auf das gro√üe Problem dieses Benchmarks hinweisen - die meiste Zeit wird an sehr hohen Grenzen verbracht, was h√∂chstwahrscheinlich gro√üen Intervallen eine √ºberm√§√üige Bedeutung beimisst.  Deshalb m√ºssen wir zum zweiten Benchmark gehen. <br><br><h4>  Benchmark Small-Shuffle </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Benchmark √§hnelt dem vorherigen, f√ºhrt jedoch viel weniger ‚ÄûArray-Mixing‚Äú (mehrere) durch. </font></font> Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mersenne-Wirbelergebnisse </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/d3b/4bd/6c5d3b4bdb5f2e45cd805a051d79ab9a.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ergebnisse verschiedener PRNGs </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/9ae/8c0/45a9ae8c040cb4d297fe82f00fa06e3c.svg"></div><br><h5>  Schlussfolgerungen </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Benchmark vermeidet eine zu starke Betonung gro√üer Grenzen und spiegelt die realen Anwendungsf√§lle genauer wider, verwirft jedoch jetzt gro√üe Grenzen vollst√§ndig. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark f√ºr alle Intervalle </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Benchmark zielt darauf ab, die Nachteile der beiden vorherigen zu vermeiden. </font><font style="vertical-align: inherit;">Er f√ºhrt Tests bei jeder Gr√∂√üe der Zweierpotenz durch, so dass jede Gr√∂√üe vorhanden ist, aber sein Einfluss wird nicht √ºbersch√§tzt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bit = <span class="hljs-number"><span class="hljs-number">1</span></span>; bit != <span class="hljs-number"><span class="hljs-number">0</span></span>; bit &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x1000000</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bound = bit | (i &amp; (bit - <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, bound); assert(bval &lt; bound); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mersenne-Wirbelergebnisse </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/65c/447/f3465c447f9b19b430bb43533a655c2f.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ergebnisse verschiedener PRNGs </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/c58/2a2/64bc582a2fde24fd0faedbeaabb9f64c.svg"></div><br><h5>  Schlussfolgerungen </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele unserer Ergebnisse bleiben unver√§ndert. </font><font style="vertical-align: inherit;">Die Skew-Methode ist schnell, wenn wir den Fehler ertragen k√∂nnen, und das Bitmaskenschema scheint eine gute gemittelte Wahl zu sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnten dies beenden, wenn wir nicht zur√ºckkehren, unseren Code kritisch betrachten und √Ñnderungen daran vornehmen m√∂chten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbesserungen vornehmen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Punkt erforderten alle Methoden zur Beseitigung von Versatz die Verwendung einer zus√§tzlichen Teilungsrestoperation, weshalb sie viel langsamer als Versatzmethoden durchgef√ºhrt werden. </font><font style="vertical-align: inherit;">Es w√§re hilfreich, wenn wir diesen Vorteil reduzieren k√∂nnten.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnellerer Schwellenwert-Drop </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einige unserer Algorithmen haben Code, der einen Schwellenwert verwendet, zum Beispiel: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Anzahl im Vergleich zum PRNG-Ausgabeintervall klein ist, ist sie meistens </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viel gr√∂√üer als der</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schwellenwert. </font><font style="vertical-align: inherit;">Das hei√üt, wenn wir eine vorl√§ufige Sch√§tzung des Schwellenwerts hinzuf√ºgen k√∂nnen, die etwas h√∂her sein kann, sparen wir den teuren Vorgang, den Rest der Division zu √ºbernehmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der folgende Code behandelt diese Aufgabe:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> r = rng(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r &lt; t) r = rng(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r % range; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese √Ñnderung kann sowohl auf "Double Mod ohne Verzerrungen" (siehe oben) als auch auf "Integer Multiplication ohne Verzerrungen" angewendet werden. </font><font style="vertical-align: inherit;">Die Idee wurde von Lemir erfunden, der sie auf die zweite Methode anwendete (aber nicht auf die erste).</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Large-Shuffle-Benchmark-Ergebnisse </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Optimierung f√ºhrt zu einer signifikanten Verbesserung der Ergebnisse des 64-Bit-Benchmarks (bei dem der Mod noch langsamer ist), verschlechtert jedoch die Leistung im 32-Bit-Benchmark geringf√ºgig. </font><font style="vertical-align: inherit;">Trotz der Verbesserungen gewinnt die Bitmaskenmethode immer noch.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb4/61d/b52/bb461db52be4a7d983dd7f97844179c0.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Small-Shuffle-Benchmark-Ergebnisse </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits beschleunigt diese √Ñnderung den Small-Shuffle-Benchmark sowohl f√ºr die Methode der ganzzahligen Multiplikation als auch f√ºr die Methode des doppelten Restes der Division erheblich. </font><font style="vertical-align: inherit;">In beiden F√§llen verschiebt sich ihre Leistung ohne Verzerrungen n√§her an die Ergebnisse der Optionen. </font><font style="vertical-align: inherit;">Die Leistung der Doppelrestmethode (OpenBSD) entspricht jetzt fast der Leistung der Einzelrestmethode (Java).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/2bd/fe2/f072bdfe2660cf0f8789b124a8f02646.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark-Ergebnisse f√ºr alle Intervalle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir sehen eine √§hnliche Verbesserung des Benchmarks f√ºr alle Intervalle. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/219/b1d/add/219b1daddfa6a55a2cb485b3ae774016.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es sieht so aus, als k√∂nnten wir einen neuen universellen Gewinner bekannt geben: eine optimierte Methode zum Multiplizieren von Lemire-Ganzzahlen ohne Verzerrung. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Division Restoptimierung </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalerweise </font></font><code>a % b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfordert </font><font style="vertical-align: inherit;">eine Berechnung </font><font style="vertical-align: inherit;">eine Division, aber in Situationen, in denen das </font></font><code>a &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis einfach ist </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und keine Division erforderlich ist. </font><font style="vertical-align: inherit;">Und wenn </font></font><code>a/2 &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ist das Ergebnis einfach </font></font><code>a - b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher statt zu rechnen</font></font><br><br><pre> <code class="cpp hljs">a %= b;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir k√∂nnen erf√ºllen </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) { a -= b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) a %= b; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Kosten f√ºr die Teilung sind so hoch, dass eine Erh√∂hung der Kosten f√ºr diesen komplexeren Code sich durch Zeitersparnis aufgrund fehlender Teilung rechtfertigen kann. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Large-Shuffle-Benchmark-Ergebnisse </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Hinzuf√ºgen dieser Optimierung werden die Ergebnisse des Large-Shuffle-Benchmarks erheblich verbessert. </font><font style="vertical-align: inherit;">Dies macht sich wiederum im 64-Bit-Code bemerkbar, bei dem die √úbernahme des Restbetrags teurer ist. </font><font style="vertical-align: inherit;">Die Doppelrestmethode (OpenBSD-Stil) zeigt Versionen mit Optimierungen f√ºr nur eine Restoperation und f√ºr beide.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e1a/669/c56e1a669836477e46f870bd1bc7a6c9.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In diesem Benchmark ist die Bitmaske immer noch der Gewinner, aber die Grenze zwischen ihr und Lemiras Ansatz hat sich erheblich verengt. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Small-Shuffle-Benchmark-Ergebnisse </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hinzuf√ºgen dieser Optimierung erh√∂ht nicht die Leistung des Small-Shuffle-Benchmarks, sodass die Frage nur bleibt, ob dadurch erhebliche Kosten entstehen. </font><font style="vertical-align: inherit;">In einigen F√§llen nein, in anderen steigen die Kosten leicht an.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/4db/b65/6fa4dbb65b9a3f6c6f9e8ba4f7b455db.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark-Ergebnisse f√ºr alle Intervalle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im Benchmark f√ºr alle Intervalle sind die √Ñnderungen ebenfalls gering. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/ae7/758/e0eae77583cc457a9e923540ad954257.svg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bonus: PRSP-Vergleichsergebnisse </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Hauptgrund f√ºr die Verwendung vieler PRNGs zum Testen von Nummernschemata in Intervallen bestand darin, eine versehentliche Verzerrung der Ergebnisse aufgrund der Besonderheiten des Betriebs einzelner PRNG-Schemata zu vermeiden. </font><font style="vertical-align: inherit;">Wir k√∂nnen jedoch dieselben Ergebnisse interner Tests verwenden, um die Generierungsschemata selbst zu vergleichen.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG mit 32-Bit-Ausgabe </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die folgende Grafik zeigt die Leistung verschiedener 32-Bit-Generierungsschemata, gemittelt f√ºr alle Methoden und f√ºnfzehn L√§ufe, normalisiert auf die Leistung des 32-Bit-Mersenne-Wirbels: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einerseits bin ich froh zu sehen, dass es </font></font><code>pcg32_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirklich schnell ist - es wurde nur von einer kleinen Version von Xoroshiro besiegt (die keine statistischen Tests besteht). </font><font style="vertical-align: inherit;">Dies zeigt aber auch, warum ich mich wegen der Leistung moderner Hochleistungs-Universal-PRSPs selten aufrege - der Unterschied zwischen den verschiedenen Methoden ist sehr unbedeutend. </font><font style="vertical-align: inherit;">Insbesondere die Leistung der schnellsten vier Schaltkreise unterscheidet sich um weniger als 5%, und ich glaube, dass dies einfach durch ‚ÄûRauschen‚Äú verursacht wird.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG mit der Ausgabe von 64-Bit-Zahlen </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grafik zeigt die Leistung verschiedener 64-Bit-Generierungsschemata, gemittelt unter allen Techniken und f√ºnfzehn L√§ufen, normalisiert auf die Leistung des 32-Bit-Mersenne-Wirbels. Es mag seltsam erscheinen, dass die Normalisierung mit dem 32-Bit-Mersenne-Wirbel durchgef√ºhrt wird, aber dies erm√∂glicht es uns, die zus√§tzlichen Kosten f√ºr die Verwendung der 64-Bit-Generierung in F√§llen zu sehen, in denen die 32-Bit-Generierung ausreichend ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/16c/b24/92816cb249e7f76c4ed4e11c65f67475.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Ergebnisse best√§tigen, dass es </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unglaublich schnell ist, aber die letzten vier Techniken unterscheiden sich wiederum nur um etwa 5%, sodass es schwierig ist, aus den schnellsten Methoden zu w√§hlen. </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>pcg64_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√ºssen langsamer sein </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da ihre Basisgeneratoren lineare kongruente 128-Bit-Generatoren (LCG) und multiplikative kongruente 128-Bit-Generatoren (MCG, MCG) sind. Trotz der Tatsache, dass sie nicht die schnellsten Techniken in diesem Satz sind, sind sie immer </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noch 20% schneller als der 64-Bit-Mersenne-Wirbel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber was vielleicht noch wichtiger ist, diese Ergebnisse zeigen auch, dass ein 64-Bit-PRNG normalerweise langsamer ist als ein 32-Bit-PRNG, wenn Sie keine 64-Bit-Ausgabe ben√∂tigen.</font></font><br><br><h3>  Schlussfolgerungen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An unseren Benchmarks k√∂nnen wir erkennen, dass der √úbergang von standardm√§√üig verwendeten PRNGs (z. B. dem 32-Bit-Mersenne-Wirbel) zu schnelleren PRNPs die Ausf√ºhrungszeit von Benchmarks um 45% reduzierte. </font><font style="vertical-align: inherit;">Der √úbergang von der Standardmethode zum Ermitteln der Zahl im Intervall zu unserer schnellsten Methode erm√∂glichte es uns jedoch, die Benchmark-Zeit um etwa 66% zu reduzieren. </font><font style="vertical-align: inherit;">mit anderen Worten, bis zu einem Drittel der urspr√ºnglichen Zeit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die schnellste Methode (ohne Verzerrungen) ist die Lemira-Methode (mit meiner zus√§tzlichen Optimierung). </font><font style="vertical-align: inherit;">Da ist er:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = -range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) { t -= range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) t %= range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t) { x = rng(); m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Verwendung der Lemira-Methode verbessert die Leistung der meisten randomisierten Algorithmen mehr als der Wechsel von einer Engine mit schneller Generation zu einer schnelleren. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anh√§nge: Testnotizen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Code aller Tests wird auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub ver√∂ffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Insgesamt habe ich 23 Methoden zur </font></font><code>bounded_rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung von 26 verschiedenen PRNs (13 32-Bit-PRNs und 13 64-Bit-PRNs) in zwei Compilern (GCC 8 und LLVM 6) </font><font style="vertical-align: inherit;">getestet </font><font style="vertical-align: inherit;">, wodurch ich jeweils 26 * 23 * 2 = 1196 ausf√ºhrbare Dateien erhielt Davon wurde es mit denselben 15 Samen durchgef√ºhrt, was 1196 * 15 = 17.940 eindeutige Testl√§ufe ergibt, in denen jeweils drei Benchmarks kombiniert werden. Grunds√§tzlich habe ich Tests auf einem 48-Kern-Computer mit vier 2,1-GHz-Xeon E7-4830v3-Prozessoren durchgef√ºhrt. Das Durchf√ºhren eines vollst√§ndigen Satzes von Tests dauerte etwas weniger als einen Monat Prozessorzeit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende kehren wir von der Einleitung des Artikels zur Situation zur√ºck. Stellen Sie sich vor, Sasha </font></font><code>jsf32.STD-libc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und Juan -</font></font><code>mt19937.BIASED_FP_MULT_SCALE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In Benchmark 3 ben√∂tigt letzteres 69,6% weniger Zeit. </font><font style="vertical-align: inherit;">Das hei√üt, die Zeit von dieser fiktiven Situation basiert auf Daten aus der Realit√§t.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455702/">https://habr.com/ru/post/de455702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455692/index.html">ASZP: Restyling oder Theater beginnen mit einem Kleiderb√ºgel</a></li>
<li><a href="../de455694/index.html">Abrechnungsarchitektur der n√§chsten Generation: √úbergang zu Tarantool</a></li>
<li><a href="../de455696/index.html">Der elektronische Zustand der Zukunft. Teil 2</a></li>
<li><a href="../de455698/index.html">Das Buch "Wie JavaScript funktioniert"</a></li>
<li><a href="../de455700/index.html">4 Tricks, die uns geholfen haben, das Frontend zu optimieren</a></li>
<li><a href="../de455710/index.html">Warum brauchen wir bei Leroy Merlin eine eigene russische Entwicklungsabteilung f√ºr 200 Mitarbeiter?</a></li>
<li><a href="../de455714/index.html">Exportieren Sie Google Forms automatisch mit IFTTT und Django nach Notion</a></li>
<li><a href="../de455716/index.html">15 Best Practices f√ºr die Bereitstellung von Business Intelligence-Software</a></li>
<li><a href="../de455720/index.html">Wie wir eine Benutzeroberfl√§che f√ºr Anzeigensysteme erstellen</a></li>
<li><a href="../de455722/index.html">Python verbraucht viel Speicher oder wie kann die Gr√∂√üe von Objekten reduziert werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>