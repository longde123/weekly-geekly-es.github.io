<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ•Ô∏è üò∂ üë©‚Äç‚ù§Ô∏è‚Äçüë® Zwei Z80 pro Maschine: Wie unterscheiden sich 8-Bit-Arcade-Maschinen von Heimcomputern? üë®üèº‚Äçüè≠ üî¢ üì†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ich bei der Erstellung des Emulators √ºber den Arcade-Automaten Bomb Jack gelernt habe 


 Ich habe k√ºrzlich einen kleinen Emulator f√ºr eine Bomb J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zwei Z80 pro Maschine: Wie unterscheiden sich 8-Bit-Arcade-Maschinen von Heimcomputern?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426291/"><h2>  Was ich bei der Erstellung des Emulators √ºber den Arcade-Automaten Bomb Jack gelernt habe </h2><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ea/be5/eae/7eabe5eaeb49a7c8a77b543628df89bf.png"></div><br>  Ich habe k√ºrzlich einen kleinen Emulator f√ºr eine Bomb Jack-Maschine geschrieben, haupts√§chlich um herauszufinden, wie sich diese ersten 8-Bit-Arcade-Maschinen im Design von 8-Bit-Heimcomputern unterscheiden. <br><br>  Wie ich viel sp√§ter erfuhr, war ein Treffen auf einer Sommermesse in meiner Heimatstadt mit Spielautomaten wie Bomb Jack einer dieser Momente, die mein Schicksal ver√§nderten.  An einem normalen Sommertag kehrte ich nach Hause zur√ºck, nachdem ich meinen gesamten Vorrat an M√ºnzen f√ºr Spielautomaten ausgegeben hatte, und mein Kopf war voller Blumen und Soundeffekte.  Ich habe versucht zu verstehen, wie diese Spiele funktionieren.  Und dann verbrachte ich bis zum Ende des Jahres meine ganze Zeit nach der Schule damit, ziemlich verblasste Kopien dieser Arcade-Spiele auf meinem Heimcomputer zu erstellen.  Ich war wie ein Fan des Frachtkultes von den Inseln des Pazifischen Ozeans, der aus St√∂cken einen amerikanischen Milit√§rradiosender schaffen wollte. <br><br>  Zuerst dachte ich √ºber die Idee nach, einen <em>Pengo-</em> Emulator zu entwickeln, weil mein jugendliches Gehirn von diesem Spiel viel mehr beeindruckt war als Bomb Jack (hier ist √ºbrigens meine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frachtkult-Version von Pengo</a> ).  F√ºr Pengo-Arcade-Ger√§te m√ºssten jedoch neue Chip-Emulatoren f√ºr Audio und Video entwickelt werden. F√ºr Bomb Jack gab es bereits gen√ºgend Teile (Z80 als CPU und AY-3-8910 f√ºr Sound), sodass ich als erster Bomb Jack √ºbernahm. <br><a name="habracut"></a><br>  Dar√ºber hinaus war Bomb Jack eine gro√üartige Gelegenheit, meinem Z80-Emulator endlich NMI-Unterst√ºtzung (Non-Maskable Interrupt) hinzuzuf√ºgen.  Keiner der zuvor emulierten Z80-basierten Computer verwendete NMI. Daher war es nicht sinnvoll, diese Funktion neu zu erstellen. Ich konnte den Betrieb immer noch nicht √ºberpr√ºfen. <br><br>  Wenn Sie nicht wissen, was Bomb Jack ist, sah dieses Spiel so aus (nicht sicher, ob ich das richtige Seitenverh√§ltnis gew√§hlt habe): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af7/79a/9ae/af779a9ae761839ee041300bc817c7f6.png" alt="Bomb Jack Screenshot"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_jJzasm63DE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Version des Emulators in WebAssembly finden Sie hier: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://floooh.github.io/tiny8bit/bombjack.html</a> <br><br>  Nachdem der Ladevorgang abgeschlossen ist und die Highscore-Tabelle angezeigt wird, dr√ºcken Sie <strong>1</strong> , um eine M√ºnze fallen zu lassen, und dr√ºcken Sie dann die <strong>Eingabetaste</strong> (oder eine andere Taste au√üer den Pfeilen und der Leertaste), um das Spiel zu starten. <br><br>  Verwenden Sie im Spiel die <strong>Pfeiltasten</strong> , um die Richtung zu √§ndern, und die <strong>Leertaste, um</strong> zu springen.  Dr√ºcken Sie in der Luft die <strong>Leertaste</strong> , um den Sturz zu verlangsamen. <br><br>  Der Quellcode ist hier: <br><br>  <a href="">https://github.com/floooh/chips-test/blob/master/examples/sokol/bombjack.c</a> <br><br>  Es verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chip-Header</a> zur Emulation des Z80 und AY-3-8910 sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sokol-Header</a> als plattform√ºbergreifender Wrapper (zur Eingabe der Anwendung, zum Rendern, zur Eingabe und zum Sound). <br><br><h2>  Schritt 1: Forschung </h2><br>  "Forschung" ist ein zu gro√ües Wort: Ich habe gerade Googles "Bombjack Arcade-Hardware-Spezifikationen" getroffen. <br><br>  Im Vergleich zu den beliebten Heimcomputern der 80er Jahre (oder sogar den mysteri√∂sen osteurop√§ischen Computern, die oft noch aktive Communities haben) gibt es im Internet nur sehr wenige Informationen √ºber Bomb Jack. <br><br>  Ich habe zwei sehr wichtige Informationen gefunden: den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schaltplan der</a> Maschine und nat√ºrlich den <a href="">Quellcode des MAME-Emulators</a> . <br><br>  Es gibt auch ein Projekt, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bomb Jack auf FGPA implementiert</a> , aus dessen VHDL-Quellen ich Details herausfinden konnte, die nicht im Schaltplan enthalten sind. <br><br>  Das Verst√§ndnis des MAME-Quellcodes w√§re schwierig, da Arcade-Maschinenemulatoren normalerweise nur eine Reihe von Makros sind, die beschreiben, wie verschiedene Ger√§te interagieren, aber es <em>gibt</em> nicht viel <em>Quellcode</em> . <br><br>  Trotzdem erwiesen sich die Makrobeschreibungen der Ger√§te und insbesondere die Kommentare immer noch als sehr n√ºtzlich, um den Betrieb der Hardware zu verstehen, und wo sie zu kryptisch wurden (zum Beispiel der <a href="">Teil zur Videodecodierung</a> ), reichten Versuch und Irrtum aus detaillierte Untersuchung des Konzepts. <br><br><h2>  Hardware-√úbersicht </h2><br>  Das Interessanteste an der Bomb Jack-Hardware ist, dass es sich tats√§chlich um <strong>zwei Computer handelt,</strong> die √ºber ein elektrisches Band miteinander verbunden sind: Es gibt eine <strong>Hauptplatine</strong> mit Z80-CPU und Videodecodierungsger√§ten sowie eine separate <strong>Soundkarte</strong> mit eigener Z80-CPU und drei (ja, drei!) Soundchips AY-3-8910. <br><br>  Videodecodierungsger√§te sind nicht als integrierte Schaltung implementiert - es handelt sich nur um viele kleine Allzweckchips (ihre Schaltung ben√∂tigt 6 von 10 Seiten des Schaltplans des Ger√§ts).  Beim Erstellen eines Emulators habe ich mich f√ºr einen kurzen Weg entschieden: Anstatt einzelne Teile des Videodecodierungsger√§ts zu emulieren, habe ich nur dessen Verhalten emuliert, die entsprechende Ausgabe aus den Eingabedaten erstellt und mich nicht wirklich darum gek√ºmmert, wie das Ger√§t selbst in der Mitte funktioniert. <br><br>  Eine solche vereinfachte L√∂sung eignet sich durchaus f√ºr einen separaten Arcade-Automaten, der nur ein Programm ausf√ºhren kann.  Wenn das Spiel startet und korrekt funktioniert, kann die Emulation als "gut genug" angesehen werden. <br><br>  Dar√ºber hinaus ist dieser vereinfachte Ansatz ein wichtiger Unterschied zur Emulation der meisten Heimcomputer: Einige Spiele erfordern eine genauere Emulation als andere. Beispielsweise ben√∂tigen Maschinen wie C64 oder Amstrad CPC eine sehr genaue Emulation bis zu Taktzyklen, sodass Videosysteme einiger Spiele und Grafiken Demos funktionierten korrekt. <br><br>  Dies bedeutet auch, dass meine vorgefertigten CPU- und Soundchip-Emulatoren f√ºr Bomb Jack eigentlich √ºberfl√ºssig sind. Beispielsweise ist die Arbeit mit Z80-CPUs mit der Implementierung der Fraktalit√§t des Maschinenzyklus √ºbertrieben, eine einfachere und schnellere Fragmentierung auf Befehlsebene w√ºrde ausreichen. <br><br><h2>  Hauptplatine </h2><br>  Normalerweise versuche ich beim Schreiben eines neuen Emulators als erstes das Speicherzuweisungsschema herauszufinden (wo sich die Bereiche ROM und RAM, Videospeicher und spezielle Adressen oder Eingabe- / Ausgabeports befinden). <br><br>  Es gibt nur einen ‚Äûinteressanten‚Äú Chip auf der Hauptplatine von Bomb Jack - die Z80-CPU, die mit 4 MHz arbeitet.  Der gesamte verbleibende Speicherplatz auf der Hauptplatine wird von Videodecodierungsger√§ten belegt (mit Ausnahme eines Paares RAM- und ROM-Chips). <br><br>  Der 16-Bit-Adressraum lautet wie folgt: <br><br><ul><li>  <strong>0000..7FFF</strong> : 32 KB ROM </li><li>  <strong>8000..8FFF</strong> : 4 KB Allzweck-RAM </li><li>  <strong>9000..93FF</strong> : 1 KB Videospeicher </li><li>  <strong>9400..97FF</strong> : 1 KB Farb-RAM </li><li>  <strong>9820..987F</strong> : 96 Byte Sprite-RAM </li><li>  <strong>9C00..9CFF</strong> : 256 Byte RAM-Farbpalette </li><li>  <strong>9E00, B000..B005, B800</strong> : Eingabe-Ausgabe-Ports </li><li>  <strong>C000..DFFF</strong> : <strong>8 KB</strong> ROM </li></ul><br>  Der E / A-Portbereich ist wie folgt.  Einige Ports sind schreibgesch√ºtzt, andere schreibgesch√ºtzt und andere haben unterschiedliche Funktionen beim Lesen und Schreiben: <br><br><ul><li>  <strong>9E00</strong> : schreiben: aktuelle Hintergrundbildnummer, lesen: - </li><li>  <strong>B000</strong> : Lesen: Status des Joysticks von Spieler 1, Schreiben: Aktivieren / Deaktivieren der NMI-Maske </li><li>  <strong>B001</strong> : Lesen: Status des Joysticks von Spieler 2, Schreiben: - </li><li>  <strong>B002</strong> : Lesen: M√ºnzen und <strong>Starttasten</strong> , Schreiben: - </li><li>  <strong>B003</strong> : lesen: CPU-Watchdog, schreiben: ??? </li><li>  <strong>B004</strong> : Lesen: DIP-Schalter 1, Schreiben: Schalterbildschirm </li><li>  <strong>B005</strong> : Lesen: DIP-Schalter 2, Schreiben: - </li><li>  <strong>B800</strong> : Schreiben: Befehlssoundkarte, Lesen: - </li></ul><br>  Folgendes ist hier erw√§hnenswert: <br><br><ul><li>  Das Ger√§t verf√ºgt √ºber viel ROM (40 KByte) und sehr wenig RAM (ca. 7 KByte, und nur 4 KByte davon sind "Allzweck-RAM"). </li><li>  F√ºr den RAM der Anzeige sind nur 2 KByte zugeordnet, aufgeteilt in zwei Fragmente von 1 KByte, was f√ºr eine 256 x 256-Vollfarbanzeige, bei der die Farben anscheinend Pixel f√ºr Pixel festgelegt werden, sehr klein erscheint </li><li>  Dies ist ein E / A-System in einem Speicherzuweisungsschema! </li></ul><br>  Die E / A im Speicherzuweisungsschema ist f√ºr eine Z80-Maschine etwas ungew√∂hnlich, da eines der Kennzeichen der Z80 der separate 16-Bit-Adressraum f√ºr E / A ist.  Dies geschieht, um wertvollen Speicheradressraum zu sparen.  Die E / A in einem Speicherzuweisungsschema befindet sich normalerweise in Computern mit einem 6502-Prozessor. <br><br>  Ein Blick auf den Schaltplan best√§tigt dies: Der IORQ-Pin wird auf der CPU der Hauptplatine nicht erkannt, nur der MREQ-Pin ist angeschlossen (der zum Initialisieren des Lesens oder Schreibens in den Speicher verwendet wird): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/99e/3d8/a5899e3d8384702517d0c7fe6c0de436.png" alt="Bomb Jack IORQ"></div><br>  Dies bedeutet, dass wir uns nicht um E / A-Anforderungen f√ºr die CPU-Timer-Funktion der Hauptplatine im Emulator k√ºmmern m√ºssen, sondern nur um Speicheranforderungen. <br><br>  Nachdem ich den Schaltplan studiert hatte, fand ich ein weiteres interessantes Detail √ºber die CPU der Hauptplatine: <br><br>  Es ist nur der NMI-Pin angeschlossen, w√§hrend der INT-Pin immer einen hohen Taktpegel beibeh√§lt / inaktiv bleibt (dies bedeutet, dass die "normalen" maskierten Interrupts nicht ausgef√ºhrt werden und nur nicht maskierte Interrupts auftreten): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/393/acf/cb8/393acfcb88d846cc868e2fa0e490fbbd.png" alt="Bomb Jack IORQ"></div><br>  Dies ist auch f√ºr ein Auto mit dem Z80 recht ungew√∂hnlich.  Bei allen Z80-basierten Heimcomputern, mit denen ich fr√ºher zu tun hatte, war das Gegenteil der Fall - sie verwendeten nur maskierbare Interrupts und niemals nicht maskierbare.  Der maskierte Interrupt Z80 ist eine sehr flexible und ernsthafte Verbesserung im Vergleich zum primitiven Interrupt-System seines ‚Äûunehelichen Vaters‚Äú - Intel 8080 oder seines Konkurrenten - MOS 6502. Diese erh√∂hte Flexibilit√§t ist jedoch auch schwieriger in Ger√§ten zu implementieren (es sei denn, es handelt sich um eine Unterbrechungsquelle Es werden andere Chips der Z80-Familie verwendet, die bereits √ºber ein integriertes komplexes Interrupt-Protokoll verf√ºgen, wenn sie √ºber einen Bus verbunden sind. <br><br>  Na ja, genug Details √ºber die Ausr√ºstung, gehen wir weiter zum Emulator! <br><br><h2>  Startvorgang </h2><br>  Der n√§chste Schritt nach dem Bestimmen der Speicherkonfiguration besteht darin, die emulierte CPU mit dem zugewiesenen Speicherzuordnungsschema zu verbinden, eine Art Visualisierung des Inhalts des Videospeichers aufzuzeichnen und die CPU-Zyklen zu starten. <br><br>  √úberraschenderweise reicht ein derart grober Ansatz oft aus, um den Ladevorgang zu durchlaufen und <em>etwas</em> auf dem Bildschirm anzuzeigen.  Beim Entwerfen des Bomb Jack-Emulators habe ich nur den Inhalt des 1-KB-Videospeichers im Bereich von 0x9000 bis 0x93FF als 32x32-Byte-Matrix verwendet.  Wenn das Byte 0 war, habe ich einen Block schwarzer Pixel 8x8 gerendert, ansonsten einen Block wei√üer Pixel. <br><br>  Dann habe ich einfach die emulierte CPU ausgef√ºhrt und auf das Beste gehofft.  Siehe!  Es erschien ein lesbares Bild: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17d/7c2/198/17d7c2198881dbfd40978e26d832aaca.png" alt="Bomb Jack Boot 1"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3b/e04/b97/d3be04b970ff2c8b5905ed3f7f757a51.png" alt="Bomb Jack Boot 2"></div><br>  Das obere Bild sieht beim Booten wie ein Hardware-Testbildschirm aus, und das untere sieht aus wie ein Score-Record-Bildschirm, der nach Abschluss des Startvorgangs angezeigt wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f6/5ae/4b9/0f65ae4b9d00fa43e2da7582b9ceb5f3.png" alt="Bomb Jack Boot 3"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/649/5c8/db1/6495c8db1d035484ef03e32902f28cdf.png" alt="Bomb Jack Boot 4"></div><br>  ... aber um 90 Grad gedreht (was logisch ist, da sich der Bildschirm von Arcade-Automaten oft in einer vertikalen "Hochformat" -Orientierung befand). <br><br>  Gro√üartig, der Anfang ist vielversprechend! <br><br>  Der n√§chste Schritt besteht darin, herauszufinden, wie diese wei√üen Bl√∂cke in Farbpixel umgewandelt werden k√∂nnen ... (und dies ist ein gro√üer Schritt. Details werden unten im Abschnitt zur Videodecodierung beschrieben). <br><br>  Zuerst ging alles ziemlich schnell, auf dem Testbildschirm wurden Pixel und Farben beim Laden angezeigt (sp√§ter bemerkte ich, dass die Farbdecodierung v√∂llig falsch war und doch ...): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/ecd/757/2c3ecd757e603194698f6f93b71e3127.png" alt="Bomb Jack Boot 5"></div><br>  Aber als der Aufnahmebildschirm erscheinen sollte, bekam ich einen schwarzen Bildschirm.  Als ich die Hintergrundfarbe so hackte, dass sie ‚Äûnicht schwarz‚Äú ist, stellte ich fest, dass die Pixel gerendert werden, aber die gesamte Farbpalette schwarz ist.  Hmm ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e81/dac/2e4/e81dac2e4796b7bf90d43a711a52f37e.png" alt="Bomb Jack Boot 5"></div><br>  Nachdem ich ein paar Minuten auf diesen Bildschirm geschaut hatte, fiel mir ein, dass einige der Farben auf dem Highscore-Bildschirm animiert sind und wenn es eine Animation gibt, sollte es eine Art Timer geben.  Die logische Zeitquelle in dieser Ger√§tekonfiguration ist das VSYNC-Anzeigesignal, und VSYNC ist mit dem NMI-Pin der CPU verbunden (oder besser gesagt nicht mit VSYNC, sondern mit VBLANK, dem kurzen Moment zwischen dem VSYNC-Signal und dem Kathodenstrahl, der sich in die obere linke Ecke bewegt). <br><br>  Und das alles habe ich noch nicht umgesetzt ... <br><br>  Als ich am n√§chsten Abend die erste Version der NMI-Verarbeitung zur Z80-Emulation hinzuf√ºgte und sie mit dem ersten Z√§hler vsync / vblank in der CPU-Timer-Funktion der Hauptplatine verband, begannen pl√∂tzlich viele Dinge zu passieren! <br><br>  Zun√§chst wurden Farben auf dem Bildschirm der Aufzeichnungen angezeigt und einige davon wurden animiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/163/661/72d/16366172d4eb6b8e2342acbbd74a64ac.png" alt="Bomb Jack NMI 1"></div><br>  Nach ein paar Sekunden begann etwas noch Aufregenderes!  Der Highscore verschwand und eine seltsame Visualisierung der ersten Karte wurde angezeigt.  Es war klar, dass dies ein Demo-Modus eines Arcade-Automaten ist, um Aufmerksamkeit zu erregen. Ich sah mehrere Bomben mit Farbanimationen, die verschwanden, als ein imagin√§rer Bomb Jack auf eine Karte sprang und diese Bomben sammelte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/cd6/81d/d60cd681dedbdfbf4329410e0014f9f0.png" alt="Bomb Jack NMI 2"></div><br>  Die Farben waren immer noch v√∂llig falsch und doch ist es PROGRESS! <br><br>  Es ist der richtige Zeitpunkt, um den Rest der Videodekodierung durchzuf√ºhren: <br><br><h2>  Video B√ºgeleisen </h2><br>  Auf den ersten Blick sah das Videoverarbeitungsger√§t in Bomb Jack f√ºr eine 8-Bit-Maschine aus dem Jahr 1984 sehr leistungsf√§hig aus: Trotz der Aufl√∂sung von nur 256 x 256 Pixel konnte es gleichzeitig 128 (von 4096) Farben anzeigen und bis zu 24 Hardware-Sprites (16 x 16 Pixel) rendern. oder 32x32) mit Pixel f√ºr Pixel Farbe. <br><br>  8-Bit-Heimcomputer hatten zu dieser Zeit ungef√§hr die gleiche Bildschirmaufl√∂sung, aber viele Farbbeschr√§nkungen.  Diese Einschr√§nkungen werden beim Vergleich der Bomb Jack-Versionen f√ºr den ZX Spectrum- und Amstrad-CPC mit der Version f√ºr den Arcade-Automaten sehr deutlich: <br><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version f√ºr das ZX Spectrum</a> hatte eine ziemlich gute Pixelaufl√∂sung (256 x 192), aber nur sehr wenige Farben und litt unter dem typischen ‚ÄûFarbkonflikt‚Äú -Effekt von Spectrum (obwohl die Entwickler sich sehr bem√ºhten, damit es nicht zu auffiel): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46d/176/fff/46d176fffb8404ad696883849dd880d1.png" alt="Bombenheber zx"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Version f√ºr Amstrad CPC ist</a> farbiger, aber um mehr Farben zu erhalten, mussten die Entwickler in den Anzeigemodus mit niedriger Aufl√∂sung (160 x 200) wechseln.  Infolgedessen verwandelten sich Jack und die Monster in unleserliche Pixel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/f33/3d8/bbdf333d8e4d8d44735047f99e53b49c.png" alt="Bomb Jack CPC"></div><br>  Vergleichen Sie dies mit der Version f√ºr den Arcade-Automaten, die dieselbe Pixelaufl√∂sung wie das ZX Spectrum hatte, jedoch viel mehr Farben <em>und eine</em> pixelweise Farbaufl√∂sung aufwies: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/112/ac5/69f/112ac569f11f32d6c1ed4836bb8c2b51.png" alt="Bomb Jack Arcade"></div><br>  Interessant ist hier, dass die Arcade-Version bessere Grafiken hat, nicht weil sie auf leistungsf√§higerer Hardware funktioniert (sie hat mehr ROMs zum Speichern von mehr Grafikdaten, aber die "Rechenleistung" ist ungef√§hr gleich), sondern weil sich die Entwickler des Ger√§ts konzentrieren k√∂nnten √ºber die Herstellung einer speziellen Maschine f√ºr eine bestimmte Art von Spiel und sie mussten keinen universellen Heimcomputer f√ºr den allgemeinen Gebrauch erstellen. <br><br>  So funktioniert die Display-Hardware (zumindest in meiner High-Level-Interpretation): <br><br><h2>  Drei Anzeigeebenen </h2><br>  Das fertige Bomb Jack-Videosignal wird aus drei Ebenen kombiniert: einer Hintergrundebene, einer Frontebene und einer Sprite-Ebene. <br><br>  Ein solches Schichtsystem hat zwei Hauptvorteile: <br><br><ul><li>  Es implementiert eine ziemlich knifflige Hardware-Bildkomprimierung, um aus einer sehr kleinen Datenmenge ein Vollfarbenbild mit hoher Aufl√∂sung zu erzeugen. </li><li>  Dies reduziert den CPU-Aufwand f√ºr die Aktualisierung dynamischer Bildschirmelemente erheblich (selbst bei einer Frequenz von 4 MHz verf√ºgt eine 8-Bit-CPU nicht √ºber gen√ºgend Leistung, um so viele Objekte auf einem 256 x 256-Display mit einer Frequenz von 60 Hz zu bewegen). </li></ul><br>  Das Video-B√ºgeleisen unterscheidet sich erheblich von dem, was ich bei 8-Bit-Heimcomputern gesehen habe, aber MAME implementiert allgemeine Hilfsklassen f√ºr diese Art von Ausr√ºstung, sodass ich davon ausgehen kann, dass es bei Arcade-Automaten durchaus √ºblich ist. <br><br><h3>  Hintergrundschicht </h3><br>  Die Hintergrundebene kann 1 von 5 im ROM eingebetteten Hintergrundbildern rendern.  Das Hintergrundbild wird ausgew√§hlt, indem ein Wert von 1 bis 5 an die Adresse 0x9E00 geschrieben wird (es scheint, dass der Wert 0 etwas Besonderes ist und einen vollst√§ndig schwarzen Hintergrund ergibt). <br><br>  Tats√§chlich scheint das Ger√§t in der Lage zu sein, 7 verschiedene Bilder zu rendern, aber das Spiel verwendet nur 5. Insgeheim hatte ich gehofft, zuvor unentdeckte Bilddaten im ROM zu finden.  Aber leider sind sie nicht da (ja, wahrscheinlich bin ich nicht der erste, der sie dort sucht). <br><br>  So sieht die Hintergrundebene der ersten Karte ohne die beiden anderen Ebenen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afe/75a/2c7/afe75a2c7386bb48fb3e90e2a24a655e.png" alt="Bomb Jack Hintergrund"></div><br>  Die Hintergrundebene besteht aus <strong>16</strong> x <strong>16</strong> Pixel gro√üen Kacheln. <br><br>  Der Vorteil des Erstellens von Hintergrundbildern aus Kacheln besteht darin, dass dieselben Kacheln mehrmals verwendet werden k√∂nnen, sodass weniger Daten im ROM gespeichert werden k√∂nnen.  Beachten Sie, dass der blaue Himmel, Teile der Pyramide und Sand unter der Pyramide dieselben Kacheln verwenden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/613/0ee/4226130ee4b597ccbeccebbce664dbdf.png" alt="Bomb Jack Hintergrundfliesen"></div><br>  Um Speicherplatz zu sparen, implementiert die Hintergrundschichtausr√ºstung einen weiteren Trick - Kacheln k√∂nnen horizontal gedreht werden.  Ich habe dies in meiner Implementierung fast √ºbersehen, weil ich angenommen habe, dass die Software diese Hardwarefunktion nicht verwendet, aber einen kleinen Fehler im Hintergrund der dritten Karte festgestellt habe: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22d/397/d5c/22d397d5c5b984b8a7b1e7c53e5abd34.png" alt="Bomb Jack Hintergrund 3"></div><br>  Ich habe den gleichen Trick auf der f√ºnften Karte angewendet, aber hier ist es etwas schwieriger zu bemerken, wenn Sie nicht wissen, wonach Sie suchen sollen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4af/82d/430/4af82d430deab8804a795ac9fb142b87.png" alt="Bomb Jack Hintergrund 5"></div><br><br><h3>  Vorderschicht: </h3><br>  √úber der Hintergrundebene befindet sich die ‚Äûvordere Ebene‚Äú, die alle festen Teile des Bildschirms darstellt, die dennoch von der CPU aktualisiert werden m√ºssen (haupts√§chlich Text, Plattformen und Bomben).  Das Layout wird aus dem RAM gelesen (aus Fragmenten von 1-KB-RAM und 1-KB-Farb-RAM). <br><br>  So sieht die isolierte vordere Ebene der ersten Karte aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/874/5ac/fa8/8745acfa89c446ba9b5a9d9e719c8d31.png" alt="Bombenheber"></div><br>  Die vordere Ebene besteht ebenfalls aus Kacheln (sowie dem Hintergrund), verwendet jedoch kleinere 8x8-Kacheln: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/e26/f94/5a9e26f94d1d9e0df0f50f4f1d1beb78.png" alt="Bomb Jack Hintergrundfliesen"></div><br>  Der Hauptvorteil der Aufteilung von Hintergrund und Front in separate Ebenen besteht darin, dass sich die CPU beim Erstellen oder L√∂schen von Frontelementen nicht um das Speichern und Wiederherstellen von Hintergrundpixeln k√ºmmern muss. <br><br><h3>  Sprite-Schicht </h3><br>  Schlie√ülich werden Hardware-Sprites √ºber die vordere Ebene gerendert.  Alles, was sich auf dem Bildschirm bewegt, wird in Sprites implementiert.  Bomb Jack-Ger√§te k√∂nnen bis zu 24 Sprites rendern, und jedes Sprite kann eine Gr√∂√üe von 16 x 16 oder 32 x 32 Pixel haben.  In diesem Fall k√∂nnen Sprites pixelgenau positioniert werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/66e/5a0/27666e5a0a266d28babf72dafe2e66bc.png" alt="Bomb Jack Sprites"></div><br><br><h2>  8x8 Fliesendecoder </h2><br>  Das Herzst√ºck der Videodecodierungsausr√ºstung ist eine Farbpalette mit 128 Elementen und einem Kacheldecoder mit 8 x 8 Pixeln.  Die Aufgabe des Kacheldecoders besteht darin, einen 7-Bit-Farbpalettenindex f√ºr jedes der 64 Pixel der Kachel zu erzeugen. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese 8x8-Kacheln sind die Bausteine ‚Äã‚Äãf√ºr alles auf dem Bildschirm - 16x16-Hintergrundkacheln, 8x8-Kacheln f√ºr die vordere Ebene und 16x16- oder 32x32-Hardware-Sprites. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Blockdiagramm dieses 8x8-Kacheldecoders zum Rendern der vorderen Ebene (wie ich es verstanden habe):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/d6e/5d9/e79d6e5d9b5019923a37bc14658e8ec4.jpg" alt="Bomb Jack Tile Decodierung"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erkl√§rung des Top-Down-Blockdiagramms: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Decodierungsprozess beginnt oben mit dem Lesen des Bytes des ‚ÄûKachelcodes‚Äú aus dem Videospeicher (organisiert als Matrix aus 32x32-Kachelcodes) und eines separaten Bytes aus dem Farb-RAM (ebenfalls eine 32x32-Matrix). </font><font style="vertical-align: inherit;">Das Abrufen der Codes f√ºr Kacheln und Farben aus dem Videospeicher erfolgt nur f√ºr die vordere Ebene. Ich habe sie jedoch hinzugef√ºgt, um das Bild insgesamt verst√§ndlicher zu machen. </font><font style="vertical-align: inherit;">Der 8x8-Kacheldecoder selbst ben√∂tigt nur einen Kachel- und Farbcode am Eingang.</font></font></li><li>             .         (         ).         ,       ,    (       ). </li><li>       8   ,     8  (   ).            ,  ,       8x8  24    (3   ). </li><li>    64    7- .  3         ,   4  ‚Äî    .  ,  ,           16 ¬´¬ª,     8 .        8     . </li><li>  7- ,        ,    12-  RGB-    (4    ).            (  ,  ,       ;   ,          ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist ein allgemeines Kacheldecodierungsschema, das von jeder der drei Anzeigeebenen verwendet wird, aber die Decodierung jeder Ebene unterscheidet sich geringf√ºgig: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die vordere Ebene kann tats√§chlich 512 verschiedene 8x8-Kacheln rendern. </font><font style="vertical-align: inherit;">Dies erfordert 9-Bit-Kachelcodes, aber der Videospeicher bietet nur 8 Bit pro Kachel. </font><font style="vertical-align: inherit;">Das neunte Bit wird aus dem f√ºnften Bit des Farbwerts "entlehnt" (da nur 4 Bits des Farbwerts zum Erstellen des Farbpalettenindex verwendet werden, verbleiben 4 weitere Bits f√ºr andere Zwecke). </font><font style="vertical-align: inherit;">Wenn alle 3 Bits aus den 8x8-Kachelbitschichten gleich Null sind, wird das vordere Pixel als transparent betrachtet und das Hintergrundpixel "durchscheint" es.</font></font></li><li>      16x16,     16x16=256     256           (512   ).    ,     16x16      8x8,        .   ,      ;      ¬´¬ª   :   7   ,    . </li><li>       16x16   32x32 ,       4  16   8x8    .  ,    16x16  96 ,    32x32 ‚Äî    384    .       ,   3      ,    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um besser zu verstehen, wie Kachelbitebenen aussehen, habe ich ein kleines </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-Programm geschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das ROM-Kacheln in PNG-Dateien konvertiert (3 Bits pro Pixel, konvertiert in 8 Graustufenebenen). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Folgende zeigt die ROM-Kacheln der vorderen Schicht. </font><font style="vertical-align: inherit;">Wir sehen Zahlen und Textschriftdaten, Plattformkacheln, Bomben (in zwei H√§lften geteilt), Teile des Logos des Bomb Jack-Bildschirmschoners und die Anzahl der Punkte-Multiplikatoren, die oben auf dem Bildschirm angezeigt werden (√ºbrigens ist alles um 90 Grad gedreht, da auch der gesamte Bildschirm gedreht ist ):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/681/ca4/fec/681ca4fec37418dffeb4d601b9e787cf.png" alt="Bomb Jack Vordergrundfliesen-ROM"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie als n√§chstes die ROM-Kacheln des Hintergrunds. </font><font style="vertical-align: inherit;">Es sieht nicht sehr klar aus, denn wir beobachten tats√§chlich, dass 16x16-Kacheln in 8x8-Kacheln dekodiert werden. </font><font style="vertical-align: inherit;">Jede 16x16-Kachel wird aus vier benachbarten 8x8-Kacheln erstellt. </font><font style="vertical-align: inherit;">Aber Sie k√∂nnen Teile des griechischen Tempels von Karte 2, die Burg von Karte 3 und Wolkenkratzer von Karte 4 erkennen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/fa9/86d/ebcfa986da9add0a45acc02b54bcb69e.png" alt="Bomb Jack Hintergrund Kachel ROM"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und schlie√ülich ROM-Sprite-Kacheln. </font><font style="vertical-align: inherit;">16x16 Sprites belegen die obere H√§lfte und 32x32 Sprites die untere H√§lfte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/974/01e/44497401e4d25c7915f1c15c9fb9f4ac.png" alt="Bomb Jack Sprite Fliesen ROM"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein interessanter Hack des Bomb Jack-Bildschirmschoners ist, dass das Logo aus Frontkacheln und Sprites zusammengesetzt ist. </font><font style="vertical-align: inherit;">Ich denke, dass den Entwicklern die vorderen Kachel-ROMs ausgegangen sind, aber im Sprite-ROM war nur noch wenig Platz:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/939/bd5/b69/939bd5b6999622ee26e337f033087234.png" alt="Bomb Jack Splash 1"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d9/fef/f2a/6d9feff2acdd4ee2aaa63b8dc4226692.png" alt="Bomb Jack Splash 2"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/819/bb9/072/819bb90727322463b2c8a9196f6f74c2.png" alt="Bomb Jack Splash 3"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprite-Ausr√ºstung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Sprite-Ausr√ºstung von Bomb Jack ist sehr leistungsf√§hig im Vergleich zu den damaligen Heimcomputern: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es k√∂nnen bis zu 24 Hardware-Sprites gerendert werden. </font><font style="vertical-align: inherit;">Es scheint, dass es keine Einschr√§nkungen hinsichtlich der Anzahl der Sprites pro Scanzeile gab.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprites k√∂nnen eine Gr√∂√üe von 16 x 16 Pixel oder 32 x 32 Pixel haben </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jedes Sprite kann einen von 16 Slots mit 8 Farben in einer gemeinsamen Farbpalette ausw√§hlen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprites hatten eine Pixel-f√ºr-Pixel-Farbaufl√∂sung. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jedes Sprite kann vertikal oder horizontal gespiegelt werden </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jedes Sprite kann eines von 128 Sprite-Bildern ausw√§hlen, die im ROM geflasht wurden. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Dekodieren von Pixeln und Sprites eines Sprite-Systems wird dieselbe 8x8-Basiskachel verwendet wie in den Hintergrund- und Frontebenen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprite-Attribute befinden sich im Adressbereich von 0x9820 bis 0x987F - 96 Byte, 4 Byte pro Sprite. </font><font style="vertical-align: inherit;">Soweit ich gesehen habe, dient dieser Bereich nur zur Aufnahme; </font><font style="vertical-align: inherit;">Zumindest f√ºhrt die CPU keinen Lesezugriff auf diesen Speicherbereich durch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Sprite wird durch 4 Bytes beschrieben:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wenn gesetzt, ist dies ein 32x32-Sprite, andernfalls 16x16</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits 6..0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 7 Bits zum Festlegen des Codes der Sprite-Kachel, die zum Suchen nach Bitebenen des Sprite-Bilds in den ROM-Kacheln verwendet wird.</font></font></li></ul></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wenn gesetzt, wird das Sprite horizontal gespiegelt</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 6</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wenn gesetzt, wird das Sprite vertikal gespiegelt</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits 3..0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 4 Bits zum Einstellen des Farbwerts f√ºr den </font><strong><font style="vertical-align: inherit;">Kacheldecoder</font></strong></font></li></ul><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Sprite-Position der X-Achse auf dem Bildschirm</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Position des Sprites auf dem Bildschirm entlang der Y-Achse</font></font></li></ul><br>  Es ist nicht klar, was die Bits 4 und 5 von Byte 1 tun, der Kommentar in MAME sagt dies: <br><br> <code>e ? (,    ) <br> f ? (,     (B)?)</code> <br> <br><h2>  Speicher-E / A-Ports </h2><br>  Einige Hinweise zu den Eingangs- / Ausgangsanschl√ºssen der Hauptplatine.  Wie oben erw√§hnt, sehen die E / A-Ports folgenderma√üen aus: <br><br><ul><li>  <strong>9E00</strong> : schreiben: aktuelle Hintergrundbildnummer, lesen: - </li><li>  <strong>B000</strong> : Lesen: Status des Joysticks von Spieler 1, Schreiben: Aktivieren / Deaktivieren der NMI-Maske </li><li>  <strong>B001</strong> : Lesen: Status des Joysticks von Spieler 2, Schreiben: - </li><li>  <strong>B002</strong> : Lesen: M√ºnzen und <strong>Starttasten</strong> , Schreiben: - </li><li>  <strong>B003</strong> : lesen: CPU-Watchdog, schreiben: ??? </li><li>  <strong>B004</strong> : Lesen: DIP-Schalter 1, Schreiben: Schalterbildschirm </li><li>  <strong>B005</strong> : Lesen: DIP-Schalter 2, Schreiben: - </li><li>  <strong>B800</strong> : Schreiben: Befehlssoundkarte, Lesen: - </li></ul><br>  Die Adresse 0x9E00 (Auswahl des Hintergrundbilds), die wir oben bereits ber√ºcksichtigt haben, und die Adresse 0xB800 (Befehlssoundkarte) werden wir im n√§chsten Abschnitt ber√ºcksichtigen.  Bleibt die Adressen von 0xB000 bis 0xB005: <br><br>  Das Lesen von den Adressen 0xB000 und 0xB001 gibt den aktuellen Status der beiden Joysticks zur√ºck.  Festgelegte Bytes zeigen geschlossene Joystick-Schalter an: <br><br><ul><li>  <strong>Bit 0</strong> : richtige Richtung </li><li>  <strong>Bit 1</strong> : linke Richtung </li><li>  <strong>Bit 2</strong> : Aufw√§rtsrichtung </li><li>  <strong>Bit 3</strong> : Abw√§rtsrichtung </li><li>  <strong>Bit 4</strong> : Sprungtaste gedr√ºckt </li></ul><br>  Die restlichen 3 Bits werden ignoriert. <br><br>  Das Lesen von 0xB002 gibt den Status des M√ºnzpr√ºfers und der Starttasten zur√ºck: <br><br><ul><li>  <strong>Bit 0</strong> : Spieler 1 M√ºnze wird geworfen </li><li>  <strong>Bit 1</strong> : Spieler 2 M√ºnze wird geworfen </li><li>  <strong>Bit 2</strong> : Starttaste f√ºr Spieler 1 </li><li>  <strong>Bit 3</strong> : Startknopf f√ºr Spieler 2 </li></ul><br>  Das Lesen von den Adressen 0xB004 und 0xB005 gibt den Status der Dip-Schalter zur√ºck, mit denen das Verhalten des Arcade-Automaten konfiguriert wird: <br><br><ul><li>  <strong>B004</strong> : <br><ul><li>  <strong>Bits 0,1</strong> : Wie viele ‚ÄûSpiele‚Äú gibt es f√ºr eine M√ºnze (1, 2, 3 oder 5)? </li><li>  <strong>Bits 2,3</strong> : Gleiches gilt f√ºr Spieler 2 </li><li>  <strong>Bits 4,5</strong> : Wie viele Leben pro Spiel (3, 4, 5 oder 2) </li><li>  <strong>Bit 6</strong> : Die Position des Arcade-Automaten: "Cocktail-Tisch" oder "vertikal". </li><li>  <strong>Bit 7</strong> : Gibt an, ob im Standby-Modus Ton abgespielt werden soll </li></ul></li><li>  <strong>B005</strong> : <br><ul><li>  <strong>Bits 3.4</strong> : Schwierigkeitsgrad 1 (Vogelgeschwindigkeit) </li><li>  <strong>Bits 5,6</strong> : Schwierigkeitsgrad 2 (Anzahl und Geschwindigkeit der Feinde) </li><li>  <strong>Bit 7</strong> : H√§ufigkeit des Auftretens einer bestimmten M√ºnze </li></ul></li></ul><br>  Schlie√ülich implementiert das Lesen von Adresse <strong>B003</strong> einen Software-Watchdog.  Die CPU muss h√§ufig von dieser Adresse lesen, sonst f√ºhrt der Arcade-Computer einen Hardware-Reset durch.  Wenn das Spiel aus irgendeinem Grund abst√ºrzt, wird das Ger√§t automatisch neu gestartet. <br><br>  Sie k√∂nnen an einige E / A-Portadressen schreiben: <br><br><ul><li>  <strong>B000</strong> : ob NMI w√§hrend vblank generiert werden soll;  scheint nur w√§hrend des Startvorgangs deaktiviert zu sein </li><li>  <strong>B004</strong> : den gesamten Bildschirm umdrehen;  Ich habe die Verwendung dieser Funktion noch nie erlebt, aber ich habe eine Theorie dar√ºber (siehe unten). </li></ul><br>  Die Funktion zum Umdrehen des Bildschirms ist etwas verwirrend, da ich beim Spielen eines Spiels nie gesehen habe, wie es verwendet wird.  Ich habe jedoch eine Ahnung, was er tut, aber um dies zu best√§tigen, m√ºssen Sie Code schreiben.  Wenn sich der Arcade-Automat in der Konfiguration ‚ÄûCocktail Table‚Äú befindet, sitzen sich zwei Spieler gegen√ºber.  Daher schlug ich vor, dass diese Funktion den Bildschirm umdreht, wenn ein Spiel von Spieler 1 zu Spieler 2 wechselt.  Ich habe den Zwei-Spieler-Modus jedoch noch nicht im Emulator implementiert. <br><br><h2>  Soundkarte </h2><br>  Die Soundkarte selbst ist ein voll ausgestatteter Computer mit einer Z80-CPU (mit einer Frequenz von 3 MHz), drei Soundchips (AY-38910 mit einer Frequenz von 1,5 MHz) sowie RAM und ROM.  Das Speicherzuweisungsschema der Soundkarte sieht ziemlich einfach aus: <br><br><ul><li>  <strong>0000..2000</strong> : 8 KB ROM </li><li>  <strong>4000..4400</strong> : 1 KB RAM </li><li>  <strong>6000</strong> : Soundbefehl von der Hauptplatine </li></ul><br>  Da das Speicherzuordnungsschema oberhalb der 0x8000-Adresse nichts Interessantes enth√§lt, ist der oberste Adresskontakt der CPU nicht einmal verbunden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2f/4ea/35e/b2f4ea35ee4d2861ea1baa502da10837.png" alt="Bomb Jack Sound A15"></div><br>  Die spezielle Adresse 0x6000 ist der im Speicher befindliche E / A-Port (8-Bit-Latch), der nicht dem realen RAM entspricht.  Dies ist derselbe Port, der sich auf der Hauptplatine bei 0xB800 befindet.  Es ist ein Kommunikationskanal zwischen der Haupt- und der Soundkarte. <br><br>  Die drei Soundchips werden von diesen Z80-Ausgabeanweisungen gesteuert, nicht √ºber die Speicheranschl√ºsse.  In AY-3-8910 sind nur zwei E / A-Ports ge√∂ffnet, der erste dient zum Speichern der Registernummer und der zweite zum Schreiben oder Lesen des Inhalts des vom ersten Port angegebenen Registers. <br><br>  Die E / A-Schaltung ist wie folgt: <br><br><ul><li>  <strong>0x00</strong> : erster Soundchip: Registerauswahl </li><li>  <strong>0x01</strong> : erster Soundchip: Zugriff auf das ausgew√§hlte Register </li><li>  <strong>0x10</strong> : zweiter Soundchip: Registerauswahl </li><li>  <strong>0x11</strong> : zweiter Soundchip: Zugriff auf das ausgew√§hlte Register </li><li>  <strong>0x80</strong> : dritter Soundchip: Registerauswahl </li><li>  <strong>0x81</strong> : dritter Soundchip: Zugriff auf das ausgew√§hlte Register </li></ul><br>  Ein paar Worte zum Soundchip AY-3-8910: <br><br>  Dies ist ein ziemlich Standardger√§t, das in Heimcomputern dieser Zeit sehr beliebt ist (z. B. in Amstrad CPC, ZX Spectrum 128, in MSX-Computern und vielen anderen).  AY-3-8910 brachte viele Variationen und Klone hervor (zum Beispiel Yamaha YM2149, das an sich die Grundlage f√ºr eine ganze Familie leistungsst√§rkerer Soundchips wurde). <br><br>  AY-3-8910 verf√ºgt √ºber 3 Kan√§le mit rechteckigen Signalen, einen Rauschgenerator, der mit drei Kan√§len gemischt werden kann, und einen H√ºllkurvengenerator.  Da es f√ºr alle drei Kan√§le nur einen H√ºllkurvengenerator gab, war dies nicht besonders n√ºtzlich, und die meisten Spiele verwendeten eine CPU, um Ton und Lautst√§rke zu modulieren. <br><br>  Dies bedeutet, dass der AY-3-8910-Chip mehr CPU-Eingriffe erfordert, um einen qualitativ hochwertigen Sound zu erzeugen (im Gegensatz zu mehr eigenst√§ndigen SID-Chips, beispielsweise in einem C64-Computer). <br><br>  Es ist erstaunlich zu sehen, was mit drei ziemlich einfachen Soundchips und der CPU, die sie steuert, gemacht werden kann.  Die Musik und Soundeffekte von Bomb Jack sind viel reicher als ich es in den meisten Heimcomputerspielen geh√∂rt habe. <br><br>  Das einzige, was an dieser Soundkarte wirklich interessant ist, ist die Art und Weise, wie sie ihre Befehle von der Hauptplatine empf√§ngt. <br><br><h2>  Sound Command Latch </h2><br>  Der ‚ÄûSound Latch‚Äú ist ein Einzelbyte-Speicher (8-Bit-Latch), der den Haupt- und Soundkarten gemeinsam ist.  Der Latch ist an die Adresse 0xB800 auf der Hauptplatine und an die Adresse 0x6000 auf der Soundkarte gebunden. <br><br>  Wenn der NMI-Interrupt mit VSYNC eingeschaltet wird, f√ºhrt die Soundkarte eine sehr einfache Interrupt-Serviceroutine durch, die den Hardware-Latch liest, in die normale Speicheradresse schreibt und das ‚ÄûSignalbit‚Äú setzt, das der ‚ÄûHauptschleife‚Äú mitteilt, dass ein neuer Soundbefehl empfangen wurde: <br><br><pre> <code class="plaintext hljs"> ex af,af' ;0066 exx ;0067 ld hl,04390h ;0068 set 0,(hl) ;006b ld a,(06000h) ;006d ld (04391h),a ;0070 exx ;0073 ex af,af' ;0074 retn ;0075</code> </pre> <br>  Die NMI-Kontaktaktivierungsmethode unterscheidet sich geringf√ºgig von der Hauptplatinenmethode: <br><br>  Auf der Hauptplatine wird der NMI-Pin f√ºr die Dauer des VBLANK-Laufs aktiv. <br><br>  Auf der Soundkarte wird NMI jedoch aktiviert, wenn VSYNC ausgel√∂st wird, und bleibt nicht w√§hrend der VBLANK aktiv, sondern bis die Interrupt-Service-Prozedur die Daten aus dem Latch bei 0x6000 liest. <br><br>  Wenn das Ger√§t das Lesen von der Adresse 0x6000 erkennt, f√ºhrt es zwei fest codierte Operationen aus: <br><br><ul><li>  Der Inhalt des Soundclips wurde auf 0 zur√ºckgesetzt </li><li>  Der NMI-Kontakt wird inaktiv </li></ul><br>  Tats√§chlich ist dies eine einfache Eliminierung des Kontaktsprungs, bei der ein Soundbefehl nicht zweimal ausgef√ºhrt werden kann. <br><br>  Die Frage bleibt nur: Wie oft schreibt die Hauptplatine einen neuen Befehl (da die Art und Weise, wie die Emulation von zwei Platinen implementiert wird, davon abh√§ngt). <br><br>  Nach dem Debuggen mit printf stellte ich fest, dass die Hauptplatine h√∂chstens einen Soundbefehl pro 60-Hz-Frame aufzeichnet.  Dies vereinfachte die Struktur des "Hauptzyklus" des Emulators erheblich. <br><br>  Das Problem der gemeinsamen Arbeit zweier separater emulierter Computer, die Daten miteinander austauschen m√ºssen, besteht darin, dass die Emulation eines Computers nur dann wirksam ist, wenn mehrere Zyklen gleichzeitig ohne Interferenz ausgef√ºhrt werden k√∂nnen. <br><br>  Der schlimmste Fall w√§re zum Beispiel: <br><br><ul><li>  Wir f√ºhren eine Anweisung in Computer 1 aus </li><li>  Wir f√ºhren eine Anweisung in Computer 2 aus </li><li>  wiederholen ... </li></ul><br>  Mein Z80-Emulator ist nicht f√ºr das Beenden und Eingeben der Emulation f√ºr jeden Befehl optimiert, da er in diesem Fall in den Speicher sp√ºlen und den Status der CPU am Anfang und Ende jedes Befehls aus dem Speicher laden sollte.  Wenn die CPU viele Befehle st√∂rungsfrei verarbeiten kann, k√∂nnen Sie den gr√∂√üten Teil des CPU-Zustands in den Registern speichern und den Zustand des letzten Befehls auf den Speicher zur√ºcksetzen. <br><br>  Das hei√üt, eine ideale Situation w√§re folgende: Wir f√ºhren ein emuliertes System ohne Interferenz √ºber den gesamten Frame des Host-Systems aus (f√ºr eine CPU mit einer Frequenz von 4 MHz und 60 Hz bedeutet dies ungef√§hr 67.000 Zyklen pro Frame oder irgendwo zwischen 3.000 und 16.000 Anleitung Z80). <br><br>  Bei der Arbeit mit Bomb Jack musste ich sicherstellen, dass die Hauptplatine keinen neuen Befehl aufzeichnet, bevor die Soundkarte den letzten Befehl lesen kann.  Bevor ich herausfand, dass die Hauptplatine nicht mehr als einen Befehl pro Frame aufzeichnet, √ºberlegte ich, ob eine komplexe Befehlswarteschlange erstellt werden muss, die Aufzeichnungen im Sound-Latch der Hauptplatine abf√§ngt und die Zyklusnummer und das Befehlsbyte in der Warteschlange speichert. <br><br>  Zu dem Zeitpunkt, als die Soundkarte ihren Frame ausf√ºhrte, nahm sie einen neuen Befehl aus der Befehlswarteschlange entgegen, wenn die Befehlszyklusnummer erreicht war. <br><br>  Ein solches System w√ºrde funktionieren und ‚Äûkorrekt‚Äú sein, aber die Komplexit√§t des Codes erheblich erh√∂hen. <br><br>  Am Ende entschied ich mich f√ºr eine viel einfachere L√∂sung ohne Warteschlangen.  Da die Hauptplatine nur einen Befehl pro Frame aufzeichnet, habe ich die Ausf√ºhrung auf zwei Computern abwechselnd ausgef√ºhrt, sodass jeder von ihnen zwei Zeitscheiben pro Frame ausf√ºhrte: <br><br><ul><li>  F√ºhren Sie die erste H√§lfte des Rahmens auf der Hauptplatine aus </li><li>  F√ºhren Sie die erste H√§lfte des Frames auf der Soundkarte aus </li><li>  F√ºhren Sie die zweite H√§lfte des Rahmens auf der Hauptplatine aus </li><li>  F√ºhren Sie die zweite H√§lfte des Frames auf der Soundkarte aus </li></ul><br>  Dies stellt sicher, dass die Soundkarte jeden von der Hauptplatine aufgezeichneten Befehl korrekt sieht und gleichzeitig jede Emulation f√ºr Tausende von Zyklen ausf√ºhren kann. <br><br>  Die Tatsache, dass das Host-System mit einer Bildrate von 60 Hz arbeitet, ist nat√ºrlich eine sehr k√ºhne Annahme :) <br><br><h2>  Und der letzte ... </h2><br>  Die letzte interessante Tatsache √ºber die Emulatorversion in WebAssembly: <br><br>  Komprimierte Gr√∂√üe aller heruntergeladenen Dateien beim Ausf√ºhren des Emulators in WebAssembly <br>  ungef√§hr gleich 113 KByte: <br><br><ul><li>  ca. 2,5 KB f√ºr HTML, CSS und "handgeschriebenes" JS </li><li>  26,8 KB pro emscripten Laufzeit-JS-Datei </li><li>  83,7 KB pro WASM-Datei </li></ul><br>  Die WASM-Datei enth√§lt die integrierten ROMs des Arcade-Automaten. <br><br>  Unkomprimiert belegen diese ROMs 112 KB. <br><br>  Das hei√üt, der <strong>gesamte</strong> komprimierte Emulator mit integrierten ROMs belegt fast das gleiche Volumen wie unkomprimierte ROMs :) <br><br>  112-Kilobyte-ROMs werden auf ungef√§hr 57 KB komprimiert, dh die wahre Gr√∂√üe des komprimierten Codes in WASM ohne ROM-Daten betr√§gt weniger als 30 KB (84-57). <br><br>  Es scheint mir ziemlich gut f√ºr einen vollst√§ndigen Emulator eines 8-Bit-Systems zu sein;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426291/">https://habr.com/ru/post/de426291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426281/index.html">Die Gr√ºnder von Amazon, Google, Microsoft und Facebook haben bei einem B√∂rsencrash mehr als 30 Milliarden US-Dollar verloren</a></li>
<li><a href="../de426283/index.html">WeChat in Indien: von einem leistungsstarken Start bis zu einem v√∂lligen Verlust des Interesses</a></li>
<li><a href="../de426285/index.html">In einer der AvtoVAZ-Werkst√§tten wurde eine Farm f√ºr den Bergbau gefunden</a></li>
<li><a href="../de426287/index.html">Zum Mond senden</a></li>
<li><a href="../de426289/index.html">Authentifizierung asp .net Kern √ºber IdentityServer4</a></li>
<li><a href="../de426293/index.html">Welches Fahrrad Sie f√ºr Stadt-, Land- und Extremreisen w√§hlen sollten - eine √úbersicht √ºber Airwheel- und Twitter-Modelle</a></li>
<li><a href="../de426295/index.html">Da sehe ich den perfekten Browser</a></li>
<li><a href="../de426297/index.html">Warum ich modernes Web nicht mag</a></li>
<li><a href="../de426299/index.html">[Designpsychologie] - Die Psychologie des Designs</a></li>
<li><a href="../de426301/index.html">Ist es so in Europa, wie sie dar√ºber schreiben?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>