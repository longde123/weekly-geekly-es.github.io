<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏼 🛀 💌 Metafísica da injeção de dependência ✉️ 🎄 👨🏾‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Injeção de Dependência é uma técnica comumente usada em programação orientada a objetos, projetada para reduzir a conectividade de componentes. Quando...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metafísica da injeção de dependência</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480364/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bp/ha/dz/bphadz2idyr738uoocd_ykof4zm.png" alt="imagem"></div><br><br>  Injeção de Dependência é uma técnica comumente usada em programação orientada a objetos, projetada para reduzir a conectividade de componentes.  Quando usado corretamente, além de atingir esse objetivo, pode trazer qualidades verdadeiramente mágicas para suas aplicações.  Como qualquer mágica, essa técnica é percebida como um conjunto de feitiços, e não como um tratado científico rigoroso.  Isso leva a uma má interpretação dos fenômenos e, como conseqüência, ao mau uso de artefatos.  Em meu material autoral, sugiro que o leitor, passo a passo, curta e em essência, siga o caminho lógico dos fundamentos apropriados do design orientado a objetos até a própria mágica da injeção automática de dependência. <br><a name="habracut"></a><br>  O material é baseado no desenvolvimento do <a href="https://github.com/cylon-v/hypo" rel="nofollow">container Hypo IoC</a> , que mencionei em um <a href="https://habr.com/ru/post/474504/">artigo anterior</a> .  Em exemplos de código em miniatura, usarei o Ruby como uma das linguagens orientadas a objetos mais concisas para escrever exemplos curtos.  Isso não deve causar problemas para os desenvolvedores de outros idiomas entenderem. <br><br><h2>  Nível 1: Princípio da inversão de dependência </h2><br>  Os desenvolvedores no paradigma orientado a objetos são confrontados diariamente com a criação de objetos, que, por sua vez, podem depender de outros objetos.  Isso leva a um gráfico de dependência.  Suponha que estamos lidando com um modelo de objeto do formulário: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/b7/vy/ihb7vyogm2d5rt-ugz_udhskzpy.png" alt="imagem"></div><br>  - algum serviço de cobrança (InvoiceProcessor) e serviço de notificação (NotificationService).  O serviço de processamento de faturas envia notificações quando certas condições são atendidas. Vamos tirar essa lógica do escopo.  Em princípio, esse modelo já é bom, pois os componentes individuais são responsáveis ​​por diferentes responsabilidades.  O problema está em como implementamos essas dependências.  Um erro comum é inicializar uma dependência em que essa dependência é usada: <br><br><pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#      notificationService = NotificationService.new notificationService.notify(invoice.owner) end end</span></span></span></span></code> </pre> <br>  Isso é um erro, visto que obtemos alta conectividade de objetos logicamente independentes (High Coupling).  Isso leva a uma violação do Princípio da Responsabilidade Única - um objeto dependente, além de suas responsabilidades imediatas, deve inicializar suas dependências;  e também “conhece” a interface do construtor de dependência, o que levará a um motivo adicional de mudança ( <a href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" rel="nofollow">“motivo para mudar”, R. Martin</a> ).  É mais correto passar esse tipo de dependência, inicializada fora do objeto dependente: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notify</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">owner</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationService</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoiceProcessor</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Essa abordagem é consistente com o Princípio da inversão de dependência.  Agora estamos transferindo um objeto com uma interface de envio de mensagens - não é mais necessário que o serviço de cobrança "saiba" como construir o objeto de serviço de notificação.  Ao escrever testes de unidade para um serviço de processamento de faturas, o desenvolvedor não precisa entender como substituir a implementação da interface do serviço de notificação por um stub.  Em idiomas com digitação dinâmica, como Ruby, você pode substituir qualquer objeto que atenda ao método de notificação;  com digitação estática, como C # / Java, você pode usar a interface INotificationService, para a qual é fácil criar um Mock.  A questão da inversão de dependência foi divulgada em detalhes por Alexander Byndyu <a href="https://blog.byndyu.ru/2009/12/blog-post.html" rel="nofollow">em um artigo</a> que comemorou recentemente seu 10º aniversário! <br><br><h2>  Nível 2: registro de objetos relacionados </h2><br>  Usar o princípio de inversão de dependência não parece uma prática complicada.  Mas com o tempo, devido a um aumento no número de objetos e relacionamentos, novos desafios aparecem.  NotificationService pode ser usado por outros serviços que não o InvoiceProcessor.  Além disso, ele próprio pode depender de outros serviços, que, por sua vez, dependem de terceiros, etc.  Além disso, alguns componentes nem sempre podem ser usados ​​em uma única cópia.  A principal tarefa é encontrar a resposta para a pergunta - “quando criar dependências?”. <br>  Para resolver esse problema, você pode tentar criar uma solução baseada em uma matriz associativa de dependências.  Um exemplo de interface de seu trabalho pode ser assim: <br><br><pre> <code class="ruby hljs">registry.add(InvoiceProcessor) .depends_on(NotificationService) registry.add(NotificationService) .depends_on(ServiceX) invoiceProcessor = registry.resolve(InvoiceProcessor) invoiceProcessor.process(invoice)</code> </pre><br>  Não é difícil de implementar na prática: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rd/bj/v4/rdbjv49agcxw3fhhask4uv5ysew.png" alt="imagem"></div><br>  Cada vez que container.resolve () é chamado, iremos para a fábrica, que criará instâncias de dependência, ignorando recursivamente o gráfico de dependência descrito no registro.  No caso de `container.resolve (InvoiceProcessor)`, o seguinte será executado: <br><br><ol><li>  factory.resolve (InvoiceProcessor) - a fábrica solicita as dependências InvoiceProcessor no registro, recebe um NotificationService, que também precisa ser montado. </li><li>  factory.resolve (NotificationService) - a fábrica solicita as dependências NotificationService no registro e recebe o ServiceX, que também precisa ser montado. </li><li>  factory.resolve (ServiceX) - não possui dependências, cria, retorna ao longo da pilha de chamadas para a etapa 1, obtém um objeto montado do tipo InvoiceProcessor. </li></ol><br>  Cada componente pode depender de vários outros, portanto, a pergunta óbvia é “como combinar corretamente os parâmetros do designer com as instâncias de dependência resultantes?”.  Um exemplo: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">paymentService</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># ... end end</span></span></span></span></code> </pre><br>  Em idiomas com digitação estática, o tipo de parâmetro pode servir como seletor: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(notificationService: NotificationService, paymentService: PaymentService) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br>  No Ruby, você pode usar a convenção - basta usar o nome do tipo no formato snake_case, este será o nome do parâmetro esperado. <br><br><h2>  Nível 3: gerenciamento de vida útil da dependência </h2><br>  Já temos uma boa solução de gerenciamento de dependências.  Sua única limitação é a necessidade de criar uma nova instância da dependência a cada chamada.  Mas e se não pudermos criar mais de uma instância de um componente?  Por exemplo, um conjunto de conexões com o banco de dados.  Aprofundar e se precisarmos fornecer uma vida útil controlada de dependências?  Por exemplo, feche a conexão com o banco de dados após a conclusão da solicitação HTTP. <br>  Torna-se aparente que o candidato para substituição na solução original é InstanceFactory.  Gráfico atualizado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hf/ed/xl/hfedxlxxnqjmm22oevtbwqrle2k.png" alt="imagem"></div><br>  E a solução lógica é usar um conjunto de estratégias ( <a href="https://refactoring.guru/ru/design-patterns/strategy" rel="nofollow">Estratégia, GoF</a> ) para obter instâncias de componentes.  Agora, nem sempre criamos novas instâncias ao chamar Container :: resolve, portanto, é apropriado renomear Factory para Resolver.  Observe que o método Container :: register possui um novo parâmetro - life_time (life).  Este parâmetro é opcional - por padrão, seu valor é "transitório" (transitório), que corresponde ao comportamento implementado anteriormente.  A estratégia singleton também é óbvia - com seu uso, apenas uma instância do componente é criada, que será retornada toda vez. <br>  O escopo é uma estratégia um pouco mais complexa.  Em vez de "caminhos transitórios" e "solitários", muitas vezes é necessário usar algo intermediário - um componente que existe ao longo da vida de outro componente.  Um exemplo semelhante pode ser um objeto de solicitação de aplicativo da web, que é o contexto da existência de objetos como, por exemplo, parâmetros HTTP, conexão com o banco de dados, agregados de modelo.  Durante toda a vida útil da solicitação, coletamos e usamos essas dependências e, após sua destruição, esperamos que todas elas também sejam destruídas.  Para implementar essa funcionalidade, será necessário desenvolver uma estrutura de objetos fechados bastante complexa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vd/97/hh/vd97hhi_p41keoxph7ku9sdxrdm.png" alt="imagem"></div><br>  O diagrama mostra um fragmento refletindo alterações nas classes Component e LifetimeStrategy no contexto da implementação da vida útil do escopo.  O resultado foi uma espécie de "ponte dupla" (semelhante ao modelo <a href="https://refactoring.guru/ru/design-patterns/bridge" rel="nofollow">Bridge, GoF</a> ).  Usando os meandros das técnicas de herança e agregação, o Component se torna o núcleo do contêiner.  A propósito, o diagrama tem herança múltipla.  Onde a linguagem de programação e a consciência permitirem, você pode deixar assim.  No Ruby, eu uso impurezas; em outros idiomas, você pode substituir a herança por outra ponte: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ri/dj/h7/ridjh7shgaolxp_mxujgvkueta4.png" alt="imagem"></div><br>  O diagrama de sequência mostra o ciclo de vida do componente da sessão, que está vinculado à vida útil do componente de solicitação: <br><br><img src="https://habrastorage.org/webt/-c/im/bt/-cimbtr3sktosriryzoyrtqxht4.png" alt="imagem"><br><br>  Como você pode ver no diagrama, em um determinado momento, quando o componente de solicitação completa sua missão, é chamado o método de liberação, que inicia o processo de destruição do escopo. <br><br><h2>  Nível 4: Injeção de Dependência </h2><br>  Até agora, falei sobre como determinar o registro de dependências e como criar e destruir componentes de acordo com o gráfico das relações formadas.  E para que serve?  Suponha que usamos isso como parte do Ruby on Rails: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceController</span></span></span><span class="hljs-class"> &lt; ApplicationController </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pay</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_repository</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">registry</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resolve</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceRepository</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_processor</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">registry</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resolve</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_repository</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class">[:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">]) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_processor</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pay</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  O código que será escrito dessa maneira não será mais legível, testável ou flexível.  Não podemos “forçar” o Rails a injetar dependências do controlador por meio de seu construtor, o que não é fornecido pela estrutura.  Mas, por exemplo, no ASP.NET MVC, isso é implementado em um nível básico.  Para aproveitar ao máximo o uso do mecanismo automático de resolução de dependências, é necessário implementar a técnica Inversion of Control (IoC, inversion of control).  Essa é uma abordagem na qual a responsabilidade pela resolução de dependências vai além do escopo do código do aplicativo e fica com a estrutura.  Considere um exemplo. <br>  Imagine que estamos projetando algo como Rails do zero.  Implementamos o seguinte esquema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y1/bg/bh/y1bgbh_27yevoryv4ntb58nej9w.png" alt="imagem"></div><br>  O aplicativo recebe a solicitação, o roteador recupera os parâmetros e instrui o controlador apropriado a processar essa solicitação.  Esse esquema copia condicionalmente o comportamento de uma estrutura da Web típica com apenas uma pequena diferença - o contêiner de IoC está envolvido na criação e implementação de dependências.  Mas aqui surge a questão: onde o próprio contêiner é criado?  Para cobrir o maior número possível de objetos da futura aplicação, nossa estrutura deve criar um contêiner no estágio inicial de sua operação.  Obviamente, não há lugar mais adequado do que o criador de aplicativos.  É também o local mais adequado para configurar todas as dependências: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#   - ,      . def initialize </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = Container.new </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(Controller) .using_lifetime(:transient) # ,     </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(InvoiceService) .using_lifetime(:singleton) # ,     </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(Router) .using_lifetime(:singleton) #  end #     -     , #      . def call(env) router = </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.resolve(Router) router.handle(env.path, env.method, env.params) end end</span></span></span></span></code> </pre><br>  Qualquer aplicativo tem um ponto de entrada, por exemplo, o método principal.  Neste exemplo, o ponto de entrada é o método de chamada.  O objetivo deste método é chamar o roteador para processar solicitações recebidas.  O ponto de entrada deve ser o único local para ligar diretamente para o contêiner - a partir desse momento, o contêiner deve ser esquecido, toda a magia subsequente deve ocorrer "sob o capô".  A implementação do controlador dentro dessa arquitetura realmente parece incomum.  Apesar do fato de não ser instanciado explicitamente, ele possui um construtor com parâmetros: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#   . #    . def initialize(invoice_service) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@invoice</span></span></span></span><span class="hljs-class"><span class="hljs-comment">_service = invoice_service end def create_invoice(params) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@invoice</span></span></span></span><span class="hljs-class"><span class="hljs-comment">_service.create(params) end end</span></span></span></span></code> </pre><br>  O ambiente "entende" como criar instâncias do controlador.  Isso é possível graças ao mecanismo de injeção de dependência fornecido pelo contêiner de IoC incorporado no coração do aplicativo da web.  No construtor do controlador, agora você pode listar tudo o que é necessário para sua operação.  O principal é que os componentes correspondentes sejam registrados no contêiner.  Agora vamos passar para a implementação do roteador: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Router</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#         -  #      #     . def initialize(controller) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@controller</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = controller end def handle(path, method, params) #  ""- if path == '/invoices' &amp;&amp; method == 'POST' </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@controller</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.create(params) end end end</span></span></span></span></code> </pre><br>  Observe que o roteador depende do controlador.  Se recordarmos as configurações de dependência, o Controlador é um componente de vida curta e o Roteador, um solitário constante.  Como isso pode ser?  A resposta é que os componentes não são instâncias das classes correspondentes, como parece externamente.  De fato, esses são objetos proxy ( <a href="https://refactoring.guru/ru/design-patterns/proxy" rel="nofollow">Proxy, GoF</a> ) com a instância do método factory ( <a href="https://refactoring.guru/ru/design-patterns/factory-method" rel="nofollow">Factory Method, GoF</a> );  eles retornam uma instância do componente de acordo com a estratégia atribuída.  Como o controlador está registrado como "transitório", o roteador sempre lidará com sua nova instância quando for acessado.  O diagrama de seqüência mostra um mecanismo aproximado de trabalho: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tl/ng/1y/tlng1yrikuvxkenacsx-gy0x7mu.png" alt="imagem"></div><br>  I.e.  Além do gerenciamento de dependências, uma boa estrutura baseada em um contêiner de IoC também assume a responsabilidade pelo gerenciamento correto da vida útil dos componentes. <br><br><h2>  Conclusão </h2><br>  A técnica de injeção de dependência pode ter uma implementação interna bastante sofisticada.  Esse é o preço de transferir a complexidade da implementação de aplicativos flexíveis para o núcleo da estrutura.  O usuário de tais estruturas não pode se preocupar com os aspectos puramente técnicos, mas dedica mais tempo ao desenvolvimento confortável da lógica de negócios dos programas aplicativos.  Usando uma implementação de DI de alta qualidade, um programador de aplicativo inicialmente escreve código testável e bem suportado.  Um bom exemplo da implementação da Injeção de Dependências é a estrutura <a href="https://github.com/cylon-v/dandy" rel="nofollow">Dandy</a> descrita no meu artigo anterior, <a href="https://habr.com/ru/post/474504/">Orthodox Backend</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480364/">https://habr.com/ru/post/pt480364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480352/index.html">O geneticista de Harvard está desenvolvendo um protótipo de aplicativo de namoro com DNA</a></li>
<li><a href="../pt480354/index.html">Introdução aos métodos de matriz JavaScript .map (), .filter () e .reduce ()</a></li>
<li><a href="../pt480356/index.html">Dicas úteis sobre Python que você não conheceu</a></li>
<li><a href="../pt480358/index.html">O preço oculto das bibliotecas CSS-in-JS nos aplicativos React</a></li>
<li><a href="../pt480362/index.html">Aventuras do hexafluoreto de urânio empobrecido alemão na Rússia. Parte 1. História e tecnologias de enriquecimento</a></li>
<li><a href="../pt480368/index.html">Captura de vazamentos de memória em C / C ++</a></li>
<li><a href="../pt480370/index.html">Conferência DEFCON 19. Os chefes adoram o Excel, os hackers também</a></li>
<li><a href="../pt480374/index.html">Reagir à DogBot da Robotics: Revolução na Indústria da Construção</a></li>
<li><a href="../pt480376/index.html">De jogos de computador a mensagens secretas: discuta ovos de Páscoa em lançamentos de vinil</a></li>
<li><a href="../pt480378/index.html">14 projetos de código aberto para aprimorar as habilidades de ciência de dados (fácil, normal, difícil)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>