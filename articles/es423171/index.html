<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍶 👏 🤷🏿 Cómo Discord sirve simultáneamente 2.5 millones de chats de voz usando WebRTC 👨🏿‍🚀 🌔 🤯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde el principio, planificamos soluciones de ingeniería y productos para que Discord sea adecuado para el chat de voz mientras juegas con amigos. Es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo Discord sirve simultáneamente 2.5 millones de chats de voz usando WebRTC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423171/"><img src="https://habrastorage.org/webt/no/3o/oj/no3oojc_pnuwknb6hcrplkrhtmq.jpeg"><br><br>  Desde el principio, planificamos soluciones de ingeniería y productos para que Discord sea adecuado para el chat de voz mientras juegas con amigos.  Estas soluciones permitieron escalar en gran medida el sistema, teniendo un equipo pequeño y recursos limitados. <br><br>  Este artículo analiza las diversas tecnologías que Discord usa para chats de audio / video. <br><br>  <i>Para mayor claridad, llamaremos a todo el grupo de usuarios y canales al "grupo" (gremio); en el cliente se les llama "servidores".</i>  <i>En cambio, el término "servidor" se refiere a nuestra infraestructura de servidores.</i> <br><a name="habracut"></a><br><h1>  Principios fundamentales </h1><br>  Cada chat de audio / video en Discord es compatible con muchos participantes.  Vimos a miles de personas chatear por turnos en grandes grupos de chat.  Tal soporte requiere una arquitectura cliente-servidor, porque una red punto a punto se vuelve prohibitivamente costosa con un aumento en el número de participantes. <br><br>  El enrutamiento del tráfico de red a través de los servidores Discord también garantiza que su dirección IP nunca sea visible, y nadie lanzará un ataque DDoS.  El enrutamiento a través de servidores tiene otras ventajas: por ejemplo, moderación.  Los administradores pueden apagar rápidamente el sonido y el video a los intrusos. <br><br><h1>  Arquitectura del cliente </h1><br>  Discord se ejecuta en muchas plataformas. <br><br><ul><li>  Web (Chrome / Firefox / Edge, etc.) </li><li>  Aplicación independiente (Windows, MacOS, Linux) </li><li>  Teléfono (iOS / Android) </li></ul><br>  Podemos admitir todas estas plataformas de una sola manera: a través de la reutilización del código <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebRTC</a> .  Esta especificación para comunicaciones en tiempo real incluye componentes de red, audio y video.  El estándar es adoptado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por el Consorcio World Wide Web</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupo de Ingeniería de Internet</a> .  WebRTC está disponible en todos los navegadores modernos y como una biblioteca nativa para implementación en aplicaciones. <br><br>  El audio y el video en Discord se ejecutan en WebRTC.  Por lo tanto, la aplicación del navegador se basa en la implementación de WebRTC en el navegador.  Sin embargo, las aplicaciones para computadoras de escritorio, iOS y Android utilizan un único motor multimedia C ++ construido sobre su propia biblioteca WebRTC, que está especialmente adaptada a las necesidades de nuestros usuarios.  Esto significa que algunas funciones en la aplicación funcionan mejor que en el navegador.  Por ejemplo, en nuestras aplicaciones nativas podemos: <br><br><ul><li>  Omitir Windows Volume Mute de forma predeterminada, cuando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">todas las aplicaciones se silencian automáticamente cuando se usan auriculares</a> .  Esto no es deseable cuando tú y tus amigos van a una redada y coordinan las actividades de chat de Discord. </li><li>  Use su propio control de volumen en lugar del mezclador global del sistema operativo. </li><li>  Procese los datos de audio originales para detectar la actividad de voz y transmitir audio y video en los juegos. </li><li>  Reduzca el ancho de banda de la CPU y el consumo de la CPU durante los períodos de silencio, incluso en los chats de voz más numerosos en un momento dado, solo unas pocas personas hablan al mismo tiempo. </li><li>  Proporcione funcionalidad en todo el sistema para el modo push to talk. </li><li>  Envíe junto con los paquetes de audio y video información adicional (por ejemplo, un indicador de prioridad en el chat). </li></ul><br>  Tener su propia versión de WebRTC significa actualizaciones frecuentes para todos los usuarios: este es un proceso lento que estamos tratando de automatizar.  Sin embargo, este esfuerzo vale la pena gracias a las características específicas para nuestros jugadores. <br><br>  En Discord, la comunicación de voz y video se inicia al ingresar un canal de voz o una llamada.  Es decir, la conexión siempre es iniciada por el cliente; esto reduce la complejidad de las partes del cliente y del servidor, y también aumenta la tolerancia a errores.  En caso de una falla en la infraestructura, los participantes pueden simplemente reconectarse al nuevo servidor interno. <br><br><h3>  Bajo nuestro control </h3><br>  El control de la biblioteca nativa le permite implementar algunas funciones de manera diferente que en la implementación del navegador de WebRTC. <br><br>  Primero, WebRTC se basa en el Protocolo de descripción de sesión ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SDP</a> ) para negociar audio / video entre los participantes (hasta 10 KB por intercambio de paquetes).  En su propia biblioteca, la API de nivel inferior de WebRTC ( <code>webrtc::Call</code> ) se utiliza para crear ambos flujos, entrantes y salientes.  Cuando se conecta a un canal de voz, hay un intercambio mínimo de información.  Esta es la dirección y el puerto del servidor de fondo, el método de cifrado, las claves, el códec y la identificación del flujo (aproximadamente 1000 bytes). <br><br><pre> <code class="cpp hljs">webrtc::<span class="hljs-function"><span class="hljs-function">AudioSendStream* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAudioSendStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ssrc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> payloadType, webrtc::Transport* transport, rtc::scoped_refptr&lt;webrtc::AudioEncoderFactory&gt; audioEncoderFactory, webrtc::Call* call)</span></span></span><span class="hljs-function"> </span></span>{ webrtc::AudioSendStream::Config config{transport}; config.rtp.ssrc = ssrc; config.rtp.extensions = {{<span class="hljs-string"><span class="hljs-string">"urn:ietf:params:rtp-hdrext:ssrc-audio-level"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}}; config.encoder_factory = audioEncoderFactory; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> webrtc::SdpAudioFormat kOpusFormat = {<span class="hljs-string"><span class="hljs-string">"opus"</span></span>, <span class="hljs-number"><span class="hljs-number">48000</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; config.send_codec_spec = webrtc::AudioSendStream::Config::SendCodecSpec(payloadType, kOpusFormat); webrtc::AudioSendStream* audioStream = call-&gt;CreateAudioSendStream(config); audioStream-&gt;Start(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> audioStream; }</code> </pre> <br>  Además, WebRTC utiliza el Establecimiento de conectividad interactiva ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ICE</a> ) para determinar la mejor ruta entre los participantes.  Como tenemos cada cliente conectado al servidor, no necesitamos ICE.  Esto le permite proporcionar una conexión mucho más confiable si está detrás de NAT, y también mantener su dirección IP en secreto de otros participantes.  Los clientes hacen ping periódicamente para que el firewall mantenga una conexión abierta. <br><br>  Finalmente, WebRTC utiliza el Protocolo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguro de</a> transporte en tiempo real ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SRTP</a> ) para encriptar los medios.  Las claves de cifrado se configuran utilizando el protocolo Datagram Transport Layer Security ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DTLS</a> ) basado en el TLS estándar.  La biblioteca incorporada de WebRTC le permite implementar su propia capa de transporte utilizando la API <code>webrtc::Transport</code> . <br><br>  En lugar de DTLS / SRTP, decidimos usar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cifrado Salsa20</a> más <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rápido</a> .  Además, no enviamos datos de audio durante períodos de silencio, una ocurrencia común, especialmente en salas de chat grandes.  Esto conduce a ahorros significativos en el ancho de banda y los recursos de la CPU, sin embargo, tanto el cliente como el servidor deben estar listos en cualquier momento para dejar de recibir datos y reescribir los números de serie de los paquetes de audio / video. <br><br>  Dado que la aplicación web utiliza la implementación basada en navegador de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API WebRTC</a> , SDP, ICE, DTLS y SRTP no se pueden abandonar.  El cliente y el servidor intercambian toda la información necesaria (menos de 1200 bytes al intercambiar paquetes), y la sesión SDP se establece sobre la base de esta información para los clientes.  El backend es responsable de resolver las diferencias entre las aplicaciones de escritorio y navegador. <br><br><h1>  Arquitectura de backend </h1><br>  Hay varios servicios de chat de voz en el backend, pero nos centraremos en tres: Discord Gateway, Discord Guilds y Discord Voice.  Todos nuestros servidores de señales están escritos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elixir</a> , lo que nos permite reutilizar el código repetidamente. <br><br>  Cuando está en línea, su cliente admite una conexión WebSocket a un Discord Gateway (lo llamamos una conexión de <i>portal</i> WebSocket).  A través de esta conexión, su cliente recibe eventos relacionados con grupos y canales, mensajes de texto, paquetes de presencia, etc. <br><br>  Cuando se conecta a un canal de voz, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">objeto de</a> estado de voz muestra el estado de la conexión.  El cliente actualiza este objeto a través de la conexión de la puerta de enlace. <br><br><pre> <code class="hljs pgsql">defmodule VoiceStates.VoiceState <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> t :: %{ session_id: String.t(), user_id: Number.t(), channel_id: Number.t() | nil, token: String.t() | nil, mute: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, deaf: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, self_mute: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, self_deaf: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, self_video: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, suppress: <span class="hljs-type"><span class="hljs-type">boolean</span></span> } defstruct session_id: nil, user_id: nil, token: nil, channel_id: nil, mute: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, deaf: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, self_mute: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, self_deaf: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, self_video: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, suppress: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Cuando se conecta a un canal de voz, se le asigna uno de los servidores de Discord Voice.  Es responsable de transmitir el sonido a cada participante en el canal.  Todos los canales de voz en un grupo se asignan a un servidor.  Si eres el primero en chatear, el servidor de Discord Guilds es responsable de asignar el servidor de Discord Voice a todo el grupo mediante el proceso que se describe a continuación. <br><br><h3>  Destino del servidor de voz Discord </h3><br>  Cada servidor de Discord Voice informa periódicamente sobre su estado y carga.  Esta información se coloca en un sistema de descubrimiento de servicios (usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">etcd</a> ), como se discutió en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo anterior</a> . <br><br>  El servidor de Discord Guilds monitorea el sistema de descubrimiento de servicios y asigna al grupo el servidor de Discord Voice menos utilizado en la región.  Cuando se selecciona, todos los objetos de estado de voz (también compatibles con el servidor de Discord Guilds) se transfieren al servidor de Discord Voice para que pueda configurar el reenvío de audio / video.  Los clientes son notificados del servidor de Discord Voice seleccionado.  Luego, el cliente abre la <i>segunda</i> conexión WebSocket con el servidor de voz (lo llamamos la conexión de <i>voz</i> WebSocket), que se utiliza para configurar el reenvío multimedia y la indicación de voz. <br><br>  Cuando el cliente muestra el estado <i>Esperando punto final</i> , esto significa que el servidor de Discord Guilds está buscando el servidor óptimo de Discord Voice.  Un mensaje de <i>Voice Connected</i> indica que el cliente ha intercambiado con éxito paquetes UDP con el servidor Discord Voice seleccionado. <br><br>  El servidor Discord Voice contiene dos componentes: un módulo de señal y una unidad de retransmisión multimedia, llamada unidad de reenvío selectivo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SFU</a> ).  El módulo de señal controla completamente la SFU y es responsable de generar identificadores de flujo y claves de cifrado, redirigir indicadores de voz, etc. <br><br>  Nuestra SFU (en C ++) es responsable de dirigir el tráfico de audio y video entre canales.  Se desarrolla por sí solo: para nuestro caso particular, SFU proporciona el máximo rendimiento y, por lo tanto, el mayor ahorro.  Cuando los moderadores violan (silencian el servidor), sus paquetes de audio no se procesan.  SFU también funciona como un puente entre las aplicaciones nativas y las basadas en el navegador: implementa el transporte y el cifrado tanto para el navegador como para las aplicaciones nativas, convirtiendo paquetes durante la transmisión.  Finalmente, la SFU es responsable del procesamiento del protocolo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTCP</a> , que se utiliza para optimizar la calidad del video.  SFU recopila y procesa informes RTCP de los destinatarios, y notifica a los remitentes qué banda está disponible para la transmisión de video. <br><br><h1>  Tolerancia a fallos </h1><br>  Dado que solo los servidores de Discord Voice están disponibles directamente desde Internet, hablaremos de ellos. <br><br>  El módulo de señal monitorea continuamente la SFU.  Si se bloquea, se reinicia instantáneamente con una pausa mínima en el servicio (varios paquetes perdidos).  El estado de SFU es restaurado por el módulo de señal sin ninguna interacción con el cliente.  Aunque los bloqueos de SFU son poco frecuentes, utilizamos el mismo mecanismo para actualizar las SFU sin interrupciones en el servicio. <br><br>  Cuando el servidor Discord Voice se bloquea, no responde al ping, y se elimina del sistema de descubrimiento de servicios.  El cliente también nota un bloqueo del servidor debido a una conexión de voz WebSocket interrumpida, luego solicita el <i>ping del servidor de voz a</i> través de la conexión de puerta de enlace WebSocket.  El servidor de Discord Guilds confirma la falla, consulta el sistema de descubrimiento de servicios y asigna un nuevo servidor de Discord Voice al grupo.  Los Discord Guilds envían todos los objetos de estado de voz al nuevo servidor de voz.  Todos los clientes reciben una notificación sobre el nuevo servidor y se conectan a él para iniciar la configuración multimedia. <br><br><img src="https://habrastorage.org/webt/tw/1r/kz/tw1rkzplhbqsax95lajz9-ylluu.gif"><br><br>  Muy a menudo, los servidores de Discord Voice caen bajo DDoS (vemos esto por el rápido aumento en los paquetes IP entrantes).  En este caso, realizamos el mismo procedimiento que cuando el servidor falla: lo eliminamos del sistema de descubrimiento de servicios, seleccionamos un nuevo servidor, le transferimos todos los objetos de estado de comunicación de voz y notificamos a los clientes sobre el nuevo servidor.  Cuando el ataque DDoS disminuye, el servidor regresa al sistema de descubrimiento de servicios. <br><br>  Si el propietario del grupo decide elegir una nueva región para la votación, seguimos un procedimiento muy similar.  Discord Guilds Server selecciona el mejor servidor de voz disponible en una nueva región en consulta con un sistema de descubrimiento de servicios.  Luego traduce todos los objetos del estado de la comunicación de voz y notifica a los clientes sobre el nuevo servidor.  Los clientes interrumpen la conexión WebSocket actual con el antiguo servidor Discord Voice y crean una nueva conexión con el nuevo servidor Discord Voice. <br><br><h1>  Escalamiento </h1><br>  Toda la infraestructura de Discord Gateway, Discord Guilds y Discord Voice admite escala horizontal.  Discord Gateway y Discord Guilds funcionan en Google Cloud. <br><br>  Tenemos más de 850 servidores de voz en 13 regiones (ubicadas en más de 30 centros de datos) en todo el mundo.  Esta infraestructura proporciona una mayor redundancia en caso de fallas en los centros de datos y DDoS.  Trabajamos con varios socios y utilizamos nuestros servidores físicos en sus centros de datos.  Más recientemente, se ha agregado la región sudafricana.  Gracias a los esfuerzos de ingeniería en las arquitecturas de cliente y servidor, Discord ahora puede servir simultáneamente a más de 2.6 millones de usuarios de chat de voz con tráfico saliente de más de 220 Gbit / sy 120 millones de paquetes por segundo. <br><br><h1>  Que sigue </h1><br>  Supervisamos constantemente la calidad de las comunicaciones de voz (las métricas se envían desde el lado del cliente a los servidores de fondo).  En el futuro, esta información ayudará en la detección automática y la eliminación de la degradación. <br><br>  Aunque lanzamos video chat y screencasts hace un año, ahora solo se pueden usar en mensajes privados.  En comparación con el audio, el video requiere significativamente más potencia de CPU y ancho de banda.  El desafío es equilibrar la cantidad de ancho de banda y los recursos de CPU / GPU utilizados para garantizar la mejor calidad de video, especialmente cuando un grupo de jugadores en un canal está en diferentes dispositivos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La</a> tecnología de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">codificación de video escalable</a> (SVC), una extensión del estándar AVC H.264 / MPEG-4, puede convertirse en una solución al problema. <br><br>  Los screencasts necesitan incluso más ancho de banda que el video, debido a la mayor resolución y FPS que las cámaras web convencionales.  Actualmente estamos trabajando en soporte para codificación de video basada en hardware en una aplicación de escritorio. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423171/">https://habr.com/ru/post/es423171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423161/index.html">La empresa quiere datos personales</a></li>
<li><a href="../es423163/index.html">Conectando CryptoPro a Mono</a></li>
<li><a href="../es423165/index.html">Dibujo dinámico de malla en Unreal Engine 4</a></li>
<li><a href="../es423167/index.html">Lo que Mark Zuckerberg habla sobre los problemas de Facebook. Lo principal del artículo de The New Yorker</a></li>
<li><a href="../es423169/index.html">Inicio del día (julio-agosto de 2018)</a></li>
<li><a href="../es423173/index.html">Tiempo mínimo - dolor máximo</a></li>
<li><a href="../es423175/index.html">¿Por qué escribir tu propio motor de juego?</a></li>
<li><a href="../es423177/index.html">Libro de infraestructura de seguridad de Microsoft Azure</a></li>
<li><a href="../es423179/index.html">Libro de guía de aplicaciones de arquitectura en la nube</a></li>
<li><a href="../es423181/index.html">Libro de guía del desarrollador de Azure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>