<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèø üñáÔ∏è üì© Starten Sie die Anzeige auf STM32 √ºber LTDC ... in den Registern üî™ üî§ üòã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gr√º√üe! Vor kurzem musste ein Projekt ein Display mit einer LVDS-Schnittstelle starten. Um die Aufgabe zu implementieren, wurde der STM32F746-Controlle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Starten Sie die Anzeige auf STM32 √ºber LTDC ... in den Registern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412753/"> Gr√º√üe!  Vor kurzem musste ein Projekt ein Display mit einer LVDS-Schnittstelle starten.  Um die Aufgabe zu implementieren, wurde der STM32F746-Controller ausgew√§hlt, weil  Ich habe schon ziemlich viel mit ihm gearbeitet und er hat das LTDC-Modul, mit dem Sie ohne Controller direkt mit dem Display arbeiten k√∂nnen.  In diesem Fall ist der Controller bereits im Mikrocontroller implementiert.  Das letzte Argument war auch, dass es auf diesem Stein ein STM32F746-Disco-Debugging gab, das ich zur Hand hatte, was bedeutet, dass ich mit der Arbeit an dem Projekt beginnen konnte, ohne darauf zu warten, dass das Board, die Komponenten usw. zu mir kamen. <br><br>  Heute werde ich Ihnen erkl√§ren, wie Sie das LTDC-Modul ausf√ºhren und mit Registern (CMSIS) arbeiten.  HAL und andere Bibliotheken m√∂gen und nutzen sie aus religi√∂sen Gr√ºnden nicht, aber dies ist auch von Interesse.  Sie werden sehen, dass das Anheben komplexer Peripherieger√§te in Registern so einfach ist wie normales SPI.  Interessant?  Dann lass uns gehen! <br><br><img src="https://habrastorage.org/webt/1q/dg/rd/1qdgrdp09rbyqcdhtzsvz8aqkbc.jpeg"><br><a name="habracut"></a><br><h2>  1. Ein wenig √ºber LTDC </h2><br>  Dieses Peripheriemodul ist im Wesentlichen eine Steuerung, die normalerweise an der Seite des Displays steht, beispielsweise SSD1963 und dergleichen.  Wenn wir uns die Struktur von LTDC ansehen, werden wir sehen, dass es sich physikalisch um einen 24-Bit-Parallelbus + Hardware-Grafikbeschleuniger + Datenarray im RAM handelt, bei dem es sich tats√§chlich um einen Anzeigepuffer (Bildpuffer) handelt. <br><br><img src="https://habrastorage.org/webt/wm/g-/7k/wmg-7k_nhwtycbwgiefmyyagmxo.png"><br><br>  Am Ausgang haben wir einen gew√∂hnlichen parallelen Bus, der 24 Farbbits (8 Bit pro Farbe des RGB-Modells), Synchronisationsleitungen, eine Anzeige-Ein / Aus-Leitung und einen Pixeltakt enth√§lt.  Letzteres ist in der Tat ein Taktsignal, mit dem Pixel in die Anzeige geladen werden, dh wenn wir eine Frequenz von 9,5 MHz haben, k√∂nnen wir in 1 Sekunde 9,5 Millionen Pixel laden.  In der Theorie sind die Zahlen in der Praxis nat√ºrlich aufgrund von Timings und anderen Dingen etwas bescheidener. <br><br>  <u>F√ºr eine detailliertere Einf√ºhrung in LTDC empfehle ich Ihnen, einige Dokumente zu lesen:</u> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein √úberblick √ºber die Funktionen von LTDC in F4, in unserem F7 ist alles gleich</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungshinweis 4861. "LCD-TFT-Display-Controller (LTDC) auf STM32-MCUs"</a> </li></ol><br><h2>  2. Was m√ºssen wir tun? </h2><br>  ST-Mikrocontroller haben aus gutem Grund an Popularit√§t gewonnen. Die wichtigste Voraussetzung f√ºr elektronische Komponenten ist die Dokumentation, und alles ist in Ordnung.  Die Seite ist sicherlich schrecklich, aber ich werde Links zu allen Dokumentationen hinterlassen.  Der Hersteller bewahrt uns vor der Qual und Erfindung des Fahrrads, daher werden auf Seite 520 im <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenzhandbuch RM0385</a></i> Schwarz-Wei√ü-Schritte angegeben, was wir tun m√ºssen: <br><br><img src="https://habrastorage.org/webt/bz/nx/ul/bznxulxfphrlrfmc_47lhv9wvgy.png"><br><br>  Tats√§chlich m√ºssen Sie nicht die H√§lfte der beschriebenen Schritte ausf√ºhren: Sie m√ºssen entweder nicht gestartet werden oder sind bereits standardm√§√üig konfiguriert.  F√ºr den minimalen Start, mit dem wir Pixel zeichnen, Bilder, Grafiken, Text usw. anzeigen k√∂nnen, reicht Folgendes aus: <br><br><ul><li>  Aktivieren Sie die LTDC-Taktung </li><li>  Stellen Sie das Taktsystem und die Frequenz der Datenausgabe ein (Pixeltakt). </li><li>  Konfigurieren Sie die E / A-Ports (GPIO) f√ºr die Arbeit mit LTDC </li><li>  Richten Sie Timings f√ºr unser Display-Modell ein </li><li>  <s>Stellen Sie die Polarit√§t der Signale ein.</s>  <s>Standardm√§√üig bereits erledigt</s> </li><li>  <s>Geben Sie die Hintergrundfarbe der Anzeige an.</s>  <s>Wir werden ihn noch nicht sehen, Sie k√∂nnen es "bei Nullen" lassen.</s> </li><li>  Legen Sie die tats√§chliche Gr√∂√üe des sichtbaren Bereichs der Anzeige f√ºr eine bestimmte Ebene fest </li><li>  W√§hlen Sie das Farbformat: ARGB8888, RGB 888, RGB565 usw. </li><li>  Geben Sie die Adresse des Arrays an, das als Bildspeicher fungieren soll </li><li>  Geben Sie die Datenmenge in einer Zeile an (L√§nge in Breite). </li><li>  Geben Sie die Anzahl der Zeilen an (Anzeigeh√∂he). </li><li>  F√ºgen Sie die Ebene hinzu, mit der wir arbeiten </li><li>  Aktivieren Sie das LTDC-Modul </li></ul><br>  Be√§ngstigend  Ich hatte Angst, aber es stellte sich heraus, dass es bei allen Vorg√§ngen 20 Minuten lang funktionierte.  Es gibt eine Aufgabe, der Plan ist geplant und es bleibt nur zu erf√ºllen. <br><br><h2>  3. Einrichten des Uhrensystems </h2><br>  Der erste Punkt, den wir ben√∂tigen, um ein Taktsignal an das LTDC-Modul zu senden, erfolgt durch Schreiben in das RCC-Register: <br><br><pre><code class="cpp hljs">RCC-&gt;APB2ENR |= RCC_APB2ENR_LTDCEN;</code> </pre> <br>  Als n√§chstes m√ºssen Sie die Taktfrequenz vom externen Quarz (HSE) auf eine Frequenz von 216 MHz, dh auf das Maximum, konfigurieren.  Der erste Schritt besteht darin, die Taktquelle vom Quarzresonator einzuschalten und auf das Bereitschaftsflag zu warten: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_HSEON; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!(RCC-&gt;CR &amp; RCC_CR_HSERDY));</code> </pre><br>  Stellen Sie nun die Verz√∂gerung f√ºr den Flash-Speicher des Controllers auf ein  Sie wei√ü nicht, wie sie mit der Kernfrequenz arbeiten soll.  Sein Wert ist wie der Rest der Daten dem Referenzhandbuch entnommen: <br><br><pre> <code class="cpp hljs">FLASH-&gt;ACR |= FLASH_ACR_LATENCY_5WS;</code> </pre><br>  Um nun die gew√ºnschte Frequenz zu erhalten, werde ich 25 MHz vom Eingang auf 25 teilen und 1 MHz erhalten.  Als n√§chstes multipliziere ich gerade in PLL mit 432, weil  In Zukunft gibt es einen Frequenzteiler mit einem Mindestwert von / 2, auf den Sie die doppelte Frequenz anwenden m√ºssen.  Danach verbinden wir den PLL-Eingang mit unserem Quarzresonator (HSE): <br><br><pre> <code class="cpp hljs">RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLM_0 | RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_4; RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLN_4 | RCC_PLLCFGR_PLLN_5 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLN_8; RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLSRC;</code> </pre><br>  Aktivieren Sie nun PLL und warten Sie auf das Ready-Flag: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_PLLON; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="hljs-number"><span class="hljs-number">0</span></span>){}</code> </pre><br>  Wir weisen den Ausgang unserer PLL als Quelle der Systemfrequenz zu und warten auf das Bereitschaftsflag: <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {}</code> </pre><br>  Dies beendet die allgemeine Takteinstellung und wir fahren mit der Einstellung der Taktfrequenz (PLLSAI) f√ºr unsere Anzeige (Pixeltakt) fort.  Das Signal f√ºr PLLSAI gem√§√ü Datenblatt wird nach dem Teiler / 25 genommen, dh am Eingang haben wir 1 MHz.  Wir brauchen eine Frequenz von ca. 9,5 MHz, daf√ºr multiplizieren wir die Frequenz von 1 MHz mit 192 und erhalten dann mit zwei Teilern mit 5 und 4 den gew√ºnschten Wert PLLSAI = 1 MHz * 192/5/4 = 9,6 MHz: <br><br><pre> <code class="cpp hljs">RCC-&gt;PLLSAICFGR |= RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7; RCC-&gt;PLLSAICFGR |= RCC_PLLSAICFGR_PLLSAIR_0 | RCC_PLLSAICFGR_PLLSAIR_2; RCC-&gt;DCKCFGR1 |= RCC_DCKCFGR1_PLLSAIDIVR_0; RCC-&gt;DCKCFGR1 &amp;= ~RCC_DCKCFGR1_PLLSAIDIVR_1;</code> </pre><br>  Als letzten Schritt aktivieren wir PLLSAI f√ºr die Anzeige und warten auf das arbeitsbereite Flag: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_PLLSAION; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((RCC-&gt;CR &amp; RCC_CR_PLLSAIRDY) == <span class="hljs-number"><span class="hljs-number">0</span></span>) {}</code> </pre><br>  Damit ist die Grundeinstellung des Taktsystems abgeschlossen. Um nicht zu vergessen und dann nicht zu leiden, aktivieren wir die Taktung an allen Eingangs- / Ausgangsanschl√ºssen (GPIO).  Wir haben keine Batterieleistung, zumindest nicht zum Debuggen, daher sparen wir nicht: <br><br><pre> <code class="cpp hljs">RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOBEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOCEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIODEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOEEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOFEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOGEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOHEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOJEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOKEN;</code> </pre><br><h2>  4. Konfigurieren der E / A-Ports (GPIO) </h2><br>  Das Einrichten von gpio ist sehr einfach - wir haben alle Abschnitte des LTDC-Busses als alternativen Ausgang und mit hoher Frequenz zu konfigurieren.  Zu diesem Zweck haben wir im Referenzhandbuch auf Seite 201 diesen Tipp: <br><br><img src="https://habrastorage.org/webt/m5/bw/e9/m5bwe9v-fev5yahji9hqc9iofno.png"><br><br>  Die Tabelle gibt an, welche Bits in den Registern Sie setzen m√ºssen, um die erforderliche Einstellung zu erhalten.  Es ist erw√§hnenswert, dass alle Zahnspangen deaktiviert sind.  Wo kann man nach einer alternativen Funktion suchen?  Gehen Sie dazu auf Seite 76 im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenblatt</a> unseres Controllers und sehen Sie sich die folgende Tabelle an: <br><br><img src="https://habrastorage.org/webt/d1/6a/6-/d16a6-uye3sjdb7rrf_m-qnz2os.png"><br><br>  Wie Sie sehen k√∂nnen, ist die Logik der Tabelle einfach: Wir finden die Funktion, die wir ben√∂tigen, in unserem Fall LTDC B0, dann schauen wir uns an, auf welchem ‚Äã‚ÄãGPIO es sich befindet (z. B. PE4), und oben sehen wir die Nummer der alternativen Funktion, die wir zum Konfigurieren verwenden werden (AF14 mit uns).  Um unseren Ausgang als Push-Pull-Ausgang mit einer alternativen Funktion, LTDC B0, zu konfigurieren, m√ºssen wir den folgenden Code schreiben: <br><br><pre> <code class="cpp hljs">GPIOE-&gt;MODER &amp;= ~GPIO_MODER_MODER4; GPIOE-&gt;MODER |= GPIO_MODER_MODER4_1; GPIOE-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR4_1; GPIOE-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;= ~GPIO_AFRL_AFRL4_0; GPIOE-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] |= GPIO_AFRL_AFRL4_1 | GPIO_AFRL_AFRL4_2 | GPIO_AFRL_AFRL4_3;</code> </pre><br>  Ich habe ein Beispiel f√ºr den PE4-Pin gegeben, der Pin B0 auf dem LTDC-Bus entspricht, dh, es ist ein Null-Bit von blauer Farbe.  F√ºr alle anderen Schlussfolgerungen ist die Einstellung identisch, nur 2 Schlussfolgerungen verdienen besondere Aufmerksamkeit, eine der fertigen enth√§lt eine Anzeige und die andere die Hintergrundbeleuchtung.  Sie sind als normaler Push-Pull-Ausgang konfiguriert, mit dem jeder eine LED blinkt.  Das Setup sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs">GPIOK-&gt;MODER &amp;= ~GPIO_MODER_MODER3; GPIOK-&gt;MODER |= GPIO_MODER_MODER3_0;</code> </pre><br>  Diese Einstellung gilt f√ºr die PK3-Ausgabe, bei der die Hintergrundbeleuchtung ein- und ausgeschaltet wird.  √úbrigens k√∂nnen Sie es auch DR√úCKEN, um die Helligkeit reibungslos anzupassen.  Bei PI12, das ein Display (DISP) enth√§lt, ist alles gleich.  Die Geschwindigkeit an diesen 2 Pins ist standardm√§√üig niedrig, weil  Einige Hochfrequenzaktionen sind von ihnen nicht erforderlich. <br><br>  Sie k√∂nnen alle anderen E / A-Ports auf der Platine der Debug-Platine oder im Schaltplan Ihres eigenen Ger√§ts anzeigen. <br><br><h2>  5. Timings und ihre Einstellungen </h2><br>  Timings aus physikalischer Sicht sind gew√∂hnliche Verz√∂gerungen.  Ich denke, Sie haben wiederholt verschiedene Perversionen vom Typ Verz√∂gerung (1) beobachtet, als Sie sich Codebeispiele auf Displays mit SPI / I2C-Controllern √§hnlich ILI9341 angesehen haben.  Dort ist eine Verz√∂gerung erforderlich, damit der Controller beispielsweise Zeit hat, den Befehl anzunehmen, auszuf√ºhren und dann etwas mit den Daten zu tun.  Im Fall von LTDC ist alles ungef√§hr gleich, nur werden wir keine Kr√ºcken herstellen und warum nicht - unser Mikrocontroller selbst kann die erforderlichen Timings in der Hardware konfigurieren.  Warum werden sie auf einem Display ben√∂tigt, auf dem kein Controller vorhanden ist?  Ja, es ist elementar, dass Sie nach dem F√ºllen der ersten Pixelzeile zur n√§chsten Zeile wechseln und zum Anfang zur√ºckkehren.  Dies ist auf die Technologie der Herstellung von Displays zur√ºckzuf√ºhren, und daher hat jedes spezifische Displaymodell seine eigenen Timings. <br><br>  Um herauszufinden, welche Werte wir ben√∂tigen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besuchen Sie</a> die ST-Website und sehen Sie sich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diagramm der STM32F746-Disco-Debug-Karte an</a> .  Dort k√∂nnen wir sehen, dass das Display <i>RK043FN48H-CT672B ist</i> und die Dokumentation dazu zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verf√ºgbar ist.  Die Tabelle auf Seite 13 in Abschnitt 7.3.1 interessiert uns am meisten: <br><br><img src="https://habrastorage.org/webt/t7/fk/ou/t7fkoukmcua7rsnn6bmema1dhio.png"><br><br>  Dies sind unsere Werte, die wir beim Einrichten ben√∂tigen.  In der Dokumentation finden Sie auch viel Interessanteres, z. B. Signaldiagramme auf dem Bus usw., die Sie m√∂glicherweise ben√∂tigen, wenn Sie beispielsweise die Anzeige auf FPGA oder CPLD erh√∂hen m√∂chten. <br><br>  Gehen Sie zu den Einstellungen.  Um diese Werte nicht im Kopf zu behalten, werde ich sie zun√§chst in Form von Definitionen anordnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HSYNC ((uint16_t)30) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HBP ((uint16_t)13) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HFP ((uint16_t)32) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VSYNC ((uint16_t)10) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VBP ((uint16_t)2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VFP ((uint16_t)2)</span></span></code> </pre><br>  Es gibt eine interessante Funktion.  Die Timing- <i>Impulsbreite</i> , die als <i>DISPLAY_HSYNC bezeichnet wird</i> , hat in der Tabelle nur einen Wert f√ºr die Pixeltaktfrequenz von 5 MHz, f√ºr 9 und 12 MHz jedoch nicht.  Dieses Timing muss f√ºr Ihre Anzeige ausgew√§hlt werden. Ich habe diesen Wert von 30 erhalten, als es in den Beispielen von ST anders war.  Wenn Sie beim ersten Start einen Fehler bei der Einstellung haben, wird das Bild entweder nach links oder nach rechts verschoben.  Wenn es rechts ist, verringern wir das Timing, wenn es links ist, erh√∂hen wir es.  Tats√§chlich beeinflusst es den Ursprung der sichtbaren Zone, die wir sp√§ter sehen werden.  Denken Sie daran, und das folgende Bild von Seite 24 unseres AN4861 hilft, diesen gesamten Absatz zu verstehen: <br><br><img src="https://habrastorage.org/webt/nu/cd/gc/nucdgcesjmx8gqq-bjwfnusk0vc.png"><br><br>  Eine kleine Abstraktion ist hier zweckm√§√üig.  Wir haben 2 Anzeigezonen: sichtbar und allgemein.  Die sichtbare Zone hat Abmessungen mit einer deklarierten Aufl√∂sung von 480 x 272 Pixel, und die Gesamtzone ist die sichtbare + unsere Zeitsteuerung, von der es auf jeder Seite 3 gibt.  Es lohnt sich auch zu verstehen (dies ist keine Abstraktion mehr), dass ein System-Tick 1 Pixel betr√§gt, sodass die Gesamtfl√§che 480 Pixel + HSYNC + HBP + HFP betr√§gt. <br><br>  Es lohnt sich auch zu erkennen, dass je weniger Timings, desto besser - die Anzeige wird schneller aktualisiert und die Bildrate wird leicht erh√∂ht.  Experimentieren Sie daher nach dem ersten Lauf mit den Timings und reduzieren Sie sie so weit wie m√∂glich, w√§hrend Sie die Stabilit√§t beibehalten. <br><br>  Um die Zeiten festzulegen, habe ich mir innerhalb des Projekts einen kleinen ‚ÄûSpickzettel‚Äú f√ºr die Zukunft gemacht. Er hilft Ihnen auch zu verstehen, welche bestimmte Figur und wo Sie sie schreiben sollen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *************************** Timings for TFT display********************************** * * HSW = (DISPLAY_HSYNC - 1) * VSH = (DISPLAY_VSYNC - 1) * AHBP = (DISPLAY_HSYNC + DISPLAY_HBP - 1) * AVBP = (DISPLAY_VSYNC + DISPLAY_VBP - 1) * AAW = (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - 1) * AAH = (DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP - 1) * TOTALW = (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP + DISPLAY_VFP - 1) * TOTALH = (DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP + DISPLAY_HFP - 1) * */</span></span></code> </pre><br>  Woher kommt dieser ‚ÄûSpickzettel‚Äú? Zuerst haben Sie einige Abs√§tze zuvor eine √§hnliche ‚ÄûFormel‚Äú gesehen.  Zweitens gehen Sie zu Seite 56 unseres AN4861: <br><br><img src="https://habrastorage.org/webt/sz/zf/yc/szzfyccwyqfw_t9ki0dazyck3ys.png"><br><br>  Ich hoffe, Sie haben die physikalische Bedeutung der Timings vor dem Erscheinen dieses Spickzettel verstanden und ich bin sicher, dass Sie es selbst h√§tten zusammenstellen k√∂nnen.  Es ist nichts Kompliziertes daran, und Bilder von RM und AN helfen dabei, die Auswirkung von Timings auf den Bilderzeugungsprozess visuell zu verstehen. <br><br>  Jetzt ist es Zeit, einen Code zu schreiben, der diese Timings festlegt.  In dem "Spickzettel" sind die Bits des Registers angegeben, in die beispielsweise TOTALH geschrieben werden soll, und nachdem das Vorzeichen gleich der Formel ist, die der Ausgabe eine bestimmte Zahl gibt.  Okay?  Dann schreiben wir: <br><br><pre> <code class="cpp hljs">LTDC-&gt;SSCR |= ((DISPLAY_HSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_VSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>)); LTDC-&gt;BPCR |= ((DISPLAY_HSYNC+DISPLAY_HBP<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_VSYNC+DISPLAY_VBP<span class="hljs-number"><span class="hljs-number">-1</span></span>)); LTDC-&gt;AWCR |= ((DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - <span class="hljs-number"><span class="hljs-number">1</span></span>)); LTDC-&gt;TWCR |= ((DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP + DISPLAY_HFP <span class="hljs-number"><span class="hljs-number">-1</span></span>)&lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> |(DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP + DISPLAY_VFP - <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  Und das ist alles mit Timings!  In diesem Abschnitt k√∂nnen Sie nur die Hintergrundfarbe konfigurieren.  Ich habe es standardm√§√üig schwarz, daher ist es in Null geschrieben.  Wenn Sie die Farbe der Hintergrundebene (Hintergrund) √§ndern m√∂chten, k√∂nnen Sie auch einen beliebigen Wert schreiben, z. B. <i>0xFFFFFFFF,</i> und alles mit Wei√ü f√ºllen: <br><br><pre> <code class="cpp hljs">LTDC-&gt;BCCR = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  Das <i>Referenzhandbuch enth√§lt</i> eine wunderbare Illustration, die deutlich zeigt, dass wir tats√§chlich drei Ebenen haben: Hintergrund, Ebene 1 und Ebene 2. Die Hintergrundebene ist ‚Äûkastriert‚Äú und kann nur mit einer bestimmten Farbe gef√ºllt werden, kann aber auch bei der Implementierung unglaublich n√ºtzlich sein zuk√ºnftiges GUI-Design.  Diese Abbildung zeigt auch deutlich die Priorit√§t von Ebenen. Dies bedeutet, dass die F√ºllfarbe nur dann im Hintergrund angezeigt wird, wenn die verbleibenden Ebenen entweder leer oder transparent sind. <br><br>  Als Beispiel zeige ich eine der Seiten des Projekts, auf der w√§hrend der Implementierung der Vorlage der Hintergrund mit einer Farbe gef√ºllt wurde und der Controller nicht die gesamte Seite neu zeichnete, sondern nur einzelne Sektoren, die f√ºr viele andere Aufgaben etwa 50-60 fps empfangen konnten: <br><br><img src="https://habrastorage.org/webt/7b/yn/il/7byniliyqlnqy0yyzpfk8um7_mg.jpeg"><br><br><h2>  6. Der letzte Teil des LTDC-Setups </h2><br>  Die LTDC-Einstellungen sind in zwei Abschnitte unterteilt: Der erste ist f√ºr das gesamte LTDC-Modul gleich und befindet sich in der <i>LTDC-</i> Registergruppe. Der zweite <i>Abschnitt</i> ist in einer von zwei Ebenen konfiguriert und befindet sich in der <i>Gruppe</i> <i>LTDC_Layer1</i> und <i>LTDC_Layer2</i> . <br><br>  Wir haben die allgemeinen Einstellungen im vorherigen Absatz vorgenommen. Dazu geh√∂ren das Einstellen der Timings und der Hintergrundebene.  Nun fahren wir mit dem Festlegen der Ebenen fort und unsere Liste erfordert die tats√§chliche Gr√∂√üe der sichtbaren Zone der Ebene, die in Form von 4 Koordinaten (x0, y0, x1, y2) beschrieben wird, mit denen wir die Abmessungen des Rechtecks ‚Äã‚Äãerhalten k√∂nnen.  Die Gr√∂√üe der sichtbaren Ebene kann geringer sein als die Aufl√∂sung der Anzeige. Niemand st√∂rt sich daran, die Gr√∂√üe der Ebene auf 100 pro 100 Pixel festzulegen.  Schreiben Sie den folgenden Code, um die Gr√∂√üe der sichtbaren Zone anzupassen: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;WHPCR |= (((DISPLAY_WIDTH + DISPLAY_HBP + DISPLAY_HSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (DISPLAY_HBP + DISPLAY_HSYNC)); LTDC_Layer2-&gt;WVPCR |= (((DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) |(DISPLAY_VSYNC + DISPLAY_VBP));</code> </pre><br>  Wie Sie sehen k√∂nnen, ist alles genau wie bei den Timings.  Die Startpunkte (x0, y0) der sichtbaren Zone bestehen aus der Summe zweier Timings: HSYNC + HBP und VSYNC + VBP.  Um die Koordinaten des Endpunkts (x1, y1) zu berechnen, werden Breite und H√∂he in Pixel einfach zu den Wertdaten hinzugef√ºgt. <br><br>  Jetzt m√ºssen Sie das Format der empfangenen Daten konfigurieren.  Die maximale Qualit√§t wird bei Verwendung des ARGB8888-Formats erzielt, gleichzeitig erhalten wir jedoch die maximale Menge an belegtem Speicher.  Ein Pixel belegt 32 Bit oder 4 Bytes, was bedeutet, dass der gesamte Bildschirm 4 * 480 * 272 = 522.240 Bytes ben√∂tigt, dh die H√§lfte des Flash-Speichers unseres nicht schw√§chsten Controllers.  Haben Sie keine Angst - das Anschlie√üen von externem SDRAM und Flash-Speicher √ºber QSPI l√∂st Speicherprobleme und es gibt keine Einschr√§nkungen f√ºr dieses Format. Wir freuen uns √ºber gute Qualit√§t.  Wenn Sie Platz sparen m√∂chten oder Ihr Display das 24-Bit-Format nicht unterst√ºtzt, werden hierf√ºr geeignetere Modelle verwendet, z. B. RGB565.  Ein sehr beliebtes Format f√ºr Displays und Kameras. Vor allem bei Verwendung ben√∂tigt 1 Pixel nur 5 + 6 + 5 = 16 Bit oder 2 Byte.  Dementsprechend ist die von der Schicht belegte Speichermenge zweimal geringer.  Standardm√§√üig ist auf dem Controller bereits das ARGB8888-Format konfiguriert und sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;PFCR = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Wenn Sie ein anderes Format als ARGB8888 ben√∂tigen, gehen Sie zu den Seiten 533 und 534 im <i>Referenzhandbuch</i> und w√§hlen Sie das gew√ºnschte Format aus der folgenden Liste aus: <br><br><img src="https://habrastorage.org/webt/be/fg/qa/befgqaa2-iokyso1coeqhaii9zu.png"><br><br>  Erstellen Sie nun ein Array und √ºbergeben Sie seine Adresse an LTDC. Es wird zu einem Frame-Puffer und ist eine ‚ÄûReflexion‚Äú unserer Ebene.  Beispielsweise m√ºssen Sie das 1. Pixel in der 1. Zeile mit wei√üer Farbe f√ºllen. Dazu m√ºssen Sie nur den Farbwert (0xFFFFFFFF) in das erste Element dieses Arrays schreiben.  M√ºssen Sie das 1. Pixel in der 2. Zeile f√ºllen?  Dann schreiben wir auch den Farbwert in das Element mit der Zahl (480 + 1).  480 - Machen Sie einen Zeilenumbruch und f√ºgen Sie dann die Nummer in die Zeile ein, die wir ben√∂tigen. <br><br>  Diese Einstellung sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_WIDTH ((uint16_t)480) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HEIGHT ((uint16_t)272) const uint32_t imageLayer2[DISPLAY_WIDTH * DISPLAY_HEIGHT]; LTDC_Layer2-&gt;CFBAR = (uint32_t)imageLayer2;</span></span></code> </pre><br>  In guter Weise m√ºssen Sie nach der Konfiguration von LTDC auch SDRAM konfigurieren, um den <i>const-</i> Modifikator zu entfernen und den Frame-Puffer im RAM abzurufen, weil  Der eigene RAM von MK reicht nicht einmal f√ºr eine Schicht mit 4 Bytes.  Dies tut zwar nicht weh, um die korrekte Konfiguration der Peripherieger√§te zu testen. <br><br>  Als n√§chstes m√ºssen Sie den Wert der Alpha-Ebene angeben, <i>dh</i> die Transparenz f√ºr unsere <i>Layer2-</i> Ebene. Dazu schreiben wir einen Wert von 0 bis 255, wobei 0 eine vollst√§ndig transparente Ebene ist, 255 vollst√§ndig undurchsichtig ist und zu 100% sichtbar ist: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CACR = <span class="hljs-number"><span class="hljs-number">255</span></span>;</code> </pre> <br>  Nach unserem Plan ist es nun notwendig, die Gr√∂√üe unseres sichtbaren Anzeigebereichs in Bytes aufzuzeichnen, dazu schreiben wir die entsprechenden Werte in die Register: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CFBLR |= (((PIXEL_SIZE * DISPLAY_WIDTH) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (PIXEL_SIZE * DISPLAY_WIDTH + <span class="hljs-number"><span class="hljs-number">3</span></span>)); LTDC_Layer2-&gt;CFBLNR |= DISPLAY_HEIGHT;</code> </pre><br>  Die letzten beiden Schritte verbleiben, n√§mlich die Einbeziehung der Schicht 2 und des LTDC-Peripheriemoduls selbst.  Schreiben Sie dazu die entsprechenden Bits: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CR |= LTDC_LxCR_LEN; LTDC-&gt;GCR |= LTDC_GCR_LTDCEN;</code> </pre><br>  Damit ist die Konfiguration unseres Moduls abgeschlossen und Sie k√∂nnen mit unserem Display arbeiten! <br><br><h2>  7. Ein wenig √ºber die Arbeit mit LTDC </h2><br>  Bei allen Arbeiten mit dem Display m√ºssen nur noch Daten in das <i>imageLayer2-</i> Array geschrieben werden. Es hat eine Gr√∂√üe von 480 <i>x</i> 272 Elementen, was unserer Aufl√∂sung vollst√§ndig entspricht und auf eine einfache Wahrheit hinweist - <b>1 Array-Element = 1 Pixel auf dem Display</b> . <br><br>  Als Beispiel habe ich ein Bild in ein Array geschrieben, in das ich in <b>LCD Image Converter</b> konvertiert habe. In Wirklichkeit ist es jedoch unwahrscheinlich, dass sich Ihre Aufgaben darauf beschr√§nken.  Es gibt zwei M√∂glichkeiten: Verwenden einer vorgefertigten Benutzeroberfl√§che und Schreiben selbst.  F√ºr relativ einfache Aufgaben wie Textausgabe, grafische Darstellung und dergleichen empfehle ich Ihnen, eine eigene GUI zu schreiben. Dies dauert einige Zeit und vermittelt Ihnen ein umfassendes Verst√§ndnis der Funktionsweise.  Wenn die Aufgabe gro√ü und schwierig ist und keine Zeit f√ºr die Entwicklung einer eigenen Benutzeroberfl√§che bleibt, empfehle ich Ihnen, auf vorgefertigte L√∂sungen zu achten, z. B. uGFX und dergleichen. <br><br>  Symbole f√ºr Text, Linien und andere Elemente sind von Natur aus Pixelarrays. Um sie zu implementieren, m√ºssen Sie die Logik selbst implementieren. Sie sollten jedoch mit der grundlegendsten Funktion beginnen - der ‚ÄûPixelausgabe‚Äú.  Es sollten 3 Argumente erforderlich sein: die Koordinate entlang X, die Koordinate entlang Y und dementsprechend die Farbe, in der das angegebene Pixel gezeichnet wird.  Es kann so aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ColorDisplay { RED = <span class="hljs-number"><span class="hljs-number">0xFFFF0000</span></span>, GREEN = <span class="hljs-number"><span class="hljs-number">0xFF00FF00</span></span>, BLUE = <span class="hljs-number"><span class="hljs-number">0xFF0000FF</span></span>, BLACK = <span class="hljs-number"><span class="hljs-number">0xFF000000</span></span>, WHITE = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span> } Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPixel</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> setX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> setY, Color Color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numBuffer = ((setY - <span class="hljs-number"><span class="hljs-number">1</span></span>) * DISPLAY_WIDTH) + setX; imageLayer2[numBuffer] = Color; }</code> </pre><br>  Nachdem wir die Koordinaten in eine Funktion √ºbernommen haben, berechnen wir sie neu in die Nummer des Arrays, das der angegebenen Koordinate entspricht, und schreiben dann die empfangene Farbe in das empfangene Element.  Basierend auf dieser Funktion k√∂nnen Sie bereits Funktionen zum Anzeigen von Geometrie, Text und anderen GUI-Extras implementieren.  Ich denke, die Idee ist verst√§ndlich, aber wie Sie sie zum Leben erwecken k√∂nnen, liegt in Ihrem Ermessen. <br><br><h2>  Zusammenfassung </h2><br>  Wie Sie sehen, ist die Implementierung selbst komplexer Peripherieger√§te in Registern (CMSIS) keine schwierige Aufgabe. Sie m√ºssen lediglich verstehen, wie sie im Inneren funktioniert.  Nat√ºrlich ist es jetzt in Mode, Firmware zu entwickeln, ohne zu verstehen, was passiert, aber dies ist eine Sackgasse, wenn Sie vorhaben, Ingenieur zu werden, und nicht ... <br><br>  Wenn Sie den resultierenden Code mit einer L√∂sung in HAL oder SPL vergleichen, werden Sie feststellen, dass der in Registern geschriebene Code kompakter ist.  Wenn Sie ein paar Kommentare hinzuf√ºgen, wo Sie sie ben√∂tigen, und sie in Funktionen einbinden, erhalten wir eine Lesbarkeit, die mindestens nicht schlechter ist als die von HAL / SPL. Wenn Sie sich daran erinnern, dass das <i>Referenzhandbuch</i> die Register dokumentiert, ist die Arbeit mit CMSIS bequemer. <br><br>  1) Das Projekt mit Quellen in TrueSTUDIO kann hier heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> <br><br>  2) F√ºr diejenigen, die sich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> wohler f√ºhlen <br><br>  3) Laden Sie hier das Dienstprogramm zum Konvertieren von Bildern in LCD Image Converter-Code herunter </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412753/">https://habr.com/ru/post/de412753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412741/index.html">Wie Sie aufh√∂ren k√∂nnen, Angst zu haben, dass k√ºnstliche Intelligenz Sie ohne Arbeit l√§sst</a></li>
<li><a href="../de412743/index.html">Beruf: Cyber ‚Äã‚ÄãDetective</a></li>
<li><a href="../de412747/index.html">MIS. Speicherung medizinischer Daten</a></li>
<li><a href="../de412749/index.html">Elektronik als Kunst: Elektrischer Strom</a></li>
<li><a href="../de412751/index.html">Kahlheit: Theorie und Praxis der Behandlung, Teil 1 "Mein Dihydrotestosteron, mein Feind"</a></li>
<li><a href="../de412755/index.html">Telegram hat den offiziellen MTProto Proxy Server ver√∂ffentlicht</a></li>
<li><a href="../de412757/index.html">LED-Lampen in Japan</a></li>
<li><a href="../de412759/index.html">Neuer MTProto-Proxy-Server von Telegram</a></li>
<li><a href="../de412763/index.html">Verwenden des Firefly-RK3288-Reload-Boards mit dem RockChip RK3288-SoC Mikrochip Digitaler I2C-W√§rmesensor - MCP9808</a></li>
<li><a href="../de412765/index.html">Einf√ºhrung in das neue Unity-Kachelkartensystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>