<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛵 👨🏽‍🌾 👨🏻‍🏭 Arbeiten Sie mit der Liste der Pins in C ++ für Mikrocontroller (am Beispiel von CortexM). 🚟 😚 👞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gute Gesundheit an alle! 


 In einem früheren Artikel habe ich versprochen, darüber zu schreiben, wie Sie mit einer Liste von Ports arbeiten können. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arbeiten Sie mit der Liste der Pins in C ++ für Mikrocontroller (am Beispiel von CortexM).</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474732/"><p><img src="https://habrastorage.org/webt/al/fo/qs/alfoqsca21zydklcnzomwtqdgwe.png"></p><br><p>  Gute Gesundheit an alle! </p><br><p>  In einem früheren Artikel habe ich versprochen, darüber zu schreiben, wie Sie mit einer Liste von Ports arbeiten können. <br>  Ich muss gleich sagen, dass bereits 2010 alles vor mir entschieden wurde, hier der Artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Arbeiten mit den Ein- / Ausgabeports von Mikrocontrollern in C ++</a> .  Die Person, die dies 2010 geschrieben hat, sieht einfach gut aus. </p><br><p>  Es war mir ein wenig peinlich, dass ich das tun würde, was bereits vor 10 Jahren getan wurde, also beschloss ich, nicht auf 2020 zu warten, sondern es 2019 zu tun, um die Entscheidung so lange wie vor 9 Jahren zu wiederholen, es wird nicht so dumm sein. </p><br><p> Im obigen Artikel wurde die Arbeit mit Typlisten mit C ++ 03 durchgeführt, wenn mehr Vorlagen eine feste Anzahl von Parametern hatten und Funktionen keine constexpr-Ausdrücke sein konnten.  Seitdem hat sich C ++ ein wenig geändert. Versuchen wir also, dasselbe zu tun, jedoch in C ++ 17.  Willkommen bei Katze: </p><a name="habracut"></a><br><h2 id="zadacha">  Herausforderung </h2><br><p>  Die Aufgabe besteht also darin, mehrere Prozessor-Pins gleichzeitig zu installieren oder zu entfernen, die zu einer Liste zusammengefasst werden.  Pins können sich an verschiedenen Ports befinden. Trotzdem sollte ein solcher Vorgang so effizient wie möglich durchgeführt werden. </p><br><p>  Tatsächlich kann mit dem Code gezeigt werden, was wir tun möchten: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin1 = Pin&lt;GPIO, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin2 = Pin&lt;GPIOB, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin3 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin4 = Pin&lt;GPIOC, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin5 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    Pin    : //   GPIOA  10 GPIOA-&gt;BSRR = 10 ; // (1&lt;&lt;1) | (1 &lt;&lt; 3) ; //   GPIOB  2 GPIOB-&gt;BSRR = 2 ; // (1 &lt;&lt; 1) //   GPIOC  6 GPIOB-&gt;BSRR = 6 ; // (1 &lt;&lt; 1) | (1 &lt;&lt; 2); PinsPack&lt;Pin1, Pin2, Pin3, Pin4, Pin5&gt;::Set() ; return 0; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Über das BSRR-Register</b> <div class="spoiler_text"><p>  Für diejenigen, die sich der Angelegenheiten des Mikrocontrollers nicht bewusst sind, ist das <code>GPIOA-&gt;BSRR</code> Register für die atomare Installation oder das Zurücksetzen von Werten an den Beinen des Mikrocontrollers verantwortlich.  Dieses Register ist 32 Bit.  Die ersten 16 Bits sind für das Setzen von 1 an den Beinen verantwortlich, die zweiten 16 Bits für das Setzen von 0 an den Beinen. </p><br><p>  Um beispielsweise den <code>BSRR</code> Nummer 3 auf 1 zu setzen, müssen Sie das dritte Bit im <code>BSRR</code> Register auf 1 <code>BSRR</code> . Um den <code>BSRR</code> Nummer 3 auf 0 zurückzusetzen, müssen Sie im selben <code>BSRR</code> Register 19 Bits auf 1 <code>BSRR</code> . </p></div></div><br><p>  Ein verallgemeinertes Schema von Schritten zur Lösung dieses Problems kann wie folgt dargestellt werden: </p><br><p><img src="https://habrastorage.org/webt/xl/zu/wm/xlzuwmbfoudvd9tf6jwlh-ih-vs.png"></p><br><p>  Mit anderen Worten: </p><br><p>  <em>Für den Compiler:</em> </p><br><ul><li>  Stellen Sie sicher, dass die Liste nur einen eindeutigen Pin enthält </li><li>  Erstellen einer Liste von Ports durch Bestimmen, an welchen Ports sich der Pin befindet; </li><li>  Berechnen des Wertes, der in jeden Port eingegeben werden soll </li></ul><br><p>  <em>Und dann das Programm</em> </p><br><ul><li>  Stellen Sie diesen Wert ein </li></ul><br><p>  Und Sie müssen dies so effizient wie möglich tun, damit der Code auch ohne Optimierung minimal ist.  Eigentlich ist das die ganze Aufgabe. </p><br><p>  Beginnen wir mit der ersten Modeerscheinung: Verifizieren, dass die Liste einen eindeutigen Pin enthält. </p><br><h2 id="proverka-spiska-na-unikalnost">  Überprüfen Sie die Liste auf Eindeutigkeit </h2><br><p>  Ich möchte Sie daran erinnern, dass wir eine Liste mit Pins haben: </p><br><pre> <code class="cpp hljs">PinsPack&lt;Pin1, Pin2, Pin3, Pin4, Pin5&gt; ;</code> </pre> <br><p><del>  Versehentlich </del>  kann dies tun: </p><br><pre> <code class="cpp hljs">PinsPack&lt;Pin1, Pin2, Pin3, Pin4, Pin1&gt; ; <span class="hljs-comment"><span class="hljs-comment">//     Pin1</span></span></code> </pre> <br><p>  Ich möchte, dass der Compiler einen solchen Fehler auffängt und den Pianisten darüber informiert. </p><br><p>  Wir werden die Liste wie folgt auf Eindeutigkeit prüfen: </p><br><ul><li>  Erstellen Sie aus der Quellliste eine neue Liste ohne Duplikate. </li><li>  Wenn der Typ der Quellliste und der Typ der Liste ohne Duplikate nicht übereinstimmen, war die PIN in der Quellliste gleich und der Programmierer hat einen Fehler gemacht. </li><li>  Wenn sie übereinstimmen, ist alles in Ordnung, es gibt keine Duplikate. </li></ul><br><p>  Um eine neue Liste ohne Duplikate zu erstellen, riet ein Kollege, das Rad nicht neu zu erfinden und den Ansatz aus der Loki-Bibliothek zu übernehmen.  Ich habe diesen Ansatz und gestohlen.  Fast das gleiche wie 2010, jedoch mit einer variablen Anzahl von Parametern. </p><br><div class="spoiler">  <b class="spoiler_title">Der Code, der von einem Kollegen ausgeliehen wurde, der die Idee von Loki ausgeliehen hat</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> PinHelper { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-comment"><span class="hljs-comment">/////////////////   NoDuplicates   LOKI //////////////// template&lt;class X, class Y&gt; struct Glue; template&lt;class T, class... Ts&gt; struct Glue&lt;T, Collection&lt;Ts...&gt;&gt; { using Result = Collection&lt;T, Ts...&gt;; }; template&lt;class Q, class X&gt; struct Erase; template&lt;class Q&gt; struct Erase&lt;Q, Collection&lt;&gt;&gt; { using Result = Collection&lt;&gt;;}; template&lt;class Q, class... Tail&gt; struct Erase&lt;Q, Collection&lt;Q, Tail...&gt;&gt; { using Result = Collection&lt;Tail...&gt;;}; template&lt;class Q, class T, class... Tail&gt; struct Erase&lt;Q, Collection&lt;T, Tail...&gt;&gt; { using Result = typename Glue&lt;T, typename Erase&lt;Q, Collection&lt;Tail...&gt;&gt;::Result&gt;::Result;}; template &lt;class X&gt; struct NoDuplicates; template &lt;&gt; struct NoDuplicates&lt;Collection&lt;&gt;&gt; { using Result = Collection&lt;&gt;; }; template &lt;class T, class... Tail&gt; struct NoDuplicates&lt; Collection&lt;T, Tail...&gt; &gt; { private: using L1 = typename NoDuplicates&lt;Collection&lt;Tail...&gt;&gt;::Result; using L2 = typename Erase&lt;T,L1&gt;::Result; public: using Result = typename Glue&lt;T, L2&gt;::Result; }; ///////////////// LOKI //////////////// }</span></span></code> </pre> </div></div><br><p>  Wie kann dies jetzt verwendet werden?  Ja, es ist sehr einfach: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin1 = Pin&lt;GPIOC, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin2 = Pin&lt;GPIOB, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin3 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin4 = Pin&lt;GPIOC, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin5 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin6 = Pin&lt;GPIOC, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Pin1  ,    Pin6      using PinList = Collection&lt;Pin1, Pin2, Pin3, Pin4, Pin1, Pin6&gt; ; using TPins = typename NoDuplicates&lt;PinList&gt;::Result; //  static_assert.        // : Collection&lt;Pin1, Pin2, Pin3, Pin4, Pin1, Pin6&gt; //   : Collection&lt;Pin1, Pin2, Pin3, Pin4&gt; // ,    static_assert(std::is_same&lt;TPins, PinList&gt;::value, ":    ") ; return 0; }</span></span></code> </pre> <br><p>  Nun, d.h.  Wenn Sie die Liste der Stifte falsch eingestellt haben und versehentlich zwei identische Stifte in der Liste angezeigt werden, wird das Programm nicht kompiliert und der Compiler gibt den folgenden Fehler aus: "Problem: Dieselben Stifte in der Liste." </p><br><div class="spoiler">  <b class="spoiler_title">Übrigens können Sie den folgenden Ansatz verwenden, um die korrekte Liste der Pins für Ports sicherzustellen:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        // PinsPack&lt;Port&lt;GPIOB, 0&gt;, Port&lt;GPIOB, 1&gt; ... Port&lt;GPIOB, 15&gt;&gt; using GpiobPort = typename GeneratePins&lt;15, GPIOB&gt;::type //      using GpioaPort = typename GeneratePins&lt;15, GPIOA&gt;::type int main() { //    :  GPIOA.0  1 Gpioa&lt;0&gt;::Set() ; // GPIOB.1  0 Gpiob&lt;1&gt;::Clear() ; using LcdData = Collection&lt;Gpioa&lt;0&gt;, Gpiob&lt;6&gt;, Gpiob&lt;2&gt;, Gpioa&lt;3&gt;, Gpioc&lt;7&gt;, Gpioa&lt;4&gt;, Gpioc&lt;3&gt;, Gpioc&lt;10&gt;&gt; ; using TPinsLcd = typename NoDuplicates&lt;LcdData&gt;::Result; static_assert(std::is_same&lt;TPinsB, LcdData&gt;::value, ":        LCD") ; // A      LcdData::Write('A'); }</span></span></code> </pre> </div></div><br><p>  Wir haben hier bereits so viel geschrieben, aber es gibt bisher keine einzige Zeile echten Codes, die in den Mikrocontroller gelangt.  Wenn alle Pins richtig gesetzt sind, sieht das Firmware-Programm folgendermaßen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br><p>  Fügen wir einen Code hinzu und versuchen, die <code>Set()</code> -Methode zum Setzen der Pins in der Liste zu verwenden. </p><br><h2 id="metod-ustanovki-pinov-v-porte">  Installationsmethode für Anschlussstifte </h2><br><p>  Lassen Sie uns kurz zum Ende der Aufgabe vordringen.  Letztendlich ist es notwendig, die <code>Set()</code> -Methode zu implementieren, die automatisch basierend auf dem Pin in der Liste bestimmt, welche Werte an welchem ​​Port installiert werden sollen. </p><br><div class="spoiler">  <b class="spoiler_title">Der Code, den wir wollen</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin1 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin2 = Pin&lt;GPIOB, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin3 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin4 = Pin&lt;GPIOC, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin5 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PinsPack&lt;Pin1, Pin2, Pin3, Pin4, Pin5&gt;::Set() ; <span class="hljs-comment"><span class="hljs-comment">//      3   // GPIOA-&gt;BSRR = 14 ; // (1&lt;&lt;1) | (1 &lt;&lt; 2) | (1 &lt;&lt; 3) ; // GPIOB-&gt;BSRR = 4 ; // (1 &lt;&lt; 2) // GPIOB-&gt;BSRR = 2 ; // (1 &lt;&lt; 1); }</span></span></code> </pre> </div></div><br><p>  Daher deklarieren wir eine Klasse, die eine Liste von Pins enthält, und definieren darin die öffentliche statische Methode <code>Set()</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PinsPack</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pins = PinsPack&lt;Ts...&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ } } ;</code> </pre> <br><p>  Wie Sie sehen, nimmt die Methode <code>Set(size_t mask)</code> einen Wert (mask) an.  Diese Maske ist die Nummer, die Sie in die Ports eingeben müssen.  Standardmäßig ist es 0xffffffff, was bedeutet, dass wir alle Pins in die Liste aufnehmen möchten (maximal 32).  Wenn Sie dort einen anderen Wert übergeben, z. B. 7 == 0b111, sollten nur die ersten 3 Pins in der Liste installiert werden und so weiter.  Das heißt  Maske überlagert die Pin-Liste. </p><br><h2 id="formirovanie-spiska-portov">  Portliste </h2><br><p>  Um etwas in die Pins installieren zu können, müssen Sie wissen, an welchen Ports sich diese Pins befinden.  Jeder Pin ist an einen bestimmten Port gebunden, und wir können diese Ports aus der Pin-Klasse ziehen und eine Liste dieser Ports erstellen. </p><br><p>  Unsere Pins sind verschiedenen Ports zugeordnet: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin1 = Pin&lt;Port&lt;GPIOA&gt;, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin2 = Pin&lt;Port&lt;GPIOB&gt;, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin3 = Pin&lt;Port&lt;GPIOA&gt;, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin4 = Pin&lt;Port&lt;GPIOC&gt;, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin5 = Pin&lt;Port&lt;GPIOA&gt;, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;;</code> </pre> <br><p>  Diese 5 Pins haben nur 3 eindeutige Ports (GPIOA, GPIOB, GPIOC).  Wenn wir eine Liste von <code>PinsPack&lt;Pin1, Pin2, Pin3, Pin4, Pin5&gt;</code> wir eine Liste von drei Ports daraus <code>Collection&lt;Port&lt;GPIOA&gt;, Port&lt;GPIOB&gt;, Port&lt;GPIOC&gt;&gt;</code> : <code>Collection&lt;Port&lt;GPIOA&gt;, Port&lt;GPIOB&gt;, Port&lt;GPIOC&gt;&gt;</code> </p><br><p>  Die Pin-Klasse enthält den Porttyp und sieht in vereinfachter Form folgendermaßen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortType = Port ; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin = pinNum ; ... }</code> </pre> <br><p>  Darüber hinaus müssen Sie noch eine Struktur für diese Liste definieren. Es handelt sich lediglich um eine Vorlagenstruktur, die eine variable Anzahl von Vorlagenargumenten akzeptiert </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">{</span></span>} ;</code> </pre> <br><p>  Jetzt definieren wir eine Liste eindeutiger Ports und prüfen gleichzeitig, ob die Liste der Pins nicht dieselben Pins enthält.  Das ist ganz einfach: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PinsPack</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pins = PinsPack&lt;Ts...&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      using TPins = typename NoDuplicates&lt;Collection&lt;Ts...&gt;&gt;::Result; //           static_assert(std::is_same&lt;TPins, Collection&lt;Ts...&gt;&gt;::value, ":    ") ; //     using Ports = typename NoDuplicates&lt;Collection&lt;typename Ts::PortType...&gt;&gt;::Result; ... } ;</span></span></code> </pre> <br><p>  Mach weiter ... </p><br><h2 id="obhod-spiska-portov">  Port List Bypass </h2><br><p>  Nachdem Sie die Liste der Ports erhalten haben, müssen Sie sie jetzt umgehen und mit jedem Port etwas unternehmen.  In einer vereinfachten Form können wir sagen, dass wir eine Funktion deklarieren müssen, die eine Liste von Ports und eine Maske für die Liste der Pins am Eingang erhält. </p><br><p>  Da wir eine Liste umgehen müssen, deren Größe nicht sicher bekannt ist, wird die Funktion eine Vorlage mit einer variablen Anzahl von Parametern sein. </p><br><p>  Wir gehen "rekursiv" umher, solange die Vorlage noch Parameter enthält, rufen wir eine Funktion mit demselben Namen auf. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PinsPack</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pins = PinsPack&lt;Ts...&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ports&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPorts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Port, Ports...&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,       if constexpr (sizeof ...(Ports) != 0U) { Pins::template WritePorts&lt;Ports...&gt;(Collection&lt;Ports...&gt;(), mask) ; } } }</span></span></code> </pre> <br><p>  Wir haben also gelernt, wie man die Liste der Ports umgeht, aber zusätzlich zur Umgehung müssen Sie einige nützliche Arbeiten ausführen, nämlich etwas im Port installieren. </p><br><pre> <code class="cpp hljs">__forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ports&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPorts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Port, Ports...&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      auto result = GetPortValue&lt;Port&gt;(mask) ; //      Port::Set(result) ; if constexpr (sizeof ...(Ports) != 0U) { Pins::template WritePorts&lt;Ports...&gt;(Collection&lt;Ports...&gt;(), mask) ; } }</span></span></code> </pre> <br><p>  Diese Methode wird zur Laufzeit ausgeführt, da der <code>mask</code> von außen an die Funktion übergeben wird.  <code>SetPorts()</code> wir nicht garantieren können, dass eine Konstante an die <code>SetPorts()</code> -Methode übergeben wird, wird die <code>GetValue()</code> -Methode auch zur Laufzeit ausgeführt. </p><br><p>  Und obwohl in dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Arbeiten mit Eingabe- / Ausgabeports von Mikrocontrollern in C ++</a> geschrieben steht, dass der Compiler in einer ähnlichen Methode festgestellt hat, dass eine Konstante übergeben wurde, und den Wert zum Schreiben in den Port in der Kompilierungsphase berechnet hat, hat mein Compiler einen solchen Trick nur bei maximaler Optimierung ausgeführt. <br>  Ich möchte, dass <code>GetValue()</code> Kompilierungszeit mit allen Compilereinstellungen ausgeführt wird. </p><br><p>  Ich habe im Standard nicht gefunden, wie der Compiler den Compiler in diesem Fall führen soll, aber wenn man bedenkt, dass der IAR-Compiler dies nur bei maximaler Optimierung ausführt, ist dies höchstwahrscheinlich nicht durch den Standard geregelt oder sollte nicht als Constexpr-Ausdruck aufgefasst werden. <br>  Wenn jemand weiß, schreibe in die Kommentare. </p><br><p>  Um die explizite Übertragung eines konstanten Werts sicherzustellen, erstellen wir eine zusätzliche Methode mit übergebener <code>mask</code> in der Vorlage: </p><br><pre> <code class="cpp hljs">__forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ports&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPorts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Port, Ports...&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyPins = PinsPack&lt;Ts...&gt; ; <span class="hljs-comment"><span class="hljs-comment">//    compile time,    value    constexpr auto result = GetPortValue&lt;Port&gt;(mask) ; Port::Set(result) ; if constexpr (sizeof ...(Ports) != 0U) { MyPins::template SetPorts&lt;mask,Ports...&gt;(Collection&lt;Ports...&gt;()) ; } }</span></span></code> </pre> <br><p>  Auf diese Weise können wir jetzt die Liste der Pins durchgehen, die Ports aus ihnen herausziehen und eine eindeutige Liste der Ports erstellen, an die sie gebunden sind, und dann die erstellte Liste der Ports durchgehen und den erforderlichen <u>Wert</u> für jeden Port festlegen. <br>  Dieser <u>Wert muss noch</u> berechnet <u>werden</u> . </p><br><h2 id="raschet-znacheniya-kotoroe-neobhodimo-ustanovit-v-port">  Berechnung des im Port einzustellenden Wertes </h2><br><p>  Wir haben eine Liste von Ports, die wir aus der Pin-Liste erhalten haben. In unserem Beispiel ist dies eine Liste: <code>Collection&lt;Port&lt;GPIOA&gt;, Port&lt;GPIOB&gt;, Port&lt;GPIOC&gt;&gt;</code> . <br>  Sie müssen ein Element dieser Liste verwenden, z. B. den GPIOA-Port. Suchen Sie dann in der Pin-Liste alle Pins, die an diesen Port angeschlossen sind, und berechnen Sie den Wert für die Installation im Port.  Und dann machen Sie dasselbe mit dem nächsten Port. </p><br><div class="spoiler">  <b class="spoiler_title">Nochmals: In unserem Fall lautet die Liste der Pins, von denen Sie eine Liste der eindeutigen Ports abrufen müssen, wie folgt:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin1 = Pin&lt;Port&lt;GPIOC&gt;, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin2 = Pin&lt;Port&lt;GPIOB&gt;, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin3 = Pin&lt;Port&lt;GPIOA&gt;, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin4 = Pin&lt;Port&lt;GPIOC&gt;, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin5 = Pin&lt;Port&lt;GPIOA&gt;, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pins = PinsPack&lt;Pin1, Pin2, Pin3, Pin4, Pin5&gt; ;</code> </pre> </div></div><br><p>  Für den GPIOA-Port sollte der Wert also <code>(1 &lt;&lt; 1 ) | (1 &lt;&lt; 3) = 10</code>  <code>(1 &lt;&lt; 1 ) | (1 &lt;&lt; 3) = 10</code> und für den GPIOC-Port - <code>(1 &lt;&lt; 1) | (1 &lt;&lt; 2) = 6</code>  <code>(1 &lt;&lt; 1) | (1 &lt;&lt; 2) = 6</code> und für GPIOB <code>(1 &lt;&lt; 1 ) = 2</code> </p><br><p>  Die Berechnungsfunktion akzeptiert den angeforderten Port. Befindet sich Pin auf demselben Port wie der angeforderte Port, muss die Maske in der Maske entsprechend der Position dieses Pina in der Liste, Einheit (1), festgelegt werden. <br>  Es ist nicht einfach, es in Worten zu erklären. Es ist besser, direkt in den Code zu schauen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PinsPack</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pins = PinsPack&lt;Ts...&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueryPort</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GetPortValue</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,       // 1. ,        // 2.            // e (.     ), ,  Pin   0  //        10,      //    ( )  (1 &lt;&lt; 10)    // 3.    1   // 4.   1-3      pass{(result |= ((std::is_same&lt;QueryPort, typename Ts::PortType&gt;::value ? 1 : 0) &amp; mask) * (1 &lt;&lt; Ts::pin), mask &gt;&gt;= 1)...} ; return result; } } ;</span></span></code> </pre> <br><h2 id="ustanovka-rasschitannogo-dlya-kazhdogo-porta-znacheniya-v-porty">  Festlegen des für jeden Port berechneten Werts für Ports </h2><br><p>  Jetzt kennen wir den Wert, der in jedem Port eingestellt werden muss.  Es bleibt noch die public <code>Set()</code> -Methode zu vervollständigen, die für den Benutzer sichtbar ist, so dass die gesamte Wirtschaftlichkeit aufgerufen wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PinsPack</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pins = PinsPack&lt;Ts...&gt; ; __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        SetPorts(Ports(), mask) ; } }</span></span></code> </pre> <br><p>  Wie im Fall von <code>SetPorts()</code> eine zusätzliche Template-Methode <code>SetPorts()</code> , um die Übertragung der <code>mask</code> als Konstante zu gewährleisten, die im Template-Attribut übergeben wird. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PinsPack</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pins = PinsPack&lt;Ts...&gt; ; <span class="hljs-comment"><span class="hljs-comment">//    0xffffffff,      32  __forceinline template&lt;std::size_t mask = 0xffffffffU&gt; static void Set() { SetPorts&lt;mask&gt;(Ports()) ; } }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">In der endgültigen Form sieht unsere Klasse für die Pin-Liste folgendermaßen aus:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> PinHelper ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PinsPack</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pins = PinsPack&lt;Ts...&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TPins = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NoDuplicates&lt;Collection&lt;Ts...&gt;&gt;::Result; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;TPins, Collection&lt;Ts...&gt;&gt;::value, <span class="hljs-string"><span class="hljs-string">":    "</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ports = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NoDuplicates&lt;Collection&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Ts::PortType...&gt;&gt;::Result; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Q</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GetPortValue</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rmask = mask ; pass{(result |= ((<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Q, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Ts::PortType&gt;::value ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; mask) * (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; Ts::pin), mask&gt;&gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>)...}; pass{(result |= ((<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Q, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Ts::PortType&gt;::value ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; ~rmask) * ((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; Ts::pin) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>), rmask&gt;&gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>)...}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ports&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPorts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Port, Ports...&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = GetPortValue&lt;Port&gt;(mask) ; Port::Set(result &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ...(Ports) != </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0U</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Pins::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> SetPorts&lt;Ports...&gt;(Collection&lt;Ports...&gt;(), mask) ; } } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ports&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPorts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Port, Ports...&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = GetPortValue&lt;Port&gt;(mask) ; Port::Set(result &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ...(Ports) != </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0U</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Pins::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> SetPorts&lt;mask, Ports...&gt;(Collection&lt;Ports...&gt;()) ; } } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ports&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WritePorts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Port, Ports...&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = GetPortValue&lt;Port&gt;(mask) ; Port::Set(result) ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ...(Ports) != </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0U</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Pins::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> WritePorts&lt;Ports...&gt;(Collection&lt;Ports...&gt;(), mask) ; } } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ports&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WritePorts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Port, Ports...&gt;)</span></span></span><span class="hljs-function"> </span></span>{ Port::Set(GetPortValue&lt;Port&gt;(mask)) ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ...(Ports) != </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0U</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Pins::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> WritePorts&lt;mask, Ports...&gt;(Collection&lt;Ports...&gt;()) ; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ...(Ts) + <span class="hljs-number"><span class="hljs-number">1U</span></span> ; __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask )</span></span></span><span class="hljs-function"> </span></span>{ SetPorts(Ports(), mask) ; } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>U&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Set() { SetPorts&lt;mask&gt;(Ports()) ; } __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ WritePorts(Ports(), mask) ; } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>U&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Write() { WritePorts&lt;mask&gt;(Ports()) ; } } ;</code> </pre></div></div><br><p>  Infolgedessen kann das Ganze wie folgt verwendet werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin1 = Pin&lt;GPIOC, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin2 = Pin&lt;GPIOB, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin3 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin4 = Pin&lt;GPIOC, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin5 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin6 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin7 = Pin&lt;GPIOC, <span class="hljs-number"><span class="hljs-number">7</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin8 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//1.   ,     3 ,  : // GPIOA-&gt;BSRR = (1 &lt;&lt; 1) | (1 &lt;&lt; 3) // GPIOB-&gt;BSRR = (1 &lt;&lt; 1) // GPIOC-&gt;BSRR = (1 &lt;&lt; 1) | (1 &lt;&lt; 2) PinsPack&lt;Pin1, Pin2, Pin3, Pin4, Pin5&gt;::Set() ; //   Set&lt;0xffffffffU&gt;() //2.   ,  3 ,  : // GPIOA-&gt;BSRR = (1 &lt;&lt; 1) // GPIOB-&gt;BSRR = (1 &lt;&lt; 1) // GPIOC-&gt;BSRR = (1 &lt;&lt; 1) | (1 &lt;&lt; 2) PinsPack&lt;Pin1, Pin2, Pin3, Pin4, Pin5, Pin6&gt;::Set&lt;7&gt;() ; //3.          , //   someRunTimeValue     ,  //  SetPorts   constexpr    PinsPack&lt;Pin1, Pin2, Pin3, Pin4, Pin5&gt;::Set(someRunTimeValue) ; using LcdData = PinsPack&lt;Pin1, Pin2, Pin3, Pin4, Pin5, Pin6, Pin7, Pin8&gt; ; LcdData::Write('A') ; }</span></span></code> </pre> <br><p>  Ein vollständigeres Beispiel finden Sie hier: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://onlinegdb.com/r1eoXQBRH</a> </p><br><h2 id="bystrodeystvie">  Leistung </h2><br><p>  Wie Sie sich erinnern, wollten wir unseren Anruf in 3 Leitungen umwandeln, die auf Port A 10, Port B - 2 und Port C - 6 eingestellt sind </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin1 = Pin&lt;GPIO, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin2 = Pin&lt;GPIOB, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin3 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin4 = Pin&lt;GPIOC, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pin5 = Pin&lt;GPIOA, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    Pin    : //   GPIOA  10 GPIOA-&gt;BSRR = 10 ; // (1&lt;&lt;1) | (1 &lt;&lt; 3) ; //   GPIOB  2 GPIOB-&gt;BSRR = 2 ; // (1 &lt;&lt; 1) //   GPIOC  6 GPIOB-&gt;BSRR = 6 ; // (1 &lt;&lt; 1) | (1 &lt;&lt; 2); PinsPack&lt;Pin1, Pin2, Pin3, Pin4, Pin5&gt;::Set() ; return 0; }</span></span></code> </pre> <br><p>  Mal sehen, was mit der vollständig deaktivierten Optimierung passiert ist. </p><br><p><img src="https://habrastorage.org/webt/d4/9l/7b/d49l7b_9vzrt8zddhn2u2exuzdy.png"></p><br><p>  Ich habe die Portwerte und Aufrufe getönt, um diese Werte auf Ports in Grün zu setzen.  Es ist ersichtlich, dass alles wie beabsichtigt ausgeführt wird. Der Compiler für jeden der Ports berechnete den Wert und rief einfach die Funktion auf, um diese Werte auf die erforderlichen Ports zu setzen. <br>  Wenn die Installationsfunktionen auch inline ausgeführt werden, erhalten wir am Ende einen Aufruf, um den Wert für jeden Port in das BSRR-Register zu schreiben. </p><br><p>  Eigentlich ist das alles.  Wen kümmert es, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Code ist hier</a> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Ein Beispiel ist hier</a> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://onlinegdb.com/ByeA50wTS</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474732/">https://habr.com/ru/post/de474732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474718/index.html">Sicherheit in der Autoelektronik - Hallo Welt auf dem Armaturenbrett-Controller</a></li>
<li><a href="../de474720/index.html">Radiolabor Nischni Nowgorod und Losevs „Cristadins“</a></li>
<li><a href="../de474722/index.html">„Niemand sagt anderen, was sie tun müssen“: Nicolò Ribaudo über die Entwicklung von Babel und mehr</a></li>
<li><a href="../de474724/index.html">Was wird mit PHP in 5 Jahren passieren? Wir haben die Sprecher der nächsten Moskauer Mitap gefragt</a></li>
<li><a href="../de474726/index.html">Sogar Kinder werden verstehen: eine einfache Erklärung von Async / Warten und Versprechen in JavaScript</a></li>
<li><a href="../de474738/index.html">Geometrische Modellierung von Verrundungsoberflächen</a></li>
<li><a href="../de474740/index.html">Das Beste aus dem Computer History Museum in Mountain View</a></li>
<li><a href="../de474744/index.html">Uber steigt in den Finanzdienstleistungsmarkt ein und startet den Geschäftsbereich Uber Money</a></li>
<li><a href="../de474746/index.html">Objektspeicher im Hinterzimmer oder So werden Sie Ihr eigener Dienstleister</a></li>
<li><a href="../de474748/index.html">Service Desk Systeme und deren Integration. Wie kann der Prozess der Zusammenarbeit mit Auftragnehmern und Herstellern automatisiert werden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>