<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüíº üî≤ ‚õπüèæ Celesta 7.x: ORM, Migration und Testen "in einem Paket" üåê üö® üßëüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vielleicht wissen Sie bereits etwas √ºber die Open-Source- Celesta- Bibliothek. Wenn nicht, spielt es keine Rolle, jetzt erz√§hlen wir Ihnen alles. Ein ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Celesta 7.x: ORM, Migration und Testen "in einem Paket"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455746/"><p>  Vielleicht wissen Sie bereits etwas √ºber die Open-Source- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Celesta-</a> Bibliothek.  Wenn nicht, spielt es keine Rolle, jetzt erz√§hlen wir Ihnen alles.  Ein weiteres Jahr verging, Version 7.x wurde ver√∂ffentlicht, viele Dinge hatten sich ge√§ndert, und es war Zeit, die √Ñnderungen zusammenzufassen und gleichzeitig daran zu erinnern, was Celesta im Allgemeinen ist. </p><br><div style="text-align:center;"><img width="350" src="https://habrastorage.org/webt/jj/7z/jt/jj7zjthmrh2dhdo4v0ueefqj6uq.png"></div><a name="habracut"></a><br><p> Wenn Sie noch nichts √ºber Celesta geh√∂rt haben und beim Lesen dieses Artikels wissen m√∂chten, f√ºr welche Gesch√§ftsaufgaben die Anwendung am effektivsten ist, kann ich den ersten Teil des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alten Beitrags</a> oder dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">halbst√ºndige Video</a> empfehlen (mit Ausnahme von W√∂rtern zur Verwendung der Python-Sprache).  Aber noch besser, lesen Sie zuerst diesen Artikel.  Ich werde mit den √Ñnderungen beginnen, die in Version 7 vorgenommen wurden, und dann ein vollst√§ndiges technisches Beispiel f√ºr die Verwendung der modernen Version von Celesta durchgehen, um mithilfe von Spring Boot einen kleinen Backend-Dienst f√ºr eine Java-Anwendung zu schreiben. </p><br><h2 id="chto-izmenilos-v-versii-7x">  Was hat sich in Version 7.x ge√§ndert? </h2><br><ol><li>  Wir haben uns geweigert, Jython als eine in Celesta integrierte Sprache zu verwenden.  Wenn wir fr√ºher √ºber Celesta mit der Tatsache gesprochen haben, dass Gesch√§ftslogik in Python geschrieben ist, kann jetzt ... jede Java-Sprache als Sprache der Gesch√§ftslogik dienen: Java, Groovy, JRuby oder dasselbe Jython.  Jetzt ruft Celesta den Gesch√§ftslogikcode nicht mehr auf, aber der Gesch√§ftslogikcode verwendet Celesta und seine Datenzugriffsklassen als h√§ufigste Java-Bibliothek.  Ja, die Abw√§rtskompatibilit√§t wurde dadurch verletzt, aber dies ist der Preis, den wir bereit waren zu zahlen.  Leider hat unsere Wette auf Jython verloren.  Als wir vor einigen Jahren mit der Verwendung von Jython begannen, war es ein lebhaftes und vielversprechendes Projekt, aber im Laufe der Jahre verlangsamte sich seine Entwicklung, der R√ºckstand aus der Sprachspezifikation h√§ufte sich und Kompatibilit√§tsprobleme f√ºr die meisten Pip-Bibliotheken wurden nicht gel√∂st.  Der letzte Strohhalm waren die neuen Fehler in den neuesten Sprachversionen, die sich bei der Arbeit an einer Produktionslast zeigten.  Wir selbst haben nicht die Ressourcen, um das Jython-Projekt zu unterst√ºtzen, und wir haben beschlossen, uns davon zu trennen.  Celesta ist nicht mehr von Jython abh√§ngig. </li><li>  Datenzugriffsklassen werden jetzt mithilfe des Maven-Plugins in der Java-Sprache (und nicht wie zuvor in Python) Code generiert.  Und da wir aus diesem Grund von der dynamischen zur statischen Typisierung √ºbergegangen sind, haben sich mehr M√∂glichkeiten f√ºr das Refactoring ergeben und es wurde einfacher, subjektiv korrekten Code zu schreiben. </li><li>  Die Erweiterung f√ºr JUnit5 wurde angezeigt, sodass es sehr praktisch wurde, Logiktests zu schreiben, die mit der Datenbank in JUnit5 arbeiten (auf die sp√§ter noch eingegangen wird). </li><li>  Ein separates Projekt ist erschienen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring-Boot-Starter-Celesta</a> , das, wie der Name schon sagt, der Celesta-Starter in Spring Boot ist.  Die M√∂glichkeit, Celesta-Anwendungen in einfach zu implementierende Spring Boot-Dienste zu packen, kompensierte den Verlust der M√∂glichkeit, die Anwendung auf dem Server zu aktualisieren, indem einfach der Ordner mit Python-Skripten ge√§ndert wurde. </li><li>  Wir haben die gesamte Dokumentation aus dem Wiki in das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AsciiDoctor-</a> Format √ºbertragen, sie zusammen mit dem Code in die Versionskontrolle gestellt und verf√ºgen nun √ºber eine aktuelle Dokumentation f√ºr jede Celesta-Version.  Die neueste Version der Online-Dokumentation finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://courseorchestra.github.io/celesta/</a> </li><li>  Wir wurden oft gefragt, ob es m√∂glich ist, die Datenbankmigration √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">idempotente DDL</a> getrennt von Celesta zu verwenden.  Jetzt gibt es eine solche M√∂glichkeit mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2bass-</a> Tool. </li></ol><br><h2 id="chto-takoe-selesta-i-chto-ona-umeet">  Was ist Celesta und was kann sie tun? </h2><br><p>  Kurz gesagt, Celesta ist: </p><br><ul><li>  eine Zwischenschicht zwischen der relationalen Datenbank und dem Gesch√§ftslogikcode, basierend auf dem <em>Datenbank-First-</em> Design-Ansatz, </li><li>  Migrationsmechanismus der Datenbankstruktur, </li><li>  Framework zum Testen von Code, der mit Daten arbeitet. </li></ul><br><p>  Wir unterst√ºtzen vier Arten relationaler Datenbanken: PostgreSQL, MS SQL Server, Oracle und H2. </p><br><p>  Hauptmerkmale von Celesta: </p><br><ol><li>  Ein Prinzip, das dem Grundprinzip von Java sehr √§hnlich ist: "Einmal schreiben, auf jedem unterst√ºtzten RDBMS ausf√ºhren."  Der Gesch√§ftslogikcode wei√ü nicht, auf welchem ‚Äã‚ÄãDatenbanktyp er ausgef√ºhrt wird.  Sie k√∂nnen den Gesch√§ftslogikcode schreiben und in MS SQL Server ausf√ºhren und dann zu PostgreSQL wechseln. Dies geschieht ohne Komplikationen (na ja, fast :) </li><li>  Automatische Umstrukturierung in einer Live-Datenbank.  Der gr√∂√üte Teil des Lebenszyklus von Celesta-Projekten findet statt, wenn die Arbeitsdatenbank bereits vorhanden ist und mit Daten gef√ºllt ist, die gespeichert werden m√ºssen. Es ist jedoch auch erforderlich, ihre Struktur st√§ndig zu √§ndern.  Eines der Hauptmerkmale von Celesta ist die M√∂glichkeit, die Datenbankstruktur automatisch an Ihr Datenmodell anzupassen. </li><li>  Testen.  Es wird viel Wert darauf gelegt, dass der Code f√ºr Celesta testbar ist, damit wir automatisch Methoden testen k√∂nnen, mit denen Daten in der Datenbank ge√§ndert werden k√∂nnen. Dies geschieht einfach, schnell und elegant, ohne externe Tools wie DbUnit und Container zu verwenden. </li></ol><br><h2 id="dlya-chego-nuzhna-nezavisimost-ot-tipa-subd">  Warum brauchen Sie Unabh√§ngigkeit von der Art des DBMS? </h2><br><p>  Die Unabh√§ngigkeit des Gesch√§ftslogikcodes vom DBMS-Typ war nicht der erste Punkt, den wir festgelegt haben: Der f√ºr Celesta geschriebene Code wei√ü √ºberhaupt nicht, auf welchem ‚Äã‚ÄãDBMS er ausgef√ºhrt wird.  Warum? </p><br><p>  Erstens aufgrund der Tatsache, dass die Wahl eines DBMS-Typs kein technologisches, sondern ein politisches Problem ist.  Wenn wir zu einem neuen Gesch√§ftskunden kommen, stellen wir h√§ufig fest, dass er bereits einen bevorzugten DBMS-Typ hat, in den Mittel investiert werden, und der Kunde m√∂chte andere L√∂sungen f√ºr die vorhandene Infrastruktur sehen.  Die technologische Landschaft √§ndert sich: PostgreSQL findet sich zunehmend in Regierungsbeh√∂rden und privaten Unternehmen, obwohl sich MS SQL Server in unserer Praxis vor einigen Jahren durchgesetzt hat.  Celesta unterst√ºtzt die g√§ngigsten DBMS, und wir sind nicht besorgt √ºber diese √Ñnderungen. </p><br><p>  Zweitens m√∂chte ich den bereits erstellten Code zur L√∂sung von Standardproblemen von einem Projekt in ein anderes √ºbertragen, um eine wiederverwendbare Bibliothek zu erstellen.  Dinge wie hierarchische Verzeichnisse oder E-Mail-Benachrichtigungsverteilungsmodule sind von Natur aus Standard. Warum m√ºssen wir mehrere Versionen f√ºr Kunden mit unterschiedlichen Beziehungen unterst√ºtzen? </p><br><p>  Drittens, nicht zuletzt die M√∂glichkeit, Komponententests ohne Verwendung von DbUnit und Containern mithilfe einer speicherinternen H2-Datenbank durchzuf√ºhren.  In diesem Modus startet die H2-Basis sofort.  Celesta erstellt sehr schnell ein Datenschema, nach dem Sie die erforderlichen Tests durchf√ºhren und die Datenbank ‚Äûvergessen‚Äú k√∂nnen.  Da der Gesch√§ftslogikcode wirklich nicht wei√ü, auf welcher Basis er ausgef√ºhrt wird, funktioniert er entsprechend fehlerfrei unter PostgreSQL, wenn er auf H2 fehlerfrei funktioniert.  Die Aufgabe der Entwickler des Celesta-Systems selbst besteht nat√ºrlich darin, alle Tests mit echten DBMS durchzuf√ºhren, um sicherzustellen, dass unsere Plattform ihre API f√ºr verschiedene Beziehungen gleicherma√üen ausf√ºhrt.  Und wir machen es.  Der Entwickler der Gesch√§ftslogik wird jedoch nicht mehr ben√∂tigt. </p><br><h2 id="celestasql">  CelestaSQL </h2><br><p>  Wie wird Cross-Basalism erreicht?  Nat√ºrlich auf Kosten der Arbeit mit Daten nur √ºber eine spezielle API, die die Logik von allen Datenbankspezifikationen isoliert.  Celesta generiert Java-Klassen f√ºr den Zugriff auf Daten einerseits und SQL-Code und einige Hilfsobjekte in der Datenbank andererseits. </p><br><p>  Celesta bietet keine objektrelationale Zuordnung in ihrer reinsten Form, da wir beim Entwerfen eines Datenmodells nicht aus Klassen, sondern aus der Datenbankstruktur stammen.  Das hei√üt, wir erstellen zuerst ein ER-Modell von Tabellen, und dann generiert Celesta basierend auf diesem Modell selbst Cursorklassen f√ºr den Zugriff auf Daten. </p><br><p>  Sie k√∂nnen dieselbe Arbeit f√ºr alle unterst√ºtzten DBMS nur f√ºr die Funktionalit√§t ausf√ºhren, die in jedem von ihnen ungef√§hr gleich implementiert ist.  Wenn wir die Menge der Funktionsf√§higkeiten jeder von uns unterst√ºtzten Basis in Form von ‚ÄûEulerkreisen‚Äú bedingt darstellen, erhalten wir das folgende Bild: </p><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/getpro/habr/post_images/7d9/2ad/1e1/7d92ad1e1a3bc0bb83b5c4bcc511ec66.png"></div><br><p>  Wenn wir eine vollst√§ndige Unabh√§ngigkeit von der Art der Datenbank bieten, sollte die Funktionalit√§t, die wir f√ºr Programmierer von Gesch√§ftslogik √∂ffnen, innerhalb des Schnittpunkts aller Basen liegen.  Auf den ersten Blick scheint dies eine erhebliche Einschr√§nkung zu sein.  Ja, f√ºr einige spezifische Funktionen k√∂nnen wir beispielsweise SQL Server nicht verwenden.  Relationale Datenbanken unterst√ºtzen jedoch ausnahmslos Tabellen, Fremdschl√ºssel, Ansichten, Sequenzen und SQL-Abfragen mit JOIN und GROUP BY.  Dementsprechend k√∂nnen wir Entwicklern diese M√∂glichkeiten geben.  Wir stellen Entwicklern "depersonalisiertes SQL" zur Verf√ºgung, das wir "CelestaSQL" nennen, und generieren dabei SQL-Abfragen f√ºr Dialekte der entsprechenden Datenbanken. </p><br><p>  Die CelestaSQL-Sprache enth√§lt DDL zum Definieren von Datenbankobjekten und SELECT-Abfragen f√ºr Ansichten und Filter, enth√§lt jedoch keine DML-Befehle: Cursor werden zum √Ñndern der Daten verwendet, die noch zu diskutieren sind. </p><br><p>  Jede Datenbank hat ihre eigenen Datentypen.  CelestaSQL hat auch eigene Typen.  Zum Zeitpunkt des Schreibens gibt es neun davon, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Tabelle</a> vergleicht sie mit realen Typen in verschiedenen Datenbanken und Java-Datentypen. </p><br><p>  Es mag den Anschein haben, dass neun Typen nicht ausreichen (im Vergleich zu dem, was PostgreSQL beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unterst√ºtzt</a> ), aber in Wirklichkeit sind dies die Typen, die ausreichen, um Finanz-, Handels- und Logistikinformationen zu speichern: Zeichenfolgen, Ganzzahlen, Bruchzahlen , Daten, Boolesche Werte und Blobs reichen immer aus, um solche Daten darzustellen. </p><br><p>  Die CelestaSQL-Sprache selbst wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> mit einer Vielzahl von Syntaxdiagrammen beschrieben. </p><br><h2 id="modifikaciya-struktury-bazy-dannyh-idempotentnyy-ddl">  √Ñnderung der Datenbankstruktur.  Idempotente DDL </h2><br><p>  Ein weiteres wichtiges Merkmal von Celesta ist der Ansatz zur Migration der Struktur der Arbeitsdatenbank w√§hrend der Projektentwicklung.  Zu diesem Zweck wird der in Celesta integrierte Ansatz mit idempotenter DDL verwendet. </p><br><p>  Kurz gesagt, wenn wir in CelestaSQL den folgenden Text schreiben: </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine( order_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, line_no <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), qty <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span> <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Idx_OrderLine PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id, line_no) );</code> </pre> <br><p>  - Dieser Text wird von Celesta nicht als "Tabelle erstellen, aber wenn bereits eine Tabelle vorhanden ist, geben Sie einen Fehler aus" interpretiert, sondern als "Tabelle in die gew√ºnschte Struktur bringen".  Das hei√üt: ‚ÄûWenn es keine Tabelle gibt, erstellen Sie sie, wenn es eine Tabelle gibt, sehen Sie, welche Felder darin enthalten sind, mit welchen Typen, welchen Indizes, welchen Fremdschl√ºsseln, welchen Standardwerten usw. und ob etwas ge√§ndert werden muss diesen Tisch, um es auf die richtige Art zu bringen. " </p><br><p>  Mit diesem Ansatz implementieren wir die M√∂glichkeit, Skripte zu refaktorieren und zu versionieren, um die Struktur der Datenbank zu bestimmen: </p><br><ul><li>  wir sehen im Skript das aktuelle "gew√ºnschte Bild" der Struktur, </li><li>  Was, von wem und warum hat sich die Struktur im Laufe der Zeit ge√§ndert? Wir k√∂nnen das Versionskontrollsystem durchsehen. </li><li>  Bei ALTER-Befehlen generiert Celesta diese automatisch und f√ºhrt sie bei Bedarf ‚Äûunter der Haube‚Äú aus. </li></ul><br><p>  Nat√ºrlich hat dieser Ansatz seine Grenzen.  Celesta unternimmt alle Anstrengungen, um sicherzustellen, dass die automatische Migration problemlos und nahtlos verl√§uft. Dies ist jedoch nicht in allen F√§llen m√∂glich.  Die Motivation, M√∂glichkeiten und Grenzen dieses Ansatzes wurden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Beitrag beschrieben</a> (die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">englische Version</a> ist ebenfalls verf√ºgbar). </p><br><p>  Um den Prozess des √úberpr√ºfens / Aktualisierens der Datenbankstruktur zu beschleunigen, wendet Celesta die Speicherung von DDL-Skriptpr√ºfsummen in der Datenbank an (bis die Pr√ºfsumme ge√§ndert wird, startet der Prozess des √úberpr√ºfens und Aktualisierens der Datenbankstruktur nicht).  Damit der Aktualisierungsprozess ohne Probleme in Bezug auf die Reihenfolge der √Ñnderung von voneinander abh√§ngigen Objekten fortgesetzt werden kann, wird die topologische Sortierung der Abh√§ngigkeiten zwischen Schemata nach Fremdschl√ºsseln angewendet.  Der automatische Migrationsprozess wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ausf√ºhrlicher beschrieben. </p><br><h2 id="sozdanie-proekta-celesta-i-modeli-dannyh">  Erstellen eines Celesta-Projekts und eines Datenmodells </h2><br><p>  Das Demo-Projekt, das wir betrachten werden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist auf dem Github verf√ºgbar</a> .  Mal sehen, wie Sie Celesta beim Schreiben einer Spring Boot-Anwendung verwenden k√∂nnen.  Hier sind die Maven-Abh√§ngigkeiten, die Sie ben√∂tigen: </p><br><ul><li>  <code>org.springframework.boot:spring-boot-starter-web</code> und <code>ru.curs:spring-boot-starter-celesta</code> (weitere Informationen finden <code>ru.curs:spring-boot-starter-celesta</code> Dokumentation). </li><li>  Wenn Sie Spring Boot nicht verwenden, k√∂nnen Sie die <code>ru.curs:celesta-system-services</code> direkt verbinden. </li><li>  F√ºr die Codegenerierung von Datenzugriffsklassen basierend auf Celesta-SQL-Skripten wird <code>ru.curs:celesta-maven-plugin</code> ben√∂tigt <code>ru.curs:celesta-maven-plugin</code> - Der Quellcode f√ºr ein Demo-Beispiel oder eine Dokumentation beschreibt, wie die Verbindung hergestellt wird. </li><li>  Um die M√∂glichkeit zu nutzen, JUnit5-Komponententests f√ºr Methoden zu schreiben, die Daten √§ndern, m√ºssen Sie <code>ru.curs:celesta-unit</code> im <code>ru.curs:celesta-unit</code> verbinden. </li></ul><br><p>  Erstellen Sie nun ein Datenmodell und kompilieren Sie Datenzugriffsklassen. </p><br><p>  Angenommen, wir f√ºhren ein Projekt f√ºr ein E-Commerce-Unternehmen durch, das k√ºrzlich mit einem anderen Unternehmen fusioniert wurde.  Jeder hat seine eigene Datenbank.  Sie sammeln Bestellungen, aber bis sie ihre Datenbanken zusammengef√ºhrt haben, ben√∂tigen sie einen einzigen Einstiegspunkt, um Bestellungen von au√üerhalb zu sammeln. </p><br><p>  Die Implementierung dieses ‚ÄûEinstiegspunkts‚Äú sollte recht traditionell sein: ein HTTP-Dienst mit CRUD-Operationen, die Daten in einer relationalen Datenbank speichern. </p><br><p>  Aufgrund der Tatsache, dass Celesta den Designansatz "Datenbank zuerst" implementiert, m√ºssen wir zuerst eine Tabellenstruktur erstellen, in der Bestellungen gespeichert werden.  Wie Sie wissen, ist eine Bestellung eine zusammengesetzte Entit√§t: Sie besteht aus einer Kopfzeile, in der Informationen √ºber den Kunden, das Bestelldatum und andere Attribute der Bestellung sowie viele Zeilen (Warenartikel) gespeichert sind. </p><br><p>  Also, f√ºr den Job: erstellen </p><br><ul><li>  <code>src/main/celestasql</code> - Standardm√§√üig ist dies der Pfad zu den CelestaSQL-Projektskripten </li><li>  Es enth√§lt Unterordner, die die Ordnerstruktur von Java-Paketen wiederholen (in unserem Fall <code>ru/curs/demo</code> ). </li><li>  Erstellen Sie im <code>.sql</code> eine <code>.sql</code> Datei mit folgendem Inhalt: </li></ul><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SCHEMA</span></span> demo <span class="hljs-keyword"><span class="hljs-keyword">VERSION</span></span> <span class="hljs-string"><span class="hljs-string">'1.0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderHeader( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> DATETIME, customer_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>), <span class="hljs-comment"><span class="hljs-comment">/**  */</span></span> customer_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>), manager_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Pk_OrderHeader PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">/** */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine( order_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, line_no <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), qty <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span> <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Idx_OrderLine PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id, line_no) ); <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> fk_OrderLine <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id) <span class="hljs-keyword"><span class="hljs-keyword">REFERENCES</span></span> OrderHeader(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> item_id;</code> </pre> <br><p>  Hier haben wir zwei Tabellen beschrieben, die durch einen Fremdschl√ºssel verbunden sind, und eine Ansicht, die eine zusammenfassende Menge f√ºr die in allen Bestellungen vorhandenen Waren zur√ºckgibt.  Wie Sie sehen, unterscheidet sich dies nicht von regul√§rem SQL, mit Ausnahme des Befehls <code>CREATE SCHEMA</code> , in dem wir die <code>demo</code> Schema-Version deklariert haben (Informationen dar√ºber, wie sich die Versionsnummer auf die automatische Migration auswirkt, finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ).  Es gibt aber auch Funktionen.  Beispielsweise k√∂nnen alle Namen der von uns verwendeten Tabellen und Felder nur so sein, dass sie in der Java-Sprache in g√ºltige Klassen- und Variablennamen umgewandelt werden k√∂nnen.  Leerzeichen, Sonderzeichen sind daher ausgeschlossen.  Sie k√∂nnen auch feststellen, dass die Kommentare, die wir √ºber die Namen von Tabellen und einigen Feldern setzen, nicht wie √ºblich mit / * begonnen haben, sondern mit / **, wie JavaDoc-Kommentare beginnen - und das ist kein Zufall!  Ein Kommentar, der f√ºr eine Entit√§t definiert ist, die mit / ** beginnt, ist zur Laufzeit in der Eigenschaft <code>.getCelestaDoc()</code> dieser Entit√§t verf√ºgbar.  Dies ist n√ºtzlich, wenn wir Datenbankelementen zus√§tzliche Metainformationen bereitstellen m√∂chten: z. B. von Menschen lesbare Feldnamen, Informationen zur Darstellung von Feldern in der Benutzeroberfl√§che usw. </p><br><p>  Das CelestaSQL-Skript erf√ºllt zwei gleich wichtige Aufgaben: Erstens f√ºr die Bereitstellung / √Ñnderung der Struktur einer relationalen Datenbank und zweitens f√ºr die Codegenerierung von Datenzugriffsklassen. </p><br><p>  Wir k√∂nnen jetzt Datenzugriffsklassen generieren. F√ºhren Sie einfach den Befehl <code>mvn generate-sources</code> . Wenn Sie in IDEA arbeiten, klicken Sie in der Maven-Systemsteuerung auf die Schaltfl√§che "Quellen generieren und Ordner aktualisieren".  Im zweiten Fall ‚Äû <code>target/generated-sources/celesta</code> IDEA <code>target/generated-sources/celesta</code> in <code>target/generated-sources/celesta</code> erstellten Ordner auf und stellt seinen Inhalt f√ºr den Import in die Projektquellcodes zur Verf√ºgung.  Das Ergebnis der Codegenerierung sieht folgenderma√üen aus: Eine Klasse f√ºr jedes Objekt in der Datenbank: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2x/3q/cs/2x3qcsydsu3y5vplbyh7oz15z-s.png"></div><br><p>  Die Verbindung zur Datenbank wird in den Anwendungseinstellungen angegeben, in unserem Fall in der Datei <code>src/main/resources/application.yml</code> .  Bei Verwendung von Spring-Boot-Starter-Celesta informiert IDEA Sie √ºber die Codeoptionen, die bei der Code-Vervollst√§ndigung verf√ºgbar sind. </p><br><p>  Wenn wir uns zu Demonstrationszwecken nicht mit dem ‚Äûechten‚Äú RDBMS besch√§ftigen m√∂chten, k√∂nnen wir Celesta mithilfe der folgenden Konfiguration dazu bringen, mit der integrierten H2-Datenbank im In-Memory-Modus zu arbeiten: </p><br><pre> <code class="plaintext hljs">celesta: h2: inMemory: true</code> </pre> <br><p>  Um eine "echte" Datenbank zu verbinden, √§ndern Sie die Konfiguration in etwas wie </p><br><pre> <code class="plaintext hljs">celesta: jdbc: url: jdbc:postgresql://127.0.0.1:5432/celesta username: &lt;your_username&gt; password: &lt;your_password&gt;</code> </pre> <br><p>  (In diesem Fall m√ºssen Sie Ihrer Anwendung √ºber die Maven-Abh√§ngigkeit auch einen PostgreSQL-JDBC-Treiber hinzuf√ºgen.) </p><br><p>  Wenn Sie eine Celesta-Anwendung mit einer Verbindung zu einem Datenbankserver starten, k√∂nnen Sie feststellen, dass die erforderlichen Tabellen, Ansichten, Indizes usw. f√ºr eine leere Datenbank erstellt und f√ºr eine nicht leere Datenbank auf die in der DDL angegebenen Strukturen aktualisiert werden. </p><br><h2 id="sozdanie-metodov-rabotayuschih-s-dannymi">  Erstellen von Datenmanipulationsmethoden </h2><br><p>  Sobald Sie herausgefunden haben, wie eine Datenbankstruktur erstellt wird, k√∂nnen Sie mit dem Schreiben von Gesch√§ftslogik beginnen. </p><br><p>  Um die Anforderungen f√ºr die Verteilung von Zugriffsrechten und Protokollierungsaktionen implementieren zu k√∂nnen, werden alle Vorg√§nge f√ºr Daten in Celesta im Auftrag eines Benutzers ausgef√ºhrt. Es gibt keine ‚Äûanonymen‚Äú Vorg√§nge.  Daher wird jeder Celesta-Code im <em>Kontext des</em> in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CallContext-</a> Klasse beschriebenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufrufs ausgef√ºhrt</a> . </p><br><ul><li>  Vor dem Starten eines Vorgangs, mit dem Daten in der Datenbank <code>CallContext</code> , wird <code>CallContext</code> aktiviert. </li><li>  Zum Zeitpunkt der Aktivierung wird eine Verbindung zur Datenbank aus dem Verbindungspool entnommen und die Transaktion beginnt. </li><li>  Nach Abschluss des <code>CallContext</code> f√ºhrt <code>CallContext</code> entweder <code>commit()</code> wenn der Vorgang erfolgreich war, oder <code>rollback()</code> wenn w√§hrend der Ausf√ºhrung eine nicht behandelte Ausnahme aufgetreten ist. <code>CallContext</code> geschlossen und die Datenbankverbindung wird an den Pool zur√ºckgegeben. </li></ul><br><p>  Wenn wir Spring-Boot-Starter-Celesta verwenden, werden diese Aktionen automatisch f√ºr alle von <code>@CelestaTransaction</code> kommentierten Methoden <code>@CelestaTransaction</code> . </p><br><p>  Angenommen, wir m√∂chten einen Handler schreiben, der das Dokument in der Datenbank speichert.  Der Code auf Controller-Ebene k√∂nnte folgenderma√üen aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/api"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DocumentService srv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DocumentController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DocumentService srv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.srv = srv; } <span class="hljs-meta"><span class="hljs-meta">@PutMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/save"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody OrderDto order)</span></span></span><span class="hljs-function"> </span></span>{ CallContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallContext(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//new SystemCallContext(); srv.postOrder(ctx, order); }</span></span></code> </pre> <br><p>  In der Regel kennen wir auf der Ebene der Controller-Methode (d. H. Wenn die Authentifizierung bereits bestanden wurde) die Benutzer-ID und k√∂nnen sie beim Erstellen des <code>CallContext</code> .  Das Binden eines Benutzers an einen Kontext bestimmt die Berechtigungen f√ºr den Zugriff auf Tabellen und bietet auch die M√∂glichkeit, in seinem Namen vorgenommene √Ñnderungen zu protokollieren.  In diesem Fall m√ºssen f√ºr die Funktionsf√§higkeit des mit der Datenbank interagierenden Codes die Rechte f√ºr den Benutzer "Benutzer1" in den Systemtabellen angegeben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Wenn Sie das Celesta-Zugriffsverteilungssystem nicht verwenden und dem Sitzungskontext alle Rechte f√ºr Tabellen erteilen m√∂chten, k√∂nnen Sie ein <code>SystemCallContext</code> Objekt erstellen. </p><br><p>  Die Methode zum Speichern der Rechnung auf Serviceebene kann folgenderma√üen aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@CelestaTransaction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context, OrderDto doc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); OrderLineCursor line = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderLineCursor(context)) { header.setId(doc.getId()); header.setDate(Date.from(doc.getDate().atStartOfDay(ZoneId.systemDefault()).toInstant())); header.setCustomer_id(doc.getCustomerId()); header.setCustomer_name(doc.getCustomerName()); header.insert(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lineNo = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (OrderLineDto docLine : doc.getLines()) { lineNo++; line.setLine_no(lineNo); line.setOrder_id(doc.getId()); line.setItem_id(docLine.getItemId()); line.setQty(docLine.getQty()); line.insert(); } } }</code> </pre> <br><p>  Beachten Sie die Annotation <code>@CelestaTransaction</code> .  Dank dessen f√ºhrt das Proxy-Objekt <code>DocumentService</code> alle diese <code>CallContext ctx</code> mit dem <code>CallContext ctx</code> beschriebenen Parameter <code>CallContext ctx</code> .  Das hei√üt, zu Beginn der Methodenausf√ºhrung ist sie bereits an die Datenbankverbindung gebunden, und die Transaktion kann gestartet werden.  Wir k√∂nnen uns darauf konzentrieren, Gesch√§ftslogik zu schreiben.  In unserem Fall lesen Sie das <code>OrderDto</code> Objekt und speichern es in der Datenbank. </p><br><p>  Dazu verwenden wir die sogenannten Cursor - Klassen, die mit dem <code>celesta-maven-plugin</code> generiert wurden.  Wir haben bereits gesehen, was sie sind.  F√ºr jedes der Schemaobjekte wird eine Klasse erstellt - zwei Tabellen und eine Ansicht.  Und jetzt k√∂nnen wir diese Klassen verwenden, um auf Datenbankobjekte in unserer Gesch√§ftslogik zuzugreifen. </p><br><p>  Um einen Cursor in der Auftragstabelle zu erstellen und den ersten Datensatz auszuw√§hlen, m√ºssen Sie den folgenden Code schreiben: </p><br><pre> <code class="java hljs">OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); header.tryFirst();</code> </pre> <br><p>  Nach dem Erstellen des Header-Objekts k√∂nnen wir √ºber Getter und Setter auf die Felder des Tabelleneintrags zugreifen: </p><br><div style="text-align:center;"><img width="450" src="https://habrastorage.org/webt/_8/gl/9i/_8gl9ikjbprpjano2dbvj0reme8.png"></div><br><p>  Beim Erstellen eines Cursors m√ºssen wir den aktiven Aufrufkontext verwenden - dies ist die einzige M√∂glichkeit, einen Cursor zu erstellen.  Der Anrufkontext enth√§lt Informationen √ºber den aktuellen Benutzer und seine Zugriffsrechte. </p><br><p>  Mit dem Cursor-Objekt k√∂nnen wir verschiedene Dinge tun: filtern, Datens√§tze durchgehen und nat√ºrlich auch Datens√§tze einf√ºgen, l√∂schen und aktualisieren.  Die gesamte Cursor-API wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ausf√ºhrlich beschrieben. </p><br><p>  Zum Beispiel k√∂nnte der Code unseres Beispiels wie folgt entwickelt werden: </p><br><pre> <code class="java hljs">OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); header.setRange(<span class="hljs-string"><span class="hljs-string">"manager_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"manager1"</span></span>); header.tryFirst(); header.setCounter(header.getCounter() + <span class="hljs-number"><span class="hljs-number">1</span></span>); header.update();</code> </pre> <br><p>  In diesem Beispiel setzen wir den Filter nach dem Feld manager_id und finden dann den ersten Datensatz mit der Methode tryFirst. </p><br><div class="spoiler">  <b class="spoiler_title">(warum "versuchen")</b> <div class="spoiler_text"><p>  Die Methoden <code>get</code> , <code>first</code> , <code>insert</code> , <code>update</code> haben zwei Optionen: ohne das try-Pr√§fix (nur <code>get(...)</code> usw.) und mit dem try-Pr√§fix ( <code>tryGet(...)</code> , <code>tryFirst()</code> usw.) .  Methoden ohne das Pr√§fix try l√∂sen eine Ausnahme aus, wenn die Datenbank nicht √ºber die entsprechenden Daten zum Ausf√ºhren der Aktion verf√ºgt.  Beispielsweise l√∂st first () eine Ausnahme aus, wenn keine Datens√§tze in den auf dem Cursor festgelegten Filter gelangen.  Gleichzeitig l√∂sen Methoden mit dem Pr√§fix try keine Ausnahme aus, sondern geben stattdessen einen Booleschen Wert zur√ºck, der den Erfolg oder Misserfolg der entsprechenden Operation signalisiert.  Es wird empfohlen, nach M√∂glichkeit Methoden ohne das Pr√§fix try zu verwenden.  Auf diese Weise wird ein "Selbsttest" -Code erstellt, der zeitliche Fehler in den Logik- und / oder Datenbankdaten signalisiert. </p></div></div><br><p>  Wenn <code>tryFirst</code> ausgel√∂st wird, werden die <code>tryFirst</code> Variablen mit den Daten eines Datensatzes gef√ºllt, wir k√∂nnen sie lesen und ihnen Werte zuweisen.  Wenn die Daten im Cursor vollst√§ndig vorbereitet sind, f√ºhren wir <code>update()</code> und speichern den Inhalt des Cursors in der Datenbank. </p><br><p>  Welches Problem k√∂nnte dieser Code betreffen?  Nat√ºrlich das Auftauchen des Rennzustands / verlorenes Update!  Denn zwischen dem Moment, in dem wir die Daten in der Zeile mit "tryFirst" erhalten haben, und dem Moment, in dem wir versuchen, diese Daten am "Update" -Punkt zu aktualisieren, kann bereits jemand anderes diese Daten in der Datenbank empfangen, √§ndern und aktualisieren.  Nachdem die Daten gelesen wurden, blockiert der Cursor in keiner Weise ihre Verwendung durch andere Benutzer!  Zum Schutz vor verlorenen Updates verwendet Celesta das optimistische Sperrprinzip.  In jeder Tabelle erstellt Celesta standardm√§√üig ein <code>recversion</code> Auf der EIN-Ebene des UPDATE-Triggers wird die Versionsnummer erh√∂ht und √ºberpr√ºft, ob die aktualisierten Daten dieselbe Version wie die Tabelle haben.  Wenn ein Problem auftritt, wird eine Ausnahme ausgel√∂st.  Weitere Informationen hierzu finden Sie im Artikel ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schutz vor verlorenen Updates</a> ‚Äú. </p><br><p>  Erinnern Sie sich erneut daran, dass dem CallContext-Objekt eine Transaktion zugeordnet ist.  Wenn die Celesta-Prozedur erfolgreich ist, erfolgt ein Commit.  Wenn die Celesta-Methode mit einer nicht behandelten Ausnahme endet, tritt ein Rollback auf.  Wenn also in einer komplizierten Prozedur ein Fehler auftritt, wird die gesamte Transaktion in Bezug auf den Aufrufkontext zur√ºckgesetzt, als ob wir nicht begonnen h√§tten, etwas mit den Daten zu tun, und die Daten werden nicht besch√§digt.  Wenn Sie aus irgendeinem Grund ein Commit in der Mitte einer gro√üen Prozedur ben√∂tigen, kann ein explizites Commit durch Aufrufen von <code>context.commit()</code> . </p><br><h2 id="testirovanie-metodov-rabotayuschih-s-dannymi">  Testen von Datenmethoden </h2><br><p>  Erstellen wir einen <code>OrderDto</code> der die Richtigkeit der Servicemethode √ºberpr√ºft, mit der <code>OrderDto</code> in der Datenbank gespeichert wird. </p><br><p>  Bei Verwendung von JUnit5 und der im <code>celesta-unit</code> Modul verf√ºgbaren Erweiterung f√ºr JUnit5 ist dies sehr einfach.  Die Struktur des Tests ist wie folgt: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CelestaTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentServiceTest</span></span></span><span class="hljs-class"> </span></span>{ DocumentService srv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DocumentService(); <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">documentIsPutToDb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ OrderDto doc =... srv.postOrder(context, doc); <span class="hljs-comment"><span class="hljs-comment">//Check the fact that records are in the database OrderHeaderCursor header = new OrderHeaderCursor(context); header.tryFirst(); assertEquals(doc.getId(), header.getId()); OrderLineCursor line = new OrderLineCursor(context); line.setRange("order_id", doc.getId()); assertEquals(2, line.count()); } }</span></span></code> </pre> <br><p>  Dank der Annotation <code>@CelestaTest</code> , einer Erweiterung f√ºr JUnit5, k√∂nnen wir den <code>CallContext context</code> in Testmethoden deklarieren.  Dieser Kontext ist bereits aktiviert und an die Datenbank gebunden (In-Memory H2). Daher m√ºssen wir die Serviceklasse nicht in einen Proxy einbinden - wir erstellen sie mit <code>new</code> und nicht mit Spring.  Falls erforderlich, injizieren Sie den Service jedoch mit Federwerkzeugen in den Test, da dies keine Hindernisse darstellt. </p><br><p>  Wir erstellen Komponententests unter der Annahme, dass die Datenbank zum Zeitpunkt ihrer Ausf√ºhrung vollst√§ndig leer sein wird, aber mit der Struktur, die wir ben√∂tigen, und nach ihrer Ausf√ºhrung k√∂nnen wir uns keine Sorgen dar√ºber machen, dass wir "M√ºll" in der Datenbank belassen haben.  Diese Tests werden mit einer sehr hohen Geschwindigkeit durchgef√ºhrt. </p><br><p>  Erstellen wir eine zweite Prozedur, die JSON mit aggregierten Werten zur√ºckgibt, die angeben, wie viele Produkte wir bestellt haben. </p><br><p>  Der Test schreibt zwei Auftr√§ge in die Datenbank und √ºberpr√ºft anschlie√üend den von der neuen Methode <code>getAggregateReport</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportReturnsAggregatedQuantities</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ srv.postOrder(context, . . .); srv.postOrder(context, . . .); Map&lt;String, Integer&gt; result = srv.getAggregateReport(context); assertEquals(<span class="hljs-number"><span class="hljs-number">5</span></span>, result.get(<span class="hljs-string"><span class="hljs-string">"A"</span></span>).intValue()); assertEquals(<span class="hljs-number"><span class="hljs-number">7</span></span>, result.get(<span class="hljs-string"><span class="hljs-string">"B"</span></span>).intValue()); }</code> </pre> <br><p>  Um die <code>getAggregateReport</code> Methode zu implementieren <code>getAggregateReport</code> wir die OrderedQty-Ansicht, die, wie ich mich erinnere, in der CelestaSQL-Datei folgenderma√üen aussieht: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> item_id;</code> </pre> <br><p>  Die Anfrage ist Standard: Wir fassen Bestellpositionen nach Menge und Gruppe nach Produktcode zusammen.  F√ºr die Ansicht wurde bereits ein OrderedQtyCursor-Cursor erstellt, den wir verwenden k√∂nnen.  Wir deklarieren diesen Cursor, iterieren dar√ºber und sammeln die gew√ºnschte <code>Map&lt;String, Integer&gt;</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CelestaTransaction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAggregateReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Integer&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (OrderedQtyCursor ordered_qty = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderedQtyCursor(context)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (OrderedQtyCursor line : ordered_qty) { result.put(ordered_qty.getItem_id(), ordered_qty.getQty()); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h2 id="materializovannye-predstavleniya-celesta">  Materialisierte Celesta-Ansichten </h2><br><p>  Warum ist die Verwendung einer Ansicht schlecht, um aggregierte Daten abzurufen?  Dieser Ansatz ist durchaus praktikabel, bringt jedoch in Wirklichkeit eine Zeitbombe in unser gesamtes System: Schlie√ülich wird eine Ansicht, bei der es sich um eine SQL-Abfrage handelt, immer langsamer ausgef√ºhrt, wenn sich Daten im System ansammeln.  Er muss immer mehr Zeilen zusammenfassen und gruppieren.  Wie vermeide ich das? </p><br><p>  Celesta versucht, alle Standardaufgaben zu implementieren, mit denen Business-Logic-Programmierer auf Plattformebene st√§ndig konfrontiert sind. </p><br><p>  MS SQL Server hat das Konzept materialisierter (indizierter) Ansichten, die als Tabellen gespeichert und schnell aktualisiert werden, wenn sich die Daten in den Quelltabellen √§ndern.  Wenn wir in einem ‚Äûsauberen‚Äú MS SQL Server arbeiten w√ºrden, w√§re in unserem Fall das Ersetzen der Ansicht durch eine indizierte Ansicht genau das, was wir ben√∂tigen: Das Abrufen des aggregierten Berichts w√ºrde sich nicht verlangsamen, wenn sich die Daten ansammeln, und die Arbeit zum Aktualisieren des aggregierten Berichts w√ºrde im Moment ausgef√ºhrt Einf√ºgen von Daten in die Tabelle der Auftragspositionen und w√ºrde auch mit zunehmender Anzahl von Zeilen nicht viel zunehmen. </p><br><p>  Was k√∂nnen wir tun, wenn wir √ºber Celesta mit PostgreSQL arbeiten?  Definieren Sie die Ansicht neu, indem Sie das materialisierte Wort hinzuf√ºgen: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">materialized</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> item_id;</code> </pre> <br><p>  Lassen Sie uns das System starten und sehen, was mit der Datenbank passiert ist. </p><br><p>  Wir werden feststellen, dass die <code>OrderedQty</code> verschwunden ist und <code>OrderedQty</code> die <code>OrderedQty</code> Tabelle <code>OrderedQty</code> wurde.  Da die OrderLine-Tabelle mit Daten gef√ºllt ist, werden die Informationen in der OrderedQty-Tabelle au√üerdem "magisch" aktualisiert, als w√§re OrderedQty eine Ansicht. </p><br><p>  Es gibt hier keine Magie, wenn wir uns die Trigger ansehen, die auf der <code>OrderLine</code> Tabelle <code>OrderLine</code> .  Nachdem Celesta die Aufgabe erhalten hatte, eine ‚Äûmaterialisierte Ansicht‚Äú zu erstellen, analysierte sie die Abfrage und erstellte Trigger in der <code>OrderLine</code> Tabelle, die <code>OrderLine</code> aktualisieren.  Durch Einf√ºgen eines einzelnen Schl√ºsselworts - <code>materialized</code> - in die CelestaSQL-Datei haben wir das Problem der Leistungsverschlechterung gel√∂st, und der Gesch√§ftslogikcode musste nicht einmal ge√§ndert werden! </p><br><p> ,    ,   , . ¬´¬ª  Celesta    ,    ,  JOIN-,    GROUP BY.     ,  , ,     ,      . .     . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>       Celesta.     ‚Äî    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455746/">https://habr.com/ru/post/de455746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455736/index.html">Konsens in Kryptow√§hrungen mit Hybrid- und Multi-PoW-Mining</a></li>
<li><a href="../de455738/index.html">Wie k√∂nnen Sie eine Milliarde verdienen, indem Sie Ihre Daten monetarisieren?</a></li>
<li><a href="../de455740/index.html">Maschinelles Lernen in einer Investmentgesellschaft: Wir klassifizieren technische Supportanrufe</a></li>
<li><a href="../de455742/index.html">Musik machen: Wenn einfache L√∂sungen das tiefe Lernen √ºbertreffen</a></li>
<li><a href="../de455744/index.html">System zur Erzeugung von Labyrinthlandschaften mit verbessertem visuellen Realismus [√úbersetzung des Artikels von Jinmo Kim]</a></li>
<li><a href="../de455754/index.html">Tests eines treibenden Stratostaten. Start von Rogozin und LoRa in die Stratosph√§re</a></li>
<li><a href="../de455756/index.html">Ist [Gunst] th</a></li>
<li><a href="../de455758/index.html">Wachstumshacking bei Retail Rocket: Von der Hypothesensuche bis zu Testtechniken</a></li>
<li><a href="../de455760/index.html">Die Magie von SwiftUI oder √ºber Funktionsersteller</a></li>
<li><a href="../de455762/index.html">Eine kurze Einf√ºhrung in Markov-Ketten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>