<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍💼 🔲 ⛹🏾 Celesta 7.x: ORM, Migration und Testen "in einem Paket" 🌐 🚨 🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vielleicht wissen Sie bereits etwas über die Open-Source- Celesta- Bibliothek. Wenn nicht, spielt es keine Rolle, jetzt erzählen wir Ihnen alles. Ein ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Celesta 7.x: ORM, Migration und Testen "in einem Paket"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455746/"><p>  Vielleicht wissen Sie bereits etwas über die Open-Source- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Celesta-</a> Bibliothek.  Wenn nicht, spielt es keine Rolle, jetzt erzählen wir Ihnen alles.  Ein weiteres Jahr verging, Version 7.x wurde veröffentlicht, viele Dinge hatten sich geändert, und es war Zeit, die Änderungen zusammenzufassen und gleichzeitig daran zu erinnern, was Celesta im Allgemeinen ist. </p><br><div style="text-align:center;"><img width="350" src="https://habrastorage.org/webt/jj/7z/jt/jj7zjthmrh2dhdo4v0ueefqj6uq.png"></div><a name="habracut"></a><br><p> Wenn Sie noch nichts über Celesta gehört haben und beim Lesen dieses Artikels wissen möchten, für welche Geschäftsaufgaben die Anwendung am effektivsten ist, kann ich den ersten Teil des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alten Beitrags</a> oder dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">halbstündige Video</a> empfehlen (mit Ausnahme von Wörtern zur Verwendung der Python-Sprache).  Aber noch besser, lesen Sie zuerst diesen Artikel.  Ich werde mit den Änderungen beginnen, die in Version 7 vorgenommen wurden, und dann ein vollständiges technisches Beispiel für die Verwendung der modernen Version von Celesta durchgehen, um mithilfe von Spring Boot einen kleinen Backend-Dienst für eine Java-Anwendung zu schreiben. </p><br><h2 id="chto-izmenilos-v-versii-7x">  Was hat sich in Version 7.x geändert? </h2><br><ol><li>  Wir haben uns geweigert, Jython als eine in Celesta integrierte Sprache zu verwenden.  Wenn wir früher über Celesta mit der Tatsache gesprochen haben, dass Geschäftslogik in Python geschrieben ist, kann jetzt ... jede Java-Sprache als Sprache der Geschäftslogik dienen: Java, Groovy, JRuby oder dasselbe Jython.  Jetzt ruft Celesta den Geschäftslogikcode nicht mehr auf, aber der Geschäftslogikcode verwendet Celesta und seine Datenzugriffsklassen als häufigste Java-Bibliothek.  Ja, die Abwärtskompatibilität wurde dadurch verletzt, aber dies ist der Preis, den wir bereit waren zu zahlen.  Leider hat unsere Wette auf Jython verloren.  Als wir vor einigen Jahren mit der Verwendung von Jython begannen, war es ein lebhaftes und vielversprechendes Projekt, aber im Laufe der Jahre verlangsamte sich seine Entwicklung, der Rückstand aus der Sprachspezifikation häufte sich und Kompatibilitätsprobleme für die meisten Pip-Bibliotheken wurden nicht gelöst.  Der letzte Strohhalm waren die neuen Fehler in den neuesten Sprachversionen, die sich bei der Arbeit an einer Produktionslast zeigten.  Wir selbst haben nicht die Ressourcen, um das Jython-Projekt zu unterstützen, und wir haben beschlossen, uns davon zu trennen.  Celesta ist nicht mehr von Jython abhängig. </li><li>  Datenzugriffsklassen werden jetzt mithilfe des Maven-Plugins in der Java-Sprache (und nicht wie zuvor in Python) Code generiert.  Und da wir aus diesem Grund von der dynamischen zur statischen Typisierung übergegangen sind, haben sich mehr Möglichkeiten für das Refactoring ergeben und es wurde einfacher, subjektiv korrekten Code zu schreiben. </li><li>  Die Erweiterung für JUnit5 wurde angezeigt, sodass es sehr praktisch wurde, Logiktests zu schreiben, die mit der Datenbank in JUnit5 arbeiten (auf die später noch eingegangen wird). </li><li>  Ein separates Projekt ist erschienen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring-Boot-Starter-Celesta</a> , das, wie der Name schon sagt, der Celesta-Starter in Spring Boot ist.  Die Möglichkeit, Celesta-Anwendungen in einfach zu implementierende Spring Boot-Dienste zu packen, kompensierte den Verlust der Möglichkeit, die Anwendung auf dem Server zu aktualisieren, indem einfach der Ordner mit Python-Skripten geändert wurde. </li><li>  Wir haben die gesamte Dokumentation aus dem Wiki in das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AsciiDoctor-</a> Format übertragen, sie zusammen mit dem Code in die Versionskontrolle gestellt und verfügen nun über eine aktuelle Dokumentation für jede Celesta-Version.  Die neueste Version der Online-Dokumentation finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://courseorchestra.github.io/celesta/</a> </li><li>  Wir wurden oft gefragt, ob es möglich ist, die Datenbankmigration über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">idempotente DDL</a> getrennt von Celesta zu verwenden.  Jetzt gibt es eine solche Möglichkeit mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2bass-</a> Tool. </li></ol><br><h2 id="chto-takoe-selesta-i-chto-ona-umeet">  Was ist Celesta und was kann sie tun? </h2><br><p>  Kurz gesagt, Celesta ist: </p><br><ul><li>  eine Zwischenschicht zwischen der relationalen Datenbank und dem Geschäftslogikcode, basierend auf dem <em>Datenbank-First-</em> Design-Ansatz, </li><li>  Migrationsmechanismus der Datenbankstruktur, </li><li>  Framework zum Testen von Code, der mit Daten arbeitet. </li></ul><br><p>  Wir unterstützen vier Arten relationaler Datenbanken: PostgreSQL, MS SQL Server, Oracle und H2. </p><br><p>  Hauptmerkmale von Celesta: </p><br><ol><li>  Ein Prinzip, das dem Grundprinzip von Java sehr ähnlich ist: "Einmal schreiben, auf jedem unterstützten RDBMS ausführen."  Der Geschäftslogikcode weiß nicht, auf welchem ​​Datenbanktyp er ausgeführt wird.  Sie können den Geschäftslogikcode schreiben und in MS SQL Server ausführen und dann zu PostgreSQL wechseln. Dies geschieht ohne Komplikationen (na ja, fast :) </li><li>  Automatische Umstrukturierung in einer Live-Datenbank.  Der größte Teil des Lebenszyklus von Celesta-Projekten findet statt, wenn die Arbeitsdatenbank bereits vorhanden ist und mit Daten gefüllt ist, die gespeichert werden müssen. Es ist jedoch auch erforderlich, ihre Struktur ständig zu ändern.  Eines der Hauptmerkmale von Celesta ist die Möglichkeit, die Datenbankstruktur automatisch an Ihr Datenmodell anzupassen. </li><li>  Testen.  Es wird viel Wert darauf gelegt, dass der Code für Celesta testbar ist, damit wir automatisch Methoden testen können, mit denen Daten in der Datenbank geändert werden können. Dies geschieht einfach, schnell und elegant, ohne externe Tools wie DbUnit und Container zu verwenden. </li></ol><br><h2 id="dlya-chego-nuzhna-nezavisimost-ot-tipa-subd">  Warum brauchen Sie Unabhängigkeit von der Art des DBMS? </h2><br><p>  Die Unabhängigkeit des Geschäftslogikcodes vom DBMS-Typ war nicht der erste Punkt, den wir festgelegt haben: Der für Celesta geschriebene Code weiß überhaupt nicht, auf welchem ​​DBMS er ausgeführt wird.  Warum? </p><br><p>  Erstens aufgrund der Tatsache, dass die Wahl eines DBMS-Typs kein technologisches, sondern ein politisches Problem ist.  Wenn wir zu einem neuen Geschäftskunden kommen, stellen wir häufig fest, dass er bereits einen bevorzugten DBMS-Typ hat, in den Mittel investiert werden, und der Kunde möchte andere Lösungen für die vorhandene Infrastruktur sehen.  Die technologische Landschaft ändert sich: PostgreSQL findet sich zunehmend in Regierungsbehörden und privaten Unternehmen, obwohl sich MS SQL Server in unserer Praxis vor einigen Jahren durchgesetzt hat.  Celesta unterstützt die gängigsten DBMS, und wir sind nicht besorgt über diese Änderungen. </p><br><p>  Zweitens möchte ich den bereits erstellten Code zur Lösung von Standardproblemen von einem Projekt in ein anderes übertragen, um eine wiederverwendbare Bibliothek zu erstellen.  Dinge wie hierarchische Verzeichnisse oder E-Mail-Benachrichtigungsverteilungsmodule sind von Natur aus Standard. Warum müssen wir mehrere Versionen für Kunden mit unterschiedlichen Beziehungen unterstützen? </p><br><p>  Drittens, nicht zuletzt die Möglichkeit, Komponententests ohne Verwendung von DbUnit und Containern mithilfe einer speicherinternen H2-Datenbank durchzuführen.  In diesem Modus startet die H2-Basis sofort.  Celesta erstellt sehr schnell ein Datenschema, nach dem Sie die erforderlichen Tests durchführen und die Datenbank „vergessen“ können.  Da der Geschäftslogikcode wirklich nicht weiß, auf welcher Basis er ausgeführt wird, funktioniert er entsprechend fehlerfrei unter PostgreSQL, wenn er auf H2 fehlerfrei funktioniert.  Die Aufgabe der Entwickler des Celesta-Systems selbst besteht natürlich darin, alle Tests mit echten DBMS durchzuführen, um sicherzustellen, dass unsere Plattform ihre API für verschiedene Beziehungen gleichermaßen ausführt.  Und wir machen es.  Der Entwickler der Geschäftslogik wird jedoch nicht mehr benötigt. </p><br><h2 id="celestasql">  CelestaSQL </h2><br><p>  Wie wird Cross-Basalism erreicht?  Natürlich auf Kosten der Arbeit mit Daten nur über eine spezielle API, die die Logik von allen Datenbankspezifikationen isoliert.  Celesta generiert Java-Klassen für den Zugriff auf Daten einerseits und SQL-Code und einige Hilfsobjekte in der Datenbank andererseits. </p><br><p>  Celesta bietet keine objektrelationale Zuordnung in ihrer reinsten Form, da wir beim Entwerfen eines Datenmodells nicht aus Klassen, sondern aus der Datenbankstruktur stammen.  Das heißt, wir erstellen zuerst ein ER-Modell von Tabellen, und dann generiert Celesta basierend auf diesem Modell selbst Cursorklassen für den Zugriff auf Daten. </p><br><p>  Sie können dieselbe Arbeit für alle unterstützten DBMS nur für die Funktionalität ausführen, die in jedem von ihnen ungefähr gleich implementiert ist.  Wenn wir die Menge der Funktionsfähigkeiten jeder von uns unterstützten Basis in Form von „Eulerkreisen“ bedingt darstellen, erhalten wir das folgende Bild: </p><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/getpro/habr/post_images/7d9/2ad/1e1/7d92ad1e1a3bc0bb83b5c4bcc511ec66.png"></div><br><p>  Wenn wir eine vollständige Unabhängigkeit von der Art der Datenbank bieten, sollte die Funktionalität, die wir für Programmierer von Geschäftslogik öffnen, innerhalb des Schnittpunkts aller Basen liegen.  Auf den ersten Blick scheint dies eine erhebliche Einschränkung zu sein.  Ja, für einige spezifische Funktionen können wir beispielsweise SQL Server nicht verwenden.  Relationale Datenbanken unterstützen jedoch ausnahmslos Tabellen, Fremdschlüssel, Ansichten, Sequenzen und SQL-Abfragen mit JOIN und GROUP BY.  Dementsprechend können wir Entwicklern diese Möglichkeiten geben.  Wir stellen Entwicklern "depersonalisiertes SQL" zur Verfügung, das wir "CelestaSQL" nennen, und generieren dabei SQL-Abfragen für Dialekte der entsprechenden Datenbanken. </p><br><p>  Die CelestaSQL-Sprache enthält DDL zum Definieren von Datenbankobjekten und SELECT-Abfragen für Ansichten und Filter, enthält jedoch keine DML-Befehle: Cursor werden zum Ändern der Daten verwendet, die noch zu diskutieren sind. </p><br><p>  Jede Datenbank hat ihre eigenen Datentypen.  CelestaSQL hat auch eigene Typen.  Zum Zeitpunkt des Schreibens gibt es neun davon, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Tabelle</a> vergleicht sie mit realen Typen in verschiedenen Datenbanken und Java-Datentypen. </p><br><p>  Es mag den Anschein haben, dass neun Typen nicht ausreichen (im Vergleich zu dem, was PostgreSQL beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unterstützt</a> ), aber in Wirklichkeit sind dies die Typen, die ausreichen, um Finanz-, Handels- und Logistikinformationen zu speichern: Zeichenfolgen, Ganzzahlen, Bruchzahlen , Daten, Boolesche Werte und Blobs reichen immer aus, um solche Daten darzustellen. </p><br><p>  Die CelestaSQL-Sprache selbst wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> mit einer Vielzahl von Syntaxdiagrammen beschrieben. </p><br><h2 id="modifikaciya-struktury-bazy-dannyh-idempotentnyy-ddl">  Änderung der Datenbankstruktur.  Idempotente DDL </h2><br><p>  Ein weiteres wichtiges Merkmal von Celesta ist der Ansatz zur Migration der Struktur der Arbeitsdatenbank während der Projektentwicklung.  Zu diesem Zweck wird der in Celesta integrierte Ansatz mit idempotenter DDL verwendet. </p><br><p>  Kurz gesagt, wenn wir in CelestaSQL den folgenden Text schreiben: </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine( order_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, line_no <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), qty <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span> <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Idx_OrderLine PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id, line_no) );</code> </pre> <br><p>  - Dieser Text wird von Celesta nicht als "Tabelle erstellen, aber wenn bereits eine Tabelle vorhanden ist, geben Sie einen Fehler aus" interpretiert, sondern als "Tabelle in die gewünschte Struktur bringen".  Das heißt: „Wenn es keine Tabelle gibt, erstellen Sie sie, wenn es eine Tabelle gibt, sehen Sie, welche Felder darin enthalten sind, mit welchen Typen, welchen Indizes, welchen Fremdschlüsseln, welchen Standardwerten usw. und ob etwas geändert werden muss diesen Tisch, um es auf die richtige Art zu bringen. " </p><br><p>  Mit diesem Ansatz implementieren wir die Möglichkeit, Skripte zu refaktorieren und zu versionieren, um die Struktur der Datenbank zu bestimmen: </p><br><ul><li>  wir sehen im Skript das aktuelle "gewünschte Bild" der Struktur, </li><li>  Was, von wem und warum hat sich die Struktur im Laufe der Zeit geändert? Wir können das Versionskontrollsystem durchsehen. </li><li>  Bei ALTER-Befehlen generiert Celesta diese automatisch und führt sie bei Bedarf „unter der Haube“ aus. </li></ul><br><p>  Natürlich hat dieser Ansatz seine Grenzen.  Celesta unternimmt alle Anstrengungen, um sicherzustellen, dass die automatische Migration problemlos und nahtlos verläuft. Dies ist jedoch nicht in allen Fällen möglich.  Die Motivation, Möglichkeiten und Grenzen dieses Ansatzes wurden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Beitrag beschrieben</a> (die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">englische Version</a> ist ebenfalls verfügbar). </p><br><p>  Um den Prozess des Überprüfens / Aktualisierens der Datenbankstruktur zu beschleunigen, wendet Celesta die Speicherung von DDL-Skriptprüfsummen in der Datenbank an (bis die Prüfsumme geändert wird, startet der Prozess des Überprüfens und Aktualisierens der Datenbankstruktur nicht).  Damit der Aktualisierungsprozess ohne Probleme in Bezug auf die Reihenfolge der Änderung von voneinander abhängigen Objekten fortgesetzt werden kann, wird die topologische Sortierung der Abhängigkeiten zwischen Schemata nach Fremdschlüsseln angewendet.  Der automatische Migrationsprozess wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ausführlicher beschrieben. </p><br><h2 id="sozdanie-proekta-celesta-i-modeli-dannyh">  Erstellen eines Celesta-Projekts und eines Datenmodells </h2><br><p>  Das Demo-Projekt, das wir betrachten werden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist auf dem Github verfügbar</a> .  Mal sehen, wie Sie Celesta beim Schreiben einer Spring Boot-Anwendung verwenden können.  Hier sind die Maven-Abhängigkeiten, die Sie benötigen: </p><br><ul><li>  <code>org.springframework.boot:spring-boot-starter-web</code> und <code>ru.curs:spring-boot-starter-celesta</code> (weitere Informationen finden <code>ru.curs:spring-boot-starter-celesta</code> Dokumentation). </li><li>  Wenn Sie Spring Boot nicht verwenden, können Sie die <code>ru.curs:celesta-system-services</code> direkt verbinden. </li><li>  Für die Codegenerierung von Datenzugriffsklassen basierend auf Celesta-SQL-Skripten wird <code>ru.curs:celesta-maven-plugin</code> benötigt <code>ru.curs:celesta-maven-plugin</code> - Der Quellcode für ein Demo-Beispiel oder eine Dokumentation beschreibt, wie die Verbindung hergestellt wird. </li><li>  Um die Möglichkeit zu nutzen, JUnit5-Komponententests für Methoden zu schreiben, die Daten ändern, müssen Sie <code>ru.curs:celesta-unit</code> im <code>ru.curs:celesta-unit</code> verbinden. </li></ul><br><p>  Erstellen Sie nun ein Datenmodell und kompilieren Sie Datenzugriffsklassen. </p><br><p>  Angenommen, wir führen ein Projekt für ein E-Commerce-Unternehmen durch, das kürzlich mit einem anderen Unternehmen fusioniert wurde.  Jeder hat seine eigene Datenbank.  Sie sammeln Bestellungen, aber bis sie ihre Datenbanken zusammengeführt haben, benötigen sie einen einzigen Einstiegspunkt, um Bestellungen von außerhalb zu sammeln. </p><br><p>  Die Implementierung dieses „Einstiegspunkts“ sollte recht traditionell sein: ein HTTP-Dienst mit CRUD-Operationen, die Daten in einer relationalen Datenbank speichern. </p><br><p>  Aufgrund der Tatsache, dass Celesta den Designansatz "Datenbank zuerst" implementiert, müssen wir zuerst eine Tabellenstruktur erstellen, in der Bestellungen gespeichert werden.  Wie Sie wissen, ist eine Bestellung eine zusammengesetzte Entität: Sie besteht aus einer Kopfzeile, in der Informationen über den Kunden, das Bestelldatum und andere Attribute der Bestellung sowie viele Zeilen (Warenartikel) gespeichert sind. </p><br><p>  Also, für den Job: erstellen </p><br><ul><li>  <code>src/main/celestasql</code> - Standardmäßig ist dies der Pfad zu den CelestaSQL-Projektskripten </li><li>  Es enthält Unterordner, die die Ordnerstruktur von Java-Paketen wiederholen (in unserem Fall <code>ru/curs/demo</code> ). </li><li>  Erstellen Sie im <code>.sql</code> eine <code>.sql</code> Datei mit folgendem Inhalt: </li></ul><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SCHEMA</span></span> demo <span class="hljs-keyword"><span class="hljs-keyword">VERSION</span></span> <span class="hljs-string"><span class="hljs-string">'1.0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderHeader( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> DATETIME, customer_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>), <span class="hljs-comment"><span class="hljs-comment">/**  */</span></span> customer_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>), manager_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Pk_OrderHeader PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">/** */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine( order_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, line_no <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_id <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, item_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), qty <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span> <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> Idx_OrderLine PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id, line_no) ); <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> fk_OrderLine <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (order_id) <span class="hljs-keyword"><span class="hljs-keyword">REFERENCES</span></span> OrderHeader(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> item_id;</code> </pre> <br><p>  Hier haben wir zwei Tabellen beschrieben, die durch einen Fremdschlüssel verbunden sind, und eine Ansicht, die eine zusammenfassende Menge für die in allen Bestellungen vorhandenen Waren zurückgibt.  Wie Sie sehen, unterscheidet sich dies nicht von regulärem SQL, mit Ausnahme des Befehls <code>CREATE SCHEMA</code> , in dem wir die <code>demo</code> Schema-Version deklariert haben (Informationen darüber, wie sich die Versionsnummer auf die automatische Migration auswirkt, finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ).  Es gibt aber auch Funktionen.  Beispielsweise können alle Namen der von uns verwendeten Tabellen und Felder nur so sein, dass sie in der Java-Sprache in gültige Klassen- und Variablennamen umgewandelt werden können.  Leerzeichen, Sonderzeichen sind daher ausgeschlossen.  Sie können auch feststellen, dass die Kommentare, die wir über die Namen von Tabellen und einigen Feldern setzen, nicht wie üblich mit / * begonnen haben, sondern mit / **, wie JavaDoc-Kommentare beginnen - und das ist kein Zufall!  Ein Kommentar, der für eine Entität definiert ist, die mit / ** beginnt, ist zur Laufzeit in der Eigenschaft <code>.getCelestaDoc()</code> dieser Entität verfügbar.  Dies ist nützlich, wenn wir Datenbankelementen zusätzliche Metainformationen bereitstellen möchten: z. B. von Menschen lesbare Feldnamen, Informationen zur Darstellung von Feldern in der Benutzeroberfläche usw. </p><br><p>  Das CelestaSQL-Skript erfüllt zwei gleich wichtige Aufgaben: Erstens für die Bereitstellung / Änderung der Struktur einer relationalen Datenbank und zweitens für die Codegenerierung von Datenzugriffsklassen. </p><br><p>  Wir können jetzt Datenzugriffsklassen generieren. Führen Sie einfach den Befehl <code>mvn generate-sources</code> . Wenn Sie in IDEA arbeiten, klicken Sie in der Maven-Systemsteuerung auf die Schaltfläche "Quellen generieren und Ordner aktualisieren".  Im zweiten Fall „ <code>target/generated-sources/celesta</code> IDEA <code>target/generated-sources/celesta</code> in <code>target/generated-sources/celesta</code> erstellten Ordner auf und stellt seinen Inhalt für den Import in die Projektquellcodes zur Verfügung.  Das Ergebnis der Codegenerierung sieht folgendermaßen aus: Eine Klasse für jedes Objekt in der Datenbank: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2x/3q/cs/2x3qcsydsu3y5vplbyh7oz15z-s.png"></div><br><p>  Die Verbindung zur Datenbank wird in den Anwendungseinstellungen angegeben, in unserem Fall in der Datei <code>src/main/resources/application.yml</code> .  Bei Verwendung von Spring-Boot-Starter-Celesta informiert IDEA Sie über die Codeoptionen, die bei der Code-Vervollständigung verfügbar sind. </p><br><p>  Wenn wir uns zu Demonstrationszwecken nicht mit dem „echten“ RDBMS beschäftigen möchten, können wir Celesta mithilfe der folgenden Konfiguration dazu bringen, mit der integrierten H2-Datenbank im In-Memory-Modus zu arbeiten: </p><br><pre> <code class="plaintext hljs">celesta: h2: inMemory: true</code> </pre> <br><p>  Um eine "echte" Datenbank zu verbinden, ändern Sie die Konfiguration in etwas wie </p><br><pre> <code class="plaintext hljs">celesta: jdbc: url: jdbc:postgresql://127.0.0.1:5432/celesta username: &lt;your_username&gt; password: &lt;your_password&gt;</code> </pre> <br><p>  (In diesem Fall müssen Sie Ihrer Anwendung über die Maven-Abhängigkeit auch einen PostgreSQL-JDBC-Treiber hinzufügen.) </p><br><p>  Wenn Sie eine Celesta-Anwendung mit einer Verbindung zu einem Datenbankserver starten, können Sie feststellen, dass die erforderlichen Tabellen, Ansichten, Indizes usw. für eine leere Datenbank erstellt und für eine nicht leere Datenbank auf die in der DDL angegebenen Strukturen aktualisiert werden. </p><br><h2 id="sozdanie-metodov-rabotayuschih-s-dannymi">  Erstellen von Datenmanipulationsmethoden </h2><br><p>  Sobald Sie herausgefunden haben, wie eine Datenbankstruktur erstellt wird, können Sie mit dem Schreiben von Geschäftslogik beginnen. </p><br><p>  Um die Anforderungen für die Verteilung von Zugriffsrechten und Protokollierungsaktionen implementieren zu können, werden alle Vorgänge für Daten in Celesta im Auftrag eines Benutzers ausgeführt. Es gibt keine „anonymen“ Vorgänge.  Daher wird jeder Celesta-Code im <em>Kontext des</em> in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CallContext-</a> Klasse beschriebenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufrufs ausgeführt</a> . </p><br><ul><li>  Vor dem Starten eines Vorgangs, mit dem Daten in der Datenbank <code>CallContext</code> , wird <code>CallContext</code> aktiviert. </li><li>  Zum Zeitpunkt der Aktivierung wird eine Verbindung zur Datenbank aus dem Verbindungspool entnommen und die Transaktion beginnt. </li><li>  Nach Abschluss des <code>CallContext</code> führt <code>CallContext</code> entweder <code>commit()</code> wenn der Vorgang erfolgreich war, oder <code>rollback()</code> wenn während der Ausführung eine nicht behandelte Ausnahme aufgetreten ist. <code>CallContext</code> geschlossen und die Datenbankverbindung wird an den Pool zurückgegeben. </li></ul><br><p>  Wenn wir Spring-Boot-Starter-Celesta verwenden, werden diese Aktionen automatisch für alle von <code>@CelestaTransaction</code> kommentierten Methoden <code>@CelestaTransaction</code> . </p><br><p>  Angenommen, wir möchten einen Handler schreiben, der das Dokument in der Datenbank speichert.  Der Code auf Controller-Ebene könnte folgendermaßen aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/api"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DocumentService srv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DocumentController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DocumentService srv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.srv = srv; } <span class="hljs-meta"><span class="hljs-meta">@PutMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/save"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody OrderDto order)</span></span></span><span class="hljs-function"> </span></span>{ CallContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallContext(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//new SystemCallContext(); srv.postOrder(ctx, order); }</span></span></code> </pre> <br><p>  In der Regel kennen wir auf der Ebene der Controller-Methode (d. H. Wenn die Authentifizierung bereits bestanden wurde) die Benutzer-ID und können sie beim Erstellen des <code>CallContext</code> .  Das Binden eines Benutzers an einen Kontext bestimmt die Berechtigungen für den Zugriff auf Tabellen und bietet auch die Möglichkeit, in seinem Namen vorgenommene Änderungen zu protokollieren.  In diesem Fall müssen für die Funktionsfähigkeit des mit der Datenbank interagierenden Codes die Rechte für den Benutzer "Benutzer1" in den Systemtabellen angegeben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Wenn Sie das Celesta-Zugriffsverteilungssystem nicht verwenden und dem Sitzungskontext alle Rechte für Tabellen erteilen möchten, können Sie ein <code>SystemCallContext</code> Objekt erstellen. </p><br><p>  Die Methode zum Speichern der Rechnung auf Serviceebene kann folgendermaßen aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@CelestaTransaction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context, OrderDto doc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); OrderLineCursor line = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderLineCursor(context)) { header.setId(doc.getId()); header.setDate(Date.from(doc.getDate().atStartOfDay(ZoneId.systemDefault()).toInstant())); header.setCustomer_id(doc.getCustomerId()); header.setCustomer_name(doc.getCustomerName()); header.insert(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lineNo = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (OrderLineDto docLine : doc.getLines()) { lineNo++; line.setLine_no(lineNo); line.setOrder_id(doc.getId()); line.setItem_id(docLine.getItemId()); line.setQty(docLine.getQty()); line.insert(); } } }</code> </pre> <br><p>  Beachten Sie die Annotation <code>@CelestaTransaction</code> .  Dank dessen führt das Proxy-Objekt <code>DocumentService</code> alle diese <code>CallContext ctx</code> mit dem <code>CallContext ctx</code> beschriebenen Parameter <code>CallContext ctx</code> .  Das heißt, zu Beginn der Methodenausführung ist sie bereits an die Datenbankverbindung gebunden, und die Transaktion kann gestartet werden.  Wir können uns darauf konzentrieren, Geschäftslogik zu schreiben.  In unserem Fall lesen Sie das <code>OrderDto</code> Objekt und speichern es in der Datenbank. </p><br><p>  Dazu verwenden wir die sogenannten Cursor - Klassen, die mit dem <code>celesta-maven-plugin</code> generiert wurden.  Wir haben bereits gesehen, was sie sind.  Für jedes der Schemaobjekte wird eine Klasse erstellt - zwei Tabellen und eine Ansicht.  Und jetzt können wir diese Klassen verwenden, um auf Datenbankobjekte in unserer Geschäftslogik zuzugreifen. </p><br><p>  Um einen Cursor in der Auftragstabelle zu erstellen und den ersten Datensatz auszuwählen, müssen Sie den folgenden Code schreiben: </p><br><pre> <code class="java hljs">OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); header.tryFirst();</code> </pre> <br><p>  Nach dem Erstellen des Header-Objekts können wir über Getter und Setter auf die Felder des Tabelleneintrags zugreifen: </p><br><div style="text-align:center;"><img width="450" src="https://habrastorage.org/webt/_8/gl/9i/_8gl9ikjbprpjano2dbvj0reme8.png"></div><br><p>  Beim Erstellen eines Cursors müssen wir den aktiven Aufrufkontext verwenden - dies ist die einzige Möglichkeit, einen Cursor zu erstellen.  Der Anrufkontext enthält Informationen über den aktuellen Benutzer und seine Zugriffsrechte. </p><br><p>  Mit dem Cursor-Objekt können wir verschiedene Dinge tun: filtern, Datensätze durchgehen und natürlich auch Datensätze einfügen, löschen und aktualisieren.  Die gesamte Cursor-API wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ausführlich beschrieben. </p><br><p>  Zum Beispiel könnte der Code unseres Beispiels wie folgt entwickelt werden: </p><br><pre> <code class="java hljs">OrderHeaderCursor header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderHeaderCursor(context); header.setRange(<span class="hljs-string"><span class="hljs-string">"manager_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"manager1"</span></span>); header.tryFirst(); header.setCounter(header.getCounter() + <span class="hljs-number"><span class="hljs-number">1</span></span>); header.update();</code> </pre> <br><p>  In diesem Beispiel setzen wir den Filter nach dem Feld manager_id und finden dann den ersten Datensatz mit der Methode tryFirst. </p><br><div class="spoiler">  <b class="spoiler_title">(warum "versuchen")</b> <div class="spoiler_text"><p>  Die Methoden <code>get</code> , <code>first</code> , <code>insert</code> , <code>update</code> haben zwei Optionen: ohne das try-Präfix (nur <code>get(...)</code> usw.) und mit dem try-Präfix ( <code>tryGet(...)</code> , <code>tryFirst()</code> usw.) .  Methoden ohne das Präfix try lösen eine Ausnahme aus, wenn die Datenbank nicht über die entsprechenden Daten zum Ausführen der Aktion verfügt.  Beispielsweise löst first () eine Ausnahme aus, wenn keine Datensätze in den auf dem Cursor festgelegten Filter gelangen.  Gleichzeitig lösen Methoden mit dem Präfix try keine Ausnahme aus, sondern geben stattdessen einen Booleschen Wert zurück, der den Erfolg oder Misserfolg der entsprechenden Operation signalisiert.  Es wird empfohlen, nach Möglichkeit Methoden ohne das Präfix try zu verwenden.  Auf diese Weise wird ein "Selbsttest" -Code erstellt, der zeitliche Fehler in den Logik- und / oder Datenbankdaten signalisiert. </p></div></div><br><p>  Wenn <code>tryFirst</code> ausgelöst wird, werden die <code>tryFirst</code> Variablen mit den Daten eines Datensatzes gefüllt, wir können sie lesen und ihnen Werte zuweisen.  Wenn die Daten im Cursor vollständig vorbereitet sind, führen wir <code>update()</code> und speichern den Inhalt des Cursors in der Datenbank. </p><br><p>  Welches Problem könnte dieser Code betreffen?  Natürlich das Auftauchen des Rennzustands / verlorenes Update!  Denn zwischen dem Moment, in dem wir die Daten in der Zeile mit "tryFirst" erhalten haben, und dem Moment, in dem wir versuchen, diese Daten am "Update" -Punkt zu aktualisieren, kann bereits jemand anderes diese Daten in der Datenbank empfangen, ändern und aktualisieren.  Nachdem die Daten gelesen wurden, blockiert der Cursor in keiner Weise ihre Verwendung durch andere Benutzer!  Zum Schutz vor verlorenen Updates verwendet Celesta das optimistische Sperrprinzip.  In jeder Tabelle erstellt Celesta standardmäßig ein <code>recversion</code> Auf der EIN-Ebene des UPDATE-Triggers wird die Versionsnummer erhöht und überprüft, ob die aktualisierten Daten dieselbe Version wie die Tabelle haben.  Wenn ein Problem auftritt, wird eine Ausnahme ausgelöst.  Weitere Informationen hierzu finden Sie im Artikel „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schutz vor verlorenen Updates</a> “. </p><br><p>  Erinnern Sie sich erneut daran, dass dem CallContext-Objekt eine Transaktion zugeordnet ist.  Wenn die Celesta-Prozedur erfolgreich ist, erfolgt ein Commit.  Wenn die Celesta-Methode mit einer nicht behandelten Ausnahme endet, tritt ein Rollback auf.  Wenn also in einer komplizierten Prozedur ein Fehler auftritt, wird die gesamte Transaktion in Bezug auf den Aufrufkontext zurückgesetzt, als ob wir nicht begonnen hätten, etwas mit den Daten zu tun, und die Daten werden nicht beschädigt.  Wenn Sie aus irgendeinem Grund ein Commit in der Mitte einer großen Prozedur benötigen, kann ein explizites Commit durch Aufrufen von <code>context.commit()</code> . </p><br><h2 id="testirovanie-metodov-rabotayuschih-s-dannymi">  Testen von Datenmethoden </h2><br><p>  Erstellen wir einen <code>OrderDto</code> der die Richtigkeit der Servicemethode überprüft, mit der <code>OrderDto</code> in der Datenbank gespeichert wird. </p><br><p>  Bei Verwendung von JUnit5 und der im <code>celesta-unit</code> Modul verfügbaren Erweiterung für JUnit5 ist dies sehr einfach.  Die Struktur des Tests ist wie folgt: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CelestaTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocumentServiceTest</span></span></span><span class="hljs-class"> </span></span>{ DocumentService srv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DocumentService(); <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">documentIsPutToDb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ OrderDto doc =... srv.postOrder(context, doc); <span class="hljs-comment"><span class="hljs-comment">//Check the fact that records are in the database OrderHeaderCursor header = new OrderHeaderCursor(context); header.tryFirst(); assertEquals(doc.getId(), header.getId()); OrderLineCursor line = new OrderLineCursor(context); line.setRange("order_id", doc.getId()); assertEquals(2, line.count()); } }</span></span></code> </pre> <br><p>  Dank der Annotation <code>@CelestaTest</code> , einer Erweiterung für JUnit5, können wir den <code>CallContext context</code> in Testmethoden deklarieren.  Dieser Kontext ist bereits aktiviert und an die Datenbank gebunden (In-Memory H2). Daher müssen wir die Serviceklasse nicht in einen Proxy einbinden - wir erstellen sie mit <code>new</code> und nicht mit Spring.  Falls erforderlich, injizieren Sie den Service jedoch mit Federwerkzeugen in den Test, da dies keine Hindernisse darstellt. </p><br><p>  Wir erstellen Komponententests unter der Annahme, dass die Datenbank zum Zeitpunkt ihrer Ausführung vollständig leer sein wird, aber mit der Struktur, die wir benötigen, und nach ihrer Ausführung können wir uns keine Sorgen darüber machen, dass wir "Müll" in der Datenbank belassen haben.  Diese Tests werden mit einer sehr hohen Geschwindigkeit durchgeführt. </p><br><p>  Erstellen wir eine zweite Prozedur, die JSON mit aggregierten Werten zurückgibt, die angeben, wie viele Produkte wir bestellt haben. </p><br><p>  Der Test schreibt zwei Aufträge in die Datenbank und überprüft anschließend den von der neuen Methode <code>getAggregateReport</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportReturnsAggregatedQuantities</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ srv.postOrder(context, . . .); srv.postOrder(context, . . .); Map&lt;String, Integer&gt; result = srv.getAggregateReport(context); assertEquals(<span class="hljs-number"><span class="hljs-number">5</span></span>, result.get(<span class="hljs-string"><span class="hljs-string">"A"</span></span>).intValue()); assertEquals(<span class="hljs-number"><span class="hljs-number">7</span></span>, result.get(<span class="hljs-string"><span class="hljs-string">"B"</span></span>).intValue()); }</code> </pre> <br><p>  Um die <code>getAggregateReport</code> Methode zu implementieren <code>getAggregateReport</code> wir die OrderedQty-Ansicht, die, wie ich mich erinnere, in der CelestaSQL-Datei folgendermaßen aussieht: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> item_id;</code> </pre> <br><p>  Die Anfrage ist Standard: Wir fassen Bestellpositionen nach Menge und Gruppe nach Produktcode zusammen.  Für die Ansicht wurde bereits ein OrderedQtyCursor-Cursor erstellt, den wir verwenden können.  Wir deklarieren diesen Cursor, iterieren darüber und sammeln die gewünschte <code>Map&lt;String, Integer&gt;</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CelestaTransaction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAggregateReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallContext context)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Integer&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (OrderedQtyCursor ordered_qty = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderedQtyCursor(context)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (OrderedQtyCursor line : ordered_qty) { result.put(ordered_qty.getItem_id(), ordered_qty.getQty()); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h2 id="materializovannye-predstavleniya-celesta">  Materialisierte Celesta-Ansichten </h2><br><p>  Warum ist die Verwendung einer Ansicht schlecht, um aggregierte Daten abzurufen?  Dieser Ansatz ist durchaus praktikabel, bringt jedoch in Wirklichkeit eine Zeitbombe in unser gesamtes System: Schließlich wird eine Ansicht, bei der es sich um eine SQL-Abfrage handelt, immer langsamer ausgeführt, wenn sich Daten im System ansammeln.  Er muss immer mehr Zeilen zusammenfassen und gruppieren.  Wie vermeide ich das? </p><br><p>  Celesta versucht, alle Standardaufgaben zu implementieren, mit denen Business-Logic-Programmierer auf Plattformebene ständig konfrontiert sind. </p><br><p>  MS SQL Server hat das Konzept materialisierter (indizierter) Ansichten, die als Tabellen gespeichert und schnell aktualisiert werden, wenn sich die Daten in den Quelltabellen ändern.  Wenn wir in einem „sauberen“ MS SQL Server arbeiten würden, wäre in unserem Fall das Ersetzen der Ansicht durch eine indizierte Ansicht genau das, was wir benötigen: Das Abrufen des aggregierten Berichts würde sich nicht verlangsamen, wenn sich die Daten ansammeln, und die Arbeit zum Aktualisieren des aggregierten Berichts würde im Moment ausgeführt Einfügen von Daten in die Tabelle der Auftragspositionen und würde auch mit zunehmender Anzahl von Zeilen nicht viel zunehmen. </p><br><p>  Was können wir tun, wenn wir über Celesta mit PostgreSQL arbeiten?  Definieren Sie die Ansicht neu, indem Sie das materialisierte Wort hinzufügen: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">materialized</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> OrderedQty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> item_id, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(qty) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> qty <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> OrderLine <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> item_id;</code> </pre> <br><p>  Lassen Sie uns das System starten und sehen, was mit der Datenbank passiert ist. </p><br><p>  Wir werden feststellen, dass die <code>OrderedQty</code> verschwunden ist und <code>OrderedQty</code> die <code>OrderedQty</code> Tabelle <code>OrderedQty</code> wurde.  Da die OrderLine-Tabelle mit Daten gefüllt ist, werden die Informationen in der OrderedQty-Tabelle außerdem "magisch" aktualisiert, als wäre OrderedQty eine Ansicht. </p><br><p>  Es gibt hier keine Magie, wenn wir uns die Trigger ansehen, die auf der <code>OrderLine</code> Tabelle <code>OrderLine</code> .  Nachdem Celesta die Aufgabe erhalten hatte, eine „materialisierte Ansicht“ zu erstellen, analysierte sie die Abfrage und erstellte Trigger in der <code>OrderLine</code> Tabelle, die <code>OrderLine</code> aktualisieren.  Durch Einfügen eines einzelnen Schlüsselworts - <code>materialized</code> - in die CelestaSQL-Datei haben wir das Problem der Leistungsverschlechterung gelöst, und der Geschäftslogikcode musste nicht einmal geändert werden! </p><br><p> ,    ,   , . «»  Celesta    ,    ,  JOIN-,    GROUP BY.     ,  , ,     ,      . .     . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>       Celesta.     —    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455746/">https://habr.com/ru/post/de455746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455736/index.html">Konsens in Kryptowährungen mit Hybrid- und Multi-PoW-Mining</a></li>
<li><a href="../de455738/index.html">Wie können Sie eine Milliarde verdienen, indem Sie Ihre Daten monetarisieren?</a></li>
<li><a href="../de455740/index.html">Maschinelles Lernen in einer Investmentgesellschaft: Wir klassifizieren technische Supportanrufe</a></li>
<li><a href="../de455742/index.html">Musik machen: Wenn einfache Lösungen das tiefe Lernen übertreffen</a></li>
<li><a href="../de455744/index.html">System zur Erzeugung von Labyrinthlandschaften mit verbessertem visuellen Realismus [Übersetzung des Artikels von Jinmo Kim]</a></li>
<li><a href="../de455754/index.html">Tests eines treibenden Stratostaten. Start von Rogozin und LoRa in die Stratosphäre</a></li>
<li><a href="../de455756/index.html">Ist [Gunst] th</a></li>
<li><a href="../de455758/index.html">Wachstumshacking bei Retail Rocket: Von der Hypothesensuche bis zu Testtechniken</a></li>
<li><a href="../de455760/index.html">Die Magie von SwiftUI oder über Funktionsersteller</a></li>
<li><a href="../de455762/index.html">Eine kurze Einführung in Markov-Ketten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>