<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò∏Ô∏è üôÜüèΩ üë©üèæ‚Äçüè´ Informationen zum Vergleichen von Speicherformaten in Hadoop: Beginnen wir mit ORC ü§¥üèº ü¶ê üìñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hadoop enth√§lt Produkte, die mit Dateien verschiedener Formate arbeiten k√∂nnen. Ich habe wiederholt gesucht, gelesen und dar√ºber nachgedacht, welches ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Informationen zum Vergleichen von Speicherformaten in Hadoop: Beginnen wir mit ORC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfastrah/blog/458552/"><p>  Hadoop enth√§lt Produkte, die mit Dateien verschiedener Formate arbeiten k√∂nnen.  Ich habe wiederholt gesucht, gelesen und dar√ºber nachgedacht, welches Format besser ist.  Als ich relativ zuf√§llig auf das ORC-Format stie√ü, wurde ich interessiert, las (und sogar ein wenig verh√§tschelt), und das habe ich verstanden - es ist falsch, Formate als solche zu vergleichen.  Genauer gesagt werden sie meiner Meinung nach normalerweise falsch verglichen.  Eigentlich ein Artikel dar√ºber sowie √ºber das Apache ORC-Format (in technischer Hinsicht) und die M√∂glichkeiten, die es bietet. </p><br><p>  Ich beginne mit der Frage: Wie gro√ü kann eine relationale Tabelle (in Bytes und sehr ungef√§hr) sein, die aus 10.000 Zeilen besteht (zwei ganzzahlige Felder pro Zeile)?  Normalerweise setzen sie hier ein Kat und die Antwort wird unter das Kat gestellt - ich werde hier antworten: 628 Bytes.  Und die Details und die Geschichte werden unter Katze √ºbertragen. </p><a name="habracut"></a><br><p>  Wie alles begann: Ich habe eine Bibliothek f√ºr die Arbeit mit Apache ORC erstellt (siehe Projekthomepage - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://orc.apache.org</a> ) und ein eigenes Beispiel f√ºr das Schreiben in ORC zusammengestellt (um Ihnen den Kopf zu brechen - wir beginnen mit dem, was funktioniert). Es hatte 2 Felder und 10 Tausend Zeilen.  Ich habe es gestartet - ich habe die Ork-Datei erhalten, weil ich es irgendwo au√üerhalb des B√ºros gemacht habe - f√ºr den Fall, dass ich die Bibliothek und die Datei auf einem Flash-Laufwerk neu geschrieben habe (in Eile - ich habe mir die Gr√∂√üe nicht angesehen, ich denke, das Flash-Laufwerk kann damit umgehen). </p><br><p>  Aber irgendwie habe ich schnell korrespondiert ... Ich habe mir die Gr√∂√üe angesehen - 628 Bytes.  Ich dachte, es sei ein Fehler, setzte mich und begann zu verstehen.  Ich habe das Dienstprogramm zum Anzeigen von ORC aus derselben kompilierten Bibliothek gestartet - der Inhalt der Datei zeigt, dass alles ehrlich ist - zehntausend Zeilen.  Danach fragte ich mich, wie zehntausend Zeilen in 628 Bytes passen k√∂nnten (ich wusste zu diesem Zeitpunkt bereits ein wenig √ºber ORC und stellte fest, dass es auch Metadaten gab - das Format war autark).  Verstanden, teilen. </p><br><h2 id="o-formate-orc">  Informationen zum ORC-Format </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/85d/d6c/e83/85dd6ce839b506e8033b3a6683c0c58c.png" alt="Bild"></p><br><p> Ich werde hier keine allgemeinen Worte √ºber das Format wiederholen - siehe den obigen Link, es ist dort gut geschrieben.  Ich werde mich auf zwei Adjektive in hervorragender Form aus dem obigen Bild konzentrieren (das Bild stammt von der Homepage des Projekts): Versuchen wir herauszufinden, warum ORC ‚Äûdas schnellste‚Äú und ‚Äûdas kompakteste‚Äú ist. </p><br><h1 id="skorost">  Geschwindigkeit </h1><br><p>  Die Geschwindigkeit kann in Bezug auf Daten unterschiedlich sein - zumindest die Geschwindigkeit des Lesens oder Schreibens (Sie k√∂nnen tiefer gehen, aber lassen Sie uns vorerst aufh√∂ren).  Da Hadoop im obigen Slogan ausdr√ºcklich erw√§hnt wird, werden wir in erster Linie die Lesegeschwindigkeit ber√ºcksichtigen. </p><br><p>  Um ein wenig mehr aus der ORC-Dokumentation zu zitieren: </p><br><blockquote>  Es ist f√ºr gro√üe Streaming-Lesevorg√§nge optimiert, bietet jedoch integrierte Unterst√ºtzung f√ºr das schnelle Auffinden der erforderlichen Zeilen.  Durch das Speichern von Daten in einem Spaltenformat kann der Leser nur die Werte lesen, dekomprimieren und verarbeiten, die f√ºr die aktuelle Abfrage erforderlich sind. </blockquote><p>  Ich werde ein wenig √ºbersetzen: </p><br><ul><li>  Format optimiert f√ºr das Streaming beim Lesen gro√üer Volumes </li><li>  enth√§lt gleichzeitig Unterst√ºtzung f√ºr die schnelle Suche nach notwendigen Zeilen </li><li>  Mit dieser Option k√∂nnen Sie nur die Daten lesen, die Sie ben√∂tigen </li></ul><br><h1 id="razmer">  Gr√∂√üe </h1><br><p>  Es gab kein Zitat, werde ich in meinen eigenen Worten sagen </p><br><ul><li>  Format speichert Meta-Informationen optimal </li><li>  ein Gleichgewicht zwischen Streaming-Lesegeschwindigkeit und kompaktem Speicher finden </li><li>  integrierte Unterst√ºtzung f√ºr die kompakteste Speicherung von Spaltenwerten </li></ul><br><h2 id="predostavlenie-vozmozhnostey">  M√∂glichkeiten bieten </h2><br><p>  Ich m√∂chte Ihre Aufmerksamkeit auf den Wortlaut aus den obigen Zitaten lenken: "optimiert f√ºr ...", "enth√§lt Unterst√ºtzung ...", "erm√∂glicht das Lesen ..." - das Dateiformat als Programmiersprache ist ein Mittel (in diesem Fall Bereitstellung) effiziente Speicherung und Zugriff auf Daten).  Ob die Speicherung und der Zugriff auf Daten wirklich effektiv sind, h√§ngt nicht nur vom Tool ab, sondern auch davon, wer sie wie verwendet. </p><br><p>  Mal sehen, welches Format das Format f√ºr Geschwindigkeit und Kompaktheit bietet. </p><br><h1 id="kolonchatoe-hranenie-i-straypy">  S√§ulenlagerung und Streifen </h1><br><p>  Die Daten im ORC werden in Form von Spalten gespeichert, die sich zun√§chst auf die Gr√∂√üe auswirken.  Um die Geschwindigkeit des Streaming-Lesens sicherzustellen, wird die Datei in sogenannte "Streifen" unterteilt, wobei jeder Streifen autark ist, d. H.  kann separat (und daher parallel) gelesen werden.  Aufgrund von Streifen nimmt die Dateigr√∂√üe zu (nicht eindeutige Spaltenwerte werden mehrmals gespeichert - in den Streifen, in denen solche Werte auftreten) - das gleiche Gleichgewicht von "Geschwindigkeit - Gr√∂√üe" (dies ist ein Kompromiss). </p><br><h1 id="indeksy">  Indizes </h1><br><p>  Das ORC-Format impliziert Indizes, mit denen Sie bestimmen k√∂nnen, ob der Streifen (oder vielmehr die Streifenteile von jeweils 10.000 Zeilen, die sogenannte "Zeilengruppe") die gew√ºnschten Daten enth√§lt oder nicht.  Indizes werden f√ºr jede der Spalten erstellt.  Dies wirkt sich auf die Lesegeschwindigkeit aus und vergr√∂√üert die Gr√∂√üe.  Beim Streaming von Leseindizes kann man √ºbrigens nicht lesen. </p><br><h1 id="szhatie">  Komprimierung </h1><br><p>  Alle Metadaten werden in komprimierter Form gespeichert, und dies </p><br><ul><li>  statistische und beschreibende Informationen (das Format erm√∂glicht es Ihnen, die darin gespeicherte Tabelle einschlie√ülich der Namen und Feldtypen neu zu erstellen) </li><li>  Indizes </li><li>  Partitionierung von Informationen (in Streifen und Streams) </li></ul><br><p>  (Unten sehen wir, dass Metadaten ein wesentlicher Bestandteil der Datei sind.) </p><br><p>  Spaltenwerte werden auch in komprimierter Form gespeichert.  Gleichzeitig ist es m√∂glich, nur den ben√∂tigten Datenblock zu lesen und zu entpacken (d. H. Keine Datei wird komprimiert und kein ganzer Streifen).  Die Komprimierung wirkt sich sowohl auf die Gr√∂√üe als auch auf die Lesegeschwindigkeit aus. </p><br><h1 id="kodirovanie">  Codierung </h1><br><p>  Die Spaltenwerte - und die Datei speichert genau diese Werte - werden in codierter Form gespeichert.  In der aktuellen Version des Formats (ORC v1) f√ºr Ganzzahlen stehen beispielsweise 4 Codierungsoptionen zur Verf√ºgung.  Gleichzeitig wird nicht die gesamte Spalte codiert, sondern Teile der Spalte werden codiert. Jeder Teil kann f√ºr diesen Teil optimal codiert werden (solche Teile werden in der Spezifikation als "Ausf√ºhren" bezeichnet).  Somit wird eine Minimierung der Gesamtl√§nge der gespeicherten Daten erreicht.  Wieder die Auswirkung auf Gr√∂√üe und Geschwindigkeit. </p><br><h2 id="posmotrim-orc-fayl">  Sehen wir uns die ORC-Datei an </h2><br><p>  Schauen wir uns ganz kurz an, was sich in der ORC-Datei befindet (die selbst ist 628 Byte).  F√ºr diejenigen, die nicht sehr an technischen Details interessiert sind, scrollen Sie zum n√§chsten Abschnitt (√ºber den Formatvergleich). </p><br><p>  So wurde unsere Tabelle im Beispieldatensatz in ORC definiert: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/af7/bb2/a01/af7bb2a019f050cbc47ec9e2c8152a2b.png" alt="Bild"></p><br><h1 id="metadannye">  Metadaten </h1><br><p>  Informationen zu den L√§ngen (ich gebe Screenshots von Jupyter Notebooks, ich denke es ist klar genug) </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d3e/e1f/398/d3ee1f39809cccf7fc9523df72bb2def.png" alt="Bild"></p><br><p>  Was wir hier sehen: </p><br><ul><li>  im "shank" (und das ist Postscript + Footer + Metadata) nur 1 + 23 + 115 + 50 = 189 Bytes </li><li>  in einem einzelnen Streifen sind nur 3 + 436 = 439 Bytes, insgesamt 628 Bytes </li><li>  Streifen enth√§lt einen Index (73 Bytes), Daten (276 Bytes), Fu√üzeile (87 Bytes) </li></ul><br><p>  Achten wir hier auf das Verh√§ltnis von Datenvolumen und Metadaten (276 zu 352 Bytes).  Diese 276 Datenbytes sind aber auch nicht nur Daten, die Daten enthalten ein bisschen ‚Äû√ºberfl√ºssig‚Äú (der K√ºrze halber gebe ich hier keine Screenshots - es dauert lange, ich werde nur meine Kommentare verwalten), die in den Daten enthalten sind: </p><br><ul><li>  Derzeit sind f√ºr jede Spalte drei Streams vorhanden (einschlie√ülich einer gemeinsamen Pseudospaltenstruktur) - jeweils 20 Bytes, insgesamt 60 Bytes </li><li>  Datenstr√∂me (hier ist die Pseudospalte nicht dargestellt) - 103 und 113 Bytes (Spalten "x" bzw. "y") </li></ul><br><p>  PRESENT-Streams sind Bitfolgen, mit denen Sie wissen, wo die Spalten NULL sind.  In unserem Beispiel sieht ihre Anwesenheit seltsam aus (in der Statistik unserer Datei steht eindeutig, dass die Daten keine NULL-Werte enthalten - warum dann PRESENT einschlie√üen? Es scheint ein Fehler zu sein ...) </p><br><p>  Insgesamt belegen die Daten selbst 216 Bytes, Metadaten - 352. </p><br><p>  Aus den Metadaten ist auch ersichtlich, dass beide Spalten mit der DIRECT_V2-Methode codiert sind (f√ºr Ganzzahlen sind 4 Arten von Darstellungen zul√§ssig, Einzelheiten finden Sie in der Spezifikation - auf der Projektwebsite). </p><br><h1 id="dannye">  Daten </h1><br><p>  Mal sehen (der K√ºrze halber ohne Screenshots), wie zehntausend Zahlen in 103 Bytes passen (f√ºr die Spalte "x"): </p><br><ul><li>  Es wird eine Delta-Codierung verwendet, bei der die Parameter der Anfangswert und der Schritt sind (der K√ºrze halber etwas vereinfacht). </li><li>  Wir haben immer 1 Schritt, der Anfangswert f√ºr den ersten Lauf ist 0, dann 511, 1022 usw. </li><li>  run (ein auf eine Weise codierter Datensatz) enth√§lt in unserem Fall 511 Werte (der maximal m√∂gliche Wert f√ºr die Delta-Codierung). </li><li>  Die L√§nge jedes Laufs in der Datei betr√§gt 4 bis 6 Byte (die L√§nge des Laufs nimmt zu, da der Anfangswert im Zickzack dargestellt wird). </li><li>  Insgesamt f√ºr die Spalte "x" erhalten wir in der Datei 20 Run-s mit einer Gesamtl√§nge von 103 Bytes (ich habe gepr√ºft - alles passt zusammen) </li></ul><br><p>  Zum Abschluss der √úberpr√ºfung der Darstellung unserer einfachen Tabelle in einer Datei m√∂chte ich sagen, dass die Indizes in diesem Beispiel entartet sind - sie zeigen den Beginn des Datenstroms an.  Ich werde mich anhand von Beispielen aus der Praxis mit Indizes befassen und sie wahrscheinlich in einem separaten Artikel beschreiben. </p><br><p>  F√ºr Interessierte: Unter dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> finden Sie ein Jupyter-Notizbuch, in dem ich das Format Interna "verstanden" habe.  Sie k√∂nnen es verwenden und wiederholen (dort ist auch die ORC-Datei angeh√§ngt). </p><br><p>  Ich bin sicher, dass viele Leser "verloren" sind - ja, das ORC-Format ist nicht einfach (sowohl hinsichtlich des Verst√§ndnisses der Details als auch hinsichtlich der Verwendung der bereitgestellten Funktionen). </p><br><h2 id="o-sravnenii-formatov">  √úber den Formatvergleich </h2><br><p>  Kommen wir nun zum Hauptpunkt - dem falschen Formatvergleich. </p><br><p>  Wie oft werden die Formate verglichen: Vergleichen wir die Gr√∂√üe der Dateien im Format A und B, die Lesegeschwindigkeit (verschiedene Arten des Lesens - zuf√§llig, Streaming usw.) im Format A und B. Vergleichen Sie, dass Format A besser ist als Format B. </p><br><p>  Am Beispiel des letzten der oben aufgef√ºhrten Kompaktheitstools (Codierungswerkzeuge): K√∂nnen die Daten im ORC optimal codiert werden?  Ja, es gibt M√∂glichkeiten - siehe oben.  Aber genauso gut kann man das nicht!  Dies h√§ngt vom ‚ÄûWriter‚Äú ab (Writer in ORC-Terminologie): Im obigen Beispiel k√∂nnte der Writer dies tun.  Aber er k√∂nnte einfach 2 Mal in zehntausend Zahlen aufschreiben und dies w√§re auch in Bezug auf das Format korrekt.  <strong>Beim Vergleich von Formaten "nach Gr√∂√üe" vergleichen wir nicht nur und nicht so sehr die Formate als vielmehr die algorithmische Qualit√§t von Anwendungssystemen, die diese Formate verwenden</strong> . </p><br><p>  Wer ist der "Schriftsteller" in Hadoop?  Es gibt viele davon - zum Beispiel Hive, das eine Tabelle erstellt, in der die Daten in Dateien im ORC-Format gespeichert werden.  Wenn wir beispielsweise ORC mit Parquet in Hadoop vergleichen, bewerten wir tats√§chlich die Qualit√§t der Implementierung des in Hive implementierten Datenkonvertierungsalgorithmus.  Wir vergleichen keine Formate (als solche). </p><br><p>  <strong>Wichtiges Merkmal von Hadoop</strong> </p><br><p>  In der klassischen relationalen Welt hatten wir keine M√∂glichkeit, die Gr√∂√üe der Tabelle in Oracle zu beeinflussen - sie wurde irgendwie gespeichert und nur Oracle wusste wie.  In Hadoop ist die Situation etwas anders: Wir k√∂nnen sehen, wie diese oder jene Tabelle gespeichert ist (wie gut Hive es beispielsweise geschafft hat, sie zu ‚Äûcodieren‚Äú).  Und wenn wir sehen, dass dies verbessert werden kann, haben wir eine echte Chance daf√ºr: unsere eigene optimalere ORC-Datei zu erstellen und sie Hive als externe Tabelle zu geben. </p><br><h2 id="sravnim-orc-i-qvd">  Vergleichen Sie ORC und QVD </h2><br><p>  Ich habe k√ºrzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das QVD-Format beschrieben</a> , das QlikVew / QlikSense aktiv verwendet.  Lassen Sie uns diese beiden Formate kurz anhand der Funktionen veranschaulichen, die sie bieten, um eine maximale Lesegeschwindigkeit zu erreichen und die Gr√∂√üe zu minimieren.  Die Funktionen von ORC sind oben wie in QVD beschrieben: </p><br><h1 id="kolonchatoe-hranenie">  Spaltenspeicherung </h1><br><p>  QVD kann als "Spaltenformat" betrachtet werden, es gibt keine Duplizierung von Spaltenwerten - eindeutige Werte werden einmal gespeichert.  ABER es erlaubt keine parallele Verarbeitung - zuerst m√ºssen Sie die Werte aller Spalten vollst√§ndig lesen, dann k√∂nnen Sie Zeilen parallel lesen. </p><br><p>  Und es gibt Duplikate auf Zeilenebene - Zeilen speichern doppelte Indexwerte in einer Zeichentabelle. </p><br><h1 id="szhatie-1">  Komprimierung </h1><br><p>  Ich bin nicht auf komprimierte QVD-Dateien gesto√üen - es ist mir nicht gelungen - es gibt ein solches Tag in den Metadaten, m√∂glicherweise kann jeder der Teile, f√ºr die es einen Versatz und eine L√§nge in den Metadaten gibt (und dies ist jede Zeichentabelle und die gesamte Zeichenfolgentabelle), komprimiert werden.  In diesem Fall ist ein paralleles Lesen der Zeilen "Auf Wiedersehen" ... </p><br><h1 id="indeksy-1">  Indizes </h1><br><p>  In der QVD-Datei kann nicht verstanden werden, welcher Teil davon gelesen werden muss.  In der Praxis m√ºssen Sie die Zeichentabelle byteweise analysieren (jeweils!). Dies ist kein sehr effizienter Weg ... </p><br><h1 id="kodirovanie-1">  Codierung </h1><br><p>  Die Codierung in QVD wird nicht verwendet. Es ist m√∂glich, eine Analogie des Bitindex in einer Tabelle von Zeichenfolgen mit Codierung zu zeichnen. Diese Analogie wird jedoch durch Duplizieren von Zahlen durch Zeichenfolgen in Zeichentabellen ‚Äûkompensiert‚Äú (Einzelheiten siehe Artikel kurz - der Spaltenwert wird h√§ufig durch die Zahl UND die Zeichenfolge dargestellt). </p><br><p>  Die Schlussfolgerung zu diesem kurzen Vergleich habe ich pers√∂nlich gezogen: Das QVD-Format enth√§lt praktisch nicht die M√∂glichkeit, die in Dateien dieses Formats enthaltenen Daten kompakt zu speichern und schnell zu lesen. </p><br><p>  (Es klang f√ºr QVD irgendwie anst√∂√üig, ich m√∂chte ein wenig hinzuf√ºgen - das Format wurde vor langer Zeit erstellt, nur QlikView / QlikSense wird verwendet und sie "speichern" alle Daten im Speicher. Ich denke, dass die QVD-Datei einfach alle "wie sie ist" im Speicher gelesen wird. und dann arbeiten diese in jeder Hinsicht wunderbaren BI-Produkte sehr schnell mit dieser Pr√§sentation - hier sind sie Meister ...) </p><br><h2 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h2><br><p>  Er kritisierte und hat noch nichts angeboten ... - schlage ich vor. </p><br><p>  Es scheint mir, dass Formate nicht am Beispiel ihrer spezifischen Implementierung verglichen werden m√ºssen, sondern dass Formate im Hinblick auf die darin enthaltenen Tools und die F√§higkeit, diese Tools zur L√∂sung unserer spezifischen Probleme zu verwenden, verglichen werden m√ºssen.  Die Geschwindigkeit der Prozessoren nimmt st√§ndig zu. Jetzt k√∂nnen wir uns fast alle Datenkonvertierungsalgorithmen leisten, nachdem sie gelesen wurden. Das Lesen von der Festplatte ist ohnehin langsamer.  Deshalb sind die "Ausdrucksmittel" der Formate wichtig. </p><br><p>  Oben habe ich meiner Meinung nach kurz interessante M√∂glichkeiten des ORC-Formats aufgelistet.  Ich habe immer noch keine Statistiken dar√ºber, wie die Dinge in der Praxis sind (welche dieser Funktionen und in welchem ‚Äã‚ÄãUmfang werden sie beispielsweise von Hive verwendet).  Wenn es erscheint - werde ich schreiben.  Die unmittelbaren Pl√§ne sehen eine √§hnliche √úberpr√ºfung eines anderen beliebten Speicherformats vor - Parkett. </p><br><p>  Nun - und abschlie√üend - in der modernen Welt gibt es viele Informationen, leider ist ein Teil dieser Informationen zu oberfl√§chlich.  Wir werden nicht nachgeben, wir werden die Essenz betrachten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458552/">https://habr.com/ru/post/de458552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458532/index.html">Pioniere neuer Technologien: Vadim Artsev erz√§hlte, wie er aufh√∂rte, blind zu sein</a></li>
<li><a href="../de458536/index.html">Python + Pyside2 oder einfach "Rechner"</a></li>
<li><a href="../de458546/index.html">Automation Day oder wie wir die Ebene der Autotests aufbauen</a></li>
<li><a href="../de458548/index.html">Erstellen Sie mit Dynamic Proxy und Spring IoC Ihre eigene Spring Data Repository-Stilbibliothek</a></li>
<li><a href="../de458550/index.html">Symbole GOST-Bibliothek f√ºr DipTrace</a></li>
<li><a href="../de458556/index.html">Entwickeln Sie die Chrome-Erweiterung mit Angular CLI</a></li>
<li><a href="../de458558/index.html">Pr√§sentationen mit Magento Meetup Kharkiv - Videos und Pr√§sentationen</a></li>
<li><a href="../de458560/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 12. Erweitertes VLAN</a></li>
<li><a href="../de458564/index.html">Gruben auf dem Weg zum Programmierer</a></li>
<li><a href="../de458566/index.html">Wie haben wir einen UX-Designer mit lebenden K√∂dern gefangen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>