<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☸️ 🙆🏽 👩🏾‍🏫 Informationen zum Vergleichen von Speicherformaten in Hadoop: Beginnen wir mit ORC 🤴🏼 🦐 📖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hadoop enthält Produkte, die mit Dateien verschiedener Formate arbeiten können. Ich habe wiederholt gesucht, gelesen und darüber nachgedacht, welches ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Informationen zum Vergleichen von Speicherformaten in Hadoop: Beginnen wir mit ORC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfastrah/blog/458552/"><p>  Hadoop enthält Produkte, die mit Dateien verschiedener Formate arbeiten können.  Ich habe wiederholt gesucht, gelesen und darüber nachgedacht, welches Format besser ist.  Als ich relativ zufällig auf das ORC-Format stieß, wurde ich interessiert, las (und sogar ein wenig verhätschelt), und das habe ich verstanden - es ist falsch, Formate als solche zu vergleichen.  Genauer gesagt werden sie meiner Meinung nach normalerweise falsch verglichen.  Eigentlich ein Artikel darüber sowie über das Apache ORC-Format (in technischer Hinsicht) und die Möglichkeiten, die es bietet. </p><br><p>  Ich beginne mit der Frage: Wie groß kann eine relationale Tabelle (in Bytes und sehr ungefähr) sein, die aus 10.000 Zeilen besteht (zwei ganzzahlige Felder pro Zeile)?  Normalerweise setzen sie hier ein Kat und die Antwort wird unter das Kat gestellt - ich werde hier antworten: 628 Bytes.  Und die Details und die Geschichte werden unter Katze übertragen. </p><a name="habracut"></a><br><p>  Wie alles begann: Ich habe eine Bibliothek für die Arbeit mit Apache ORC erstellt (siehe Projekthomepage - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://orc.apache.org</a> ) und ein eigenes Beispiel für das Schreiben in ORC zusammengestellt (um Ihnen den Kopf zu brechen - wir beginnen mit dem, was funktioniert). Es hatte 2 Felder und 10 Tausend Zeilen.  Ich habe es gestartet - ich habe die Ork-Datei erhalten, weil ich es irgendwo außerhalb des Büros gemacht habe - für den Fall, dass ich die Bibliothek und die Datei auf einem Flash-Laufwerk neu geschrieben habe (in Eile - ich habe mir die Größe nicht angesehen, ich denke, das Flash-Laufwerk kann damit umgehen). </p><br><p>  Aber irgendwie habe ich schnell korrespondiert ... Ich habe mir die Größe angesehen - 628 Bytes.  Ich dachte, es sei ein Fehler, setzte mich und begann zu verstehen.  Ich habe das Dienstprogramm zum Anzeigen von ORC aus derselben kompilierten Bibliothek gestartet - der Inhalt der Datei zeigt, dass alles ehrlich ist - zehntausend Zeilen.  Danach fragte ich mich, wie zehntausend Zeilen in 628 Bytes passen könnten (ich wusste zu diesem Zeitpunkt bereits ein wenig über ORC und stellte fest, dass es auch Metadaten gab - das Format war autark).  Verstanden, teilen. </p><br><h2 id="o-formate-orc">  Informationen zum ORC-Format </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/85d/d6c/e83/85dd6ce839b506e8033b3a6683c0c58c.png" alt="Bild"></p><br><p> Ich werde hier keine allgemeinen Worte über das Format wiederholen - siehe den obigen Link, es ist dort gut geschrieben.  Ich werde mich auf zwei Adjektive in hervorragender Form aus dem obigen Bild konzentrieren (das Bild stammt von der Homepage des Projekts): Versuchen wir herauszufinden, warum ORC „das schnellste“ und „das kompakteste“ ist. </p><br><h1 id="skorost">  Geschwindigkeit </h1><br><p>  Die Geschwindigkeit kann in Bezug auf Daten unterschiedlich sein - zumindest die Geschwindigkeit des Lesens oder Schreibens (Sie können tiefer gehen, aber lassen Sie uns vorerst aufhören).  Da Hadoop im obigen Slogan ausdrücklich erwähnt wird, werden wir in erster Linie die Lesegeschwindigkeit berücksichtigen. </p><br><p>  Um ein wenig mehr aus der ORC-Dokumentation zu zitieren: </p><br><blockquote>  Es ist für große Streaming-Lesevorgänge optimiert, bietet jedoch integrierte Unterstützung für das schnelle Auffinden der erforderlichen Zeilen.  Durch das Speichern von Daten in einem Spaltenformat kann der Leser nur die Werte lesen, dekomprimieren und verarbeiten, die für die aktuelle Abfrage erforderlich sind. </blockquote><p>  Ich werde ein wenig übersetzen: </p><br><ul><li>  Format optimiert für das Streaming beim Lesen großer Volumes </li><li>  enthält gleichzeitig Unterstützung für die schnelle Suche nach notwendigen Zeilen </li><li>  Mit dieser Option können Sie nur die Daten lesen, die Sie benötigen </li></ul><br><h1 id="razmer">  Größe </h1><br><p>  Es gab kein Zitat, werde ich in meinen eigenen Worten sagen </p><br><ul><li>  Format speichert Meta-Informationen optimal </li><li>  ein Gleichgewicht zwischen Streaming-Lesegeschwindigkeit und kompaktem Speicher finden </li><li>  integrierte Unterstützung für die kompakteste Speicherung von Spaltenwerten </li></ul><br><h2 id="predostavlenie-vozmozhnostey">  Möglichkeiten bieten </h2><br><p>  Ich möchte Ihre Aufmerksamkeit auf den Wortlaut aus den obigen Zitaten lenken: "optimiert für ...", "enthält Unterstützung ...", "ermöglicht das Lesen ..." - das Dateiformat als Programmiersprache ist ein Mittel (in diesem Fall Bereitstellung) effiziente Speicherung und Zugriff auf Daten).  Ob die Speicherung und der Zugriff auf Daten wirklich effektiv sind, hängt nicht nur vom Tool ab, sondern auch davon, wer sie wie verwendet. </p><br><p>  Mal sehen, welches Format das Format für Geschwindigkeit und Kompaktheit bietet. </p><br><h1 id="kolonchatoe-hranenie-i-straypy">  Säulenlagerung und Streifen </h1><br><p>  Die Daten im ORC werden in Form von Spalten gespeichert, die sich zunächst auf die Größe auswirken.  Um die Geschwindigkeit des Streaming-Lesens sicherzustellen, wird die Datei in sogenannte "Streifen" unterteilt, wobei jeder Streifen autark ist, d. H.  kann separat (und daher parallel) gelesen werden.  Aufgrund von Streifen nimmt die Dateigröße zu (nicht eindeutige Spaltenwerte werden mehrmals gespeichert - in den Streifen, in denen solche Werte auftreten) - das gleiche Gleichgewicht von "Geschwindigkeit - Größe" (dies ist ein Kompromiss). </p><br><h1 id="indeksy">  Indizes </h1><br><p>  Das ORC-Format impliziert Indizes, mit denen Sie bestimmen können, ob der Streifen (oder vielmehr die Streifenteile von jeweils 10.000 Zeilen, die sogenannte "Zeilengruppe") die gewünschten Daten enthält oder nicht.  Indizes werden für jede der Spalten erstellt.  Dies wirkt sich auf die Lesegeschwindigkeit aus und vergrößert die Größe.  Beim Streaming von Leseindizes kann man übrigens nicht lesen. </p><br><h1 id="szhatie">  Komprimierung </h1><br><p>  Alle Metadaten werden in komprimierter Form gespeichert, und dies </p><br><ul><li>  statistische und beschreibende Informationen (das Format ermöglicht es Ihnen, die darin gespeicherte Tabelle einschließlich der Namen und Feldtypen neu zu erstellen) </li><li>  Indizes </li><li>  Partitionierung von Informationen (in Streifen und Streams) </li></ul><br><p>  (Unten sehen wir, dass Metadaten ein wesentlicher Bestandteil der Datei sind.) </p><br><p>  Spaltenwerte werden auch in komprimierter Form gespeichert.  Gleichzeitig ist es möglich, nur den benötigten Datenblock zu lesen und zu entpacken (d. H. Keine Datei wird komprimiert und kein ganzer Streifen).  Die Komprimierung wirkt sich sowohl auf die Größe als auch auf die Lesegeschwindigkeit aus. </p><br><h1 id="kodirovanie">  Codierung </h1><br><p>  Die Spaltenwerte - und die Datei speichert genau diese Werte - werden in codierter Form gespeichert.  In der aktuellen Version des Formats (ORC v1) für Ganzzahlen stehen beispielsweise 4 Codierungsoptionen zur Verfügung.  Gleichzeitig wird nicht die gesamte Spalte codiert, sondern Teile der Spalte werden codiert. Jeder Teil kann für diesen Teil optimal codiert werden (solche Teile werden in der Spezifikation als "Ausführen" bezeichnet).  Somit wird eine Minimierung der Gesamtlänge der gespeicherten Daten erreicht.  Wieder die Auswirkung auf Größe und Geschwindigkeit. </p><br><h2 id="posmotrim-orc-fayl">  Sehen wir uns die ORC-Datei an </h2><br><p>  Schauen wir uns ganz kurz an, was sich in der ORC-Datei befindet (die selbst ist 628 Byte).  Für diejenigen, die nicht sehr an technischen Details interessiert sind, scrollen Sie zum nächsten Abschnitt (über den Formatvergleich). </p><br><p>  So wurde unsere Tabelle im Beispieldatensatz in ORC definiert: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/af7/bb2/a01/af7bb2a019f050cbc47ec9e2c8152a2b.png" alt="Bild"></p><br><h1 id="metadannye">  Metadaten </h1><br><p>  Informationen zu den Längen (ich gebe Screenshots von Jupyter Notebooks, ich denke es ist klar genug) </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d3e/e1f/398/d3ee1f39809cccf7fc9523df72bb2def.png" alt="Bild"></p><br><p>  Was wir hier sehen: </p><br><ul><li>  im "shank" (und das ist Postscript + Footer + Metadata) nur 1 + 23 + 115 + 50 = 189 Bytes </li><li>  in einem einzelnen Streifen sind nur 3 + 436 = 439 Bytes, insgesamt 628 Bytes </li><li>  Streifen enthält einen Index (73 Bytes), Daten (276 Bytes), Fußzeile (87 Bytes) </li></ul><br><p>  Achten wir hier auf das Verhältnis von Datenvolumen und Metadaten (276 zu 352 Bytes).  Diese 276 Datenbytes sind aber auch nicht nur Daten, die Daten enthalten ein bisschen „überflüssig“ (der Kürze halber gebe ich hier keine Screenshots - es dauert lange, ich werde nur meine Kommentare verwalten), die in den Daten enthalten sind: </p><br><ul><li>  Derzeit sind für jede Spalte drei Streams vorhanden (einschließlich einer gemeinsamen Pseudospaltenstruktur) - jeweils 20 Bytes, insgesamt 60 Bytes </li><li>  Datenströme (hier ist die Pseudospalte nicht dargestellt) - 103 und 113 Bytes (Spalten "x" bzw. "y") </li></ul><br><p>  PRESENT-Streams sind Bitfolgen, mit denen Sie wissen, wo die Spalten NULL sind.  In unserem Beispiel sieht ihre Anwesenheit seltsam aus (in der Statistik unserer Datei steht eindeutig, dass die Daten keine NULL-Werte enthalten - warum dann PRESENT einschließen? Es scheint ein Fehler zu sein ...) </p><br><p>  Insgesamt belegen die Daten selbst 216 Bytes, Metadaten - 352. </p><br><p>  Aus den Metadaten ist auch ersichtlich, dass beide Spalten mit der DIRECT_V2-Methode codiert sind (für Ganzzahlen sind 4 Arten von Darstellungen zulässig, Einzelheiten finden Sie in der Spezifikation - auf der Projektwebsite). </p><br><h1 id="dannye">  Daten </h1><br><p>  Mal sehen (der Kürze halber ohne Screenshots), wie zehntausend Zahlen in 103 Bytes passen (für die Spalte "x"): </p><br><ul><li>  Es wird eine Delta-Codierung verwendet, bei der die Parameter der Anfangswert und der Schritt sind (der Kürze halber etwas vereinfacht). </li><li>  Wir haben immer 1 Schritt, der Anfangswert für den ersten Lauf ist 0, dann 511, 1022 usw. </li><li>  run (ein auf eine Weise codierter Datensatz) enthält in unserem Fall 511 Werte (der maximal mögliche Wert für die Delta-Codierung). </li><li>  Die Länge jedes Laufs in der Datei beträgt 4 bis 6 Byte (die Länge des Laufs nimmt zu, da der Anfangswert im Zickzack dargestellt wird). </li><li>  Insgesamt für die Spalte "x" erhalten wir in der Datei 20 Run-s mit einer Gesamtlänge von 103 Bytes (ich habe geprüft - alles passt zusammen) </li></ul><br><p>  Zum Abschluss der Überprüfung der Darstellung unserer einfachen Tabelle in einer Datei möchte ich sagen, dass die Indizes in diesem Beispiel entartet sind - sie zeigen den Beginn des Datenstroms an.  Ich werde mich anhand von Beispielen aus der Praxis mit Indizes befassen und sie wahrscheinlich in einem separaten Artikel beschreiben. </p><br><p>  Für Interessierte: Unter dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> finden Sie ein Jupyter-Notizbuch, in dem ich das Format Interna "verstanden" habe.  Sie können es verwenden und wiederholen (dort ist auch die ORC-Datei angehängt). </p><br><p>  Ich bin sicher, dass viele Leser "verloren" sind - ja, das ORC-Format ist nicht einfach (sowohl hinsichtlich des Verständnisses der Details als auch hinsichtlich der Verwendung der bereitgestellten Funktionen). </p><br><h2 id="o-sravnenii-formatov">  Über den Formatvergleich </h2><br><p>  Kommen wir nun zum Hauptpunkt - dem falschen Formatvergleich. </p><br><p>  Wie oft werden die Formate verglichen: Vergleichen wir die Größe der Dateien im Format A und B, die Lesegeschwindigkeit (verschiedene Arten des Lesens - zufällig, Streaming usw.) im Format A und B. Vergleichen Sie, dass Format A besser ist als Format B. </p><br><p>  Am Beispiel des letzten der oben aufgeführten Kompaktheitstools (Codierungswerkzeuge): Können die Daten im ORC optimal codiert werden?  Ja, es gibt Möglichkeiten - siehe oben.  Aber genauso gut kann man das nicht!  Dies hängt vom „Writer“ ab (Writer in ORC-Terminologie): Im obigen Beispiel könnte der Writer dies tun.  Aber er könnte einfach 2 Mal in zehntausend Zahlen aufschreiben und dies wäre auch in Bezug auf das Format korrekt.  <strong>Beim Vergleich von Formaten "nach Größe" vergleichen wir nicht nur und nicht so sehr die Formate als vielmehr die algorithmische Qualität von Anwendungssystemen, die diese Formate verwenden</strong> . </p><br><p>  Wer ist der "Schriftsteller" in Hadoop?  Es gibt viele davon - zum Beispiel Hive, das eine Tabelle erstellt, in der die Daten in Dateien im ORC-Format gespeichert werden.  Wenn wir beispielsweise ORC mit Parquet in Hadoop vergleichen, bewerten wir tatsächlich die Qualität der Implementierung des in Hive implementierten Datenkonvertierungsalgorithmus.  Wir vergleichen keine Formate (als solche). </p><br><p>  <strong>Wichtiges Merkmal von Hadoop</strong> </p><br><p>  In der klassischen relationalen Welt hatten wir keine Möglichkeit, die Größe der Tabelle in Oracle zu beeinflussen - sie wurde irgendwie gespeichert und nur Oracle wusste wie.  In Hadoop ist die Situation etwas anders: Wir können sehen, wie diese oder jene Tabelle gespeichert ist (wie gut Hive es beispielsweise geschafft hat, sie zu „codieren“).  Und wenn wir sehen, dass dies verbessert werden kann, haben wir eine echte Chance dafür: unsere eigene optimalere ORC-Datei zu erstellen und sie Hive als externe Tabelle zu geben. </p><br><h2 id="sravnim-orc-i-qvd">  Vergleichen Sie ORC und QVD </h2><br><p>  Ich habe kürzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das QVD-Format beschrieben</a> , das QlikVew / QlikSense aktiv verwendet.  Lassen Sie uns diese beiden Formate kurz anhand der Funktionen veranschaulichen, die sie bieten, um eine maximale Lesegeschwindigkeit zu erreichen und die Größe zu minimieren.  Die Funktionen von ORC sind oben wie in QVD beschrieben: </p><br><h1 id="kolonchatoe-hranenie">  Spaltenspeicherung </h1><br><p>  QVD kann als "Spaltenformat" betrachtet werden, es gibt keine Duplizierung von Spaltenwerten - eindeutige Werte werden einmal gespeichert.  ABER es erlaubt keine parallele Verarbeitung - zuerst müssen Sie die Werte aller Spalten vollständig lesen, dann können Sie Zeilen parallel lesen. </p><br><p>  Und es gibt Duplikate auf Zeilenebene - Zeilen speichern doppelte Indexwerte in einer Zeichentabelle. </p><br><h1 id="szhatie-1">  Komprimierung </h1><br><p>  Ich bin nicht auf komprimierte QVD-Dateien gestoßen - es ist mir nicht gelungen - es gibt ein solches Tag in den Metadaten, möglicherweise kann jeder der Teile, für die es einen Versatz und eine Länge in den Metadaten gibt (und dies ist jede Zeichentabelle und die gesamte Zeichenfolgentabelle), komprimiert werden.  In diesem Fall ist ein paralleles Lesen der Zeilen "Auf Wiedersehen" ... </p><br><h1 id="indeksy-1">  Indizes </h1><br><p>  In der QVD-Datei kann nicht verstanden werden, welcher Teil davon gelesen werden muss.  In der Praxis müssen Sie die Zeichentabelle byteweise analysieren (jeweils!). Dies ist kein sehr effizienter Weg ... </p><br><h1 id="kodirovanie-1">  Codierung </h1><br><p>  Die Codierung in QVD wird nicht verwendet. Es ist möglich, eine Analogie des Bitindex in einer Tabelle von Zeichenfolgen mit Codierung zu zeichnen. Diese Analogie wird jedoch durch Duplizieren von Zahlen durch Zeichenfolgen in Zeichentabellen „kompensiert“ (Einzelheiten siehe Artikel kurz - der Spaltenwert wird häufig durch die Zahl UND die Zeichenfolge dargestellt). </p><br><p>  Die Schlussfolgerung zu diesem kurzen Vergleich habe ich persönlich gezogen: Das QVD-Format enthält praktisch nicht die Möglichkeit, die in Dateien dieses Formats enthaltenen Daten kompakt zu speichern und schnell zu lesen. </p><br><p>  (Es klang für QVD irgendwie anstößig, ich möchte ein wenig hinzufügen - das Format wurde vor langer Zeit erstellt, nur QlikView / QlikSense wird verwendet und sie "speichern" alle Daten im Speicher. Ich denke, dass die QVD-Datei einfach alle "wie sie ist" im Speicher gelesen wird. und dann arbeiten diese in jeder Hinsicht wunderbaren BI-Produkte sehr schnell mit dieser Präsentation - hier sind sie Meister ...) </p><br><h2 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h2><br><p>  Er kritisierte und hat noch nichts angeboten ... - schlage ich vor. </p><br><p>  Es scheint mir, dass Formate nicht am Beispiel ihrer spezifischen Implementierung verglichen werden müssen, sondern dass Formate im Hinblick auf die darin enthaltenen Tools und die Fähigkeit, diese Tools zur Lösung unserer spezifischen Probleme zu verwenden, verglichen werden müssen.  Die Geschwindigkeit der Prozessoren nimmt ständig zu. Jetzt können wir uns fast alle Datenkonvertierungsalgorithmen leisten, nachdem sie gelesen wurden. Das Lesen von der Festplatte ist ohnehin langsamer.  Deshalb sind die "Ausdrucksmittel" der Formate wichtig. </p><br><p>  Oben habe ich meiner Meinung nach kurz interessante Möglichkeiten des ORC-Formats aufgelistet.  Ich habe immer noch keine Statistiken darüber, wie die Dinge in der Praxis sind (welche dieser Funktionen und in welchem ​​Umfang werden sie beispielsweise von Hive verwendet).  Wenn es erscheint - werde ich schreiben.  Die unmittelbaren Pläne sehen eine ähnliche Überprüfung eines anderen beliebten Speicherformats vor - Parkett. </p><br><p>  Nun - und abschließend - in der modernen Welt gibt es viele Informationen, leider ist ein Teil dieser Informationen zu oberflächlich.  Wir werden nicht nachgeben, wir werden die Essenz betrachten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458552/">https://habr.com/ru/post/de458552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458532/index.html">Pioniere neuer Technologien: Vadim Artsev erzählte, wie er aufhörte, blind zu sein</a></li>
<li><a href="../de458536/index.html">Python + Pyside2 oder einfach "Rechner"</a></li>
<li><a href="../de458546/index.html">Automation Day oder wie wir die Ebene der Autotests aufbauen</a></li>
<li><a href="../de458548/index.html">Erstellen Sie mit Dynamic Proxy und Spring IoC Ihre eigene Spring Data Repository-Stilbibliothek</a></li>
<li><a href="../de458550/index.html">Symbole GOST-Bibliothek für DipTrace</a></li>
<li><a href="../de458556/index.html">Entwickeln Sie die Chrome-Erweiterung mit Angular CLI</a></li>
<li><a href="../de458558/index.html">Präsentationen mit Magento Meetup Kharkiv - Videos und Präsentationen</a></li>
<li><a href="../de458560/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 12. Erweitertes VLAN</a></li>
<li><a href="../de458564/index.html">Gruben auf dem Weg zum Programmierer</a></li>
<li><a href="../de458566/index.html">Wie haben wir einen UX-Designer mit lebenden Ködern gefangen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>