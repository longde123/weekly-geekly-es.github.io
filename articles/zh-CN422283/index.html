<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏯 🤳🏼 🗾 白盒测试 🎦 👨‍🚒 🧒🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="高质量程序的开发意味着该程序及其各个部分都经过了测试。 经典的单元测试涉及将大型程序分解为便于测试的小块。 或者，如果测试的开发与代码的开发并行进行，或者测试是在程序之前进行的（TDD-测试驱动的开发），那么程序最初是按照适合测试要求的小块形式开发的。 


 单元测试的种类之一可以认为是基于属性的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>白盒测试</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422283/"><p> 高质量程序的开发意味着该程序及其各个部分都经过了测试。 经典的单元测试涉及将大型程序分解为便于测试的小块。 或者，如果测试的开发与代码的开发并行进行，或者测试是在程序之前进行的（TDD-测试驱动的开发），那么程序最初是按照适合测试要求的小块形式开发的。 </p><br><p> 单元测试的种类之一可以认为是基于属性的测试（例如，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">QuickCheck和ScalaCheck库中</a>实现了这种方法）。 该方法基于查找对于任何输入数据都应有效的通用属性。 例如， <em>序列化后反序列化应产生相同的对象</em> 。 或者， <em>重新排序不应更改列表中项目的顺序</em> 。 为了验证这种通用属性，上述库支持一种用于生成随机输入数据的机制。 这种方法对于基于数学定律的程序特别有效，这些定律可用作适用于各种程序的通用属性。 甚至还有一个现成的数学属性库- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">学科</a> -可让您在新程序中检查这些属性的性能（重用测试的一个很好的例子）。 </p><br><p> 有时，事实证明，必须测试复杂的程序而不将其解析为可独立验证的部分。 在这种情况下，测试程序是 <del> 黑色的 </del> 白色框（白色-因为我们有机会研究程序的内部结构）。 </p><br><p> 在切口下，描述了几种测试复杂程序的方法，这些复杂程序的一个输入具有不同程度的复杂性（参与度）和不同程度的覆盖率。 </p><a name="habracut"></a><br><p>  * <em>在本文中，我们假设被测程序可以表示为没有内部状态的纯函数。</em>  <em>（如果存在内部状态，则可以应用下面给出的一些注意事项，但是可以将此状态重置为固定值。）</em> </p><br><h3 id="testovyy-stend-test-bench"> 试验台 </h3><br><p>首先，由于仅测试了一个函数，其调用代码始终相同，因此我们无需创建单独的单元测试。 所有这些测试都是相同的，对于输入和检查都是准确的。 循环传输源数据（ <code>input</code> ）并检查结果（ <code>expectedOutput</code> ）就足够了。 为了在检测到错误的情况下识别出测试数据的问题集，必须标记所有测试数据。 因此，一组测试数据可以表示为三元组： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expectedOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> 一次运行的结果可以表示为<code>TestCaseResult</code> ： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseResult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">testCase: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TestCase</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">], actualOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Try</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  （我们使用“ <code>Try</code>捕获可能的异常”来显示启动的结果。） </p><br><p> 为了简化通过被测程序的所有测试数据的运行，可以使用一个辅助函数，该函数将为每个输入值调用该程序： </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCases</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](cases: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCase</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]] = cases .map{ testCase =&gt; <span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>(testCase, <span class="hljs-type"><span class="hljs-type">Try</span></span>{ f(testCase.input) } ) } .filter(r =&gt; r.actualOutput != <span class="hljs-type"><span class="hljs-type">Success</span></span>(r.testCase.expectedOutput))</code> </pre> <br><p> 此辅助函数将返回有问题的数据和结果与预期不同。 </p><br><p> 为方便起见，您可以格式化测试结果。 </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span></span>(results: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[_, _]]): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"Failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${results.length}</span></span></span><span class="hljs-string">:\n"</span></span> + results .map(r =&gt; r.testCase.label + <span class="hljs-string"><span class="hljs-string">": expected "</span></span> + r.testCase.expectedOutput + <span class="hljs-string"><span class="hljs-string">", but got "</span></span> + r.actualOutput) .mkString(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><p> 并仅在出现错误的情况下显示报告： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) test(<span class="hljs-string"><span class="hljs-string">"all test cases"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testBench = runTestCases(testCases) _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> results = testBench(f) assert(results.isEmpty, report(results)) }</code> </pre> <br><h3 id="podgotovka-vhodnyh-dannyh"> 输入准备 </h3><br><p> 在最简单的情况下，您可以手动创建测试数据来测试程序，将其直接写入测试代码中，然后使用它，如上所示。 通常会发现有趣的测试数据案例有很多共同点，可以作为一些基本实例进行细微的更改。 </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = <span class="hljs-type"><span class="hljs-type">MyObject</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//        val testCases = Seq( TestCase("baseline", baseline, ???), TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???) )</span></span></code> </pre> <br><p> 当使用嵌套的不可变数据结构时，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Monocle</a>库中的镜头提供了很大的帮助： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testObject1 = (field1 composeLens field2).set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline) <span class="hljs-comment"><span class="hljs-comment">//    : val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))</span></span></code> </pre> <br><p> 镜头使您可以优雅地“修改”数据结构的深层嵌套部分：每个镜头都是一个属性的吸气剂和吸气剂。 可以组合镜头以生产“聚焦”到下一个层次的镜头。 </p><br><h3 id="ispolzovanie-dsl-dlya-predstavleniya-izmeneniy"> 使用DSL呈现更改 </h3><br><p> 接下来，我们将通过更改一些初始输入对象来考虑测试数据的形成。 通常，要获得我们需要的测试对象，我们需要进行一些更改。 同时，在TestCase的文本描述中包含更改列表非常有用： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline"</span></span>, baseline, ???), <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline + "</span></span> + <span class="hljs-string"><span class="hljs-string">"(field1 = 123) + "</span></span> + <span class="hljs-comment"><span class="hljs-comment">//  1-  "(field2 = 456) + " + // 2- "(field3 = 789)", // 3- baseline .copy(field1 = "123") // 1-  .copy(field2 = "456") // 2-  .copy(field3 = "789"), // 3-  ???) )</span></span></code> </pre> <br><p> 然后，我们将始终知道要执行哪些测试数据。 </p><br><p> 为了使更改的文本列表不会偏离实际更改，您必须遵循“真理的单一版本”的原则。  （如果在多个点上需要/使用相同的信息，则应该有唯一的唯一信息的主要来源，并且应该通过必要的转换将信息自动分发给所有其他使用点。如果违反了该原理，则不可避免地要手动复制信息。在不同的点，换言之在测试数据，我们看到一个，和测试数据的描述差异版本信息， -另一个例子中，复制的变化<code>field2 = "456"</code> ，并在调整它<code>field3 = "789"</code>我们毛格 一不小心忘了更正的说明。其结果是，该说明将只反映三两个变化。） </p><br><p> 在我们的案例中，信息的主要来源是更改本身，或者更确切地说，是进行更改的程序的源代码。 我们想从他们那里得出描述这些变化的文字。 另外，作为第一种选择，您可以建议使用一个宏，该宏将捕获更改的源代码，并将该源代码用作文档。 显然，这是记录实际更改的一种很好且相对简单的方法，并且可能会在某些情况下应用。 不幸的是，如果我们以纯文本形式显示更改，我们将无法对更改列表进行有意义的转换。 例如，检测并消除重复或重叠的更改，以方便最终用户的方式绘制更改列表。 </p><br><p> 为了能够处理更改，您必须具有结构化的模型。 该模型应具有足够的表现力，以描述我们感兴趣的所有变化。 例如，该模型的一部分将是对象字段，常量，赋值操作的寻址。 </p><br><p> 变更模型应允许解决以下任务： </p><br><ol><li> 生成变更模型实例。  （也就是说，实际上是创建特定的更改列表。） </li><li> 形成对变更的文字描述。 </li><li> 将更改应用于域对象。 </li><li> 在模型上执行优化转换。 </li></ol><br><p> 如果使用通用编程语言进行更改，则可能很难在模型中表示这些更改。 程序的源代码可以使用模型不支持的复杂构造。 这样的程序可以使用辅助模式（例如镜头或<code>copy</code>方法）来更改对象的字段，这些字段是相对于更改模型级别的较低级别的抽象。 结果，可能需要对这种模式进行额外的分析，以输出变化的实例。 因此，最初使用宏的好选择不是很方便。 </p><br><p> 创建变更模型实例的另一种方法可以是专用语言（DSL），它使用一组扩展方法和辅助运算符来创建变更模型对象。 好了，在最简单的情况下，可以通过构造函数直接创建变更模型的实例。 </p><br><div class="spoiler">  <b class="spoiler_title">更改语言详细信息</b> <div class="spoiler_text"><p> 变更语言是一个相当复杂的结构，包含几个组成部分，而这些组成部分又是不平凡的。 </p><br><ol><li> 数据结构模型。 </li><li> 更改模型。 </li><li> 实际上是嵌入式（？）DSL-辅助结构，扩展方法，用于方便地进行更改。 </li><li> 更改的解释器，使您可以实际“修改”对象（当然，实际上是创建修改后的副本）。 </li></ol><br><p> 这是使用DSL编写的程序的示例： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target: <span class="hljs-type"><span class="hljs-type">Entity</span></span>[<span class="hljs-type"><span class="hljs-type">Target</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ,     val updateField1 = target \ field1 := "123" val updateField2 = target \ subobject \ field2 := "456" // ,   DSL: val updateField1 = SetProperty(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123")) val updateField2 = SetProperty(PropertyAccess(PropertyAccess(target, Property(subobject, typeTag[SubObject])), Property(field2, typeTag[String])), LiftedString("456"))</span></span></code> </pre> <br><p> 也就是说，使用扩展方法<code>\</code>和<code>:=</code> ， <code>PropertyAccess</code> ， <code>SetProperty</code>对象由先前创建的<code>target</code> ， <code>field1</code> ， <code>subobject</code>和<code>field2</code> 。 同样，由于（危险的）隐式转换，字符串“ 123”被打包到<code>LiftedString</code> （您可以不进行隐式转换而显式地调用相应的方法： <code>lift("123")</code> ）。 </p><br><p> 可以将类型化的本体用作数据模型（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/post/229035/</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/post/222553/</a> ）。  （简而言之：声明了代表任何类型域的属性的名称对象： <code>val field1: Property[Target, String]</code> 。）在这种情况下，实际数据可以以JSON的形式存储。 在我们的案例中，类型化本体的便利性在于这样的事实，即更改模型通常以对象的单个属性运行，而本体只是提供了一种处理属性的合适工具。 </p><br><p> 为了表示更改，您需要与上述<code>SetProperty</code>类具有相同计划的一组类： </p><br><ul><li>  <code>Modify</code> -功能的应用， </li><li>  <code>Changes</code> -按顺序应用多个更改 </li><li>  <code>ForEach</code>将更改应用于集合中的每个项目， </li><li> 等 </li></ul><br><p> 更改语言解释器是基于PatternMatching的正则递归表达式评估器。 类似于： </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">DslExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Any</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">LiftedString</span></span>(str) =&gt; str <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PropertyAccess</span></span>(obj, prop) =&gt; <span class="hljs-type"><span class="hljs-type">Getter</span></span>(prop)(gamma).get(obj) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (expression: <span class="hljs-type"><span class="hljs-type">DslChangeExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>], target: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SetProperty</span></span>(path, valueExpr) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = eval(valueExpr, gamma) <span class="hljs-type"><span class="hljs-type">Setter</span></span>(path)(gamma).set(value)(target) }</code> </pre> <br><p> 要直接对对象的属性进行操作，必须为更改模型中使用的每个属性指定getter和setter。 这可以通过填充本体属性及其对应的镜头之间的映射来实现。 </p></div></div><br><p> 这种方法总体上是有效的，并且确实允许您一次描述更改，但是逐渐需要表示越来越复杂的更改，并且更改模型在不断发展。 例如，如果您需要使用同一对象的另一个属性的值来更改属性（例如， <code>field1 = field2 + 1</code> ），则需要在DSL级别上支持变量。 而且，如果更改属性并非易事，那么在DSL级别上，就需要支持算术表达式和函数。 </p><br><h3 id="testirovanie-vetvey"> 分支测试 </h3><br><p> 测试代码可以是线性的，然后从总体上讲，一组测试数据足以了解其是否有效。 如果有一个分支（ <code>if-then-else</code> ），则必须使用不同的输入数据至少运行白盒两次，以便两个分支都被执行。 足以覆盖所有分支的输入数据集的数量在数值上显然等于具有分支的代码的圈复杂度。 </p><br><p> 如何形成所有输入数据集？ 由于我们正在处理白盒，因此我们可以隔离分支条件并修改输入对象两次，以便在一种情况下执行一个分支，在另一种情况下执行另一个分支。 考虑一个例子： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p> 有了这样的条件，我们可以形成两个测试用例： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase1 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline), <span class="hljs-comment"><span class="hljs-comment">/* result of A */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase2 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, field1.set(<span class="hljs-comment"><span class="hljs-comment">/*  "123", , , */</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> + <span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;)(baseline), <span class="hljs-comment"><span class="hljs-comment">/*result of B*/</span></span>)</code> </pre> <br><p>  <em>（如果无法创建其中一种测试场景，那么我们可以假定已检测到无效代码，并且可以安全地删除该条件以及相应的分支。）</em> </p><br><p> 如果在几个分支中检查对象的独立属性，那么形成一组详尽的修改后的测试对象非常简单，它完全涵盖了所有可能的组合。 </p><br><div class="spoiler">  <b class="spoiler_title">DSL构成所有变更组合</b> <div class="spoiler_text"><p> 让我们更详细地考虑允许形成所有可能的更改列表的机制，以提供所有分支的完整覆盖。 为了在测试期间使用更改列表，我们需要将所有更改组合到一个对象中，然后将其提交给测试代码的输入，也就是说，需要对组合的支持。 为此，您可以使用上面的DSL来建模更改，然后简单的更改列表就足够了，或者可以将一个更改作为修改函数<code>T =&gt; T</code>呈现： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> change1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(_) <span class="hljs-comment"><span class="hljs-comment">// val change1: T =&gt; T = _.copy(field1 = "123") val change2: T =&gt; T = field2.set("456")</span></span></code> </pre> <br><p> 那么变更链将仅仅是功能的组合： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> changes = change1 compose change2</code> </pre> <br><p> 或者，对于更改列表： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawChangesList: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(change1, change2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allChanges: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = rawChangesList.foldLeft(identity)(_ compose _)</code> </pre> <br><p> 要紧凑地记录与所有可能的分支相对应的所有更改，可以使用以下抽象级别的DSL，该DSL模拟被测试的白盒的结构： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)] = <span class="hljs-type"><span class="hljs-type">IF</span></span>(<span class="hljs-string"><span class="hljs-string">"field1 == '123'"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,    THEN( field1.set("123"))( //  target \ field1 := "123" IF("field2 == '456') THEN(field2.set("456"))(TERMINATE) ELSE(field2.set("456" + "1"))(TERMINATE) ) ELSE( field1.set("123" + "1") )(TERMINATE)</span></span></code> </pre> <br><p> 在这里， <code>tests</code>集合包含与所有可能的分支组合相对应的汇总更改。 类型为<code>String</code>的参数将包含条件的所有名称以及对形成汇总更改函数的更改的所有描述。 一对类型<code>T =&gt; T</code>的第二个元素只是由于个体变化的组成而获得的变化的聚合函数。 </p><br><p> 要获取更改的对象，您需要将所有汇总的更改功能应用于基准对象： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests2: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>)] = tests.map(_.map_2(_(baseline)))</code> </pre> <br><p> 结果，我们得到了一个对的集合，该行将描述所应用的更改，并且该对的第二个元素将是所有这些更改组合在一起的对象。 </p><br><p> 基于树形式的被测试代码的模型结构，更改列表将表示从树的根到表的路径。 因此，大部分更改将被复制。 您可以使用DSL选项摆脱这种重复，该选项在您沿着分支移动时将更改直接应用于基线对象。 在这种情况下，将执行较少的不必要的计算。 </p></div></div><br><h3 id="avtomaticheskoe-formirovanie-testovyh-dannyh"> 自动生成测试数据 </h3><br><p> 由于我们正在处理一个白框，因此可以看到所有分支。 这样就可以构建白盒中包含的逻辑模型，并使用该模型生成测试数据。 如果测试代码是用Scala编写的，则可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">scalameta</a>读取代码，然后再转换为逻辑模型。 同样，正如前面讨论的对变更逻辑建模的问题一样，我们很难对通用语言的所有可能性进行建模。 此外，我们将假定使用语言的有限子集或最初受限制的另一种语言或DSL来实现测试代码。 这使我们可以专注于我们感兴趣的语言方面。 </p><br><p> 考虑一个包含单个分支的代码示例： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p> 该条件将<code>field1</code>值的集合分为两个等效类： <code>== "123"</code>和<code>!= "123"</code> 。 因此，就此条件而言，整个输入数据集也分为两个等效类<code>ClassCondition1IsTrue</code>和<code>ClassCondition1IsFalse</code> 。 从覆盖的完整性的角度来看，我们足以从这两个类中至少取一个例子来覆盖分支<code>A</code>和分支<code>B</code> 对于第一类，我们可以在某种意义上以独特的方式构建示例：随机对象，但将<code>field1</code>更改为<code>"123"</code> 。 而且，该对象肯定会<code>ClassCondition1IsTrue</code>在等价类<code>ClassCondition1IsTrue</code> ，并且计算将沿着分支<code>A</code> 第二类还有更多示例。 生成第二类示例的一种方法是生成任意输入对象，并丢弃<code>field1 == "123"</code>那些输入对象。 另一种方法：获取随机对象，但将<code>field1</code>更改为<code>"123" + "*"</code> （进行修改，可以使用控制行中的任何更改来确保新行不等于控制行）。 </p><br><p>  <a href="">ScalaCheck库</a>中的<a href=""><code>  Arbitrary</code>和<code>Gen</code></a>非常适合作为随机数据<a href=""><code>  Arbitrary</code></a> 。 </p><br><p> 本质上，我们<strong>调用</strong> <code>if</code>使用<strong>的</strong>布尔函数。 也就是说，我们找到此布尔函数对其求值的输入对象的所有值<code>ClassCondition1IsTrue</code> ，以及对它接受<code>false</code>的输入对象的所有值<code>ClassCondition1IsFalse</code> 。 </p><br><p> 以类似的方式，可以生成适合于由简单条件运算符使用常量（大于或小于常量，包含在集合中，从常量开始）生成的约束的数据。 这种情况很容易逆转。 即使在测试代码中调用了简单的函数，我们也可以用其定义（内联）替换它们的调用，并且仍然可以反转条件表达式。 </p><br><h4 id="trudno-obratimye-funkcii"> 硬可逆功能 </h4><br><p> 当条件使用难以逆转的功能时，情况就不同。 例如，如果使用哈希函数，则似乎无法自动生成给出所需哈希码值的示例。 </p><br><p> 在这种情况下，尽管违反了功能连接，您仍可以向输入对象添加一个代表函数计算结果的附加参数，用对此参数的调用替换函数调用，并更新此参数： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sha(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a9403</span></span></span><span class="hljs-class">...") ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">object.sha_field1 == "a9403..."</span></span></span><span class="hljs-class">) ...</span></span></code> </pre> <br><p> 附加参数允许在分支内执行代码，但是很显然，它可能导致实际错误的结果。 也就是说，测试程序将产生实际上无法观察到的结果。 尽管如此，检查本来无法访问的部分代码仍然有用，并且可以视为单元测试的一种形式。 毕竟，即使在单元测试期间，也可能会使用在程序中永远不会使用的参数来调用子函数。 </p><br><p> 通过这种操作，我们替换（替换）了测试对象。 但是，从某种意义上说，新建程序包括旧程序的逻辑。 确实，如果将新人工参数的值作为计算用参数替换的函数的结果，则程序将产生相同的结果。 显然，测试修改后的程序仍然很有趣。 您只需要记住在什么条件下更改的程序的行为将与原始程序相同。 </p><br><h4 id="zavisimye-usloviya"> 相关条件 </h4><br><p>         ,      .        ,  ,   ,      .        ,     . (,  , <code>x &gt; 0</code> ,   — <code>x &lt;= 1</code> .         ,           — <code>(-∞, 0]</code> , <code>(0, 1]</code> , <code>(1, +∞)</code> , —      .) </p><br><p>       ,     ,   ,        <code>true</code>  <code>false</code>     .   ,    ,  " "         . </p><br><h4 id="svyazannye-parametry">   </h4><br><p>  ,        ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; x)</code> </pre> <br><p> (     <code>&gt; 0</code> ,       — <code>y &gt; x</code> .) <br>    "", ,   ,      ,    ,     .             ,             "  "     . <br>  ,   "",  ( <code>y == x + 1</code> ),    ,        . <br>   "" ( <code>y &gt; x + 1 &amp;&amp; y &lt; x + 2</code> ),     ,        . </p><br><h4 id="simvolnoe-vypolnenie">   </h4><br><p>  ,    ,    -  ,   "c " ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Symbolic Execution</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> ),     .        ( <code>field1 = field1_initial_value</code> ).       ,    .       : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = field1 + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//    a = field_initial_value + 10 val b = a * 3 //    b = 3 * field_initial_value + 30</span></span></code> </pre> <br><p>         — <code>true</code>  <code>false</code> .       .           . 举个例子 </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-comment"><span class="hljs-comment">//   A ,  field_initial_value + 10 &gt; 0 //   B ,  field_initial_value + 10 &lt;= 0</span></span></code> </pre> <br><p>           ,  ,   ,     ,    .        ,       (, ,   ). </p><br><h4 id="testirovanie-ciklov-i-rekursivnyh-funkciy">      </h4><br><p>        .    ,     ,       .        ,       .         ,         . </p><br><p> ,      .       . , ,        .  ,       ,      ,        .        ,   ,   ,  ,   ,      ? </p><br><p>     Y- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">"  "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">stackoverflow:What is a Y-combinator? (2- )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">habr:  Y-  7  </a> ).      ,       . (   ,      ,  .)    .            ,      .        ,    ""    . Y-   "  "     (     ). </p><br><p>        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ).   ,       .         ,     .       ,      . ,   ,       ,       <code>TestCase</code> '.  ,       ,     ( <code>throw</code>   <code>Nothing</code>  <code>bottom</code> ,    ).            . </p><br><p>        ,   .        .    ,  ,        .  ,       .        ,    ,     .          , ,    ,    ,      .      ,        .      ,    . </p><br><h3 id="smysl-testirovaniya-belogo-yaschika">     </h3><br><p>      ,  ,     ,      ,    100% .       ,     ,   . 嗯 .   , ,   ,   ?         ,    ,     -  . </p><br><p>           : </p><br><ol><li>                . </li><li>       (      ). </li><li>       ,          . </li><li>      ,    . </li></ol><br><p>       ,   ,       . -,       ,     ,   ,       . -,    ,   ,     ( ,  ),         ,  ,   ""  .   /    ,         . </p><br><h3 id="zaklyuchenie"> 结论 </h3><br><p>        "   "  "   ".  ,      ,     ,      ,     .         ,           . </p><br><p>      ,      ,  ,  ,  . -,          ,        ( ),      . -, -,      .      DSL,  ,    . -,          ,   . -,       ,        (   ,     ,   ).            . </p><br><p>  ,          ,      . ,      ,         -   . </p><br><h3 id="blagodarnosti"> 致谢 </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@mneychev</a>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN422283/">https://habr.com/ru/post/zh-CN422283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN422269/index.html">该书“内部设备Windows。 第七版</a></li>
<li><a href="../zh-CN422273/index.html">智慧城市中没有愚蠢的道路。 什么是RWIS，它将如何降低道路工程成本</a></li>
<li><a href="../zh-CN422275/index.html">由于软件漏洞，一名Google员工能够控制公司办公室的开门系统</a></li>
<li><a href="../zh-CN422277/index.html">架构和编程RCA Studio II</a></li>
<li><a href="../zh-CN422281/index.html">A7数据服务器：在线数据管理</a></li>
<li><a href="../zh-CN422285/index.html">为什么网上购物拥有1％的客户足够的忠诚度</a></li>
<li><a href="../zh-CN422291/index.html">小黑盒子（可视化所有货币和世界市场）</a></li>
<li><a href="../zh-CN422293/index.html">通过AlarmIRP接口从OSS获取警报列表</a></li>
<li><a href="../zh-CN422297/index.html">第一次体验或如何尝试成为代码和魔术的传奇</a></li>
<li><a href="../zh-CN422299/index.html">TsNIImash：据称SpaceX实现了苏联的发展。 为什么Ilon Mask有这么多敌人</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>