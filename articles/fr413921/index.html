<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíáüèº üïî üè° Comment sauver le projet de livres suppl√©mentaires üìÉ ü§õ üéå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! Je m'appelle Ilya, je suis d√©veloppeur iOS sur Tinkoff.ru. Dans cet article, je veux parler de la fa√ßon de r√©duire la duplication de c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment sauver le projet de livres suppl√©mentaires</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/413921/"><img src="https://habrastorage.org/webt/bh/r7/at/bhr7at_omfzwpf1mdp7rcrrb14m.jpeg"><br><br>  Bonjour √† tous!  Je m'appelle Ilya, je suis d√©veloppeur iOS sur Tinkoff.ru.  Dans cet article, je veux parler de la fa√ßon de r√©duire la duplication de code dans la couche de pr√©sentation √† l'aide de protocoles. <br><a name="habracut"></a><br><h3>  Quel est le probl√®me? </h3><br>  √Ä mesure que le projet se d√©veloppe, la quantit√© de duplication de code augmente.  Cela ne devient pas imm√©diatement apparent et il devient difficile de corriger les erreurs du pass√©.  Nous avons remarqu√© ce probl√®me sur notre projet et l'avons r√©solu en utilisant une approche, appelons-le, conditionnellement, des traits. <br><br><h3>  Exemple de vie </h3><br>  L'approche peut √™tre utilis√©e avec diff√©rentes solutions architecturales diff√©rentes, mais je la consid√©rerai en utilisant VIPER comme exemple. <br><br>  Consid√©rez la m√©thode la plus courante dans le routeur - la m√©thode qui ferme l'√©cran: <br><br><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionHandler.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> <br>  Il est pr√©sent dans de nombreux routeurs et il est pr√©f√©rable de l'√©crire une seule fois. <br><br>  L'h√©ritage nous y aiderait, mais √† l'avenir, lorsque nous aurons de plus en plus de classes avec des m√©thodes inutiles dans notre application, ou que nous ne serons pas en mesure de cr√©er la classe dont nous avons besoin car les m√©thodes requises sont dans diff√©rentes classes de base, de grandes appara√Ætront probl√®mes. <br>  En cons√©quence, le projet se d√©veloppera en de nombreuses classes de base et classes descendantes avec des m√©thodes superflues.  L'h√©r√©dit√© ne nous aidera pas. <br><br>  Quoi de mieux que l'h√©ritage?  Bien s√ªr, la composition. <br><br>  Vous pouvez cr√©er une classe distincte pour la m√©thode qui ferme l'√©cran et l'ajouter √† chaque routeur dans lequel elle est n√©cessaire: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionHandler.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } }</code> </pre><br>  Nous devons encore d√©clarer cette m√©thode dans le protocole d'entr√©e du routeur et l'impl√©menter dans le routeur lui-m√™me: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouterInput</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouterInput</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closeRouter = { <span class="hljs-type"><span class="hljs-type">CloseRouter</span></span>(transitionHandler: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>. transitionHandler) }() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.closeRouter.close() } }</code> </pre><br>  Il s'est av√©r√© trop de code qui fait simplement office de proxy pour la m√©thode close.  <s>Le</s> bon programmeur <s>paresseux</s> n'appr√©ciera pas. <br><br><h3>  Solution de protocole </h3><br>  Les protocoles viennent √† la rescousse.  Il s'agit d'un outil assez puissant qui vous permet d'impl√©menter la composition et peut contenir des m√©thodes d'impl√©mentation en extension.  Nous pouvons donc cr√©er un protocole contenant la m√©thode close et l'impl√©menter en extension. <br><br>  Voici √† quoi cela ressemblera: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionHandler.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } }</code> </pre><br>  La question est, pourquoi le mot trait appara√Æt-il dans le nom du protocole?  C'est simple - vous pouvez sp√©cifier que ce protocole impl√©mente ses m√©thodes en extension et doit √™tre utilis√© en tant que m√©lange avec un autre type pour √©tendre ses fonctionnalit√©s. <br><br>  Voyons maintenant √† quoi ressemblera l'utilisation d'un tel protocole: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> }</code> </pre><br>  Oui, c‚Äôest tout.  √áa a l'air g√©nial :).  Nous avons obtenu la composition en ajoutant le protocole √† la classe du routeur, n'avons pas √©crit une seule ligne suppl√©mentaire et avons eu la possibilit√© de r√©utiliser le code. <br><br><h3>  Qu'est-ce qui est inhabituel dans cette approche? </h3><br>  Vous avez peut-√™tre d√©j√† pos√© cette question.  L'utilisation de protocoles comme trait est assez courante.  La principale diff√©rence est d'utiliser cette approche comme solution architecturale au sein de la couche de pr√©sentation.  Comme toute solution architecturale, il devrait y avoir ses propres r√®gles et recommandations. <br><br>  Voici ma liste: <br><br><ul><li>  Les traits ne doivent pas stocker et changer d'√©tat.  Ils ne peuvent avoir que des d√©pendances sous forme de services, etc., qui sont des propri√©t√©s get-only. </li><li>  Les traits ne devraient pas avoir de m√©thodes qui ne sont pas impl√©ment√©es en extension, car cela viole leur concept </li><li>  Les noms des m√©thodes dans trait doivent refl√©ter explicitement ce qu'ils font, sans √™tre li√©s au nom du protocole.  Cela aidera √† √©viter les collisions de noms et √† rendre le code plus clair. </li></ul><br><h3>  De VIPER √† MVP </h3><br>  Si vous passez compl√®tement √† l'utilisation de cette approche avec des protocoles, les classes routeur et interacteur ressembleront √† ceci: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OtherRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someService: <span class="hljs-type"><span class="hljs-type">SomeServiceInput!</span></span> }</code> </pre><br>  Cela ne s'applique pas √† toutes les classes; dans la plupart des cas, le projet aura simplement des routeurs et des interacteurs vides.  Dans ce cas, vous pouvez perturber la structure du module VIPER et passer en douceur √† MVP en ajoutant des protocoles d'impuret√©s au pr√©sentateur. <br><br>  Quelque chose comme √ßa: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomePresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OtherRouterTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OtherInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someService: <span class="hljs-type"><span class="hljs-type">SomeSericeInput!</span></span> }</code> </pre><br>  Oui, la possibilit√© d'impl√©menter un routeur et un interacteur en tant que d√©pendances est perdue, mais dans certains cas, c'est le cas. <br><br>  Le seul inconv√©nient est transitionHandler = UIViewController.  Et selon les r√®gles de VIPER Presenter, rien ne doit √™tre connu sur la couche View et comment elle est impl√©ment√©e √† l'aide de quelles technologies.  Ceci est r√©solu dans ce cas simplement - les m√©thodes de transition de UIViewController sont "ferm√©es" par le protocole, par exemple, TransitionHandler.  Ainsi, le pr√©sentateur interagira avec l'abstraction. <br><br><h3>  Changer le comportement des traits </h3><br>  Voyons comment vous pouvez changer le comportement dans de tels protocoles.  Ce sera un analogue de la substitution de certaines parties du module, par exemple, pour des tests ou un talon temporaire. <br><br>  Par exemple, prenons un simple interacteur avec une m√©thode qui effectue une requ√™te r√©seau: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someService: <span class="hljs-type"><span class="hljs-type">SomeServiceInput!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Response)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Response)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { someService.performRequest(completion) } }</code> </pre><br>  C'est un code abstrait, par exemple.  Supposons que nous n'ayons pas besoin d'envoyer une demande, mais simplement de renvoyer une sorte de talon.  Ici, nous allons √† l'astuce - cr√©er un protocole vide appel√© Mock et proc√©dez comme suit: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Response)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { completion(<span class="hljs-type"><span class="hljs-type">MockResponse</span></span>()) } }</code> </pre><br>  Ici, l'impl√©mentation de la m√©thode performRequest a √©t√© modifi√©e pour les types qui impl√©mentent le protocole Mock.  Vous devez maintenant impl√©menter le protocole Mock pour la classe qui impl√©mentera SomeInteractor: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomePresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeInteractorTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mock { // Implementation }</span></span></span></span></code> </pre><br>  Pour la classe SomePresenter, l'impl√©mentation de la m√©thode performRequest sera appel√©e, situ√©e en extension, o√π Self satisfait le protocole Mock.  Il vaut la peine de supprimer le protocole Mock et l'impl√©mentation de la m√©thode performRequest sera prise de l'extension habituelle √† SomeInteractor. <br><br>  Si vous ne l'utilisez que pour des tests, il est pr√©f√©rable de placer tout le code associ√© √† la substitution de l'impl√©mentation dans la cible de test. <br><br><h3>  Pour r√©sumer </h3><br>  En conclusion, il convient de noter les avantages et les inconv√©nients de cette approche et dans quels cas, √† mon avis, elle vaut la peine d'√™tre utilis√©e. <br><br>  Commen√ßons par les inconv√©nients: <br><br><ul><li>  Si vous vous d√©barrassez du routeur et de l'interacteur, comme indiqu√© dans l'exemple, la possibilit√© d'impl√©menter ces d√©pendances est perdue. </li><li>  Un autre inconv√©nient est le nombre fortement croissant de protocoles. </li><li>  Parfois, le code peut ne pas sembler aussi clair que l'utilisation d'approches conventionnelles. </li></ul><br>  Les aspects positifs de cette approche sont les suivants: <br><br><ul><li>  Plus important et √©vident, la duplication est consid√©rablement r√©duite. </li><li>  La liaison statique est appliqu√©e aux m√©thodes de protocole.  Cela signifie que la d√©termination de la mise en ≈ìuvre de la m√©thode se fera au stade de la compilation.  Par cons√©quent, pendant l'ex√©cution du programme, aucun temps suppl√©mentaire ne sera consacr√© √† la recherche d'une impl√©mentation (bien que ce temps ne soit pas particuli√®rement important). </li><li>  Du fait que les protocoles sont de petites ¬´briques¬ª, toute composition peut √™tre facilement compos√©e √† partir d'eux.  De plus en karma pour une flexibilit√© d'utilisation. </li><li>  Facilit√© de refactoring, aucun commentaire ici. </li><li>  Vous pouvez commencer √† utiliser cette approche √† n'importe quelle √©tape du projet, car elle n'affecte pas l'int√©gralit√© du projet. </li></ul><br>  Consid√©rer cette d√©cision comme bonne ou non est une affaire priv√©e pour tout le monde.  Notre exp√©rience avec cette approche a √©t√© positive et a r√©solu des probl√®mes. <br><br>  C‚Äôest tout! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413921/">https://habr.com/ru/post/fr413921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413907/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 256 (4 juin - 12 juin)</a></li>
<li><a href="../fr413909/index.html">C'est l√† que tes souvenirs d'enfance sont all√©s</a></li>
<li><a href="../fr413913/index.html">Connaissance des expositions d'√©quipements audio et vid√©o: bref sur les plus grands √©v√©nements - premi√®re partie</a></li>
<li><a href="../fr413915/index.html">Faire de Tower Defense un jeu d'unit√© - Partie 2</a></li>
<li><a href="../fr413917/index.html">Les titulaires de droits d'auteur croient que Yandex contribue √† la croissance du piratage dans le pays</a></li>
<li><a href="../fr413923/index.html">Peut-√™tre que l'atmosph√®re peut encore √™tre nettoy√©e du dioxyde de carbone</a></li>
<li><a href="../fr413925/index.html">CVT pour Moskvich</a></li>
<li><a href="../fr413927/index.html">Digispark sur Attiny85 - Connexion sous Windows 10</a></li>
<li><a href="../fr413929/index.html">Sotchi. Appareil photo: caract√©ristiques de la cr√©ation d'un projet en g√©n√©ral, compl√®tement, compl√®tement √† partir de z√©ro, sans normes et exemples d√©j√† mis en ≈ìuvre</a></li>
<li><a href="../fr413931/index.html">Version du noyau Linux 4.17: ce que vous devez savoir √† ce sujet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>