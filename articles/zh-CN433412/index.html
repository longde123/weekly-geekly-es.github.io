<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍⚕️ 👩🏿‍🎨 📻 功能思维。 第11部分：决赛 ⭐️ 👩🏽‍🤝‍👩🏼 👍🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我们正在完成有关函数式编程的系列文章。 原来有11个部分。 我相信这是一项成就。 在本文中，我们实现了一个简单的堆栈计算器（也称为“反向波兰符号”）。 该实现几乎完全建立在函数的基础上，只有一种特殊类型，并且通常不与示例进行比较，因此这是本系列中所涵盖概念的绝佳测试平台。 





 我要分...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>功能思维。 第11部分：决赛</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433412/"><p> 今天，我们正在完成有关函数式编程的系列文章。 原来有11个部分。 我相信这是一项成就。 在本文中，我们实现了一个简单的堆栈计算器（也称为“反向波兰符号”）。 该实现几乎完全建立在函数的基础上，只有一种特殊类型，并且通常不与示例进行比较，因此这是本系列中所涵盖概念的绝佳测试平台。 </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><p> 我要分别感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@kleidemos</em></a> 。 是他担任了整个系列文章的主要翻译和经理。 谢谢你 </p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第三部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第四部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第五部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第六部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第七部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第八部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第九部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十</a></strong> <a name="habracut"></a></li></ul><br><hr><br><p> 如果您不熟悉这样的计算器，则它的工作方式如下：将数字压入堆栈，然后进行运算（例如加法和乘法），从堆栈顶部选取数字，然后放回运算结果。 </p><br><p> 堆栈上的简单计算方案： </p><br><br><p> 在设计这样的系统之前，您应该考虑如何使用它。 遵循类似Forth的语法，我们将为每个操作赋予适当的标签，以便在上面的示例中您可以编写类似以下内容的内容： </p><br><pre><code class="plaintext hljs">EMPTY ONE THREE ADD TWO MUL SHOW</code> </pre> <br><p> 也许不可能完全获得这种语法，但让我们尝试尽可能地接近此语法。 </p><br><h2> 堆栈数据类型 </h2><br><p> 首先，您需要定义堆栈的数据结构。 为简单起见，您可以使用浮点数列表。 </p><br><pre> <code class="plaintext hljs">type Stack = float list</code> </pre> <br><p> 但是最好将其包装在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单个case联合类型中，</a>以使该类型更直观，如下所示： </p><br><pre> <code class="plaintext hljs">type Stack = StackContents of float list</code> </pre> <br><p> 为什么这样做更好，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>阅读。 </p><br><p> 现在使用<code>StackContents</code>作为构造函数创建一个新堆栈： </p><br><pre> <code class="plaintext hljs">let newStack = StackContents [1.0;2.0;3.0]</code> </pre> <br><p> 要从现有堆栈中提取内容，请使用与<code>StackContents</code>匹配的模式： </p><br><pre> <code class="plaintext hljs">let (StackContents contents) = newStack //  "contents"   // float list = [1.0; 2.0; 3.0]</code> </pre> <br><h2> 推送功能 </h2><br><p> 接下来，我们需要一种将数字放入此堆栈的方法。 为此，只需使用“ <code>::</code> ”将新值添加到列表顶部。 </p><br><p> 功能示例： </p><br><pre> <code class="plaintext hljs">let push x aStack = let (StackContents contents) = aStack let newContents = x::contents StackContents newContents</code> </pre> <br><p> 此功能具有许多值得讨论的功能。 </p><br><p> 首先，您应注意<code>list</code>结构是不可变的，这意味着该函数必须采用现有堆栈并返回一个新堆栈。 这不仅仅是对现有堆栈的更改。 实际上，此示例中的所有函数都将具有类似的格式： </p><br><pre> <code class="plaintext hljs">Input: Stack   -  Output:  Stack</code> </pre> <br><p> 其次，为什么参数按该顺序排列？ 为什么堆栈应该排在最前或最后？ 在关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用部分应用程序设计功能的部分中，</a>据说最频繁更改的参数应该排在最后。 很快将有可能验证是否遵循了这些建议。 </p><br><p> 最后，通过与功能参数本身中的模式匹配，而不是<code>let</code>进入函数主体，可以使函数更简洁。 </p><br><p> 改写的版本： </p><br><pre> <code class="plaintext hljs">let push x (StackContents contents) = StackContents (x::contents)</code> </pre> <br><p> 好多了！ </p><br><p> 顺便说一句，看看她优美的签名： </p><br><pre> <code class="plaintext hljs">val push : float -&gt; Stack -&gt; Stack</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如前所述</a> ，签名告诉了我们很多。 <br> 在这种情况下，我仅凭其签名就可以猜出该函数的作用，甚至不知道它被称为“推”。 <br> 这是拥有显式类型名称的一个好主意的另一个原因。 如果堆栈只是浮点数的列表，那么该函数就不会如此自我记录。 </p><br><p> 一种或另一种方法，检查： </p><br><pre> <code class="plaintext hljs">let emptyStack = StackContents [] let stackWith1 = push 1.0 emptyStack let stackWith2 = push 2.0 stackWith1</code> </pre> <br><p> 很棒！ </p><br><h2> 使用push堆叠顶部上标 </h2><br><p> 使用此简单功能，您可以轻松定义将特定数字压入堆栈的操作。 </p><br><pre> <code class="plaintext hljs">let ONE stack = push 1.0 stack let TWO stack = push 2.0 stack</code> </pre> <br><p> 但是请稍等！ 您看到表达式的两边都提到了<code>stack</code>参数吗？ 实际上，没有必要再提两次。 相反，您可以省略参数，并使用部分应用程序编写函数： </p><br><pre> <code class="plaintext hljs">let ONE = push 1.0 let TWO = push 2.0 let THREE = push 3.0 let FOUR = push 4.0 let FIVE = push 5.0</code> </pre> <br><p> 现在很明显，如果<code>push</code>函数的参数顺序不同，则必须两次提及<code>stack</code> 。 </p><br><p> 还值得定义一个创建空堆栈的函数： </p><br><pre> <code class="plaintext hljs">let EMPTY = StackContents []</code> </pre> <br><p> 检查收到的功能： </p><br><pre> <code class="plaintext hljs">let stackWith1 = ONE EMPTY let stackWith2 = TWO stackWith1 let stackWith3 = THREE stackWith2</code> </pre> <br><p> 这些中间堆栈烦人吗？ 有可能摆脱它们吗？ 当然可以！ 请注意，一个，两个和三个函数具有相同的签名： </p><br><pre> <code class="plaintext hljs">Stack -&gt; Stack</code> </pre> <br><p> 因此，它们完美地连接在一起！ 一个功能的输出可以输入以下内容： </p><br><pre> <code class="plaintext hljs">let result123 = EMPTY |&gt; ONE |&gt; TWO |&gt; THREE let result312 = EMPTY |&gt; THREE |&gt; ONE |&gt; TWO</code> </pre> <br><h2> 从堆栈中弹出 </h2><br><p> 解决了堆栈问题之后， <code>pop</code>函数又如何呢？ </p><br><p> 从堆栈中检索时，显然有必要返回堆栈的顶部，但是仅仅是这样吗？ </p><br><p> 在面向对象的风格中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">答案是肯定的</a> 。 但是对于OOP，将在后台更改堆栈，以便删除顶部项目。 </p><br><p> 但是，在功能风格上，堆栈是不可变的。 删除顶部元素只有一种方法-创建一个没有该元素的<em>新堆栈</em> 。 为了使调用者可以访问新的精简堆栈，它必须与top元素一起返回。 </p><br><p> 换句话说， <code>pop</code>函数应返回<em>两个</em>值，即top元素和新堆栈。 在F＃中执行此操作的最简单方法是简单地使用元组。 </p><br><p> 实现方式： </p><br><pre> <code class="plaintext hljs">///     ///          let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack)</code> </pre> <br><p> 产生的功能也非常简单。 </p><br><p> 和以前一样，直接从参数<code>contents</code>提取<code>contents</code> 。 </p><br><p> 然后，使用<code>match..with</code>表达式检查内容的<code>contents</code> 。 </p><br><p> 然后将顶部元素与列表的其余部分分开，根据其余元素创建一个新的堆栈，最后将所有这些作为元组对返回。 </p><br><p> 尝试运行此代码，看看会发生什么。 您会得到一个编译错误！ <br> 编译器检测到一个尚未解决的情况-如果堆栈为空会怎样？ </p><br><p> 您必须决定如何处理它。 </p><br><ul><li> 选项1：返回特殊状态“成功”或“错误”，如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">系列“为什么使用F＃？”</a>中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">帖子所述。</a>  。 </li><li> 选项2：引发异常。 </li></ul><br><p> 我通常更喜欢对错误使用特殊的状态，但是在这种特殊情况下，我更喜欢抛出异常。 固定版本的<code>pop</code>带有空的案例处理： </p><br><pre> <code class="plaintext hljs">let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack) | [] -&gt; failwith "Stack underflow"</code> </pre> <br><p> 检查： </p><br><pre> <code class="plaintext hljs">let initialStack = EMPTY |&gt; ONE |&gt; TWO let popped1, poppedStack = pop initialStack let popped2, poppedStack2 = pop poppedStack</code> </pre> <br><p> 和异常测试： </p><br><pre> <code class="plaintext hljs">let _ = pop EMPTY</code> </pre> <br><h2> 算术函数 </h2><br><p> 现在添加和删除已经到位，您可以开始使用“ add”和“ multiply”功能了： </p><br><pre> <code class="plaintext hljs">let ADD stack = let x,s = pop stack //   let y,s2 = pop s //    let result = x + y //   push result s2 //     let MUL stack = let x,s = pop stack //   let y,s2 = pop s //    let result = x * y //   push result s2 //    </code> </pre> <br><p> 在线测试： </p><br><pre> <code class="plaintext hljs">let add1and2 = EMPTY |&gt; ONE |&gt; TWO |&gt; ADD let add2and3 = EMPTY |&gt; TWO |&gt; THREE |&gt; ADD let mult2and3 = EMPTY |&gt; TWO |&gt; THREE |&gt; MUL</code> </pre> <br><p> 有效！ </p><br><h3> 重构时间... </h3><br><p> 显然，这两个函数中有大量的代码重复。 我们该如何解决？ </p><br><p> 这两个函数都从堆栈中提取两个值，对它们应用某个二进制函数，然后将结果推回堆栈中。 您可以将通用代码输出到二进制函数，该函数采用带有两个参数的数学函数： </p><br><pre> <code class="plaintext hljs">let binary mathFn stack = //    let y,stack' = pop stack //     let x,stack'' = pop stack' //  let z = mathFn xy //      push z stack''</code> </pre> <br><p>  <em>请注意，在此实现中，“相同”对象的不同版本用不同数量的引号标记。</em>  <em>这是因为数字后缀很容易导致混淆。</em> </p><br><p> 问题：为什么参数完全按此顺序排列，而不是在<code>stack</code>之后添加<code>mathFn</code> ？ </p><br><p> 现在您有了一个<code>binary</code>函数，定义ADD和其他函数要容易得多： </p><br><p> 第一次尝试使用<code>binary</code>实现ADD： </p><br><pre> <code class="plaintext hljs">let ADD aStack = binary (fun xy -&gt; x + y) aStack</code> </pre> <br><p> 但是您可以摆脱lambda，因为 它表示内置函数<code>+</code>的<em>确切</em>定义： </p><br><pre> <code class="plaintext hljs">let ADD aStack = binary (+) aStack</code> </pre> <br><p> 同样，可以使用部分应用程序来隐藏堆栈参数。 最终定义： </p><br><pre> <code class="plaintext hljs">let ADD = binary (+)</code> </pre> <br><p> 其他数学函数的定义： </p><br><pre> <code class="plaintext hljs">let SUB = binary (-) let MUL = binary (*) let DIV = binary (../)</code> </pre> <br><p> 在线尝试： </p><br><pre> <code class="plaintext hljs">let div2by3 = EMPTY |&gt; THREE|&gt; TWO |&gt; DIV let sub2from5 = EMPTY |&gt; TWO |&gt; FIVE |&gt; SUB let add1and2thenSub3 = EMPTY |&gt; ONE |&gt; TWO |&gt; ADD |&gt; THREE |&gt; SUB</code> </pre> <br><p> 同样，您可以为一元运算创建辅助功能 </p><br><pre> <code class="plaintext hljs">let unary f stack = let x,stack' = pop stack push (fx) stack'</code> </pre> <br><p> 并定义一些一元函数： </p><br><pre> <code class="plaintext hljs">let NEG = unary (fun x -&gt; -x) let SQUARE = unary (fun x -&gt; x * x)</code> </pre> <br><p> 互动模式： </p><br><pre> <code class="plaintext hljs">let neg3 = EMPTY |&gt; THREE|&gt; NEG let square2 = EMPTY |&gt; TWO |&gt; SQUARE</code> </pre> <br><h2> 全部放在一起| 全部放在一起 </h2><br><p> 在最初的要求中，提到我们希望能够显示结果，因此值得定义SHOW函数。 </p><br><pre> <code class="plaintext hljs">let SHOW stack = let x,_ = pop stack printfn "The answer is %f" x stack //      </code> </pre> <br><p> 请注意，在这种情况下，将忽略通过<code>pop</code>接收到的堆栈的新版本。 最终结果是原始堆栈，就好像它从未更改过一样。 </p><br><p> 最后，您可以根据原始要求编写以下示例 </p><br><pre> <code class="plaintext hljs">EMPTY |&gt; ONE |&gt; THREE |&gt; ADD |&gt; TWO |&gt; MUL |&gt; SHOW</code> </pre> <br><h3> 继续前进 </h3><br><p> 这很有趣，但是您还能做什么？ </p><br><p> 您可以定义几个附加功能： </p><br><pre> <code class="plaintext hljs">///      let DUP stack = //    let x,_ = pop stack //      push x stack ///      let SWAP stack = let x,s = pop stack let y,s' = pop s push y (push x s') ///    let START = EMPTY</code> </pre> <br><p> 使用这些附加功能，您可以编写一些精美的示例： </p><br><pre> <code class="plaintext hljs">START |&gt; ONE |&gt; TWO |&gt; SHOW START |&gt; ONE |&gt; TWO |&gt; ADD |&gt; SHOW |&gt; THREE |&gt; ADD |&gt; SHOW START |&gt; THREE |&gt; DUP |&gt; DUP |&gt; MUL |&gt; MUL // 27 START |&gt; ONE |&gt; TWO |&gt; ADD |&gt; SHOW // 3 |&gt; THREE |&gt; MUL |&gt; SHOW // 9 |&gt; TWO |&gt; SWAP |&gt; DIV |&gt; SHOW // 9 div 2 = 4.5</code> </pre> <br><h2> 使用合成代替流水线 </h2><br><p> 但这还不是全部。 实际上，还有另一种有趣的方式来表示这些功能。 </p><br><p> 如前所述，它们都具有相同的签名： </p><br><pre> <code class="plaintext hljs">Stack -&gt; Stack</code> </pre> <br><p> 由于输入和输出是同一类型，因此也可以使用组合运算符<code>&gt;&gt;</code>组合这些函数，而不仅是通过管道运算符。 </p><br><p> 一些例子： </p><br><pre> <code class="plaintext hljs">//    let ONE_TWO_ADD = ONE &gt;&gt; TWO &gt;&gt; ADD START |&gt; ONE_TWO_ADD |&gt; SHOW //    let SQUARE = DUP &gt;&gt; MUL START |&gt; TWO |&gt; SQUARE |&gt; SHOW //     let CUBE = DUP &gt;&gt; DUP &gt;&gt; MUL &gt;&gt; MUL START |&gt; THREE |&gt; CUBE |&gt; SHOW //   let SUM_NUMBERS_UPTO = DUP // n &gt;&gt; ONE &gt;&gt; ADD // n+1 &gt;&gt; MUL // n(n+1) &gt;&gt; TWO &gt;&gt; SWAP &gt;&gt; DIV // n(n+1) / 2 START |&gt; THREE |&gt; SQUARE |&gt; SUM_NUMBERS_UPTO |&gt; SHOW</code> </pre> <br><p> 在每个这些示例中，使用其他功能的组合定义了一个新功能。 这是构建功能的“组合”方法的一个很好的例子。 </p><br><h2> 输送机与成分 </h2><br><p> 我们看到了使用模型的两种不同方法。 使用输送机和成分。 但是有什么区别呢？ 为什么一个人比另一个人更受青睐？ </p><br><p> 区别在于，从某种意义上说，管道是“实时转换”操作。 在使用管道时，将通过传输特定堆栈立即执行操作。 </p><br><p> 另一方面，合成就像我们要实现的“计划”一样，无需直接应用即可从一组组件构建功能。 </p><br><p> 例如，您可以通过结合一些小操作来创建一个“计划”来计算数字的平方： </p><br><pre> <code class="plaintext hljs">let COMPOSED_SQUARE = DUP &gt;&gt; MUL</code> </pre> <br><p> 我不能根据管道给出等效的结果。 </p><br><pre> <code class="plaintext hljs">let PIPED_SQUARE = DUP |&gt; MUL</code> </pre> <br><p> 这将导致编译错误。 我需要一些特定的堆栈实例才能使表达式起作用： </p><br><pre> <code class="plaintext hljs">let stackWith2 = EMPTY |&gt; TWO let twoSquared = stackWith2 |&gt; DUP |&gt; MUL</code> </pre> <br><p> 即使在这种情况下，我也只能针对此特定输入获得答案，而不能像基于<code>COMPOSED_SQUARE</code>的示例那样基于任何输入获得通用的计算计划。 </p><br><p> 创建“计划”的另一种方法是将lambda显式传递给更多原始函数： </p><br><pre> <code class="plaintext hljs">let LAMBDA_SQUARE = unary (fun x -&gt; x * x)</code> </pre> <br><p> 这是一种更明确的方法（并且可能更快），但是失去了组合方法的所有优点和清晰度。 </p><br><p> 通常，如果可能的话，您应该争取一种合成方法！ </p><br><h2> 完整代码 </h2><br><p> 上面所有示例的完整代码： </p><br><pre> <code class="plaintext hljs">// ============================================== //  // ============================================== type Stack = StackContents of float list // ============================================== //   // ============================================== ///     let push x (StackContents contents) = StackContents (x::contents) ///        ///       let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack) | [] -&gt; failwith "Stack underflow" // ============================================== //  () // ============================================== //     //      //     let binary mathFn stack = let y,stack' = pop stack let x,stack'' = pop stack' let z = mathFn xy push z stack'' //    //      //     let unary f stack = let x,stack' = pop stack push (fx) stack' // ============================================== //  () // ============================================== ///      let SHOW stack = let x,_ = pop stack printfn "The answer is %f" x stack //      ///    let DUP stack = let x,s = pop stack push x (push xs) ///      let SWAP stack = let x,s = pop stack let y,s' = pop s push y (push x s') ///    let DROP stack = let _,s = pop stack //   s //   // ============================================== // ,    // ============================================== //  // ------------------------------- let EMPTY = StackContents [] let START = EMPTY //  // ------------------------------- let ONE = push 1.0 let TWO = push 2.0 let THREE = push 3.0 let FOUR = push 4.0 let FIVE = push 5.0 //   // ------------------------------- let ADD = binary (+) let SUB = binary (-) let MUL = binary (*) let DIV = binary (../) let NEG = unary (fun x -&gt; -x) // ============================================== // ,     // ============================================== let SQUARE = DUP &gt;&gt; MUL let CUBE = DUP &gt;&gt; DUP &gt;&gt; MUL &gt;&gt; MUL let SUM_NUMBERS_UPTO = DUP // n &gt;&gt; ONE &gt;&gt; ADD // n+1 &gt;&gt; MUL // n(n+1) &gt;&gt; TWO &gt;&gt; SWAP &gt;&gt; DIV // n(n+1) / 2</code> </pre> <br><h2> 结论 </h2><br><p> 我们有一个简单的基于堆栈的计算器。 我们看到了如何从一些原始操作（ <code>push</code> ， <code>pop</code> ， <code>binary</code> ， <code>unary</code> ）和其他操作开始，构建出易于实现和使用的功能完善的DSL。 </p><br><p> 您可能会猜到，这个示例几乎是基于Forth语言的。 我强烈推荐免费的书籍<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《 Thinking Forth》</a> ，该书不仅讲述了Forth语言，而且还讲解了其他分解方法的方法（这些方法通常适用于函数式编程）。 </p><br><p> 我从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ashley Feniello</a>的华丽博客中获得了这篇文章的想法。 如果您想更深入地研究基于F＃的基于堆栈的语言，请从它开始。  <em>玩得开心！</em> </p><br><h1> 其他资源 </h1><br><p>  F＃的教程很多，包括那些具有C＃或Java经验的人的材料。 当您深入了解F＃时，以下链接可能会很有用： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃指南</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃娱乐与利润</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃维基</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Y分钟内学习X：F＃</a> </li></ul><br><p> 还介绍了其他几种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开始学习F＃的方法</a> 。 </p><br><p> 最后，F＃社区非常适合初学者。 在Slack上，由F＃Software Foundation支持的聊天非常活跃，您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以自由加入</a>初学者室。 我们强烈建议您这样做！ </p><br><p> 不要忘记访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语社区F＃的网站</a> ！ 如果您对学习语言有任何疑问，我们将很乐意在聊天室中讨论这些问题： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃软件基金会Slack聊天</a>室中的<code>#ru_general</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">室</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在电报中聊天</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聊天聊天</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃软件基金会Slack聊天</a>室中的#en_general <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">室</a> </li></ul><br><h2> 关于翻译作者 </h2><br><p> 由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@kleidemos</em></a>翻译 <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在F＃开发人员</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语社区</a>的努力下进行了翻译和编辑更改。 我们也感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@schvepsss</em></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@shwars</em></a>为本文准备发表。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433412/">https://habr.com/ru/post/zh-CN433412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433402/index.html">功能思维。 第8部分</a></li>
<li><a href="../zh-CN433404/index.html">React教程第3部分：组件文件，项目结构</a></li>
<li><a href="../zh-CN433406/index.html">功能思维。 第9部分</a></li>
<li><a href="../zh-CN433408/index.html">Node.js中的高效内存处理</a></li>
<li><a href="../zh-CN433410/index.html">功能思维。 第10部分</a></li>
<li><a href="../zh-CN433414/index.html">测试PRTG网络监视器并与Zabbix进行比较</a></li>
<li><a href="../zh-CN433420/index.html">ZeroNights 2018结果</a></li>
<li><a href="../zh-CN433424/index.html">可以在Super Mario Maker中加载无法逾越的关卡吗？</a></li>
<li><a href="../zh-CN433428/index.html">创造力从何而来：在RAT测试过程中对大脑α波活动的分析</a></li>
<li><a href="../zh-CN433430/index.html">新鲜的SoC Amlogic S905X2上具有4 GB RAM和Android TV 8.1的Android盒子Mecool KM9-了解并原谅</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>