<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„Ä∞Ô∏è üôáüèø üï§ Implementaci√≥n de la interfaz de usuario de OpenStack LBaaS üÜî üÜó üë®üèº‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando implement√© la interfaz de usuario del equilibrador de carga para una nube privada virtual, tuve que enfrentar dificultades significativas. Esto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementaci√≥n de la interfaz de usuario de OpenStack LBaaS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/455523/"><img src="https://habrastorage.org/webt/ct/q8/3-/ctq83--b7viz0r6evi5um6brnam.png"><br><br>  Cuando implement√© la interfaz de usuario del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">equilibrador de carga</a> para una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nube privada virtual,</a> tuve que enfrentar dificultades significativas.  Esto me llev√≥ a reflexionar sobre el papel de la interfaz, que quiero compartir en primer lugar.  Y luego justifique sus pensamientos, usando el ejemplo de una tarea espec√≠fica. <br><br>  La soluci√≥n al problema result√≥, en mi opini√≥n, bastante creativa, y tuve que buscarla en un marco muy limitado, as√≠ que creo que puede ser interesante. <br><a name="habracut"></a><br><h2>  Rol frontend </h2><br>  Debo decir de inmediato que no finjo la verdad y planteo un tema controvertido.  Estoy algo deprimido por la iron√≠a del front-end y de la web en particular, como algo insignificante.  Y es a√∫n m√°s deprimente que a veces esto ocurra razonablemente.  Ahora la moda ya estaba dormida, pero hubo un momento en que todos corr√≠an con marcos, paradigmas y otras entidades, diciendo en voz alta que todo esto es s√∫per importante y s√∫per necesario, y a cambio recibieron una iron√≠a de que el front-end se ocupa de la salida de formularios y procesando clics en botones, que se pueden hacer "en la rodilla". <br><br>  Ahora, al parecer, todo ha vuelto m√°s o menos a la normalidad.  Nadie realmente quiere hablar sobre cada versi√≥n menor del pr√≥ximo marco.  Pocas personas buscan la herramienta o el enfoque perfecto, debido a la creciente conciencia de su utilidad.  Pero incluso esto, por ejemplo, no interfiere con el rega√±o casi irrazonable de Electron y sus aplicaciones.  Creo que esto se debe a la falta de comprensi√≥n de la tarea que est√° resolviendo el front-end. <br><br>  El frontend no es solo un medio para mostrar la informaci√≥n proporcionada por el backend, y no solo un medio para procesar las acciones del usuario.  La interfaz es algo m√°s, algo abstracto, y si le das una definici√≥n simple y clara, inevitablemente se perder√° el significado. <br><br>  La interfaz est√° en alg√∫n "marco".  Por ejemplo, en t√©rminos t√©cnicos, se encuentra entre la API proporcionada por el backend y la API proporcionada por las instalaciones de E / S.  En t√©rminos de tareas, UX resuelve entre las tareas de la interfaz de usuario y las tareas que resuelve el backend.  Por lo tanto, se obtiene una especializaci√≥n frontend bastante estrecha, una especializaci√≥n de la capa.  Esto no significa que los proveedores front-end no puedan ejercer influencia en √°reas fuera de su especializaci√≥n, pero en el momento en que esta influencia es imposible, surge la verdadera tarea front-end. <br><br>  Este problema puede expresarse a trav√©s de una contradicci√≥n.  No se requiere la interfaz de usuario para cumplir con los modelos de datos y el comportamiento del backend.  El comportamiento y los modelos de datos del backend no son necesarios para adaptarse a las tareas de la interfaz de usuario.  Y luego la tarea del front-end es eliminar esta contradicci√≥n.  Cuanto mayor sea la discrepancia entre las tareas del backend y la interfaz de usuario, m√°s importante ser√° el papel de la interfaz.  Y para dejar en claro de lo que estoy hablando, dar√© un ejemplo donde esta discrepancia, por alguna raz√≥n, result√≥ ser significativa. <br><br><h2>  Declaraci√≥n del problema. </h2><br>  OpenStack LBaaS, en mi opini√≥n, es un complejo de herramientas de hardware y software necesarias para equilibrar la carga entre servidores.  Para m√≠ es importante que su implementaci√≥n dependa de factores objetivos, de la visualizaci√≥n f√≠sica.  Debido a esto, hay algunas peculiaridades en la API y en las formas de interactuar con esta API. <br><br>  Al desarrollar una interfaz de usuario, el inter√©s principal no son las caracter√≠sticas t√©cnicas del backend, sino sus capacidades fundamentales.  La interfaz se crea para el usuario, y el usuario necesita una interfaz para administrar los par√°metros de equilibrio, y el usuario no necesita sumergirse en las caracter√≠sticas internas de la implementaci√≥n del backend. <br><br>  El backend est√° desarrollado en su mayor parte por la comunidad, y es posible influir en su desarrollo en cantidades muy limitadas.  Una de las caracter√≠sticas clave para m√≠ es que los desarrolladores de back-end est√°n listos para sacrificar la conveniencia y la simplicidad de los controles en aras del rendimiento, y esto est√° absolutamente justificado, ya que se trata de equilibrar la carga. <br><br>  Hay un punto m√°s sutil, y quiero resumirlo de inmediato, advirtiendo algunas preguntas.  Est√° claro que en OpenStack y su API la luz no convergi√≥.  Siempre puede desarrollar su propio conjunto de herramientas o una "capa" que funcionar√° con la API de OpenStack, produciendo su propia API, conveniente para las tareas del usuario.  La √∫nica pregunta es la conveniencia.  Si las herramientas inicialmente disponibles le permiten implementar la interfaz de usuario como estaba previsto, ¬øtiene sentido producir entidades? <br><br>  La respuesta a esta pregunta es multifac√©tica y para las empresas depender√° de los desarrolladores, su empleo, su competencia, cuestiones de responsabilidad, soporte, etc.  En nuestro caso, fue m√°s conveniente resolver algunas de las tareas en el front-end. <br><br><h3>  Caracter√≠sticas de OpenStack LBaaS </h3><br>  Quiero identificar solo aquellas caracter√≠sticas que han tenido una fuerte influencia en la interfaz.  Las preguntas sobre por qu√© surgieron estas caracter√≠sticas o en qu√© se basan ya est√°n fuera del alcance de este art√≠culo. <br><br>  Trabajo con documentaci√≥n preparada y tengo que aceptar sus caracter√≠sticas.  Aquellos que est√©n interesados ‚Äã‚Äãen lo que OpenStack Octavia es desde el interior pueden familiarizarse con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n oficial</a> .  Octavia es el nombre de un conjunto de herramientas dise√±adas para equilibrar la carga en el ecosistema OpenStack. <br><br>  La primera caracter√≠stica que encontr√© durante el desarrollo es la gran cantidad de modelos y relaciones necesarias para mostrar el estado del equilibrador.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de Octavia</a> describe 12 modelos, pero solo se necesitan 7 para el lado del cliente. Estos modelos tienen conexiones, a menudo desnormalizadas, la imagen a continuaci√≥n muestra un diagrama aproximado: <br><br><div style="text-align:center;"><img title="Diagrama de muestra de modelos y relaciones OpenStack Octavia" src="https://habrastorage.org/webt/p2/fw/2v/p2fw2vvyascudv9zjx5a0m-5bkq.png"></div><br><br>  "Siete" no suena muy impresionante, pero en realidad, para garantizar el funcionamiento completo de la interfaz, al momento de escribir este texto, tuve que usar 16 modelos de datos y unas 30 relaciones entre ellos.  Como Octavia es solo un equilibrador, requiere otros m√≥dulos OpenStack para funcionar.  Y todo esto es necesario para solo dos p√°ginas en la interfaz de usuario. <br><br>  Las caracter√≠sticas segunda y tercera son Octavia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">asincr√≥nicas</a> y transaccionales.  Los modelos de datos tienen un campo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estado</a> que refleja el estado de las operaciones realizadas en un objeto. <br><div class="scrollable-table"><table><tbody><tr><th>  Estado </th><th>  Descripci√≥n </th></tr><tr><td>  ACTIVO </td><td>  Objeto en buen estado </td></tr><tr><td>  BORRADO </td><td>  Objeto eliminado </td></tr><tr><td>  Error </td><td>  El objeto est√° da√±ado. </td></tr><tr><td>  PENDING_CREATE </td><td>  Objeto en la fabricaci√≥n </td></tr><tr><td>  PENDING_UPDATE </td><td>  Objeto en proceso de actualizaci√≥n </td></tr><tr><td>  PENDING_DELETE </td><td>  Objeto en proceso de borrado </td></tr></tbody></table></div>  La operaci√≥n de lectura de un objeto se produce sincr√≥nicamente y no tiene restricciones.  Pero las operaciones de creaci√≥n, actualizaci√≥n y eliminaci√≥n pueden llevar una cantidad de tiempo indefinida.  Esto se debe precisamente al hecho de que los modelos de datos tienen, en t√©rminos generales, un significado f√≠sico. <br><br>  Despu√©s de enviar una solicitud de creaci√≥n, podemos saber que el registro ha aparecido, podemos leerlo, pero hasta que se complete la operaci√≥n de creaci√≥n, no podemos realizar ninguna otra operaci√≥n en este registro.  Cualquier intento de este tipo dar√° como resultado un error.  La operaci√≥n de cambiar un objeto solo se puede iniciar cuando el objeto est√° en el estado <b>ACTIVO</b> ; puede enviar un objeto para su eliminaci√≥n en los estados <b>ACTIVO</b> y <b>ERROR</b> . <br><br>  Estos estados pueden venir a trav√©s de WebSockets, lo que facilita enormemente su procesamiento, pero las transacciones son un problema mucho mayor.  Al realizar cambios en cualquier objeto, todos los modelos relacionados tambi√©n participar√°n en la transacci√≥n.  Por ejemplo, al realizar cambios en <b>Member</b> , se bloquear√° el <b>Pool</b> , <b>Listener</b> y <b>Loadbalancer asociados</b> .  Esto es lo que parece en t√©rminos de eventos recibidos en sockets web: <br><br><div style="text-align:center;"><img title="El proceso de cambiar el estado de los objetos relacionados." src="https://habrastorage.org/webt/ia/fp/ff/iafpffzblzikgdekdrrs83br1_y.png"></div><ul><li>  los primeros cuatro eventos son la transferencia de objetos al estado <strong>PENDING_UPDATE</strong> : el campo de <strong>destino</strong> contiene el nombre del modelo del objeto que participa en la transacci√≥n; </li><li>  el quinto evento es solo un duplicado (no s√© con qu√© est√° conectado); </li><li>  los √∫ltimos cuatro es un retorno al estado <strong>ACTIVO</strong> .  En este caso, esta es una operaci√≥n de cambio de peso, y lleva menos de un segundo, pero a veces lleva mucho m√°s tiempo. </li></ul><br>  Tambi√©n puede ver en la captura de pantalla que el orden de los eventos no tiene que ser estricto.  Por lo tanto, resulta que para iniciar cualquier operaci√≥n, es necesario conocer no solo el estado del objeto en s√≠, sino tambi√©n los estados de todas las dependencias que tambi√©n participar√°n en la transacci√≥n. <br><br><h3>  Funciones de interfaz de usuario </h3><br>  Ahora imag√≠nese en el lugar de un usuario que necesita saber en alg√∫n lugar para equilibrar entre dos servidores: <br><br><ol><li>  Es necesario crear un oyente en el que se definir√° el algoritmo de equilibrio. </li><li>  Crea una piscina. </li><li>  Asigne un grupo al oyente. </li><li>  Agregue enlaces a puertos balanceados al grupo. </li></ol><br>  Cada vez es necesario esperar la finalizaci√≥n de la operaci√≥n, que depende de todos los objetos creados previamente. <br><br>  Como lo demostr√≥ un estudio interno, en opini√≥n del usuario com√∫n, solo hay una comprensi√≥n aproximada de que el equilibrador debe tener un punto de entrada, debe haber puntos de salida y los par√°metros del equilibrio a realizar: algoritmo, peso y otros.  El usuario no tiene que saber qu√© es OpenStack. <br><br>  No s√© cu√°n complicada deber√≠a ser la interfaz para la percepci√≥n, donde el usuario mismo debe seguir todas las caracter√≠sticas t√©cnicas del backend descrito anteriormente.  Para la consola, esto puede ser permisible, ya que su uso implica un alto nivel de inmersi√≥n en la tecnolog√≠a, pero para la web dicha interfaz es horrible. <br><br>  En la web, el usuario espera completar un formulario claro y l√≥gico, presionar un bot√≥n, esperar y todo funcionar√°.  Quiz√°s esto se pueda discutir, pero propongo concentrarme en las caracter√≠sticas que afectan la implementaci√≥n de la interfaz. <br><br>  La interfaz fue dise√±ada de tal manera que involucra el uso en cascada de las operaciones: una acci√≥n en la interfaz puede involucrar varias operaciones.  La interfaz no implica que el usuario pueda realizar acciones que actualmente no son posibles, pero supone que el usuario debe comprender por qu√© es as√≠.  La interfaz es un todo √∫nico y, por lo tanto, sus elementos individuales pueden usar informaci√≥n de varias entidades dependientes, incluida la metainformaci√≥n. <br><br><div style="text-align:center;"><img title="La interfaz de la lista de equilibradores en el panel Selectel" src="https://habrastorage.org/webt/cc/no/am/ccnoamyjre40swvpswygbqezn_w.png"></div><br><br>  Si tenemos en cuenta que hay algunas caracter√≠sticas de la interfaz que no son exclusivas del equilibrador, como interruptores, acordeones, pesta√±as, un men√∫ contextual y asumimos que sus principios operativos son claros inicialmente, entonces creo que para un usuario que sabe qu√© es el equilibrio de carga, no Ser√° muy dif√≠cil leer la mayor parte de la interfaz anterior y hacer una suposici√≥n sobre c√≥mo administrarla.  Pero resaltar qu√© partes de la interfaz est√°n ocultas detr√°s de los modelos del equilibrador, el oyente, el grupo, los miembros y otras entidades ya no es la tarea m√°s obvia. <br><br><h3>  Resolviendo contradicciones </h3><br>  Espero haber podido demostrar que las caracter√≠sticas del backend no se ajustan bien a la interfaz y que el backend no siempre puede eliminar estas caracter√≠sticas.  Junto con esto, las caracter√≠sticas de la interfaz no encajan bien en el backend, y tampoco siempre se pueden eliminar sin complicar la interfaz.  Cada una de estas √°reas resuelve sus propios problemas.  La responsabilidad del front-end es resolver problemas para garantizar el nivel necesario de interacci√≥n entre la interfaz y el back-end. <br><br>  En mi pr√°ctica, inmediatamente corr√≠ a la piscina con la cabeza, sin prestar atenci√≥n, o mejor dicho, ni siquiera tratando de descubrir esas caracter√≠sticas que son m√°s altas, pero tuve suerte o la experiencia ayud√≥ (y se eligi√≥ el vector correcto).  Me he dado cuenta repetidamente de m√≠ mismo que cuando utilizo una API o biblioteca de terceros, es muy √∫til familiarizarse con la documentaci√≥n de antemano: cuantos m√°s detalles, mejor.  La documentaci√≥n a menudo es similar entre s√≠, las personas a√∫n conf√≠an en la experiencia de otras personas, pero hay una descripci√≥n de las caracter√≠sticas de cada sistema individual y est√° contenida en los detalles. <br><br>  Si inicialmente pas√© un par de horas adicionales estudiando la documentaci√≥n, en lugar de extraer la informaci√≥n necesaria por palabras clave, habr√≠a pensado en los problemas que tendr√≠an que enfrentar, y este conocimiento podr√≠a tener un impacto en la arquitectura del proyecto desde las primeras etapas.  Volver a eliminar los errores cometidos al principio es muy desmoralizador.  Y sin un contexto completo, a veces tienes que volver varias veces. <br><br>  Como opci√≥n, puede doblar su l√≠nea, generando gradualmente m√°s y m√°s c√≥digo "con un mordisco", pero cuanto m√°s este mont√≥n de c√≥digo sea, m√°s ser√° rastrillado al final.  Al dise√±ar la arquitectura, por supuesto, uno no debe sumergirse demasiado profundamente, tener en cuenta todas las opciones posibles e imposibles, pasar una gran cantidad de tiempo en ella, es importante encontrar un equilibrio.  Pero el conocimiento m√°s o menos detallado de la documentaci√≥n a menudo demuestra ser una inversi√≥n muy √∫til de no mucho tiempo. <br><br>  Sin embargo, desde el principio, habiendo visto una gran cantidad de modelos involucrados, me di cuenta de que ser√≠a necesario construir un mapeo del estado del backend al cliente con todas las conexiones preservadas.  Despu√©s de que logr√© mostrar toda la informaci√≥n necesaria en el cliente, con todas las conexiones, etc., fue necesario organizar una cola de tareas. <br><br>  Los datos se actualizan de forma as√≠ncrona, la disponibilidad de las operaciones est√° determinada por una variedad de condiciones, y cuando se requieren operaciones en cascada, no se puede prescindir de la cola en tales condiciones.  Quiz√°s, en pocas palabras, esta es toda la arquitectura de mi soluci√≥n: almacenamiento con un reflejo del estado del backend y la cola de tareas. <br><br><h2>  Arquitectura de soluciones </h2><br>  Debido a la cantidad indefinida de modelos y relaciones, pongo escalabilidad en la estructura del repositorio al hacer esto usando una f√°brica que devuelve una descripci√≥n declarativa de las colecciones del repositorio.  La colecci√≥n tiene un servicio, una clase de modelo simple con CRUD.  Ser√≠a posible hacer una descripci√≥n de los enlaces en el modelo, como se hace, por ejemplo, en RoR o en el antiguo Backbone, pero esto requerir√≠a una gran cantidad de c√≥digo para cambiar.  Por lo tanto, la descripci√≥n de las relaciones se encuentra al lado de la clase de modelo: <br><br><div style="text-align:center;"><img title="Ejemplo de descripci√≥n de enlace" src="https://habrastorage.org/webt/_y/jw/pr/_yjwpryzsckc_by0igzpq5vlog0.png"></div><br><br>  En total, obtuve 2 tipos de conexiones: una a una, una a muchas.  La retroalimentaci√≥n tambi√©n se puede describir.  Adem√°s del tipo, se indica la colecci√≥n de dependencias, el campo al que se adjunta la dependencia encontrada y el campo desde el que se lee la ID del objeto dependiente (en caso de comunicaci√≥n uno a muchos, se lee la lista de ID).  Si la condici√≥n de comunicaci√≥n de un objeto es m√°s complicada que los simples enlaces a objetos, entonces en la f√°brica se puede describir la funci√≥n de probar dos objetos, cuyos resultados determinar√°n la presencia de una conexi√≥n.  Todo parece un poco "bicicleta", pero funciona sin dependencias innecesarias y exactamente como deber√≠a. <br><br>  El repositorio tiene un m√≥dulo para esperar para agregar y eliminar un recurso, en esencia est√° procesando eventos √∫nicos con verificaci√≥n condicional y con una interfaz promis.  Al suscribirse, se pasa el tipo de evento (agregar, eliminar), la funci√≥n de prueba y el controlador.  Cuando se produce un determinado evento y con un resultado de prueba positivo, se ejecuta el controlador, despu√©s de lo cual se detiene el seguimiento.  Un evento puede ocurrir al suscribirse sincr√≥nicamente. <br><br>  El uso de dicho patr√≥n permiti√≥ fijar autom√°ticamente relaciones complejas arbitrariamente entre modelos y hacerlo en un solo lugar.  Este lugar lo llam√© rastreador.  Al agregar un objeto al repositorio, comienza a rastrear sus relaciones.  El m√≥dulo de espera le permite responder a eventos y verificar una conexi√≥n entre el objeto monitoreado y el objeto en el almacenamiento.  Si el objeto ya estaba en el repositorio, el m√≥dulo de espera llama al manejador inmediatamente. <br><br>  Tal dispositivo de almacenamiento le permite describir cualquier cantidad de colecciones y las relaciones entre ellas.  Al agregar y eliminar objetos, la tienda coloca o restablece autom√°ticamente las propiedades con el contenido de los objetos dependientes.  Las ventajas de este enfoque son que todas las relaciones se describen expl√≠citamente, y son monitoreadas y actualizadas por un sistema;  contras - en la complejidad de la implementaci√≥n y depuraci√≥n. <br><br>  En general, dicho repositorio es bastante trivial y lo hice yo mismo, porque ser√≠a mucho m√°s dif√≠cil integrar una soluci√≥n preparada en una base de c√≥digo existente, pero ser√≠a a√∫n m√°s dif√≠cil adjuntar una cola de tareas a una soluci√≥n preparada. <br><br>  Todas las tareas, como las colecciones, tienen una descripci√≥n declarativa y son creadas por la f√°brica.  Las tareas pueden tener en la descripci√≥n las condiciones para comenzar y una lista de tareas que deber√°n agregarse a la cola una vez completada la actual. <br><br><div style="text-align:center;"><img title="Un ejemplo de generar una tarea para crear un grupo" src="https://habrastorage.org/webt/03/7w/fo/037wfo0c0fn7uxeblixnsahw7j8.png"></div><br>  El ejemplo anterior describe la tarea de crear un grupo.  En las dependencias, el equilibrador y el oyente est√°n indicados, de forma predeterminada, se realiza una verificaci√≥n del estado <b>ACTIVO</b> .  El objeto del equilibrador est√° bloqueado, ya que las tareas de procesamiento en la cola pueden ocurrir sincr√≥nicamente, el bloqueo le permite evitar conflictos en el momento en que se envi√≥ la solicitud de ejecuci√≥n, pero el estado no ha cambiado, pero se supone que cambiar√°.  En lugar de <b>PADRE</b> , si el grupo se crea como resultado de la cascada de tareas, la <b>ID</b> se sustituir√° autom√°ticamente. <br><br>  Despu√©s de crear un grupo, se agregar√°n tareas a la cola para crear un monitor de disponibilidad y crear todos los miembros de este grupo.  El resultado es una estructura que se puede convertir completamente a JSON.  Esto se hace para poder restaurar la cola en caso de falla. <br><br>  La cola, basada en la descripci√≥n de la tarea, monitorea independientemente todos los cambios en el repositorio y verifica las condiciones que deben cumplirse para ejecutar la tarea.  Como ya dije, los estados provienen de los sockets web, y es muy simple generar los eventos necesarios para la cola, pero si es necesario, no ser√° un problema adjuntar un mecanismo de actualizaci√≥n de datos del temporizador (esto se estableci√≥ originalmente en la arquitectura, ya que los sockets web eran por varias razones puede no funcionar muy estable).  Una vez completada la tarea, la cola informa autom√°ticamente al repositorio sobre la necesidad de actualizar los enlaces en los objetos especificados. <br><br><h2>  Conclusi√≥n </h2><br>  La necesidad de escalabilidad ha llevado a un enfoque declarativo.  La necesidad de mostrar modelos y las relaciones entre ellos ha llevado a un √∫nico repositorio.  La necesidad de procesar objetos dependientes ha llevado a la cola. <br><br>  La combinaci√≥n de estas necesidades puede no ser la tarea m√°s f√°cil en t√©rminos de implementaci√≥n (pero este es un tema aparte).  Pero en t√©rminos de arquitectura, la soluci√≥n es muy simple y le permite eliminar todas las contradicciones entre las tareas del backend y la interfaz de usuario, establecer su interacci√≥n y sentar las bases para otras caracter√≠sticas posibles de cualquiera de las partes. <br><br>  Desde el lado del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">panel de control de</a> Selectel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> el proceso de equilibrio es simple y directo, lo que permite a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los</a> clientes del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">servicio</a> no gastar recursos en la implementaci√≥n independiente del equilibrador, mientras se mantiene la capacidad de administrar el tr√°fico de manera flexible. <br><br>  Pruebe nuestro equilibrador en acci√≥n ahora y escriba su opini√≥n en los comentarios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455523/">https://habr.com/ru/post/455523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455511/index.html">El sue√±o es el principal recurso para el cerebro de un programador.</a></li>
<li><a href="../455513/index.html">La explosi√≥n y la conspiraci√≥n global: la historia de la creaci√≥n de bater√≠as de iones de litio</a></li>
<li><a href="../455515/index.html">Invertir y piratear el HDD externo de autocifrado de Aigo. Parte 1: disecci√≥n en partes</a></li>
<li><a href="../455517/index.html">Graduado del curso de Netolog√≠a ‚ÄúData Science‚Äù sobre su trabajo en el sector bancario.</a></li>
<li><a href="../455519/index.html">C√≥mo implementamos la incorporaci√≥n de nuevos desarrolladores</a></li>
<li><a href="../455525/index.html">Zimbra y Mail Bomb Defense</a></li>
<li><a href="../455527/index.html">¬øQu√© est√° escrito en esto? Detr√°s de escena de objetos JavaScript</a></li>
<li><a href="../455529/index.html">Invertir y piratear el HDD externo de autocifrado de Aigo. Parte 2: Dumping con Cypress PSoC</a></li>
<li><a href="../455533/index.html">Bubble Physics: A Search for Foam Destruction Mechanism</a></li>
<li><a href="../455535/index.html">Administrar certificados SSL / TLS en las nubes y contenedores, no trabajo humano</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>