<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏒 🎽 🙏🏿 Neuronales Netzwerk zur Klassifizierung von Satellitenbildern mit Tensorflow in Python ⛹🏼 💆🏿 🅱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist eine schrittweise Anleitung zur Klassifizierung multispektraler Bilder vom Landsat 5-Satelliten. In einer Reihe von Bereichen dominiert heute...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Neuronales Netzwerk zur Klassifizierung von Satellitenbildern mit Tensorflow in Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jetinfosystems/blog/468973/"><img src="https://habrastorage.org/webt/uq/qc/uz/uqqcuz2dhxwps1cueikg6ceigja.jpeg"><br><br>  Dies ist eine schrittweise Anleitung zur Klassifizierung multispektraler Bilder vom Landsat 5-Satelliten. In einer Reihe von Bereichen dominiert heute das tiefe Lernen als Werkzeug zur Lösung komplexer Probleme, einschließlich geografischer Probleme.  Ich hoffe, Sie sind mit Satellitendatensätzen vertraut, insbesondere mit Landsat 5 TM.  Wenn Sie mit Algorithmen für maschinelles Lernen ein wenig vertraut sind, können Sie dieses Handbuch schnell erlernen.  Und für diejenigen, die nicht verstehen, ist es ausreichend zu wissen, dass maschinelles Lernen tatsächlich darin besteht, Beziehungen zwischen mehreren Merkmalen (einer Menge von Attributen X) eines Objekts mit seiner anderen Eigenschaft (Wert oder Bezeichnung, die Zielvariable Y) herzustellen.  Wir füttern das Modell mit vielen Objekten, für die die Eigenschaften und der Wert des Zielindikators / der Zielklasse des Objekts bekannt sind (beschriftete Daten), und trainieren es so, dass es den Wert der Zielvariablen Y für neue Daten vorhersagen kann (nicht markiert). <br><a name="habracut"></a><br>  Was ist das Hauptproblem bei Satellitenbildern? <br><br>  Zwei oder mehr Klassen von Objekten (z. B. Gebäude, Baulücken und Fundamentgruben) in Satellitenbildern können die gleichen spektralen Eigenschaften des Werts aufweisen. Daher war ihre Klassifizierung in den letzten zwanzig Jahren eine schwierige Aufgabe. <br><br>  Aus diesem Grund ist es möglich, klassische Modelle des maschinellen Lernens mit und ohne Lehrer zu verwenden, aber ihre Qualität ist alles andere als ideal.  Sie haben immer die gleichen Nachteile.  Betrachten Sie ein Beispiel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/15b/16c/5b7/15b16c5b76906f81f27374daa8558806.jpg"><br><br>  Wenn Sie eine vertikale Linie als Klassifikator verwenden und entlang der X-Achse verschieben, ist das Klassifizieren von Bildern von Häusern nicht einfach.  Die Daten werden so verteilt, dass es unmöglich ist, sie mit einer vertikalen Linie in Klassen zu unterteilen (in solchen Fällen heißt es, dass "Objekte verschiedener Klassen nicht linear trennbar sind").  Dies bedeutet jedoch nicht, dass Häuser überhaupt nicht klassifiziert werden können! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc4/ea7/7a0/cc4ea77a0f9f4713ea6a49b7885d31c2.gif"><br><br>  Verwenden wir die rote Linie, um die beiden Klassen zu trennen.  In diesem Fall identifizierte der Klassifizierer die meisten Häuser, aber ein Haus wurde nicht seiner Klasse zugeordnet, und drei weitere Bäume wurden fälschlicherweise den "Häusern" zugeordnet.  Um kein einziges Haus zu verpassen, können Sie den Klassifikator in Form einer blauen Linie verwenden.  Dann wird zu Hause alles abgedeckt, dh wir sagen, dass die Rückrufmetrik (Fülle) hoch ist.  Es stellte sich jedoch heraus, dass nicht alle klassifizierten Werte Häuser waren, dh gleichzeitig erhielten wir einen niedrigen Wert der Präzisionsmetrik.  Wenn wir die grüne Linie verwenden, sind alle als Häuser klassifizierten Bilder tatsächlich Häuser, dh der Klassifikator zeigt eine hohe Genauigkeit.  In diesem Fall ist die Fülle geringer, da die drei Häuser nicht berücksichtigt werden.  In den meisten Fällen müssen wir einen Kompromiss zwischen Genauigkeit und Vollständigkeit finden. <br><br>  Dieses Problem von Häusern und Bäumen ähnelt dem Problem von Gebäuden, unbebauten Grundstücken und Gruben.  Die Priorität der Klassifizierungsmetriken für Satellitenbilder kann je nach Aufgabe variieren.  Wenn Sie beispielsweise sicherstellen müssen, dass alle bebauten Gebiete ausnahmslos als Gebäude klassifiziert sind und Sie bereit sind, Pixel anderer Klassen mit ähnlichen Signaturen zu akzeptieren, die ebenfalls als Gebäude klassifiziert werden, benötigen Sie ein Modell mit hoher Vollständigkeit.  Wenn es für Sie wichtiger ist, ein Gebäude zu klassifizieren, ohne Pixel anderer Klassen hinzuzufügen, und Sie bereit sind, die Klassifizierung gemischter Gebiete aufzugeben, wählen Sie einen Klassifizierer mit hoher Genauigkeit.  Bei Häusern und Bäumen verwendet das übliche Modell die rote Linie, um ein Gleichgewicht zwischen Genauigkeit und Vollständigkeit zu gewährleisten. <br><br><h2>  Verwendete Daten </h2><br>  Als Zeichen werden wir die Werte von sechs Bereichen (Band 2 - Band 7) des Bildes aus Landsat 5 TM verwenden und versuchen, die binäre Entwicklungsklasse vorherzusagen.  Für Schulungen und Tests werden multispektrale Daten (Bilder und eine Ebene mit einer binären Gebäudeklasse) mit Landsat 5 für 2011 für Bangalore verwendet.  Und für die Vorhersage werden multispektrale Landsat 5-Daten verwendet, die 2005 in Hyderabad erhalten wurden. <br>  Da wir für den Unterricht markierte Daten verwenden, wird dies als Unterricht mit dem Lehrer bezeichnet. <br><br><img src="https://habrastorage.org/webt/c4/nx/71/c4nx71fzbix6rhp4fb1-ofdupjm.jpeg"><br><br>  <i>Multispektrale Trainingsdaten und die entsprechende binäre Schicht mit Entwicklung.</i> <br><br>  Um ein neuronales Netzwerk zu erstellen, verwenden wir Python - die Google Tensorflow-Bibliothek.  Wir werden auch diese Bibliotheken brauchen: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>pyrsgis</i></a> - zum Lesen und Schreiben von GeoTIFF. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>scikit-learn</i></a> - zur Datenvorverarbeitung und Genauigkeitsbewertung. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>numpy</i></a> - für grundlegende Operationen mit Arrays. <br></li></ol><br>  Und jetzt schreiben wir ohne weiteres den Code. <br><br>  Legen Sie alle drei Dateien in einem Verzeichnis ab, schreiben Sie den Pfad und die Namen der Eingabedateien in das Skript und lesen Sie dann die GeoTIFF-Dateien. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyrsgis <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> raster os.chdir(<span class="hljs-string"><span class="hljs-string">"E:\\yourDirectoryName"</span></span>) mxBangalore = <span class="hljs-string"><span class="hljs-string">'l5_Bangalore2011_raw.tif'</span></span> builtupBangalore = <span class="hljs-string"><span class="hljs-string">'l5_Bangalore2011_builtup.tif'</span></span> mxHyderabad = <span class="hljs-string"><span class="hljs-string">'l5_Hyderabad2011_raw.tif'</span></span> <span class="hljs-comment"><span class="hljs-comment"># Read the rasters as array ds1, featuresBangalore = raster.read(mxBangalore, bands='all') ds2, labelBangalore = raster.read(builtupBangalore, bands=1) ds3, featuresHyderabad = raster.read(mxHyderabad, bands='all')</span></span></code> </pre> <br>  Das <code>raster</code> Modul aus dem <code>pyrsgis</code> Paket liest GeoTIFF- <code>pyrsgis</code> und DN-Werte (Digital Number) als separate NumPy-Arrays.  Wenn Sie an Details interessiert sind, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Jetzt zeigen wir die Größe der gelesenen Daten an. <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"Bangalore multispectral image shape: "</span></span>, featuresBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Bangalore binary built-up image shape: "</span></span>, labelBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Hyderabad multispectral image shape: "</span></span>, featuresHyderabad.shape)</code> </pre> <br>  Ergebnis: <br><br><pre> <code class="python hljs">Bangalore multispectral image shape: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2054</span></span>, <span class="hljs-number"><span class="hljs-number">2044</span></span> Bangalore binary built-up image shape: <span class="hljs-number"><span class="hljs-number">2054</span></span>, <span class="hljs-number"><span class="hljs-number">2044</span></span> Hyderabad multispectral image shape: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1318</span></span>, <span class="hljs-number"><span class="hljs-number">1056</span></span></code> </pre> <br>  Wie Sie sehen können, haben die Bilder von Bangalore die gleiche Anzahl von Zeilen und Spalten wie in der Binärebene (entsprechend dem Gebäude).  Die Anzahl der Schichten in multispektralen Bildern in Bangalore und Hyderabad stimmt ebenfalls überein.  Das Modell lernt anhand der entsprechenden Werte für alle 6 Spektren zu entscheiden, welche Pixel zum Gebäude gehören und welche nicht.  Daher müssen multispektrale Bilder dieselbe Anzahl von Merkmalen (Bereichen) aufweisen, die in derselben Reihenfolge aufgeführt sind. <br><br>  Jetzt verwandeln wir die Arrays in zweidimensionale Arrays, wobei jede Zeile ein separates Pixel darstellt, da dies für den Betrieb der meisten Algorithmen für maschinelles Lernen erforderlich ist.  Wir werden dies mit dem <code>convert</code> aus dem <code>pyrsgis</code> Paket <code>pyrsgis</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d69/176/b91/d69176b91e9758291e1faae6c25486e5.jpg"><br>  <i>Datenumstrukturierungsschema.</i> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyrsgis.convert <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> changeDimension featuresBangalore = changeDimension(featuresBangalore) labelBangalore = changeDimension (labelBangalore) featuresHyderabad = changeDimension(featuresHyderabad) nBands = featuresBangalore.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] labelBangalore = (labelBangalore == <span class="hljs-number"><span class="hljs-number">1</span></span>).astype(int) print(<span class="hljs-string"><span class="hljs-string">"Bangalore multispectral image shape: "</span></span>, featuresBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Bangalore binary built-up image shape: "</span></span>, labelBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Hyderabad multispectral image shape: "</span></span>, featuresHyderabad.shape)</code> </pre> <br>  Ergebnis: <br><br><pre> <code class="python hljs">Bangalore multispectral image shape: <span class="hljs-number"><span class="hljs-number">4198376</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> Bangalore binary built-up image shape: <span class="hljs-number"><span class="hljs-number">4198376</span></span> Hyderabad multispectral image shape: <span class="hljs-number"><span class="hljs-number">1391808</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  In der siebten Zeile haben wir alle Pixel mit dem Wert 1 extrahiert. Dies hilft, Probleme mit Pixeln ohne Informationen (NoData) zu vermeiden, die häufig extrem hohe oder niedrige Werte aufweisen. <br>  Jetzt werden wir die Daten in Trainings- und Validierungsbeispiele aufteilen.  Dies ist erforderlich, damit das Modell die Testdaten nicht sieht und mit den neuen Informationen genauso gut funktioniert.  Andernfalls wird das Modell umgeschult und funktioniert nur mit Trainingsdaten. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> train_test_split xTrain, xTest, yTrain, yTest = train_test_split(featuresBangalore, labelBangalore, test_size=<span class="hljs-number"><span class="hljs-number">0.4</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">42</span></span>) print(xTrain.shape) print(yTrain.shape) print(xTest.shape) print(yTest.shape)</code> </pre> <br>  Ergebnis: <br><br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">2519025</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">2519025</span></span>,) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>,) test_size=<span class="hljs-number"><span class="hljs-number">0.4</span></span></code> </pre> <br>  bedeutet, dass die Daten in einem Verhältnis von 60/40 in Training und Validierung unterteilt sind. <br>  Viele Algorithmen für maschinelles Lernen, einschließlich neuronaler Netze, benötigen normalisierte Daten.  Dies bedeutet, dass sie innerhalb eines bestimmten Bereichs (in diesem Fall von 0 bis 1) verteilt werden müssen.  Um diese Anforderung zu erfüllen, normalisieren wir daher die Symptome.  Dies kann erreicht werden, indem der Minimalwert extrahiert und dann durch den Spread dividiert wird (die Differenz zwischen den Maximal- und Minimalwerten).  Da der Landsat-Datensatz 8-Bit ist, sind die Minimal- und Maximalwerte 0 und 255 (2 <sup>⁸</sup> = 256 Werte). <br><br>  Beachten Sie, dass es für die Normalisierung immer besser ist, die Minimal- und Maximalwerte basierend auf den Daten zu berechnen.  Um die Aufgabe zu vereinfachen, halten wir uns standardmäßig an den 8-Bit-Bereich. <br><br>  Eine weitere Stufe der Vorverarbeitung ist die Transformation der Attributmatrix von zweidimensional zu dreidimensional, sodass das Modell jede Zeile als separates Pixel (separates Lernobjekt) wahrnimmt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/965/d0f/aa8/965d0faa8e8c7b4787c10823cf038d20.jpg"><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Normalise the data xTrain = xTrain / 255.0 xTest = xTest / 255.0 featuresHyderabad = featuresHyderabad / 255.0 # Reshape the data xTrain = xTrain.reshape((xTrain.shape[0], 1, xTrain.shape[1])) xTest = xTest.reshape((xTest.shape[0], 1, xTest.shape[1])) featuresHyderabad = featuresHyderabad.reshape((featuresHyderabad.shape[0], 1, featuresHyderabad.shape[1])) # Print the shape of reshaped data print(xTrain.shape, xTest.shape, featuresHyderabad.shape)</span></span></code> </pre> <br>  Ergebnis: <br><br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">2519025</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1391808</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre> <br>  Alles ist fertig, lassen Sie uns unser Modell mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Keras zusammenbauen</a> .  Verwenden Sie zunächst das sequentielle Modell und fügen Sie nacheinander Ebenen hinzu.  Wir werden eine Eingabeebene haben, deren Anzahl der Knoten der Anzahl der Bereiche ( <code>nBands</code> ) entspricht - in unserem Fall sind es 6. Wir werden auch eine versteckte Ebene mit 14 Knoten und der <code>ReLu</code> Aktivierungsfunktion <code>ReLu</code> .  Die letzte Schicht besteht aus zwei Knoten zum Definieren einer binären Gebäudeklasse mit der <code>softmax</code> Aktivierungsfunktion, die zum Anzeigen eines kategorisierten Ergebnisses geeignet ist.  Lesen Sie hier mehr über Aktivierungsfunktionen. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras <span class="hljs-comment"><span class="hljs-comment"># Define the parameters of the model model = keras.Sequential([ keras.layers.Flatten(input_shape=(1, nBands)), keras.layers.Dense(14, activation='relu'), keras.layers.Dense(2, activation='softmax')]) # Define the accuracy metrics and parameters model.compile(optimizer="adam", loss="sparse_categorical_crossentropy", metrics=["accuracy"]) # Run the model model.fit(xTrain, yTrain, epochs=2)</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/d8a/9cd/5ec/d8a9cd5ec53c57d671d77b0c46bfb17e.png"><br>  <i>Neuronale Netzwerkarchitektur</i> <br><br>  Wie in Zeile 10 erwähnt, geben wir <code>adam</code> als Modelloptimierer an (es gibt mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> ).  In diesem Fall verwenden wir die Kreuzentropie als Verlustfunktion (en. <code>categorical-sparse-crossentropy</code> - mehr dazu finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  Um die Qualität des Modells zu beurteilen, verwenden wir die <code>accuracy</code> . <br><br>  Schließlich werden wir beginnen, unser Modell für zwei Epochen (oder Iterationen) auf <code>xTrain</code> und <code>yTrain</code> .  Dies kann je nach Datengröße und Verarbeitungsleistung einige Zeit dauern.  Folgendes sehen Sie nach der Kompilierung: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfa/3fc/c47/dfa3fcc47572b2fd20c5252ba4da1e50.png"><br><br>  Lassen Sie uns die Werte für die Validierungsdaten vorhersagen, die wir separat speichern, und verschiedene Genauigkeitsmetriken berechnen. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.metrics <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> confusion_matrix, precision_score, recall_score <span class="hljs-comment"><span class="hljs-comment"># Predict for test data yTestPredicted = model.predict(xTest) yTestPredicted = yTestPredicted[:,1] # Calculate and display the error metrics yTestPredicted = (yTestPredicted&gt;0.5).astype(int) cMatrix = confusion_matrix(yTest, yTestPredicted) pScore = precision_score(yTest, yTestPredicted) rScore = recall_score(yTest, yTestPredicted) print("Confusion matrix: for 14 nodes\n", cMatrix) print("\nP-Score: %.3f, R-Score: %.3f" % (pScore, rScore))</span></span></code> </pre> <br>  Die <code>softmax</code> Funktion generiert separate Spalten für Wahrscheinlichkeitswerte für jede Klasse.  Wir verwenden nur die Werte für die erste Klasse ("es gibt ein Gebäude"), wie aus der sechsten Zeile des obigen Codes ersichtlich ist.  Die Bewertung der Arbeit von Geodatenanalysemodellen ist im Gegensatz zu anderen klassischen Problemen des maschinellen Lernens nicht so einfach.  Es ist unfair, sich auf einen allgemeinen Gesamtfehler zu verlassen.  Der Schlüssel zu einem erfolgreichen Modell ist die räumliche Anordnung.  Somit können die Verwirrungsmatrix, Genauigkeit und Vollständigkeit eine korrektere Vorstellung von der Qualität des Modells geben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/399/3d8/bf3/3993d8bf36a5f4165b60f39e36e5c566.jpg"><br>  <i>Die Konsole zeigt also die Fehlermatrix, Genauigkeit und Vollständigkeit an.</i> <br><br>  Wie Sie der Verwirrungsmatrix entnehmen können, gibt es Tausende von Pixeln, die sich auf Gebäude beziehen, aber unterschiedlich klassifiziert sind und umgekehrt.  Ihr Anteil am gesamten Datenvolumen ist jedoch nicht zu groß.  Die Genauigkeit und Vollständigkeit der Testdaten hat den Schwellenwert von 0,8 überschritten. <br><br>  Sie können mehr Zeit aufwenden und mehrere Iterationen durchführen, um die optimale Anzahl versteckter Ebenen, die Anzahl der Knoten in jeder verborgenen Ebene sowie die Anzahl der Epochen zu ermitteln, um die gewünschte Genauigkeit zu erzielen.  Bei Bedarf können Fernerkundungsindizes wie NDBI oder NDWI als Funktionen verwendet werden.  Wenn Sie die gewünschte Genauigkeit erreicht haben, verwenden Sie das Modell, um die Entwicklung basierend auf neuen Daten vorherzusagen und das Ergebnis in GeoTIFF zu exportieren.  Für solche Aufgaben können Sie ein ähnliches Modell mit geringfügigen Änderungen verwenden. <br><br><pre> <code class="python hljs">predicted = model.predict(feature2005) predicted = predicted[:,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-comment"><span class="hljs-comment">#Export raster prediction = np.reshape(predicted, (ds.RasterYSize, ds.RasterXSize)) outFile = 'Hyderabad_2011_BuiltupNN_predicted.tif' raster.export(prediction, ds3, filename=outFile, dtype='float')</span></span></code> </pre> <br>  Bitte beachten Sie, dass wir GeoTIFF mit vorhergesagten Wahrscheinlichkeitswerten und nicht mit ihrer binärisierten Version exportieren.  Später in der GIS-Umgebung können wir den Schwellenwert für eine Ebene vom Typ float festlegen, wie in der folgenden Abbildung dargestellt. <br><br><img src="https://habrastorage.org/webt/sk/ka/kz/skkakzxokrbkvrgulcvm0vkuwua.jpeg"><br>  <i>Vom Modell auf der Grundlage multispektraler Daten vorhergesagte Hyderabad-Aufbauschicht.</i> <br><br>  Die Modellgenauigkeit wurde bereits mit Präzision und Rückruf gemessen.  Sie können auch herkömmliche Überprüfungen (z. B. mithilfe des Kappa-Koeffizienten) für eine neue vorhergesagte Ebene durchführen.  Zusätzlich zu den oben genannten Schwierigkeiten bei der Klassifizierung von Satellitenbildern umfassen andere offensichtliche Einschränkungen die Unmöglichkeit der Vorhersage auf der Grundlage von Bildern, die zu verschiedenen Jahreszeiten und in verschiedenen Regionen aufgenommen wurden, da sie unterschiedliche spektrale Signaturen aufweisen. <br><br>  Das in diesem Artikel beschriebene Modell hat die einfachste Architektur für neuronale Netze.  Bessere Ergebnisse können mit komplexeren Modellen erzielt werden, einschließlich Faltungs-Neuronalen Netzen.  Der Hauptvorteil einer solchen Klassifizierung ist ihre Skalierbarkeit (Anwendbarkeit) nach dem Training des Modells. <br><br>  Die verwendeten Daten und der gesamte Code sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468973/">https://habr.com/ru/post/de468973/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468961/index.html">Wie kann man die Routine im Leben für 560 Dollar loswerden? Oder wie man lebt, nicht lebt</a></li>
<li><a href="../de468963/index.html">Backup, Teil auf Wunsch der Leser: UrBackup-Übersicht, BackupPC, AMANDA</a></li>
<li><a href="../de468967/index.html">"Technologie" zum Erhalten von Gleichungen der Dynamik von TAU. Und warum ist Systemidentifikation scheiße und "ehrliche Physik" Regeln</a></li>
<li><a href="../de468969/index.html">Erstellen Sie Google-Nutzer aus PowerShell über die API</a></li>
<li><a href="../de468971/index.html">Schreiben in Java für Nintendo DS</a></li>
<li><a href="../de468989/index.html">UEBA-Markt stirbt - Es lebe die UEBA</a></li>
<li><a href="../de468991/index.html">Modulare Sprite-Charaktere und ihre Animation</a></li>
<li><a href="../de468993/index.html">Oculus Quest stellt eine Verbindung zu einem PC her und sieht Hände</a></li>
<li><a href="../de468995/index.html">Offenheitsrichtlinie: Wie Benutzer das Projekt beeinflussen</a></li>
<li><a href="../de468997/index.html">Mentoring - ein Muss oder ein schöner Bonus?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>