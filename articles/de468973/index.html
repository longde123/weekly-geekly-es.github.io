<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèí üéΩ üôèüèø Neuronales Netzwerk zur Klassifizierung von Satellitenbildern mit Tensorflow in Python ‚õπüèº üíÜüèø üÖ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist eine schrittweise Anleitung zur Klassifizierung multispektraler Bilder vom Landsat 5-Satelliten. In einer Reihe von Bereichen dominiert heute...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Neuronales Netzwerk zur Klassifizierung von Satellitenbildern mit Tensorflow in Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jetinfosystems/blog/468973/"><img src="https://habrastorage.org/webt/uq/qc/uz/uqqcuz2dhxwps1cueikg6ceigja.jpeg"><br><br>  Dies ist eine schrittweise Anleitung zur Klassifizierung multispektraler Bilder vom Landsat 5-Satelliten. In einer Reihe von Bereichen dominiert heute das tiefe Lernen als Werkzeug zur L√∂sung komplexer Probleme, einschlie√ülich geografischer Probleme.  Ich hoffe, Sie sind mit Satellitendatens√§tzen vertraut, insbesondere mit Landsat 5 TM.  Wenn Sie mit Algorithmen f√ºr maschinelles Lernen ein wenig vertraut sind, k√∂nnen Sie dieses Handbuch schnell erlernen.  Und f√ºr diejenigen, die nicht verstehen, ist es ausreichend zu wissen, dass maschinelles Lernen tats√§chlich darin besteht, Beziehungen zwischen mehreren Merkmalen (einer Menge von Attributen X) eines Objekts mit seiner anderen Eigenschaft (Wert oder Bezeichnung, die Zielvariable Y) herzustellen.  Wir f√ºttern das Modell mit vielen Objekten, f√ºr die die Eigenschaften und der Wert des Zielindikators / der Zielklasse des Objekts bekannt sind (beschriftete Daten), und trainieren es so, dass es den Wert der Zielvariablen Y f√ºr neue Daten vorhersagen kann (nicht markiert). <br><a name="habracut"></a><br>  Was ist das Hauptproblem bei Satellitenbildern? <br><br>  Zwei oder mehr Klassen von Objekten (z. B. Geb√§ude, Baul√ºcken und Fundamentgruben) in Satellitenbildern k√∂nnen die gleichen spektralen Eigenschaften des Werts aufweisen. Daher war ihre Klassifizierung in den letzten zwanzig Jahren eine schwierige Aufgabe. <br><br>  Aus diesem Grund ist es m√∂glich, klassische Modelle des maschinellen Lernens mit und ohne Lehrer zu verwenden, aber ihre Qualit√§t ist alles andere als ideal.  Sie haben immer die gleichen Nachteile.  Betrachten Sie ein Beispiel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/15b/16c/5b7/15b16c5b76906f81f27374daa8558806.jpg"><br><br>  Wenn Sie eine vertikale Linie als Klassifikator verwenden und entlang der X-Achse verschieben, ist das Klassifizieren von Bildern von H√§usern nicht einfach.  Die Daten werden so verteilt, dass es unm√∂glich ist, sie mit einer vertikalen Linie in Klassen zu unterteilen (in solchen F√§llen hei√üt es, dass "Objekte verschiedener Klassen nicht linear trennbar sind").  Dies bedeutet jedoch nicht, dass H√§user √ºberhaupt nicht klassifiziert werden k√∂nnen! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc4/ea7/7a0/cc4ea77a0f9f4713ea6a49b7885d31c2.gif"><br><br>  Verwenden wir die rote Linie, um die beiden Klassen zu trennen.  In diesem Fall identifizierte der Klassifizierer die meisten H√§user, aber ein Haus wurde nicht seiner Klasse zugeordnet, und drei weitere B√§ume wurden f√§lschlicherweise den "H√§usern" zugeordnet.  Um kein einziges Haus zu verpassen, k√∂nnen Sie den Klassifikator in Form einer blauen Linie verwenden.  Dann wird zu Hause alles abgedeckt, dh wir sagen, dass die R√ºckrufmetrik (F√ºlle) hoch ist.  Es stellte sich jedoch heraus, dass nicht alle klassifizierten Werte H√§user waren, dh gleichzeitig erhielten wir einen niedrigen Wert der Pr√§zisionsmetrik.  Wenn wir die gr√ºne Linie verwenden, sind alle als H√§user klassifizierten Bilder tats√§chlich H√§user, dh der Klassifikator zeigt eine hohe Genauigkeit.  In diesem Fall ist die F√ºlle geringer, da die drei H√§user nicht ber√ºcksichtigt werden.  In den meisten F√§llen m√ºssen wir einen Kompromiss zwischen Genauigkeit und Vollst√§ndigkeit finden. <br><br>  Dieses Problem von H√§usern und B√§umen √§hnelt dem Problem von Geb√§uden, unbebauten Grundst√ºcken und Gruben.  Die Priorit√§t der Klassifizierungsmetriken f√ºr Satellitenbilder kann je nach Aufgabe variieren.  Wenn Sie beispielsweise sicherstellen m√ºssen, dass alle bebauten Gebiete ausnahmslos als Geb√§ude klassifiziert sind und Sie bereit sind, Pixel anderer Klassen mit √§hnlichen Signaturen zu akzeptieren, die ebenfalls als Geb√§ude klassifiziert werden, ben√∂tigen Sie ein Modell mit hoher Vollst√§ndigkeit.  Wenn es f√ºr Sie wichtiger ist, ein Geb√§ude zu klassifizieren, ohne Pixel anderer Klassen hinzuzuf√ºgen, und Sie bereit sind, die Klassifizierung gemischter Gebiete aufzugeben, w√§hlen Sie einen Klassifizierer mit hoher Genauigkeit.  Bei H√§usern und B√§umen verwendet das √ºbliche Modell die rote Linie, um ein Gleichgewicht zwischen Genauigkeit und Vollst√§ndigkeit zu gew√§hrleisten. <br><br><h2>  Verwendete Daten </h2><br>  Als Zeichen werden wir die Werte von sechs Bereichen (Band 2 - Band 7) des Bildes aus Landsat 5 TM verwenden und versuchen, die bin√§re Entwicklungsklasse vorherzusagen.  F√ºr Schulungen und Tests werden multispektrale Daten (Bilder und eine Ebene mit einer bin√§ren Geb√§udeklasse) mit Landsat 5 f√ºr 2011 f√ºr Bangalore verwendet.  Und f√ºr die Vorhersage werden multispektrale Landsat 5-Daten verwendet, die 2005 in Hyderabad erhalten wurden. <br>  Da wir f√ºr den Unterricht markierte Daten verwenden, wird dies als Unterricht mit dem Lehrer bezeichnet. <br><br><img src="https://habrastorage.org/webt/c4/nx/71/c4nx71fzbix6rhp4fb1-ofdupjm.jpeg"><br><br>  <i>Multispektrale Trainingsdaten und die entsprechende bin√§re Schicht mit Entwicklung.</i> <br><br>  Um ein neuronales Netzwerk zu erstellen, verwenden wir Python - die Google Tensorflow-Bibliothek.  Wir werden auch diese Bibliotheken brauchen: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>pyrsgis</i></a> - zum Lesen und Schreiben von GeoTIFF. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>scikit-learn</i></a> - zur Datenvorverarbeitung und Genauigkeitsbewertung. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>numpy</i></a> - f√ºr grundlegende Operationen mit Arrays. <br></li></ol><br>  Und jetzt schreiben wir ohne weiteres den Code. <br><br>  Legen Sie alle drei Dateien in einem Verzeichnis ab, schreiben Sie den Pfad und die Namen der Eingabedateien in das Skript und lesen Sie dann die GeoTIFF-Dateien. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyrsgis <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> raster os.chdir(<span class="hljs-string"><span class="hljs-string">"E:\\yourDirectoryName"</span></span>) mxBangalore = <span class="hljs-string"><span class="hljs-string">'l5_Bangalore2011_raw.tif'</span></span> builtupBangalore = <span class="hljs-string"><span class="hljs-string">'l5_Bangalore2011_builtup.tif'</span></span> mxHyderabad = <span class="hljs-string"><span class="hljs-string">'l5_Hyderabad2011_raw.tif'</span></span> <span class="hljs-comment"><span class="hljs-comment"># Read the rasters as array ds1, featuresBangalore = raster.read(mxBangalore, bands='all') ds2, labelBangalore = raster.read(builtupBangalore, bands=1) ds3, featuresHyderabad = raster.read(mxHyderabad, bands='all')</span></span></code> </pre> <br>  Das <code>raster</code> Modul aus dem <code>pyrsgis</code> Paket liest GeoTIFF- <code>pyrsgis</code> und DN-Werte (Digital Number) als separate NumPy-Arrays.  Wenn Sie an Details interessiert sind, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Jetzt zeigen wir die Gr√∂√üe der gelesenen Daten an. <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"Bangalore multispectral image shape: "</span></span>, featuresBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Bangalore binary built-up image shape: "</span></span>, labelBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Hyderabad multispectral image shape: "</span></span>, featuresHyderabad.shape)</code> </pre> <br>  Ergebnis: <br><br><pre> <code class="python hljs">Bangalore multispectral image shape: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2054</span></span>, <span class="hljs-number"><span class="hljs-number">2044</span></span> Bangalore binary built-up image shape: <span class="hljs-number"><span class="hljs-number">2054</span></span>, <span class="hljs-number"><span class="hljs-number">2044</span></span> Hyderabad multispectral image shape: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1318</span></span>, <span class="hljs-number"><span class="hljs-number">1056</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, haben die Bilder von Bangalore die gleiche Anzahl von Zeilen und Spalten wie in der Bin√§rebene (entsprechend dem Geb√§ude).  Die Anzahl der Schichten in multispektralen Bildern in Bangalore und Hyderabad stimmt ebenfalls √ºberein.  Das Modell lernt anhand der entsprechenden Werte f√ºr alle 6 Spektren zu entscheiden, welche Pixel zum Geb√§ude geh√∂ren und welche nicht.  Daher m√ºssen multispektrale Bilder dieselbe Anzahl von Merkmalen (Bereichen) aufweisen, die in derselben Reihenfolge aufgef√ºhrt sind. <br><br>  Jetzt verwandeln wir die Arrays in zweidimensionale Arrays, wobei jede Zeile ein separates Pixel darstellt, da dies f√ºr den Betrieb der meisten Algorithmen f√ºr maschinelles Lernen erforderlich ist.  Wir werden dies mit dem <code>convert</code> aus dem <code>pyrsgis</code> Paket <code>pyrsgis</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d69/176/b91/d69176b91e9758291e1faae6c25486e5.jpg"><br>  <i>Datenumstrukturierungsschema.</i> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyrsgis.convert <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> changeDimension featuresBangalore = changeDimension(featuresBangalore) labelBangalore = changeDimension (labelBangalore) featuresHyderabad = changeDimension(featuresHyderabad) nBands = featuresBangalore.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] labelBangalore = (labelBangalore == <span class="hljs-number"><span class="hljs-number">1</span></span>).astype(int) print(<span class="hljs-string"><span class="hljs-string">"Bangalore multispectral image shape: "</span></span>, featuresBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Bangalore binary built-up image shape: "</span></span>, labelBangalore.shape) print(<span class="hljs-string"><span class="hljs-string">"Hyderabad multispectral image shape: "</span></span>, featuresHyderabad.shape)</code> </pre> <br>  Ergebnis: <br><br><pre> <code class="python hljs">Bangalore multispectral image shape: <span class="hljs-number"><span class="hljs-number">4198376</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> Bangalore binary built-up image shape: <span class="hljs-number"><span class="hljs-number">4198376</span></span> Hyderabad multispectral image shape: <span class="hljs-number"><span class="hljs-number">1391808</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  In der siebten Zeile haben wir alle Pixel mit dem Wert 1 extrahiert. Dies hilft, Probleme mit Pixeln ohne Informationen (NoData) zu vermeiden, die h√§ufig extrem hohe oder niedrige Werte aufweisen. <br>  Jetzt werden wir die Daten in Trainings- und Validierungsbeispiele aufteilen.  Dies ist erforderlich, damit das Modell die Testdaten nicht sieht und mit den neuen Informationen genauso gut funktioniert.  Andernfalls wird das Modell umgeschult und funktioniert nur mit Trainingsdaten. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> train_test_split xTrain, xTest, yTrain, yTest = train_test_split(featuresBangalore, labelBangalore, test_size=<span class="hljs-number"><span class="hljs-number">0.4</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">42</span></span>) print(xTrain.shape) print(yTrain.shape) print(xTest.shape) print(yTest.shape)</code> </pre> <br>  Ergebnis: <br><br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">2519025</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">2519025</span></span>,) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>,) test_size=<span class="hljs-number"><span class="hljs-number">0.4</span></span></code> </pre> <br>  bedeutet, dass die Daten in einem Verh√§ltnis von 60/40 in Training und Validierung unterteilt sind. <br>  Viele Algorithmen f√ºr maschinelles Lernen, einschlie√ülich neuronaler Netze, ben√∂tigen normalisierte Daten.  Dies bedeutet, dass sie innerhalb eines bestimmten Bereichs (in diesem Fall von 0 bis 1) verteilt werden m√ºssen.  Um diese Anforderung zu erf√ºllen, normalisieren wir daher die Symptome.  Dies kann erreicht werden, indem der Minimalwert extrahiert und dann durch den Spread dividiert wird (die Differenz zwischen den Maximal- und Minimalwerten).  Da der Landsat-Datensatz 8-Bit ist, sind die Minimal- und Maximalwerte 0 und 255 (2 <sup>‚Å∏</sup> = 256 Werte). <br><br>  Beachten Sie, dass es f√ºr die Normalisierung immer besser ist, die Minimal- und Maximalwerte basierend auf den Daten zu berechnen.  Um die Aufgabe zu vereinfachen, halten wir uns standardm√§√üig an den 8-Bit-Bereich. <br><br>  Eine weitere Stufe der Vorverarbeitung ist die Transformation der Attributmatrix von zweidimensional zu dreidimensional, sodass das Modell jede Zeile als separates Pixel (separates Lernobjekt) wahrnimmt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/965/d0f/aa8/965d0faa8e8c7b4787c10823cf038d20.jpg"><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Normalise the data xTrain = xTrain / 255.0 xTest = xTest / 255.0 featuresHyderabad = featuresHyderabad / 255.0 # Reshape the data xTrain = xTrain.reshape((xTrain.shape[0], 1, xTrain.shape[1])) xTest = xTest.reshape((xTest.shape[0], 1, xTest.shape[1])) featuresHyderabad = featuresHyderabad.reshape((featuresHyderabad.shape[0], 1, featuresHyderabad.shape[1])) # Print the shape of reshaped data print(xTrain.shape, xTest.shape, featuresHyderabad.shape)</span></span></code> </pre> <br>  Ergebnis: <br><br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">2519025</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1679351</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) (<span class="hljs-number"><span class="hljs-number">1391808</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre> <br>  Alles ist fertig, lassen Sie uns unser Modell mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Keras zusammenbauen</a> .  Verwenden Sie zun√§chst das sequentielle Modell und f√ºgen Sie nacheinander Ebenen hinzu.  Wir werden eine Eingabeebene haben, deren Anzahl der Knoten der Anzahl der Bereiche ( <code>nBands</code> ) entspricht - in unserem Fall sind es 6. Wir werden auch eine versteckte Ebene mit 14 Knoten und der <code>ReLu</code> Aktivierungsfunktion <code>ReLu</code> .  Die letzte Schicht besteht aus zwei Knoten zum Definieren einer bin√§ren Geb√§udeklasse mit der <code>softmax</code> Aktivierungsfunktion, die zum Anzeigen eines kategorisierten Ergebnisses geeignet ist.  Lesen Sie hier mehr √ºber Aktivierungsfunktionen. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras <span class="hljs-comment"><span class="hljs-comment"># Define the parameters of the model model = keras.Sequential([ keras.layers.Flatten(input_shape=(1, nBands)), keras.layers.Dense(14, activation='relu'), keras.layers.Dense(2, activation='softmax')]) # Define the accuracy metrics and parameters model.compile(optimizer="adam", loss="sparse_categorical_crossentropy", metrics=["accuracy"]) # Run the model model.fit(xTrain, yTrain, epochs=2)</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/d8a/9cd/5ec/d8a9cd5ec53c57d671d77b0c46bfb17e.png"><br>  <i>Neuronale Netzwerkarchitektur</i> <br><br>  Wie in Zeile 10 erw√§hnt, geben wir <code>adam</code> als Modelloptimierer an (es gibt mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> ).  In diesem Fall verwenden wir die Kreuzentropie als Verlustfunktion (en. <code>categorical-sparse-crossentropy</code> - mehr dazu finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  Um die Qualit√§t des Modells zu beurteilen, verwenden wir die <code>accuracy</code> . <br><br>  Schlie√ülich werden wir beginnen, unser Modell f√ºr zwei Epochen (oder Iterationen) auf <code>xTrain</code> und <code>yTrain</code> .  Dies kann je nach Datengr√∂√üe und Verarbeitungsleistung einige Zeit dauern.  Folgendes sehen Sie nach der Kompilierung: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfa/3fc/c47/dfa3fcc47572b2fd20c5252ba4da1e50.png"><br><br>  Lassen Sie uns die Werte f√ºr die Validierungsdaten vorhersagen, die wir separat speichern, und verschiedene Genauigkeitsmetriken berechnen. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.metrics <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> confusion_matrix, precision_score, recall_score <span class="hljs-comment"><span class="hljs-comment"># Predict for test data yTestPredicted = model.predict(xTest) yTestPredicted = yTestPredicted[:,1] # Calculate and display the error metrics yTestPredicted = (yTestPredicted&gt;0.5).astype(int) cMatrix = confusion_matrix(yTest, yTestPredicted) pScore = precision_score(yTest, yTestPredicted) rScore = recall_score(yTest, yTestPredicted) print("Confusion matrix: for 14 nodes\n", cMatrix) print("\nP-Score: %.3f, R-Score: %.3f" % (pScore, rScore))</span></span></code> </pre> <br>  Die <code>softmax</code> Funktion generiert separate Spalten f√ºr Wahrscheinlichkeitswerte f√ºr jede Klasse.  Wir verwenden nur die Werte f√ºr die erste Klasse ("es gibt ein Geb√§ude"), wie aus der sechsten Zeile des obigen Codes ersichtlich ist.  Die Bewertung der Arbeit von Geodatenanalysemodellen ist im Gegensatz zu anderen klassischen Problemen des maschinellen Lernens nicht so einfach.  Es ist unfair, sich auf einen allgemeinen Gesamtfehler zu verlassen.  Der Schl√ºssel zu einem erfolgreichen Modell ist die r√§umliche Anordnung.  Somit k√∂nnen die Verwirrungsmatrix, Genauigkeit und Vollst√§ndigkeit eine korrektere Vorstellung von der Qualit√§t des Modells geben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/399/3d8/bf3/3993d8bf36a5f4165b60f39e36e5c566.jpg"><br>  <i>Die Konsole zeigt also die Fehlermatrix, Genauigkeit und Vollst√§ndigkeit an.</i> <br><br>  Wie Sie der Verwirrungsmatrix entnehmen k√∂nnen, gibt es Tausende von Pixeln, die sich auf Geb√§ude beziehen, aber unterschiedlich klassifiziert sind und umgekehrt.  Ihr Anteil am gesamten Datenvolumen ist jedoch nicht zu gro√ü.  Die Genauigkeit und Vollst√§ndigkeit der Testdaten hat den Schwellenwert von 0,8 √ºberschritten. <br><br>  Sie k√∂nnen mehr Zeit aufwenden und mehrere Iterationen durchf√ºhren, um die optimale Anzahl versteckter Ebenen, die Anzahl der Knoten in jeder verborgenen Ebene sowie die Anzahl der Epochen zu ermitteln, um die gew√ºnschte Genauigkeit zu erzielen.  Bei Bedarf k√∂nnen Fernerkundungsindizes wie NDBI oder NDWI als Funktionen verwendet werden.  Wenn Sie die gew√ºnschte Genauigkeit erreicht haben, verwenden Sie das Modell, um die Entwicklung basierend auf neuen Daten vorherzusagen und das Ergebnis in GeoTIFF zu exportieren.  F√ºr solche Aufgaben k√∂nnen Sie ein √§hnliches Modell mit geringf√ºgigen √Ñnderungen verwenden. <br><br><pre> <code class="python hljs">predicted = model.predict(feature2005) predicted = predicted[:,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-comment"><span class="hljs-comment">#Export raster prediction = np.reshape(predicted, (ds.RasterYSize, ds.RasterXSize)) outFile = 'Hyderabad_2011_BuiltupNN_predicted.tif' raster.export(prediction, ds3, filename=outFile, dtype='float')</span></span></code> </pre> <br>  Bitte beachten Sie, dass wir GeoTIFF mit vorhergesagten Wahrscheinlichkeitswerten und nicht mit ihrer bin√§risierten Version exportieren.  Sp√§ter in der GIS-Umgebung k√∂nnen wir den Schwellenwert f√ºr eine Ebene vom Typ float festlegen, wie in der folgenden Abbildung dargestellt. <br><br><img src="https://habrastorage.org/webt/sk/ka/kz/skkakzxokrbkvrgulcvm0vkuwua.jpeg"><br>  <i>Vom Modell auf der Grundlage multispektraler Daten vorhergesagte Hyderabad-Aufbauschicht.</i> <br><br>  Die Modellgenauigkeit wurde bereits mit Pr√§zision und R√ºckruf gemessen.  Sie k√∂nnen auch herk√∂mmliche √úberpr√ºfungen (z. B. mithilfe des Kappa-Koeffizienten) f√ºr eine neue vorhergesagte Ebene durchf√ºhren.  Zus√§tzlich zu den oben genannten Schwierigkeiten bei der Klassifizierung von Satellitenbildern umfassen andere offensichtliche Einschr√§nkungen die Unm√∂glichkeit der Vorhersage auf der Grundlage von Bildern, die zu verschiedenen Jahreszeiten und in verschiedenen Regionen aufgenommen wurden, da sie unterschiedliche spektrale Signaturen aufweisen. <br><br>  Das in diesem Artikel beschriebene Modell hat die einfachste Architektur f√ºr neuronale Netze.  Bessere Ergebnisse k√∂nnen mit komplexeren Modellen erzielt werden, einschlie√ülich Faltungs-Neuronalen Netzen.  Der Hauptvorteil einer solchen Klassifizierung ist ihre Skalierbarkeit (Anwendbarkeit) nach dem Training des Modells. <br><br>  Die verwendeten Daten und der gesamte Code sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468973/">https://habr.com/ru/post/de468973/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468961/index.html">Wie kann man die Routine im Leben f√ºr 560 Dollar loswerden? Oder wie man lebt, nicht lebt</a></li>
<li><a href="../de468963/index.html">Backup, Teil auf Wunsch der Leser: UrBackup-√úbersicht, BackupPC, AMANDA</a></li>
<li><a href="../de468967/index.html">"Technologie" zum Erhalten von Gleichungen der Dynamik von TAU. Und warum ist Systemidentifikation schei√üe und "ehrliche Physik" Regeln</a></li>
<li><a href="../de468969/index.html">Erstellen Sie Google-Nutzer aus PowerShell √ºber die API</a></li>
<li><a href="../de468971/index.html">Schreiben in Java f√ºr Nintendo DS</a></li>
<li><a href="../de468989/index.html">UEBA-Markt stirbt - Es lebe die UEBA</a></li>
<li><a href="../de468991/index.html">Modulare Sprite-Charaktere und ihre Animation</a></li>
<li><a href="../de468993/index.html">Oculus Quest stellt eine Verbindung zu einem PC her und sieht H√§nde</a></li>
<li><a href="../de468995/index.html">Offenheitsrichtlinie: Wie Benutzer das Projekt beeinflussen</a></li>
<li><a href="../de468997/index.html">Mentoring - ein Muss oder ein sch√∂ner Bonus?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>