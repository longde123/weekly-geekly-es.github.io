<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏫 🏵️ 🔚 关于Clang [[trivial_abi]] 🚗 🌳 🕦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最后，我写了一篇关于[[trivial_abi]]的帖子！ 

 这是Clang干线中的一项新的专有功能，于2018年2月新增。这是C ++语言的供应商扩展，它不是标准的C ++，它不受GCC干线的支持，据我所知，WG21没有积极的提议将其包括在C ++标准中。 



 我没有参与此功能的实现。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于Clang [[trivial_abi]]</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468759/"> 最后，我写了一篇关于[[trivial_abi]]的帖子！ <br><br> 这是Clang干线中的一项新的专有功能，于2018年2月新增。这是C ++语言的供应商扩展，它不是标准的C ++，它不受GCC干线的支持，据我所知，WG21没有积极的提议将其包括在C ++标准中。 <br><br><img src="https://habrastorage.org/webt/ie/do/9e/iedo9ep8gzdeliscehwljy0clnq.jpeg"><br><br> 我没有参与此功能的实现。 我只是查看了cfe-commits邮件列表上的补丁，并默默地为自己鼓掌。 但这是一个很酷的功能，我想每个人都应该知道。 <br><a name="habracut"></a><br> 因此，我们首先要开始：这不是标准属性，而Clang干线不支持属性[[trivial_abi]]的标准拼写。 相反，您应该使用旧样式编写它，如下所示： <br><br><pre><code class="cpp hljs">__attribute__((trivial_abi)) __attribute__((__trivial_abi__)) [[clang::trivial_abi]]</code> </pre> <br> 并且，由于这是一个属性，因此编译器对粘贴位置非常挑剔，并且如果将其粘贴到错误的位置，则会被动地主动保持沉默（因为无法识别的属性将被忽略而没有消息）。 这不是错误，而是功能。 正确的语法是这样的： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) class TRIVIAL_ABI Widget { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ... };</span></span></span></span></code> </pre> <br><br><h3> 这能解决什么问题？ </h3><br><br> 还记得我在04/17/2018上发布的两个课程版本的帖子吗？ <br><br><blockquote> 注意事项 佩雷夫（Perev）：由于04/17/2018的帖子量很小，因此我没有单独发布它，而是将其插入扰流器下方。 <br></blockquote><div class="spoiler">  <b class="spoiler_title">从2018年4月17日发布</b> <div class="spoiler_text"><h3> 缺少琐碎的析构函数调用的缺点 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请参阅C ++标准提案邮件列表。</a>  foo或bar这两个函数中的哪个函数将具有由编译器生成的最佳代码？ <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Integer() {} <span class="hljs-comment"><span class="hljs-comment">// deliberately non-trivial }; void foo(std::vector&lt;int&gt;&amp; v) { v.back() *= 0xDEADBEEF; v.pop_back(); } void bar(std::vector&lt;Integer&gt;&amp; v) { v.back().value *= 0xDEADBEEF; v.pop_back(); }</span></span></code> </pre><br><br> 使用GCC和libstdc ++进行编译。 猜对吧？ <br><br><pre> <code class="cpp hljs">foo: movq <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi), %rax imull $<span class="hljs-number"><span class="hljs-number">-559038737</span></span>, <span class="hljs-number"><span class="hljs-number">-4</span></span>(%rax), %edx subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, %rax movl %edx, (%rax) movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret bar: subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret</code> </pre> <br><br> 这就是这里发生的事情：GCC足够聪明，可以理解，当一个内存区域的析构函数启动时，它的生存期结束，并且该内存区域的所有先前条目都是“死的”。 但是GCC也足够聪明，可以理解琐碎的析构函数（例如伪析构函数〜int（））什么也不做，也不产生任何效果。 <br><br> 因此，bar函数调用pop_back，后者运行〜Integer（），这使vec.back（）失效，并且GCC完全删除了0xDEADBEEF的乘法。 <br><br> 另一方面，foo调用pop_back，它启动〜int（）伪析构函数（它可以完全跳过该调用，但不能完全跳过），GCC看到它为空，并且忘记了它。 因此，GCC不会看到vec.back（）已死，也不会删除与0xDEADBEEF相乘的结果。 <br><br> 对于平凡的析构函数会发生这种情况，但对于〜int（）这样的伪析构函数则不会发生这种情况。 将〜Integer（）{}替换为〜Integer（）=默认值； 看看不道德的指示又如何出现了！ <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Foo() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// trivial }; struct Bar { int value; ~Bar() {} // deliberately non-trivial };</span></span></code> </pre> <br> 在那篇文章中，给出了代码，其中编译器为Foo生成的代码比为Bar生成的代码差。 值得讨论为什么这是意外的。 程序员直观地期望“平凡”的代码比“非平凡”的代码更好。 在大多数情况下就是这种情况。 特别是在我们进行函数调用或返回时就是这种情况： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">incr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class">) {</span></span> obj.value += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; }</code> </pre> <br>  incr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编译</a>为以下代码： <br><br><pre> <code class="cpp hljs">leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax retq</code> </pre> <br>  （leal是x86 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命令的</a>意思是“ add”。）我们看到4字节的obj被传递到％edi寄存器中的incr，然后将其值加1并将其返回给％eax。 输入四个字节，输出四个字节，简单易行。 <br><br> 现在让我们看一下incr（具有非平凡析构函数的情况）。 <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rsi) movl %eax, (%rdi) movq %rdi, %rax retq</code> </pre> <br> 在这里，尽管这里的4个字节具有相同的语义，但obj没有传递到寄存器中。 在这里，obj被传递并返回到该地址。 在这里，调用方为返回值保留了一些空间，并在rdi中向我们传递了指向该空间的指针，而调用方在下一个参数％rsi的寄存器中为我们提供了返回值obj的指针。 我们从（％rsi）中提取值，将其加1，保存回（％rsi）中以更新obj本身的值，然后（平凡地）将obj的4个字节复制到插槽中，以获取％rdi所指向的返回值。 最后，我们将调用者传递的原始指针从％rdi复制到％rax，因为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">x86-64 ABI</a>文档（第22页）告诉我们要执行此操作。 <br><br>  Bar与Foo如此不同的原因是Bar具有非平凡的析构函数，而<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">x86-64 ABI</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">p。19</a> ）明确指出： <br><br><blockquote> 如果C ++对象具有非平凡的复制构造函数或非平凡的析构函数，则会通过不可见的链接传递该对象（该对象将替换为参数列表中的指针）。 </blockquote><br> 稍后的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Itanium C ++ ABI</a>文档定义了以下内容： <br><blockquote> 如果出于调用目的参数类型很重要，则调用者必须分配一个临时位置，并将链接传递到该临时位置： <br>  [...] <br> 在以下情况下，出于调用目的，一种类型被认为是非平凡的： <br><br> 它具有非平凡的复制构造函数，移动的构造函数，析构函数，或者其所有移动和复制构造函数均被删除。 </blockquote><br> 这就说明了一切：Bar的代码生成较差，因为它是通过不可见的链接传递的。 由于发生了两个独立情况的不幸组合，因此它通过不可见的链接进行传输： <br><ul><li>  ABI文件说具有非平凡析构函数的对象通过不可见链接传递 </li><li>  Bar具有非平凡的析构函数。 </li></ul><br> 这是经典的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三段论</a> ：第一点是主要前提，第二点是私密性。 结果，Bar通过不可见的链接传输。 <br><br> 让别人给我们一个三段论： <br><ul><li> 所有人都是凡人 </li><li> 苏格拉底是个男人。 </li><li> 因此，苏格拉底是凡人。 </li></ul><br><br> 如果我们要驳斥“苏格拉底是凡人”的结论，我们必须驳斥其中一个前提：要么驳斥主要事物（也许有些人不是凡人），要么驳斥私人（也许苏格拉底不是一个人）。 <br><br> 为了使Bar在寄存器（如Foo）中通过，我们必须驳斥两个前提之一。 标准的C ++路径是给Bar一个琐碎的析构函数，从而破坏了私有前提。 但是还有另一种方式！ <br><br><h3>  [[trivial_abi]]如何解决问题 </h3><br> 新的Clang属性破坏了主要前提。  Clang扩展了ABI文档，如下所示： <br><blockquote> 如果出于调用目的参数类型很重要，则调用者必须分配一个临时位置，并将链接传递到该临时位置： <br>  [...] <br> 如果一个类型被标记为[[trivial_abi]]并被视为： <br> 它具有非平凡的复制构造函数，移动的构造函数，析构函数，或者其所有移动和复制构造函数均被删除。 <br></blockquote><br> 即使具有非平凡的构造函数或析构函数的类出于调用的目的而被视为平凡的，但如果将其标记为[[trivial_abi]]，则该类也是如此。 <br><br> 所以现在，使用Clang，我们可以这样写： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) struct TRIVIAL_ABI Baz { int value; ~Baz() {} </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// deliberately non-trivial };</span></span></span></span></code> </pre> <br> 编译incr &lt;Baz&gt;，并获得与incr &lt;Foo&gt;相同的代码！ <br><h3> 警告＃1：[[trivial_abi]]有时什么都不做 </h3><br> 我希望我们可以对标准库类型进行“琐碎的调用”包装，如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trivial_unique_ptr</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt;::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>; };</code> </pre> <br>  las，这行不通。 如果您的类具有“对于调用而言不平凡”的任何基类或非静态字段，则现在编写形式的Clang扩展将使您的类“不可逆转不平凡”，并且该属性将无效。  （不会发出诊断消息。这意味着您可以在类模板中使用[[trivial_abi]]作为可选属性，并且该类将是“有条件的琐碎”，这有时很有用。缺点当然是，您可以将该类标记为琐碎的，然后发现编译器已对其进行静默修复。） <br><br> 如果您的类具有虚拟基类或虚拟函数，则忽略该属性而不会显示消息。 在这些情况下，它可能不适合寄存器，而且我不知道您想通过按值传递值来获得什么，但是您可能知道。 <br><br> 因此，据我所知，将TRIVIAL_ABI用于“标准实用程序类型”（例如可选&lt;T&gt;，unique_ptr &lt;T&gt;和shared_ptr &lt;T&gt;）的唯一方法是 <br><ul><li> 从头实现它们并应用属性，或者 </li><li> 进入libc ++的本地副本，然后用手将属性插入其中 </li></ul><br>  （在开源世界中，这两种方法本质上是相同的） <br><br><h3> 警告2：破坏者的责任 </h3><br> 在Foo / Bar的示例中，该类具有空的析构函数。 让我们的班级实际上有一个非平凡的析构函数。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Up1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; Up1(Up1&amp;&amp; u) : value(u.value) { u.value = <span class="hljs-number"><span class="hljs-number">0</span></span>; } ~Up1() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"destroyed"</span></span>); } };</code> </pre> <br> 这是您应该熟悉的，这是unique_ptr &lt;int&gt;，简化为限制，删除时会显示消息。 <br><br> 如果没有TRIVIAL_ABI，incr &lt;Up1&gt;就像incr &lt;Bar&gt;： <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rdi) movl $<span class="hljs-number"><span class="hljs-number">0</span></span>, (%rsi) movq %rdi, %rax retq</code> </pre> <br><br> 使用TRIVIAL_ABI，incr看起来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更大更可怕</a> ！ <br><br><pre> <code class="cpp hljs">pushq %rbx leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %ebx movl $.L.str, %edi callq <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span> movl %ebx, %eax popq %rbx retq</code> </pre> <br><br> 在传统的调用约定中，具有非平凡析构函数的类型始终通过不可见的链接传递，这意味着接收方（在这种情况下为incr）始终接受指向参数对象的指针，而不拥有该对象。 该对象归调用者所有，这使得省略工作变得可行！ <br><br> 当将具有[[trivial_abi]]的类型传递到寄存器中时，我们实际上是在复制参数对象。 <br><br> 由于x86-64只有一个寄存器要返回（掌声），因此被调用函数无法在最后返回对象。 所调用的函数应该拥有我们传递给它的对象的所有权！ 这意味着被调用的函数必须在完成时调用参数对象的析构函数。 <br><br> 在我们前面的示例Foo / Bar / Baz中，调用了析构函数，但它为空，并且我们没有注意到它。 现在在incr &lt;Up2&gt;中，我们在调用函数的一侧看到了析构函数生成的其他代码。 <br><br> 可以假定在某些用户情况下可能会生成此附加代码。 但是，相反，析构函数的调用不会出现在任何地方！ 因为在调用函数中<i>未</i>调用它，所以在incr中调用它。 通常，价格和收益将保持平衡。 <br><br><h3> 警告3：析构函数顺序 </h3><br> 具有琐碎ABI的参数的析构函数将由被调用函数而不是被调用函数调用（警告编号2）。 理查德·史密斯（Richard Smith）指出，这意味着它不会按其他参数的析构函数所在的顺序被调用。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alpha</span></span></span><span class="hljs-class"> {</span></span> alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha constructed"</span></span>); } ~alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha destroyed"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beta</span></span></span><span class="hljs-class"> {</span></span> beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta constructed"</span></span>); } ~beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta destroyed"</span></span>); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alpha, beta)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(alpha{}, beta{}); }</code> </pre> <br> 此代码打印： <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed alpha destroyed beta destroyed</code> </pre> <br> 将TRIVIAL_ABI定义为[[clang :: trivial_abi]]时，将输出： <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed beta destroyed alpha destroyed</code> </pre> <br><h3> 与“可重定位” /“移动重定位”对象的关系 </h3><br> 没有关系...，对吗？ <br><br> 如您所见，对于[[trivial_abi]]类没有任何要求，可以为移动的构造函数，析构函数或默认构造函数具有任何特定的语义。 任何特定的类都可能是琐碎可重定位的，仅仅是因为大多数类都是琐碎可重定位的。 <br><br> 我们可以简单地设置offset_ptr类，以使其无法轻易重定位： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">offset_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span> value_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: offset_ptr(T *p) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)p - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} offset_ptr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} <span class="hljs-function"><span class="hljs-function">T *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T *)((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + value_); } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) { value_ = ((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff) { value_ += (diff * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ offset_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; top = &amp;a[<span class="hljs-number"><span class="hljs-number">4</span></span>]; top = incr(top); assert(top.get() == &amp;a[<span class="hljs-number"><span class="hljs-number">5</span></span>]); }</code> </pre> <br>  <a href="">这是完整的代码。</a> <br> 定义TRIVIAL_ABI时，Clang干线在-O0和-O1处通过了此测试，但在-O2处通过了此测试（即，当它尝试内联对trivial_offset_ptr ::运算符+ =和复制构造函数的调用时），它在断言时崩溃。 <br><br> 所以再警告一遍。 如果您的类型使用this指针做了如此疯狂的事情，则您可能不想在寄存器中传递它。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误37319</a> ，实际上是对文档的请求。 在这种情况下，事实证明，没有办法使代码按程序员希望的方式工作。 我们说value_的值应该取决于this指针的值，但是在调用函数和被调用函数之间的边界上，对象位于寄存器中，并且指向它的指针不存在！ 因此，调用函数将其写入内存，然后再次传递此指针，被调用函数应如何计算正确的值才能将其写入value_？ 也许最好问一下它在-O0下如何工作？  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此代码根本不起作用。</a> <br><br> 因此，如果要使用[[trivial_abi]]，应避免使用成员函数（不仅是特殊的，而且还包括一般情况下的成员函数）在很大程度上依赖于对象自己的地址（“基本”一词具有未定义的含义）。 <br><br> 直观地，当一个类被标记为[[trivial_abi]]时，只要您希望复制，就可以获取copy plus memcpy。 同样，当您希望搬家时，您实际上可以得到搬家加上memcpy。 <br><br> 当一个类型是“可重定位的”（由我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++ Now中</a>定义）时，那么只要您希望复制和销毁它，实际上就可以得到memcpy。 同样，当您期望位移和破坏时，您实际上可以得到memcpy。 实际上，如果我们谈论“琐碎的重定位”，则对特殊功能的调用将丢失，但是当类具有Clang的[[trivial_abi]]属性时，调用不会丢失。 除了您期望的呼叫之外，您还可以获得（原样）memcpy。 这种（某种）memcpy是您为更快的电话注册约定支付的价格。 <br><br><h3> 链接以供进一步阅读： </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2017年11月以来的Hat中明晃（Akira Hatanaka）的cfe-dev线程</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方Clang文档</a> <br>  <a href="">单元测试trivial_abi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误37319：trivial_offset_ptr可能无法工作</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN468759/">https://habr.com/ru/post/zh-CN468759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN468741/index.html">智慧城市中的互联网</a></li>
<li><a href="../zh-CN468747/index.html">我如何在VK度过整个夏天</a></li>
<li><a href="../zh-CN468749/index.html">Android LiveData活动</a></li>
<li><a href="../zh-CN468753/index.html">色盲-人的朋友（卫生部不正确）</a></li>
<li><a href="../zh-CN468757/index.html">错误1040后出现MySQL连接：连接过多</a></li>
<li><a href="../zh-CN468761/index.html">使用pwnable.kr解决问题24-简单登录。 堆叠框架覆盖</a></li>
<li><a href="../zh-CN468765/index.html">以Delimobile为例确认控制命令的重要性</a></li>
<li><a href="../zh-CN468767/index.html">木制玩具，第二部分-1986-1988</a></li>
<li><a href="../zh-CN468769/index.html">Xavier Noria on Rails 6，咨询等</a></li>
<li><a href="../zh-CN468773/index.html">印度能源公司NTPC将建造一个5,000兆瓦的太阳能公园</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>