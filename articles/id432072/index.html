<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒŠ ğŸ¤´ğŸ¾ ğŸ‘© Tiga jenis kebocoran memori ğŸ’ ğŸ¾ ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘©ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo kolega. 

 Pencarian panjang kami untuk buku terlaris abadi tentang optimasi kode sejauh ini hanya menghasilkan hasil pertama, tetapi kami siap u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tiga jenis kebocoran memori</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432072/"> Halo kolega. <br><br>  Pencarian panjang kami untuk buku terlaris abadi tentang optimasi kode sejauh ini hanya menghasilkan hasil pertama, tetapi kami siap untuk menyenangkan Anda bahwa terjemahan buku legendaris Ben Watson " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menulis Kinerja Tinggi. Kode NET</a> " baru saja selesai.  Di toko - sementara pada bulan April, perhatikan iklan. <br><br>  Dan hari ini kami menawarkan Anda untuk membaca artikel yang sepenuhnya praktis tentang jenis kebocoran memori yang paling mendesak, yang ditulis oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nelson Ilheidzhe</a> (Strike). <br><a name="habracut"></a><br>  Jadi, Anda memiliki program yang membutuhkan waktu lebih lama untuk diselesaikan, semakin lama dibutuhkan.  Anda mungkin tidak akan mengalami kesulitan memahami bahwa ini adalah tanda pasti kebocoran memori. <br>  Namun, apa sebenarnya yang dimaksud dengan "kebocoran memori"?  Dalam pengalaman saya, kebocoran memori eksplisit dibagi menjadi tiga kategori utama, yang masing-masing ditandai dengan perilaku khusus, dan untuk debugging masing-masing kategori diperlukan alat dan teknik khusus.  Pada artikel ini saya ingin menjelaskan ketiga kelas dan menyarankan cara mengenali dengan benar <br>  di kelas mana Anda berurusan, dan bagaimana menemukan kebocoran. <br><br>  Jenis (1): Fragmen memori yang tidak terjangkau dialokasikan <br><br>  Ini adalah kebocoran memori klasik di C / C ++.  Seseorang mengalokasikan memori menggunakan <code>new</code> atau <code>malloc</code> , dan tidak menelepon <code>free</code> atau <code>delete</code> untuk membebaskan memori setelah selesai bekerja dengannya. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *leaked = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">4096</span></span>); use_a_buffer(leaked); <span class="hljs-comment"><span class="hljs-comment">/* ,   free() */</span></span> }</code> </pre> <br>  <i>Cara menentukan apakah kebocoran termasuk dalam kategori ini</i> <br><br><ul><li>  Jika Anda menulis dalam C atau C ++, terutama dalam C ++ tanpa penggunaan smart pointer secara luas untuk mengontrol masa pakai segmen memori, maka ini adalah opsi yang kami pertimbangkan terlebih dahulu. </li><li>  Jika program berjalan di lingkungan dengan pengumpulan sampah, ada kemungkinan kebocoran tipe ini dipicu oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi kode asli</a> , namun, kebocoran tipe (2) dan (3) harus terlebih dahulu dihilangkan. </li></ul><br>  <i>Cara menemukan kebocoran seperti itu</i> <br><br><ul><li>  Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASAN</a> .  Gunakan ASAN.  Gunakan ASAN. </li><li>  Gunakan detektor yang berbeda.  Saya mencoba alat Valgrind atau tcmalloc untuk bekerja dengan banyak, ada juga alat lain di lingkungan lain. </li><li>  Beberapa pengalokasi memori memungkinkan untuk membuang profil heap, yang akan menampilkan semua area memori yang tidak terisi.  Jika Anda memiliki kebocoran, maka setelah beberapa waktu, hampir semua debit aktif akan mengalir darinya, jadi menemukan itu mungkin tidak sulit. </li><li>  Jika semuanya gagal, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buang dump memori dan memeriksanya seteliti mungkin</a> .  Tapi yang pasti jangan mulai dengan ini. </li></ul><br>  <b>Jenis (2): alokasi memori berumur panjang yang tidak direncanakan</b> <br><br>  Situasi seperti itu tidak "bocor" dalam arti kata klasik, karena tautan dari suatu tempat ke bagian memori ini tetap dipertahankan, sehingga pada akhirnya dapat dilepaskan (jika program berhasil sampai ke sana tanpa menghabiskan semua memori). <br>  Situasi dalam kategori ini dapat muncul karena berbagai alasan spesifik.  Yang paling umum adalah: <br><br><ul><li>  Akumulasi negara yang tidak disengaja dalam struktur global;  misalnya, server HTTP menulis ke daftar global setiap objek <code>Request</code> diterima. </li><li>  Tembolok tanpa kebijakan usang yang dipikirkan dengan matang.  Misalnya, cache ORM yang cache setiap objek tunggal dimuat, aktif selama migrasi, di mana semua catatan yang ada dalam tabel dimuat tanpa terkecuali. </li><li>  Keadaan terlalu tebal ditangkap di sirkuit.  Kasus ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sangat umum</a> di Java Script, tetapi dapat juga terjadi di lingkungan lain. </li><li>  Dalam arti yang lebih luas, retensi yang tidak disengaja dari setiap elemen array atau stream, sementara itu diasumsikan bahwa elemen-elemen ini akan diproses streaming online. </li></ul><br>  <i>Cara menentukan apakah kebocoran termasuk dalam kategori ini</i> <br><br><ul><li>  Jika program berjalan di lingkungan dengan pengumpulan sampah, maka ini adalah opsi yang kami pertimbangkan terlebih dahulu. </li><li>  Bandingkan ukuran tumpukan yang ditampilkan dalam statistik pengumpul sampah dengan ukuran memori bebas yang dihasilkan oleh sistem operasi.  Jika kebocoran masuk ke dalam kategori ini, maka jumlahnya akan sebanding dan, yang paling penting, akan mengikuti satu sama lain dari waktu ke waktu. </li></ul><br>  <i>Cara menemukan kebocoran seperti itu</i> <br><br>  Gunakan profiler atau heap dump tools yang tersedia di lingkungan Anda.  Saya tahu ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">guppy</a> di Python atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memory_profiler</a> di Ruby, dan saya juga menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ObjectSpace</a> langsung di Ruby. <br><br>  <b>Jenis (3): memori bebas tetapi tidak digunakan atau tidak dapat digunakan</b> <br><br>  Kategori ini paling sulit dikarakterisasi, tetapi justru yang paling penting untuk dipahami dan diperhitungkan. <br><br>  Kebocoran tipe ini terjadi di zona abu-abu, di antara memori, yang dianggap "bebas" dari sudut pandang pengalokasi di dalam VM atau lingkungan runtime, dan memori, yang "bebas" dari sudut pandang sistem operasi.  Alasan paling umum (tapi bukan satu-satunya) untuk fenomena ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan tumpukan</a> .  Beberapa pengalokasi hanya mengambil dan tidak mengembalikan memori ke sistem operasi setelah dialokasikan. <br><br>  Kasus semacam ini dapat dipertimbangkan dengan contoh program singkat yang ditulis dengan Python: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> guppy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hpy hp = hpy() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rss</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4096</span></span> * int(open(<span class="hljs-string"><span class="hljs-string">'/proc/self/stat'</span></span>).read().split(<span class="hljs-string"><span class="hljs-string">' '</span></span>)[<span class="hljs-number"><span class="hljs-number">23</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcsize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hp.heap().size rss0, gc0 = (rss(), gcsize()) buf = [bytearray(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">200</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>)] print(<span class="hljs-string"><span class="hljs-string">"start rss={} gcsize={}"</span></span>.format(rss()-rss0, gcsize()-gc0)) buf = buf[::<span class="hljs-number"><span class="hljs-number">2</span></span>] print(<span class="hljs-string"><span class="hljs-string">"end rss={} gcsize={}"</span></span>.format(rss()-rss0, gcsize()-gc0))</code> </pre> <br>  Kami mengalokasikan 200.000 buffer 1-kb, dan kemudian menyimpan setiap berikutnya.  Setiap detik, kami menampilkan status memori dari sudut pandang sistem operasi dan dari sudut pandang pengumpul sampah Python kami sendiri. <br><br>  Di laptop saya, saya mendapatkan sesuatu seperti ini: <br><br> <code>start rss=232222720 gcsize=11667592 <br> end rss=232222720 gcsize=5769520</code> <br> <br>  Kita dapat memastikan bahwa Python benar-benar membebaskan setengah dari buffer, karena tingkat gcsize turun hampir setengah dari nilai puncak, tetapi tidak dapat mengembalikan satu byte memori ini ke sistem operasi.  Memori yang dibebaskan tetap dapat diakses oleh proses Python yang sama, tetapi tidak untuk proses lain pada mesin ini. <br><br>  Fragmen memori yang bebas tetapi tidak digunakan seperti itu bisa bermasalah dan tidak berbahaya.  Jika program Python bertindak seperti ini dan kemudian mengalokasikan beberapa fragmen 1kb, maka ruang ini hanya digunakan kembali, dan semuanya baik-baik saja. <br><br>  Tetapi, jika kita melakukan ini selama pengaturan awal, dan kemudian mengalokasikan memori seminimal mungkin, atau jika semua fragmen yang dialokasikan selanjutnya masing-masing adalah 1,5 kb dan tidak sesuai dengan buffer yang tersisa sebelumnya, maka semua memori yang dialokasikan dengan cara ini akan selalu berdiri diam akan sia-sia. <br><br>  Masalah semacam ini sangat relevan dalam lingkungan tertentu, yaitu, dalam sistem server multiproses untuk bekerja dengan bahasa seperti Ruby atau Python. <br><br>  Katakanlah kita membuat sistem di mana: <br><br><ul><li>  Di setiap server, N pekerja single-threaded digunakan untuk melayani permintaan secara kompeten.  Mari kita ambil N = 10 untuk akurasi. </li><li>  Sebagai aturan, setiap karyawan memiliki jumlah memori yang hampir konstan.  Untuk akurasi, mari ambil 500MB. </li><li>  Dengan frekuensi rendah, kami menerima permintaan yang membutuhkan lebih banyak memori daripada permintaan median.  Untuk akurasi, mari kita asumsikan bahwa sekali semenit kita mendapatkan permintaan, waktu eksekusi yang tambahannya membutuhkan memori 1GB tambahan, dan ketika permintaan diproses, memori ini dibebaskan. </li></ul><br>  Sekali semenit, permintaan "cetacean" semacam itu tiba, proses yang kami percayakan kepada salah satu dari 10 pekerja, misalnya, secara acak: <code>~random</code> .  Idealnya, selama pemrosesan permintaan ini, karyawan ini harus mengalokasikan 1GB RAM, dan setelah kerja selesai, kembalikan memori ini ke sistem operasi sehingga dapat digunakan kembali nanti.  Untuk memproses permintaan tanpa batas dengan prinsip ini, server hanya perlu 10 * 500MB + 1GB = 6GB RAM. <br><br>  Namun, mari kita asumsikan bahwa karena fragmentasi atau karena alasan lain, mesin virtual tidak akan pernah dapat mengembalikan memori ini ke sistem operasi.  Artinya, jumlah RAM yang dibutuhkan dari OS sama dengan jumlah memori terbesar yang harus Anda alokasikan sekaligus.  Dalam hal ini, ketika seorang karyawan tertentu melayani permintaan intensif sumber daya seperti itu, area yang ditempati oleh proses dalam memori akan selamanya membengkak oleh seluruh gigabyte. <br><br>  Ketika Anda memulai server, Anda akan melihat bahwa jumlah memori yang digunakan adalah 10 * 500MB = 5GB.  Segera setelah permintaan besar pertama tiba, pekerja pertama membutuhkan memori 1GB, dan kemudian tidak mengembalikannya.  Jumlah total memori yang digunakan akan melonjak menjadi 6GB.  Permintaan masuk berikut kadang-kadang dapat dialihkan ke proses yang sebelumnya memproses "paus", dalam hal ini jumlah memori yang digunakan tidak akan berubah.  Tetapi kadang-kadang permintaan sebesar itu akan dikirimkan ke karyawan lain, karena itu ingatannya akan meningkat sebesar 1GB, dan seterusnya hingga setiap karyawan dapat memproses permintaan sebesar itu setidaknya satu kali.  Dalam hal ini, Anda akan membutuhkan hingga 10 * (500MB + 1GB) = 15GB RAM dengan operasi ini, yang jauh lebih dari 6GB ideal!  Selain itu, jika Anda melihat bagaimana armada server digunakan dari waktu ke waktu, Anda dapat melihat bagaimana jumlah memori yang digunakan secara bertahap tumbuh dari 5GB menjadi 15GB, yang akan sangat mengingatkan pada kebocoran "nyata". <br><br>  <i>Cara menentukan apakah kebocoran termasuk dalam kategori ini</i> <br><br><ul><li>  Bandingkan ukuran tumpukan yang ditampilkan dalam statistik pengumpul sampah dengan ukuran memori bebas yang dihasilkan oleh sistem operasi.  Jika kebocoran termasuk dalam kategori (ketiga) ini, maka jumlahnya akan berbeda dari waktu ke waktu. </li><li>  Saya ingin mengonfigurasi server aplikasi saya sehingga kedua angka ini secara berkala menangkis dalam infrastruktur deret waktu saya, jadi nyaman untuk menampilkan grafik pada mereka. </li><li>  Di Linux, lihat status sistem operasi di bidang 24 dari <code>/proc/self/stat</code> , dan lihat pengalokasi memori melalui bahasa atau API khusus mesin virtual. </li></ul><br>  <i>Cara menemukan kebocoran seperti itu</i> <br><br>  Seperti yang telah disebutkan, kategori ini sedikit lebih berbahaya daripada yang sebelumnya, karena masalah sering muncul bahkan ketika semua komponen bekerja "sebagaimana dimaksud".  Namun, ada sejumlah trik yang berguna untuk membantu mengurangi atau mengurangi dampak dari "kebocoran virtual" tersebut: <br><br><ul><li>  Mulai ulang proses Anda lebih sering.  Jika masalah tumbuh lambat, maka mungkin me-restart semua proses aplikasi sekali setiap 15 menit atau sekali per jam mungkin tidak sulit. </li><li>  Pendekatan yang bahkan lebih radikal: Anda dapat mengajarkan semua proses untuk memulai kembali secara mandiri, segera setelah ruang yang mereka tempati dalam memori melebihi nilai ambang tertentu atau tumbuh dengan nilai yang telah ditentukan.  Namun, cobalah untuk meramalkan bahwa seluruh armada server Anda tidak dapat memulai restart sinkron spontan. </li><li>  Ubah pengalokasi memori.  Dalam jangka panjang, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tcmalloc</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jemalloc</a> biasanya menangani fragmentasi jauh lebih baik daripada pengalokasi default, dan bereksperimen dengannya sangat nyaman menggunakan variabel <code>LD_PRELOAD</code> . </li><li>  Cari tahu apakah Anda memiliki kueri individual yang menghabiskan lebih banyak memori daripada yang lain.  Di Stripe, server API kami mengukur RSS (konsumsi memori konstan) sebelum dan setelah melayani setiap permintaan API dan mencatat delta.  Kemudian, kami dengan mudah meminta sistem agregasi log kami untuk menentukan apakah ada terminal dan pengguna (dan pola) yang dapat digunakan untuk menghapus semburan konsumsi memori. </li><li>  Sesuaikan pengumpul sampah / pengalokasi memori.  Banyak dari mereka memiliki parameter yang dapat disesuaikan yang memungkinkan Anda menentukan seberapa aktif mekanisme tersebut akan mengembalikan memori ke sistem operasi, seberapa optimalnya untuk menghilangkan fragmentasi;  ada opsi berguna lainnya.  Semuanya di sini juga cukup rumit: pastikan Anda memahami dengan tepat apa yang Anda ukur dan optimalkan, dan cobalah untuk menemukan ahli di mesin virtual yang sesuai dan berkonsultasi dengannya. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432072/">https://habr.com/ru/post/id432072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432060/index.html">Cara terbaik untuk menghafal kata-kata bahasa Inggris</a></li>
<li><a href="../id432062/index.html">Pengembangan AI menggunakan contoh game Dicey Dungeons</a></li>
<li><a href="../id432064/index.html">Cara melarikan diri dari "hares". Instruksi UV</a></li>
<li><a href="../id432068/index.html">Cara memfasilitasi studi Bahasa Inggris: 5 layanan bermanfaat</a></li>
<li><a href="../id432070/index.html">Secara singkat tentang saluran redux-saga</a></li>
<li><a href="../id432074/index.html">Bagaimana pemain merobek kain realitas Spelunky dengan senapan</a></li>
<li><a href="../id432076/index.html">Fungsi yang tidak dikenali memperlambat program 5 kali</a></li>
<li><a href="../id432078/index.html">Lalu lintas di ujung terowongan atau DNS di pentest</a></li>
<li><a href="../id432080/index.html">Pemain salah paham saat menilai risiko. Kontrol generator angka acak dalam pengembangan</a></li>
<li><a href="../id432082/index.html">Microsoft AI Chatbot Meluncurkan Koleksi Pakaian Cina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>