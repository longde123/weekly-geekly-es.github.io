<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âœ‹ğŸ¿ ğŸš§ ğŸ™†ğŸ¾ [DotNetBook] Rentang: Baru. Tipe Data NET ğŸ¤³ğŸ¿ ğŸ‘ ğŸ§˜ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan artikel ini, saya terus menerbitkan serangkaian artikel, yang hasilnya akan menjadi buku tentang karya .NET CLR, dan .NET secara umum (sekitar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[DotNetBook] Rentang: Baru. Tipe Data NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/418911/"><p><img width="350" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png" align="left">  Dengan artikel ini, saya terus menerbitkan serangkaian artikel, yang hasilnya akan menjadi buku tentang karya .NET CLR, dan .NET secara umum (sekitar 200 halaman buku sudah siap, jadi selamat datang di akhir artikel untuk tautan). </p><br><p>  Baik bahasa dan platform telah ada selama bertahun-tahun: dan selama ini ada banyak alat untuk bekerja dengan kode yang tidak dikelola.  Jadi mengapa sekarang API berikutnya untuk bekerja dengan kode yang tidak terkelola keluar jika sebenarnya sudah ada selama bertahun-tahun?  Untuk menjawab pertanyaan ini, cukup memahami apa yang hilang sebelumnya. </p><br><p> Pengembang platform telah mencoba membantu kami mencerahkan kehidupan sehari-hari pembangunan dengan menggunakan sumber daya yang tidak dikelola: ini adalah pembungkus otomatis untuk metode yang diimpor.  Dan marshalling, yang dalam banyak kasus berfungsi secara otomatis.  Ini juga merupakan instruksi <code>stackallloc</code> , yang dibahas dalam bab tentang tumpukan thread.  Namun, bagi saya, jika pengembang awal yang menggunakan C # berasal dari dunia C ++ (seperti yang saya lakukan), sekarang mereka berasal dari bahasa tingkat yang lebih tinggi (misalnya, saya tahu pengembang yang berasal dari JavaScript).  Apa artinya ini?  Ini berarti bahwa orang semakin curiga terhadap sumber daya dan konstruksi yang tidak dikelola yang serupa semangatnya dengan C / C ++ dan bahkan lebih lagi bagi Assembler. </p><br><blockquote><h3>  Catatan </h3><br>  Bab yang diterbitkan di HabrÃ© tidak diperbarui dan, mungkin, sudah agak ketinggalan zaman.  Dan karena itu, silakan buka teks asli untuk teks yang lebih baru: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub, daftar isi</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  Buku CLR: <a href="">GitHub, bab</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Rilis 0,5.2 buku, PDF: <a href="">Rilis GitHub</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p><a name="habracut"></a><br><p>  Sebagai hasil dari sikap seperti itu, semakin sedikit konten kode tidak aman dalam proyek dan semakin percaya pada API platform itu sendiri.  Ini mudah diverifikasi dengan melihat penggunaan konstruksi <code>stackalloc</code> di seluruh repositori terbuka: ia dapat diabaikan.  Tetapi jika Anda mengambil kode apa pun yang menggunakannya: </p><br><p>  <strong>Kelas Interop.ReadDir</strong> <br>  <a href="">/src/mscorlib/shared/Interop/Unix/System.Native/Interop.ReadDir.cs</a> </p><br><pre> <code class="plaintext hljs">unsafe { // s_readBufferSize is zero when the native implementation does not support reading into a buffer. byte* buffer = stackalloc byte[s_readBufferSize]; InternalDirectoryEntry temp; int ret = ReadDirR(dir.DangerousGetHandle(), buffer, s_readBufferSize, out temp); // We copy data into DirectoryEntry to ensure there are no dangling references. outputEntry = ret == 0 ? new DirectoryEntry() { InodeName = GetDirectoryEntryName(temp), InodeType = temp.InodeType } : default(DirectoryEntry); return ret; }</code> </pre> <br><p>  Ini menjadi alasan yang jelas untuk ketidakpopuleran.  Lihatlah tanpa membaca kode dan jawab satu pertanyaan untuk diri sendiri: apakah Anda mempercayainya?  Saya dapat berasumsi bahwa jawabannya adalah tidak.  Lalu jawab yang lain: mengapa?  Jawabannya akan jelas: selain melihat kata <code>Dangerous</code> , yang entah bagaimana mengisyaratkan bahwa ada sesuatu yang salah, faktor kedua yang mempengaruhi sikap kita adalah baris <code>byte* buffer = stackalloc byte[s_readBufferSize];</code>  , dan lebih khusus lagi, <code>byte*</code> .  Catatan ini adalah pemicu bagi siapa saja sehingga pikiran itu muncul di kepala saya: "apa, tidak bisa dilakukan secara berbeda atau apa?".  Kalau begitu mari kita lihat sedikit lebih jauh psikoanalisis: mengapa pemikiran seperti itu muncul?  Di satu sisi, kami menggunakan konstruksi bahasa dan sintaks yang diusulkan di sini jauh dari, misalnya, C ++ / CLI, yang memungkinkan Anda untuk melakukan apa saja (termasuk menyisipkan pada Assembler murni), dan di sisi lain, itu terlihat tidak biasa. </p><br><p>  Jadi apa pertanyaannya?  Bagaimana cara mengembalikan pengembang ke pangkuan kode yang tidak dikelola?  Penting untuk memberi mereka perasaan tenang bahwa mereka tidak dapat membuat kesalahan secara tidak sengaja, karena ketidaktahuan.  Jadi, mengapa <code> Span&lt;T&gt;</code> dan <code>Memory&lt;T&gt;</code> diperkenalkan? </p><br><h2 id="spant-readonlyspant">  Rentang [T], BacaHanyapan [T] </h2><br><p>  Tipe <code>Span</code> mewakili bagian dari array data tertentu, sub-rentang nilainya.  Pada saat yang sama, memungkinkan, seperti halnya array, untuk bekerja dengan elemen-elemen dari rentang ini baik untuk menulis maupun membaca.  Namun, untuk overclocking dan pemahaman umum, mari kita bandingkan tipe data yang menjadi implementasi dari tipe <code>Span</code> dan lihat kemungkinan tujuan pengenalannya. </p><br><p>  Jenis data pertama yang ingin Anda bicarakan adalah array reguler.  Untuk array, bekerja dengan Span akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs"> var array = new [] {1,2,3,4,5,6}; var span = new Span&lt;int&gt;(array, 1, 3); var position = span.BinarySearch(3); Console.WriteLine(span[position]); // -&gt; 3</code> </pre> <br><p>  Seperti yang kita lihat dalam contoh ini, untuk permulaan kita membuat array data tertentu.  Setelah itu, kami membuat <code>Span</code> (atau subset), yang, merujuk pada array itu sendiri, memungkinkan kodenya untuk hanya menggunakan rentang nilai yang ditentukan selama inisialisasi. </p><br><p>  Di sini kita melihat properti pertama dari tipe data ini: ini menciptakan beberapa konteks.  Mari kembangkan ide kita dengan konteks: </p><br><pre> <code class="plaintext hljs">void Main() { var array = new [] {'1','2','3','4','5','6'}; var span = new Span&lt;char&gt;(array, 1, 3); if(TryParseInt32(span, out var res)) { Console.WriteLine(res); } else { Console.WriteLine("Failed to parse"); } } public bool TryParseInt32(Span&lt;char&gt; input, out int result) { result = 0; for (int i = 0; i &lt; input.Length; i++) { if(input[i] &lt; '0' || input[i] &gt; '9') return false; result = result * 10 + ((int)input[i] - '0'); } return true; } ----- 234</code> </pre> <br><p>  Seperti yang bisa kita lihat, <code>Span&lt;T&gt;</code> memperkenalkan abstraksi akses ke bagian memori tertentu, baik untuk membaca maupun menulis.  Apa yang ini berikan pada kita?  Jika kita mengingat apa lagi yang dapat dibuat berdasarkan <code>Span</code> , maka kita mengingat sumber daya dan jalur yang tidak dikelola: </p><br><pre> <code class="plaintext hljs">// Managed array var array = new[] { '1', '2', '3', '4', '5', '6' }; var arrSpan = new Span&lt;char&gt;(array, 1, 3); if (TryParseInt32(arrSpan, out var res1)) { Console.WriteLine(res1); } // String var srcString = "123456"; var strSpan = srcString.AsSpan().Slice(1, 3); if (TryParseInt32(strSpan, out var res2)) { Console.WriteLine(res2); } // void * Span&lt;char&gt; buf = stackalloc char[6]; buf[0] = '1'; buf[1] = '2'; buf[2] = '3'; buf[3] = '4'; buf[4] = '5'; buf[5] = '6'; if (TryParseInt32(buf.Slice(1, 3), out var res3)) { Console.WriteLine(res3); } ----- 234 234 234</code> </pre> <br><p>  Yaitu, ternyata <code>Span&lt;T&gt;</code> adalah alat unifikasi untuk bekerja dengan memori: terkelola dan tidak terkelola, yang menjamin keamanan dalam bekerja dengan data semacam ini selama Pengumpulan Sampah: jika area memori dengan array yang dikelola mulai bergerak, maka untuk itu akan aman bagi kita. </p><br><p>  Namun, apakah pantas untuk bersukacita begitu banyak?  Mungkinkah semua ini telah dicapai sebelumnya?  Sebagai contoh, jika kita berbicara tentang array yang dikelola, maka tidak ada keraguan sama sekali: cukup bungkus array di kelas lain, menyediakan antarmuka yang sama dan Anda selesai.  Selain itu, operasi serupa dapat dilakukan dengan string: mereka memiliki metode yang diperlukan.  Sekali lagi, cukup bungkus string dengan tipe yang persis sama dan berikan metode untuk bekerja dengannya.  Hal lain adalah bahwa untuk menyimpan string, buffer atau array dalam satu jenis, Anda harus mengotak-atik banyak dengan menyimpan tautan ke masing-masing opsi yang mungkin dalam satu salinan (tentu saja, hanya satu yang akan aktif): </p><br><pre> <code class="plaintext hljs">public readonly ref struct OurSpan&lt;T&gt; { private T[] _array; private string _str; private T * _buffer; // ... }</code> </pre> <br><p>  Atau, jika Anda memulai dari arsitektur, maka lakukan tiga jenis yang mewarisi satu antarmuka.  Ternyata untuk membuat alat antarmuka terpadu antara tipe data ini <code>managed</code> , sambil mempertahankan kinerja maksimum, tidak ada cara lain selain <code>Span&lt;T&gt;</code> . </p><br><p>  Selanjutnya, untuk melanjutkan diskusi, apa yang dimaksud dengan <code>ref struct</code> dalam hal <code>Span</code> ?  Ini justru "struktur, mereka hanya di tumpukan," yang sering kita dengar dalam wawancara.  Dan ini berarti tipe data ini hanya bisa melalui tumpukan dan tidak memiliki hak untuk pergi ke tumpukan.  Dan oleh karena itu, <code>Span</code> , menjadi struktur referensi, adalah tipe data konteks yang menyediakan metode, tetapi bukan objek dalam memori.  Dari sini, untuk pengertiannya, kita harus melanjutkan. </p><br><p>  Dari sini kita dapat merumuskan definisi tipe Span dan tipe ReadonlySpan yang hanya baca yang terkait dengannya: </p><br><blockquote>  Span adalah tipe data yang menyediakan antarmuka tunggal untuk bekerja dengan tipe array data yang heterogen serta kemampuan untuk mentransfer subset dari array ini ke metode lain sehingga, terlepas dari kedalaman konteks, kecepatan akses ke array asli konstan dan setinggi mungkin. </blockquote><p>  Dan sungguh: jika kita memiliki sesuatu seperti kode ini: </p><br><pre> <code class="plaintext hljs">public void Method1(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method2(buffer.Slice(1,2)); } Method2(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method3(buffer.Slice(1,1)); } Method3(Span&lt;byte&gt; buffer) { buffer[0] = 0; }</code> </pre> <br><p>  maka kecepatan akses ke buffer sumber akan setinggi mungkin: Anda bekerja bukan dengan objek yang dikelola, tetapi dengan pointer yang dikelola.  Yaitu  bukan dengan tipe .NET yang dikelola, tetapi dengan tipe yang tidak aman yang dibungkus dengan shell yang dikelola. </p><br><h3 id="spant-na-primerah">  Rentang [T] dengan contoh </h3><br><p>  Seseorang begitu teratur sehingga seringkali sampai ia menerima pengalaman tertentu, maka pemahaman akhir tentang mengapa suatu alat dibutuhkan sering tidak datang.  Karena itu, karena kita perlu pengalaman, mari kita beralih ke contoh. </p><br><h4 id="valuestringbuilder">  ValueStringBuilder </h4><br><p>  Salah satu contoh yang paling menarik secara algoritmik adalah tipe <code>ValueStringBuilder</code> , yang dikubur di suatu tempat di perut <code>mscorlib</code> dan untuk beberapa alasan, seperti banyak tipe data menarik lainnya, ditandai dengan pengubah <code>internal</code> , yang berarti bahwa jika bukan untuk studi kode sumber mscorlib, kita akan berbicara tentang metode optimasi yang luar biasa, tidak akan pernah tahu. </p><br><p>  Apa minus utama dari tipe sistem StringBuilder?  Ini, tentu saja, adalah esensinya: dia sendiri dan berdasarkan apa dia (dan ini adalah array <code>char[]</code> ) adalah tipe referensi.  Dan itu berarti setidaknya dua hal: kita masih (walaupun sedikit) memuat banyak dan yang kedua - kita meningkatkan kemungkinan kehilangan cache prosesor. </p><br><p>  Pertanyaan lain yang saya miliki untuk StringBuilder adalah pembentukan string kecil.  Yaitu  ketika baris hasil "memberi gigi" akan pendek: misalnya, kurang dari 100 karakter.  Ketika kami memiliki pemformatan yang cukup singkat, masalah kinerja muncul: </p><br><pre> <code class="plaintext hljs"> $"{x} is in range [{min};{max}]"</code> </pre> <br><p>  Seberapa parahkah catatan ini daripada pembuatan manual melalui StringBuilder?  Jawabannya jauh dari selalu jelas: semuanya tergantung pada tempat pembentukan: seberapa sering metode ini akan dipanggil.  Setelah semua, <code>string.Format</code> pertama.Format mengalokasikan memori untuk <code>StringBuilder</code> internal, yang akan membuat array karakter (SourceString.Length + args.Length * 8) dan jika selama pembentukan array ternyata panjangnya tidak ditebak, maka <code>StringBuilder</code> lain akan dibuat untuk membentuk kelanjutan, dengan demikian membentuk daftar yang hanya terhubung.  Dan sebagai hasilnya, akan diperlukan untuk mengembalikan baris yang dihasilkan: dan ini adalah salinan lain.  Menyia-nyiakan dan menyia-nyiakan.  Sekarang, jika kita dapat menyingkirkan penempatan array pertama dari string yang dibentuk pada heap, itu akan luar biasa: kita pasti akan menyingkirkan satu masalah. </p><br><p>  Lihatlah jenis dari usus <code>mscorlib</code> : </p><br><p>  <strong>Kelas ValueStringBuilder</strong> <br>  <a href="">/ src / mscorlib / shared / System / Text / ValueStringBuilder</a> </p><br><pre> <code class="plaintext hljs"> internal ref struct ValueStringBuilder { //           private char[] _arrayToReturnToPool; //     private Span&lt;char&gt; _chars; private int _pos; //    ,       public ValueStringBuilder(Span&lt;char&gt; initialBuffer) { _arrayToReturnToPool = null; _chars = initialBuffer; _pos = 0; } public int Length { get =&gt; _pos; set { int delta = value - _pos; if (delta &gt; 0) { Append('\0', delta); } else { _pos = value; } } } //   -       public override string ToString() { var s = new string(_chars.Slice(0, _pos)); Clear(); return s; } //       //     :   public void Insert(int index, char value, int count) { if (_pos &gt; _chars.Length - count) { Grow(count); } int remaining = _pos - index; _chars.Slice(index, remaining).CopyTo(_chars.Slice(index + count)); _chars.Slice(index, count).Fill(value); _pos += count; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Append(char c) { int pos = _pos; if (pos &lt; _chars.Length) { _chars[pos] = c; _pos = pos + 1; } else { GrowAndAppend(c); } } [MethodImpl(MethodImplOptions.NoInlining)] private void GrowAndAppend(char c) { Grow(1); Append(c); } //   ,     //         //            //           [MethodImpl(MethodImplOptions.NoInlining)] private void Grow(int requiredAdditionalCapacity) { Debug.Assert(requiredAdditionalCapacity &gt; _chars.Length - _pos); char[] poolArray = ArrayPool&lt;char&gt;.Shared.Rent(Math.Max(_pos + requiredAdditionalCapacity, _chars.Length * 2)); _chars.CopyTo(poolArray); char[] toReturn = _arrayToReturnToPool; _chars = _arrayToReturnToPool = poolArray; if (toReturn != null) { ArrayPool&lt;char&gt;.Shared.Return(toReturn); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Clear() { char[] toReturn = _arrayToReturnToPool; this = default; // for safety, to avoid using pooled array if this instance is erroneously appended to again if (toReturn != null) { ArrayPool&lt;char&gt;.Shared.Return(toReturn); } } //  :       private void AppendSlow(string s); public bool TryCopyTo(Span&lt;char&gt; destination, out int charsWritten); public void Append(string s); public void Append(char c, int count); public unsafe void Append(char* value, int length); public Span&lt;char&gt; AppendSpan(int length); }</code> </pre> <br><p>  Kelas ini memiliki fungsionalitas yang mirip dengan kakaknya, <code>StringBuilder</code> , tetapi memiliki satu fitur yang menarik dan sangat penting: ini adalah tipe yang signifikan.  Yaitu  disimpan dan dikirim seluruhnya berdasarkan nilai.  Dan pengubah tipe <code>ref</code> terbaru, yang ditugaskan untuk tanda tangan dari deklarasi tipe, memberi tahu kita bahwa tipe ini memiliki batasan tambahan: ia memiliki hak untuk berada di stack saja.  Yaitu  output instansnya ke bidang kelas akan menghasilkan kesalahan.  Kenapa semua squat ini?  Untuk menjawab pertanyaan ini, lihat saja kelas <code>StringBuilder</code> , esensi yang baru saja kami jelaskan: </p><br><p>  <strong>Class StringBuilder</strong> <a href="">/src/mscorlib/src/System/Text/StringBuilder.cs</a> </p><br><pre> <code class="plaintext hljs">public sealed class StringBuilder : ISerializable { // A StringBuilder is internally represented as a linked list of blocks each of which holds // a chunk of the string. It turns out string as a whole can also be represented as just a chunk, // so that is what we do. internal char[] m_ChunkChars; // The characters in this block internal StringBuilder m_ChunkPrevious; // Link to the block logically before this block internal int m_ChunkLength; // The index in m_ChunkChars that represent the end of the block internal int m_ChunkOffset; // The logical offset (sum of all characters in previous blocks) internal int m_MaxCapacity = 0; // ... internal const int DefaultCapacity = 16;</code> </pre> <br><p>  StringBuilder adalah kelas di dalamnya yang memiliki tautan ke berbagai karakter.  Yaitu  ketika Anda membuatnya, pada kenyataannya, setidaknya dua objek dibuat: StringBuilder itu sendiri dan sebuah array karakter setidaknya 16 karakter (omong-omong, itu sebabnya sangat penting untuk menentukan perkiraan panjang string: konstruksinya akan melalui pembuatan daftar array 16-karakter yang terhubung secara tunggal. )  Apa artinya ini dalam konteks percakapan kami tentang tipe ValueStringBuilder: kapasitas tidak ada secara default, karena  dibutuhkan memori dari luar, ditambah itu sendiri adalah tipe yang signifikan dan memaksa pengguna untuk mengalokasikan buffer untuk karakter pada stack.  Akibatnya, seluruh instance type didorong ke stack bersama dengan kontennya, dan masalah optimisasi di sini menjadi teratasi.  Tidak ada alokasi memori di heap?  Tidak ada masalah dengan kinerja kendur di heap.  Tetapi Anda memberi tahu saya: mengapa tidak menggunakan ValueStringBuilder (atau versi yang ditulis sendiri: apakah itu internal dan tidak dapat diakses oleh kami) selalu?  Jawabannya adalah: Anda perlu melihat masalah yang sedang Anda pecahkan.  Akankah string yang dihasilkan berukuran diketahui?  Apakah akan memiliki panjang maksimal tertentu yang diketahui?  Jika jawabannya adalah ya dan jika ukuran string tidak melampaui batas yang masuk akal, maka Anda dapat menggunakan versi StringBuilder yang bermakna.  Kalau tidak, jika kita mengharapkan antrean panjang, kita beralih menggunakan versi reguler. </p><br><h4 id="valuelistbuilder">  ValueListBuilder </h4><br><p>  Tipe data kedua yang ingin saya perhatikan adalah tipe <code>ValueListBuilder</code> .  Itu dibuat untuk situasi ketika perlu untuk membuat kumpulan elemen untuk waktu yang singkat dan segera memberikannya kepada beberapa algoritma untuk diproses. </p><br><p>  Setuju: tugas ini sangat mirip dengan tugas <code>ValueStringBuilder</code> .  Ya, dan itu diselesaikan dengan cara yang sangat mirip: </p><br><p>  <strong>File <a href="">ValueListBuilder.cs</a></strong> </p><br><p>  Terus terang, situasi seperti itu cukup umum.  Namun, sebelum kami menyelesaikan pertanyaan ini dengan cara lain: kami membuat <code>List</code> , mengisinya dengan data dan kehilangan tautan.  Jika metode ini cukup sering dipanggil, muncul situasi yang menyedihkan: banyak instance dari kelas <code>List</code> digantung di heap, dan dengan mereka array yang terkait dengan mereka digantung di heap.  Sekarang masalah ini telah dipecahkan: tidak ada objek tambahan yang akan dibuat.  Namun, seperti dalam kasus <code>ValueStringBuilder</code> , itu diselesaikan hanya untuk pemrogram Microsoft: kelas memiliki pengubah <code>internal</code> . </p><br><h3 id="pravila-i-praktika-ispolzovaniya">  Syarat dan ketentuan penggunaan </h3><br><p>  Untuk akhirnya memahami esensi dari tipe data baru, Anda perlu "bermain-main" dengannya dengan menulis beberapa hal, atau lebih baik, lebih banyak metode menggunakannya.  Namun, aturan dasar dapat dipelajari sekarang: </p><br><ul><li>  Jika metode Anda akan memproses beberapa set data yang masuk tanpa mengubah ukurannya, Anda dapat mencoba untuk berhenti pada tipe <code>Span</code> .  Jika tidak ada modifikasi buffer ini, maka pada tipe <code>ReadOnlySpan</code> ; </li><li>  Jika metode Anda akan bekerja dengan string, menghitung beberapa statistik atau mengurai string, maka metode Anda <em>harus</em> menerima <code>ReadOnlySpan&lt;char&gt;</code> .  Ini wajib: ini adalah aturan baru.  Lagi pula, jika Anda menerima string, maka Anda memaksa seseorang untuk membuat substring untuk Anda </li><li>  Jika Anda perlu membuat array yang cukup pendek dengan data (katakanlah, maksimum 10Kb) sebagai bagian dari pekerjaan metode, maka Anda dapat dengan mudah mengatur array seperti itu menggunakan <code>Span&lt;TType&gt; buf = stackalloc TType[size]</code> .  Namun, tentu saja, TType seharusnya hanya tipe yang bermakna, seperti  <code>stackalloc</code> hanya bekerja dengan tipe yang berarti. </li></ul><br><p>  Dalam kasus lain, ada baiknya melihat lebih dekat pada <code>Memory</code> atau menggunakan tipe data klasik. </p><br><h3 id="kak-rabotaet-span">  Bagaimana Span Bekerja </h3><br><p>  Selain itu, saya ingin berbicara tentang bagaimana Span bekerja dan apa yang sangat luar biasa tentangnya.  Dan ada sesuatu untuk dibicarakan: tipe data itu sendiri dibagi menjadi dua versi: untuk .NET Core 2.0+ dan untuk semua orang. </p><br><p>  <strong><a href="">Span.Fast.cs, .NET Core 2.0</a> File</strong> </p><br><pre> <code class="plaintext hljs">public readonly ref partial struct Span&lt;T&gt; { ///    .NET    internal readonly ByReference&lt;T&gt; _pointer; ///      private readonly int _length; // ... }</code> </pre> <br><p>  <strong>File ???</strong>  <strong>[didekompilasi]</strong> </p><br><pre> <code class="plaintext hljs">public ref readonly struct Span&lt;T&gt; { private readonly System.Pinnable&lt;T&gt; _pinnable; private readonly IntPtr _byteOffset; private readonly int _length; // ... }</code> </pre> <br><p>  Masalahnya adalah .NET Framework dan .NET Core 1. * yang besar tidak memiliki pengumpul sampah yang dimodifikasi secara khusus (berbeda dengan versi .NET Core 2.0+) dan karena itu dipaksa untuk menyeret penunjuk tambahan: ke awal buffer dengan mana bekerja.  Yaitu, ternyata <code>Span</code> internal bekerja dengan objek yang dikelola dari platform .NET sebagai tidak dikelola.  Lihatlah bagian dalam versi kedua dari struktur: ada tiga bidang.  Bidang pertama adalah referensi ke objek yang dikelola.  Yang kedua adalah offset dari awal objek ini dalam byte untuk mendapatkan awal buffer data (dalam garis itu adalah buffer dengan karakter <code>char</code> , dalam array itu adalah buffer dengan data array).  Dan akhirnya, bidang ketiga adalah jumlah elemen buffer ini ditumpuk satu demi satu. </p><br><p>  Misalnya, ambil pekerjaan <code>Span</code> untuk string: </p><br><p>  <strong>File <a href="">coreclr :: src / System.Private.CoreLib / shared / System / MemoryExtensions.Fast.cs</a></strong> </p><br><pre> <code class="plaintext hljs">public static ReadOnlySpan&lt;char&gt; AsSpan(this string text) { if (text == null) return default; return new ReadOnlySpan&lt;char&gt;(ref text.GetRawStringData(), text.Length); }</code> </pre> <br><p>  Di mana <code>string.GetRawStringData()</code> sebagai berikut: </p><br><p>  <strong>File definisi lapangan <a href="">coreclr :: src / System.Private.CoreLib / src / System / String.CoreCLR.cs</a></strong> </p><br><p>  <strong>File definisi file <a href="">getRawStringData coreclr :: src / System.Private.CoreLib / shared / System / String.cs</a></strong> </p><br><pre> <code class="plaintext hljs">public sealed partial class String : IComparable, IEnumerable, IConvertible, IEnumerable&lt;char&gt;, IComparable&lt;string&gt;, IEquatable&lt;string&gt;, ICloneable { // // These fields map directly onto the fields in an EE StringObject. See object.h for the layout. // [NonSerialized] private int _stringLength; // For empty strings, this will be '\0' since // strings are both null-terminated and length prefixed [NonSerialized] private char _firstChar; internal ref char GetRawStringData() =&gt; ref _firstChar; }</code> </pre> <br><p>  Yaitu  ternyata metode tersebut berjalan langsung di dalam garis, dan spesifikasi referensi memungkinkan Anda untuk melacak tautan tidak terkelola GC di dalam garis, menggerakkannya bersama dengan garis selama operasi GC. </p><br><p>  Kisah yang sama terjadi dengan array: ketika <code>Span</code> dibuat, beberapa kode di dalam JIT menghitung offset awal data array dan menginisialisasi <code>Span</code> offset ini.  Dan bagaimana cara menghitung offset untuk string dan array, kami belajar di bab tentang struktur objek dalam memori. </p><br><h3 id="spant-kak-vozvraschaemoe-znachenie">  Rentang [T] sebagai nilai kembali </h3><br><p>    ,   <code>Span</code> ,    ,        .     : </p><br><pre> <code class="plaintext hljs">unsafe void Main() { var x = GetSpan(); } public Span&lt;byte&gt; GetSpan() { Span&lt;byte&gt; reff = new byte[100]; return reff; }</code> </pre> <br><p>       . ,     : </p><br><pre> <code class="plaintext hljs">unsafe void Main() { var x = GetSpan(); } public Span&lt;byte&gt; GetSpan() { Span&lt;byte&gt; reff = stackalloc byte[100]; return reff; }</code> </pre> <br><p>      .    , ,     ,       . </p><br><p> ,  ,   ,    ,      .  ,          .         ,   ,     ,       x[0.99]    . </p><br><p> ,  ,        ,     ,  : <code>CS8352 Cannot use local 'reff' in this context because it may expose referenced variables outside of their declaration scope</code>   :     ,   , ,                  . </p><br><h2 id="esli-poyavilis-voprosy">    </h2><br><p>   <code>Span&lt;T&gt;</code>  ,  .         ,    use cases    . </p><br><blockquote><h3>  Tautan ke seluruh buku </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  Buku CLR: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Rilis 0,5.0 buku, PDF: <a href="">Rilis GitHub</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418911/">https://habr.com/ru/post/id418911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418901/index.html">Rusia memenangkan mayoritas medali emas di Olimpiade Ilmu Komputer Eropa eJOI 2018</a></li>
<li><a href="../id418903/index.html">Ilmuwan: COâ‚‚ di Mars tidak cukup untuk menghangatkan atmosfer. Ledakan tiang tidak akan membantu</a></li>
<li><a href="../id418905/index.html">InlineKeyboard di Telegram Bots</a></li>
<li><a href="../id418907/index.html">Cara mengajar Zabbix untuk mengirim pemberitahuan masalah langsung ke desktop</a></li>
<li><a href="../id418909/index.html">Leads Python: Siapa dan Mengapa Menggunakannya</a></li>
<li><a href="../id418913/index.html">UE4 | Inventaris untuk Multi pemain # 1 | Gudang Data di DataAsset</a></li>
<li><a href="../id418915/index.html">Menyeimbangkan lalu lintas antara server Web menggunakan IP CEF pada peralatan jaringan</a></li>
<li><a href="../id418917/index.html">Keamanan dimulai dengan router rumah</a></li>
<li><a href="../id418919/index.html">Tentang pertumbuhan profesional desainer dan bekerja dengan stres. Dan bagaimana menemukan kekuatan di masa-masa paling sulit</a></li>
<li><a href="../id418921/index.html">4 perpustakaan membuat hidup lebih mudah untuk pengembang Bereaksi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>