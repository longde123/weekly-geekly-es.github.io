<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õëÔ∏è ü¶Ö üë®‚Äçüë©‚Äçüëß iOS Netzwerk, wenn die Anwendung nicht ausgef√ºhrt wird ü§∏üèø üö≠ üë®üèø‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Benutzer erwarten, dass das Netzwerk ‚Äûmagisch‚Äú und unbemerkt funktioniert. Diese Magie h√§ngt von den Entwicklern des Systems und der Anwendungen ab. E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS Netzwerk, wenn die Anwendung nicht ausgef√ºhrt wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/478566/"><p><img src="https://habrastorage.org/webt/ok/hf/in/okhfincdajhwvcffenwaoaj6wcs.png" alt="Bild"></p><br><p>  Benutzer erwarten, dass das Netzwerk ‚Äûmagisch‚Äú und unbemerkt funktioniert.  Diese Magie h√§ngt von den Entwicklern des Systems und der Anwendungen ab.  Es ist schwierig, das System zu beeinflussen, daher beschr√§nken wir uns auf die Anwendung. </p><br><p>  Dieses Thema ist komplex und es gibt unz√§hlige Probleme.  Wir werden diejenigen diskutieren, denen wir in den letzten Monaten begegnet sind.  Ich entschuldige mich sofort f√ºr die Lautst√§rke.  Kurz gesagt, keineswegs zu viele kleine Dinge, die es wert sind, beachtet zu werden. </p><a name="habracut"></a><br><p>  Zun√§chst besch√§ftigen wir uns mit der Terminologie. </p><br><p>  Die Daten√ºbertragung erfolgt in zwei Richtungen: </p><br><ul><li>  <em>Herunterladen</em> (Herunterladen, Herunterladen von Daten vom Server), </li><li>  <em>Upload</em> (Senden von Daten an den Server). </li></ul><br><p>  Die Anwendung ist m√∂glicherweise aktiv, arbeitet jedoch m√∂glicherweise im Hintergrund.  Formal hat er <a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle">andere Zust√§nde</a> , aber wir interessieren uns nur f√ºr diese: </p><br><ul><li>  <em>Hintergrund</em> (wenn die Anwendung minimiert ist), </li><li>  <em>aktiv</em> (wenn die Anwendung aktiv ist, auf dem Bildschirm). </li></ul><br><p> N√ºtzliche Muster: <em>R√ºckruf</em> , <em>Delegat</em> ( <a href="https://developer.apple.com/documentation/swift/cocoa_design_patterns">Cocoa Design Patterns</a> , <a href="https://en.wikipedia.org/wiki/Callback_(computer_programming)">√ºber R√ºckruf auf Wikipedia</a> ).  Sie m√ºssen auch wissen, <a href="https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started"><code>  URLSession</code></a> (in dem Artikel erw√§hnt der Link auch die Hintergrundarbeit mit dem Netzwerk, aber im Vorbeigehen). </p><br><p>  Alle Beispiele sind in <a href="https://docs.swift.org/swift-book/">Swift 5 geschrieben</a> , funktionieren unter iOS 11 und neuer (getestet unter iOS 11 und 12) und setzen die Verwendung regul√§rer HTTP-Anforderungen voraus.  Zum gr√∂√üten Teil wird dies alles ab iOS 9 funktionieren, aber es gibt "Nuancen". </p><br><h2 id="obschaya-shema-raboty-s-setyu-urlsession">  Das allgemeine Schema der Arbeit mit dem Netzwerk.  URLSession </h2><br><p>  Die Arbeit mit dem Netzwerk ist nicht besonders schwierig: </p><br><ul><li>  Erstellen Sie die <a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration"><code>URLSessionConfiguration</code></a> Konfiguration. </li><li>  Erstellen Sie eine Konfigurationsinstanz von <a href="https://developer.apple.com/documentation/foundation/urlsession"><code>URLSession</code></a> . </li><li>  Erstellen Sie eine Aufgabe (mit <a href="https://developer.apple.com/documentation/foundation/urlsession/1411554-datatask"><code>session.dataTask(‚Ä¶)</code></a> und √§hnlichen Methoden). </li><li>  Task-Updates abonnieren.  Aktualisierungen erfolgen asynchron, sie k√∂nnen an den <em>Delegaten gesendet werden,</em> der beim Erstellen der Sitzung registriert wird, oder sie befinden sich im <em>R√ºckruf,</em> der beim <em>Erstellen</em> der Aufgabe erstellt wird. </li><li>  Als wir sahen, dass die Aufgabe abgeschlossen ist, kehren wir zur Anwendungslogik zur√ºck. </li></ul><br><p>  Ein einfaches Beispiel sieht so aus: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataTask = session.dataTask(with: url) { data, response, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//     //  callback,    }</span></span></code> </pre> <br><p>  Dieses Schema ist f√ºr verschiedene Aufgaben √§hnlich, nur die kleinen Dinge √§ndern sich.  Und bis wir nicht weiter mit dem Netzwerk arbeiten m√ºssen, nachdem der Benutzer die Anwendung geschlossen hat, ist alles relativ einfach. </p><br><blockquote>  Ich stelle sofort fest, dass es auch in diesem Szenario viele interessante Dinge gibt.  Manchmal m√ºssen Sie mit kniffligen Weiterleitungen arbeiten, manchmal ben√∂tigen Sie eine Autorisierung, SSL-Fixierung oder alles gleichzeitig.  Sie k√∂nnen viel dar√ºber lesen.  Aus irgendeinem Grund wird das Arbeiten mit dem Netzwerk im Hintergrund viel weniger beschrieben. </blockquote><br><h2 id="sozdanie-sessii-dlya-raboty-v-background">  Erstellen einer Sitzung f√ºr die Arbeit im Hintergrund </h2><br><p>  Was ist der Unterschied zwischen der <em>URLSession im</em> Hintergrund und der √ºblichen?  Es funktioniert au√üerhalb des Anwendungsprozesses, irgendwo innerhalb des Systems.  Daher "stirbt" es nicht, wenn der Bewerbungsprozess abgeschlossen ist.  Es wird als Hintergrundsitzung bezeichnet (ebenso wie der etwas verwirrende Status der Anwendung) und erfordert bestimmte Einstellungen.  Zum Beispiel das: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> configuration = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.background(withIdentifier: <span class="hljs-string"><span class="hljs-string">"com.my.app"</span></span>) configuration.sessionSendsLaunchEvents = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.isDiscretionary = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.allowsCellularAccess = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.shouldUseExtendedBackgroundIdleMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.waitsForConnectivity = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: configuration, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><p>  Die Konfiguration enth√§lt viele andere Parameter, die sich jedoch direkt auf Hintergrundsitzungen beziehen: </p><br><ul><li>  <em>bezeichner</em> (im Initialisierer √ºbergeben) ist eine Zeichenfolge, die verwendet wird, um Hintergrundsitzungen abzugleichen, wenn die Anwendung neu gestartet wird.  Wenn die Anwendung neu gestartet wird und Sie eine Hintergrundsitzung mit einer ID erstellen, die bereits in einer anderen Hintergrundsitzung verwendet wird, kann die neue auf die Aufgaben der vorherigen zugreifen.  Die Schlussfolgerung daraus ist einfach.  F√ºr einen ordnungsgem√§√üen Betrieb muss diese Kennung f√ºr Ihre Anwendung eindeutig und dauerhaft sein (Sie k√∂nnen beispielsweise eine Ableitung von <em>BundleId-</em> Anwendungen verwenden). </li><li>  <em>sessionSendsLaunchEvents</em> gibt an, ob die Hintergrundsitzung die Anwendung starten soll, wenn die Daten√ºbertragung abgeschlossen ist.  Wenn dieser Parameter auf <code>false,</code> der Trigger nicht auf und die Anwendung empf√§ngt beim n√§chsten Start alle Ereignisse.  Wenn der Parameter <code>true</code> ist, startet das System nach Abschluss der Daten√ºbertragung die Anwendung und ruft die entsprechende <code>AppDelegate: application(_:handleEventsForBackgroundURLSession:completionHandler:)</code> Methode auf <code>AppDelegate: application(_:handleEventsForBackgroundURLSession:completionHandler:)</code> ; </li><li>  <em>Mit isDiscretionary</em> kann das System Aufgaben seltener planen.  Dies verbessert einerseits die Batterielebensdauer und kann andererseits die Aufgabe verlangsamen.  Oder vielleicht beschleunigen.  Wenn beispielsweise ein gro√ües Volumen heruntergeladen wird, kann das System die Aufgabe anhalten, bis eine Verbindung zum WLAN hergestellt ist, und dann schnell alles herunterladen, ohne langsames mobiles Internet ausgeben zu m√ºssen (wenn dies √ºberhaupt zul√§ssig ist, wie geht es weiter).  Wenn die Aufgabe erstellt wird, w√§hrend sich die Anwendung bereits im Hintergrund befindet, wird dieser Parameter automatisch auf <code>true</code> . </li><li>  <em>allowCellularAccess</em> - Ein Parameter, der <em>angibt</em> , dass Sie die Mobilfunkkommunikation f√ºr die Arbeit mit dem Netzwerk verwenden k√∂nnen.  Ich habe nicht sorgf√§ltig mit ihm gespielt, aber laut Rezensionen sind dort (zusammen mit einem √§hnlichen Systemschalter) eine gro√üe Anzahl von Rechen ausgelegt; </li><li>  <em>shouldUseExtendedBackgroundIdleMode.</em>  Ein n√ºtzlicher Parameter, der anzeigt, dass das System l√§nger eine Verbindung zum Server aufrechterhalten sollte, wenn die Anwendung in den Hintergrund tritt.  Andernfalls wird die Verbindung unterbrochen. </li><li>  <em>waitsForConnectivity</em> Auf einem mobilen Ger√§t kann die Kommunikation f√ºr kurze Zeit unterbrochen werden.  Die zu diesem Zeitpunkt erstellten Aufgaben k√∂nnen entweder angehalten werden, bis eine Verbindung angezeigt wird, oder es wird sofort ein Fehler "Keine Verbindung" zur√ºckgegeben.  Mit dem Parameter k√∂nnen Sie dieses Verhalten steuern.  Wenn es <code>false,</code> bricht die Task ohne Kommunikation sofort mit einem Fehler ab.  Wenn dies <code>true</code> , warten Sie, bis ein Link angezeigt wird. </li><li>  Die letzte Zeile (Session Initializer) enth√§lt einen wichtigen Parameter, <em>delegate.</em>  √úber ihn - ein bisschen mehr. </li></ul><br><h3 id="delegate-vs-callbacks">  Delegiert gegen R√ºckrufe </h3><br><p>  Wie oben erw√§hnt, gibt es zwei M√∂glichkeiten, Ereignisse aus einer Aufgabe / aus einer Sitzung abzurufen.  Der erste ist <em>R√ºckruf:</em> </p><br><pre> <code class="swift hljs">session.dataTask(with: request) { data, response, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ...   }</code> </pre> <br><p>  In diesem Fall wird das Ereignis zur Beendigung der Aufgabe an den Abschluss gesendet, wo Sie √ºberpr√ºfen m√ºssen, ob ein Fehler vorliegt, was in der Antwort enthalten ist und welche Daten eingetroffen sind. </p><br><p>  Die zweite M√∂glichkeit, mit einer Sitzung zu arbeiten, besteht darin, sie zu <em>delegieren.</em>  In diesem Fall m√ºssen wir eine Klasse erstellen, die die <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate"><code>URLSessionDataDelegate</code></a> Protokolle und (oder) andere Protokolle in der <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate"><code>URLSessionDataDelegate</code></a> implementiert (f√ºr verschiedene Aufgabentypen unterscheiden sich die Protokolle geringf√ºgig).  Ein Verweis auf eine Instanz dieser Klasse befindet sich in einer Sitzung und ihre Methoden werden aufgerufen, wenn Ereignisse an den Delegaten √ºbergeben werden.  Der Link kann vom Initialisierer in der Sitzung registriert werden.  Im Beispiel wird <code>self.</code> </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: configuration, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><p>  F√ºr regul√§re Sitzungen stehen beide Methoden zur Verf√ºgung.  Hintergrundsitzungen k√∂nnen nur von einem Delegierten verwendet werden. </p><br><p>  Also haben wir die Sitzung eingerichtet, erstellt und schauen uns an, wie man etwas herunterl√§dt. </p><br><h2 id="obschaya-shema-skachivaniya-dannyh-v-fone">  Allgemeines Schema zum Herunterladen von Daten im Hintergrund </h2><br><p>  Um Daten herunterzuladen, m√ºssen Sie normalerweise eine <a href="https://developer.apple.com/documentation/foundation/urlrequest"><code> (URLRequest)</code></a> , die erforderlichen Parameter / Header / Daten darin registrieren, eine <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask"><code>URLSessionDownloadTask</code></a> erstellen und zur Ausf√ºhrung ausf√ºhren.  Ungef√§hr so: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//  request,   let task = session.downloadTask(with: request) if #available(iOS 11, *) { task.countOfBytesClientExpectsToSend = [approximate size of request] task.countOfBytesClientExpectsToReceive = [approximate size of response] } task.resume()</span></span></code> </pre> <br><p>  Derzeit unterscheidet sich nichts wesentlich von der √ºblichen Download-Aufgabe.  Zwar erschienen zwei Parameter <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1411534-countofbytesexpectedtosend">countOfBytesClientExpectsToSend</a> / <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1410663-countofbytesexpectedtoreceive">countOfBytesClientExpectsToReceive</a> , sie zeigen die Datenmenge an, die wir in der Anfrage senden und in der Antwort <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1411534-countofbytesexpectedtosend">zur√ºckerhalten</a> <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1410663-countofbytesexpectedtoreceive">m√∂chten</a> .  Dies ist erforderlich, damit das System die Arbeit mit der Aufgabe korrekter planen und schneller herunterladen kann, ohne dass es zu √úberarbeitungen kommt.  Diese Werte m√ºssen nicht genau sein. </p><br><p>  Nach <code>resume()</code> Aufgabe ausgef√ºhrt.  W√§hrend der Daten√ºbertragung wird der Fortschritt √ºbertragen (dazu - siehe unten, dort gibt es auch Optionen), und nach Abschluss werden mehrere Delegierungsmethoden ausgef√ºhrt.  Unter ihnen ist eines sehr wichtig: </p><br><pre> <code class="swift hljs">urlSession(<span class="hljs-number"><span class="hljs-number">_</span></span>:downloadTask:didFinishDownloadingTo:)</code> </pre> <br><p>  Tatsache ist, dass der Download in einer tempor√§ren Datei stattfindet, wonach die Anwendung die M√∂glichkeit hat, diese Datei an einen anderen Ort zu verschieben oder etwas anderes damit zu tun.  Diese tempor√§re Datei ist nur innerhalb dieser Methode verf√ºgbar. Nach dem Verlassen wird die Datei gel√∂scht und kann nicht mehr verwendet werden. </p><br><p>  Nach dieser wichtigen Methode wird eine andere Methode aufgerufen, bei der der Fehler abf√§llt, wenn er auftritt.  Wenn kein <code>error</code> , ist der <code>error</code> <code>nil.</code> </p><br><pre> <code class="swift hljs">urlSession(<span class="hljs-number"><span class="hljs-number">_</span></span>:task:didCompleteWithError:)</code> </pre> <br><p>  Und was passiert am Ende, wenn die Bewerbung in den Hintergrund tritt oder abgeschlossen ist?  Wie rufe ich Delegate-Methoden auf?  Hier ist es nicht einfach. </p><br><p>  Wenn der Download von etwas, das von der Anwendung gestartet wurde, beendet wurde und sich das Flag <code>sessionSendsLaunchEvents</code> in der Sitzungskonfiguration befindet, startet das System die Anwendung (im Hintergrund) und ruft die Methode <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622941-application%3Flanguage%3Dobjc">application (_: handleEventsForBackgroundURLSession: completionHandler :)</a> in <code>AppDelegate,</code> . </p><br><p>  Bei dieser Methode sollte die Anwendung: </p><br><ul><li>  save <code>completionHandler</code> (muss nach einiger Zeit asynchron und im Haupt-Thread aufgerufen werden); </li><li>  Erstellen Sie eine Hintergrundsitzung mit demselben Bezeichner wie zuvor neu (und der bei mehreren Hintergrundsitzungen an diese Methode √ºbergeben wird). </li><li>  In einer neu erstellten Sitzung treffen Ereignisse beim Delegaten ein (insbesondere die sehr wichtige <code>urlSession(_:downloadTask:didFinishDownloadingTo:)</code> ). Sie m√ºssen sie verarbeiten und die Dateien kopieren, wo Sie m√∂chten. </li><li>  Nachdem alle Methoden aufgerufen wurden, wird eine andere <code>urlSessionDidFinishEvents(forBackgroundURLSession:)</code> aufgerufen, die <code>urlSessionDidFinishEvents(forBackgroundURLSession:)</code> und in der Sie den <code>completionHandler.</code> aufrufen m√ºssen, der zuvor gespeichert wurde <code>completionHandler.</code> </li></ul><br><blockquote>  Es ist wichtig.  Es ist erforderlich, den <code>completionHandler</code> im Hauptthread mit <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue/1781006-main"><code>DispatchQueue.main.async(...)</code></a> aufzurufen. </blockquote><p>  Gleichzeitig m√ºssen Sie bedenken, dass dies alles in einer Anwendung geschieht, die im Hintergrund arbeitet.  Und das bedeutet, dass die Ressourcen (Ausf√ºhrungszeit) begrenzt sind.  Speichern Sie Dateien schnell an den gew√ºnschten Stellen, √§ndern Sie die erforderlichen Status in der Anwendung und fahren Sie sie herunter - das ist fast alles, was getan werden kann.  Wenn Sie mehr tun m√∂chten, k√∂nnen Sie <a href="https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtask"><code>UIApplication.beginBackgroundTask()</code></a> oder die neuen <a href="https://developer.apple.com/documentation/backgroundtasks">BackgroundTasks verwenden</a> . </p><br><h2 id="obschaya-shema-fonovoy-otpravki-dannyh">  Allgemeines Schema zum Senden von Hintergrunddaten </h2><br><p>  Das Hochladen von Dateien auf den Server funktioniert ebenfalls mit Einschr√§nkungen.  Alles beginnt jedoch auf √§hnliche Weise: Wir bilden eine Anfrage, erstellen eine Aufgabe (jetzt ist es <a href="https://developer.apple.com/documentation/foundation/urlsessionuploadtask"><code>URLSessionUploadTask)</code></a> und f√ºhren die Aufgabe aus.  Was ist das Problem? </p><br><p>  Das Problem ist, wie wir die Anfrage erstellen.  Normalerweise bilden wir die gesendeten Daten als <code>Data</code> .  Hintergrund <code>URLSession,</code> wei√ü nicht, wie man damit arbeitet.  Und bei einer Streaming-Anfrage ( <code>uploadTask(withStreamedRequest:)</code> ) wei√ü auch keiner wie.  Es ist notwendig, alles zu schreiben, was an eine Datei gesendet werden muss, und eine Sendeaufgabe aus der Datei zu erstellen.  Es stellt sich irgendwie so heraus: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileUrl = methodThatSavesFileAndRetursItsUrl(...) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = session.uploadTask(with: request, fromFile: fileUrl) task.resume()</code> </pre> <br><p>  Es ist jedoch nicht erforderlich, die Gr√∂√üe zu registrieren. <code>URLSession</code> kann sie selbst <code>URLSession</code> .  Nach dem Senden wird dieselbe Delegate-Methode <code>urlSession(_:task:didCompleteWithError:)</code> wie beim Herunterladen.  Und genau so kommt die Anwendung <code>application(_:handleEventsForBackgroundURLSession:completionHandler:),</code> an, wenn die Anwendung w√§hrend des <code>application(_:handleEventsForBackgroundURLSession:completionHandler:),</code> wurde oder in den Hintergrund trat. <code>application(_:handleEventsForBackgroundURLSession:completionHandler:),</code> muss genau nach den gleichen Regeln wie beim Herunterladen von Daten verarbeitet werden. </p><br><h2 id="chto-takoe-prilozhenie-zaversheno">  Was ist eine Bewerbung vollst√§ndig? </h2><br><p>  Um das Herunterladen und Senden im Hintergrund zu testen, m√ºssen Sie die Fertigstellung der Anwendung simulieren (die Hintergrundarbeit mit dem Netzwerk wurde speziell entwickelt, um dies zu √ºberstehen).  Wie kann man das machen?  Anfangs - auf keinen Fall.  Das hei√üt, es gibt keine regul√§re (autorisierte, √∂ffentliche) Methode, mit der dies m√∂glich w√§re.  Mal sehen, wo der Rechen ist. </p><br><ul><li>  Erstens funktioniert das Schlie√üen der Anwendung (durch Dr√ºcken der Home-Taste oder durch Ausf√ºhren einer entsprechenden Geste) nicht.  Dadurch wird die Anwendung nicht beendet, sondern nur in den Hintergrund gesendet.  Die Arbeit mit einer Hintergrundsitzung hat die Bedeutung, dass sie auch dann funktioniert, wenn die Anwendung "vollst√§ndig, vollst√§ndig" beendet wurde. </li><li>  Zweitens ist es nicht m√∂glich, dass ein Debugger (AppCode, Xcode oder nur LLDB) verbunden ist. Er l√§sst die Anwendung auch einige Zeit nach dem "Schlie√üen" nicht sterben. </li><li>  Drittens k√∂nnen Sie die Anwendung nicht √ºber die Taskleiste beenden (Task-Manager, Double Home oder langsames Wischen "nach oben").  Daher wird eine abgebrochene Anwendung als "dauerhaft" abgebrochen betrachtet, und das System stoppt zusammen mit einer solchen Aktion die mit der Anwendung verbundenen Hintergrundsitzungen. </li><li>  viertens m√ºssen Sie diesen Prozess auf einem realen Ger√§t testen.  Es gibt keine Probleme mit der Protokollierung (siehe unten) und es wird mehr debuggt.  Es wird argumentiert, dass der Simulator auch so funktionieren sollte, wie er sollte.  Aber ich bemerkte unerkl√§rliche Kuriosit√§ten, die ich nur mit den St√∂rungen des Simulators erkl√§ren konnte.  Testen Sie im Allgemeinen das Ger√§t. </li><li>  Die einzige sinnvolle M√∂glichkeit, das zu tun, was Sie wollen, ist die <code>exit(int)</code> -Funktion.  Wie jeder wei√ü, k√∂nnen Sie es nicht auf den Server hochladen ( <a href="https://developer.apple.com/library/archive/qa/qa1561">dies widerspricht direkt den Anforderungen</a> ), aber wir testen es gerade - es ist nicht be√§ngstigend.  Ich kenne zwei sinnvolle M√∂glichkeiten, um diese Funktion zu nutzen: <br><ul><li>  Rufen Sie es automatisch in der <code>AppDelegate.applicationDidEnterBackground(_:)</code> -Methode auf, damit die Anwendung sofort nach dem Beenden des Springboards beendet wird. </li><li>  Erstellen Sie eine Komponente in der Benutzeroberfl√§che (z. B. eine Schaltfl√§che oder h√§ngen Sie eine Aktion an eine Geste), indem Sie auf die Komponente klicken und <code>exit(...).</code> <br>  In diesem Fall wird die Anwendung beendet und die Hintergrundarbeit mit dem Netzwerk sollte fortgesetzt werden.  Und nach einiger Zeit sollten wir einen Aufruf an <code>application(_:handleEventsForBackgroundURLSession:completionHandler:).</code> </li></ul></li></ul><br><h2 id="kak-protokolirovat-rabotu-prilozheniya-esli-nelzya-polzovatsya-otladochnoy-konsolyu-xcode">  Wie wird die Anwendung protokolliert, wenn Sie die Xcode-Debug-Konsole nicht verwenden k√∂nnen? </h2><br><p>  Das ist unm√∂glich.  Sie k√∂nnen, wenn Sie wirklich wollen.  Sie k√∂nnen nicht von Xcode aus starten. Wenn die Anwendung beispielsweise aufgrund eines Systemereignisses bereits neu gestartet wurde, k√∂nnen Sie sie an die Anwendung anh√§ngen (an den Prozess anh√§ngen) und aus der Warteschlange entfernen.  Aber diese L√∂sung ist so lala, dass Sie den Neustartprozess selbst irgendwie testen m√ºssen. </p><br><p>  Sie k√∂nnen <a href="https://en.wikipedia.org/wiki/Log_file">Protokolle (Protokolle, Protokolle) verwenden</a> .  Es gibt mehrere Optionen f√ºr ihre Implementierung: </p><br><ul><li> <a href="https://developer.apple.com/documentation/swift/1541053-print"><code>print.</code></a>  Es wird oft verwendet, um "etwas schnell rauszubekommen".  In unserem Fall ist es unm√∂glich zu verwenden, da wir keinen Zugriff auf die Konsole auf dem Ger√§t haben, wird die Anwendung beendet. </li><li> <a href="https://developer.apple.com/documentation/foundation/1409759-nslog"><code>NSLog.</code></a>  Es wird funktionieren, da es die dritte Methode verwendet. </li><li> <a href="https://developer.apple.com/documentation/os/logging"><code>os_log.</code></a>  Die korrekteste Methode, mit der Sie die Protokolle ordnungsgem√§√ü konfigurieren, mit dem gew√ºnschten Typ versehen, nach dem Debuggen deaktivieren, ohne den Code selbst zu schneiden usw. </li></ul><br><blockquote>  Achtung!  Mit <code>os_log</code> gibt es Probleme (zum Beispiel das Fehlen von Debug-Protokollen), die nur im Simulator, aber nicht auf diesem Ger√§t abgespielt werden.  Verwenden Sie das Ger√§t. </blockquote><p>  <code>os_log,</code> zur Verwendung von <code>os_log,</code> Sie in der <a href="https://developer.apple.com/documentation/os/logging">Apple-Dokumentation</a> .  Insbesondere sollten Sie <code>debug</code> und <code>info</code> Protokolle aktivieren, da diese standardm√§√üig ausgeblendet sind. </p><br><h2 id="otslezhivanie-progressa-skachivaniya-ili-otpravki-dannyh">  Verfolgen des Fortschritts beim Herunterladen oder Senden von Daten </h2><br><p>  W√§hrend der Daten√ºbertragung m√∂chte ich verstehen, wie viel bereits gesendet wurde und wie viel noch √ºbrig ist.  Hierf√ºr gibt es zwei M√∂glichkeiten.  Der erste ist die Verwendung von Delegate-Methoden: </p><br><ul><li>  Zum Senden m√ºssen Sie <code>urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)</code> </li><li>  Es gibt eine √§hnliche <code>urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)</code> Methode zum Herunterladen <code>urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)</code> </li></ul><br><p>  Diese Methoden werden jedes Mal aufgerufen, wenn das n√§chste Datenelement heruntergeladen oder gesendet wird.  Sie stimmen nicht unbedingt mit den Methoden zum Abschluss des Vorgangs √ºberein, sondern k√∂nnen auch aufgerufen werden, nachdem die Daten vollst√§ndig heruntergeladen oder gesendet wurden. Daher kann nicht festgestellt werden, dass ‚Äûalles fertig ist‚Äú. </p><br><p>  Die zweite Methode ist interessanter.  Fakt ist, dass jede Task ein Objekt vom Typ <a href="https://developer.apple.com/documentation/foundation/progress"><code>Progress</code></a> (liegt im Feld <code>task.progress</code> ) bereitstellt, mit dem ein beliebiger Prozess einschlie√ülich des Daten√ºbertragungsprozesses √ºberwacht werden kann.  Wie ist er interessant?  Zwei Dinge: </p><br><ul><li>  Aus den <code>Progress</code> k√∂nnen Sie einen Aufgabenausf√ºhrungsbaum erstellen, dessen Knoten anzeigen, wie fortgeschritten alle darin enthaltenen Aufgaben sind.  Wenn Sie beispielsweise f√ºnf Dateien senden m√ºssen, k√∂nnen Sie den Fortschritt f√ºr jede Datei erfassen, allgemeine Fortschritte erzielen, f√ºnf weitere hinzuf√ºgen und den Fortschritt einer √ºbergeordneten Datei √ºberwachen und die Aktualisierungen mit einem Schnittstellenelement verkn√ºpfen. </li><li>  Sie k√∂nnen diesem Baum Ihren Fortschritt hinzuf√ºgen und die mit dem hinzugef√ºgten Fortschritt verbundenen Aktionen anhalten und abbrechen. </li></ul><br><p>  In welcher Beziehung steht dies zum Herunterladen oder Senden von Daten im Hintergrund?  Auf keinen Fall.  Delegatmethoden werden nicht aufgerufen und Fortschrittsobjekte sterben ab, wenn die Anwendung beendet wird.  F√ºr Hintergrundsitzungen ist diese Methode nicht geeignet. </p><br><h2 id="peredacha-zadach-iz-obychnoy-sessii-v-background-sessiyu">  √úbertragen Sie Aufgaben von einer regul√§ren Sitzung in eine Hintergrundsitzung </h2><br><p>  Nun, es ist schwieriger, mit einer Hintergrundsitzung zu arbeiten.  Das ist aber praktisch!  Es geht keine einzige Aufgabe verloren. Werden wir jemals alle angeforderten Daten erhalten, warum nicht immer die Hintergrundsitzung verwenden? </p><br><p>  Leider hat sie Fehler und schwerwiegende.  Beispielsweise ist eine Hintergrundsitzung langsamer.  In meinen Experimenten variierte die Geschwindigkeit mehrmals.  Zweitens kann die Ausf√ºhrung einer Aufgabe im Hintergrund verz√∂gert werden (insbesondere wenn der Parameter <code>isDiscretionary</code> ist, was, wie bereits erw√§hnt, immer f√ºr Aufgaben gilt, die erstellt werden, w√§hrend die Anwendung im Hintergrund ausgef√ºhrt wird. </p><br><p>  Daher m√ºssen Sie jedes Mal, wenn Sie eine Aufgabe erstellen, genau verstehen, nach welchen Kriterien sie ausgef√ºhrt wird, wo sie zu einer regul√§ren Sitzung oder einer Hintergrundsitzung hinzugef√ºgt werden soll.  Normal l√§uft schneller, startet sofort.  Hintergrund - l√§nger, nicht sofort, wird aber nicht beendet, wenn der Benutzer die Anwendung schlie√üt. </p><br><p>  Wenn es kein offensichtliches Verst√§ndnis daf√ºr gibt, dass die Aufgabe in der Hintergrundsitzung ausgef√ºhrt werden sollte (z. B. unkritische √úbertragung einer sehr gro√üen Datenmenge, z. B. Synchronisierung oder Sicherung), sollten Sie wie folgt vorgehen: </p><br><ul><li>  Starten Sie die Aufgabe in einer regul√§ren Sitzung.  F√ºhren Sie in diesem Fall <em>backgroundTask aus,</em> damit das System versteht, dass wir Zeit ben√∂tigen, um die Aufgabe abzuschlie√üen.  Dies gibt einige Zeit (bis zu mehreren Minuten, aber in iOS 13 ist etwas kaputt gegangen und es ist nicht klar, was damit passiert), damit die Aufgabe abgeschlossen werden kann. </li><li>  Wenn es keine Zeit hat, √ºbertragen <em>wir</em> die Aufgabe am Ende von <em>backgroundTask</em> von einer regul√§ren Sitzung in eine Hintergrundsitzung, in der sie weiterarbeitet und endet, wenn dies m√∂glich ist. </li></ul><br><p>  Wie √ºberweisen?  Auf keinen Fall.  Beenden Sie einfach die √ºbliche Aufgabe (brechen Sie sie ab) und erstellen Sie einen √§hnlichen Hintergrund (mit derselben Anforderung).  Warum nennt man das eine ‚Äû√úberweisung‚Äú?  Und warum in Anf√ºhrungszeichen? </p><br><p>  Es erfolgt keine √úbertragung zum Senden von Daten.  Es ist genau das, was beschrieben wird.  Sie haben eine Aufgabe erledigt, eine andere gestartet, alle Daten, die zum ersten Mal gesendet wurden, gingen verloren. </p><br><p>  Beim Herunterladen ist die Situation anders.  Das System wei√ü, in welche Datei die Anforderung heruntergeladen wird.  Wenn Sie beispielsweise mehrere Tasks ausf√ºhren, um dieselbe URL herunterzuladen, wird die Anforderung nicht mehrmals ausgef√ºhrt.  Die Daten werden einmal heruntergeladen. Anschlie√üend wird die endg√ºltige Delegatmethode (oder der R√ºckruf) mehrmals ausgef√ºhrt.  <a href="https://medium.com/%40sdrzn/handling-multiple-urlsession-tasks-efficiently-91c0957a7d77">Hier wird ein Experiment beschrieben</a> , das dies best√§tigt.  H√∂chstwahrscheinlich wird Standard-HTTP-Caching verwendet, genau wie in Browsern. </p><br><p>  Hier ist ein Beispielcode, der dies tut: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = foregroundSession.downloadTask(with: request) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> backgroundId = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.beginBackgroundTask { task.cancel() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = backgroundSession.downloadTask(with: request) task.resume() } task.resume()</code> </pre> <br><p>  Wenn die Aufgabe beendet ist, bevor <code>expirationHandler</code> funktioniert, m√ºssen Sie daran denken, <code>UIApplication.shared.endBackgroundTask(backgroundId)</code> .  Dies ist in der <a href="https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtask">Dokumentation</a> n√§her beschrieben. </p><br><p>  Damit das System den Download fortsetzt (z. B. kann durch Abbrechen die tempor√§re Datei gel√∂scht werden, bevor der Download im Hintergrund fortgesetzt wird), gibt es spezielle Methoden: </p><br><ul><li>  Um die f√ºr die Erneuerung erforderlichen Daten <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask/1411634-cancel">abzurufen</a> , m√ºssen Sie die vorherige Aufgabe mit der <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask/1411634-cancel">cancel-</a> Methode <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask/1411634-cancel">(byProducingResumeData :) abbrechen</a> . </li><li><font style="vertical-align: inherit;"></font><a href="https://developer.apple.com/documentation/foundation/urlsession/1409226-downloadtask"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Aufgabe zu erstellen, gehen Sie bei den bereits heruntergeladenen Daten wie </font><a href="https://developer.apple.com/documentation/foundation/urlsession/1409226-downloadtask"><font style="vertical-align: inherit;">folgt vor</font></a><font style="vertical-align: inherit;"> : </font><a href="https://developer.apple.com/documentation/foundation/urlsession/1409226-downloadtask"><font style="vertical-align: inherit;">downloadTask (withResumeData :) -&gt; URLSessionDownloadTask</font></a><font style="vertical-align: inherit;"> , also </font><a href="https://developer.apple.com/documentation/foundation/urlsession/1409226-downloadtask"><font style="vertical-align: inherit;">ungef√§hr</font></a><font style="vertical-align: inherit;"> so:</font></font></li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = foregroundSession.downloadTask(with: request) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> backgroundId = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.beginBackgroundTask { task.cancel { data <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDownloadTask</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data { task = backgroundSession.downloadTask(withResumeData: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { task = backgroundSession.downloadTask(with: request) } task.resume() } }</code> </pre> <br><h2 id="grabli-na-kotorye-ya-nastupil"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Den Rechen, auf den ich getreten bin </font></font></h2><br><h3 id="logi">  Protokolle </h3><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Schwierigste dabei ist, genau zu verstehen, was passiert. </font><font style="vertical-align: inherit;">Exzellente Protokollierung ist die erste Aufgabe, die sofort angegangen werden muss. </font><font style="vertical-align: inherit;">Das Verhalten von Hintergrundsitzungen kann nur mit normalen Protokollen getestet werden.</font></font></p><br><p> ,  ,  background     -,       ,      ,          (   UI,      ). , ,    ‚Äî .     ,   ‚Äî ,  ,  <code>os_log.</code> ( <code>NSLog)</code> </p><br><h3 id="priostanovka-biznes-logiki">  - </h3><br><p>        -  ,         .         ,     -  .    ,      ,   ,      ( )     . ,    ,      -,  ,  .     ‚Äî       ‚Äî ,    .   ‚Äî  ,       -  ( ),       ,      . </p><br><h3 id="testirovanie-na-ustroystve">    </h3><br><p>     .            (  ),    .  ,      ,    ,       . </p><br><h3 id="ogranicheniya">  Einschr√§nkungen </h3><br><p>    : </p><br><ul><li>   ,  ; </li><li>  ‚Äî  ,    ; </li><li>        ,     (,    ‚Ä¶); </li></ul><br><h3 id="melochi">  </h3><br><ul><li>        ,    <code>(task.taskIdentifier)</code>  ,     (Dictionary).    ,          1,   . </li><li>   , <code>URLSession.getAllTasks</code> .    ,        background .  ,    .   ,    . ¬Ø\_(„ÉÑ)_/¬Ø </li><li>   ,  ,         ,    ,     . </li></ul><br><p>       ,      background ,      .      ,      -    .      : <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html">https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1</a> .   , : </p><br><blockquote> If your app extension initiates a background NSURLSession task, you must also set up a shared container that both the extension and its containing app can access. Use the sharedContainerIdentifier property of the NSURLSessionConfiguration class to specify an identifier for the shared container so that you can access it later. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478566/">https://habr.com/ru/post/de478566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478550/index.html">Wie verwalte ich eine Uhr? Analyse der Front-End-Strecke der zweiten Programmiermeisterschaft</a></li>
<li><a href="../de478552/index.html">Zweites Applet, Schlie√üen und transparente Schaltfl√§chen in Verarbeitung 3</a></li>
<li><a href="../de478554/index.html">Webinar "SRE - Hype oder die Zukunft?" 12. Dezember um 11:00 Uhr</a></li>
<li><a href="../de478560/index.html">Sind kostenlose Instant Messenger anonym?</a></li>
<li><a href="../de478564/index.html">Wie wir bei TsIAN Terabytes an Protokollen gez√§hmt haben</a></li>
<li><a href="../de478572/index.html">Bot in neuronalen Netzen: Wie ein virtueller Assistent funktioniert und lernt</a></li>
<li><a href="../de478574/index.html">Die Wahrheit √ºber Eisenbahnbremsen: Teil 4 - Fahrgastbremsen</a></li>
<li><a href="../de478582/index.html">Globaler VPN-Bericht √ºber mobile Ger√§te im Jahr 2019</a></li>
<li><a href="../de478584/index.html">JVM-Interna, Teil 2 - Dateistruktur der Klasse</a></li>
<li><a href="../de478586/index.html">Ineffizienz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>