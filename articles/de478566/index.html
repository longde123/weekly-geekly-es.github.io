<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛑️ 🦅 👨‍👩‍👧 iOS Netzwerk, wenn die Anwendung nicht ausgeführt wird 🤸🏿 🚭 👨🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Benutzer erwarten, dass das Netzwerk „magisch“ und unbemerkt funktioniert. Diese Magie hängt von den Entwicklern des Systems und der Anwendungen ab. E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS Netzwerk, wenn die Anwendung nicht ausgeführt wird</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/478566/"><p><img src="https://habrastorage.org/webt/ok/hf/in/okhfincdajhwvcffenwaoaj6wcs.png" alt="Bild"></p><br><p>  Benutzer erwarten, dass das Netzwerk „magisch“ und unbemerkt funktioniert.  Diese Magie hängt von den Entwicklern des Systems und der Anwendungen ab.  Es ist schwierig, das System zu beeinflussen, daher beschränken wir uns auf die Anwendung. </p><br><p>  Dieses Thema ist komplex und es gibt unzählige Probleme.  Wir werden diejenigen diskutieren, denen wir in den letzten Monaten begegnet sind.  Ich entschuldige mich sofort für die Lautstärke.  Kurz gesagt, keineswegs zu viele kleine Dinge, die es wert sind, beachtet zu werden. </p><a name="habracut"></a><br><p>  Zunächst beschäftigen wir uns mit der Terminologie. </p><br><p>  Die Datenübertragung erfolgt in zwei Richtungen: </p><br><ul><li>  <em>Herunterladen</em> (Herunterladen, Herunterladen von Daten vom Server), </li><li>  <em>Upload</em> (Senden von Daten an den Server). </li></ul><br><p>  Die Anwendung ist möglicherweise aktiv, arbeitet jedoch möglicherweise im Hintergrund.  Formal hat er <a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle">andere Zustände</a> , aber wir interessieren uns nur für diese: </p><br><ul><li>  <em>Hintergrund</em> (wenn die Anwendung minimiert ist), </li><li>  <em>aktiv</em> (wenn die Anwendung aktiv ist, auf dem Bildschirm). </li></ul><br><p> Nützliche Muster: <em>Rückruf</em> , <em>Delegat</em> ( <a href="https://developer.apple.com/documentation/swift/cocoa_design_patterns">Cocoa Design Patterns</a> , <a href="https://en.wikipedia.org/wiki/Callback_(computer_programming)">über Rückruf auf Wikipedia</a> ).  Sie müssen auch wissen, <a href="https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started"><code>  URLSession</code></a> (in dem Artikel erwähnt der Link auch die Hintergrundarbeit mit dem Netzwerk, aber im Vorbeigehen). </p><br><p>  Alle Beispiele sind in <a href="https://docs.swift.org/swift-book/">Swift 5 geschrieben</a> , funktionieren unter iOS 11 und neuer (getestet unter iOS 11 und 12) und setzen die Verwendung regulärer HTTP-Anforderungen voraus.  Zum größten Teil wird dies alles ab iOS 9 funktionieren, aber es gibt "Nuancen". </p><br><h2 id="obschaya-shema-raboty-s-setyu-urlsession">  Das allgemeine Schema der Arbeit mit dem Netzwerk.  URLSession </h2><br><p>  Die Arbeit mit dem Netzwerk ist nicht besonders schwierig: </p><br><ul><li>  Erstellen Sie die <a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration"><code>URLSessionConfiguration</code></a> Konfiguration. </li><li>  Erstellen Sie eine Konfigurationsinstanz von <a href="https://developer.apple.com/documentation/foundation/urlsession"><code>URLSession</code></a> . </li><li>  Erstellen Sie eine Aufgabe (mit <a href="https://developer.apple.com/documentation/foundation/urlsession/1411554-datatask"><code>session.dataTask(…)</code></a> und ähnlichen Methoden). </li><li>  Task-Updates abonnieren.  Aktualisierungen erfolgen asynchron, sie können an den <em>Delegaten gesendet werden,</em> der beim Erstellen der Sitzung registriert wird, oder sie befinden sich im <em>Rückruf,</em> der beim <em>Erstellen</em> der Aufgabe erstellt wird. </li><li>  Als wir sahen, dass die Aufgabe abgeschlossen ist, kehren wir zur Anwendungslogik zurück. </li></ul><br><p>  Ein einfaches Beispiel sieht so aus: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataTask = session.dataTask(with: url) { data, response, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//     //  callback,    }</span></span></code> </pre> <br><p>  Dieses Schema ist für verschiedene Aufgaben ähnlich, nur die kleinen Dinge ändern sich.  Und bis wir nicht weiter mit dem Netzwerk arbeiten müssen, nachdem der Benutzer die Anwendung geschlossen hat, ist alles relativ einfach. </p><br><blockquote>  Ich stelle sofort fest, dass es auch in diesem Szenario viele interessante Dinge gibt.  Manchmal müssen Sie mit kniffligen Weiterleitungen arbeiten, manchmal benötigen Sie eine Autorisierung, SSL-Fixierung oder alles gleichzeitig.  Sie können viel darüber lesen.  Aus irgendeinem Grund wird das Arbeiten mit dem Netzwerk im Hintergrund viel weniger beschrieben. </blockquote><br><h2 id="sozdanie-sessii-dlya-raboty-v-background">  Erstellen einer Sitzung für die Arbeit im Hintergrund </h2><br><p>  Was ist der Unterschied zwischen der <em>URLSession im</em> Hintergrund und der üblichen?  Es funktioniert außerhalb des Anwendungsprozesses, irgendwo innerhalb des Systems.  Daher "stirbt" es nicht, wenn der Bewerbungsprozess abgeschlossen ist.  Es wird als Hintergrundsitzung bezeichnet (ebenso wie der etwas verwirrende Status der Anwendung) und erfordert bestimmte Einstellungen.  Zum Beispiel das: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> configuration = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.background(withIdentifier: <span class="hljs-string"><span class="hljs-string">"com.my.app"</span></span>) configuration.sessionSendsLaunchEvents = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.isDiscretionary = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.allowsCellularAccess = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.shouldUseExtendedBackgroundIdleMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.waitsForConnectivity = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: configuration, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><p>  Die Konfiguration enthält viele andere Parameter, die sich jedoch direkt auf Hintergrundsitzungen beziehen: </p><br><ul><li>  <em>bezeichner</em> (im Initialisierer übergeben) ist eine Zeichenfolge, die verwendet wird, um Hintergrundsitzungen abzugleichen, wenn die Anwendung neu gestartet wird.  Wenn die Anwendung neu gestartet wird und Sie eine Hintergrundsitzung mit einer ID erstellen, die bereits in einer anderen Hintergrundsitzung verwendet wird, kann die neue auf die Aufgaben der vorherigen zugreifen.  Die Schlussfolgerung daraus ist einfach.  Für einen ordnungsgemäßen Betrieb muss diese Kennung für Ihre Anwendung eindeutig und dauerhaft sein (Sie können beispielsweise eine Ableitung von <em>BundleId-</em> Anwendungen verwenden). </li><li>  <em>sessionSendsLaunchEvents</em> gibt an, ob die Hintergrundsitzung die Anwendung starten soll, wenn die Datenübertragung abgeschlossen ist.  Wenn dieser Parameter auf <code>false,</code> der Trigger nicht auf und die Anwendung empfängt beim nächsten Start alle Ereignisse.  Wenn der Parameter <code>true</code> ist, startet das System nach Abschluss der Datenübertragung die Anwendung und ruft die entsprechende <code>AppDelegate: application(_:handleEventsForBackgroundURLSession:completionHandler:)</code> Methode auf <code>AppDelegate: application(_:handleEventsForBackgroundURLSession:completionHandler:)</code> ; </li><li>  <em>Mit isDiscretionary</em> kann das System Aufgaben seltener planen.  Dies verbessert einerseits die Batterielebensdauer und kann andererseits die Aufgabe verlangsamen.  Oder vielleicht beschleunigen.  Wenn beispielsweise ein großes Volumen heruntergeladen wird, kann das System die Aufgabe anhalten, bis eine Verbindung zum WLAN hergestellt ist, und dann schnell alles herunterladen, ohne langsames mobiles Internet ausgeben zu müssen (wenn dies überhaupt zulässig ist, wie geht es weiter).  Wenn die Aufgabe erstellt wird, während sich die Anwendung bereits im Hintergrund befindet, wird dieser Parameter automatisch auf <code>true</code> . </li><li>  <em>allowCellularAccess</em> - Ein Parameter, der <em>angibt</em> , dass Sie die Mobilfunkkommunikation für die Arbeit mit dem Netzwerk verwenden können.  Ich habe nicht sorgfältig mit ihm gespielt, aber laut Rezensionen sind dort (zusammen mit einem ähnlichen Systemschalter) eine große Anzahl von Rechen ausgelegt; </li><li>  <em>shouldUseExtendedBackgroundIdleMode.</em>  Ein nützlicher Parameter, der anzeigt, dass das System länger eine Verbindung zum Server aufrechterhalten sollte, wenn die Anwendung in den Hintergrund tritt.  Andernfalls wird die Verbindung unterbrochen. </li><li>  <em>waitsForConnectivity</em> Auf einem mobilen Gerät kann die Kommunikation für kurze Zeit unterbrochen werden.  Die zu diesem Zeitpunkt erstellten Aufgaben können entweder angehalten werden, bis eine Verbindung angezeigt wird, oder es wird sofort ein Fehler "Keine Verbindung" zurückgegeben.  Mit dem Parameter können Sie dieses Verhalten steuern.  Wenn es <code>false,</code> bricht die Task ohne Kommunikation sofort mit einem Fehler ab.  Wenn dies <code>true</code> , warten Sie, bis ein Link angezeigt wird. </li><li>  Die letzte Zeile (Session Initializer) enthält einen wichtigen Parameter, <em>delegate.</em>  Über ihn - ein bisschen mehr. </li></ul><br><h3 id="delegate-vs-callbacks">  Delegiert gegen Rückrufe </h3><br><p>  Wie oben erwähnt, gibt es zwei Möglichkeiten, Ereignisse aus einer Aufgabe / aus einer Sitzung abzurufen.  Der erste ist <em>Rückruf:</em> </p><br><pre> <code class="swift hljs">session.dataTask(with: request) { data, response, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ...   }</code> </pre> <br><p>  In diesem Fall wird das Ereignis zur Beendigung der Aufgabe an den Abschluss gesendet, wo Sie überprüfen müssen, ob ein Fehler vorliegt, was in der Antwort enthalten ist und welche Daten eingetroffen sind. </p><br><p>  Die zweite Möglichkeit, mit einer Sitzung zu arbeiten, besteht darin, sie zu <em>delegieren.</em>  In diesem Fall müssen wir eine Klasse erstellen, die die <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate"><code>URLSessionDataDelegate</code></a> Protokolle und (oder) andere Protokolle in der <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate"><code>URLSessionDataDelegate</code></a> implementiert (für verschiedene Aufgabentypen unterscheiden sich die Protokolle geringfügig).  Ein Verweis auf eine Instanz dieser Klasse befindet sich in einer Sitzung und ihre Methoden werden aufgerufen, wenn Ereignisse an den Delegaten übergeben werden.  Der Link kann vom Initialisierer in der Sitzung registriert werden.  Im Beispiel wird <code>self.</code> </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: configuration, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><p>  Für reguläre Sitzungen stehen beide Methoden zur Verfügung.  Hintergrundsitzungen können nur von einem Delegierten verwendet werden. </p><br><p>  Also haben wir die Sitzung eingerichtet, erstellt und schauen uns an, wie man etwas herunterlädt. </p><br><h2 id="obschaya-shema-skachivaniya-dannyh-v-fone">  Allgemeines Schema zum Herunterladen von Daten im Hintergrund </h2><br><p>  Um Daten herunterzuladen, müssen Sie normalerweise eine <a href="https://developer.apple.com/documentation/foundation/urlrequest"><code> (URLRequest)</code></a> , die erforderlichen Parameter / Header / Daten darin registrieren, eine <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask"><code>URLSessionDownloadTask</code></a> erstellen und zur Ausführung ausführen.  Ungefähr so: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//  request,   let task = session.downloadTask(with: request) if #available(iOS 11, *) { task.countOfBytesClientExpectsToSend = [approximate size of request] task.countOfBytesClientExpectsToReceive = [approximate size of response] } task.resume()</span></span></code> </pre> <br><p>  Derzeit unterscheidet sich nichts wesentlich von der üblichen Download-Aufgabe.  Zwar erschienen zwei Parameter <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1411534-countofbytesexpectedtosend">countOfBytesClientExpectsToSend</a> / <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1410663-countofbytesexpectedtoreceive">countOfBytesClientExpectsToReceive</a> , sie zeigen die Datenmenge an, die wir in der Anfrage senden und in der Antwort <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1411534-countofbytesexpectedtosend">zurückerhalten</a> <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1410663-countofbytesexpectedtoreceive">möchten</a> .  Dies ist erforderlich, damit das System die Arbeit mit der Aufgabe korrekter planen und schneller herunterladen kann, ohne dass es zu Überarbeitungen kommt.  Diese Werte müssen nicht genau sein. </p><br><p>  Nach <code>resume()</code> Aufgabe ausgeführt.  Während der Datenübertragung wird der Fortschritt übertragen (dazu - siehe unten, dort gibt es auch Optionen), und nach Abschluss werden mehrere Delegierungsmethoden ausgeführt.  Unter ihnen ist eines sehr wichtig: </p><br><pre> <code class="swift hljs">urlSession(<span class="hljs-number"><span class="hljs-number">_</span></span>:downloadTask:didFinishDownloadingTo:)</code> </pre> <br><p>  Tatsache ist, dass der Download in einer temporären Datei stattfindet, wonach die Anwendung die Möglichkeit hat, diese Datei an einen anderen Ort zu verschieben oder etwas anderes damit zu tun.  Diese temporäre Datei ist nur innerhalb dieser Methode verfügbar. Nach dem Verlassen wird die Datei gelöscht und kann nicht mehr verwendet werden. </p><br><p>  Nach dieser wichtigen Methode wird eine andere Methode aufgerufen, bei der der Fehler abfällt, wenn er auftritt.  Wenn kein <code>error</code> , ist der <code>error</code> <code>nil.</code> </p><br><pre> <code class="swift hljs">urlSession(<span class="hljs-number"><span class="hljs-number">_</span></span>:task:didCompleteWithError:)</code> </pre> <br><p>  Und was passiert am Ende, wenn die Bewerbung in den Hintergrund tritt oder abgeschlossen ist?  Wie rufe ich Delegate-Methoden auf?  Hier ist es nicht einfach. </p><br><p>  Wenn der Download von etwas, das von der Anwendung gestartet wurde, beendet wurde und sich das Flag <code>sessionSendsLaunchEvents</code> in der Sitzungskonfiguration befindet, startet das System die Anwendung (im Hintergrund) und ruft die Methode <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622941-application%3Flanguage%3Dobjc">application (_: handleEventsForBackgroundURLSession: completionHandler :)</a> in <code>AppDelegate,</code> . </p><br><p>  Bei dieser Methode sollte die Anwendung: </p><br><ul><li>  save <code>completionHandler</code> (muss nach einiger Zeit asynchron und im Haupt-Thread aufgerufen werden); </li><li>  Erstellen Sie eine Hintergrundsitzung mit demselben Bezeichner wie zuvor neu (und der bei mehreren Hintergrundsitzungen an diese Methode übergeben wird). </li><li>  In einer neu erstellten Sitzung treffen Ereignisse beim Delegaten ein (insbesondere die sehr wichtige <code>urlSession(_:downloadTask:didFinishDownloadingTo:)</code> ). Sie müssen sie verarbeiten und die Dateien kopieren, wo Sie möchten. </li><li>  Nachdem alle Methoden aufgerufen wurden, wird eine andere <code>urlSessionDidFinishEvents(forBackgroundURLSession:)</code> aufgerufen, die <code>urlSessionDidFinishEvents(forBackgroundURLSession:)</code> und in der Sie den <code>completionHandler.</code> aufrufen müssen, der zuvor gespeichert wurde <code>completionHandler.</code> </li></ul><br><blockquote>  Es ist wichtig.  Es ist erforderlich, den <code>completionHandler</code> im Hauptthread mit <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue/1781006-main"><code>DispatchQueue.main.async(...)</code></a> aufzurufen. </blockquote><p>  Gleichzeitig müssen Sie bedenken, dass dies alles in einer Anwendung geschieht, die im Hintergrund arbeitet.  Und das bedeutet, dass die Ressourcen (Ausführungszeit) begrenzt sind.  Speichern Sie Dateien schnell an den gewünschten Stellen, ändern Sie die erforderlichen Status in der Anwendung und fahren Sie sie herunter - das ist fast alles, was getan werden kann.  Wenn Sie mehr tun möchten, können Sie <a href="https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtask"><code>UIApplication.beginBackgroundTask()</code></a> oder die neuen <a href="https://developer.apple.com/documentation/backgroundtasks">BackgroundTasks verwenden</a> . </p><br><h2 id="obschaya-shema-fonovoy-otpravki-dannyh">  Allgemeines Schema zum Senden von Hintergrunddaten </h2><br><p>  Das Hochladen von Dateien auf den Server funktioniert ebenfalls mit Einschränkungen.  Alles beginnt jedoch auf ähnliche Weise: Wir bilden eine Anfrage, erstellen eine Aufgabe (jetzt ist es <a href="https://developer.apple.com/documentation/foundation/urlsessionuploadtask"><code>URLSessionUploadTask)</code></a> und führen die Aufgabe aus.  Was ist das Problem? </p><br><p>  Das Problem ist, wie wir die Anfrage erstellen.  Normalerweise bilden wir die gesendeten Daten als <code>Data</code> .  Hintergrund <code>URLSession,</code> weiß nicht, wie man damit arbeitet.  Und bei einer Streaming-Anfrage ( <code>uploadTask(withStreamedRequest:)</code> ) weiß auch keiner wie.  Es ist notwendig, alles zu schreiben, was an eine Datei gesendet werden muss, und eine Sendeaufgabe aus der Datei zu erstellen.  Es stellt sich irgendwie so heraus: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileUrl = methodThatSavesFileAndRetursItsUrl(...) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = session.uploadTask(with: request, fromFile: fileUrl) task.resume()</code> </pre> <br><p>  Es ist jedoch nicht erforderlich, die Größe zu registrieren. <code>URLSession</code> kann sie selbst <code>URLSession</code> .  Nach dem Senden wird dieselbe Delegate-Methode <code>urlSession(_:task:didCompleteWithError:)</code> wie beim Herunterladen.  Und genau so kommt die Anwendung <code>application(_:handleEventsForBackgroundURLSession:completionHandler:),</code> an, wenn die Anwendung während des <code>application(_:handleEventsForBackgroundURLSession:completionHandler:),</code> wurde oder in den Hintergrund trat. <code>application(_:handleEventsForBackgroundURLSession:completionHandler:),</code> muss genau nach den gleichen Regeln wie beim Herunterladen von Daten verarbeitet werden. </p><br><h2 id="chto-takoe-prilozhenie-zaversheno">  Was ist eine Bewerbung vollständig? </h2><br><p>  Um das Herunterladen und Senden im Hintergrund zu testen, müssen Sie die Fertigstellung der Anwendung simulieren (die Hintergrundarbeit mit dem Netzwerk wurde speziell entwickelt, um dies zu überstehen).  Wie kann man das machen?  Anfangs - auf keinen Fall.  Das heißt, es gibt keine reguläre (autorisierte, öffentliche) Methode, mit der dies möglich wäre.  Mal sehen, wo der Rechen ist. </p><br><ul><li>  Erstens funktioniert das Schließen der Anwendung (durch Drücken der Home-Taste oder durch Ausführen einer entsprechenden Geste) nicht.  Dadurch wird die Anwendung nicht beendet, sondern nur in den Hintergrund gesendet.  Die Arbeit mit einer Hintergrundsitzung hat die Bedeutung, dass sie auch dann funktioniert, wenn die Anwendung "vollständig, vollständig" beendet wurde. </li><li>  Zweitens ist es nicht möglich, dass ein Debugger (AppCode, Xcode oder nur LLDB) verbunden ist. Er lässt die Anwendung auch einige Zeit nach dem "Schließen" nicht sterben. </li><li>  Drittens können Sie die Anwendung nicht über die Taskleiste beenden (Task-Manager, Double Home oder langsames Wischen "nach oben").  Daher wird eine abgebrochene Anwendung als "dauerhaft" abgebrochen betrachtet, und das System stoppt zusammen mit einer solchen Aktion die mit der Anwendung verbundenen Hintergrundsitzungen. </li><li>  viertens müssen Sie diesen Prozess auf einem realen Gerät testen.  Es gibt keine Probleme mit der Protokollierung (siehe unten) und es wird mehr debuggt.  Es wird argumentiert, dass der Simulator auch so funktionieren sollte, wie er sollte.  Aber ich bemerkte unerklärliche Kuriositäten, die ich nur mit den Störungen des Simulators erklären konnte.  Testen Sie im Allgemeinen das Gerät. </li><li>  Die einzige sinnvolle Möglichkeit, das zu tun, was Sie wollen, ist die <code>exit(int)</code> -Funktion.  Wie jeder weiß, können Sie es nicht auf den Server hochladen ( <a href="https://developer.apple.com/library/archive/qa/qa1561">dies widerspricht direkt den Anforderungen</a> ), aber wir testen es gerade - es ist nicht beängstigend.  Ich kenne zwei sinnvolle Möglichkeiten, um diese Funktion zu nutzen: <br><ul><li>  Rufen Sie es automatisch in der <code>AppDelegate.applicationDidEnterBackground(_:)</code> -Methode auf, damit die Anwendung sofort nach dem Beenden des Springboards beendet wird. </li><li>  Erstellen Sie eine Komponente in der Benutzeroberfläche (z. B. eine Schaltfläche oder hängen Sie eine Aktion an eine Geste), indem Sie auf die Komponente klicken und <code>exit(...).</code> <br>  In diesem Fall wird die Anwendung beendet und die Hintergrundarbeit mit dem Netzwerk sollte fortgesetzt werden.  Und nach einiger Zeit sollten wir einen Aufruf an <code>application(_:handleEventsForBackgroundURLSession:completionHandler:).</code> </li></ul></li></ul><br><h2 id="kak-protokolirovat-rabotu-prilozheniya-esli-nelzya-polzovatsya-otladochnoy-konsolyu-xcode">  Wie wird die Anwendung protokolliert, wenn Sie die Xcode-Debug-Konsole nicht verwenden können? </h2><br><p>  Das ist unmöglich.  Sie können, wenn Sie wirklich wollen.  Sie können nicht von Xcode aus starten. Wenn die Anwendung beispielsweise aufgrund eines Systemereignisses bereits neu gestartet wurde, können Sie sie an die Anwendung anhängen (an den Prozess anhängen) und aus der Warteschlange entfernen.  Aber diese Lösung ist so lala, dass Sie den Neustartprozess selbst irgendwie testen müssen. </p><br><p>  Sie können <a href="https://en.wikipedia.org/wiki/Log_file">Protokolle (Protokolle, Protokolle) verwenden</a> .  Es gibt mehrere Optionen für ihre Implementierung: </p><br><ul><li> <a href="https://developer.apple.com/documentation/swift/1541053-print"><code>print.</code></a>  Es wird oft verwendet, um "etwas schnell rauszubekommen".  In unserem Fall ist es unmöglich zu verwenden, da wir keinen Zugriff auf die Konsole auf dem Gerät haben, wird die Anwendung beendet. </li><li> <a href="https://developer.apple.com/documentation/foundation/1409759-nslog"><code>NSLog.</code></a>  Es wird funktionieren, da es die dritte Methode verwendet. </li><li> <a href="https://developer.apple.com/documentation/os/logging"><code>os_log.</code></a>  Die korrekteste Methode, mit der Sie die Protokolle ordnungsgemäß konfigurieren, mit dem gewünschten Typ versehen, nach dem Debuggen deaktivieren, ohne den Code selbst zu schneiden usw. </li></ul><br><blockquote>  Achtung!  Mit <code>os_log</code> gibt es Probleme (zum Beispiel das Fehlen von Debug-Protokollen), die nur im Simulator, aber nicht auf diesem Gerät abgespielt werden.  Verwenden Sie das Gerät. </blockquote><p>  <code>os_log,</code> zur Verwendung von <code>os_log,</code> Sie in der <a href="https://developer.apple.com/documentation/os/logging">Apple-Dokumentation</a> .  Insbesondere sollten Sie <code>debug</code> und <code>info</code> Protokolle aktivieren, da diese standardmäßig ausgeblendet sind. </p><br><h2 id="otslezhivanie-progressa-skachivaniya-ili-otpravki-dannyh">  Verfolgen des Fortschritts beim Herunterladen oder Senden von Daten </h2><br><p>  Während der Datenübertragung möchte ich verstehen, wie viel bereits gesendet wurde und wie viel noch übrig ist.  Hierfür gibt es zwei Möglichkeiten.  Der erste ist die Verwendung von Delegate-Methoden: </p><br><ul><li>  Zum Senden müssen Sie <code>urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)</code> </li><li>  Es gibt eine ähnliche <code>urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)</code> Methode zum Herunterladen <code>urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)</code> </li></ul><br><p>  Diese Methoden werden jedes Mal aufgerufen, wenn das nächste Datenelement heruntergeladen oder gesendet wird.  Sie stimmen nicht unbedingt mit den Methoden zum Abschluss des Vorgangs überein, sondern können auch aufgerufen werden, nachdem die Daten vollständig heruntergeladen oder gesendet wurden. Daher kann nicht festgestellt werden, dass „alles fertig ist“. </p><br><p>  Die zweite Methode ist interessanter.  Fakt ist, dass jede Task ein Objekt vom Typ <a href="https://developer.apple.com/documentation/foundation/progress"><code>Progress</code></a> (liegt im Feld <code>task.progress</code> ) bereitstellt, mit dem ein beliebiger Prozess einschließlich des Datenübertragungsprozesses überwacht werden kann.  Wie ist er interessant?  Zwei Dinge: </p><br><ul><li>  Aus den <code>Progress</code> können Sie einen Aufgabenausführungsbaum erstellen, dessen Knoten anzeigen, wie fortgeschritten alle darin enthaltenen Aufgaben sind.  Wenn Sie beispielsweise fünf Dateien senden müssen, können Sie den Fortschritt für jede Datei erfassen, allgemeine Fortschritte erzielen, fünf weitere hinzufügen und den Fortschritt einer übergeordneten Datei überwachen und die Aktualisierungen mit einem Schnittstellenelement verknüpfen. </li><li>  Sie können diesem Baum Ihren Fortschritt hinzufügen und die mit dem hinzugefügten Fortschritt verbundenen Aktionen anhalten und abbrechen. </li></ul><br><p>  In welcher Beziehung steht dies zum Herunterladen oder Senden von Daten im Hintergrund?  Auf keinen Fall.  Delegatmethoden werden nicht aufgerufen und Fortschrittsobjekte sterben ab, wenn die Anwendung beendet wird.  Für Hintergrundsitzungen ist diese Methode nicht geeignet. </p><br><h2 id="peredacha-zadach-iz-obychnoy-sessii-v-background-sessiyu">  Übertragen Sie Aufgaben von einer regulären Sitzung in eine Hintergrundsitzung </h2><br><p>  Nun, es ist schwieriger, mit einer Hintergrundsitzung zu arbeiten.  Das ist aber praktisch!  Es geht keine einzige Aufgabe verloren. Werden wir jemals alle angeforderten Daten erhalten, warum nicht immer die Hintergrundsitzung verwenden? </p><br><p>  Leider hat sie Fehler und schwerwiegende.  Beispielsweise ist eine Hintergrundsitzung langsamer.  In meinen Experimenten variierte die Geschwindigkeit mehrmals.  Zweitens kann die Ausführung einer Aufgabe im Hintergrund verzögert werden (insbesondere wenn der Parameter <code>isDiscretionary</code> ist, was, wie bereits erwähnt, immer für Aufgaben gilt, die erstellt werden, während die Anwendung im Hintergrund ausgeführt wird. </p><br><p>  Daher müssen Sie jedes Mal, wenn Sie eine Aufgabe erstellen, genau verstehen, nach welchen Kriterien sie ausgeführt wird, wo sie zu einer regulären Sitzung oder einer Hintergrundsitzung hinzugefügt werden soll.  Normal läuft schneller, startet sofort.  Hintergrund - länger, nicht sofort, wird aber nicht beendet, wenn der Benutzer die Anwendung schließt. </p><br><p>  Wenn es kein offensichtliches Verständnis dafür gibt, dass die Aufgabe in der Hintergrundsitzung ausgeführt werden sollte (z. B. unkritische Übertragung einer sehr großen Datenmenge, z. B. Synchronisierung oder Sicherung), sollten Sie wie folgt vorgehen: </p><br><ul><li>  Starten Sie die Aufgabe in einer regulären Sitzung.  Führen Sie in diesem Fall <em>backgroundTask aus,</em> damit das System versteht, dass wir Zeit benötigen, um die Aufgabe abzuschließen.  Dies gibt einige Zeit (bis zu mehreren Minuten, aber in iOS 13 ist etwas kaputt gegangen und es ist nicht klar, was damit passiert), damit die Aufgabe abgeschlossen werden kann. </li><li>  Wenn es keine Zeit hat, übertragen <em>wir</em> die Aufgabe am Ende von <em>backgroundTask</em> von einer regulären Sitzung in eine Hintergrundsitzung, in der sie weiterarbeitet und endet, wenn dies möglich ist. </li></ul><br><p>  Wie überweisen?  Auf keinen Fall.  Beenden Sie einfach die übliche Aufgabe (brechen Sie sie ab) und erstellen Sie einen ähnlichen Hintergrund (mit derselben Anforderung).  Warum nennt man das eine „Überweisung“?  Und warum in Anführungszeichen? </p><br><p>  Es erfolgt keine Übertragung zum Senden von Daten.  Es ist genau das, was beschrieben wird.  Sie haben eine Aufgabe erledigt, eine andere gestartet, alle Daten, die zum ersten Mal gesendet wurden, gingen verloren. </p><br><p>  Beim Herunterladen ist die Situation anders.  Das System weiß, in welche Datei die Anforderung heruntergeladen wird.  Wenn Sie beispielsweise mehrere Tasks ausführen, um dieselbe URL herunterzuladen, wird die Anforderung nicht mehrmals ausgeführt.  Die Daten werden einmal heruntergeladen. Anschließend wird die endgültige Delegatmethode (oder der Rückruf) mehrmals ausgeführt.  <a href="https://medium.com/%40sdrzn/handling-multiple-urlsession-tasks-efficiently-91c0957a7d77">Hier wird ein Experiment beschrieben</a> , das dies bestätigt.  Höchstwahrscheinlich wird Standard-HTTP-Caching verwendet, genau wie in Browsern. </p><br><p>  Hier ist ein Beispielcode, der dies tut: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = foregroundSession.downloadTask(with: request) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> backgroundId = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.beginBackgroundTask { task.cancel() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = backgroundSession.downloadTask(with: request) task.resume() } task.resume()</code> </pre> <br><p>  Wenn die Aufgabe beendet ist, bevor <code>expirationHandler</code> funktioniert, müssen Sie daran denken, <code>UIApplication.shared.endBackgroundTask(backgroundId)</code> .  Dies ist in der <a href="https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtask">Dokumentation</a> näher beschrieben. </p><br><p>  Damit das System den Download fortsetzt (z. B. kann durch Abbrechen die temporäre Datei gelöscht werden, bevor der Download im Hintergrund fortgesetzt wird), gibt es spezielle Methoden: </p><br><ul><li>  Um die für die Erneuerung erforderlichen Daten <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask/1411634-cancel">abzurufen</a> , müssen Sie die vorherige Aufgabe mit der <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask/1411634-cancel">cancel-</a> Methode <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask/1411634-cancel">(byProducingResumeData :) abbrechen</a> . </li><li><font style="vertical-align: inherit;"></font><a href="https://developer.apple.com/documentation/foundation/urlsession/1409226-downloadtask"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Aufgabe zu erstellen, gehen Sie bei den bereits heruntergeladenen Daten wie </font><a href="https://developer.apple.com/documentation/foundation/urlsession/1409226-downloadtask"><font style="vertical-align: inherit;">folgt vor</font></a><font style="vertical-align: inherit;"> : </font><a href="https://developer.apple.com/documentation/foundation/urlsession/1409226-downloadtask"><font style="vertical-align: inherit;">downloadTask (withResumeData :) -&gt; URLSessionDownloadTask</font></a><font style="vertical-align: inherit;"> , also </font><a href="https://developer.apple.com/documentation/foundation/urlsession/1409226-downloadtask"><font style="vertical-align: inherit;">ungefähr</font></a><font style="vertical-align: inherit;"> so:</font></font></li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = foregroundSession.downloadTask(with: request) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> backgroundId = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.beginBackgroundTask { task.cancel { data <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDownloadTask</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data { task = backgroundSession.downloadTask(withResumeData: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { task = backgroundSession.downloadTask(with: request) } task.resume() } }</code> </pre> <br><h2 id="grabli-na-kotorye-ya-nastupil"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Den Rechen, auf den ich getreten bin </font></font></h2><br><h3 id="logi">  Protokolle </h3><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Schwierigste dabei ist, genau zu verstehen, was passiert. </font><font style="vertical-align: inherit;">Exzellente Protokollierung ist die erste Aufgabe, die sofort angegangen werden muss. </font><font style="vertical-align: inherit;">Das Verhalten von Hintergrundsitzungen kann nur mit normalen Protokollen getestet werden.</font></font></p><br><p> ,  ,  background     -,       ,      ,          (   UI,      ). , ,    — .     ,   — ,  ,  <code>os_log.</code> ( <code>NSLog)</code> </p><br><h3 id="priostanovka-biznes-logiki">  - </h3><br><p>        -  ,         .         ,     -  .    ,      ,   ,      ( )     . ,    ,      -,  ,  .     —       — ,    .   —  ,       -  ( ),       ,      . </p><br><h3 id="testirovanie-na-ustroystve">    </h3><br><p>     .            (  ),    .  ,      ,    ,       . </p><br><h3 id="ogranicheniya">  Einschränkungen </h3><br><p>    : </p><br><ul><li>   ,  ; </li><li>  —  ,    ; </li><li>        ,     (,    …); </li></ul><br><h3 id="melochi">  </h3><br><ul><li>        ,    <code>(task.taskIdentifier)</code>  ,     (Dictionary).    ,          1,   . </li><li>   , <code>URLSession.getAllTasks</code> .    ,        background .  ,    .   ,    . ¯\_(ツ)_/¯ </li><li>   ,  ,         ,    ,     . </li></ul><br><p>       ,      background ,      .      ,      -    .      : <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html">https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1</a> .   , : </p><br><blockquote> If your app extension initiates a background NSURLSession task, you must also set up a shared container that both the extension and its containing app can access. Use the sharedContainerIdentifier property of the NSURLSessionConfiguration class to specify an identifier for the shared container so that you can access it later. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478566/">https://habr.com/ru/post/de478566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478550/index.html">Wie verwalte ich eine Uhr? Analyse der Front-End-Strecke der zweiten Programmiermeisterschaft</a></li>
<li><a href="../de478552/index.html">Zweites Applet, Schließen und transparente Schaltflächen in Verarbeitung 3</a></li>
<li><a href="../de478554/index.html">Webinar "SRE - Hype oder die Zukunft?" 12. Dezember um 11:00 Uhr</a></li>
<li><a href="../de478560/index.html">Sind kostenlose Instant Messenger anonym?</a></li>
<li><a href="../de478564/index.html">Wie wir bei TsIAN Terabytes an Protokollen gezähmt haben</a></li>
<li><a href="../de478572/index.html">Bot in neuronalen Netzen: Wie ein virtueller Assistent funktioniert und lernt</a></li>
<li><a href="../de478574/index.html">Die Wahrheit über Eisenbahnbremsen: Teil 4 - Fahrgastbremsen</a></li>
<li><a href="../de478582/index.html">Globaler VPN-Bericht über mobile Geräte im Jahr 2019</a></li>
<li><a href="../de478584/index.html">JVM-Interna, Teil 2 - Dateistruktur der Klasse</a></li>
<li><a href="../de478586/index.html">Ineffizienz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>