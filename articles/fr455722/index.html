<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì¶ üë† üì¶ Python consomme beaucoup de m√©moire ou comment r√©duire la taille des objets? üëåüèΩ üê∏ üôÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un probl√®me de m√©moire peut survenir lorsque vous devez avoir un grand nombre d'objets pendant l'ex√©cution du programme, surtout s'il existe des restr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python consomme beaucoup de m√©moire ou comment r√©duire la taille des objets?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455722/"><p>  Un probl√®me de m√©moire peut survenir lorsque vous devez avoir un grand nombre d'objets pendant l'ex√©cution du programme, surtout s'il existe des restrictions sur la taille totale de la RAM disponible. </p><br><p>  Ce qui suit est un aper√ßu de certaines m√©thodes pour r√©duire la taille des objets, ce qui peut r√©duire consid√©rablement la quantit√© de RAM requise pour les programmes en Python pur. </p><a name="habracut"></a><br><p> Pour plus de simplicit√©, nous consid√©rerons les structures en Python pour repr√©senter des points avec des <code>x</code> , <code>y</code> , <code>z</code> avec acc√®s aux valeurs de coordonn√©es par leur nom. </p><br><h3 id="dict">  Dict </h3><br><p>  Dans les petits programmes, en particulier les scripts, il est assez simple et pratique d'utiliser le <code>dict</code> int√©gr√© pour repr√©senter les informations structurelles: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = {'x':1, 'y':2, 'z':3} &gt;&gt;&gt; x = ob['x'] &gt;&gt;&gt; ob['y'] = y</code> </pre> <br><p>  Avec l'av√®nement d'une impl√©mentation plus ¬´compacte¬ª dans Python 3.6 avec un ensemble ordonn√© de cl√©s, <code>dict</code> devenu encore plus attrayant.  Cependant, regardez la taille de sa trace en RAM: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 240</code> </pre> <br><p>  Cela prend beaucoup de m√©moire, surtout si vous devez soudainement cr√©er un grand nombre d'instances: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'exemplaires </th><th>  Taille de trace </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  240 Mo </td></tr><tr><td>  10 000 000 </td><td>  2,40 Go </td></tr><tr><td>  100 000 000 </td><td>  24 Go </td></tr></tbody></table></div><br><h3 id="class-instance">  Instance de classe </h3><br><p>  Pour ceux qui aiment tout habiller en classe, il est pr√©f√©rable de le d√©finir comme une classe avec acc√®s par nom d'attribut: </p><br><pre> <code class="plaintext hljs">class Point: # def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; x = ob.x &gt;&gt;&gt; ob.y = y</code> </pre> <br><p>  La structure de l'instance de classe est int√©ressante: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Le terrain </th><th>  Taille (octets) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  __weakref__ </td><td>  8 </td></tr><tr><td>  __dict__ </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>56</b> </td></tr></tbody></table></div><br><p>  Ici, <code>__weakref__</code> est un lien vers une liste de soi-disant <em>r√©f√©rences faibles</em> √† cet objet, le champ <code>__dict__</code> est un lien vers le dictionnaire d'instances de la classe qui contient les valeurs des attributs de l'instance (notez que les liens sur une plate-forme 64 bits occupent 8 octets).  √Ä partir de Python 3.3, un espace cl√© de dictionnaire partag√© est utilis√© pour toutes les instances de la classe.  Cela r√©duit la taille de la trace d'instance en m√©moire: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob), sys.getsizeof(ob.__dict__)) 56 112</code> </pre> <br><p>  Par cons√©quent, un grand nombre d'instances de classe laissent une plus petite empreinte en m√©moire qu'un dictionnaire standard ( <code>dict</code> ): </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'exemplaires </th><th>  Taille de trace </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  168 Mo </td></tr><tr><td>  10 000 000 </td><td>  1,68 Go </td></tr><tr><td>  100 000 000 </td><td>  16,8 Go </td></tr></tbody></table></div><br><p>  Il est facile de voir que la trace de l'instance en m√©moire est toujours importante en raison de la taille du dictionnaire d'instances. </p><br><h3 id="instance-of-class-with--__slots__">  Instance de classe avec __slots__ </h3><br><p>  Une r√©duction significative de la trace d'une instance en m√©moire est obtenue en √©liminant <code>__dict__</code> et <code>__weakref__</code> .  C'est possible avec le "truc" avec <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">class Point: __slots__ = 'x', 'y', 'z' def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 64</code> </pre> <br><p>  La trace en m√©moire est devenue beaucoup plus compacte: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Le terrain </th><th>  Taille (octets) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  z </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>64</b> </td></tr></tbody></table></div><br><p>  L'utilisation de <code>__slots__</code> dans la d√©finition de classe conduit au fait que la trace d'un grand nombre d'instances en m√©moire est consid√©rablement r√©duite: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'exemplaires </th><th>  Taille de trace </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  64 Mo </td></tr><tr><td>  10 000 000 </td><td>  640 Mo </td></tr><tr><td>  100 000 000 </td><td>  6,4 Go </td></tr></tbody></table></div><br><p>  Actuellement, il s'agit de la principale m√©thode pour r√©duire consid√©rablement la trace d'une instance de classe dans la m√©moire du programme. </p><br><p>  Cette r√©duction est obtenue par le fait que, apr√®s l'en-t√™te d'objet, les r√©f√©rences aux objets sont stock√©es dans la m√©moire et que l'acc√®s √† celles-ci est effectu√© √† l'aide de descripteurs sp√©ciaux qui se trouvent dans le dictionnaire de classes: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; pprint(Point.__dict__) mappingproxy( .................................... 'x': &lt;member 'x' of 'Point' objects&gt;, 'y': &lt;member 'y' of 'Point' objects&gt;, 'z': &lt;member 'z' of 'Point' objects&gt;})</code> </pre> <br><p>  Il existe une biblioth√®que de <code>__slots__</code> pour automatiser le processus de cr√©ation d'une classe avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">__slots__</a> .  La fonction <code>namedlist.namedlist</code> cr√©e une structure de classe identique √† la classe avec <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedlist('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Un autre package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attrs</a> vous permet d'automatiser le processus de cr√©ation de classes avec et sans <code>__slots__</code> . </p><br><h3 id="tuple">  Tuple </h3><br><p>  Python a √©galement un type de <code>tuple</code> int√©gr√© pour repr√©senter les ensembles de donn√©es.  Le tuple est une structure ou un enregistrement fixe, mais sans nom de champ.  Pour acc√©der au champ, l'index du champ est utilis√©.  Les champs de tuple sont une fois pour toutes associ√©s aux objets valeur au moment o√π le tuple est instanci√©: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = (1,2,3) &gt;&gt;&gt; x = ob[0] &gt;&gt;&gt; ob[1] = y # </code> </pre> <br><p>  Les instances de tuple sont assez compactes: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 72</code> </pre> <br><p>  Ils occupent 8 octets de plus en m√©moire que les instances de classe avec <code>__slots__</code> , car la trace de tuple en m√©moire contient √©galement le nombre de champs: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Le terrain </th><th>  Taille (octets) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  [0] </td><td>  8 </td></tr><tr><td>  [1] </td><td>  8 </td></tr><tr><td>  [2] </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>72</b> </td></tr></tbody></table></div><br><h3 id="namedtuple">  Namedtuple </h3><br><p>  Le tuple √©tant tr√®s largement utilis√©, un jour, il a √©t√© demand√© de pouvoir √©galement acc√©der aux champs par leur nom.  La r√©ponse √† cette demande a √©t√© le module <code>collections.namedtuple</code> . </p><br><p>  La fonction <code>namedtuple</code> con√ßue pour automatiser le processus de g√©n√©ration de ces classes: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedtuple('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Il cr√©e une sous-classe de tuple, qui d√©finit les poign√©es pour acc√©der aux champs par leur nom.  Pour notre exemple, cela ressemblera √† ceci: </p><br><pre> <code class="plaintext hljs"> class Point(tuple): # @property def _get_x(self): return self[0] @property def _get_y(self): return self[1] @property def _get_y(self): return self[2] # def __new__(cls, x, y, z): return tuple.__new__(cls, (x, y, z))</code> </pre> <br><p>  Toutes les instances de ces classes ont une trace en m√©moire identique √† tuple.  Un grand nombre d'instances laisse une empreinte m√©moire l√©g√®rement plus grande: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'exemplaires </th><th>  Taille de trace </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  72 Mo </td></tr><tr><td>  10 000 000 </td><td>  720 Mo </td></tr></tbody></table></div><br><h3 id="recordclass-mutiruemyy-namedtuple-bez-gc">  Recordclass: mut√© nomm√© tuple sans GC </h3><br><p>  √âtant <code>namedtuple</code> classes <code>tuple</code> et, par cons√©quent, <code>namedtuple</code> g√©n√®rent des objets non modifiables dans le sens o√π un objet valeur <code>ob.x</code> ne <code>ob.x</code> plus √™tre associ√© √† un autre objet valeur, une demande de variante de mutable namedtuple mut√©e est apparue.  √âtant donn√© que Python n'a pas de type int√©gr√© identique √† un tuple qui prend en charge les affectations, de nombreuses variantes ont √©t√© cr√©√©es.  Nous nous concentrerons sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe d'enregistrement</a> , qui a re√ßu une note de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stackoverflow</a> .  De plus, avec son aide, il est possible de r√©duire la taille de la trace d'un objet en m√©moire par rapport √† la taille de la trace d'objets de type <code>tuple</code> . </p><br><p>  Dans le package <strong>recordclass</strong> , le type <strong>recordclass.mutabletuple</strong> est <code>recordclass.mutabletuple</code> , qui est presque identique √† tuple mais prend √©galement en charge les affectations.  Sur sa base, des sous-classes sont cr√©√©es qui sont presque identiques aux couples nomm√©s, mais prennent √©galement en charge l'affectation de nouvelles valeurs aux champs (sans cr√©er de nouvelles instances).  La fonction <code>recordclass</code> , comme la fonction <code>namedtuple</code> , automatise la cr√©ation de telles classes: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = recordclass('Point', ('x', 'y', 'z')) &gt;&gt;&gt; ob = Point(1, 2, 3)</code> </pre> <br><p>  Les instances de la classe ont la m√™me structure que <code>tuple</code> , mais uniquement sans <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Le terrain </th><th>  Taille (octets) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>48</b> </td></tr></tbody></table></div><br><p>  Par d√©faut, la fonction <code>recordclass</code> g√©n√®re une classe qui n'est pas impliqu√©e dans le m√©canisme de r√©cup√©ration de place circulaire.  En r√®gle g√©n√©rale, <code>namedtuple</code> et <code>recordclass</code> sont utilis√©s pour g√©n√©rer des classes qui repr√©sentent des enregistrements ou des structures de donn√©es simples (non r√©cursives).  Leur utilisation correcte en Python ne g√©n√®re pas de r√©f√©rences circulaires.  Pour cette raison, la trace des instances de classes g√©n√©r√©es par la <code>PyGC_Head</code> par d√©faut <code>PyGC_Head</code> fragment <code>PyGC_Head</code> , qui est n√©cessaire pour les classes qui prennent en charge le m√©canisme de r√©cup√©ration de place cyclique (plus pr√©cis√©ment: l'indicateur <code>PyTypeObject</code> n'est pas d√©fini dans le champ <code>flags</code> de la structure <code>PyTypeObject</code> correspondant √† la classe en cours de cr√©ation). </p><br><p>  La taille de trace d'un grand nombre d'instances est plus petite que celle des instances d'une classe avec <code>__slots__</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'exemplaires </th><th>  Taille de trace </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  48 Mo </td></tr><tr><td>  10 000 000 </td><td>  480 Mo </td></tr><tr><td>  100 000 000 </td><td>  4,8 Go </td></tr></tbody></table></div><br><h3 id="dataobject">  Dataobject </h3><br><p>  Une autre solution propos√©e dans la biblioth√®que <code>recordclass</code> repose sur l'id√©e: utiliser la structure de stockage en m√©moire, comme dans les instances de classes avec <code>__slots__</code> , mais ne pas participer au m√©canisme de ramassage cyclique des ordures.  La classe est <code>recordclass.make_dataclass</code> √† l'aide de la fonction <code>recordclass.make_dataclass</code> : </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = make_dataclass('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  La classe par d√©faut cr√©√©e de cette mani√®re cr√©e des instances mut√©es. </p><br><p>  Une autre fa√ßon consiste √† utiliser la d√©claration de classe en h√©ritant de <code>recordclass.dataobject</code> : </p><br><pre> <code class="plaintext hljs">class Point(dataobject): x:int y:int z:int</code> </pre> <br><p>  Les classes cr√©√©es de cette mani√®re g√©n√©reront des instances qui ne participent pas au m√©canisme de collecte de d√©chets circulaire.  La structure de l'instance en m√©moire est la m√™me qu'avec <code>__slots__</code> , mais sans l'en <code>PyGC_Head</code> t√™te <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Le terrain </th><th>  Taille (octets) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>40</b> </td></tr></tbody></table></div><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 40</code> </pre> <br><p>  Pour acc√©der aux champs, des descripteurs sp√©ciaux sont √©galement utilis√©s pour acc√©der au champ par son d√©calage par rapport au d√©but de l'objet, qui sont plac√©s dans le dictionnaire de classe: </p><br><pre> <code class="plaintext hljs">mappingproxy({'__new__': &lt;staticmethod at 0x7f203c4e6be0&gt;, ....................................... 'x': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c690&gt;, 'y': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c670&gt;, 'z': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c410&gt;})</code> </pre> <br><p>  La taille de trace d'un grand nombre d'instances est la plus petite possible pour CPython: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'exemplaires </th><th>  Taille de trace </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  40 Mo </td></tr><tr><td>  10 000 000 </td><td>  400 Mo </td></tr><tr><td>  100 000 000 </td><td>  4,0 Go </td></tr></tbody></table></div><br><h3 id="cython">  Cython </h3><br><p>  Il existe une approche bas√©e sur l'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cython</a> .  Son avantage est que les champs peuvent prendre des valeurs de types de langage C. Les descripteurs pour acc√©der aux champs √† partir de Python pur sont cr√©√©s automatiquement.  Par exemple: </p><br><pre> <code class="plaintext hljs">cdef class Python: cdef public int x, y, z def __init__(self, x, y, z): self.x = x self.y = y self.z = z</code> </pre> <br><p>  Dans ce cas, les instances ont une taille de m√©moire encore plus petite: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 32</code> </pre> <br><p>  Une trace d'instance en m√©moire a la structure suivante: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Le terrain </th><th>  Taille (octets) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  est vide </td><td>  4 </td></tr><tr><td>  <b>TOTAL:</b> </td><td>  <b>32</b> </td></tr></tbody></table></div><br><p>  La taille de trace d'un grand nombre de copies est plus petite: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'exemplaires </th><th>  Taille de trace </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  32 Mo </td></tr><tr><td>  10 000 000 </td><td>  320 Mo </td></tr><tr><td>  100 000 000 </td><td>  3,2 Go </td></tr></tbody></table></div><br><p>  Cependant, il faut se rappeler que lors de l'acc√®s √† partir du code Python, la conversion de <code>int</code> en objet Python et vice versa sera effectu√©e √† chaque fois. </p><br><h3 id="numpy">  Numpy </h3><br><p>  L'utilisation de tableaux multidimensionnels ou d'enregistrement pour de grandes quantit√©s de donn√©es donne un gain de m√©moire.  Cependant, pour un traitement efficace en Python pur, vous devez utiliser des m√©thodes de traitement qui se concentrent sur l'utilisation des fonctions du package <code>numpy</code> . </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = numpy.dtype(('x', numpy.int32), ('y', numpy.int32), ('z', numpy.int32)])</code> </pre> <br><p>  Un tableau et <code>N</code> √©l√©ments initialis√©s avec des z√©ros sont cr√©√©s √† l'aide de la fonction: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; points = numpy.zeros(N, dtype=Point)</code> </pre> <br><p>  La taille du tableau est la plus petite possible: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nombre d'exemplaires </th><th>  Taille de trace </th></tr></thead><tbody><tr><td>  1 000 000 </td><td>  12 Mo </td></tr><tr><td>  10 000 000 </td><td>  120 Mo </td></tr><tr><td>  100 000 000 </td><td>  1,20 Go </td></tr></tbody></table></div><br><p>  L'acc√®s r√©gulier aux √©l√©ments du tableau et aux cha√Ænes n√©cessitera une conversion d'objet Python <br>  dans la valeur de C <code>int</code> et vice versa.  L'extraction d'une seule ligne donne un tableau contenant un seul √©l√©ment.  Sa piste ne sera pas aussi compacte: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; sys.getsizeof(points[0]) 68</code> </pre> <br><p>  Par cons√©quent, comme indiqu√© ci-dessus, dans le code Python, il est n√©cessaire de traiter les tableaux √† l'aide des fonctions du package <code>numpy</code> . </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  √Ä l'aide d'un exemple clair et simple, il a √©t√© possible de v√©rifier que la communaut√© des d√©veloppeurs et des utilisateurs du langage de programmation Python (CPython) a de r√©elles opportunit√©s de r√©duire consid√©rablement la quantit√© de m√©moire utilis√©e par les objets. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455722/">https://habr.com/ru/post/fr455722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455702/index.html">G√©n√©ration efficace de nombres dans un intervalle donn√©</a></li>
<li><a href="../fr455710/index.html">Pourquoi chez Leroy Merlin, avons-nous besoin de notre propre service de d√©veloppement russe pour 200 personnes</a></li>
<li><a href="../fr455714/index.html">Exportez automatiquement Google Forms vers Notion √† l'aide d'IFTTT et de Django</a></li>
<li><a href="../fr455716/index.html">15 meilleures pratiques pour le d√©ploiement de logiciels de Business Intelligence</a></li>
<li><a href="../fr455720/index.html">Comment nous construisons l'interface utilisateur pour les syst√®mes publicitaires</a></li>
<li><a href="../fr455726/index.html">C ++ Enterprise Edition. Est-ce possible?</a></li>
<li><a href="../fr455728/index.html">Faire votre bouton d'action flottant presque √©tendu</a></li>
<li><a href="../fr455730/index.html">Installez MacOS High Sierra lorsque seul le WiFi est √† port√©e de main</a></li>
<li><a href="../fr455734/index.html">L'habitude de faire maintenant</a></li>
<li><a href="../fr455736/index.html">Consensus sur les crypto-monnaies avec l'exploitation mini√®re hybride et multi-PoW</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>