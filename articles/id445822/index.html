<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📔 👩🏽‍🤝‍👨🏿 🖤 Kenapa Jaop? Mengapa raket? 👩🏼‍🚒 💘 🤲🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah kelanjutan dari artikel “Mengapa Racket? Kenapa Tertidur? ” Saya menulis sekitar setahun setelah saya menemukan Racket . Sebagai seorang pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kenapa Jaop? Mengapa raket?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445822/"> Ini adalah kelanjutan dari artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Mengapa Racket?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kenapa Tertidur? ”</a>  Saya menulis sekitar setahun setelah saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Racket</a> .  Sebagai seorang pemula, saya tidak bisa memahami pujian yang mengalir pada Lisp dari semua sisi.  Saya tidak tahu harus berpikir apa.  Bagaimana memahami bahwa Lisp pada akhirnya akan menyebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"pencerahan yang mendalam</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a>  Oke, bro, katamu. <br><br>  Saya punya pertanyaan sederhana: <b>apa gunanya?</b>  Dalam artikel sebelumnya, saya mencoba menjawabnya dan merangkum alasan mengapa seseorang ingin belajar Lisp atau, khususnya, Racket. <br><br>  Saya telah menyusun daftar fitur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sembilan bahasa yang</a> paling berharga bagi saya sebagai pemula untuk Racket.  Misalnya, fitur nomor 5 adalah "penciptaan bahasa pemrograman baru".  Metode ini juga disebut <i>pemrograman berorientasi bahasa</i> , atau <i>JOP</i> . <br><a name="habracut"></a><br>  Sejak itu, IOP telah menjadi bagian favorit saya dari Racket, dan saya berbagi kekaguman saya dalam buku online <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beautiful Racket</a> , yang menjelaskan teknik ROP dan alat Racket. <br><br>  Salah satu contoh dalam pekerjaan saya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pollen</a> .  Saya menulis bahasa pemrograman ini untuk tipografi yang nyaman dari buku online saya.  Di Pollen, paragraf sebelumnya diprogram sebagai berikut: <br><br><pre><code class="plaintext hljs">#lang pollen     ◊link["https://beautifulracket.com/appendix/why-racket-why-lisp.html#so-really-whats-in-it-for-me-now"]{  },        Racket. ,  № 5 — «   ».     ◊em{- },  ◊em{}.</code> </pre> <br>  Contoh lain adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">brag</a> , generator parser (dengan gaya <code>lex/yacc</code> ), yang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tata bahasa BNF</a> sebagai kode sumber.  Contoh sederhana untuk bahasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bf</a> : <br><br><pre> <code class="plaintext hljs">#lang brag bf-program : (bf-op | bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "." | "," bf-loop : "[" (bf-op | bf-loop)* "]"</code> </pre> <br>  Kedua bahasa diimplementasikan dalam Racket dan dapat dijalankan dengan juru bahasa Racket biasa atau di dalam IDE Racket (disebut DrRacket). <br><br><h1>  Masalah utama </h1><br>  Namun ... Terlepas dari kenyataan bahwa buku itu telah memaksa ribuan orang untuk mulai menjelajahi Racket, kadang-kadang tampak bagi saya bahwa saya melangkah di tanah cepat yang sama dengan para penggemar Lisp yang pernah saya kritik. <br><br>  Jika NOP sangat keren, lalu mengapa menghabiskan beberapa hari membaca buku.  Benar?  Saya bisa menjelaskan semuanya dengan singkat, tanpa basa-basi lagi.  Dua pertanyaan sederhana perlu dijawab: <br><br><ol><li>  Masalah apa yang paling cocok untuk pemrograman bahasa? <br></li><li>  Mengapa Racket terbaik untuk membuat bahasa? </li></ol><br>  Pertanyaan kedua sederhana.  Yang pertama bukan.  Saya ditanyai dia berkali-kali.  Saya sering mengutip ungkapan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terkenal</a> Hakim Stewart Stewart: Anda akan memahaminya ketika Anda melihatnya.  Jawabannya cukup baik bagi mereka yang benar-benar tertarik.  Tetapi tidak bagi mereka yang berada di pihak dan ingin mendengarkan argumen substantif. <br><br>  Jadi, saya akan coba.  Perlu diingat bahwa saya bukan profesor ilmu komputer dan tidak bisa berbicara tentang teori bahasa pemrograman.  Sebaliknya, saya menggunakan Racket dan bahasa khusus domain (DSL) untuk tujuan praktis: pekerjaan sehari-hari saya bergantung pada mereka.  Karena itu, saya akan fokus pada aspek praktis. <br><br><h1>  Jawaban singkat </h1><br><ol><li>  JOP sebenarnya adalah metode desain antarmuka.  Ini sangat ideal untuk tugas-tugas yang membutuhkan <b>notasi minimal dengan</b> tetap menjaga <b>akurasi maksimum</b> .  Notasi minimal berarti satu-satunya notasi yang diizinkan.  Tidak lebih.  Presisi maksimum, yaitu, makna notasi ini, persis seperti yang Anda katakan.  Tidak ada ambiguitas atau pola.  TIO mencapai titik seperti tidak ada yang lain. <br><br>  (Tidak sabar dapat beralih ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kategori tugas tertentu</a> yang akan mendapat manfaat dari NOP). <br></li><li>  Racket sangat ideal untuk OOP karena <b>sistem makronya</b> .  Mereka bekerja dalam gaya kompiler, menyederhanakan konversi kode.  Sistem makro Racket lebih baik daripada yang lain. </li></ol><br>  Pada titik ini, setengah dari pembaca artikel akan ingin menerbitkan komentar anonim yang mengkritik tesis saya.  Tetapi harap diingat: bagaimanapun juga, saya menang.  JOP dan Racket telah sangat meningkatkan produktivitas pemrograman saya.  Saya senang berbagi pengetahuan ini sehingga Anda juga dapat memanfaatkan manfaat ini.  Tetapi saya juga akan senang jika alat ini tetap menjadi senjata rahasia saya.  Dalam hal ini, saya akan tetap di 0,01% dari programmer paling produktif, mendapatkan hasil yang lebih mengesankan dan menguntungkan daripada 99,9% sisanya <br><br>  Jadi pilihan ada di tangan Anda. <br><br><h1>  Jawaban panjang </h1><br>  Jika Anda memikirkan pertanyaan-pertanyaan paling penting, mereka sampai pada satu pertanyaan meta: mengapa sulit untuk menjelaskan manfaat senjata nuklir? <br><br>  Mungkin ketika kita berbicara tentang <i>bahasa</i> , istilah itu penuh dengan harapan tentang apa bahasa itu dan apa fungsinya.  Sementara kita berada di dalam paradigma ini, sulit untuk memahami nilai bahasa pemrograman. <br><br>  Tetapi jika Anda mengurangi skala dan menganggap bahasa sebagai bagian dari kategori yang lebih luas dari antarmuka manusia-komputer, maka lebih mudah untuk melihat keuntungan spesifik dari OOP.  Jadi mari kita lakukan. <br><br><h1>  Bahasa umum dan bahasa khusus domain </h1><br>  Pertama, terminologi kecil.  Pemrograman berorientasi bahasa (juga dikenal sebagai OOP) adalah ide untuk memecahkan masalah pemrograman dengan menciptakan bahasa baru, dan kemudian menulis program di atasnya.  Seringkali "bahasa kecil" seperti itu disebut bahasa khusus domain (DSL). <br><br>  Seperti namanya, bahasa yang berorientasi pada subjek disesuaikan dengan tugas-tugas bidang tertentu.  Misalnya, PostScript, SQL, <code>make</code> , ekspresi reguler, <code>.htaccess</code> dan HTML dianggap bahasa yang berorientasi pada subjek.  Mereka tidak berusaha melakukan segalanya.  Sebaliknya, mereka fokus melakukan satu hal dengan baik. <br><br>  Di ujung lain dari spektrum <i>adalah bahasa tujuan umum</i> .  Di sini kita melihat C, Pascal, Perl, Java, Python, Ruby, Racket, dll. Mengapa mereka tidak dianggap berorientasi pada subjek?  Karena mereka memposisikan diri untuk berbagai tugas komputasi. <br><br>  Dalam praktiknya, bahasa serba guna sering berspesialisasi dalam bidang tertentu.  Misalnya, C lebih baik daripada yang lain untuk pemrograman sistem.  Perl - untuk skrip dalam administrasi sistem.  Python menonjol sebagai bahasa untuk pemula.  Racket untuk pemrograman berorientasi bahasa.  Dalam setiap kasus, ini adalah apa bahasa yang awalnya dirancang untuk. <br><br>  Ada garis tipis antara DSL dan bahasa tujuan umum.  Misalnya, Ruby dibuat sebagai bahasa tujuan umum, tetapi menjadi populer terutama untuk aplikasi web melalui hubungannya dengan Ruby on Rails.  Sebaliknya, JavaScript pada awalnya adalah bahasa yang berorientasi pada subjek untuk skrip browser web.  Tapi dia bermutasi seperti virus, dan sejak itu telah berkembang jauh melampaui tugas aslinya. <br><br><h1>  Apa itu bahasa? </h1><br>  Jika seluruh spektrum luas ini disebut bahasa, lalu apa saja fitur yang menentukan dari bahasa tersebut? <br><br>  Saya tahu apa yang Anda pikirkan: “Di sinilah Anda salah.  HTML bukan bahasa.  Ini hanya markup.  Dia tidak bisa mendeskripsikan algoritme. ”  Atau: “Ekspresi reguler bukan bahasa.  Mereka tidak bekerja sendiri.  Itu hanya sintaks untuk bahasa lain. " <br><br>  Dulu saya juga berpikir begitu.  Tetapi semakin dekat saya melihat, semakin kabur perbedaan-perbedaan ini.  Dengan demikian, pernyataan utama pertama saya (dari tiga): bahasa pemrograman pada dasarnya merupakan media pertukaran - <b>sistem notasi yang dapat dimengerti oleh orang dan komputer</b> . <br><br>  Sistem notasi (notasi) berarti bahasa tersebut memiliki sintaksis.  "Jelas" berarti bahwa dengan sintaksnya bahasa menyampaikan <i>makna</i> (atau <i>semantik</i> , jika Anda menggunakan kata yang lebih mewah).  Definisi ini mencakup semua bahasa pemrograman untuk tujuan umum.  Dan semua DSL.  (Tapi tidak setiap aliran data, yang akan dibahas lebih detail nanti). <br><br>  (Omong-omong, meskipun "pemrograman" dan "bahasa" adalah kata-kata yang digunakan secara bersama-sama, bahasa ini tidak hanya digunakan oleh orang-orang untuk memprogram komputer. Kadang-kadang mereka digunakan oleh komputer untuk berkomunikasi dengan kami (misalnya, ekspresi S), kadang-kadang untuk berkomunikasi satu sama lain (misalnya, XML, JSON, HTML.) Jelas, tampaknya salah untuk mengecualikan fitur-fitur ini. Tetapi dalam praktiknya, ya - apa yang biasanya kita lakukan dengan bahasa pemrograman, sebenarnya, pemrograman.) <br><br>  Pertimbangkan kode HTML: cara untuk memberi tahu komputer - khususnya browser web - cara menggambar halaman web.  Ini adalah sistem notasi (kurung sudut, tag, atribut, dll.) Yang dapat dimengerti oleh manusia dan komputer (atribut <code>charset</code> menunjukkan pengkodean karakter, tag <code>p</code> berisi paragraf, dll.). <br><br>  Ini adalah halaman HTML kecil: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UTF-8"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>My web page<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>world<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Misalkan Anda tidak setuju bahwa HTML adalah bahasa pemrograman.  Bagus  Kami akan menampilkan halaman kami dengan Python.  Ini adalah bahasa pemrograman yang nyata, bukan? <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;!DOCTYPE html&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;html&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;head&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;meta charset=\"UTF-8\"&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;title&gt;My web page&lt;/title&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;/head&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;body&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;p&gt;Hello &lt;strong&gt;world&lt;/strong&gt;&lt;/p&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;/body&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;html&gt;"</span></span></code> </pre> <br>  Jika Python adalah bahasa pemrograman, tetapi HTML tidak, maka sampel Python ini adalah sebuah program, tetapi sampel HTML bukan. <br><br>  Jelas, ini adalah perbedaan yang tersiksa.  Di sini pythonization tidak menambahkan apa pun kecuali kompleksitas dan stereotip.  Hal yang mengasyikkan adalah bahwa satu-satunya konten semantik yang menarik dalam program Python - dari sudut pandang mengelola browser web - adalah bahwa konten tersebut disematkan dalam HTML (mungkin tag HTML seperti <code>DOCTYPE</code> , <code>meta</code> , dan <code>strong</code> dapat dianggap sebagai fungsi yang mengambil argumen).  Logika membuat kita menyimpulkan bahwa HTML, meskipun lebih sederhana dan kurang fleksibel, masih merupakan bahasa pemrograman. <br><br><h1>  Bahasa Tertanam </h1><br>  Contoh dengan HTML dan Python kami buat.  Tetapi menanamkan DSL dalam bahasa lain ada di mana-mana.  Bahasa yang digunakan dengan cara ini disebut <i>tertanam</i> .  Mereka mewakili bentuk pemrograman bahasa yang paling umum.  Sebagai seorang programmer, Anda telah mengandalkan JOP selama bertahun-tahun, bahkan jika Anda tidak tahu namanya. <br><br>  Misalnya, ekspresi reguler (contoh lain: <code>printf</code> untuk string pemformatan, CLDR untuk pola tanggal / waktu, SQL).  Kami tidak dapat menganggap ekspresi reguler sebagai bahasa independen.  Tetapi setiap programmer tahu apa itu: <br><br><pre> <code class="plaintext hljs">^fo+(bar)*$</code> </pre> <br>  Selain itu, Anda mungkin dapat memasukkan ekspresi reguler ini dalam bahasa pemrograman favorit Anda dan itu hanya akan berfungsi.  Perilaku konsisten ini hanya dimungkinkan karena notasi ekspresi reguler adalah bahasa eksternal ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">POSIX</a> ). <br><br>  Seperti halnya HTML, kita dapat menulis ekspresi yang setara dalam notasi bahasa host.  Misalnya, Racket mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skeme regular expressions</a> (SRE): ini adalah ekspresi reguler dengan notasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekspresi-S</a> .  Template di atas akan ditulis seperti ini: <br><br><pre> <code class="plaintext hljs">(seq bos "f" (+ "o") (* (submatch "bar")) eos)</code> </pre> <br>  Tetapi programmer Racket jarang menggunakan ekspresi SRE.  Mereka terlalu panjang dan sulit untuk diingat. <br><br>  Contoh lain yang ada di mana-mana dari DSL yang disematkan: ekspresi matematika.  Setiap programmer tahu apa artinya ini: <br><br><pre> <code class="plaintext hljs">(1 + 2) * (3 / 4) - 5</code> </pre> <br>  Ekspresi matematika saja tidak membuat program yang menarik.  Kita perlu menggabungkannya dengan konstruksi bahasa lain.  Tetapi, seperti halnya ekspresi reguler, ini adalah catatan yang ergonomis dan praktis.  Ekspresi matematika memiliki notasi dan makna mereka sendiri yang dapat dimengerti oleh orang dan komputer, sehingga mereka memenuhi syarat sebagai bahasa bawaan yang terpisah. <br><br><h1>  Apakah Anda bercanda bahwa HTML adalah pemrograman? </h1><br>  Bukan itu.  Saya menegaskan bahwa HTML (baik ekspresi reguler maupun matematika) memenuhi syarat sebagai bahasa pemrograman yang belum sempurna.  Ini berarti bahwa menulis HTML (atau ekspresi reguler atau ekspresi matematika) memenuhi syarat sebagai pemrograman dasar. <br><br>  Tolong jangan panik.  Tentu saja, seorang "programmer" di LinkedIn dengan pengetahuan hanya HTML dan aritmatika, ini omong kosong (walaupun dalam seminggu ia mungkin akan mendapatkan pekerjaan sebesar $ 180 ribu).  Tapi ini adalah masalah terpisah, apa artinya "programmer" di pasar tenaga kerja.  Kami tidak membicarakan hal itu. <br><br><h1>  Turing Totality Trap </h1><br>  Jika definisi bahasa pemrograman ini masih mengganggu Anda, mungkin Anda berpikir bahwa bahasa pemrograman nyata harus mengekspresikan semua algoritma yang mungkin - yaitu, itu harus <i>Turing lengkap</i> . <br><br>  Saya mengerti bahwa secara intuitif pemikiran seperti itu menunjukkan dirinya.  Setiap bahasa pemrograman tujuan umum Turing lengkap. <br><br>  Tetapi masalahnya adalah bahwa ini adalah bar rendah.  Kelengkapan Turing adalah metrik teknis yang tidak sesuai dengan penggunaan bahasa di dunia nyata.  Sebagai contoh, ekspresi reguler tidak Turing lengkap, tetapi mereka berguna ketika mengekspresikan banyak perhitungan dengan notasi minimal.  HTML juga Turing tidak lengkap, tetapi ini adalah cara yang berguna untuk mengontrol browser.  Sebaliknya, bahasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bf</a> adalah Turing yang lengkap, tetapi bahkan tugas yang paling sepele membutuhkan kilometer kode yang tidak bisa dilewati. <br><br><h1>  Batasan bahasa </h1><br>  Apakah ada yang masuk dalam definisi bahasa saya?  Tidak. <br><br><ul><li>  <i>Format data biner</i> tidak dianggap sebagai bahasa.  Misalnya, file <code>jpeg</code> .  Meskipun komputer dapat memahaminya, seseorang tidak.  Atau PDF: jika Anda meretasnya, ada beberapa bagian di dalamnya yang dapat dibaca manusia.  Tapi ini karena cara kerja PDF.  Tidak ada gunanya menulis ide menggunakan konstruk PDF. <br></li><li>  <i>File teks</i> bukan bahasa.  Misalkan kita memiliki file dengan Homer's Iliad.  Kita manusia dapat membaca dan memahaminya.  Meskipun komputer dapat dengan mudah memproses file dengan, misalnya, mencetak kontennya, teks di dalamnya tidak dapat dipahami oleh komputer. <br></li><li>  <i>Antarmuka pengguna grafis</i> bukan bahasa.  Ya, ini adalah sistem notasi (yang mengandalkan teks dan gambar).  Tetapi mereka hanya bisa dimengerti oleh orang-orang.  Komputer menggambar GUI tetapi tidak memahaminya. </li></ul><br><h1>  Bahasa sebagai Antarmuka </h1><br>  Di atas, saya menggambarkan bahasa pemrograman sebagai "media pertukaran" antara orang dan komputer.  Dengan demikian, bahasa masuk ke dalam kategori yang lebih luas, yang kami sebut <i>antarmuka</i> . <br><br>  Ini mengarah pada pernyataan dasar kedua (dari tiga): bahwa <b>pemrograman bahasa pada dasarnya adalah metode mendesain antarmuka</b> .  Jika Anda suka memikirkan antarmuka, Anda akan menyukai JOP.  Jika tidak, Anda masih akan menyukai JOP karena memungkinkan antarmuka yang tidak dapat dicapai. <br><br>  Salah satu contoh favorit saya dari bahasa sebagai antarmuka adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sesumbar</a> , bahasa generator parser yang dibuat dengan Racket.  Jika Anda pernah menggunakan lex / yacc toolchain, Anda tahu bahwa seringkali tujuannya adalah untuk menghasilkan parser dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tata bahasa BNF</a> .  Misalnya, untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bf,</a> terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">bf-program : (bf-op | bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "." | "," bf-loop : "[" (bf-op | bf-loop)* "]"</code> </pre><br>  Untuk membuat parser dalam bahasa tujuan umum, Anda perlu menerjemahkan tata bahasa ini menjadi sekelompok kode asli.  Ini adalah pekerjaan yang membosankan.  Dan tidak ada gunanya - bukankah kita sudah menulis tata bahasa?  Kenapa melakukannya lagi? <br><br>  Namun, <code>brag</code> memenuhi keinginan kami.  Untuk membuat parser, kita cukup menambahkan baris <code>#Lang brag</code> ke file, yang secara ajaib mengubah tata bahasa BNF ke kode sumber <code>brag</code> : <br><br><pre> <code class="plaintext hljs">#Lang brag bf- : (Bf-op | Bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "."| "," Bf-loop : "["(Bf-op | Bf-loop)* "]"</code> </pre> <br>  Selesai!  Saat dikompilasi, file ini mengekspor fungsi <code>parse</code> , yang mengimplementasikan tata bahasa BNF ini. <br><br>  Ini adalah salah satu contoh favorit saya karena tidak dapat disangkal unggul dari opsi lain.  Selain itu, dengan bahasa tujuan umum, antarmuka seperti itu praktis tidak mungkin. <br><br>  Tetapi seorang programmer JOP terus-menerus membuat antarmuka seperti itu. <br><br><a name="1"></a><h1>  Di mana bahasa adalah antarmuka terbaik </h1><br>  Ini membawa saya pada tesis dasar ketiga dan terakhir saya bahwa <b>bahasa memiliki kelebihan unik dibandingkan antarmuka</b> .  Tentu saja, kategori di bawah ini tidak lengkap atau eksklusif.  Tetapi saya menemukan bahwa IOP memiliki banyak hal untuk ditawarkan dalam situasi seperti ini: <br><br>  1. Saat Anda ingin membuat antarmuka untuk programmer yang kurang terampil, atau yang bukan programmer, atau programmer yang malas (jangan meremehkan ukuran kategori yang terakhir). <br><br>  Misalnya, Racket memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan aplikasi web yang</a> canggih.  Tetapi server web sederhana juga dapat dengan cepat mulai menggunakan bahasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>web-server/insta</code></a> : <br><br><pre> <code class="plaintext hljs">#lang web-server/insta (define (start request) (response/xexpr '(html (body "Hello LOP World"))))</code> </pre> <br>  Matthew Flatt dalam artikelnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Creating Languages ​​in Racket"</a> menunjukkan bahasa yang menghasilkan petualangan teks yang dapat diputar.  Seperti <code>brag</code> , itu lebih mirip spesifikasi daripada program, tetapi berfungsi: <br><br><pre> <code class="plaintext hljs">#lang txtadv ===VERBS=== north, n "go north" south, s "go south" get _, grab _, take _ "get" ===THINGS=== ---cactus--- get "Ouch!" ===PLACES=== ---desert--- "You're in a desert. There is nothing for miles around." [cactus, key] north meadow south desert</code> </pre> <br>  2. Ketika Anda ingin menyederhanakan notasi.  Salah satu contohnya adalah ekspresi reguler.  Contoh lain adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pollen</a> bahasa berorientasi subjek saya untuk menulis buku online.  Pollen mirip dengan Racket, hanya di sini Anda mulai bekerja dalam mode teks dan menggunakan karakter khusus untuk menunjukkan perintah Racket yang tertanam dalam konten (Pollen didasarkan pada bahasa dokumentasi Racket yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scribble</a> , yang mengambil sebagian besar beban).  Jadi, awal paragraf ini diprogram sebagai berikut: <br><br><pre> <code class="plaintext hljs">    .    —  .   —  -  ◊link["https://pollenpub.com/"]{Pollen}   -.</code> </pre> <br>  Pollen peduli tentang menempelkan semua tag yang diperlukan dan mengubahnya menjadi HTML yang sempurna.  Saya masih memiliki semua kelebihan markup manual (kontrol penuh atas halaman), tetapi tidak ada kekurangan (katakanlah, saya tidak dapat secara tidak sengaja meninggalkan tag yang tidak tertutup). <br><br>  Contoh lain dari notasi yang disederhanakan adalah <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lindenmayer</a></code> , generasi fraktal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem Lindenmayer</a> dan bahasa gambar, seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/e10/ffe/f98e10ffe99b9f7efbb052ddaf4097a5.png"></div><br><br>  Dalam Racket biasa, program Lindenmayer mungkin terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">#lang racket/base (require lindenmayer/simple/compile) (define (finish val) (newline)) (define (A value) (display 'A)) (define (B value) (display 'B)) (lindenmayer-system (void) finish 3 (A) (A -&gt; AB) (B -&gt; A))</code> </pre> <br>  Tetapi Anda dapat menggunakan notasi yang disederhanakan dengan hanya mengubah notasi <code>#lang</code> di bagian atas file: <br><br><pre> <code class="plaintext hljs">#lang lindenmayer/simple ## axiom ## A ## rules ## A -&gt; AB B -&gt; A ## variables ## n=3</code> </pre> <br>  Bahasa ini mengasumsikan bahwa Anda sudah terbiasa dengan sistem-L.  Tetapi notasi yang disederhanakan memudahkan untuk menuliskan keinginan Anda dalam program yang melakukan apa yang Anda inginkan. <br><br>  3. Saat Anda ingin bekerja dengan notasi yang ada.  Kami melihat di atas bagaimana <code>brag</code> menggunakan tata bahasa BNF sebagai kode sumber. <br><br><pre> <code class="plaintext hljs">#lang brag bf-program : (bf-op | bf-loop)* bf-op : "&gt;" | "&lt;" | "+" | "-" | "." | "," bf-loop : "[" (bf-op | bf-loop)* "]"</code> </pre> <br>  Contoh lain.  Orang yang mencoba Pollen berkata, "Ya, itu bagus, tapi saya lebih suka Markdown."  Tidak masalah: <code>pollen/markdown</code> adalah dialek Pollen yang menawarkan semantik Pollen tetapi menerima notasi Markdown biasa: <br><br><pre> <code class="markdown hljs">    .    —  .   —  -  [<span class="hljs-string"><span class="hljs-string">Pollen</span></span>](<span class="hljs-link"><span class="hljs-link">"https://pollenpub.com/"</span></span>)   -.</code> </pre> <br>  Hal yang paling menyenangkan?  Saya menulis dialek ini hanya dalam satu jam, menggabungkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parser Markdown</a> dengan kode yang ada. <br><br>  4. Jika Anda ingin membuat target menengah untuk bahasa lain.  JSON, YAML, S-expressions, dan XML adalah semua bahasa yang berorientasi subjek yang menentukan format data untuk mesin baca dan tulis. <br><br>  Dalam Perfect Racket, satu bahasa pelatihan disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>jsonic</code></a> .  Ini memungkinkan Anda untuk menanamkan ekspresi Racket di JSON, sehingga membuat JSON dapat diprogram.  Kode sumber terlihat seperti ini: <br><br><pre> <code class="json hljs">#lang jsonic // a line comment [ @$ '<span class="hljs-literal"><span class="hljs-literal">null</span></span> $@, @$ (* <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>) $@, @$ (= <span class="hljs-number"><span class="hljs-number">2</span></span> (+ <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) $@, @$ (list <span class="hljs-string"><span class="hljs-string">"array"</span></span> <span class="hljs-string"><span class="hljs-string">"of"</span></span> <span class="hljs-string"><span class="hljs-string">"strings"</span></span>) $@, @$ (hash 'key<span class="hljs-number"><span class="hljs-number">-1</span></span> '<span class="hljs-literal"><span class="hljs-literal">null</span></span> 'key<span class="hljs-number"><span class="hljs-number">-2</span></span> (even? <span class="hljs-number"><span class="hljs-number">3</span></span>) 'key<span class="hljs-number"><span class="hljs-number">-3</span></span> (hash 'subkey <span class="hljs-number"><span class="hljs-number">21</span></span>)) $@ ]</code> </pre> <br>  Kompilasi ke JSON reguler: <br><br><pre> <code class="json hljs">[ <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, [<span class="hljs-string"><span class="hljs-string">"array"</span></span>,<span class="hljs-string"><span class="hljs-string">"of"</span></span>,<span class="hljs-string"><span class="hljs-string">"strings"</span></span>], {<span class="hljs-attr"><span class="hljs-attr">"key-1"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>,<span class="hljs-attr"><span class="hljs-attr">"key-3"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"subkey"</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span>},<span class="hljs-attr"><span class="hljs-attr">"key-2"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>} ]</code> </pre> <br>  5. Ketika bagian utama dari program adalah konfigurasi.  Sebagai contoh, Dotfiles dapat digambarkan sebagai DSL.  Contoh yang lebih kompleks dari Racket adalah Riposte Jesse Alama, bahasa untuk menguji HTTP API berbasis JSON: <br><br><pre> <code class="plaintext hljs">#lang riposte $productId := 41966 $qty := 5 $campaignId := 1 $payload := { "product_id": $productId, "campaign_id": $campaignId, "qty": $qty } POST $payload cart/{uuid}/items responds with 200 $itemId := /items/0/cart_item_id GET cart responds with 200</code> </pre> <br>  Sebagai bahasa skrip miniatur, Riposte jauh lebih pintar daripada rata-rata dotfile.  Itu menyembunyikan semua kode perantara yang diperlukan untuk transaksi HTTP, dan memungkinkan pengguna untuk fokus pada tes menulis.  Ini masih membersihkan rumah.  Tapi setidaknya Anda bisa fokus pada rumah tangga yang Anda sayangi. <br><br><h1>  Mengapa raket? </h1><br>  Seringkali, kritikus JOP bertanya: “Mengapa membuat bahasa yang berorientasi pada subjek?  Apakah lebih mudah menulis perpustakaan asli? " <br><br>  Tidak, itu tidak mudah jika Anda memiliki alat yang tepat.  Racket tidak biasa: ia dirancang dari bawah ke atas khusus untuk YOP.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, menerapkan DSL pada Racket lebih cepat, lebih murah, dan lebih mudah daripada alternatif. Misalnya, dalam pelajaran pertama buku saya, saya menunjukkan bagaimana mengembangkan bahasa baru dalam satu jam - bahkan jika Anda belum pernah menggunakan Racket. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bawah penutup setiap DSL dalam Racket, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kompiler sumber-ke-sumber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> benar-benar berfungsi </font><font style="vertical-align: inherit;">, yang mengubah notasi dan semantik DSL menjadi program Racket yang setara. Untuk alasan ini, Racket DSL tidak akan dapat berjalan secepat kode C. yang ditulis secara manual. Namun, semua alat dan pustaka Racket tersedia untuk setiap DSL. Anda kehilangan produktivitas, tetapi berulang kali menang dalam kenyamanan. Dan ketika membuat DSL nyaman dan mudah, itu menjadi pilihan realistis untuk berbagai masalah yang jauh lebih luas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, untuk menjawab kritik - tidak, DSL tidak serta-merta membutuhkan lebih banyak pekerjaan daripada perpustakaan asli. </font><font style="vertical-align: inherit;">Selain itu, seperti yang telah kita lihat, sebagai antarmuka, bahasa dapat melakukan apa yang tidak bisa dilakukan perpustakaan asli.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengapa makro? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena semua DSL dikompilasi ke dalam Racket, programmer harus menulis beberapa transformator sintaks yang mengubah notasi DSL ke Racket asli. </font><font style="vertical-align: inherit;">Konverter sintaksis ini dikenal sebagai </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">makro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bahkan, mereka dapat digambarkan sebagai ekstensi ke kompiler Racket. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem makro Racket sangat luas, elegan, dan tidak diragukan lagi adalah mutiara mahkotanya. </font><font style="vertical-align: inherit;">Banyak buku saya tentang kesenangan bekerja dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">makro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Racket. </font><font style="vertical-align: inherit;">Saya dapat menyebutkan dua fungsi luar biasa:</font></font><br><br><ol><li>  Racket    ,   <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a></i> .     .    ,      ,   Racket   ,     ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> .           ( .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">« »</a> ). <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Makro raket adalah </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">higienis</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yaitu, secara default kode yang dibuat oleh makro mempertahankan konteks leksikal dari mana makro didefinisikan. </font><font style="vertical-align: inherit;">Dalam praktiknya, ini menghilangkan sejumlah besar gerakan tidak perlu yang biasanya diperlukan untuk DSL (untuk lebih jelasnya lihat bab </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Hygiene"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah mungkin untuk mengimplementasikan DSL di, katakanlah, Python? </font></font> Tentu saja<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan, saya menulis DSL pertama saya khusus di Python - dan masih menggunakannya dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pekerjaan desain tipe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saya </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ya itu. </font><font style="vertical-align: inherit;">Satu kali sudah cukup. </font><font style="vertical-align: inherit;">Sejak itu saya menggunakan Racket.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesimpulan: kemenangan dengan YaOP </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat ini, Anda mungkin memiliki satu dari dua reaksi: </font></font><br><br><ol><li> <i>«  ,    ,    »</i> . ,          . ,    ,       .       .        .      ,       .         . <br></li><li> <i>«,   ,     c    Racket    »</i> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>  ,     -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Riposte</a> , —         (  ): <br><br><blockquote> [ ]     -  Racket. ,  ,    -     …             : «     API  ,   ?»  : «  Riposte».  ,   ,  [DSL],   ,   .    «» Racket.   <b> DSL  ,   </b> . </blockquote></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di akhir artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Kenapa Racket? </font><font style="vertical-align: inherit;">Kenapa Tertidur? ” </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mengatakan bahwa bahasa Lisp "memberi Anda kesempatan untuk mengeluarkan potensi Anda sebagai seorang programmer dan pemikir dan dengan demikian meningkatkan harapan Anda tentang apa yang dapat Anda capai." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOP menawarkan kesempatan yang sama: untuk meningkatkan harapan kami mengenai apa yang bisa dilakukan oleh bahasa pemrograman untuk kami. </font><font style="vertical-align: inherit;">Bahasa bukan kotak hitam. </font><font style="vertical-align: inherit;">Ini adalah antarmuka yang bisa kita desain. </font><font style="vertical-align: inherit;">Pada saat yang sama, kami membuka kemungkinan baru untuk apa yang dapat dilakukan dengan bantuan program. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda dapat menemukan teknik pemrograman terbaik, gunakan itu. </font><font style="vertical-align: inherit;">Sekarang saya memiliki OOP dan Racket, saya tidak akan pernah kembali.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bacaan lebih lanjut </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">« Racket»</a>   ( ).       .    —    ,     Racket     . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> Racket 2019</a> .    Racket     :   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">« Racket»</a> ( )   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«  »</a> (  Racket). <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«   Racket:  »</a>  .  ,   —     ,      «» ( ),     ,      . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«   Racket»</a>  .  —   Racket (   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   ).           DSL   DSL    . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> DSL,   Racket,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445822/">https://habr.com/ru/post/id445822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445806/index.html">Bagaimana kecerdasan buatan mengubah ilmu pengetahuan</a></li>
<li><a href="../id445808/index.html">Kami membenci dan memburu: kehidupan berbahaya seorang cracker virus yang membuat musuh yang kuat</a></li>
<li><a href="../id445814/index.html">Bagaimana robot pengiriman telah mengubah kebiasaan kuliner siswa Amerika</a></li>
<li><a href="../id445816/index.html">Bagaimana kami melihat rendering server dan apa yang terjadi</a></li>
<li><a href="../id445820/index.html">MVCC-3. Versi baris</a></li>
<li><a href="../id445824/index.html">Pembuatan Kode di Dart. Bagian 1. Dasar-dasar</a></li>
<li><a href="../id445826/index.html">Kami berjalan keliling kota dengan bijak - 2: keliling kota dalam lingkaran menggunakan algoritma genetika</a></li>
<li><a href="../id445828/index.html">Spektrum matahari Cina</a></li>
<li><a href="../id445832/index.html">Radiasi: pembunuh tak terlihat dan putri-putrinya atau sedikit tentang radon</a></li>
<li><a href="../id445834/index.html">Mengembangkan keterampilan menggunakan pengelompokan dan visualisasi data dalam Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>