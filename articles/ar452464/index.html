<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍⚖️ 🤽🏽 🍞 إذا كان مشروعك هو "مسرح" ، فاستخدم الممثلين 🤘🏻 🧘🏿 💠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="هناك قصة حول تجربة استخدام Actor Model في مشروع واحد مثير للاهتمام لتطوير نظام تحكم تلقائي للمسرح. أدناه سوف اقول انطباعاتي ، لا أكثر من ذلك. 


 منذ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>إذا كان مشروعك هو "مسرح" ، فاستخدم الممثلين</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452464/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  هناك قصة حول تجربة استخدام Actor Model في مشروع واحد مثير للاهتمام لتطوير نظام تحكم تلقائي للمسرح.  أدناه سوف اقول انطباعاتي ، لا أكثر من ذلك. </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl"> منذ وقت ليس ببعيد شاركت في مهمة واحدة مثيرة: تحديث نظام التحكم الآلي (ACS) لرافعات الرافعة ، ولكن في الواقع كان تطوير ACS جديدًا. </p><br><p style=";text-align:right;direction:rtl">  المسرح الحديث (خاصة إذا كان كبيرًا) يعد تنظيمًا شديد التعقيد.  هناك الكثير من الناس ، والآليات والأنظمة المختلفة.  أحد هذه الأنظمة هو ACS لمعالجة الرفع ووضع المشهد.  تستخدم العروض الحديثة ، مثل الأوبرا والباليه ، وسائل تقنية أكثر وأكثر عامًا بعد عام.  يتم استخدام المشهد بفعالية من قبل مديري المعرض وحتى لعب دورها المهم.  كان من الممتع اكتشاف ما يحدث خلف الستائر لأن المشاهدين العاديين يمكنهم عرض الأعمال على الساحة فقط. </p><br><p style=";text-align:right;direction:rtl">  لكن هذه مقالة تقنية ، وأريد أن أشارك تجربتي في استخدام Actor Model لكتابة نظام تحكم.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وشارك</a> انطباعاتي عن استخدام أحد أطر عمل الممثل لـ C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">SObjectizer</a> . </p><br><p style=";text-align:right;direction:rtl">  لماذا اخترنا هذا الإطار؟  لقد بحثنا في ذلك لفترة طويلة.  هناك الكثير من المقالات باللغة الروسية ، ولها وثائق رائعة والعديد من الأمثلة.  المشروع يبدو وكأنه واحد ناضجة.  لقد أوضحت نظرة مختصرة على الأمثلة أن مطوري SObjectizer يستخدمون نفس المصطلحات (حالات ، توقيت ، أحداث ، وما إلى ذلك) ولم نتوقع حدوث مشكلات كبيرة في دراستها واستخدامها.  وهناك عامل مهم آخر: فريق SObjectizer مفيد ومستعد دائمًا لمساعدتنا.  لذلك قررنا أن نحاول. </p><br><h1 id="what-were-doing" style=";text-align:right;direction:rtl">  ماذا نفعل؟ </h1><br><p style=";text-align:right;direction:rtl">  دعنا نتحدث عن هدف مشروعنا.  نظام رافعات الضرب له 62 عروة (أنابيب معدنية).  كل قرد ما دامت المرحلة بأكملها.  يتم تعليقها على الحبال بالتوازي مع الثغرات من 30-40 سم ، بدءا من الحافة الأمامية للمرحلة.  يمكن أن تثار كل أو سوط.  يتم استخدام بعضها في عرض للمشهد.  يتم تثبيت المشهد على البدن ويتم تحريكه لأعلى / لأسفل أثناء الأداء.  أوامر من المشغلين بدء الحركة.  يشبه نظام "موازنة حبل المحرك" النظام المستخدم في المصاعد في المباني السكنية.  يتم وضع المحركات خارج المسرح ، لذلك لا يراها المتفرجون.  جميع المحركات مقسمة إلى 8 مجموعات ، ولكل مجموعة 3 محولات تردد (FC).  في معظم المحركات الثلاثة يمكن استخدامها في نفس الوقت في مجموعة ، كل واحد منهم متصل بـ FC منفصل.  لذلك لدينا نظام من 62 محركا و 24 FCs ، وعلينا السيطرة على هذا النظام. </p><br><p style=";text-align:right;direction:rtl">  كانت مهمتنا هي تطوير واجهة الإنسان والآلة (HMI) للسيطرة على هذا النظام وتنفيذ خوارزميات التحكم.  يتضمن النظام ثلاث محطات تحكم.  يوجد اثنان منهم فوق المسرح ، وواحد في غرفة المحرك (يتم استخدام هذه المحطة من قبل كهربائي يعمل في الخدمة).  هناك أيضا كتل التحكم مع وحدات التحكم في غرفة المحرك.  تقوم وحدات التحكم هذه بتنفيذ أوامر التحكم ، والقيام بتعديل عرض النبض (PWM) ، أو تشغيل المحركات أو إيقاف تشغيلها ، والتحكم في موضع الضرب.  تحتوي محطتان للتحكم أعلى المرحلة على شاشات العرض ووحدات النظام وكرات التتبع كأجهزة تأشير.  محطات التحكم متصلة عبر الإيثرنت.  يتم توصيل كل محطة التحكم مع كتل التحكم بواسطة قناة RS485.  يمكن استخدام كلتا المحطتين فوق المسرح للتحكم في النظام في نفس الوقت ، ولكن يمكن أن تكون محطة واحدة فقط نشطة.  يتم اختيار المحطة النشطة من قبل المشغل ؛  المحطة الثانية ستكون سلبية ؛  المحطة الخاملة لديها قناة RS485 تعطيل. </p><br><h1 id="why-actors" style=";text-align:right;direction:rtl">  لماذا الممثلين؟ </h1><br><p style=";text-align:right;direction:rtl">  من وجهة نظر الخوارزميات ، تم بناء النظام على قمة الأحداث.  البيانات من المستشعرات ، وتصرفات المشغل ، وانتهاء الموقتات ... هذه كلها أمثلة على الأحداث.  يعمل Actor Model بشكل جيد مع مثل هذه الخوارزميات: يتعامل الممثلون مع الأحداث الواردة ويشكلون بعض الإجراءات الصادرة وفقًا لحالتهم الحالية.  تتوفر هذه الميكانيكا في SObjectizer خارج الصندوق. </p><br><p style=";text-align:right;direction:rtl">  المبادئ الأساسية لمثل هذه الأنظمة هي: الفاعلون يتفاعلون عبر رسائل غير متزامنة ، والجهات الفاعلة لديها حالات وتتحول من حالة إلى أخرى ، فقط الرسائل التي لها معنى للحالة الحالية. </p><br><p style=";text-align:right;direction:rtl">  من المثير للاهتمام أن يتم فصل الممثلين عن خيوط العمل في SObjectizer.  هذا يعني أنه يمكنك تنفيذ وتصحيح الجهات الفاعلة الخاصة بك أولاً وبعد ذلك فقط يمكنك تحديد مؤشر ترابط العامل الذي سيتم استخدامه لكل ممثل.  هناك "المرسلون" الذين يقومون بتنفيذ العديد من السياسات المتعلقة بالسلسلة.  على سبيل المثال ، يوجد المرسل الذي يوفر سلسلة عمليات منفصلة لكل ممثل ؛  يوجد مرسل تجمع مؤشرات ترابط يوفر تجمع ذو حجم ثابت من مؤشرات ترابط العامل؛  هناك المرسل الذي يعمل جميع الجهات الفاعلة على نفس الموضوع. </p><br><p style=";text-align:right;direction:rtl">  يوفر وجود المرسلين طريقة مرنة للغاية لضبط نظام فاعل لتلبية احتياجاتنا.  يمكننا تجميع بعض الجهات الفاعلة للعمل على نفس السياق.  يمكننا تغيير نوع المرسل فقط بسطر واحد من الكود.  يقول مطورو SObjectizer أن كتابة مرسل مخصص ليست مهمة معقدة.  ولكن لم تكن هناك حاجة لكتابة المرسل الخاص بنا في هذا المشروع ؛  تم العثور على كل ما نحتاجه في SObjectizer. </p><br><p style=";text-align:right;direction:rtl">  ميزة أخرى مثيرة للاهتمام هي تعاون الجهات الفاعلة.  التعاون عبارة عن مجموعة من الجهات الفاعلة التي يمكن أن توجد إذا وفقط إذا بدأت جميع الجهات الفاعلة بنجاح.  لا يمكن بدء التعاون إذا فشل واحد من ممثليها على الأقل في البدء.  يبدو أن هناك تشابه بين تعاون SObjectizer والقرون من Kubernetes ، ولكن يبدو أيضًا أن تعاون SObjectizer ظهر في وقت سابق ... </p><br><p style=";text-align:right;direction:rtl">  عند إنشاء ممثل ، تتم إضافته إلى التعاون (يمكن أن يحتوي التعاون على ممثل واحد فقط) ويكون مرتبطًا ببعض المرسل.  من السهل إنشاء تعاونيات وممثلين ديناميكيين ، ويقول مطورو SObjectizer إنها عملية رخيصة إلى حد ما. </p><br><p style=";text-align:right;direction:rtl">  تتفاعل جميع الجهات الفاعلة مع بعضها البعض عبر "مربعات الرسائل" (mbox).  إنه مفهوم SObjectizer آخر مثير للاهتمام وقوي.  يوفر طريقة مرنة لمعالجة الرسائل. </p><br><p style=";text-align:right;direction:rtl">  في البداية ، يمكن أن يكون هناك أكثر من جهاز استقبال للرسائل خلف mbox.  انها مفيدة جدا.  على سبيل المثال ، يمكن أن يكون هناك mbox يُستخدم بواسطة أجهزة الاستشعار لنشر بيانات جديدة.  يمكن للجهات الفاعلة إنشاء اشتراكات لهذا mbox ، وسيتلقى الممثلون المشتركون البيانات التي يريدونها.  هذا يسمح بالعمل بأسلوب "نشر / اشتراك". </p><br><p style=";text-align:right;direction:rtl">  في الثانية ، يتصور مطورو SObjectizer إمكانية إنشاء mbox المخصص.  من السهل نسبيًا إنشاء mbox مخصص مع معالجة خاصة للرسائل الواردة (مثل التصفية أو الانتشار بين عدة مشتركين استنادًا إلى محتوى الرسالة). </p><br><p style=";text-align:right;direction:rtl">  يوجد أيضًا mbox شخصي لكل ممثل ويمكن للجهات الفاعلة تمرير إشارة إلى ذلك mbox في الرسائل إلى الجهات الفاعلة الأخرى (التي تسمح بالرد مباشرة على ممثل معين). </p><br><p style=";text-align:right;direction:rtl">  في مشروعنا ، نقوم بتقسيم جميع الكائنات الخاضعة للرقابة إلى ثماني مجموعات (مجموعة واحدة لكل مربع تحكم).  تم إنشاء ثلاثة مؤشرات ترابط تابعة لكل مجموعة (نظرًا لأن ثلاثة محركات فقط يمكنها العمل في نفس الوقت).  لقد سمح لنا بالحصول على الاستقلال بين مجموعات المحركات.  كما سمح للعمل بشكل غير متزامن مع محركات داخل كل مجموعة. </p><br><p style=";text-align:right;direction:rtl">  من الضروري الإشارة إلى أن SObjectizer-5 لا يوجد لديه آليات للتفاعل بين الشبكات و / و.  هذا قرار واع لمطوري SObjectizer ؛  أرادوا جعل SObjectizer خفيفة الوزن قدر الإمكان.  علاوة على ذلك ، كان هناك دعم شفاف للشبكات في بعض الإصدارات السابقة من SObjectizer ولكن تمت إزالته.  لم يزعجنا ذلك لأن آلية التواصل تعتمد بشكل كبير على المهمة والبروتوكولات المستخدمة وغيرها من الشروط.  لا يوجد حل عالمي واحد لجميع الحالات. </p><br><p style=";text-align:right;direction:rtl">  في حالتنا ، استخدمنا مكتبة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">libuniset2</a> القديمة الخاصة بنا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">للاتصالات والشبكات</a> .  نتيجة لذلك ، يدعم libuniset2 الاتصالات مع أجهزة الاستشعار وكتل التحكم ، ويدعم SObjectizer الجهات الفاعلة والتفاعلات بين العناصر الفاعلة داخل عملية واحدة. </p><br><p style=";text-align:right;direction:rtl">  كما قلت في وقت سابق هناك 62 محركات.  يمكن توصيل كل محرك بـ FC (محول التردد) ؛  يمكن تحديد إحداثيات الوجهة للبطين المقابل ؛  يمكن أيضا تحديد سرعة حركة البطين.  وكإضافة إلى ذلك ، يحتوي كل محرك على الحالات التالية: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  جاهز للعمل </li><li style=";text-align:right;direction:rtl">  اتصال. </li><li style=";text-align:right;direction:rtl">  العمل. </li><li style=";text-align:right;direction:rtl">  عطل. </li><li style=";text-align:right;direction:rtl">  الاتصال (حالة انتقالية) ؛ </li><li style=";text-align:right;direction:rtl">  قطع الاتصال (حالة انتقالية) ؛ </li></ul><br><p style=";text-align:right;direction:rtl"> يتم تمثيل كل محرك في النظام بواسطة ممثل يقوم بتنفيذ الانتقال بين الحالات ، والتعامل مع البيانات من أجهزة الاستشعار وأوامر الإصدار.  ليس من الصعب إنشاء ممثل في SObjectizer: فقط <code>so_5::agent_t</code> من <code>so_5::agent_t</code> type.  يجب أن تكون الوسيطة الأولى <code>context_t</code> الفاعل من النوع <code>context_t</code> ، ويمكن تعريف جميع الوسائط الأخرى كما يريد المطور. </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); ... }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لن أعرض الوصف التفصيلي للفصول والأساليب لأنه ليس تعليميًا.  أريد فقط أن أوضح مدى سهولة إجراء كل شيء في SObjectizer (في بضعة أسطر حرفيًا).  اسمحوا لي أن أذكرك أن SObjectizer لديه <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وثائق</a> ممتازة والعديد من الأمثلة. </p><br><h1 id="what-is-the-state-of-an-actor-what-are-we-talking-about" style=";text-align:right;direction:rtl">  ما هي "حالة" الممثل؟  عن ماذا نتحدث؟ </h1><br><p style=";text-align:right;direction:rtl">  يعد استخدام الحالات والانتقال بينها "موضوعًا أصليًا" لأنظمة التحكم.  هذا المفهوم هو جيد جدا للتعامل مع الحدث.  يتم دعم هذا المفهوم في SObjectizer على مستوى API.  يتم إعلان الدول داخل فئة الممثل: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Drive_A(); <span class="hljs-comment"><span class="hljs-comment">//  state_t st_base {this}; state_t st_disabled{ initial_substate_of{st_base}, "disabled" }; state_t st_preinit{ substate_of{st_base}, "preinit" }; state_t st_off{ substate_of{st_base}, "off" }; state_t st_connecting{ substate_of{st_base}, "connecting" }; state_t st_disconnecting{ substate_of{st_base}, "disconnecting" }; state_t st_connected{ substate_of{st_base}, "connected" }; ... }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  ومن ثم يتم تعريف معالجات الأحداث لكل ولاية.  في بعض الأحيان يكون من الضروري عمل شيء ما عند الدخول إلى الدولة أو الخروج منها.  يتم دعم هذا أيضًا في SObjectizer من خلال معالجات on_enter / on_exit.  يبدو أن مطوري SObjectizer لديهم خلفية في تطوير أنظمة التحكم. </p><br><h1 id="event-handlers" style=";text-align:right;direction:rtl">  معالجات الأحداث </h1><br><p style=";text-align:right;direction:rtl">  معالج الأحداث هو المكان الذي يتم فيه تطبيق منطق التطبيق الخاص بك.  كما قلت سابقًا ، يتم إنشاء اشتراك لمجموعة mbox معينة وحالة معينة.  إذا لم يكن للممثل أي حالات محددة صراحة ، فهو في "default_state" خاص. </p><br><p style=";text-align:right;direction:rtl">  يمكن تعريف معالجات مختلفة لنفس الحدث في حالات مختلفة.  إذا لم تحدد معالجًا لحدث ما ، فسيتم تجاهل هذا الحدث (لن يعرفه أحد الممثلين). </p><br><p style=";text-align:right;direction:rtl">  يوجد بناء جملة بسيط لتعريف معالجات الأحداث.  يمكنك تحديد طريقة ، وليس هناك حاجة لتحديد أنواع أو معلمات قالب إضافية.  على سبيل المثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_base) .event( &amp;Drive_A::on_get_info ) .event( &amp;Drive_A::on_control ) .event( &amp;Drive_A::off_control );</code> </pre> <br><p style=";text-align:right;direction:rtl">  إنه مثال على الاشتراك في الأحداث من mbox معين في حالة st_base.  تجدر الإشارة إلى أن st_base هي حالة أساسية لبعض الحالات الأخرى وأن هذا الاشتراك سيتم توريثه بواسطة حالات مشتقة.  يسمح هذا الأسلوب بالتخلص من النسخ واللصق لمعالجات الأحداث المماثلة في حالات مختلفة.  لكن يمكن إعادة تعريف معالج الأحداث الموروثة لحالة معينة أو يمكن تعطيل الحدث بالكامل ("تم كبحه"). </p><br><p style=";text-align:right;direction:rtl">  هناك طريقة أخرى لتعريف معالجات الأحداث وهي استخدام وظائف lambda.  إنها طريقة مريحة للغاية لأن معالجات الأحداث غالباً ما تحتوي فقط على سطر أو اثنين من التعليمات البرمجية: إرسال شيء إلى مكان ما أو تغيير الحالة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_disconnecting) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_disconnected_t</span></span>&amp; m) { ... st_off.activate(); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&amp; m ) { ... st_protection.activate(); });</code> </pre> <br><p style=";text-align:right;direction:rtl">  يبدو بناء الجملة معقدًا في البداية ، لكنه يصبح مألوفًا بعد بضعة أيام من الترميز النشط ويمكنك حتى البدء في الإعجاب به.  فذلك لأن المنطق الكامل لبعض الممثل يمكن أن يكون موجزا ووضعه في شاشة واحدة.  في المثال الموضح أعلاه ، هناك انتقالات من st_disconnected إلى st_off أو st_protection.  هذا الكود سهل القراءة. </p><br><p style=";text-align:right;direction:rtl">  راجع للشغل ، للحالات المباشرة ، حيث يكون انتقال الحالة ضروريًا فقط ، يوجد بناء جملة خاص: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mbox = drv-&gt;so_mbox(); st_off .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_connected_t</span></span>&gt;(mbox, st_connected) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_limit_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_t</span></span>&gt;(mbox, st_on);</code> </pre> <br><h1 id="the-control" style=";text-align:right;direction:rtl">  السيطرة </h1><br><p style=";text-align:right;direction:rtl">  كيف يتم تنظيم السيطرة؟  كما ذكرنا أعلاه ، يوجد محطتان للتحكم في حركة الضربات.  تحتوي كل محطة تحكم على شاشة وجهاز تأشير (كرة التتبع) وجهاز ضبط السرعة (ونحن لا نعول جهاز كمبيوتر داخل المحطة وبعض الملحقات الإضافية). </p><br><p style=";text-align:right;direction:rtl">  هناك وضعان للتحكم: اليدوي و "وضع السيناريو".  ستتم مناقشة "وضع السيناريو" لاحقًا ، والآن دعنا نتحدث عن الوضع اليدوي.  في هذا الوضع ، يختار المشغل عنصرًا ، ويقوم بإعداده للحركة (يربط المحرك بـ FC) ، ويحدد العلامة المستهدفة للضربة ، وعندما يتم ضبط السرعة فوق الصفر ، يبدأ الضرب في التحرك. </p><br><p style=";text-align:right;direction:rtl">  جهاز ضبط السرعة هو ملحق مادي على شكل "مقياس قوة ذو مقبض" ، ولكن يوجد أيضًا مقياس افتراضي معروض على شاشة المحطة.  كلما تم تشغيله ، كلما زادت سرعة الحركة.  الحد الأقصى للسرعة محدود عند 1.5 متر في الثانية.  جهاز ضبط السرعة هو واحد لجميع الضربات.  هذا يعني أن جميع الضربات المختارة تتحرك بنفس السرعة.  يمكن أن تتحرك العربات في اتجاهين متعاكسين (يعتمد ذلك على اختيار المشغل).  من الواضح أنه من الصعب على الإنسان التحكم في أكثر من بضع ضربات.  بسبب ذلك ، يتم التعامل مع مجموعات صغيرة فقط من الضربات في الوضع اليدوي.  يمكن للمشغلين التحكم في الضربات من محطتي تحكم في نفس الوقت.  لذلك هناك محدد سرعة منفصل لكل محطة. </p><br><p style=";text-align:right;direction:rtl">  من وجهة نظر التطبيق ، لا يوجد منطق محدد في الوضع اليدوي.  ينتقل أمر "connect engine" من الواجهة الرسومية ، ويتم تحويله إلى رسالة مقابلة إلى ممثل ، ثم تتم معالجته بواسطة هذا الممثل.  ينتقل الممثل من حالة "إيقاف التشغيل" إلى "اتصال" ، ثم إلى حالة "متصل".  تحدث أشياء مماثلة مع أوامر لتحديد موضع الضبط وتحديد سرعة الحركة.  يتم تمرير كل هذه الأوامر إلى ممثل في شكل رسائل.  ولكن تجدر الإشارة إلى أن "الواجهة الرسومية" و "عملية التحكم" هما عمليتان منفصلتان ويستخدم libuniset2 في IPC. </p><br><h1 id="the-scenario-mode-are-there-actors-again" style=";text-align:right;direction:rtl">  وضع السيناريو (هل هناك ممثلون مرة أخرى؟) </h1><br><p style=";text-align:right;direction:rtl">  في الممارسة العملية ، يتم استخدام الوضع اليدوي فقط لحالات بسيطة للغاية أو أثناء البروفات.  وضع التحكم الرئيسي هو "وضع السيناريو".  في هذا الوضع ، يتم نقل كل عنصر إلى وضعية معينة بسرعة خاصة وفقًا لإعدادات السيناريو.  يتوفر أمران بسيطان لمشغل في هذا الوضع: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تحضير (يتم توصيل مجموعة من المحركات بـ FC) ؛ </li><li style=";text-align:right;direction:rtl">  اذهب (حركة المجموعة تبدأ). </li></ul><br><p style=";text-align:right;direction:rtl">  سيناريو كله ينقسم إلى "جداول أعمال".  يصف "جدول الأعمال" حركة واحدة لمجموعة من الضربات.  وهذا يعني أن "جدول الأعمال" يتضمن بعض اللطخات ويحتوي على وجهات مستهدفة وسرعات لها.  في الواقع ، يتكون السيناريو من الأفعال ، وتتألف الأفعال من صور ، وتتكون الصورة من جداول الأعمال ، ويتألف جدول الأعمال من أهداف للعبة.  لكن من وجهة نظر عنصر التحكم ، لا يهم ذلك ، لأن جداول الأعمال هي فقط التي تحتوي على المعلمات الدقيقة لحركة الضرب. </p><br><p style=";text-align:right;direction:rtl">  ممثل نموذج يناسب هذه القضية تماما.  لقد طورنا "لاعب سيناريو" يولد مجموعة من الممثلين الخاصين ويبدأهم.  لقد قمنا بتطوير نوعين من الجهات الفاعلة: الجهات الفاعلة المنفذون (يتحكمون في حركة الضربات) والممثلين المنسقين (يقومون بتوزيع المهام بين المنفذين).  يتم إنشاء المنفذين عند الطلب: عندما لا يكون هناك مدراء تنفيذيين مجانيين ، سيتم إنشاء منفذ جديد.  منسق يدير مجموعة من المسؤولين التنفيذيين المتاحة.  نتيجة لذلك ، يبدو عنصر التحكم كما يلي تقريبًا: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  مشغل يحمل سيناريو ؛ </li><li style=";text-align:right;direction:rtl">  "بالتمرير" حتى جدول الأعمال المطلوب ؛ </li><li style=";text-align:right;direction:rtl">  يضغط على زر "الاستعداد" في الوقت المناسب.  في تلك اللحظة يتم إرسال رسالة إلى المنسق.  تحتوي هذه الرسالة على بيانات لكل قاتل من جدول الأعمال ؛ </li><li style=";text-align:right;direction:rtl">  يقوم المنسق بمراجعة مجموعة من المنفذين ويوزع المهام بين المنفذين المجانيين (يتم إنشاء منفذين جدد ، إذا لزم الأمر) ؛ </li><li style=";text-align:right;direction:rtl">  يستقبل كل منفّذ مهمة وينفذ إجراءات التحضير (يربط محركًا بـ FC ، ثم ينتظر أمر "go") ؛ </li><li style=";text-align:right;direction:rtl">  يضغط المشغل على زر "go" في اللحظة المناسبة ؛ </li><li style=";text-align:right;direction:rtl">  ينتقل الأمر "go" إلى المنسق ، ويقوم بتوزيع الأمر بين جميع المسؤولين التنفيذيين قيد الاستخدام حاليًا. </li></ul><br><p style=";text-align:right;direction:rtl">  هناك بعض المعلمات الإضافية في جداول الأعمال.  مثل "ابدأ الحركة فقط بعد تأخير N ثانية" أو "ابدأ الحركة فقط بعد أمر إضافي من مشغل".  ولهذا السبب ، فإن قائمة الدول للمنفذ طويلة جدًا: "جاهز للأمر التالي" ، "جاهز للحركة" ، "تأخر الحركة" ، "في انتظار أمر المشغل" ، "نقل" ، "مكتمل" ، "الفشل". </p><br><p style=";text-align:right;direction:rtl">  عندما يصل الضرب بنجاح إلى العلامة المستهدفة (أو يكون هناك عطل) ، يقوم المسؤول التنفيذي بإبلاغ المنسق عن إتمام المهمة.  يرد المنسق بأمر لإيقاف تشغيل المحرك (إذا لم يشارك البطين في جدول الأعمال بعد الآن) أو يرسل مهمة جديدة إلى المنفذ.  يقوم المشغّل بإيقاف تشغيل المحرك ويتحول إلى حالة "انتظار" أو يبدأ في معالجة الأمر الجديد. </p><br><p style=";text-align:right;direction:rtl">  نظرًا لأن SObjectizer يحتوي على واجهة برمجة تطبيقات (API) مدروسة ومناسبة تمامًا للعمل مع الحالات ، فقد تبين أن رمز التنفيذ هو موجز للغاية.  على سبيل المثال ، يتم وصف التأخير قبل الحركة بسطر من التعليمات البرمجية فقط: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">st_delay.time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{target-&gt;delay()}, st_moving ); st_delay.activate(); ...</code> </pre> <br><p style=";text-align:right;direction:rtl">  تحدد طريقة <code>time_limit</code> مقدار الوقت للبقاء في الولاية والحالة التي ينبغي تنشيطها بعد ذلك ( <code>st_moving</code> في هذا المثال). </p><br><h1 id="protection-actors" style=";text-align:right;direction:rtl">  الجهات الفاعلة الحماية </h1><br><p style=";text-align:right;direction:rtl">  بالتأكيد ، يمكن أن يحدث الفشل.  هناك متطلبات لمعالجة هذه الإخفاقات بشكل صحيح.  تستخدم الجهات الفاعلة لهذه المهام أيضا.  دعونا نلقي نظرة على بعض الأمثلة: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  حماية التيار الزائد. </li><li style=";text-align:right;direction:rtl">  الحماية من عطل المستشعر ؛ </li><li style=";text-align:right;direction:rtl">  الحماية من الحركة في الاتجاه المعاكس (يمكن أن يحدث ذلك إذا حدث خطأ ما في أجهزة الاستشعار أو المشغلات) ؛ </li><li style=";text-align:right;direction:rtl">  الحماية من الحركة التلقائية (بدون أمر) ؛ </li><li style=";text-align:right;direction:rtl">  مراقبة تنفيذ الأوامر (يجب فحص حركة الضرب). </li></ul><br><p style=";text-align:right;direction:rtl">  يمكننا أن نرى أن كل هذه الحالات مكتفية ذاتيا ، لكن يجب السيطرة عليها معًا ، في نفس الوقت.  وهذا يعني أن أي فشل يمكن أن يحدث.  لكن كل عملية تحقق لها منطقها: في بعض الأحيان يكون من الضروري التحقق من مهلة ، وأحيانًا تكون هناك حاجة لتحليل بعض القيم السابقة من جهاز استشعار.  بسبب ذلك ، يتم تنفيذ الحماية في شكل الجهات الفاعلة الصغيرة.  تضاف هذه الجهات الفاعلة إلى التعاون مع الممثل الرئيسي الذي ينفذ منطق التحكم.  يتيح هذا النهج إضافة سهلة لحالات الحماية الجديدة: فقط أضف ممثلًا آخر للحماية إلى التعاون.  عادة ما يكون كود هذا الممثل موجزا وسهل الفهم ، لأنه ينفذ وظيفة واحدة فقط. </p><br><p style=";text-align:right;direction:rtl">  الجهات الفاعلة حامي لديها أيضا العديد من الدول.  عادة ، يتم تشغيلها عند تشغيل المحرك أو عندما يبدأ الضرب في حركته.  عندما يكتشف الحامي عطلًا / عطلًا ، فإنه ينشر إشعارًا (مع رمز الحماية وبعض التفاصيل الإضافية في الداخل).  يتفاعل الممثل الرئيسي مع هذا الإشعار ويقوم بتنفيذ الإجراءات اللازمة (مثل إيقاف تشغيل المحرك والتبديل إلى الحالة المحمية). </p><br><h1 id="as-the-conclusion" style=";text-align:right;direction:rtl">  كما الاستنتاج ... </h1><br><p style=";text-align:right;direction:rtl">  ... هذه المقالة ليست انفراجة بالطبع.  يتم استخدام نموذج ممثل في أنظمة مختلفة متعددة لفترة طويلة جدا.  ولكن كانت تجربتي الأولى في استخدام Actor Model لبناء نظام تحكم تلقائي في مشروع صغير إلى حد ما.  وقد تحولت هذه التجربة إلى نجاح كبير.  آمل أن أكون قد أظهرت أن الجهات الفاعلة مناسبة تمامًا لخوارزميات التحكم: هناك أماكن للجهات الفاعلة حرفيًا في كل مكان. </p><br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لقد</a> طبقنا شيئًا مماثلاً في المشروعات السابقة (أقصد الحالات ، وتبادل الرسائل ، وإدارة خيوط العمل ، وما إلى ذلك) ، لكنه لم يكن نهجًا موحدًا.  باستخدام SObjectizer ، حصلنا على أداة صغيرة وخفيفة الوزن تحل الكثير من المشكلات.  لم نعد بحاجة إلى (صراحة) استخدام آليات التزامن ذات المستوى المنخفض (مثل المزامنة) ، ولا توجد إدارة خيطية يدوية ، ولا توجد رسائل توضيحية مكتوبة بخط اليد.  يتم توفير كل هذه من خلال الإطار ، متصلة منطقيا ويعبر عنها في شكل API مريحة ، ولكنك لا تفقد السيطرة على التفاصيل.  لذلك كانت تجربة مثيرة.  إذا كنت لا تزال موضع شك ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">فأوصيك بإلقاء</a> نظرة على Actor Model و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">SObjectizer</a> بشكل خاص.  إنه يترك عواطف إيجابية. </p><br><p style=";text-align:right;direction:rtl">  ممثل النموذج يعمل حقا!  خاصة في المسرح. </p><br><p style=";text-align:right;direction:rtl">  المقالة الأصلية باللغة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الروسية</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar452464/">https://habr.com/ru/post/ar452464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar452454/index.html">تسجيل الدخول إلى Azure DevOps باستخدام بيانات اعتماد GitHub الخاصة بك</a></li>
<li><a href="../ar452456/index.html">تمكن Microsoft Kaizala السكك الحديدية الهندية من توصيل موظفيها الثلاثة ملايين بخدمة الرعاية الصحية</a></li>
<li><a href="../ar452458/index.html">مشاهدة الكلاب في الحياة الحقيقية ، أو نقاط الضعف الخطيرة في ACS</a></li>
<li><a href="../ar452460/index.html">تقديم ويندوز الطرفية</a></li>
<li><a href="../ar452462/index.html">حول OOP</a></li>
<li><a href="../ar452466/index.html">لوحة مفاتيح برايل</a></li>
<li><a href="../ar452468/index.html">"إذا كنت بحاجة لقتل شخص ما ، فأنت أتيت إلى العنوان"</a></li>
<li><a href="../ar452474/index.html">تحليل المويجات. الجزء 2</a></li>
<li><a href="../ar452478/index.html">إنشاء الجداول في نظام تصميم Figma وتنفيذها في Storybook (React)</a></li>
<li><a href="../ar452480/index.html">Phoenix LiveView: عندما لم تعد بحاجة إلى JavaScript *</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>