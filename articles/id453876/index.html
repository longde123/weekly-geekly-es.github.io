<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàÅ ‚úçüèª üë®üèæ‚Äçüç≥ Seperti di Yandex.Practicum, desync front-end menang: angka akrobatik dengan Redux-Saga, postMessage dan Jupyter üèáüèª üé∏ ü§úüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nama saya Artyom Nesmiyanov, saya adalah pengembang penuh-tumpukan di Yandex.Practicum, saya terutama berurusan dengan frontend. Kami percaya bahwa ad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seperti di Yandex.Practicum, desync front-end menang: angka akrobatik dengan Redux-Saga, postMessage dan Jupyter</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/453876/">  Nama saya Artyom Nesmiyanov, saya adalah pengembang penuh-tumpukan di Yandex.Practicum, saya terutama berurusan dengan frontend.  Kami percaya bahwa adalah mungkin dan perlu untuk mempelajari pemrograman, analisis data, dan kerajinan digital lainnya dengan senang hati.  Dan mulailah belajar, dan lanjutkan.  Setiap pengembang yang tidak menyerah pada dirinya sendiri selalu "melanjutkan".  Begitu juga kita.  Oleh karena itu, kami menganggap tugas kerja sebagai format pembelajaran.  Dan salah satu yang baru-baru ini membantu saya dan teman-teman untuk lebih memahami ke arah mana untuk mengembangkan tumpukan frontend kami. <br><br><img src="https://habrastorage.org/webt/u2/uh/nx/u2uhnxzsc0hv3v7clkqskbzwnc0.png"><br><br><h3>  Terbuat dari apa dan dari apa bengkel itu </h3><br>  Tim pengembangan kami sangat kompak.  Hanya ada dua orang di backend, di front-end - empat, mengingat saya, setumpuk penuh.  Dari waktu ke waktu, orang-orang dari Yandex.Tutorial bergabung dengan kami dalam penguatan.  Kami mengerjakan Scrum dengan sprint dua minggu. <br><a name="habracut"></a><br>  Frontend kami didasarkan pada React.js bersama dengan Redux / Redux-Saga, kami menggunakan Express untuk berkomunikasi dengan backend.  Bagian backend stack adalah dalam Python (lebih tepatnya, Django), database adalah PostgreSQL, dan untuk beberapa tugas, Redis.  Menggunakan Redux, kami menyimpan penyimpanan informasi, mengirim tindakan yang diproses oleh Redux dan Redux-Saga.  Semua efek samping, seperti permintaan server, panggilan ke Yandex.Metrica dan arahan ulang, diproses hanya di Redux-Saga.  Dan semua modifikasi data terjadi pada reduksi Redux. <br><br><h3>  Bagaimana tidak mengabaikan log di iframe Anda </h3><br>  Sekarang di platform kami, pelatihan terbuka dalam tiga profesi: pengembang front-end, pengembang web, analis data.  Dan kami secara aktif menggergaji alat untuk setiap kursus. <br><br>  Untuk kursus enam bulan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analis Data</a> ", kami membuat simulator interaktif, tempat kami mengajarkan pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cara menggunakan Jupyter Notebook</a> .  Ini adalah shell keren untuk komputasi interaktif, yang sangat disukai oleh para ilmuwan data.  Semua operasi di lingkungan dilakukan di dalam notebook, tetapi dengan cara yang sederhana - notebook (seperti yang akan saya sebut nanti). <br><br>  Pengalaman diminta, dan kami yakin: adalah penting bahwa tugas-tugas pelatihan mendekati kenyataan.  Termasuk dalam hal lingkungan kerja.  Oleh karena itu, perlu dipastikan bahwa di dalam pelajaran semua kode dapat ditulis, dijalankan, dan diperiksa tepat di buku catatan. <br><br>  Tidak ada kesulitan dengan implementasi dasar.  Notebook itu sendiri diselesaikan dalam iframe terpisah, logika untuk memeriksanya ditentukan di backend. <br><br><img src="https://habrastorage.org/webt/2z/_9/iy/2z_9iyuj7pmha0ielvj4evuyhic.png"><br>  <i>Buku catatan siswa itu sendiri (di sebelah kanan) hanyalah iframe yang URL-nya mengarah ke buku catatan khusus di JupyterHub.</i> <br><br>  Dalam perkiraan pertama, semuanya bekerja tanpa hambatan, tanpa hambatan.  Namun, selama pengujian, absurditas keluar.  Misalnya, Anda dijamin untuk mengarahkan versi kode yang benar ke dalam buku catatan, namun, setelah mengklik tombol "Tugas uji", server menjawab bahwa jawabannya seharusnya salah.  Dan mengapa - sebuah misteri. <br><br>  Nah, apa yang terjadi, kami menyadari pada hari yang sama ketika kami menemukan bug: ternyata solusi yang tidak terbang adalah yang sekarang, solusi hanya didorong ke dalam bentuk Notebook Jupyter, tetapi yang sebelumnya telah dihapus.  Notebook itu sendiri tidak punya waktu untuk bertahan, dan kami memperlambat backend sehingga memeriksa tugas di dalamnya.  Apa, tentu saja, dia tidak bisa lakukan. <br><br>  Kami harus menyingkirkan rassinhron antara menyimpan notebook dan mengirim permintaan ke server untuk memeriksanya.  Tangkapannya adalah bahwa itu perlu untuk membuat iframe dari notebook berkomunikasi dengan jendela induk, yaitu, dengan frontend di mana pelajaran secara keseluruhan berputar.  Tentu saja, tidak mungkin untuk meneruskan acara apa pun di antara mereka secara langsung: mereka hidup di domain yang berbeda. <br><br>  Mencari solusi, saya menemukan bahwa Jupyter Notebook memungkinkan plugin-nya dihubungkan.  Ada objek Jupiter - notebook - yang dapat digunakan untuk beroperasi.  Bekerja dengannya melibatkan berbagai peristiwa, termasuk pelestarian notebook, serta panggilan tindakan yang sesuai.  Setelah mengetahui bagian dalam Jupyter (saya harus: tidak ada dokumentasi normal untuk itu), saya dan orang-orang melakukannya - kami membangun plug-in kami sendiri untuk itu dan, menggunakan mekanisme postMessage, mencapai pekerjaan terkoordinasi dari unsur-unsur dari mana pelajaran Lokakarya disusun. <br><br>  Kami menyusun solusi dengan mempertimbangkan fakta bahwa tumpukan kami awalnya mencakup Redux-Saga yang telah disebutkan - sederhananya, middleware atas Redux, yang memungkinkan untuk bekerja lebih fleksibel dengan efek samping.  Misalnya, menyimpan buku catatan adalah sesuatu seperti efek samping ini.  Kami mengirim sesuatu ke backend, menunggu sesuatu, mendapatkan sesuatu.  Semua gerakan ini diproses di dalam Redux-Saga: ia melempar acara ke frontend, mendiktekan kepadanya bagaimana menampilkan apa yang ada di UI. <br><br>  Apa hasilnya?  PostMessage dibuat dan dikirim ke iframe dengan buku catatan.  Ketika iframe melihat sesuatu telah datang dari luar, ia mem-parsing string yang diterima.  Menyadari bahwa ia perlu menyimpan notebook itu, ia melakukan tindakan ini dan, pada gilirannya, mengirim respons postMessage tentang eksekusi permintaan. <br><br>  Ketika kami mengklik tombol "Tugas uji", acara yang sesuai dikirim ke Redux Store: "Dulu, kami pergi untuk diperiksa."  Redux-Saga melihat aksi tiba dan melakukan postMessage dalam iframe.  Sekarang dia sedang menunggu iframe untuk memberikan jawaban.  Sementara itu, siswa kami melihat indikator unduhan pada tombol "Periksa tugas" dan memahami bahwa simulator tidak hang, tetapi "berpikir".  Dan hanya ketika postMessage kembali mengatakan bahwa save sudah selesai, Redux-Saga terus bekerja dan mengirim permintaan ke backend.  Di server, tugas diperiksa - solusi yang tepat atau tidak, jika kesalahan dibuat, lalu yang mana, dll., Dan informasi ini disimpan dengan rapi di Redux Store.  Dan dari sana, skrip front-end menariknya ke antarmuka pelajaran. <br><br>  Berikut adalah diagram yang keluar pada akhirnya: <br><br><img src="https://habrastorage.org/webt/ks/gc/eu/ksgceup6hokoh9jtvqoajegbjfc.png"><br><br>  <i>(1) Kami menekan tombol "Periksa tugas" (Periksa) ‚Üí (2) Kami mengirim tindakan CHECK_NOTEBOOK_REQUEST ‚Üí (3) Kami mengirim tindakan cek ‚Üí (2) Kami mengirim tindakan SAVE_NOTEBOOK_REQUEST ‚Üí (3) Kami menangkap tindakan dan mengirim post Pesan di iframe ‚Üí simpan acara (4) Terima pesan ‚Üí (5) Notebook disimpan ‚Üí (4) Terima acara dari Jupyter API bahwa notebook telah disimpan dan kirim postMessage disimpan notebook ‚Üí (1) Terima acara ‚Üí (2) Kirim tindakan SAVE_NOTEBOOK_SUCCESS ‚Üí (3) Kami menangkap aksi dan kirim permintaan untuk memeriksa buku catatan ‚Üí (6) ‚Üí (7) Periksa apakah buku catatan ini ada di database ‚Üí (8) ‚Üí (7) Cari kode buku catatan ‚Üí (5) Kembalikan kode ‚Üí (7) Jalankan kode periksa ‚Üí (9) ) ‚Üí (7) Kami mendapat potongan</i>  <i>tat cek ‚Üí (6) ‚Üí (3) kami kirimkan tindakan CHECK_NOTEBOOK_SUCCESS ‚Üí (2) turun untuk memverifikasi respon sisi ‚Üí (1) Gambarkan hasil</i> <br><br>  Mari kita lihat bagaimana semua ini bekerja dalam konteks kode. <br><br>  Kami memiliki trainer_type_jupyter.jsx di ujung depan - skrip halaman tempat buku catatan kami dibuat. <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__right-column"</span></span></span><span class="hljs-tag">&gt;</span></span> {notebookLinkIsLoading ? ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">iframe</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__jupiter-frame"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{this.onIframeRef}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{notebookLink}</span></span></span><span class="hljs-tag"> /&gt;</span></span> ) : ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Spin</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"l"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mix</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__jupiter-spin"</span></span></span><span class="hljs-tag"> /&gt;</span></span> )} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Setelah mengklik tombol "Periksa pekerjaan", metode handleCheckTasks dipanggil. <br><br><pre> <code class="xml hljs">handleCheckTasks = () =&gt; { const {checkNotebook, lesson} = this.props; checkNotebook({id: lesson.id, iframe: this.iframeRef}); };</code> </pre> <br>  Bahkan, handleCheckTasks berfungsi untuk menjalankan aksi Redux dengan parameter yang diteruskan. <br><br><pre> <code class="xml hljs">export const checkNotebook = getAsyncActionsFactory(CHECK_NOTEBOOK).request;</code> </pre> <br>  Ini adalah tindakan umum yang dirancang untuk Redux-Saga dan metode asinkron.  Di sini getAsyncActionsFactory menghasilkan tiga tindakan: <br><br>  // utils / store-helpers / async.js <br><br><pre> <code class="xml hljs">export function getAsyncActionsFactory(type) { const ASYNC_CONSTANTS = getAsyncConstants(type); return { request: payload =&gt; ({type: ASYNC_CONSTANTS.REQUEST, payload}), error: (response, request) =&gt; ({type: ASYNC_CONSTANTS.ERROR, response, request}), success: (response, request) =&gt; ({type: ASYNC_CONSTANTS.SUCCESS, response, request}), } }</code> </pre> <br>  Dengan demikian, getAsyncConstants menghasilkan tiga konstanta dari bentuk * _REQUEST, * _SUCCESS dan * _ERROR. <br><br>  Sekarang mari kita lihat bagaimana Redux-Saga kami akan menangani semua ekonomi ini: <br><br>  // trainer.saga.js <br><br><pre> <code class="xml hljs">function* watchCheckNotebook() { const watcher = createAsyncActionSagaWatcher({ type: CHECK_NOTEBOOK, apiMethod: Api.checkNotebook, preprocessRequestGenerator: function* ({id, iframe}) { yield put(trainerActions.saveNotebook({iframe})); yield take(getAsyncConstants(SAVE_NOTEBOOK).SUCCESS); return {id}; }, successHandlerGenerator: function* ({response}) { const {completed_tests: completedTests} = response; for (let id of completedTests) { yield put(trainerActions.setTaskSolved(id)); } }, errorHandlerGenerator: function* ({response: error}) { yield put(appActions.setNetworkError(error)); } }); yield watcher(); }</code> </pre> <br>  Keajaiban?  Tidak ada yang luar biasa.  Seperti yang Anda lihat, createAsyncActionSagaWatcher cukup membuat watermarker yang dapat pra-proses data masuk ke dalam tindakan, membuat permintaan di URL tertentu, mengirimkan tindakan * _REQUEST, dan mengirimkan * _SUCCESS dan * _ERROR setelah respons yang berhasil dari server.  Selain itu, tentu saja, untuk setiap opsi, penangan disediakan di dalam arloji. <br><br>  Anda mungkin memperhatikan bahwa di preprocessor data kami memanggil Redux-Saga lain, tunggu sampai selesai dengan SUKSES, dan baru kemudian terus bekerja.  Dan tentu saja, iframe tidak perlu dikirim ke server, jadi kami hanya memberikan id. <br><br>  Lihatlah lebih dekat fungsi saveNotebook: <br><br><pre> <code class="xml hljs">function* saveNotebook({payload: {iframe}}) { iframe.contentWindow.postMessage(JSON.stringify({ type: 'save-notebook' }), '*'); yield; }</code> </pre> <br>  Kami telah mencapai mekanisme paling penting dalam interaksi iframe dengan frontend - postMessage.  Fragmen kode yang diberikan mengirimkan tindakan dengan tipe save-notebook, yang diproses di dalam iframe. <br><br>  Saya sudah menyebutkan bahwa kami perlu menulis plug-in untuk Notebook Jupyter, yang akan dimuat di dalam notebook.  Plugin ini terlihat seperti ini: <br><br><pre> <code class="xml hljs">define([ 'base/js/namespace', 'base/js/events' ], function( Jupyter, events ) {...});</code> </pre><br>  Untuk membuat ekstensi seperti itu, Anda harus berurusan dengan Jupyter Notebook API itu sendiri.  Sayangnya, tidak ada dokumentasi yang jelas tentang itu.  Tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber</a> tersedia, dan saya menyelidiki mereka.  Bagus bahwa kodenya dapat dibaca di sana. <br><br>  Plugin harus diajarkan untuk berkomunikasi dengan jendela induk di bagian depan pelajaran: setelah semua, desync di antara mereka adalah penyebab bug dengan verifikasi tugas.  Pertama-tama, kami berlangganan semua pesan yang kami terima: <br><br><pre> <code class="xml hljs">window.addEventListener('message', actionListener);</code> </pre> <br>  Sekarang kami akan menyediakan pemrosesan mereka: <br><br><pre> <code class="xml hljs">function actionListener({data: eventString}) { let event = ''; try { event = JSON.parse(eventString); } catch(e) { return; } switch (event.type) { case 'save-notebook': Jupyter.actions.call('jupyter-notebook:save-notebook'); Break; ... default: break; } }</code> </pre> <br>  Semua acara yang tidak sesuai dengan format kami diabaikan dengan berani. <br><br>  Kami melihat bahwa acara simpan-buku catatan tiba kepada kami, dan kami memanggil tindakan untuk menyimpan buku catatan.  Tetap hanya untuk mengirim kembali pesan bahwa notebook telah disimpan: <br><br><pre> <code class="xml hljs">events.on('notebook_saved.Notebook', actionDispatcher); function actionDispatcher(event) { switch (event.type) { case 'select': const selectedCell = Jupyter.notebook.get_selected_cell(); dispatchEvent({ type: event.type, data: {taskId: getCellTaskId(selectedCell)} }); return; case 'notebook_saved': default: dispatchEvent({type: event.type}); } } function dispatchEvent(event) { return window.parent.postMessage( typeof event === 'string' ? event : JSON.stringify(event), '*' ); }</code> </pre><br>  Dengan kata lain, cukup kirim {type: 'notebook_saved'} ke atas.  Ini berarti notebook telah dilestarikan. <br><br>  Mari kita kembali ke komponen kita: <br><br>  //trainer_type_jupyter.jsx <br><br><pre> <code class="xml hljs">componentDidMount() { const {getNotebookLink, lesson} = this.props; getNotebookLink({id: lesson.id}); window.addEventListener('message', this.handleWindowMessage); }</code> </pre> <br>  Saat memasang komponen, kami meminta server untuk tautan ke buku catatan dan berlangganan semua tindakan yang dapat terbang kepada kami: <br><br><pre> <code class="xml hljs">handleWindowMessage = ({data: eventString}) =&gt; { const {activeTaskId, history, match: {params}, setNotebookSaved, tasks} = this.props; let event = null; try { event = JSON.parse(eventString); } catch(e) { return; } const {type, data} = event; switch (type) { case 'app_initialized': this.selectTaskCell({taskId: activeTaskId}) return; case 'notebook_saved': setNotebookSaved(); return; case 'select': { const taskId = data &amp;&amp; data.taskId; if (!taskId) { return } const task = tasks.find(({id}) =&gt; taskId === id); if (task &amp;&amp; task.status === TASK_STATUSES.DISABLED) { this.selectTaskCell({taskId: null}) return; } history.push(reversePath(urls.trainerTask, {...params, taskId})); return; } default: break; } };</code> </pre> <br>  Di sinilah pengiriman tindakan setNotebookSaved dipanggil, yang akan memungkinkan Redux-Saga untuk terus bekerja dan menyimpan notebook. <br><br><h3>  Gangguan pilihan </h3><br>  Kami mengatasi bug pelestarian notebook.  Dan segera beralih ke masalah baru.  Itu perlu untuk belajar memblokir tugas (tugas), yang belum tercapai siswa.  Dengan kata lain, itu perlu untuk menyinkronkan navigasi antara simulator interaktif kami dan Notebook Jupyter: di dalam satu pelajaran, kami memiliki satu buku catatan dengan beberapa tugas yang duduk di iframe, transisi di antaranya harus dikoordinasikan dengan perubahan pada antarmuka pelajaran secara keseluruhan.  Sebagai contoh, sehingga dengan mengklik tugas kedua di antarmuka pelajaran di buku catatan, beralih ke sel yang sesuai dengan tugas kedua terjadi.  Dan sebaliknya: jika dalam bingkai Jupyter Notebook Anda memilih sel yang dikaitkan dengan tugas ketiga, maka URL di bilah alamat browser harus segera berubah dan, dengan demikian, teks yang menyertai teori untuk tugas ketiga harus ditampilkan dalam antarmuka pelajaran. <br><br>  Ada tugas yang lebih sulit.  Faktanya adalah bahwa program pelatihan kami dirancang untuk memberikan pelajaran dan tugas yang konsisten.  Sementara itu, secara default, di notebook Jupiter, tidak ada yang mencegah pengguna membuka sel apa pun.  Dan dalam kasus kami, setiap sel adalah tugas yang terpisah.  Ternyata Anda bisa menyelesaikan tugas pertama dan ketiga, dan melewatkan yang kedua.  Risiko bagian nonlinear dari pelajaran harus dihilangkan. <br><br>  Solusinya didasarkan pada postMessage yang sama.  Hanya kami yang harus mempelajari lebih jauh tentang Jupyter Notebook API, lebih khusus lagi, tentang apa yang dapat dilakukan oleh objek Jupiter.  Dan datang dengan mekanisme untuk memeriksa tugas sel mana yang dilampirkan.  Dalam bentuknya yang paling umum, adalah sebagai berikut.  Dalam struktur notebook, sel-sel berjalan berurutan.  Mereka mungkin memiliki metadata.  Kolom "Tag" disediakan dalam metadata, dan tag hanyalah pengidentifikasi tugas di dalam pelajaran.  Selain itu, menggunakan sel penandaan, Anda dapat menentukan apakah sel harus diblokir oleh siswa sejauh ini.  Akibatnya, sesuai dengan model simulator saat ini, dengan mengklik sel, kami mulai mengirim postMessage dari iframe ke frontend kami, yang, pada gilirannya, pergi ke Toko Redux dan memeriksa, berdasarkan pada sifat-sifat tugas, apakah tersedia untuk kita sekarang.  Jika tidak tersedia, kami beralih ke sel aktif sebelumnya. <br><br>  Jadi kami telah mencapai bahwa tidak mungkin untuk memilih sel dalam buku catatan yang tidak boleh diakses oleh timeline pelatihan.  Benar, ini memunculkan bug yang tidak kritis, tetapi: Anda mencoba mengklik sel dengan tugas yang tidak dapat diakses, dan dengan cepat "berkedip": jelas bahwa itu diaktifkan untuk sesaat, tetapi segera diblokir.  Meskipun kami belum menghilangkan kekasaran ini, itu tidak mengganggu kelulusan pelajaran, tetapi di latar belakang kami terus berpikir bagaimana cara mengatasinya (omong-omong, apakah ada pemikiran?) <br><br>  Sedikit tentang bagaimana kami memodifikasi antarmuka kami untuk menyelesaikan masalah.  Mari kita kembali ke trainer_type_jupyter.jsx - kita akan fokus pada app_initialized dan pilih. <br><br>  Dengan app_initialized, semuanya sederhana: notebook telah dimuat, dan kami ingin melakukan sesuatu.  Misalnya, pilih sel saat ini tergantung pada tugas yang dipilih.  Plugin ini dideskripsikan sehingga Anda dapat melewati taskId dan beralih ke sel pertama yang sesuai dengan taskId ini. <br><br>  Yaitu: <br><br>  // trainer_type_jupyter.jsx <br><br><pre> <code class="xml hljs">selectTaskCell = ({taskId}) =&gt; { const {selectCell} = this.props; if (!this.iframeRef) { return; } selectCell({iframe: this.iframeRef, taskId}); };</code> </pre> <br>  // trainer.actions.js <br><br><pre> <code class="xml hljs">export const selectCell = ({iframe, taskId}) =&gt; ({ type: SELECT_CELL, iframe, taskId });</code> </pre> <br>  // trainer.saga.js <br><br><pre> <code class="xml hljs">function* selectCell({iframe, taskId}) { iframe.contentWindow.postMessage(JSON.stringify({ type: 'select-cell', data: {taskId} }), '*'); yield; } function* watchSelectCell() { yield takeEvery(SELECT_CELL, selectCell); }</code> </pre> <br>  // custom.js (plugin Jupyter) <br><br><pre> <code class="xml hljs">function getCellTaskId(cell) { const notebook = Jupyter.notebook; while (cell) { const tags = cell.metadata.tags; const taskId = tags &amp;&amp; tags[0]; if (taskId) { return taskId; } cell = notebook.get_prev_cell(cell); } return null; } function selectCell({taskId}) { const notebook = Jupyter.notebook; const selectedCell = notebook.get_selected_cell(); if (!taskId) { selectedCell.unselect(); return; } if (selectedCell &amp;&amp; selectedCell.selected &amp;&amp; getCellTaskId(selectedCell) === taskId) { return; } const index = notebook.get_cells() .findIndex(cell =&gt; getCellTaskId(cell) === taskId); if (index <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">) { </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span><span class="hljs-tag">; } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">notebook.select</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">index</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cell</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">notebook.get_cell(index);</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cell.element</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">]</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.scrollIntoView</span></span></span><span class="hljs-tag">({ </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">behavior:</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">smooth</span></span></span><span class="hljs-tag">', </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">block:</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">start</span></span></span><span class="hljs-tag">' }); } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">function</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">actionListener</span></span></span><span class="hljs-tag">({</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">eventString</span></span></span><span class="hljs-tag">}) { </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">case</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">select-cell</span></span></span><span class="hljs-tag">'</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">selectCell</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">event.data</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">break</span></span></span><span class="hljs-tag">;</span></span></code> </pre> <br>  Sekarang Anda dapat beralih sel dan belajar dari iframe bahwa sel telah diaktifkan. <br><br>  Saat mengganti sel, kami mengubah URL dan masuk ke tugas lain.  Tetap hanya melakukan yang sebaliknya - saat memilih tugas lain di antarmuka, alihkan sel.  Mudah: <br><br><pre> <code class="xml hljs">componentDidUpdate({match: {params: {prevTaskId}}) { const {match: {params: {taskId}}} = this.props; if (taskId !== prevTaskId) { this.selectTaskCell({taskId});</code> </pre> <br><h3>  Boiler terpisah untuk perfeksionis </h3><br>  Itu akan keren untuk hanya membual tentang seberapa baik kita.  Solusi pada intinya efektif, meskipun terlihat sedikit berantakan: jika kita meringkas, kami memiliki metode yang memproses pesan yang datang dari luar (dalam kasus kami, dari iframe).  Tetapi dalam sistem yang kami bangun sendiri, ada hal-hal yang saya, dan rekan, tidak sukai. <br><br>  ‚Ä¢ Tidak ada fleksibilitas dalam interaksi elemen: setiap kali kita ingin menambahkan fungsionalitas baru, kita harus mengubah plugin untuk mendukung format komunikasi lama dan baru.  Tidak ada mekanisme tunggal yang terisolasi untuk bekerja antara iframe dan komponen front-end kami, yang menjadikan Notebook Jupyter dalam antarmuka pelajaran dan bekerja dengan tugas-tugas kami.  Secara global - ada keinginan untuk membuat sistem yang lebih fleksibel sehingga di masa depan mudah untuk menambahkan tindakan, peristiwa, dan proses baru.  Dan dalam kasus tidak hanya notebook Jupiter, tetapi juga dengan iframe dalam simulator.  Jadi kami ingin meneruskan kode plug-in melalui postMessage dan merendernya (eval) di dalam plug-in. <br><br>  ‚Ä¢ Kode fragmen yang menyelesaikan masalah tersebar di seluruh proyek.  Komunikasi dengan iframe dilakukan baik dari Redux-Saga dan dari komponen, yang tentunya tidak optimal. <br><br>  ‚Ä¢ Iframe sendiri dengan rendering Notebook Jupyter duduk di layanan lain.  Mengeditnya sedikit bermasalah, terutama sesuai dengan prinsip kompatibilitas ke belakang.  Misalnya, jika kita ingin mengubah semacam logika di ujung depan dan di notebook itu sendiri, kita harus melakukan pekerjaan ganda. <br><br>  ‚Ä¢ Banyak yang ingin menerapkan lebih mudah.  Ambil setidaknya Bereaksi.  Dia memiliki banyak metode siklus hidup, dan masing-masing dari mereka perlu diproses.  Selain itu, saya bingung dengan ikatan untuk Bereaksi sendiri.  Idealnya, saya ingin dapat bekerja dengan iframe kami, apa pun kerangka front-end Anda.  Secara umum, persimpangan teknologi yang kami pilih memberlakukan batasan: Redux-Saga yang sama mengharapkan tindakan Redux dari kami, bukan postMessage. <br><br>  Jadi kita pasti tidak akan berhenti pada apa yang telah dicapai.  Dilema buku teks: Anda dapat pergi ke sisi keindahan, tetapi mengorbankan optimalitas kinerja, atau sebaliknya.  Kami belum menemukan solusi terbaik. <br><br>  Mungkin ide-ide muncul dengan Anda? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453876/">https://habr.com/ru/post/id453876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453866/index.html">Permintaan API dengan React Hooks, HOC, atau Render Prop</a></li>
<li><a href="../id453868/index.html">Sentuh sakelar mini dengan panel kaca di nRF52832</a></li>
<li><a href="../id453870/index.html">Kami menulis Reverse socks5 proxy di PowerShell</a></li>
<li><a href="../id453872/index.html">Mengembalikan foto menggunakan jaringan saraf</a></li>
<li><a href="../id453874/index.html">Dari Roulette Rusia ke LOTO Aman: Cara Melindungi Personil Pusat Data</a></li>
<li><a href="../id453882/index.html">Panduan hebat tentang profesi arsitek solusi (+ daftar tautan berguna)</a></li>
<li><a href="../id453884/index.html">Penggantian HYIP Kamera atau DSLR?</a></li>
<li><a href="../id453888/index.html">Pembelajaran Alat Berat dengan Kecepatan Tinggi: Perawatan Prediktif Empat Bulan</a></li>
<li><a href="../id453890/index.html">Soviet memimpikan masa depan</a></li>
<li><a href="../id453892/index.html">Sertifikasi ISTQB. Bagian 2: Bagaimana mempersiapkan sertifikasi ISTQB? Berlatih cerita</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>