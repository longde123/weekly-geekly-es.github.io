<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🏫 🔘 👨🏽‍🔧 Zoo AFL Phasers 🚴 🤷🏿 🐿️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ha habido artículos sobre el Habré un par de veces que plantean el tema de American Fuzzy Lop (AFL) ( 1 , 2 ). Pero en este artículo no hablaremos del...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zoo AFL Phasers</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/435644/"><img src="https://habrastorage.org/webt/l4/vc/qr/l4vcqrdnz0vgsseyssmztrfrvdg.jpeg" alt="imagen"><br><br>  Ha habido artículos sobre el Habré un par de veces que plantean el tema de American Fuzzy Lop (AFL) ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> ).  Pero en este artículo no hablaremos del AFL clásico, sino de las utilidades auxiliares y sus modificaciones, que, en nuestra opinión, pueden mejorar significativamente la calidad del fuzzing.  Si está interesado en aprender cómo actualizar AFL y buscar vulnerabilidades más rápidas y más, ¡bienvenido al corte! <br><a name="habracut"></a><br><h1>  ¿Qué es AFL y por qué es tan bueno? </h1><br>  AFL: fuzzer guiado por cobertura o fuzzer basado en feedback.  Puede obtener más información sobre estos conceptos en un artículo tan genial como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuzzing: Arte, Ciencia e Ingeniería</a> .  Si resumimos la información sobre AFL, entonces podemos decir lo siguiente: <br><ul><li>  Herramientas de un ejecutable para recopilar información de cobertura </li><li>  Muta la entrada para maximizar la cobertura. </li><li>  Repite el paso anterior para encontrar bloqueos del programa. <ul><li>  En la práctica, demostrado ser muy efectivo <ul><li>  Muy fácil de usar </li></ul></li></ul></li></ul><br><br>  Gráficamente, esto se puede representar de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/iq/5z/au/iq5zaub6qftefx3x_q5te6d6guo.png" alt="imagen"><br><br>  Si no sabe qué es AFL, para comenzar le recomendamos: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Página oficial del proyecto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-training</a> : una breve excursión a AFL </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-demo</a> - una demostración simple de cómo difuminar un programa C ++ usando AFL </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-cve</a> - Colección de vulnerabilidades descubiertas usando AFL (no actualizado desde 2017) </li><li>  El hecho de que AFL se suma al programa durante su montaje se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí.</a> </li><li>  Algunos consejos útiles para aplicaciones de red fuzzing <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> </li></ol><br>  Al momento de escribir, la última versión de AFL era la versión <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.52b</a> .  Fazzer se está desarrollando activamente y, con el tiempo, algunos desarrollos de terceros se incluyen en la rama principal de AFL y se vuelven irrelevantes por sí mismos.  Actualmente hay varias herramientas auxiliares útiles que se pueden identificar: se enumeran en la siguiente sección. <br><br><div class="spoiler">  <b class="spoiler_title">Rode de competencia0 día</b> <div class="spoiler_text">  Por separado, vale la pena mencionar la competencia mensual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rode0day</a> , donde hay una competencia entre fases que encontrarán vulnerabilidades más rápido y más en casos preparados previamente con acceso al código fuente y sin él.  Y en general es una confrontación de varias modificaciones y bifurcaciones AFL. <br></div></div><br>  Al mismo tiempo, algunos usuarios de AFL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">señalan</a> que el autor del phaser Michal Zalewski calificó una campaña para apoyar su creación, ya que los últimos cambios datan del 5 de noviembre de 2017.  Esto supuestamente está asociado con su salida de Google y nuevos proyectos.  En este sentido, las personas comenzaron a recolectar y hacer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parches de forma</a> independiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para la</a> última versión actual 2.52b. <br><br><img src="https://habrastorage.org/webt/fy/00/xa/fy00xat3cumh3iq9a5biou30czi.png" alt="imagen"><br><br>  También hay diferentes opciones y derivados de AFL que permiten difuminar Python, Go, Rust, OCaml, GCJ Java, syscalls del kernel o incluso máquinas virtuales completas. <br><br><div class="spoiler">  <b class="spoiler_title">AFL para otros PL</b> <div class="spoiler_text"><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">python-afl</a> - para Python. <br>  - <a href="">afl.rs</a> - por <a href="">difuminar</a> un programa en Rust <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-fuzz-js</a> - afl-fuzz para javascript. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">java-afl</a> - AFL fuzzing para Java <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kelinci</a> : otro phaser para Java con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> sobre este tema <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">javan-warty-pig</a> - Fuzzer similar a AFL para JVM. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-swift</a> - para difuminar un programa en swift <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ocamlopt-afl</a> - para OCaml. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sharpfuzz</a> - basado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl</a> para .net fuzzer. <br></div></div><br><h1>  Herramientas auxiliares </h1><br>  En esta sección, hemos seleccionado varios scripts y herramientas para trabajar con AFL y los hemos dividido en varias categorías: <br><br>  <u>Procesamiento de kresh</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-utils</a> : un conjunto de utilidades para el procesamiento / análisis automático de accidentes y para minimizar los casos de prueba. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-crash-analyzer</a> : otro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">analizador de bloqueos</a> AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuzzer-utils</a> : un conjunto de scripts para analizar los resultados. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">atriage</a> es una herramienta de triaje simple. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-kit</a> : reescrito en python afl-cmin. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AFLize</a> es una herramienta que genera automáticamente compilaciones de paquetes de Debian amigables con AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-fid</a> : un conjunto de herramientas para trabajar con datos de entrada. </li></ul><br>  <u>Cobertura de código</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-cov</a> : proporciona datos de cobertura legibles por humanos. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">count-afl-calls</a> - Puntuación de proporción.  El script cuenta el número de bloques instrumentados en el binario. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-sancov</a> : como afl-cov, pero usa desinfectante clang. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">covnavi</a> es un script de análisis y cobertura de código del Grupo Cisco Talos. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LAF LLVM Passes</a> es una colección de parches para afl que modifican el código para facilitar que los fuzzers pasen por las ramas </li></ul><br>  <u>Varios scripts para minimizar los casos de prueba</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-pytmin</a> es un contenedor para afl-tmin que intenta acelerar el proceso de minimizar el caso de prueba mediante el uso de múltiples núcleos de CPU. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-ddmin-mod</a> : una variación de afl-tmin basada en el algoritmo ddmin. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">halfempty</a> es una utilidad rápida basada en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paralelización</a> para minimizar los casos de prueba de Tavis Ormandy. </li></ul><br>  <u>Para inicio distribuido</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">disfuzz-afl</a> : fuzzing distribuido para afl. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AFLDFF</a> es un marco para la distribución difusa con AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-launch</a> es una herramienta para lanzar muchas instancias afl. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-motherhip</a> : administre y lance múltiples fuzzers AFL sincronizados en la nube de AWS. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-in-the-cloud</a> es otro script para ejecutar afl en AWS. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VU_BSc_project</a> - Fuzz que prueba bibliotecas de código abierto con libFuzzer y AFL. </li></ul><br>  Además, recientemente se publicó un muy buen artículo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">“Escalar AFL a una máquina de 256 hilos”</a> sobre este tema, que describe el lanzamiento de AFL en 256 hilos. <br><br>  <u>Despliegue, gestión, seguimiento, informes.</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-other-arch</a> : un conjunto de parches y scripts para agregar fácilmente soporte para varias arquitecturas (no x86) en AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-trivia</a> : algunos scripts pequeños para simplificar la administración de AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-monitor</a> : un script para monitorear el funcionamiento de AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-manager</a> : un servidor web de Python para administrar multi-afl. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-tools</a> : imagen acoplable con afl-latest, afl-dyninst y Triforce-afl. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-remote</a> : un servidor web para la gestión remota de instancias afl. </li></ul><br><h1>  Modificaciones AFL </h1><br>  AFL ha influido enormemente en la comunidad de búsqueda de vulnerabilidades y en la industria difusa en sí.  Y no es sorprendente que con el tiempo, varias modificaciones inspiradas en el AFL original comenzaron a aparecer sobre la base de su idea.  En esta sección los consideraremos.  Cada una de estas modificaciones tiene sus ventajas y desventajas en comparación con la versión original de AFL en diferentes situaciones. <br><br>  Simplemente diga que si hay problemas con la instalación o si no desea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">perder</a> tiempo, se puede encontrar casi cualquier modificación en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hub.docker.com</a> <br><br>  Por qué <br><br><ul><li>  Aumente la velocidad y / o la cobertura del código <br><ul><li>  Algoritmos </li><li>  El medio ambiente <br><ul><li>  OS </li><li>  Hierro </li></ul><br></li></ul><br></li><li>  Trabaja en condiciones sin código fuente <br><ul><li>  Emulación de código </li><li>  Instrumentación de código <br><ul><li>  Estática </li><li>  Dinámico </li></ul><br></li></ul><br></li></ul><br>  <u>Modos AFL incorporados</u> <br><br>  Antes de proceder a la discusión de las diversas modificaciones y horquillas de AFL, es necesario hablar sobre dos modos importantes que una vez también fueron modificaciones, y que finalmente se convirtieron en modos incorporados.  Este es el modo Syzygy y el modo Qemu. <br><br>  Modo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Syzygy</a> : es el modo operativo en instrument instrument.exe <pre><code class="bash hljs">instrument.exe --mode=afl --input-image=test.exe --output-image=test.instr.exe</code> </pre>  Para este modo es necesario: reescribir estáticamente los binarios de PE32 con AFL, se requieren símbolos, requiere un desarrollo adicional para que el núcleo WinAFL sea consciente. <br><br>  Modo Qemu: cómo funciona bajo QEMU se puede encontrar aquí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Internals of AFL fuzzer - QEMU Instrumentation"</a> .  El soporte para trabajar con archivos binarios que usan QEMU apareció en el flujo ascendente AFL de la versión 1.31b.  El modo Afl qemu funciona con la funcionalidad adicional de instrumentación de código binario en el motor de traducción binario qemu tcg (generador de código pequeño).  Para hacer esto, afl tiene un script de compilación qemu que descarga el código fuente de una versión específica (2.10.0) de qemu, les impone varios parches pequeños y los compila para una arquitectura dada.  Después de eso, se devuelve el archivo afl-qemu-trace, que en realidad es una qemu-emulación en modo de usuario (emulación de solo archivos ejecutables ELF).  Gracias a esto, puede usar fuzzing con comentarios sobre binarios de elfos y para un montón de arquitecturas diferentes compatibles con qemu.  Además, obtienes todas las herramientas afl geniales, comenzando con una pantalla conveniente con información sobre la sesión actual y terminando con cosas avanzadas como afl-analyse.  Pero tenga en cuenta que también obtiene restricciones de qemu.  Además, por ejemplo, si el archivo es compilado por una cadena de herramientas que utiliza características de hardware SoC, en el que se inicia el binario y que no es compatible con qemu, el fuzzing se interrumpirá tan pronto como se encuentre una instrucción específica o, por ejemplo, se use un MMIO específico. <br><br>  También hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una</a> bifurcación <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tan</a> interesante del modo qemu, donde la velocidad aumentó 3x-4x veces debido a la instrumentación del código TCG y el almacenamiento en caché. <br><br>  <u>Tenedores</u> <br><br>  La apariencia de las horquillas AFL se asocia principalmente con cambios, mejoras en los algoritmos de operación de los AFL clásicos. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-cygwin</a> es un intento de portar AFL clásico a Windows utilizando Cygwin.  Desafortunadamente, este intento es bastante confuso, lento, y se puede decir que el desarrollo está abandonado. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AFLFast</a> (extiende AFL con Power Schedules): uno de los primeros tenedores de AFL, se agregaron todo tipo de heurísticas, gracias a las cuales podría ir más lejos en un corto período. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FairFuzz</a> es una extensión AFL cuyo objetivo es tratar de pasar más tiempo en sucursales más raras. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AFLGo</a> es una extensión para AFL, que está destinada principalmente al logro específico de ciertas secciones del código, en lugar de la cobertura general del código del programa.  Esto se puede usar para probar parches o secciones de código recién agregadas. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PerfFuzz</a> es una extensión AFL que busca casos de prueba que podrían ralentizar el programa tanto como sea posible. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pythia</a> es una extensión para AFL que tiene como objetivo agregar elementos de predicción al proceso de fases con respecto a la dificultad de descubrir nuevos caminos. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Angora</a> es uno de los fuzzers lanzados más recientemente, escrito en óxido.  Utiliza sus nuevas estrategias para la mutación y para aumentar la cobertura. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Neuzz</a> : un intento de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuzzing</a> utilizando redes neuronales. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UnTracer-AFL</a> : integración afl con UnTracer, para un seguimiento eficiente. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Qsym</a> : práctico motor de ejecución concólico adaptado para fuzzing híbrido.  De hecho, es un motor de ejecución de símbolos (los componentes principales se implementan como un complemento de pin de Intel), que, en combinación con afl, implementa fuzzing híbrido.  Esta es una evolución adicional en el tema de fuzzing basado en comentarios y merece una discusión por separado.  Su principal mérito es que puede realizar muy rápidamente (en relación con el resto) la ejecución concólica.  Esto ocurre debido a la ejecución nativa de comandos sin presentación intermedia del código, eliminando el mecanismo de instantánea y una serie de heurísticas.  Utiliza el pin anterior de Intel (debido a una serie de problemas de soporte entre libz3 y otros DBT), y actualmente puede trabajar con arquitecturas elf x86 y x86_64. </li></ul><br>  Vale la pena decir que hay una gran cantidad de trabajos académicos relacionados con la implementación de nuevos enfoques, técnicas de fuzzing, donde se toma y modifica AFL.  Además del documento técnico, no hay nada más disponible, por lo que ni siquiera mencionamos tales implementaciones.  Si estás interesado, entonces son fáciles de google.  Por ejemplo, este último es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CollAFL: Path Sensitive Fuzzing</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EnFuzz</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Smart Greybox Fuzzing</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ML</a> para afl. <br><br>  <u>Modificaciones basadas en Qemu</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TriforceAFL</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuzz</a> AFL / QEMU con emulación completa del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sistema</a> .  Horquilla de nccgroup.  Permite difuminar todo el sistema operativo en modo qemu.  Implementado a través de una instrucción especial (aflCall (0f 24)), que se agregó a la CPU QEMU x64.  Desafortunadamente, ya no es compatible, la última versión de afl es 2.06b. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TriforceLinuxSyscallFuzzer</a> - Llamadas fuzzing del sistema Linux. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-qai</a> es un pequeño proyecto de demostración con QEMU Augmented Instrumentation (qai). </li></ul><br><br>  <u>Modificación basada en KLEE</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kleefl</a> : para generar casos de prueba mediante ejecución simbólica (muy lento en programas grandes). <br><br>  <u>Modificaciones basadas en Unicornio</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-unicorn</a> : le permite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">confundir</a> fragmentos de código, emulándolo en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Unicorn Engine</a> .  También utilizamos con éxito esta variación AFL en nuestra práctica, es decir, en las secciones de código de un RTOS, que se ejecutó en SOC, y era imposible utilizar el modo QEMU.  Es aconsejable usar esta modificación cuando no hay fuentes (no puede ensamblar binarios independientes para el análisis del analizador sintáctico) y el programa no acepta datos de entrada directamente (por ejemplo, están encriptados o representan muestras de señales como en un binario CGC), entonces puede usarlo retroceda y encuentre las funciones de lugares propuestas donde estos datos se procesan en un formato conveniente para el difusor y que se pueden difuminar.  Esta es la modificación AFL más común.  En el sentido de que te permite literalmente difuminar todo.  Es decir, no depende de la arquitectura, la disponibilidad de los códigos fuente, el formato de los datos de entrada y el formato del binario en sí (el ejemplo más llamativo es simplemente de metal, solo piezas de código de la memoria del controlador).  El investigador examina preliminarmente este binario y escribe un fuzzer que emula el estado en la entrada del procedimiento del analizador, por ejemplo.  Se puede ver que, a diferencia de AFL, necesita hacer algún tipo de investigación sobre el binario.  Para el firmware de metal desnudo, como Wi-Fi o banda base, simplemente hay una serie de desventajas que debe tener en cuenta: <br><br><ol><li>  Es necesario de alguna manera localizar las sumas de verificación. </li><li>  Debe tenerse en cuenta que el estado del fuzzer es el estado de la memoria que se almacenó en el volcado de memoria, esto puede evitar el logro de ciertas rutas para el fuzzer. </li><li>  No hay un saneamiento de los accesos a la memoria dinámica, pero se puede implementar manualmente (también con esfuerzos) y dependerá de RTOS (también debe investigarse de antemano). </li><li>  La interacción entre tareas de RTOS no se emula: también puede evitar que el fuzzer encuentre ciertas rutas. </li></ol><br>  Un ejemplo de trabajo con esta modificación es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"afl-unicorn: Fuzzing Arbitrary Binary Code"</a> y <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Afl-unicornio: Parte 2 - Fuzzing the 'Unfuzzable'"</a> . <br><br>  Antes de pasar a las modificaciones basadas en los marcos de instrumentación binaria dinámica (DBI), recordamos de inmediato que el más rápido de estos marcos es DynamoRIO, luego DynInst y finalmente PIN. <br><br>  <u>Modificaciones PIN</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aflpin</a> - AFL con Intel PIN Instrumentation. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl_pin_mode</a> : otra instrumentación AFL implementada a través de Intel PIN. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-pin</a> - AFL con PINtool. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NaFl</a> : un clon (del núcleo básico) de AFL fuzzer. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PinAFL</a> : el autor de la herramienta intentó transferir AFL a Windows para difuminar binarios ya compilados.  Aparentemente, se hizo más en el ventilador en una noche, y luego el proyecto no se desarrolla.  El repositorio no contiene fuentes, solo binarios recopilados e instrucciones para comenzar.  La versión AFL en la que se basa esta herramienta no se especifica y solo admite aplicaciones de 32 bits. </li></ul><br>  Como puede ver, hay muchas modificaciones diferentes, pero en la práctica no hay mucho uso en la vida real. <br><br>  <u>Modificaciones basadas en Dyninst</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-dyninst</a> - American Fuzzy Lop + Dyninst == AFL blackbox fuzzing.  La característica de esta versión es que el programa inicialmente estudiado (sin código fuente) está instrumentado estáticamente (instrumentación binaria estática, reescritura binaria estática) usando DynInst, y luego se difunde con el clásico AFL, que cree que el programa fue construido usando afl-gcc / afl -g ++ / afl-as;) Al final, nos da la oportunidad de trabajar sin código fuente y con muy buen rendimiento. Solía ​​ser a una velocidad de 0.25x en comparación con una compilación nativa.  Hay una ventaja significativa sobre QEMU, que es la capacidad de instrumentar bibliotecas vinculadas dinámicamente.  Si bien QEMU solo puede instrumentar el archivo ejecutable principal vinculado estáticamente a las bibliotecas.  Desafortunadamente, ahora esto es relevante solo para el sistema operativo Linux.  Para admitir Windows, se necesitan cambios en DynInst y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajando allí</a> . <br><br>  También puede prestar atención a tal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bifurcación</a> donde se bombeó bien sobre varias capacidades (soporte para arquitecturas AARCH64 y PPC) y velocidad;) <br><br>  <u>Modificaciones basadas en DynamoRIO</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">drAFL</a> - AFL + DynamoRIO = fuzzing sin fuente en Linux. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-dr</a> : una implementación más sobre la base de DynamoRIO, que ya está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pintada</a> con gran detalle en espacios abiertos de Habr. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">afl-dynamorio</a> : modificación de vanhauser-thc (un ventilador para bombear y estabilizar AFL).  dice acerca de esta versión: "ejecute AFL con DynamoRIO cuando afl-dyninst normal está bloqueando el binario y el modo qemu -Q no es una opción".  Desde agradable, aquí se agrega soporte para ARM y AARCH64.  Respecto al rendimiento: DynamoRIO es aproximadamente ~ 10 más lento que Qemu, ~ 25 más lento que dyninst, sin embargo, ~ 10 más rápido que Pintool. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WinAFL</a> es la bifurcación más famosa de afl para Windows.  (DynamoRIO, también tiene modo syzygy).  La aparición de esta modificación fue solo cuestión de tiempo, ya que el deseo de probar AFL bajo Windows en aplicaciones para las que no hay códigos fuente apareció para muchos.  En este momento, la herramienta se está desarrollando activamente y, a pesar de utilizar la base de código AFL ligeramente retrasada (2.43b en el momento de la redacción), ya se han encontrado varias vulnerabilidades (CVE-2016-7212, CVE-2017-0073, CVE-2017- 0190, CVE-2017-11816).  Cabe señalar que los principales desarrolladores son especialistas del equipo del Proyecto Google Zero y del Equipo de Vulnerabilidades y Mitigaciones de MSRC, lo que da motivos para esperar un mayor desarrollo activo del proyecto.  Para implementar el fuzzer, los desarrolladores han pasado de compilar instrumentación de tiempo a usar instrumentación dinámica (basada en DynamoRIO), que se esperaba que ralentizara la ejecución del software en estudio, pero la sobrecarga resultante (dos veces) es comparable al AFL clásico en modo binario.  Los desarrolladores también resolvieron el problema de un largo inicio del proceso, llamándolo modo de fuzzing persistente, seleccionan la función que necesita ser difuminada (por desplazamiento dentro del archivo o por nombre si la función se presenta en la tabla de exportación) y la instrumentan de tal manera que se pueda llamar en un bucle, iniciando así varias muestras de datos de entrada sin reiniciar el proceso.  Recientemente apareció un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> interesante en el que los investigadores mostraron cómo encontraron ~ 50 vulnerabilidades con ~ 50 días usando winafl.  Además, casi antes de la publicación del artículo en WinAFL, también se agregó el modo Intel PT (más sobre esto más adelante) - los detalles están <a href="">aquí</a> . </li></ul><br>  Un lector avanzado / sofisticado puede notar que hay modificaciones con todos los marcos de instrumentación populares, con la excepción de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Frida</a> , de hecho lo es.  La única mención del uso de Frida con AFL se encontró solo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Chizpurfle: un Fuzzer de Android Gray-Box para personalizaciones de servicios de proveedores</a> .  La versión de AFL con Frida fue realmente útil ya que Frida admite varias arquitecturas RISC. <br><br>  Muchos investigadores también esperan con ansias el lanzamiento del marco Scorpio DBI del creador de Capstone, Unicorne, Keystone.  En base a este marco, los propios autores ya han creado un fuzzer (Darko) y, según ellos, lo han utilizado con éxito para difuminar dispositivos integrados.  Para obtener más información, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Excavación profunda: búsqueda de 0 días en sistemas integrados con fuzzing guiado de cobertura de código</a> . <br><br>  <u>Modificaciones basadas en las capacidades de hardware del procesador</u> <br><br>  Cuando se trata de modificaciones AFL con soporte para las capacidades de hardware del procesador, esto indica principalmente la posibilidad de difuminar el código del kernel y, en segundo lugar, una mayor velocidad de difuminado para aplicaciones sin código fuente. <br><br>  Y, por supuesto, antes que nada estamos hablando de capacidades de hardware del procesador como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intel PT</a> (Processor Tracing).  Que está disponible a partir de la sexta generación de procesadores (esto es de aproximadamente 2015).  Naturalmente, para usar los siguientes fuzzers, necesitará hardware con el soporte Intel PT adecuado. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WinAFL-IntelPT</a> es una modificación de WinAFL de terceros en la que ya se utiliza la tecnología Intel PT en lugar de DynamoRIO. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kAFL</a> es un desarrollo académico destinado a resolver el problema guiado por la cobertura para la eliminación gradual del núcleo de manera independiente del sistema operativo.  Lo que se resuelve utilizando el hipervisor y la tecnología Intel PT.  Puede obtener más información en su documento técnico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"kAFL: Fuzzing de retroalimentación asistida por hardware para kernels del sistema operativo"</a> . </li></ul><br><h1>  Conclusión </h1><br>  Como habrás notado, este tema se está desarrollando activamente.  Al mismo tiempo, hay mucho espacio para la creatividad para crear una modificación nueva, interesante y útil de AFL. <br><br>  ¡Gracias por su atención y su exitoso fuzzing! <br><br>  <b>Coautor:</b> Nikita Knizhov <br><br>  <i>PD: Gracias a todo el equipo del centro de investigación por su ayuda en la preparación de este material, sin su experiencia y ayuda, sería imposible prepararlo.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435644/">https://habr.com/ru/post/es435644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435630/index.html">Network IB en la nube: 5 tendencias de 2019</a></li>
<li><a href="../es435636/index.html">Cómo aprender con el aprendizaje automático de expertos en Dota 2</a></li>
<li><a href="../es435638/index.html">Sobre la felicidad de los desarrolladores y dónde encontrarla</a></li>
<li><a href="../es435640/index.html">El resumen de eventos para profesionales de recursos humanos en el campo de TI para enero de 2019</a></li>
<li><a href="../es435642/index.html">Pentax Auto 110: "¿en qué puño está la cámara?"</a></li>
<li><a href="../es435646/index.html">NB-IoT, Internet de las cosas de banda estrecha. Información general, características tecnológicas.</a></li>
<li><a href="../es435648/index.html">Bot genera tutoriales de artículos de Wikipedia</a></li>
<li><a href="../es435650/index.html">Cómo incrustar una biblioteca C en un marco Swift</a></li>
<li><a href="../es435652/index.html">Cómo no contraseñas en scripts de Python</a></li>
<li><a href="../es435654/index.html">Errores de las propiedades CSS personalizadas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>