<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ´ ğŸ‘ğŸ» ğŸ¦… Pemrograman heterogen dan oneAPI Toolkit. Kuliah pakar improvisasi Intel menjawab pertanyaan Anda ğŸ¥¢ ğŸ‘˜ ğŸ¦ƒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebagai bagian dari kolom "Ajukan pertanyaan ke pakar Intel", kami meminta spesialis Intel terkemuka Konstantin Vladimirov untuk menjawab pertanyaan t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman heterogen dan oneAPI Toolkit. Kuliah pakar improvisasi Intel menjawab pertanyaan Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/479486/"><img src="https://habrastorage.org/webt/tz/b5/gv/tzb5gvt-1m1z3yvd4tjzot84ao4.jpeg"><br><br>  Sebagai bagian dari kolom "Ajukan pertanyaan ke pakar Intel", kami meminta spesialis Intel terkemuka Konstantin Vladimirov untuk menjawab pertanyaan terkait pemrograman heterogen, <a href="https//software.intel.com/en-us/oneapi">toolkit oneAPI,</a> dan hal-hal menarik terkait.  Hasilnya melebihi semua harapan kami.  Konstantin tidak menyisihkan waktu dan memberikan jawaban yang terperinci dan kuat, tanpa takut menjadi polemik.  Bahkan, kami mendapat kuliah kecil tentang pemrograman lintas-arsitektur dalam segala bentuknya: nuansa muatan, optimisasi, standar, dan sebagainya. <br>  Kami mentransfer mikrofon ke ahli.  Nah, komentar diberikan kepada audiens. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="gambar">  Pertanyaan <a href="https://habr.com/ru/users/soarex16/" class="user_link">Soarex16</a> <br><blockquote>  Seberapa melelahkan transisi dari OpenCL ke oneAPI dan manfaat apa yang bisa didapat dari ini? </blockquote><br>  <b>Jawabannya</b>  Beralih ke DPC ++ bisa rumit, tapi menurut saya, itu sepadan.  Ada dua tahap utama. <br><br>  Pertama, ini adalah transisi dari bahasa pemrograman heterogen Anda (komputasi OpenCL, Vulkan), yang, kemungkinan besar, didasarkan pada API.  Di sini Anda memiliki permulaan dalam kenyataan bahwa Anda sudah mengetahui bidang subjek, dan kesulitannya adalah dalam mengalihkan pemikiran dari kontrol langsung melalui API ke konstruksi bahasa yang sedikit lebih implisit. <br>  Kedua, ini adalah transisi dari bahasa host Anda.  Jika Anda telah melepas seluruh hidup Anda dari C murni, maka ambang input sama dengan ambang untuk beralih dari C ke C ++, yang cukup tinggi. <br><br>  Mengapa mencoba <br><br>  Pertama, DPC ++ melakukan pekerjaan yang bagus untuk seorang programmer.  Anda akan dengan cepat lupa, seperti mimpi buruk, semua panggilan eksplisit ini ke clXXXYYY, dan apa arti argumen keenam, dan apakah Anda lupa kode pengembalian.  Banyak pembungkus berorientasi objek menyembunyikan rutinitas tidak lebih buruk, tetapi biasanya dengan biaya beralih dari API OpenCL standar ke API pembungkus yang tidak terlalu standar (saya juga melihat sepeda itu).  Dalam kasus DPC ++, Anda cukup menulis SYCL standar dengan ekstensi Intel (yang mungkin juga akan menjadi SYCL standar). <br><br>  Kedua, DPC ++ menyediakan untuk kompilasi bersama, yaitu, Anda dapat memastikan jenisnya dan Anda tidak akan memiliki masalah di perbatasan API dengan dimensi, pengisi, pelurusan.  Anda menulis kode kernel dan host dalam satu file, dan ini adalah kode yang sama.  Menggunakan USM, Anda juga dapat bekerja dengan struktur data yang kompleks jauh lebih mudah. <br><br>  Ketiga, DPC ++ adalah C ++ asli, yaitu memungkinkan pemrograman umum.  Misalnya, kernel paling sederhana untuk menambahkan dua vektor: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> kern = [A, B, C](cl::sycl::id&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; wiID) { C[wiID] = A[wiID] + B[wiID]; <span class="hljs-comment"><span class="hljs-comment">//   A, B  C?  ! };</span></span></code> </pre> <br>  Hal yang sama di OpenCL: <br><br><pre> <code class="cpp hljs">_<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *A, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *B, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *C)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>); C[i] = A[i] + B[i]; }</code> </pre> <br>  Soalnya, saya terpaksa menunjuk ke int tipe OpenCL.  Jika saya membutuhkan float, saya harus menulis kernel lain, atau menggunakan preprocessor, atau pembuatan kode eksternal.  Mendapatkan hampir semua fitur C ++ yang Anda inginkan bisa sedikit menakutkan jika Anda belum memiliki pengalaman dengan C ++.  Tapi ini adalah hal yang umum ketika terjadi perubahan teknologi besar. <br><br>  Dan semua manfaatnya tidak terbatas pada ini saja.  Saya akan menyebutkan hal lain dalam jawaban berikut. <br><br>  Jadi saya akan mengunduh kompiler di tempat Anda dan mencobanya, karena tidak sulit melakukan ini dengan paket <a href="https://software.intel.com/en-us/oneapi">OneAPI</a> . <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="gambar">  <a href="https://habr.com/ru/users/juster/" class="user_link">Juster</a> Pertanyaan <br><blockquote>  Apakah OpenVINO dan oneAPI terkait entah bagaimana? </blockquote><br>  <b>Jawabannya</b>  Distribusi OpenVINO sekarang menjadi bagian dari distribusi OneAPI.  Belajar dan menggunakan jaringan saraf adalah tugas yang sulit secara komputasi yang sangat diuntungkan dari pemrograman heterogen.  Saya percaya bahwa cepat atau lambat, semua komponen OneAPI akan memungkinkan untuk menggunakan semua sumber daya komputasi yang tersedia untuk Anda: akselerator grafis dan akselerator khusus seperti Nervana dan FPGA.  Dan semua ini tanpa meninggalkan paradigma bahasa dan sistem tipe program C ++ Anda. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="gambar">  Pertanyaan dari surat <br><blockquote>  Saya mencoba memahami bagaimana akselerator perangkat keras AI dalam 3 tahun, tolong bantu dengan ini.  Ada perusahaan Graphcore yang menarik dan IPU-nya - perangkat ini tidak kalah efisien dari FPGA, tetapi jauh lebih mudah untuk diprogram - Python dengan dukungan untuk TensorFlow dan kerangka kerja lainnya.  Ternyata jika janji-janji Graphcore dipenuhi, tidak akan ada kebutuhan untuk FPGA di pasar pembelajaran mesin.  Python jauh lebih nyaman untuk ilmuwan data daripada C ++. <br>  Apakah Anda setuju bahwa FPGA tidak cocok untuk pasar pembelajaran mesin dibandingkan dengan solusi yang dapat diprogram Python?  Jika pasar ML hilang, aplikasi FPGA luas apa lagi yang Anda lihat? <br>  Dalam aplikasi apa Anda melihat kebutuhan yang tak terhindarkan untuk pemrograman heterogen, di mana Anda tidak bisa bertahan dengan alat yang lebih nyaman seperti Python? </blockquote><br>  <b>Jawabannya</b>  Saya melihat sekilas IPU seperti apa.  Satu potong besi lagi yang akan dilepas semua orang.  Orang-orang ini bersaing dengan GPU dan dengan akselerator khusus, dan bukan dengan FPGA. <br><br>  Dalam tugas-tugas yang mana perangkat keras khusus dipertajam, itu akan selalu mengalahkan FPGA, misalnya, membuat video lebih baik pada kartu video, dll.  Tetapi di dunia (termasuk di dunia ML) ada banyak tugas yang tidak ada yang khusus diciptakan atau dirilis, dan di sini FPGA akan selalu diperlukan.  Misalnya, karena ada masalah harga dan, agar murah, perangkat keras khusus harus besar. <br><br>  Asumsikan sekarang bahwa IPU yang ditentukan benar-benar keren.  Ini tidak akan membatalkan pemrograman heterogen, sebaliknya, kehadiran akselerator yang sangat baik akan memacu itu.  Dan itu juga akan memberikan kepala raksasa memulai OneAPI dan DPC ++, karena cepat atau lambat seseorang akan berkata "Saya ingin menggunakan IPU dan GPU saya dari satu program."  Agak awal karena pemrograman heterogen adalah tentang itu.  Artinya adalah pembongkaran tugas yang cocok ke perangkat yang sesuai.  Sebuah tugas bisa datang dari mana saja.  Dan perangkat ini bisa berupa apa saja, bahkan bisa menjadi perangkat yang sama tempat program dijalankan.  Sebagai contoh, jika Anda melepas kernel yang ditulis dalam ISPC dan memanfaatkan fitur vektor Xeon secara maksimal, Anda dapat melepasnya sendiri dan masih menjadi keuntungan yang signifikan.  Kriteria utama di sini adalah kinerja.  Ya, tidak akan pernah ada terlalu banyak produktivitas di dunia ini.  Bahkan dengan akselerator terbaik di dunia. <br><br>  Adapun Python dan kenyamanannya ... Saya harus segera mengakui bahwa saya tidak suka bahasa yang diketik secara dinamis: mereka lambat dan bukannya kesalahan kompilasi normal, Anda harus menunggu dua jam sebelum jatuh ke runtime karena jenis yang salah.  Tapi saya tidak melihat betapa buruknya melakukan offload yang sama dari bawah Python.  Omong-omong, OneAPI sudah menyertakan Intel Distribution for Python, yang sangat nyaman untuk berbagai tinjauan. <br><br>  Yaitu, di dunia impian para pecinta Python, Anda menulis sebuah program di atasnya dan menurunkannya ke semua akselerator yang dapat Anda temukan menggunakan OneAPI, dan bukan sekelompok perpustakaan khusus vendor.  Hal lain adalah bahwa dengan pendekatan ini Anda kehilangan pengetikan ujung ke ujung dan kembali ke dunia pemrograman berbasis API yang sangat berbahaya.  Mungkin pengembangan DPC ++ akan mendorong masyarakat untuk lebih aktif menggunakan alat yang lebih tepat, seperti C ++. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="gambar">  Pertanyaan dari surat <br><blockquote>  Kinerja versus OpenCL.  Harus ada pajak untuk barang mewah - mis.  biaya overhead.  Apakah ada pengukuran? </blockquote><br>  <b>Jawabannya</b>  Di Internet Anda dapat menemukan banyak pengukuran dengan berbagai hasil, tergantung pada kompiler, tugas dan kualitas implementasi.  Sebagai penelitian pribadi, saya mengukur pada tugas-tugas sederhana (SGEMM, DGEMM) pada laptop saya (grafik Skylake terintegrasi), dan saya melihat bahwa sejauh ini ada beberapa drawdown (dalam persen).  Tapi menurut saya ini adalah konsekuensi dari kenyataan bahwa semua ini adalah beta sejauh ini. <br><br>  Secara teori, hasilnya harus akselerasi, bukan perlambatan, yaitu, pada prinsipnya, semua kemewahan ini harus memiliki nilai negatif.  Ini semua tentang kompiler.  Ketika program Anda terdiri dari satu sumber dan diproses sebagai satu program, kompiler mendapat peluang fantastis, luar biasa untuk optimasi: meletakkan kode umum, membalikkan loop, menyusun ulang bagian kode, dan segala sesuatu yang tidak dapat dilakukan oleh kompiler dalam pendekatan berbasis API, tetapi cepat atau lambat, dia pasti akan belajar dengan model sumber tunggal. <br><br>  Selain itu, DPC ++ akan memiliki biaya negatif dalam hal waktu pengembangan.  Contoh sederhana adalah pengakses SYCL, yang sudah digunakan oleh kompiler untuk mengatur acara dan mengelola antrian asinkron. <br><br><pre> <code class="cpp hljs">deviceQueue.submit([&amp;](cl::sycl::handler &amp;cgh) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> A = bufferA.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> B = bufferB.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> C = bufferC.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_write&gt;(cgh); .... deviceQueue.submit([&amp;](cl::sycl::handler &amp;cgh) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> A = bufferA.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> B = bufferB.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> D = bufferD.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_write&gt;(cgh);</code> </pre><br>  Di sini, kompilator melihat bahwa kedua paket hanya membaca A dan B dan menulis buffer independen C dan D, sebagai hasilnya, ia melihat kemampuan untuk mengirimnya secara paralel jika ada ukuran global yang cukup. <br><br>  Tentu saja, program OpenCL yang ditulis dengan pedantik dapat melakukannya juga, tetapi waktu pengembangan yang dihabiskan dengan kernel non-sepele tidak akan sebanding. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="gambar">  Pertanyaan dari surat <br><blockquote>  Apakah semua cara untuk mengoptimalkan aplikasi OpenCL untuk DPC ++ relevan?  Apa yang baru ditambahkan ke mereka? </blockquote><br>  <b>Jawabannya</b>  Saya akan mengatakan bahwa sebagian besar optimasi manual yang dilakukan oleh penulis kernel dapat dan harus dilakukan oleh kompiler.  Dengan cara yang sama, misalnya, saya menganggap itu praktik berbahaya untuk menginstal inline assembler secara manual dalam program C ++, karena meskipun memberikan manfaat taktis, itu mengganggu optimasi dan bertindak sebagai faktor negatif dalam pengembangan dan transfer produk.  Nah, OpenCL sekarang juga assembler. <br><br>  Adapun jawaban yang lebih rinci, saya takut jurang maut di sini.  Misalnya, ada dokumen Intel yang terkenal "Panduan Pengembang OpenCL untuk Intel Processor Graphics".  Dan ada <a href="https://software.intel.com/en-us/iocl-opg-avoiding-needless-synchronization">bagian</a> tentang cara mencoba, agar tidak meletakkan tempat sinkronisasi berlebih. <br><br>  Jadi, dari sudut pandang saya, pada prinsipnya ini bukan tugas manusia.  Orang-orang sangat miskin dalam alasan tentang sinkronisasi multi-utas dan cenderung memahat sinkronisasi baik secara konservatif atau tidak benar, atau keduanya sekaligus - saya menempatkan koma seperti ini ( <i>tetapi kami memperbaikinya - catatan editorial</i> ). <br><br>  Di sisi lain, di DPC ++, alih-alih menulis kode dengan penghalang eksplisit, seperti ini: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (t = <span class="hljs-number"><span class="hljs-number">0</span></span>; t &lt; numTiles; t++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tiledRow = TS * t + row; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tiledCol = TS * t + col; Asub[col][row] = A[globalRow * AY + tiledCol]; Bsub[col][row] = B[tiledRow * BY + globalCol]; <span class="hljs-comment"><span class="hljs-comment">// Synchronise to make sure the tile is loaded barrier(CLK_LOCAL_MEM_FENCE); // .... etc ....</span></span></code> </pre> <br>  Anda kemungkinan besar akan menulis iterasi eksplisit <i>parallel_for_work_group</i> , di dalamnya <i>group.parallel_for_work_item</i> <br><br><pre> <code class="cpp hljs">cgh.parallel_for_work_group&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mxm_kernel</span></span></span><span class="hljs-class">&gt;( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cl</span></span></span><span class="hljs-class">:</span></span>:sycl::range&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;{BIG_AX / TS, BIG_BY / TS}, cl::sycl::range&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;{TS, TS}, [=](cl::sycl::group&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; group) { <span class="hljs-comment"><span class="hljs-comment">// .... etc .... for (int t = 0; t &lt; numTiles; t++) { group.parallel_for_work_item([&amp;](cl::sycl::h_item&lt;2&gt; it) { // .... etc .... Asub[col][row] = A[globalRow][tiledCol]; Bsub[col][row] = B[tiledRow][globalCol]; }); //      ,   </span></span></code> </pre> <br>  Akibatnya, Anda tidak perlu mengatur sinkronisasi dengan tangan sama sekali, dan seluruh bagian dapat dibuang. <br><br>  Sehingga Anda bisa berjalan di semua bagian.  Sesuatu akan bertahan, sesuatu akan pergi.  Saya meramalkan munculnya dokumen baru "Optimasi untuk DPC ++", tetapi waktu harus berlalu, karena semua teknik yang benar-benar bekerja dikembangkan kemudian dan dengan darah <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="gambar">  Pertanyaan dari surat <br><blockquote>  Ada batasan dalam OpenCL - Anda tidak dapat menggunakan "data jauh" di kernel, yaitu, misalnya, menerapkan "filter lebar" yang menggunakan input data dari kelompok besar piksel lebih besar dari kelompok kerja OpenCL dalam satu perhitungan.  Apa yang DPC ++ tawarkan dalam hal ini? </blockquote><br>  <b>Jawabannya</b>  Yah, itu tidak mungkin.  Tentu saja, saya tidak terlalu menulis kernel ... Tetapi sangat yakin bahwa Anda dapat menggunakan semua memori global seperti itu, Anda hanya perlu memastikan bahwa Anda bekerja dengan operasi atom (atau menyinkronkan kernel hirarkis secara eksternal).  Dan Anda juga dapat menghubungkan Sistem SVM (baik, atau ada USM di DPC ++). <br><br>  Sayangnya, semua ini sangat tidak efisien, dan saya tidak suka semua trik ini.  Selain itu, mereka sulit dioptimalkan oleh kompiler. <br><br>  Jadi, jika kita berbicara tentang solusi langsung dan efektif, maka, tentu saja, tidak ada keajaiban di DPC ++.  Program Anda pada akhirnya masih dibagi menjadi beberapa bagian: kode host dan kode perangkat, dan semua pembatasan perangkat memengaruhi kode perangkat.  Ukuran maksimum kelompok kerja adalah paralelisme nyata yang dapat dilakukan perangkat keras Anda.  Semua yang ada di atasnya hanyalah cara untuk keluar, secara dramatis memengaruhi kinerja.  Itulah sebabnya DPC ++ memberikan kesempatan untuk melakukan ini: <i>device.get_info &lt;sycl :: info :: device :: max_work_group_size&gt; ()</i> dan kemudian memutuskan bagaimana hidup dengan nomor yang dihasilkan. <br><br>  Tentu saja akan tergoda untuk membuat model di DPC ++, ketika programmer bekerja sesuka Anda dengan loop berapa pun, dan kompiler melihat apa yang harus dilakukan selanjutnya, tetapi itu akan sangat salah, karena akan menyembunyikan konstanta, dan bahkan asimtotik dari kompleksitas tambahan. komputasi muncul entah dari mana.  Untuk alasan lain, Alexandrescu menulis bahwa "kerumitan yang merangkum harus dianggap sebagai kejahatan," dan ini juga berlaku. <br><br>  Terkadang merevisi algoritma itu sendiri membantu.  Di sini DPC ++ membuat segalanya lebih mudah karena kode yang lebih terstruktur lebih mudah untuk di-refactor.  Tapi ini penghiburan yang begitu-begitu saja. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="gambar">  Pertanyaan dari surat <br><blockquote>  DPC ++ didasarkan pada SYCL.  Tetapi bagaimana jika Anda masuk lebih dalam di balik tudung, apa perbedaan dari OpenCL dalam implementasi back end, jika ada.  Misalnya, apakah mekanisme distribusi antara perangkat heterogen sama dengan OpenCL? </blockquote><br>  <b>Jawabannya</b>  Jika Anda berada di bawah tenda, maka ini adalah OpenCL.  Semua kelebihan dan kelebihan SYCL adalah kelebihan dan kelebihan dari bahasa tersebut, yaitu frontend.  Dari ujung depan muncul SPIRV tua yang bagus yang pergi ke backend dan di sana dioptimalkan (sering sudah saat runtime, yaitu, JIT) sudah untuk kartu video tertentu dengan cara yang sama seperti OpenCL akan dioptimalkan untuk itu. <br><br>  Hal lain adalah bahwa mekanisme untuk mendistribusikan pekerjaan antara perangkat heterogen hanya lebih front-end daripada back-end, karena itu adalah kode host yang memutuskan apa yang harus dikirim dan ke mana.  Dan kode host diperoleh dari DPC ++.  Saya telah menunjukkan contoh sedikit lebih tinggi bagaimana kompiler dapat, atas dasar accessors, membuat keputusan tentang paket paralel.  Dan ini hanyalah puncak gunung es. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="gambar">  Pertanyaan dari surat <br><blockquote>  Perpustakaan  Ya, kita tidak berbicara tentang CUDA.  Tetapi kita tahu bahwa untuk pengembang CUDA ada perpustakaan yang sangat berguna yang bekerja dengan kinerja tinggi pada GPU.  OneAPI juga berisi beberapa perpustakaan, tetapi, misalnya, <a href="https://software.intel.com/en-us/ipp">IPP</a> - tidak ada arsip yang berguna untuk bekerja dengan gambar di oneAPI / OpenCL.  Akankah ada sesuatu, dan bagaimana dalam kasus ini untuk beralih dari CUDA ke oneAPI? </blockquote><br>  <b>Jawabannya</b>  Transisi dari CUDA ke standar terbuka tunggal akan sulit, tetapi tidak terhindarkan.  Tentu saja, CUDA sekarang memiliki infrastruktur yang lebih matang.  Tetapi fitur-fitur dari perizinannya adalah hambatan pemblokiran, karena semakin banyak pemain muncul di pasar sistem heterogen, semakin banyak kartu dan akselerator yang menarik dari berbagai produsen. <br><br>  Keragaman API yang ada membuat penggunaan dunia kemungkinan ini sulit bagi programmer dengan pengalaman CPU klasik.  Yang mengarah ke OneAPI atau semacamnya.  Di sini keajaiban tidak ada pada terobosan Intel dalam hal grafis, tetapi pada kenyataan bahwa Intel membuka pintu ke DPC ++ untuk semua orang.  Kami bahkan tidak memiliki standar SYCL, itu milik grup Khronos dan semua ekstensi Intel adalah ekstensi di Khronos tempat siapa pun dapat melakukan (dan ada perwakilan dari semua pemain besar di sana).  Dan itu berarti (perpustakaan) dan komunitas akan muncul (sudah muncul), dan banyak lowongan di arah ini. <br><br>  Dan tentu saja, IPP akan ditulis ulang untuk realitas baru.  Saya tidak ada hubungannya dengan IPP, tetapi menggunakan DPC ++ adalah akal sehat, dan orang waras duduk di sana. <br><br>  Tetapi yang lebih penting, sekarang adalah saat dalam sejarah ketika Anda dapat menulis perpustakaan Anda sendiri, yang akan melampaui IPP dan yang kemudian akan digunakan oleh seluruh dunia.  Karena standar terbuka selalu menang. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="gambar">  Pertanyaan dari surat <br><blockquote>  Jika kita membandingkan peluncuran pelatihan dan algoritma jaringan saraf inferensi pada Nervana dan FPGA - apa perbedaan dalam pemrograman dan efisiensi yang dihasilkan? </blockquote><br>  <b>Jawabannya</b>  Saya tidak tahu apa-apa tentang detail pemrograman FPGA, saya menulis kompiler.  Tapi saya punya pertanyaan balasan.  Dan bagaimana kita akan membandingkan?  Pada tolok ukur standar itu tidak sportif, Nervana menjilat di bawah mereka.  Tetapi jika Anda memiliki sesuatu yang menarik, maka FPGA akan melepaskan tangan Anda, dan meletakkan sesuatu ini pada Nervana bisa lama, mahal, itu saja. <br><br>  Ternyata pertanyaan itu sendiri, seolah-olah, dari seri â€œsiapa yang lebih kuat dari gajah atau pausâ€.  Tapi ini bukan pertanyaan nyata.  Pertanyaan sebenarnya adalah: bagaimana cara memanfaatkan gajah dan paus dalam satu gerobak?  Nah, atau setidaknya mendistribusikan, katakanlah, untuk seekor gajah menariknya melalui darat, dan seekor paus di laut. <br><br>  Dalam kasus OneAPI, Anda akan memiliki program yang sama di, secara umum, standar C ++.  Dan Anda dapat menulisnya sendiri dan menjalankannya dengan offload bolak-balik.  Ini akan menjadi tugas yang sangat menarik bagi Anda, di mana Anda sendiri dapat mengukur dan mengoptimalkan kinerja.  Standar tunggal dan antarmuka tunggal ke perangkat heterogen akan menjadi langkah menuju membandingkan apel dengan apel dalam hal-hal tersebut. <br><br>  Misalnya: "apa yang lebih baik untuk% dari tugas saya% dari sudut pandang kemudahan pemrograman dan efisiensi - letakkan bagian ini di FPGA, tinggalkan bagian ini di Nervana atau pisahkan bagian ini menjadi dua, dan tulis ulang bagian ini untuk GPU?" <br><br>  Dan keseluruhan cerita dengan OneAPI - hanya untuk Anda mengatakan, "mengapa memikirkannya untuk waktu yang lama, saya akan mencobanya sekarang dengan cepat, IT'S SIMPLE". <br><br>  Belum, tidak mudah.  Tetapi akan ada. <br><br><hr><br>  <b>Kata penutup dari ahlinya</b> <br><br>  Terima kasih atas pertanyaan Anda.  Mungkin dan bahkan mungkin saya salah, tidak akurat, dan membuat kesalahan.  Itu terjadi, di internet terus-menerus seseorang salah. <br><br>  Saya harap saya dapat menarik minat seseorang dalam pemrograman heterogen dan DPC ++.  Saya ingin merekomendasikan semua orang situs <a href="https://sycl.tech/">sycl.tech</a> , tempat berton- <a href="https://sycl.tech/">tonnya</a> laporan, termasuk dari para pakar terkenal dunia (bahasa Inggris diperlukan) <br><br>  Baik untuk semua! <br><br>  <i>PS dari penerbit.</i>  <i>Kali ini, dengan keputusan bulat dari dewan editorial, diputuskan untuk memberikan hadiah untuk pertanyaan terbaik ... kepada penulis jawaban.</i>  <i>Saya pikir Anda akan setuju bahwa ini adil.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479486/">https://habr.com/ru/post/id479486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479468/index.html">Edge of Honesty dan John Doe</a></li>
<li><a href="../id479474/index.html">Mengapa self-organisasi tim sangat penting dalam Scrum dan mengapa tidak ada manajer di dalamnya</a></li>
<li><a href="../id479478/index.html">Plug-in Java tanpa rasa sakit</a></li>
<li><a href="../id479480/index.html">SARIF SDK dan Kesalahannya</a></li>
<li><a href="../id479482/index.html">SARIF SDK dan kesalahannya</a></li>
<li><a href="../id479488/index.html">Dari laptop - server rumah dengan daya redundan ke router Mikrotik</a></li>
<li><a href="../id479492/index.html">Komputasi tanpa server berdasarkan OpenWhisk, bagian 3</a></li>
<li><a href="../id479496/index.html">Parsing Tugas WTF dalam JavaScript</a></li>
<li><a href="../id479498/index.html">Bagaimana waktu linear berubah menjadi Windows dalam O (nÂ²)</a></li>
<li><a href="../id479502/index.html">Bagaimana cara bertahan hidup di zaman es paling parah dalam sejarah Bumi?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>