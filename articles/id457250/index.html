<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§–ğŸ¼ ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ˜‡ Hari gelap untuk Vue.js ğŸ˜† ğŸª âš™ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini saya kagum pada bagaimana komunitas Vue.js yang biasanya positif dan ramah menyelinap ke dalam konfrontasi yang menyedihkan. Dua minggu lalu,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hari gelap untuk Vue.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457250/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/sm/rx/mssmrxcmkko2cpgoc48w6bzofea.png" width="500"></div><br><p>  Hari ini saya kagum pada bagaimana komunitas Vue.js yang biasanya positif dan ramah menyelinap ke dalam konfrontasi yang menyedihkan.  Dua minggu lalu, pembuat Vue Ewan Yu menerbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proposal</a> (RFC) dengan API fitur baru untuk komponen dalam Vue 3.0 mendatang.  Hari ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi kritis tentang Reddit</a> dan komentar serupa tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hacker News</a> telah menyebabkan masuknya pengembang ke RFC asli dengan kemarahan, kadang-kadang bahkan terlalu keras. </p><a name="habracut"></a><br><p>  Itu menyatakan sesuatu seperti berikut: </p><br><ul><li>  Semua kode Vue harus ditulis ulang dengan cara yang benar-benar baru, karena sintaks yang ada akan dihapus </li><li>  Semua waktu yang dihabiskan orang untuk mempelajari Vue ternyata sia-sia, karena semuanya akan berubah </li><li>  Sintaks baru ternyata lebih buruk daripada yang lama, tidak memberikan struktur yang jelas dan menghasilkan kode spaghetti </li><li>  Tim Vue meluncurkan perubahan besar tanpa berkonsultasi dengan siapa pun </li><li>  Vue berubah menjadi React! </li><li>  Atau tidak, dalam AngularJS / Angular! </li><li>  Semua HTML sekarang harus ditulis dalam satu baris besar! </li></ul><br><p>  Setelah dinding komentar negatif pada Reddit, mengejutkan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi tentang RFC</a> sendiri berisi sebagian besar reaksi positif, terutama di antara komentar pertama.  Bahkan, komentar pertama penuh dengan antusiasme. </p><br><p>  Saya adalah orang yang menulis komentar pertama ini.  Ternyata saya menerima pemberitahuan tentang RFC baru, segera membacanya dan menemukan bahwa inilah yang saya inginkan dari Vue 3.0 dan menulis komentar mengenai hal itu dalam waktu 15 menit setelah penerbitan RFC untuk menyampaikan terima kasih.  Dalam posting ini, saya berharap untuk mengungkapkan topik ini, mengapa saya menganggap API baru sebagai ide yang bagus.  Tapi pertama-tama, izinkan saya menjawab pernyataan para kritikus. </p><br><p>  Saya menduga bahwa banyak orang menjadi malu setelah membaca Hacker News atau Reddit, di mana ada banyak komentar tidak dapat diandalkan yang menyesatkan, tetapi tidak membaca <a href="">kalimat aslinya</a> .  Evan telah menambahkan bagian Tanya Jawab yang menjawab sebagian besar pertanyaan: </p><br><ul><li>  Anda tidak perlu menulis ulang apa pun dari awal jika Anda tidak mau - sintaks baru adalah pelengkap, sedangkan yang lama akan tetap bersama kami sepanjang Vue 3.0 sampai digunakan secara aktif.  Bahkan jika akhirnya dihapus dari kode utama, <a href="">dapat dengan mudah dikembalikan menggunakan plugin</a> . </li><li>  Waktu untuk belajar Vue tidak sia-sia - sintaks baru bekerja dengan cara yang sama seperti sebelumnya, dengan konsep yang sudah dikenal, seperti komponen file tunggal, templat, dan gaya lokal. </li><li>  Perubahan tidak dilakukan tanpa diskusi - RFC ini adalah diskusi.  Sintaks baru masih jauh dari rilis final. </li><li>  Dan tidak, HTML tidak harus ditulis seperti string besar </li></ul><br><p>  Ada poin yang agak subjektif tentang fakta bahwa sintaks baru menghasilkan kode yang kurang terstruktur.  Saya ingin menunjukkan ini dengan contoh sederhana yang akan menjelaskan mengapa saya sangat antusias tentang RFC dan mengapa saya berpikir bahwa pendekatan baru akan mengarah pada kode yang <em>lebih</em> terstruktur. </p><br><p>  Bayangkan sebuah komponen yang memungkinkan pengguna untuk memasukkan informasi tentang hewan peliharaan mereka dan diperbarui saat Anda memasukkan data.  Dalam hal ini: </p><br><ul><li>  Teks judul diperbarui tergantung pada nama hewan peliharaan. </li><li>  Warna stroke tergantung pada warna yang dipilih dari hewan, termasuk bayangan, warna yang dihitung berdasarkan warna yang dipilih. </li><li>  Ukuran font header dan gaya goresan tergantung pada ukuran hewan yang dipilih pengguna </li></ul><br><p><img src="https://habrastorage.org/webt/h3/pz/xg/h3pzxgpq4av_ibqk-9nbattvaoa.png"></p><br><p>  <em>Penampilan komponen</em> </p><br><p>  Anda dapat melihat demo langsung dengan komponen di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan juga melihat kode sumber untuk Vue 2.x di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (komponen file / Vue2.vue). </p><br><p>  Pertimbangkan bagian Javascript dari komponen ini: </p><br><pre><code class="javascript hljs">data() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">petName</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">petColor</span></span>: <span class="hljs-string"><span class="hljs-string">"#000"</span></span>, <span class="hljs-attr"><span class="hljs-attr">petSize</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }; }, <span class="hljs-attr"><span class="hljs-attr">computed</span></span>: { <span class="hljs-attr"><span class="hljs-attr">header</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.petName) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"My Pet "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.petName; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Enter Pet Details"</span></span>; }, <span class="hljs-attr"><span class="hljs-attr">petColorDarker</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tinycolor(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.petColor) .darken() .toString(); }, <span class="hljs-attr"><span class="hljs-attr">shadow</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"2px 2px "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.petColorDarker; }, <span class="hljs-attr"><span class="hljs-attr">borderStyle</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.petSize) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Small"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dotted"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Medium"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dashed"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"solid"</span></span>; } }, <span class="hljs-attr"><span class="hljs-attr">headerSize</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.petSize) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Small"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"12px"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Large"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"60px"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"30px"</span></span>; } } }</code> </pre> <br><p>  Pada dasarnya, kami memiliki beberapa jenis data dan berbagai properti yang dihitung dari data ini.  Perhatikan bahwa dalam Vue 2.x tidak ada cara untuk menyatukan hal-hal terkait.  Kami tidak dapat menempatkan <code>petColor</code> sebelah <code>petColorDarker</code> dihitung, karena di Vue 2.x mereka dikelompokkan berdasarkan jenis. </p><br><p>  Tentu saja, untuk contoh sekecil ini, ini tidak terlalu penting.  Tapi bayangkan sebuah contoh yang lebih besar, di mana ada bagian fungsionalitas dengan data yang diperlukan, properti yang dihitung, metode, dan bahkan dengan beberapa pengamat.  Sekarang tidak ada cara yang baik untuk menggabungkan entitas terkait bersama-sama!  Seseorang mungkin berpikir tentang mixin atau komponen tingkat tinggi, tetapi mereka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki masalah</a> - sulit untuk melihat dari mana properti ini berasal, dan ada juga masalah konflik nama. </p><br><p>  Sintaks baru menawarkan organisasi komponen dengan fungsionalitas terkait, bukan tipe nilai.  Ini mirip dengan bagaimana Anda mengatur file di komputer Anda - biasanya Anda tidak membuat folder terpisah untuk tabel excel dan dokumen kata, melainkan akan ada folder seperti pekerjaan atau perencanaan liburan.  Mari kita bayangkan seperti apa komponen kita dalam sintaks baru yang diusulkan (seberapa banyak ini akan terjadi tanpa kemampuan untuk menjalankan kode - beri tahu saya jika Anda menemukan bug): </p><br><pre> <code class="javascript hljs"> setup() { <span class="hljs-comment"><span class="hljs-comment">// Pet name const petName = value(""); const header = computed(() =&gt; { if (petName.value) { return "My Pet " + petName.value; } return "Enter Pet Details"; }); // Pet color const petColor = value("#000"); const petColorDarker = computed(() =&gt; { return tinycolor(petColor.value) .darken() .toString(); }); const shadow = computed(() =&gt; "2px 2px " + petColorDarker.value); // Pet size const petSize = value(""); const borderStyle = computed(() =&gt; { switch (petSize.value) { case "Small": return "dotted"; case "Medium": return "dashed"; default: return "solid"; } }); const headerSize = computed(() =&gt; { switch (petSize.value) { case "Small": return "12px"; case "Large": return "60px"; default: return "30px"; } }); // All properties we can bind to in our template return { petName, header, petColor, shadow, petSize, borderStyle, headerSize }; }</span></span></code> </pre> <br><p>  Perhatikan bahwa: </p><br><ul><li>  Sangat mudah untuk mengelompokkan entitas terkait bersama-sama. </li><li>  Melihat nilai balik dari fungsi pengaturan, kami segera melihat apa yang kami miliki akses di templat. </li></ul><br><p>  Selain itu, sintaks baru menyediakan dukungan penuh TypeScript, yang sulit dicapai dengan sintaks objek Vue 2.x.  Dan kita dapat memperbaiki logika kita dengan mentransfernya ke fungsi yang dapat digunakan kembali.  Sesuatu seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usePetName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> petName = value(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> header = computed(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (petName.value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"My Pet "</span></span> + petName.value; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Enter Pet Details"</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { petName, header }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usePetColor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> petColor = value(<span class="hljs-string"><span class="hljs-string">"#000"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> petColorDarker = computed(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tinycolor(petColor.value) .darken() .toString(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { petColor, petColorDarker }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">petSizeToBorderStyle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sizeWrapper</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> borderStyle = computed(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (sizeWrapper.value) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Small"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dotted"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Medium"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dashed"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"solid"</span></span>; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { borderStyle }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">petSizeToHeaderSize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">petSizeWrapper</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerSize = computed(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (petSizeWrapper.value) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Small"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"12px"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Large"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"60px"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"30px"</span></span>; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { headerSize }; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { setup() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { petName, header } = usePetName(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { petColor, petColorDarker } = usePetColor(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shadow = computed(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"2px 2px "</span></span> + petColorDarker.value); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> petSize = value(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { borderStyle } = petSizeToBorderStyle(petSize); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { headerSize } = petSizeToHeaderSize(petSize); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { petName, header, petColor, shadow, petSize, borderStyle, headerSize }; } };</code> </pre> <br><p>  Dalam Vue 2.x, saya sering menemukan bahwa saya sedang menulis "komponen mengerikan" yang sulit untuk dipecah menjadi potongan-potongan kecil - itu tidak dapat dibagi menjadi komponen yang lebih kecil, karena terlalu banyak yang terjadi berdasarkan sejumlah kecil variabel keadaan.  Namun, dengan sintaks baru yang diusulkan, dapat dilihat bahwa Anda dapat dengan mudah mengekstraksi logika dari komponen besar menjadi potongan-potongan terpisah, memasukkannya ke file terpisah, jika perlu, dengan memperoleh fungsi dan komponen yang kecil dan mudah dipahami. </p><br><p>  Apakah Vue mengalami hari yang lebih gelap?  Kemungkinan besar tidak.  Mantan komunitas di sekitar perpecahan proyek.  Tetapi saya memiliki harapan bahwa orang akan melihat lagi pada RFC, yang tidak merusak apa pun, karena memungkinkan orang untuk masih mengelompokkan entitas berdasarkan jenis, jika mereka menyukainya, tetapi juga memungkinkan lebih banyak - kode yang lebih dimengerti dan bersih, lebih banyak opsi untuk perpustakaan dan dukungan naskah lengkap. </p><br><p>  Dan akhirnya, ketika menggunakan open source, alangkah baiknya mengingat bahwa para pengembangnya berusaha keras untuk mendapatkan apa yang Anda dapatkan secara gratis.  Kritik yang terlalu keras yang kita lihat hari ini bukanlah sesuatu yang cocok untuk kita.  Untungnya, komentar yang tidak sopan ada di minoritas (meskipun signifikan), dan sebagian besar mampu mengekspresikan diri mereka dengan nada yang lebih tepat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457250/">https://habr.com/ru/post/id457250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457234/index.html">Bias kognitif produk</a></li>
<li><a href="../id457236/index.html">Bagaimana perusahaan IT berjuang untuk menjual musik</a></li>
<li><a href="../id457240/index.html">Berita terbaik minggu ini: jaringan saraf dan gambar foto, pertumbuhan saham Yandex, Huawei membutuhkan $ 1 miliar untuk paten</a></li>
<li><a href="../id457246/index.html">Bagaimana cara berkedip 4 LED pada CortexM menggunakan C ++ 17, tuple dan sedikit fantasi</a></li>
<li><a href="../id457248/index.html">Pemrograman JavaScript untuk mesin bubut</a></li>
<li><a href="../id457254/index.html">Intisari materi menarik untuk pengembang seluler # 303 (17 - Juni Juni)</a></li>
<li><a href="../id457256/index.html">Sejarah Internet: ARPANET - paket</a></li>
<li><a href="../id457258/index.html">Pirate Bay selama 15 tahun dan tidak bisa membunuh</a></li>
<li><a href="../id457260/index.html">Decoding wadah LUKS saat boot</a></li>
<li><a href="../id457262/index.html">Analisis kualifikasi kejuaraan pemrograman antara pengembang backend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>