<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💺 🌃 📵 Tutorial: arranque de resorte reactivo 💛 🚘 ☎️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El mes pasado, Trisha Gee (JetBrains) presentó en SpringOne una demostración de cómo crear una aplicación de precio de acciones en tiempo real usando ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tutorial: arranque de resorte reactivo</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481950/">  El mes pasado, Trisha Gee (JetBrains) presentó en SpringOne una demostración de cómo crear una aplicación de precio de acciones en tiempo real usando Spring Boot, Kotlin y JavaFX.  La demostración en vivo se grabó y está disponible como un <a href="https://youtu.be/Lse51SpfKHo">video de 70 minutos</a> . <br><br>  El 18 de diciembre, Trisha completó la publicación en <a href="https://dzone.com/">dzone.com del</a> tutorial reactivo Spring Boot basado en este video, como una serie de videos más cortos con una publicación de blog acompañante que explica cada paso más lentamente y con más detalle. <br><br>  Tuve la idea de traducir este tutorial al ruso.  Sin embargo, Trisha respondió cortésmente con mi pregunta sobre esto: <br><blockquote>  "Déjame consultar con mi organización.  Me encantaría traducirlo, pero podríamos tener una forma preferida de traducir las cosas ". </blockquote><br>  Así que decidí limitarme a una descripción general de este tutorial, que incluye la siguiente serie de lecciones: <br><a name="habracut"></a><br><ol><li>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-1-building-a-ko">Construyendo un Servicio REST de Kotlin</a> </li><li>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-2-a-rest-client">Un cliente REST para secuencias reactivas</a> </li><li>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-3-a-javafx-spri">Una aplicación JavaFX Spring Boot</a> </li><li>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-4-a-javafx-line">Un gráfico de líneas JavaFX</a> </li><li>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-5-auto-configur">Configuración automática para beans compartidos</a> </li><li>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-6-displaying-re">Mostrar datos reactivos</a> </li><li>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-7-subscribing-m">Suscribirse Múltiples suscriptores</a> </li><li>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-8-kotlin-rsocke">Servidor Kotlin RSocket</a> </li><li>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-9-java-rsocket">Cliente Java RSocket</a> </li><li>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-10-spring-profi">Perfiles de primavera para cambiar clientes</a> </li></ol><br>  El tutorial es una serie de lecciones en las que se creará una aplicación Spring Boot completa con la interfaz interna de Kotlin, el cliente Java y la interfaz de usuario JavaFX. <br><br><h3>  Parte 1. Crear un servicio REST en Kotlin </h3><br>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-1-building-a-ko">La primera parte del tutorial</a> describe cómo crear una aplicación Spring Boot en Kotlin, que sirve como el lado del servidor de la aplicación.  Se creará un servicio REST reactivo, al que puede conectarse en las siguientes partes del manual. <br><br>  Esta entrada de blog contiene un <a href="https://youtu.be/coM6wWKau5E">video que</a> muestra el proceso paso a paso y una guía de texto (adaptada de la transcripción del video) para aquellos que prefieren un formato escrito. <br><br>  Esta parte del tutorial incluye los siguientes pasos: <br><br><ul><li>  Crear un proyecto de servicio Spring Boot </li><li>  Estructura del proyecto Spring Boot </li><li>  Crear un controlador REST </li><li>  Crear una clase de datos para precios de acciones </li><li>  Generación de precios y retorno </li><li>  Lanzamiento de la aplicación </li></ul><br>  Después de completar estos pasos en la parte 1 del tutorial, se creará una aplicación Kotlin Spring Boot simple que usa Reactive Streams para emitir una cotización de acciones generada aleatoriamente una vez por segundo. <br><br>  <a href="https://github.com/trishagee/s1p-stocks-service">El código completo para la parte 1 del tutorial está disponible en GitHub</a> . <br><br><h3>  Parte 2. Cliente REST para flujos reactivos </h3><br>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-2-a-rest-client">La parte 2 del tutorial</a> muestra cómo crear un cliente Java reactivo en Spring que se conecta a un servicio REST que transmite los precios de las acciones una vez por segundo.  Este cliente se utilizará en secciones posteriores del manual.  Durante el desarrollo, se utilizará un proceso basado en TDD para crear el cliente y probarlo. <br><br>  Esta <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-2-a-rest-client">entrada de blog</a> contiene un <a href="https://youtu.be/iLcstbXDW6E">video que muestra el proceso paso a paso</a> y una guía de texto (adaptada de la transcripción del video) para aquellos que prefieren un formato escrito. <br><br>  Esta parte del tutorial incluye los siguientes pasos: <br><br><ul><li>  Crear un proyecto para un cliente </li><li>  Crear una clase de cliente </li><li>  Crear una prueba de cliente </li><li>  Crear un método de precio base de cliente </li><li>  Crear una clase para mantener los precios de las acciones. </li><li>  Agregar aserciones a la prueba </li><li>  Conecte el cliente al servicio REST </li><li>  Ejecutar prueba de integración </li><li>  Afirmaciones más exhaustivas en la prueba de integración </li></ul><br>  Probar aplicaciones reactivas no es una habilidad fácil, y ciertamente hay formas mucho mejores de hacerlo que en este simple ejemplo.  Sin embargo, se utilizó con éxito una prueba de integración para determinar la API y la funcionalidad del cliente para los precios de las acciones. <br><br>  Este cliente se conecta al punto final, que genera eventos enviados por el servidor y devuelve una secuencia de objetos StockPrice que puede utilizar otro servicio.  Cómo hacerlo se mostrará en los próximos videos de esta serie. <br><br>  <a href="https://github.com/trishagee/s1p-stocks-ui/tree/master/client">El código completo de 2 partes está disponible en GitHub</a> . <br><br><h3>  Parte 3. Aplicación JavaFX Spring Boot </h3><br>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-3-a-javafx-spri">La tercera demostración</a> muestra cómo crear una aplicación JavaFX que se inicia y administra a través de Spring Boot para usar las funciones de Spring, como la Inversión de control y la Inyección de dependencias, en nuestra aplicación JavaFX. <br><br>  Esta entrada de blog también contiene un <a href="https://youtu.be/u0dEf-QN-90">video que</a> muestra el proceso paso a paso y una guía de texto (adaptada de la transcripción del video) para aquellos que prefieren un formato escrito. <br><br>  Esta parte del tutorial incluye los siguientes pasos: <br><br><ul><li>  Configuración del módulo </li><li>  Cambio de la clase de aplicación Spring Boot </li><li>  Edición de la configuración de arranque de Spring </li><li>  Crear una clase de aplicación JavaFX </li><li>  Configurar la clase de aplicación Spring Boot </li><li>  Publicación de eventos a través del contexto de la aplicación. </li><li>  Crear contexto de aplicación </li><li>  Cerrar el contexto de la aplicación </li><li>  Escuchar eventos de aplicaciones </li></ul><br>  Después de completar los pasos 3 del tutorial, se creará la ventana principal de la aplicación JavaFX (Etapa: consulte la <a href="https://habr.com/ru/post/474498/">parte 2 del Tutorial JavaFX</a> ), que le permite configurar la interfaz de usuario.  A continuación, puede ejecutar nuestra aplicación StockUIA y ver que se inicia con éxito como una aplicación Spring Boot.  También lanza un proceso Java que mostraría la interfaz de usuario si la creáramos.  Por el momento, se ha creado con éxito una aplicación JavaFX, que se inicia y administra con Spring y le permite utilizar las prácticas funciones de cualquier aplicación Spring. <br><br>  <a href="https://github.com/trishagee/s1p-stocks-ui/tree/master/ui">El código completo del tutorial de 3 partes</a> está disponible en GitHub. <br><br><h3>  Parte 4. Gráfico de líneas JavaFX </h3><br>  En <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-4-a-javafx-line">este paso del tutorial,</a> veremos cómo crear una aplicación JavaFX que muestre un diagrama de líneas.  Esta aplicación utiliza Spring para funciones importantes como la inversión de control. <br><br>  Esta entrada de blog contiene un <a href="https://youtu.be/01GTN2iXbd8">video que</a> muestra el proceso paso a paso y una guía de texto (adaptada de la transcripción del video) para aquellos que prefieren un formato escrito. <br><br>  Esta parte del tutorial incluye los siguientes pasos: <br><br><ul><li>  Crear una escena (Escena: consulte la <a href="https://habr.com/ru/post/474498/">parte 2 del Tutorial JavaFX</a> ) </li><li>  Usando FXML </li><li>  Crear un archivo FXML </li><li>  Establecer encabezado de aplicación </li><li>  Configuración del encabezado de la <b>aplicación</b> desde <b>application.properties</b> </li><li>  Obteniendo controladores JavaFX de Spring </li><li>  Crea un gráfico de líneas </li></ul><br>  Después de completar los pasos anteriores, la parte 4 del tutorial creará una aplicación JavaFX.  Después de iniciar la aplicación, deberíamos ver el esquema del gráfico de líneas que se muestra en nuestra ventana, con números para el precio a lo largo del eje Y y el tiempo a lo largo del eje X. <br><br><img src="https://habrastorage.org/webt/mi/vp/hg/mivphgfusrcsp2smikk40vqyld4.png"><br><br>  Se creó una aplicación JavaFX integrada en Spring Boot que usa FXML para declarar lo que se debe mostrar en la vista. <br><br>  El <a href="https://github.com/trishagee/s1p-stocks-ui/tree/master/ui">código</a> completo <a href="https://github.com/trishagee/s1p-stocks-ui/tree/master/ui">para esta parte del tutorial</a> está disponible en GitHub. <br><br><h3>  Parte 5. Configuración automática para beans compartidos </h3><br>  La Lección 5 muestra cómo usar Spring Beans de un módulo en otro módulo usando la autoconfiguración. <br><br>  Esta entrada de blog también contiene un <a href="https://youtu.be/uPI4Xu7NtI0">video que</a> muestra el proceso paso a paso y una guía de texto (adaptada de la transcripción del video) para aquellos que prefieren un formato escrito. <br><br>  En la última lección, se creó una aplicación JavaFX Spring Boot que mostraba un diagrama de línea vacío.  En este video veremos cómo configurar la autoconfiguración para Spring Beans para que podamos usar los componentes de bean definidos en el módulo stock-client en el módulo stock-ui. <br><br>  Esta parte del tutorial incluye los siguientes pasos: <br><br><ul><li>  Agregar una dependencia en otro módulo </li><li>  Crear un WebClientStockClient Bean </li><li>  Activa la configuración automática </li></ul><br>  Esta es una parte bastante pequeña del tutorial, pero nos permite crear módulos que pueden ser reutilizados por varias aplicaciones Spring Boot.  Ahora podemos usar el cliente en ChartController para conectarse al servicio de precios y comenzar a mostrar los precios en tiempo real en un gráfico de líneas. <br><br>  El <a href="https://github.com/trishagee/s1p-stocks-ui/">código</a> completo <a href="https://github.com/trishagee/s1p-stocks-ui/">de esta parte</a> está disponible en GitHub. <br><br><h3>  Parte 6. Visualización de datos reactivos </h3><br>  <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-6-displaying-re">Esta lección</a> discute la conexión de diagramas JavaFX a nuestro servicio Kotlin Spring Boot para mostrar los precios en tiempo real.  Esta entrada de blog contiene un <a href="https://youtu.be/OMuqIykUh5w">video que</a> muestra el proceso paso a paso y una guía de texto (adaptada de la transcripción del video) para aquellos que prefieren un formato escrito. <br><br>  En la <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-4-a-javafx-line">cuarta parte</a> , se creó la aplicación JavaFX Spring Boot, que muestra un diagrama de línea vacío.  La última versión ( <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-5-auto-configur">quinta parte</a> ) utilizó WebClientStockClient para conectarse al servicio de precios.  En esta parte, se obtuvo un gráfico de líneas que muestra los precios provenientes de nuestro servicio Kotlin Spring Boot en tiempo real. <br><br>  Esta parte del tutorial incluye los siguientes pasos: <br><br><ul><li>  Configurar datos del gráfico </li><li>  Suscríbase a los datos de precios </li><li>  Visualización de datos de precios </li><li>  Lanzamiento de la aplicación </li><li>  Visualización del nombre del personaje </li><li>  Limpieza de código </li></ul><br>  Algunas líneas de código en esta parte del tutorial crearon una aplicación JavaFX que usa SpringClient para conectarse al servicio Spring Boot, se suscribe a un flujo de precios reactivo y dibuja los precios en un gráfico de líneas en tiempo real. <br><br>  El <a href="https://github.com/trishagee/s1p-stocks-ui/">código</a> completo <a href="https://github.com/trishagee/s1p-stocks-ui/">de esta parte</a> está disponible en GitHub. <br><br><h3>  Parte 7. Suscribirse a múltiples suscriptores </h3><br>  En la <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-6-displaying-re">parte anterior</a> , nos suscribimos a un gráfico de líneas JavaFX para los precios de nuestro servicio Reactive Spring Boot y los mostramos en tiempo real. <br><br>  En <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-7-subscribing-m">esta lección,</a> se finalizará un cronograma de actualización en tiempo real para mostrar los precios de más de una acción, lo que requiere que más de un consumidor se suscriba a nuestro flujo de precios reactivo. <br><br>  En el blog encontrará un <a href="https://youtu.be/o_hRybh7eJA">video que</a> muestra el proceso paso a paso y una descripción del texto (adaptado de la transcripción del video) para aquellos que prefieren un formato escrito. <br><br>  Esta parte del tutorial incluye los siguientes pasos: <br><br><ul><li>  Nos damos cuenta de los precios de suscripción </li><li>  Transferencia de derechos a un suscriptor de precios </li><li>  Agregar un segundo suscriptor </li><li>  Limpieza de código </li><li>  Refactorización de bonificación (¡no en el video!) </li></ul><br>  Al final de esta parte del tutorial, creará una aplicación JavaFX que se suscribe a más de un precio de nuestro servicio Spring Boot y muestra cada conjunto de datos de precios en tiempo real en varias series en un gráfico de líneas. <br><br>  El <a href="https://github.com/trishagee/s1p-stocks-ui/">código</a> completo <a href="https://github.com/trishagee/s1p-stocks-ui/">de esta parte</a> está disponible en GitHub. <br><br><h3>  Parte 8. Servidor Kotlin RSocket </h3><br>  En <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-8-kotlin-rsocke">esta lección</a> , se agregará un nuevo servicio interno a Kotlin, que envía los precios a través de RSocket, un protocolo para flujos reactivos.  Esta entrada de blog contiene un <a href="https://youtu.be/JYg159twPYE">video que</a> muestra el proceso paso a paso y una guía de texto (adaptada de la transcripción del video) para aquellos que prefieren un formato escrito. <br><br>  En esta etapa de la serie de tutoriales, se creó con éxito una aplicación integral que publica los precios del servicio Kotlin Spring Boot y los muestra en un gráfico de líneas JavaFX.  Utiliza el protocolo HTTP para enviar eventos al servidor.  Sin embargo, dado que esta es una aplicación reactiva, podemos elegir el protocolo que mejor se adapte a la transmisión de datos. <br><br>  En esta parte del tutorial, se creará un servicio que produce datos de precios utilizando el protocolo RSocket. <br><br>  Esta parte del tutorial incluye los siguientes pasos: <br><br><ul><li>  Crear un controlador RSocket </li><li>  Realizamos servicio de precios </li><li>  Portar código común a PriceService </li><li>  Reduce la duplicación de código </li><li>  Refactorización para reducir la caldera </li><li>  Configuración de visualización de mensajes </li><li>  Configuración del servidor RSocket </li></ul><br>  Al final de esta parte del tutorial, el puerto 7000 lanzará un servicio de precios, listo para conectar a un cliente para recibir precios de acciones a través de RSocket. <br><br>  El <a href="https://github.com/trishagee/s1p-stocks-service">código fuente</a> completo <a href="https://github.com/trishagee/s1p-stocks-service">de esta parte</a> está disponible en GitHub. <br><br><h3>  Parte 9. Cliente Java RSocket </h3><br>  En <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-9-java-rsocket">esta lección,</a> agregaremos un cliente RSocket que puede comunicarse con el servidor <a href="https://blog.jetbrains.com/idea/2019/12/tutorial-reactive-spring-boot-kotlin-rsocket-server/">RSocket que creamos en la última lección</a> . <br><br>  Esta entrada de blog contiene un <a href="https://youtu.be/P0uJRJlCl1M">video que</a> muestra el proceso paso a paso y una guía de texto (adaptada de la transcripción del video) para aquellos que prefieren un formato escrito. <br><br>  Actualmente, tenemos una aplicación que funciona de principio a fin usando Spring <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/reactive/function/client/WebClient.html">WebClient</a> .  En la <a href="https://blog.jetbrains.com/idea/2019/12/tutorial-reactive-spring-boot-kotlin-rsocket-server/">última lección,</a> presentamos el nuevo servidor RSocket, que actualmente está funcionando, y en esta lección veremos cómo crear un cliente para conectarse a él. <br><br>  Esta parte del tutorial incluye los siguientes pasos: <br><br><ul><li>  Crea una prueba de integración </li><li>  Creación de RSocket Stock Client </li><li>  Presentación de la interfaz de StockClient </li><li>  Implementación de conexión RSocket </li><li>  Creando RSocketRequester </li><li>  Prueba de aprobación de integración </li><li>  Prueba con StepVerifier </li><li>  Agregar estrategias de reversión y manejo de errores </li></ul><br>  Al final de esta parte del tutorial, tendremos un servidor RSocket que genera precios de acciones, y un cliente RSocket que puede conectarse y ver estos precios.  En la próxima lección, veremos cómo pasar de usar WebClientStockClient a nuestro nuevo RSocketStockClient. <br><br>  El <a href="https://github.com/trishagee/jb-stock-client">código fuente</a> completo <a href="https://github.com/trishagee/jb-stock-client">de esta parte</a> está disponible en GitHub. <br><br><h3>  Parte 10. Perfiles de resorte para cambiar clientes </h3><br>  La <a href="https://dzone.com/articles/tutorial-reactive-spring-boot-part-10-spring-profi">parte final del tutorial</a> usa la configuración Spring Profiles para que la aplicación pueda determinar cuál de nuestros dos clientes (eventos enviados por el servidor a través de WebClient o RSocket) usar para conectarse a nuestro servicio de precios Kotlin Spring Boot. <br><br>  Como de costumbre, esta publicación de blog contiene un <a href="https://youtu.be/2ykaHcEAc0M">video que</a> muestra el proceso paso a paso y una guía de texto (adaptada de la transcripción del video) para aquellos que prefieren un formato escrito. <br><br>  Para esta etapa de la serie de tutoriales, tenemos un cliente RSocket que nos permite conectarnos a nuestro servidor RSocket, queremos usar estas funciones desde nuestra aplicación JavaFX. <br><br>  Esta parte del tutorial incluye los siguientes pasos: <br><br><ul><li>  Crear un bean RSocketStockClient </li><li>  Elegir un frijol para usar </li><li>  Selección activa de perfil </li><li>  Registro para depuración </li><li>  Obtener precios a través de RSocket </li></ul><br>  Al final de esta parte del tutorial, tendremos una aplicación completa de gráficos lineales JavaFX que se suscribe al flujo de precios reactivo de la aplicación Kotlin Spring Boot.  Además, la aplicación se puede configurar para recibir estos precios a través de eventos enviados por el servidor o mediante el nuevo protocolo RSocket. <br><br>  El código completo está disponible en GitHub: <br><br>  <a href="https://github.com/trishagee/jb-stock-client">Proyecto de cliente</a> (stock-client y stock-ui-modules). <br>  <a href="https://github.com/trishagee/jb-stock-service">Proyecto de servidor</a> (aplicación Kotlin Spring Boot) <br><br><h3>  Lectura adicional </h3><br>  <a href="https://dzone.com/articles/fully-reactive-spring-kotlin-and-javafx-playing-to">Totalmente reactivo: Spring, Kotlin y JavaFX jugando juntos [Enlaces]</a> <br>  <a href="https://dzone.com/articles/kotlin-microservice-with-spring-boot">Tutorial de microservicio de Kotlin con Spring Boot</a> <br>  <a href="https://dzone.com/articles/spring-reactive-programming-in-java">Programación reactiva de primavera en Java</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/481950/">https://habr.com/ru/post/481950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../481940/index.html">Trabajo rápido y efectivo en línea de comando</a></li>
<li><a href="../481942/index.html">Regreso al futuro: qué juegos modernos se presentaron en 2010</a></li>
<li><a href="../481944/index.html">¿Qué determina la posición del sitio en la página de búsqueda?</a></li>
<li><a href="../481946/index.html">Métodos de comunicación en equipos de Microsoft: Canales VS Chats</a></li>
<li><a href="../481948/index.html">¿Cómo crear un robot virtual?</a></li>
<li><a href="../481952/index.html">Hitachi muriendo duro, golpe y tecno-necrofilia</a></li>
<li><a href="../481954/index.html">¿Cómo y por qué puedo hackear VR?</a></li>
<li><a href="../481956/index.html">En busca del programador desaparecido. Búsqueda de año nuevo</a></li>
<li><a href="../481958/index.html">¿Cuándo es un firmante en mail.ru o cómo cruzar un tanque T-34 con una interfaz de correo?</a></li>
<li><a href="../481960/index.html">2. Pila elástica: análisis de registros de seguridad. Logstash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>