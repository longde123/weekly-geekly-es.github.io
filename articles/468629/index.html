<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöö üõãÔ∏è ‚ûñ C√≥mo cre√© un filtro que no corrompe la imagen incluso despu√©s de un mill√≥n de ejecuciones - parte 2 ü•ã üëñ üå≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la primera parte de esta publicaci√≥n, habl√© sobre c√≥mo el uso repetido de los filtros de halfpel est√°ndar crea im√°genes distorsionadas, y luego mos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo cre√© un filtro que no corrompe la imagen incluso despu√©s de un mill√≥n de ejecuciones - parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468629/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" alt="imagen"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" alt="imagen"></div><br>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte de</a> esta publicaci√≥n, habl√© sobre c√≥mo el uso repetido de los filtros de halfpel est√°ndar crea im√°genes distorsionadas, y luego mostr√© un nuevo filtro que no tiene este problema. <br><br>  Estaba un poco m√°s borroso y esto no ser√≠a adecuado para todos.  Sin embargo, era mejor que sus alternativas; de hecho, este filtro se us√≥ en la versi√≥n original de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bink 2</a> .  Debido a la carga de trabajo constante, nunca logr√© volver a √©l de nuevo y examinarlo con m√°s detalle. <br><br>  Pero ahora que he <i>encontrado</i> tiempo para volver a este filtro y escribir un art√≠culo al respecto, finalmente deber√≠a hacer una pregunta: ¬øhay un filtro <i>menos borroso</i> que a√∫n conserva la propiedad de "estabilidad infinita"? <br><br>  Advertencia de spoiler: la respuesta correcta es "probablemente no" y "definitivamente ah√≠".  Pero antes de llegar a por qu√© hay dos respuestas a esta pregunta y qu√© significan, mejor preparemos un banco de pruebas. <br><a name="habracut"></a><br><h2>  Ajuste de compensaci√≥n </h2><br>  Cuando trabaj√© inicialmente en este problema, no ten√≠a idea de lo que estaba buscando.  Ni siquiera sab√≠a que <i>exist√≠a</i> algo as√≠ como un filtro de halfpel "infinitamente estable", por lo que no cre√© un sistema en su b√∫squeda.  Estaba buscando algo que resistiera las "muchas" iteraciones de filtro sin distorsi√≥n de imagen.  Todas las im√°genes de la primera parte reflejan esta metodolog√≠a: la imagen se desplaza de derecha a izquierda medio p√≠xel a la vez, es decir, si aplica el filtro 100 veces, la imagen resultante se desplazar√° 50 p√≠xeles. <br><br>  Ahora que sabemos lo que <i>realmente estamos</i> buscando, podemos ser un poco m√°s precisos.  Aplicando el filtro halfpel dos veces, cambiamos la imagen exactamente un p√≠xel.  Es decir, si simplemente <i>movemos la imagen un p√≠xel hacia atr√°s</i> , entonces permanecer√° en el mismo espacio.  Gracias a esto, la prueba se ver√° mucho m√°s hermosa, porque no solo podremos aplicar el filtro varias veces, sin temor a que la imagen se "arrastre" fuera de la pantalla, sino que tambi√©n podremos encontrar la <i>diferencia de la</i> imagen con versiones anteriores y el original. <br><br>  Esto nos permitir√° probar los filtros autom√°ticamente.  Simplemente aplicamos el filtro muchas veces y vemos una de dos cosas: convergencia a una imagen sin cambios, lo que indica que el filtro es infinitamente estable, o una desviaci√≥n significativamente grande de la imagen original, lo que indica que el filtro est√° "roto".  Para estas pruebas, eleg√≠ el error promedio por canal 64 (de 255), o el error m√°ximo en cualquiera de los canales al 255 completo como "significativamente grande". Si alguna de estas condiciones es cierta, asumiremos que el filtro "se rompi√≥" ". <br><br><h2>  Volver a probar los filtros de la primera parte </h2><br>  Entonces, ahora entendemos mejor c√≥mo probar estos filtros, as√≠ que echemos un vistazo a los filtros de la primera parte.  Comencemos con un bilineal, que, por supuesto, no es muy interesante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/35a/e35/f0235ae35bdf31c9a6ed17f168681836.png" width="1016" height="284"></div><br>  Esta es una imagen despu√©s de 244 iteraciones.  Como es de esperar, la imagen se "rompe" gradualmente debido al promedio constante de p√≠xeles.  Pero incluso gradualmente alcanza el l√≠mite del error promedio. <br><br>  Aqu√≠ est√° h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91e/cb8/54b/91ecb854b5c9339b41d803a256176c31.png" width="1016" height="284"></div><br>  Para romper la imagen, 78 iteraciones son suficientes para √©l.  El filtro HEVC con 8 muestras se comporta un poco mejor, pero a√∫n se rompe despu√©s de 150 iteraciones: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/d72/f5a/0add72f5ab060248be682d182abffd92.png" width="1016" height="284"></div><br>  Lanczos con 6 cortes de muestras despu√©s de 166 iteraciones: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" width="1016" height="284"></div><br>  Esos son todos nuestros filtros rotos.  Todo lo que queda es mi filtro entero: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/048/7be/511/0487be5114581255d15aa6f61c03d872.png" width="1016" height="284"></div><br>  Como era de esperar, no fue <i>el</i> √∫nico <i>en</i> romper.  Converge en una imagen infinitamente estable despu√©s de 208 iteraciones. <br><br>  Lo que sabemos es bastante notable aqu√≠: al menos para una amplia gama de im√°genes de prueba, este filtro es <i>infinitamente estable</i> , es decir, nunca crear√° un artefacto, sin importar cu√°ntas veces se use. <br><br>  Esto nos lleva de vuelta a la pregunta original: ¬øes realmente el mejor?  Y ya sabes las respuestas, porque al principio del art√≠culo tambi√©n escrib√≠: "probablemente no" y "definitivamente s√≠". <br><br>  Primero veamos primero la parte "probablemente no". <br><br><h2>  Filtros enteros </h2><br>  Entonces, en la primera parte de la publicaci√≥n, mencion√© que el n√∫cleo del filtro que encontr√© era "el mejor de los detectados", y esta es su peculiaridad.  Y aqu√≠ est√° la caracter√≠stica: <br><br>  Cuando estaba buscando este filtro, <i>de hecho,</i> no estaba buscando el <i>mejor</i> filtro.  Estaba buscando el mejor filtro <i>que se pueda expresar con un n√∫mero muy peque√±o de cambios enteros, sumas y restas</i> .  Puede parecer extra√±o, pero t√≥mate tu tiempo. <br><br>  Es posible que haya notado que cuando mostr√© los coeficientes de h.264, HEVC y el filtro bilineal, as√≠ como mi filtro, los escrib√≠ como numeradores enteros sobre denominadores enteros, como este: <br><br><pre><code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Pero en el caso de la ventana sinc, actu√© de manera diferente y lo escrib√≠ as√≠: <br><br><pre> <code class="cpp hljs">LanczosKernel[] = {<span class="hljs-number"><span class="hljs-number">0.02446</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.02446</span></span>};</code> </pre> <br>  La raz√≥n de esto es que el sinc en ventana se infiere realmente de una funci√≥n matem√°tica continua que no tiene nada que ver con fracciones enteras ordinarias.  Cuando se usa este filtro, se usan n√∫meros de coma flotante (con la mayor precisi√≥n posible) que corresponden a los valores de la funci√≥n sinc.  Si se esfuerza por aplicarlos con precisi√≥n, no debe redondearlos a fracciones comunes, ya que esto agregar√° un error. <br><br>  Los c√≥decs de video tradicionalmente no pueden permitirse realizar tales operaciones.  Las operaciones de punto flotante en tareas "pesadas" como la compensaci√≥n de movimiento son simplemente imposibles de usar en equipos especializados o de baja potencia.  Esto es <i>especialmente</i> cierto si estamos hablando de c√≥decs est√°ndar de la industria que deber√≠an ejecutarse en una amplia gama de dispositivos, incluidos chips integrados de bajo costo y bajo costo. <br><br>  Adem√°s, incluso si los ejecuta en la CPU, los conjuntos de instrucciones modernos se basan en SIMD, es decir, las operaciones de enteros en la CPU a√∫n se pueden realizar m√°s r√°pido: puede colocar dos enteros de 16 bits en el espacio de un flotante de 32 bits, esencialmente duplicando el rendimiento de las operaciones, por lo tanto, si consideramos el n√∫mero exacto de ciclos por operaci√≥n, un punto flotante no siempre es la opci√≥n m√°s r√°pida. <br><br>  Ahora puede ver por qu√© esta caracter√≠stica era importante.  Como solo necesitaba operaciones enteras simples de 16 bits, busqu√© los n√∫cleos que se pueden expresar como enteros peque√±os sobre divisores en el poder de dos a 64 y no m√°s.  Este es un conjunto de filtros mucho m√°s limitado en comparaci√≥n con si estuviera considerando <i>cualquier</i> conjunto de 6 coeficientes de coma flotante. <br><br>  Del mismo modo, por razones de eficiencia, no consider√© ning√∫n <i>otro</i> n√∫mero de muestras.  La √∫nica opci√≥n era 6 o menos, por lo que ni siquiera prob√© versiones con 8 o 10 muestras. <br><br>  As√≠ llegamos a la primera respuesta: "probablemente no".  Si nos adherimos a estas restricciones, lo m√°s probable es que no encontremos un mejor filtro que pueda aplicarse infinitas veces sin degradaci√≥n.  El n√∫cleo del filtro de la primera parte es <i>probablemente el</i> mejor que podemos encontrar, aunque debe admitirse que no puedo probarlo exhaustivamente. <br><br>  Pero, ¬øqu√© pasa si <i>no necesitamos</i> adherirnos a tales restricciones? <br><br><h2>  Versi√≥n de punto flotante </h2><br>  Si nos deshacemos de las limitaciones espec√≠ficas de la versi√≥n original de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bink 2</a> (que ahora est√° bastante desactualizada, desde entonces se han lanzado muchas revisiones) y utilizamos coeficientes arbitrarios de punto flotante, ¬øc√≥mo podemos mejorar los resultados? <br><br>  Bueno, dado que sabemos que mi n√∫cleo entero nunca se degrada, y sabemos que Lanczos es m√°s agudo, pero se degrada, es l√≥gico que podamos encontrar un lugar <i>entre los</i> dos conjuntos de coeficientes donde comienza la degradaci√≥n.  Entonces escrib√≠ un programa que me ayud√≥ a encontrar este punto en particular, y esto es lo que encontr√©: <br><br><pre> <code class="cpp hljs">MyFloatKernel6[] = {<span class="hljs-number"><span class="hljs-number">0.027617</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.027617</span></span>};</code> </pre> <br>  Este n√∫cleo requiere 272 iteraciones para converger, pero es infinitamente estable y se ve <i>mucho</i> m√°s n√≠tido que mi filtro entero: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/855/81c/e4885581cec995e7aabc0a845ac92868.png" width="1016" height="284"></div><br>  De hecho, es casi indistinguible del original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Casi ... pero no del todo.  Si observa de cerca, a√∫n puede ver desenfoque y atenuaci√≥n en √°reas de alto contraste.  La forma m√°s f√°cil de ver esto es en el ojo de un "dinosaurio" naranja y en √°reas de luz brillante detr√°s del bamb√∫. <br><br>  Es decir, un filtro de punto flotante de 6 muestras es definitivamente mejor, pero no es perfecto.  ¬øSe puede mejorar todav√≠a? <br><br><h2>  Aumentar el ancho del filtro </h2><br>  Inicialmente, se seleccion√≥ un filtro con 6 muestras por las mismas razones que las fracciones con enteros peque√±os: estaba buscando un filtro extremadamente eficiente.  Pero ahora estamos investigando y ya hemos pasado a n√∫meros de coma flotante, entonces, ¬øpor qu√© no considerar un filtro m√°s amplio? <br><br>  Combinando nuestro filtro entero de 6 muestras con los Lanczos de 6 muestras, obtuvimos un muy buen filtro.  ¬øPor qu√© no lo combinamos con los Lanczos de 8 muestras? <br><br>  El Lanczos de 8 muestras se ve as√≠: <br><br><pre> <code class="cpp hljs">Lanczos8[] = {<span class="hljs-number"><span class="hljs-number">-0.01263</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.01263</span></span>};</code> </pre> <br>  Al igual que los Lanczos de 6 muestras, es muy inestable y se derrumba despu√©s de 178 iteraciones: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c5/38f/1c6/2c538f1c656fbd96798b8e3a82205c11.png" width="1016" height="284"></div><br>  Si buscamos un mejor filtro entre un filtro entero de 6 muestras y un Lanczos de 8 muestras, encontraremos este filtro de 8 muestras bastante notable: <br><br><pre> <code class="cpp hljs">MyFloatKernel8[] = {<span class="hljs-number"><span class="hljs-number">-0.010547</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.010547</span></span>};</code> </pre> <br>  Como filtro infinitamente estable, funciona incre√≠blemente bien.  Converge despu√©s de 202 iteraciones (la convergencia es m√°s r√°pida que mis dos filtros), y se parece tanto al original que es dif√≠cil distinguir cu√°l de ellos es cu√°l: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" width="1016" height="284"></div><br>  Aqu√≠ est√° el original para referencia nuevamente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  En comparaci√≥n con mi filtro entero original, hay una mejora significativa. <br><br><h2>  ¬øC√≥mo funcionan los filtros infinitamente estables? </h2><br>  Iba a terminar esta publicaci√≥n algo como esto: <br><br>  "No s√© exactamente c√≥mo funciona todo.  En otras √°reas donde he trabajado con las transformaciones infinitamente aplicables, s√© c√≥mo se realizan las matem√°ticas l√≠mite y se crea un an√°lisis √∫til.  En primer lugar, se trata del an√°lisis de la superficie l√≠mite para las superficies de subdivisi√≥n, donde se calculan los valores propios y los vectores propios de la matriz de subdivisi√≥n, despu√©s de lo cual es posible llevar con precisi√≥n el l√≠mite a un grado infinito.  Pero no tengo experiencia en realizar un an√°lisis de este tipo para los filtros halfpel, porque no dejan p√≠xeles en su lugar, sino que los desplazan de lado ". <br><br>  Ese era mi plan.  Pero entre la redacci√≥n de la primera y la segunda parte, envi√© los resultados del filtro mejorado a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fabien Giessen</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Charles Bloom</a> .  No es sorprendente que supieran las matem√°ticas necesarias para el estudio anal√≠tico de este problema.  Result√≥ que para los filtros realmente hay un an√°lisis de valores propios y vectores, pero no funciona de esa manera. <br><br>  Pero se <i>puede hacer</i> f√°cilmente; de ‚Äã‚Äãhecho, est√° integrado en los programas CAM como un proceso trivial de un solo paso y realmente podemos ver los valores propios de los filtros.  No nos da respuestas completas, porque aqu√≠ el hecho de <i>redondear</i> (o truncar) a 8 bits (o 10 bits, o 12 bits) despu√©s de cada filtrado es importante, porque el truncamiento afecta el m√©todo de acumular errores en comparaci√≥n con el √°lgebra infinitamente precisa. <br><br>  Desafortunadamente, dado que esta no es mi √°rea de especializaci√≥n, ni siquiera puedo obtener una visi√≥n general de este an√°lisis.  Le pregunt√© a Fabien y Charles si pod√≠an escribir publicaciones con la buena informaci√≥n que me enviaron por correo (ambos tienen blogs t√©cnicos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el blog</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ryg</a> y los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comentarios de cbloom</a> ), y Fabien escribi√≥ una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">excelente serie de art√≠culos sobre los fundamentos matem√°ticos de los filtros estables</a> .  Si est√°s interesado en la estructura te√≥rica de lo que est√° sucediendo en mis dos publicaciones, ¬°te recomiendo leer esta serie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468629/">https://habr.com/ru/post/468629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468615/index.html">Los 10 idiomas principales para la localizaci√≥n de aplicaciones</a></li>
<li><a href="../468621/index.html">Traducimos la red dom√©stica a DoH u otro clic en el filtro de nariz</a></li>
<li><a href="../468623/index.html">Quiero comentarios sobre Habr</a></li>
<li><a href="../468625/index.html">Sin servidor: 15% m√°s lento y ocho veces m√°s caro</a></li>
<li><a href="../468627/index.html">M√≥dulos de E / S ADAM-6200</a></li>
<li><a href="../468635/index.html">Dichalcogenuros de metales de transici√≥n: descubriendo los secretos del crecimiento cristalino de WS2</a></li>
<li><a href="../468637/index.html">C√≥mo manejar grandes conjuntos de datos en pandas. Trabajamos con la base de datos FIAS usando Python y 8GB de memoria.</a></li>
<li><a href="../468639/index.html">Novedades de las consolas web 2019</a></li>
<li><a href="../468645/index.html">Dos p√°ginas fueron suficientes para probar la hip√≥tesis de 30 a√±os del campo de la inform√°tica.</a></li>
<li><a href="../468647/index.html">M√∫sica arriesgada en una vieja impresora de l√≠nea de mainframe de IBM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>