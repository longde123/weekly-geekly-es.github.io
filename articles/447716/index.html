<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöΩ üë¥ ü§πüèº Unidad: dibuja muchas barras de salud en una sola llamada üë¶üèΩ ü§òüèæ üôÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, necesitaba resolver un problema que es bastante com√∫n en muchos juegos con una vista superior: representar en la pantalla un mont√≥n de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unidad: dibuja muchas barras de salud en una sola llamada</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447716/">  Recientemente, necesitaba resolver un problema que es bastante com√∫n en muchos juegos con una vista superior: representar en la pantalla un mont√≥n de barras de salud enemigas.  Algo como esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/081/95e/14e08195e0e331c7f24a8ba50c556d7e.png"></div><br>  Obviamente, quer√≠a hacer esto de la manera m√°s eficiente posible, preferiblemente en una llamada de sorteo.  Como de costumbre, antes de comenzar a trabajar, hice una peque√±a investigaci√≥n en l√≠nea sobre las decisiones de otras personas, y los resultados fueron muy diferentes. <br><br>  No avergonzar√© a nadie por el c√≥digo, pero basta con decir que algunas de las soluciones no fueron del todo brillantes, por ejemplo, alguien agreg√≥ un objeto Canvas a cada enemigo (lo cual es muy ineficiente). <br><br>  El m√©todo al que llegu√© como resultado es ligeramente diferente de todo lo que he visto con otros, y no utiliza ninguna clase de IU (incluido Canvas), as√≠ que decid√≠ documentarlo para el p√∫blico.  Y para aquellos que quieran aprender el c√≥digo fuente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lo publiqu√© en Github</a> . <br><a name="habracut"></a><br><h2>  ¬øPor qu√© no usar Canvas? </h2><br>  Un lienzo para cada enemigo es obviamente una mala decisi√≥n, pero podr√≠a usar un lienzo com√∫n para todos los enemigos;  un solo Canvas tambi√©n llevar√≠a a procesar el procesamiento por lotes de llamadas. <br><br>  Sin embargo, no me gusta la cantidad de trabajo realizado en cada marco relacionado con este enfoque.  Si usa Canvas, en cada cuadro debe realizar las siguientes operaciones: <br><br><ul><li>  Determine cu√°les de los enemigos est√°n en la pantalla y seleccione cada uno de ellos en la tira de la interfaz de usuario del grupo. </li><li>  Proyecte la posici√≥n del enemigo en la c√°mara para colocar la tira. </li><li>  Cambie el tama√±o de la parte de "relleno" de la tira, probablemente como Imagen. </li><li>  Lo m√°s probable es que cambie el tama√±o de las tiras de acuerdo con el tipo de enemigos;  por ejemplo, los enemigos grandes deben tener tiras grandes para que no se vea tonto. </li></ul><br>  De todos modos, todo esto contaminar√≠a los b√∫feres de geometr√≠a de Canvas y conducir√≠a a una reconstrucci√≥n de todos los datos de v√©rtices en el procesador.  No quer√≠a que todo esto se hiciera por un elemento tan simple. <br><br><h2>  Brevemente sobre mi decisi√≥n </h2><br>  Una breve descripci√≥n de mi proceso de trabajo: <br><br><ul><li>  Adjuntamos objetos de tiras de energ√≠a a los enemigos en 3D. <br><ul><li>  Esto le permite organizar y recortar autom√°ticamente las tiras. </li><li>  La posici√≥n / tama√±o de la tira se puede ajustar seg√∫n el tipo de enemigo. </li><li>  Dirigiremos las rayas a la c√°mara en el c√≥digo usando transform, que todav√≠a est√° all√≠. </li><li>  El sombreador garantiza que siempre se renderice por encima de todo. </li></ul></li><li>  Usamos Instancing para representar todas las tiras en una sola llamada de sorteo. </li><li>  Utilizamos simples coordenadas UV de procedimiento para mostrar el nivel de plenitud de la tira. </li></ul><br>  Ahora veamos la soluci√≥n con m√°s detalle. <br><br><h2>  ¬øQu√© es la instancia? </h2><br>  Al trabajar con gr√°ficos, la t√©cnica est√°ndar se ha utilizado durante mucho tiempo: varios objetos se combinan entre s√≠ para que tengan datos y materiales de v√©rtice comunes y se puedan representar en una sola llamada de dibujo.  Esto es exactamente lo que necesitamos, porque cada llamada de sorteo es una carga adicional en la CPU y la GPU.  En lugar de hacer una sola llamada de dibujo para cada objeto, los procesamos todos al mismo tiempo y usamos un sombreador para agregar variabilidad a cada copia. <br><br>  Puede hacer esto manualmente duplicando los datos del v√©rtice de malla X veces en un b√∫fer, donde X es el n√∫mero m√°ximo de copias que se pueden representar, y luego usando la matriz de par√°metros de sombreado para convertir / colorear / variar cada copia.  Cada copia debe almacenar el conocimiento sobre qu√© instancia numerada es, para usar este valor como √≠ndice de la matriz.  Entonces podemos usar una llamada de renderizaci√≥n indexada que ordena "renderizar solo a N", donde N es el n√∫mero de instancias que <em>realmente se</em> necesita en el marco actual, menos que el n√∫mero m√°ximo de X. <br><br>  La mayor√≠a de las API modernas ya tienen c√≥digo para esto, por lo que no es necesario que lo haga manualmente.  Esta operaci√≥n se llama "Instancing";  de hecho, automatiza el proceso descrito anteriormente con restricciones predefinidas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El motor de Unity tambi√©n admite instancias</a> , tiene su propia API y un conjunto de macros de sombreado que ayudan en su implementaci√≥n.  Utiliza ciertos supuestos, por ejemplo, que cada instancia requiere una transformaci√≥n 3D completa.  Estrictamente hablando, para las tiras 2D no es necesario por completo, podemos hacerlo con simplificaciones, pero como lo son, las usaremos.  Esto simplificar√° nuestro sombreador y tambi√©n proporcionar√° la capacidad de usar indicadores 3D, por ejemplo, c√≠rculos o arcos. <br><br><h2>  Clase da√±able </h2><br>  Nuestros enemigos tendr√°n un componente llamado <code>Damageable</code> , que les dar√° salud y les permitir√° sufrir da√±os por colisiones.  En nuestro ejemplo, es bastante simple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Damageable</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxHealth; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceThreshold = <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceScale = <span class="hljs-number"><span class="hljs-number">5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentHealth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentHealth = MaxHealth; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCollisionEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collision other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Collision would usually be on another component, putting it all here for simplicity float force = other.relativeVelocity.magnitude; if (force &gt; DamageForceThreshold) { CurrentHealth -= (int)((force - DamageForceThreshold) * DamageForceScale); CurrentHealth = Mathf.Max(0, CurrentHealth); } } }</span></span></code> </pre> <br><h2>  Objeto HealthBar: posici√≥n / giro </h2><br>  El objeto de la barra de salud es muy simple: de hecho, es solo un Quad conectado al enemigo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/2ef/6e2/be52ef6e247fca661f9136e2835bb5dc.png"><br><br>  Usamos la <strong>escala de</strong> este objeto para hacer que la tira sea larga y delgada, y colocarla directamente sobre el enemigo.  No se preocupe por su rotaci√≥n, lo arreglaremos utilizando el c√≥digo adjunto al objeto en <code>HealthBar.cs</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlignCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mainCamera != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camXform = mainCamera.transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> forward = transform.position - camXform.position; forward.Normalize(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> up = Vector3.Cross(forward, camXform.right); transform.rotation = Quaternion.LookRotation(forward, up); } }</code> </pre> <br>  Este c√≥digo siempre dirige el quad hacia la c√°mara.  Podemos realizar cambios de tama√±o y rotaci√≥n en el sombreador, pero los implemento aqu√≠ por dos razones. <br><br>  En primer lugar, la creaci√≥n de instancias de Unity siempre usa la transformaci√≥n completa de cada objeto, y dado que transferimos todos los datos de todos modos, puede usarla.  En segundo lugar, establecer la escala / rotaci√≥n aqu√≠ asegura que el paralelogramo delimitador para recortar la tira siempre ser√° verdadero.  Si hici√©ramos la tarea de tama√±o y rotaci√≥n la responsabilidad del sombreador, entonces Unity podr√≠a truncar las tiras que deber√≠an ser visibles cuando est√°n cerca de los bordes de la pantalla, porque el tama√±o y la rotaci√≥n de su paralelogramo delimitador no corresponder√°n a lo que vamos a renderizar.  Por supuesto, podr√≠amos implementar nuestro propio m√©todo de truncamiento, pero generalmente es mejor usar lo que tenemos si es posible (el c√≥digo de Unity es nativo y tiene acceso a m√°s datos espaciales que nosotros). <br><br>  Explicar√© c√≥mo se procesa la tira despu√©s de mirar el sombreador. <br><br><h2>  Shader HealthBar </h2><br>  En esta versi√≥n, crearemos una simple tira cl√°sica rojo-verde. <br><br>  Utilizo una textura 2x1 con un p√≠xel verde a la izquierda y uno rojo a la derecha.  Naturalmente, desactiv√© mipmapping, filtrado y compresi√≥n, y configur√© el par√°metro del modo de direccionamiento en Clamp, lo que significa que los p√≠xeles en nuestra tira siempre ser√°n perfectamente verdes o rojos, y no se extender√°n por los bordes.  Esto nos permitir√° cambiar las coordenadas de textura en el sombreador para desplazar la l√≠nea que divide los p√≠xeles rojo y verde hacia abajo y hacia arriba de la tira. <br><br>  <em>(Dado que solo hay dos colores aqu√≠, podr√≠a usar la funci√≥n de paso en el sombreador para volver al punto de uno u otro. Sin embargo, este m√©todo es conveniente porque puede usar una textura m√°s compleja si lo desea, y esto funcionar√° de manera similar mientras la transici√≥n est√© en textura media)</em> <br><br>  Primero, declararemos las propiedades que necesitamos: <br><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"UI/HealthBar"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Fill (<span class="hljs-string"><span class="hljs-string">"Fill"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  <code>_MainTex</code> es una textura rojo-verde, y <code>_Fill</code> es un valor de 0 a 1, donde 1 es salud completa. <br><br>  A continuaci√≥n, debemos ordenar que la tira se renderice en la cola de superposici√≥n, lo que significa ignorar toda la profundidad de la escena y renderizar encima de todo: <br><br><pre> <code class="cpp hljs"> SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Overlay"</span></span> } Pass { ZTest Off</code> </pre> <br>  La siguiente parte es el c√≥digo del sombreador en s√≠.  Estamos escribiendo un sombreador sin iluminaci√≥n (apagado), por lo que no debemos preocuparnos por la integraci√≥n con varios sombreadores de superficie Unity, este es un par simple de sombreadores de v√©rtices / fragmentos.  Primero, escribe bootstrap: <br><br><pre> <code class="cpp hljs"> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vertex vert #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fragment frag #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile_instancing #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityCG.cginc"</span></span></span></span></code> </pre> <br>  En su mayor parte, este es un programa de arranque est√°ndar, con la excepci√≥n de <code>#pragma multi_compile_instancing</code> , que le dice al compilador de Unity qu√© debe compilarse para la Instancia. <br><br>  La estructura del v√©rtice debe incluir datos de instancia, por lo que haremos lo siguiente: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">appdata</span></span></span><span class="hljs-class"> {</span></span> float4 vertex : POSITION; float2 uv : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID };</code> </pre> <br>  Tambi√©n debemos especificar qu√© ser√° exactamente en los datos de las instancias, adem√°s de los procesos de Unity (transformaci√≥n) para nosotros: <br><br><pre> <code class="cpp hljs"> UNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, _Fill) UNITY_INSTANCING_BUFFER_END(Props)</code> </pre> <br>  Por lo tanto, informamos que Unity debe crear un b√∫fer llamado "Props" para almacenar los datos de cada instancia, y dentro de √©l utilizaremos un flotante por instancia para una propiedad llamada <code>_Fill</code> . <br><br>  Puede usar varios tampones;  vale la pena hacerlo si tiene varias propiedades actualizadas a diferentes frecuencias;  dividi√©ndolos, puede, por ejemplo, no cambiar un b√∫fer cuando se cambia otro, lo cual es m√°s eficiente.  Pero no necesitamos esto. <br><br>  Nuestro sombreador de v√©rtices hace casi completamente el trabajo est√°ndar, porque el tama√±o, la posici√≥n y la rotaci√≥n ya se transfieren para transformar.  Esto se implementa utilizando <code>UnityObjectToClipPos</code> , que utiliza autom√°ticamente la transformaci√≥n de cada instancia.  Uno podr√≠a imaginar que, sin instancias, esto normalmente ser√≠a un uso simple de una propiedad de matriz √∫nica.  pero cuando se usa la creaci√≥n de instancias dentro del motor, parece una matriz de matrices, y Unity selecciona independientemente una matriz adecuada para esta instancia. <br><br>  Adem√°s, debe cambiar UV para cambiar la ubicaci√≥n del punto de transici√≥n de rojo a verde de acuerdo con la propiedad <code>_Fill</code> .  Aqu√≠ est√° el fragmento de c√≥digo relevante: <br><br><pre> <code class="cpp hljs"> UNITY_SETUP_INSTANCE_ID(v); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fill = UNITY_ACCESS_INSTANCED_PROP(Props, _Fill); <span class="hljs-comment"><span class="hljs-comment">// generate UVs from fill level (assumed texture is clamped) o.uv = v.uv; o.uv.x += 0.5 - fill;</span></span></code> </pre> <br>  <code>UNITY_SETUP_INSTANCE_ID</code> y <code>UNITY_ACCESS_INSTANCED_PROP</code> hacen toda la magia accediendo a la versi√≥n deseada de la propiedad <code>_Fill</code> desde el b√∫fer constante para esta instancia. <br><br>  Sabemos que en el estado normal, las coordenadas UV del cuadrante cubren todo el intervalo de textura, y que la l√≠nea divisoria de la tira est√° en el medio de la textura horizontalmente.  Por lo tanto, peque√±os c√°lculos matem√°ticos desplazan horizontalmente la tira hacia la izquierda o hacia la derecha, y el valor de sujeci√≥n de la textura garantiza el relleno de la parte restante. <br><br>  El sombreador de fragmentos no podr√≠a ser m√°s simple porque todo el trabajo ya est√° hecho: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, i.uv);</code> </pre> <br>  El c√≥digo completo del sombreador de comentarios est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el repositorio de GitHub</a> . <br><br><h2>  Material de barra de salud </h2><br>  Entonces todo es simple: solo tenemos que asignar a nuestra tira el material que utiliza este sombreador.  Casi no se necesita hacer nada m√°s, solo seleccione el sombreador deseado en la parte superior, asigne una textura rojo-verde y, lo m√°s importante, <strong>marque la casilla "Habilitar la instalaci√≥n de GPU"</strong> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06e/6e0/dcd/06e6e0dcd1965aa73f1dbbcf64e90a22.png" alt="imagen"><br><br><h2>  Actualizaci√≥n de propiedades de relleno de HealthBar </h2><br>  Entonces, tenemos el objeto de la barra de salud, el sombreador y el material que se representar√°, ahora necesitamos establecer la propiedad <code>_Fill</code> para cada instancia.  Hacemos esto dentro de <code>HealthBar.cs</code> siguiente manera: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateParams</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { meshRenderer.GetPropertyBlock(matBlock); matBlock.SetFloat(<span class="hljs-string"><span class="hljs-string">"_Fill"</span></span>, damageable.CurrentHealth / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)damageable.MaxHealth); meshRenderer.SetPropertyBlock(matBlock); }</code> </pre> <br>  <code>CurrentHealth</code> el <code>CurrentHealth</code> clase <code>CurrentHealth</code> en un valor de 0 a 1, dividi√©ndolo por <code>MaxHealth</code> .  Luego lo pasamos a la propiedad <code>_Fill</code> usando <code>MaterialPropertyBlock</code> . <br><br>  Si no ha utilizado <code>MaterialPropertyBlock</code> para transferir datos a sombreadores, incluso sin crear instancias, debe estudiarlo.  No est√° bien explicado en la documentaci√≥n de Unity, pero es la forma m√°s eficiente de transferir datos de cada objeto a los sombreadores. <br><br>  En nuestro caso, cuando se usa la creaci√≥n de instancias, los valores para todas las barras de salud se empaquetan en un b√∫fer constante para que puedan transferirse todos juntos y dibujarse a la vez. <br><br>  Aqu√≠ no hay casi nada, excepto una placa repetitiva para establecer variables, y el c√≥digo es bastante aburrido;  vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el repositorio de GitHub para m√°s</a> detalles. <br><br><h2>  Demo </h2><br>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio de GitHub</a> tiene una demostraci√≥n de prueba en la que un mont√≥n de cubos azules malvados son destruidos por heroicas esferas rojas (¬°hurra!), Tomando el da√±o que muestran las rayas descritas en el art√≠culo.  Demo escrita en Unity 2018.3.6f1. <br><br>  El efecto del uso de instancias se puede observar de dos maneras: <br><br><h3>  Panel de estad√≠sticas </h3><br>  Despu√©s de hacer clic en Reproducir, haz clic en el bot√≥n de Estad√≠sticas arriba del panel de Juego.  Aqu√≠ puede ver cu√°ntas llamadas de sorteo se guardan gracias a la instancia: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/f25/204/ad0f25204bb3daf73a2c3700fd185938.png" alt="imagen"><br><br>  Despu√©s de iniciar el juego, puede hacer clic en el material HealthBar y <em>desmarcar la casilla de verificaci√≥n</em> "Habilitar la instalaci√≥n de GPU", despu√©s de lo cual el n√∫mero de llamadas guardadas se reducir√° a cero. <br><br><h3>  Depurador de trama </h3><br>  Despu√©s de iniciar el juego, ve a Ventana&gt; An√°lisis&gt; Depurador de cuadros, y luego haz clic en "Habilitar" en la ventana que aparece. <br><br>  En la parte inferior izquierda ver√° todas las operaciones de renderizado realizadas.  Tenga en cuenta que si bien hay muchos desaf√≠os separados para enemigos y proyectiles (si lo desea, tambi√©n puede implementar instancias para ellos).  Si te desplazas hacia la parte inferior, ver√°s el elemento "Barra de salud Dibujar malla (instanciada)". <br><br>  Esta llamada individual representa todas las tiras.  Si hace clic en esta operaci√≥n y luego en la operaci√≥n, ver√° que todas las tiras desaparecen, ya que se dibujan en una sola llamada.  Si est√° en el Depurador de tramas, desmarca la casilla de verificaci√≥n Habilitar la instalaci√≥n de GPU del material, ver√° que una l√≠nea se convirti√≥ en varias, y despu√©s de configurar la bandera nuevamente en una. <br><br><h2>  C√≥mo expandir este sistema </h2><br>  Como dije antes, dado que estas barras de salud son objetos reales, no hay nada que te impida convertir simples barras 2D en algo m√°s complejo.  Pueden ser semic√≠rculos bajo enemigos que disminuyen en un arco, o rombos giratorios sobre sus cabezas.  Con el mismo enfoque, a√∫n puede procesarlos todos en una sola llamada. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447716/">https://habr.com/ru/post/447716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447704/index.html">Climbing Elbrus - Reconocimiento en batalla. Parte t√©cnica 1. Registros, pilas y otros detalles t√©cnicos.</a></li>
<li><a href="../447706/index.html">Ni un solo ORM</a></li>
<li><a href="../447708/index.html">Yandex present√≥ a los j√≥venes cient√≠ficos y l√≠deres cient√≠ficos los primeros premios Ilya Segalovich</a></li>
<li><a href="../447712/index.html">Hola SaaS | Rusia SaaS 2018 - resultados</a></li>
<li><a href="../447714/index.html">Sobre la aplicaci√≥n de la teor√≠a de los procesos ARMA en la pr√°ctica de la ingenier√≠a.</a></li>
<li><a href="../447718/index.html">Todo ir√° de acuerdo al plan</a></li>
<li><a href="../447720/index.html">Seguridad de IoT. Problema 2. Hogar inteligente</a></li>
<li><a href="../447724/index.html">C√≥mo surgen las ciudades inteligentes</a></li>
<li><a href="../447728/index.html">Calculamos el presupuesto de energ√≠a de una l√≠nea de radio para un sat√©lite en formato CubeSat</a></li>
<li><a href="../447730/index.html">La evoluci√≥n del marketing por correo electr√≥nico: de QWERTYUIOP a GDPR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>