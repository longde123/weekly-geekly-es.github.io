<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëö üëãüèª üî• OpenSceneGraph: No√ß√µes b√°sicas de textura üë§ üé¢ üë©üèæ‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 J√° examinamos um exemplo em que eles pintaram um quadrado em todas as cores do arco-√≠ris. No entanto, existe outra tecnologia, a aplic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: No√ß√µes b√°sicas de textura</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437624/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagem"><br><br><h1>  1. Introdu√ß√£o </h1><br>  J√° examinamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo em</a> que eles pintaram um quadrado em todas as cores do arco-√≠ris.  No entanto, existe outra tecnologia, a aplica√ß√£o √† geometria tridimensional do chamado <em>mapa de textura</em> ou apenas textura - uma imagem raster bidimensional.  Nesse caso, o efeito n√£o est√° nos v√©rtices da geometria, mas os dados de todos os pixels obtidos durante a rasteriza√ß√£o da cena s√£o alterados.  Essa t√©cnica pode aumentar significativamente o realismo e os detalhes da imagem final. <br><br>  O OSG suporta v√°rios atributos de textura e modos de texturiza√ß√£o.  Mas, antes de falar sobre texturas, vamos falar sobre como o OSG lida com imagens de bitmap.  Para trabalhar com imagens raster, √© fornecida uma classe especial - osg :: Image, que armazena dados de imagem dentro dela, destinados, em √∫ltima an√°lise, √† texturiza√ß√£o do objeto. <br><a name="habracut"></a><br><h1>  1. Apresenta√ß√£o de dados de imagem raster.  Classe Osg :: Imagem </h1><br>  A melhor maneira de carregar uma imagem do disco √© usar a chamada osgDB :: readImageFile ().  √â muito semelhante √† chamada osg :: readNodeFile (), que j√° nos aborreceu.  Se tivermos um bitmap chamado picture.bmp, o carregamento ser√° parecido com este <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>);</code> </pre> <br>  Se a imagem for carregada corretamente, o ponteiro ser√° v√°lido; caso contr√°rio, a fun√ß√£o retornar√° NULL.  Ap√≥s o download, podemos obter informa√ß√µes da imagem usando os seguintes m√©todos p√∫blicos <br><br><ol><li>  t (), s () er () - retorna a largura, altura e profundidade da imagem. <br></li><li>  data () - retorna um ponteiro do tipo char n√£o assinado * para os dados da imagem "brutos".  Atrav√©s desse ponteiro, o desenvolvedor pode atuar diretamente nos dados da imagem.  Voc√™ pode ter uma id√©ia do formato dos dados da imagem usando os m√©todos getPixalFormat () e getDataType ().  Os valores retornados por eles s√£o equivalentes aos par√¢metros do formato e tipo das fun√ß√µes do OpenGL glTexImage * ().  Por exemplo, se a imagem tiver o formato de pixel GL_RGB e o tipo for GL_UNSIGNED_BYTE, tr√™s elementos independentes (bytes n√£o assinados) ser√£o usados ‚Äã‚Äãpara representar o componente de cor RGB <br></li></ol><br><img src="https://habrastorage.org/webt/6g/mo/or/6gmoorwfvryg44pq7sdi0cb4l9s.png"><br><br>  Voc√™ pode criar um novo objeto de imagem e alocar mem√≥ria para ele. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Image; image-&gt;allocateImage(s, t, r, GL_RGB, GL_UNSIGNED_BYTE); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = image-&gt;data(); <span class="hljs-comment"><span class="hljs-comment">//        </span></span></code> </pre><br>  Aqui s, t, r s√£o tamanhos de imagem;  GL_RGB define o formato de pixel e GL_UNSIGNED_BYTE define o tipo de dados para descrever um √∫nico componente de cor.  Um buffer de dados interno do tamanho necess√°rio √© alocado na mem√≥ria e √© destru√≠do automaticamente se n√£o houver um √∫nico link para esta imagem. <br><br>  O sistema de plug-in OSG suporta o download de quase todos os formatos populares de imagem: * .jpg, * .bmp, * .png, * .tif e assim por diante.  √â f√°cil expandir essa lista escrevendo seu pr√≥prio plug-in, mas este √© um t√≥pico para outra discuss√£o. <br><br><h1>  2. O b√°sico da texturiza√ß√£o </h1><br>  Para aplicar textura a um modelo tridimensional, voc√™ precisa executar v√°rias etapas: <br><br><ol><li>  Defina as coordenadas de textura dos v√©rtices para o objeto geom√©trico (no ambiente de designers 3D, isso √© chamado de varredura UV). <br></li><li>  Crie um objeto de atributo de textura para textura 1D, 2D, 3D ou c√∫bica. <br></li><li>  Defina uma ou mais imagens para um atributo de textura. <br></li><li>  Anexe um atributo e modo de textura ao conjunto de estados aplicados ao objeto que est√° sendo desenhado. <br></li></ol><br>  OSG define a classe osg :: Texture, que encapsula todos os tipos de texturas.  As subclasses osg :: Texture1D, osg :: Texture2D, osg :: Texture3D e osg :: TextureCubeMap s√£o herdadas dele, o que representa v√°rias t√©cnicas de texturiza√ß√£o adotadas no OpenGL. <br><br>  O m√©todo mais comum da classe osg :: Texture √© setImage (), que define a imagem usada na textura, por exemplo <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>); osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; texture-&gt;setImage(image.get());</code> </pre><br>  ou, voc√™ pode passar o objeto de imagem diretamente para o construtor da classe de textura <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>); osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D(image.get());</code> </pre><br>  A imagem pode ser recuperada do objeto de textura chamando o m√©todo getImage (). <br><br>  Outro ponto importante √© definir as coordenadas da textura para cada v√©rtice no objeto osg :: Geometry.  A transfer√™ncia dessas coordenadas ocorre atrav√©s da matriz osg :: Vec2Array e osg :: Vec3Array chamando o m√©todo setTexCoordArray (). <br><br>  Ap√≥s definir as coordenadas da textura, precisamos definir o n√∫mero do slot da textura (unidade), pois o OSG suporta a sobreposi√ß√£o de v√°rias texturas na mesma geometria.  Ao usar uma √∫nica textura, o n√∫mero da unidade √© sempre 0. Por exemplo, o c√≥digo a seguir ilustra a configura√ß√£o das coordenadas da textura para a unidade 0 da geometria <br><br><pre> <code class="cpp hljs">osf::ref_ptr&lt;osg::Vec2Array&gt; texcoord = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoord-&gt;push_back( osg::Vec2(...) ); ... geom-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoord.get());</code> </pre><br>  Depois disso, podemos adicionar o atributo de textura ao conjunto de estados, ativando automaticamente o modo de textura correspondente (no nosso exemplo GL_TEXTURE_2D) e aplicar o atributo √† geometria ou n√≥ que cont√©m essa geometria <br><br><pre> <code class="cpp hljs">geom-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(texture.get());</code> </pre><br>  Observe que o OpenGL gerencia os dados da imagem na mem√≥ria gr√°fica da placa de v√≠deo, mas o objeto osg :: Image, juntamente com os mesmos dados, est√° localizado na mem√≥ria do sistema.  Como resultado, encontraremos o fato de que armazenamos duas c√≥pias dos mesmos dados, ocupando a mem√≥ria do processo.  Se essa imagem n√£o for compartilhada por v√°rios atributos de textura, ela poder√° ser exclu√≠da da mem√≥ria do sistema imediatamente ap√≥s o OpenGL transferi-la para a mem√≥ria do adaptador de v√≠deo.  A classe osg :: Texture fornece o m√©todo apropriado para ativar esta fun√ß√£o. <br><br><pre> <code class="cpp hljs">texture-&gt;setUnRefImageDataAfterApply( <span class="hljs-literal"><span class="hljs-literal">true</span></span> );</code> </pre> <br><h1>  3. Carregue e aplique uma textura 2D </h1><br>  A t√©cnica mais usada √© a texturiza√ß√£o 2D - sobreposi√ß√£o de uma imagem bidimensional (ou imagens) na borda de uma superf√≠cie tridimensional.  Considere o exemplo mais simples de aplica√ß√£o de uma √∫nica textura a um pol√≠gono quadrangular <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de textura</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Texture2D&gt; #include &lt;osg/Geometry&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, 0.5f) ); vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, 0.5f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet( new osg::DrawArrays(GL_QUADS, 0, 4) ); osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile("../data/Images/lz.rgb"); texture-&gt;setImage(image.get()); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); root-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Crie uma matriz de v√©rtices e normais para a face <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) );</code> </pre><br>  Crie uma matriz de coordenadas de textura <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) );</code> </pre><br>  O ponto √© que cada v√©rtice do modelo tridimensional corresponde a um ponto na textura bidimensional e as coordenadas dos pontos na textura s√£o relativas - elas s√£o normalizadas para a largura e altura reais da imagem.  Queremos esticar a imagem inteira a ser carregada no quadrado, respectivamente, os cantos do quadrado corresponder√£o aos pontos de textura (0, 0), (0, 1), (1, 1) e (1, 0).  A ordem dos v√©rtices na matriz de v√©rtices deve corresponder √† ordem dos v√©rtices da textura. <br><br>  Em seguida, crie um quadrado, atribuindo √† geometria uma matriz de v√©rtices e uma matriz de normais <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoords.get()); quad-&gt;addPrimitiveSet( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) );</code> </pre><br>  Crie um objeto de textura e carregue a imagem usada para ele. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"../data/Images/lz.rgb"</span></span>); texture-&gt;setImage(image.get());</code> </pre><br>  Crie o n√≥ raiz da cena e coloque a geometria que criamos l√° <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get());</code> </pre><br>  e, finalmente, aplique o atributo texture ao n√≥ no qual a geometria √© colocada <br><br><pre> <code class="cpp hljs">root-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, texture.get());</code> </pre><br><img src="https://habrastorage.org/webt/wm/2a/fy/wm2afywfx6dnkhwaagvceqkycd8.png"><br><br>  A classe osg :: Texture2D determina se os tamanhos de imagem de textura s√£o m√∫ltiplos de uma pot√™ncia de dois (por exemplo, 64x64 ou 256x512), dimensionando automaticamente imagens inadequadas para o tamanho, na verdade usando a fun√ß√£o gluScaleImage () do OpenGL.  Existe um m√©todo setResizeNonPowerOfTwoHint () que determina se deve ou n√£o redimensionar a imagem.  Algumas placas de v√≠deo requerem um m√∫ltiplo do tamanho de uma imagem com a capacidade de duas, enquanto a classe osg :: Texture2D suporta o trabalho com um tamanho de textura arbitr√°rio. <br><br><h1>  Algo sobre a mistura de texturas </h1><br>  Como j√° dissemos, as coordenadas da textura s√£o normalizadas de 0 a 1. O ponto (0, 0) corresponde ao canto superior esquerdo da imagem e o ponto (1, 1) corresponde ao canto inferior direito.  O que acontece se voc√™ definir coordenadas de textura maiores que uma? <br><br>  Por padr√£o, no OpenGL, como no OSG, a textura ser√° repetida na dire√ß√£o do eixo, o valor da coordenada da textura exceder√° um.  Essa t√©cnica √© frequentemente usada, por exemplo, para criar um modelo de uma longa parede de tijolos, uso uma textura pequena, repetindo sua superposi√ß√£o muitas vezes tanto em largura quanto em altura. <br><br>  Esse comportamento pode ser controlado pelo m√©todo setWrap () da classe osg :: Texture.  Como primeiro par√¢metro, o m√©todo usa o identificador do eixo ao qual o modo de mesclagem deve ser aplicado, passado como o segundo par√¢metro, por exemplo <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     s texture-&gt;setWrap( osg::Texture::WRAP_S, osg::Texture::REPEAT ); //     r texture-&gt;setWrap( osg::Texture::WRAP_R, osg::Texture::REPEAT );</span></span></code> </pre><br>  Esse c√≥digo diz explicitamente ao mecanismo para repetir a textura ao longo dos eixos se er os valores das coordenadas da textura excederem 1. Uma lista completa dos modos de mapeamento de textura: <br><br><ol><li>  REPETIR - repita a textura. <br></li><li>  ESPELHO - repita a textura, espelhando-a. <br></li><li>  CLAMP_TO_EDGE - as coordenadas que v√£o al√©m de 0 a 1 s√£o ajustadas na borda correspondente da textura. <br></li><li>  CLAMP_TO_BORDER - coordenadas que v√£o al√©m de 0 a 1 fornecer√£o a cor da borda definida pelo usu√°rio. <br></li></ol><br><h1>  4. Renderiza√ß√£o para textura </h1><br>  A t√©cnica de renderiza√ß√£o de textura permite ao desenvolvedor criar uma textura com base em alguma subcena ou modelo tridimensional e aplic√°-la √† superf√≠cie na cena principal.  Uma tecnologia semelhante √© freq√ºentemente chamada de textura de cozimento. <br><br>  Para assar uma textura dinamicamente, voc√™ deve concluir tr√™s etapas: <br><br><ol><li>  Crie um objeto de textura para renderizar nele. <br></li><li>  Renderize a cena em uma textura. <br></li><li>  Use a textura resultante como pretendido. <br></li></ol><br>  N√≥s devemos criar um objeto de textura vazio.  O OSG permite criar uma textura vazia de um determinado tamanho.  O m√©todo setTextureSize () permite definir a largura e a altura da textura, bem como a profundidade como um par√¢metro adicional (para texturas 3D). <br><br>  Para renderizar em uma textura, voc√™ deve anex√°-lo ao objeto da c√¢mera chamando o m√©todo attach (), que aceita um objeto de textura como argumento.  Al√©m disso, esse m√©todo aceita um argumento indicando qual parte do buffer do quadro deve ser renderizada nessa textura.  Por exemplo, para transferir um buffer de cores para uma textura, voc√™ deve executar o seguinte c√≥digo <br><br><pre> <code class="cpp hljs">camera-&gt;attach( osg::Camera::COLOR_BUFFER, texture.get() );</code> </pre><br>  Outras partes do buffer de quadros dispon√≠veis para renderiza√ß√£o incluem o buffer de profundidade DEPTH_BUFFER, o buffer de est√™ncil STENCIL_BUFFER e buffers de cores adicionais de COLOR_BUFFER0 a COLOR_BUFFER15.  A presen√ßa de buffers de cores adicionais e seu n√∫mero √© determinado pelo modelo da placa de v√≠deo. <br><br>  Al√©m disso, para uma c√¢mera que √© renderizada em uma textura, voc√™ deve definir os par√¢metros da matriz de proje√ß√£o e da janela de visualiza√ß√£o, cujo tamanho corresponde ao tamanho da textura.  A textura ser√° atualizada √† medida que cada quadro √© desenhado.  Lembre-se de que a c√¢mera principal n√£o deve ser usada para renderizar uma textura, pois fornece a renderiza√ß√£o da cena principal e voc√™ apenas obt√©m uma tela preta.  Esse requisito pode n√£o ser atendido apenas quando voc√™ executa a renderiza√ß√£o fora da tela. <br><br><h1>  5. Um exemplo da implementa√ß√£o de renderiza√ß√£o em textura </h1><br>  Para demonstrar a t√©cnica de renderiza√ß√£o em uma textura, implementamos a seguinte tarefa: criar um quadrado, desenhar uma textura quadrada e renderizar uma cena animada na textura, √© claro com a cessna que amamos.  O programa que implementa o exemplo √© bastante volumoso.  No entanto, darei seu c√≥digo fonte completo de qualquer maneira. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de Texrender</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Camera&gt; #include &lt;osg/Texture2D&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/TrackballManipulator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Geometry *createQuad(const osg::Vec3 &amp;pos, float w, float h) { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( pos + osg::Vec3( w / 2, 0.0f, -h / 2) ); vertices-&gt;push_back( pos + osg::Vec3( w / 2, 0.0f, h / 2) ); vertices-&gt;push_back( pos + osg::Vec3(-w / 2, 0.0f, h / 2) ); vertices-&gt;push_back( pos + osg::Vec3(-w / 2, 0.0f, -h / 2) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); return quad.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; sub_model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::rotate(0.0, osg::Vec3(0.0f, 0.0f, 1.0f))); transform1-&gt;addChild(sub_model.get()); osg::ref_ptr&lt;osg::Geode&gt; model = new osg::Geode; model-&gt;addChild(createQuad(osg::Vec3(0.0f, 0.0f, 0.0f), 2.0f, 2.0f)); int tex_widht = 1024; int tex_height = 1024; osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; texture-&gt;setTextureSize(tex_widht, tex_height); texture-&gt;setInternalFormat(GL_RGBA); texture-&gt;setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR); texture-&gt;setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR); model-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture.get()); osg::ref_ptr&lt;osg::Camera&gt; camera = new osg::Camera; camera-&gt;setViewport(0, 0, tex_widht, tex_height); camera-&gt;setClearColor(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); camera-&gt;setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); camera-&gt;setRenderOrder(osg::Camera::PRE_RENDER); camera-&gt;setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT); camera-&gt;attach(osg::Camera::COLOR_BUFFER, texture.get()); camera-&gt;setReferenceFrame(osg::Camera::ABSOLUTE_RF); camera-&gt;addChild(transform1.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model.get()); root-&gt;addChild(camera.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.setCameraManipulator(new osgGA::TrackballManipulator); viewer.setUpViewOnSingleScreen(0); camera-&gt;setProjectionMatrixAsPerspective(30.0, static_cast&lt;double&gt;(tex_widht) / static_cast&lt;double&gt;(tex_height), 0.1, 1000.0); float dist = 100.0f; float alpha = 10.0f * 3.14f / 180.0f; osg::Vec3 eye(0.0f, -dist * cosf(alpha), dist * sinf(alpha)); osg::Vec3 center(0.0f, 0.0f, 0.0f); osg::Vec3 up(0.0f, 0.0f, -1.0f); camera-&gt;setViewMatrixAsLookAt(eye, center, up); float phi = 0.0f; float delta = -0.01f; while (!viewer.done()) { transform1-&gt;setMatrix(osg::Matrix::rotate(static_cast&lt;double&gt;(phi), osg::Vec3(0.0f, 0.0f, 1.0f))); viewer.frame(); phi += delta; } return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Para criar um quadrado, escreva uma fun√ß√£o livre separada <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Geometry *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createQuad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( pos + osg::Vec3( w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, -h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3( w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3(-w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3(-w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, -h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoords.get()); quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quad.release(); }</code> </pre><br>  A fun√ß√£o aceita a posi√ß√£o do centro do quadrado e suas dimens√µes geom√©tricas como entrada.  Em seguida, uma matriz de v√©rtices, uma matriz de normais e coordenadas de textura s√£o criadas, ap√≥s o qual a geometria criada √© retornada da fun√ß√£o. <br><br>  No corpo do programa principal, carregue o modelo de cessna <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; sub_model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Para animar esse modelo, crie e inicialize a transforma√ß√£o de rota√ß√£o em torno do eixo Z <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>))); transform1-&gt;addChild(sub_model.get());</code> </pre><br>  Agora crie um modelo para a cena principal - um quadrado no qual renderizaremos <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; model-&gt;addChild(createQuad(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>));</code> </pre><br>  Crie uma textura vazia para um quadrado de 1024x1024 pixels com um formato de pixel RGBA (cor de tr√™s componentes de 32 bits com canal alfa) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tex_widht = <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tex_height = <span class="hljs-number"><span class="hljs-number">1024</span></span>; osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; texture-&gt;setTextureSize(tex_widht, tex_height); texture-&gt;setInternalFormat(GL_RGBA); texture-&gt;setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR); texture-&gt;setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);</code> </pre><br>  Aplique essa textura ao modelo quadrado. <br><br><pre> <code class="cpp hljs">model-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, texture.get());</code> </pre><br>  Em seguida, crie uma c√¢mera que cozer√° a textura <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Camera&gt; camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Camera; camera-&gt;setViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, tex_widht, tex_height); camera-&gt;setClearColor(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); camera-&gt;setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</code> </pre><br>  A janela de exibi√ß√£o da c√¢mera √© do mesmo tamanho da textura.  Al√©m disso, n√£o se esque√ßa de definir a cor de fundo ao limpar a tela e a m√°scara de limpeza, indicando para limpar o buffer de cores e o buffer de profundidade.  Em seguida, configure a c√¢mera para renderizar em textura <br><br><pre> <code class="cpp hljs">camera-&gt;setRenderOrder(osg::Camera::PRE_RENDER); camera-&gt;setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT); camera-&gt;attach(osg::Camera::COLOR_BUFFER, texture.get());</code> </pre><br>  A ordem de renderiza√ß√£o de PRE_RENDER indica que esta c√¢mera est√° renderizando antes de renderizar para a cena principal.  Especifique o FBO como o destino da renderiza√ß√£o e anexe nossa textura √† c√¢mera.  Agora configuramos a c√¢mera para trabalhar em um sistema de coordenadas absolutas e, como cena, configuramos nossa sub√°rvore, que queremos renderizar em uma textura: transforma√ß√£o de rota√ß√£o com um modelo de cessna anexado a ela <br><br><pre> <code class="cpp hljs">camera-&gt;setReferenceFrame(osg::Camera::ABSOLUTE_RF); camera-&gt;addChild(transform1.get());</code> </pre><br>  Crie um n√≥ de grupo raiz adicionando o modelo principal (quadrado) e uma textura de processamento de c√¢mera a ele <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model.get()); root-&gt;addChild(camera.get());</code> </pre><br>  Crie e personalize um visualizador <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.setCameraManipulator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgGA::TrackballManipulator); viewer.setUpViewOnSingleScreen(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Configure a matriz de proje√ß√£o para a c√¢mera - uma proje√ß√£o em perspectiva atrav√©s dos par√¢metros da pir√¢mide de recorte <br><br><pre> <code class="cpp hljs">camera-&gt;setProjectionMatrixAsPerspective(<span class="hljs-number"><span class="hljs-number">30.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(tex_widht) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(tex_height), <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1000.0</span></span>);</code> </pre><br>  Montamos uma matriz de vista que define a posi√ß√£o da c√¢mera no espa√ßo em rela√ß√£o √† origem da sub-cessna <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = <span class="hljs-number"><span class="hljs-number">100.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = <span class="hljs-number"><span class="hljs-number">10.0f</span></span> * <span class="hljs-number"><span class="hljs-number">3.14f</span></span> / <span class="hljs-number"><span class="hljs-number">180.0f</span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eye</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, -dist * cosf(alpha), dist * sinf(alpha))</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">center</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; camera-&gt;setViewMatrixAsLookAt(eye, center, up);</code> </pre><br>  Por fim, anime e exiba a cena, alterando o √¢ngulo de rota√ß√£o da aeronave em torno do eixo Z em cada quadro <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> phi = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> delta = <span class="hljs-number"><span class="hljs-number">-0.01f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!viewer.done()) { transform1-&gt;setMatrix(osg::Matrix::rotate(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(phi), osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>))); viewer.frame(); phi += delta; }</code> </pre><br>  Como resultado, temos uma imagem bastante interessante <br><br><img src="https://habrastorage.org/webt/se/g1/jr/seg1jrflbtmzfkb5cbtwys1hleg.gif"><br><br>  Neste exemplo, implementamos algumas anima√ß√µes de cena, mas lembre-se de que expandir o loop run () e alterar os par√¢metros de renderiza√ß√£o antes ou depois da renderiza√ß√£o do quadro √© uma atividade insegura em termos de organiza√ß√£o do acesso aos dados de diferentes fluxos.  Como o OSG usa renderiza√ß√£o multithread, tamb√©m existem mecanismos regulares para incorporar suas pr√≥prias a√ß√µes no processo de renderiza√ß√£o, que fornecem acesso seguro aos dados aos threads. <br><br><h1>  6. Salvando o resultado da renderiza√ß√£o em um arquivo </h1><br>  O OSG suporta a capacidade de conectar um objeto osg :: Image √† c√¢mera e salvar o conte√∫do do buffer de quadros no buffer de dados da imagem.  Depois disso, √© poss√≠vel salvar esses dados em disco usando a fun√ß√£o osg :: writeImageFile () <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Image; image-&gt;allocateImage( width, height, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA, GL_UNSIGNED_BYTE ); camera-&gt;attach( osg::Camera::COLOR_BUFFER, image.get() ); ... osgDB::writeImageFile( *image, <span class="hljs-string"><span class="hljs-string">"saved_image.bmp"</span></span> );</code> </pre><br><h1>  Conclus√£o </h1><br>  Talvez o material apresentado no artigo pare√ßa trivial.  No entanto, descreve os princ√≠pios b√°sicos do trabalho com texturas no OpenSceneGraph, nos quais se baseiam t√©cnicas mais complexas para trabalhar com esse mecanismo, sobre as quais falaremos definitivamente no futuro. <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para continuar ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437624/">https://habr.com/ru/post/pt437624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437614/index.html">O Padr√£o Arquitet√¥nico Iterador no Universo R√°pido</a></li>
<li><a href="../pt437616/index.html">Seis meses sem queda nas vendas de CEO e iPhone: por que as a√ß√µes da Intel caem</a></li>
<li><a href="../pt437618/index.html">42 Operadores de pesquisa avan√ßada do Google (lista completa)</a></li>
<li><a href="../pt437620/index.html">Como a tecnologia da nuvem est√° mudando a maneira como tratamos</a></li>
<li><a href="../pt437622/index.html">Introdu√ß√£o ao servi√ßo Azure Machine Learning</a></li>
<li><a href="../pt437626/index.html">Desempenho da plataforma de negocia√ß√£o com um exemplo simples</a></li>
<li><a href="../pt437630/index.html">Os principais an√∫ncios da Microsoft da confer√™ncia BETT</a></li>
<li><a href="../pt437632/index.html">Mash, o b√°sico do idioma</a></li>
<li><a href="../pt437634/index.html">Roteador sem fio DIY</a></li>
<li><a href="../pt437636/index.html">Publicando o aplicativo na Microsoft Store: algumas mudan√ßas para o ano</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>