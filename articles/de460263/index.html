<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈹 💇🏻 ↩️ Eine wirklich intelligente Suche durchführen: Schritt-für-Schritt-Anleitung 👨🏻 👨🏿‍💻 🧑🏾‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suche im Unternehmensinformationssystem - schon von diesem Satz selbst bleibt es im Mund stecken. Es ist gut, wenn Sie überhaupt eine haben, müssen Si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine wirklich intelligente Suche durchführen: Schritt-für-Schritt-Anleitung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/460263/"><p>  <em>Suche im Unternehmensinformationssystem</em> - schon von diesem Satz selbst bleibt es im Mund stecken.  Es ist gut, wenn Sie überhaupt eine haben, müssen Sie nicht einmal über eine positive Benutzererfahrung nachdenken.  Wie kann man die Einstellung der von Suchmaschinen verwöhnten Benutzer umkehren und ein schnelles, genaues und perfekt verständliches Produkt erstellen?  Wir müssen ein gutes Stück Elasticsearch, eine Handvoll intelligenter Dienste, nehmen und sie in diesem Handbuch kneten. </p><br><p>  Es gibt viele Artikel darüber, wie Sie die Volltextsuche basierend auf Elasticsearch in die vorhandene Datenbank integrieren können.  Aber es gibt eindeutig nicht genug Artikel darüber, wie man eine wirklich kluge Suche durchführt. </p><br><blockquote>  Gleichzeitig hat sich der Ausdruck "Smart Search" selbst bereits zu einem Schlagwort entwickelt und ist an den Ort gewöhnt und nicht.  Was sollte eine Suchmaschine tun, um als intelligent zu gelten?  Letztendlich kann dies so beschrieben werden, dass das Ergebnis angegeben wird, das der Benutzer tatsächlich benötigt, auch wenn dieses Ergebnis nicht ganz mit dem Text der Anforderung übereinstimmt.  Beliebte Suchmaschinen wie Google und Yandex gehen noch weiter und finden nicht nur die benötigten Informationen, sondern beantworten direkt Benutzerfragen. </blockquote><p>  Okay, wir werden nicht sofort eine Ultimatum-Entscheidung treffen, aber was kann getan werden, um eine <em>regelmäßige</em> Volltextsuche einer <em>intelligenten</em> näher zu bringen? </p><a name="habracut"></a><br><h2 id="elementy-intellektualnosti">  Elemente der Intelligenz </h2><br><p>  Intelligente Suche - Dies ist nur dann der Fall, wenn die Quantität in Qualität gehen kann und viele kleine und ziemlich einfache Funktionen ein Gefühl der Magie erzeugen können. </p><br><ul><li>  Korrektur von Benutzerfehlern - ob es sich um einen Tippfehler, ein falsches Layout oder möglicherweise eine Anfrage mit einer verdächtig geringen Anzahl von Ergebnissen handelt, die jedoch einer Anfrage ähnelt, für die es viel mehr Informationen gibt. </li><li>  Für <del>  th </del>  NLP-Chats (Verarbeitung natürlicher Sprache, nicht das, was Sie dachten) - Wenn der Benutzer <em><strong>im letzten Jahr kommerzielle Angebote</strong></em> eingegeben hat, wollte er wirklich im Text aller Dokumente nach diesen Wörtern suchen oder brauchte er wirklich nur kommerzielle Angebote und erst im letzten Jahr ? </li><li>  Prognostizieren Sie Eingaben basierend auf früheren Abfragen oder beliebten Dokumenten. </li><li> Die Präsentation des Ergebnisses ist das übliche Highlight des gefundenen Fragments. Zusätzliche Informationen hängen davon ab, wonach Sie gesucht haben.  Da im vorherigen Absatz kommerzielle Vorschläge erforderlich waren, ist es möglicherweise sinnvoll, das Thema des Vorschlags und die Organisation, von der er stammt, sofort anzuzeigen. </li><li>  Einfacher Drilldown - die Möglichkeit, die Suchabfrage mithilfe zusätzlicher Filter und Facetten zu verfeinern. </li></ul><br><h2 id="vvodnaya">  Einführung </h2><br><p>  Es gibt ein ECM-DIRECTUM mit vielen Dokumenten.  Das Dokument besteht aus einer Karte mit Metainformationen und einem Textkörper, der mehrere Versionen haben kann. </p><br><p>  Ziel ist es, schnell und bequem nach Informationen in diesen Dokumenten zu suchen, wie es für einen Benutzer von Suchmaschinen üblich ist. </p><br><h2 id="indeksirovanie">  Indizierung </h2><br><blockquote>  Um nach etwas Gutem zu suchen, müssen Sie es zuerst gut indizieren. </blockquote><p>  Dokumente in ECM sind nicht statisch. Benutzer ändern Text, erstellen neue Versionen und ändern Daten auf Karten.  Es werden ständig neue Dokumente erstellt und alte manchmal gelöscht. <br>  Um die aktuellen Informationen in Elasticsearch auf dem neuesten Stand zu halten, müssen Dokumente ständig neu indiziert werden.  Glücklicherweise verfügt ECM bereits über eine eigene Warteschlange für asynchrone Ereignisse. Wenn Sie also ein Dokument ändern, fügen Sie es einfach zur Indizierung in die Warteschlange ein. </p><br><h3 id="otobrazhenie-dokumentov-ecm-na-dokumenty-elasticsearch">  Zuordnen von ECM-Dokumenten zu Elasticsearch-Dokumenten </h3><br><p>  Ein Dokumentkörper in ECM kann mehrere Versionen haben.  In Elasticsearch könnte dies als ein Array verschachtelter Objekte betrachtet werden, aber dann wird es unpraktisch, mit ihnen zu arbeiten. Es wird schwieriger, Abfragen zu schreiben. Wenn Sie eine der Versionen ändern, müssen Sie alles neu indizieren. Verschiedene Versionen desselben Dokuments können nicht in verschiedenen Indizes gespeichert werden (warum ist dies möglicherweise erforderlich?) im nächsten Abschnitt).  Daher denormalisieren wir ein Dokument aus ECM in mehrere Elasticsearch-Dokumente mit derselben Karte, aber unterschiedlichen Körpern. </p><br><p>  Zusätzlich zu Karte und Körper werden dem Elasticsearch-Dokument verschiedene Serviceinformationen hinzugefügt, die separat erwähnt werden sollten: </p><br><ul><li>  eine Liste von IDs von Gruppen und Benutzern, die Rechte an dem Dokument haben - für Suchen mit Rechten; </li><li>  die Anzahl der Aufrufe des Dokuments - zur Optimierung der Relevanz; </li><li>  Zeitpunkt der letzten Indizierung. </li></ul><br><h3 id="sostav-indeksov">  Indexzusammensetzung </h3><br><p>  Ja, Pluralindizes.  Normalerweise werden mehrere Indizes zum Speichern von Informationen mit ähnlicher Bedeutung in Elasticsearch nur verwendet, wenn diese Informationen unveränderlich und an einen bestimmten Zeitraum gebunden sind, z. B. Protokolle.  Dann werden die Indizes je nach Intensität der Belastung jeden Monat / Tag oder häufiger erstellt.  In unserem Fall kann jedes Dokument geändert werden, und es wäre möglich, alles in einem Index zu speichern. </p><br><p>  Aber - die Dokumente im System können in verschiedenen Sprachen vorliegen, und das Speichern mehrsprachiger Daten in Elasticsearch bringt zwei Probleme mit sich: </p><br><ul><li>  Falsches Stemming.  Bei einigen Wörtern wird die Basis korrekt gefunden, bei einigen - falsch (es gibt ein anderes Wort im Index), bei einigen - wird sie überhaupt nicht gefunden (der Index wird mit Wortformen verstopft).  Bei einigen Wörtern aus verschiedenen Sprachen und mit unterschiedlichen Bedeutungen ist die Basis dieselbe, und dann geht die Bedeutung des Wortes verloren.  Die Verwendung mehrerer Stemmers hintereinander kann zu einer zusätzlichen Berechnung der Basis für einen bereits berechneten führen. </li></ul><br><blockquote>  Stamming - die Basis des Wortes finden.  Der Stamm muss nicht die Wurzel des Wortes oder seine normale Form sein.  Normalerweise reicht es aus, wenn die zugehörigen Wörter in ein Framework projiziert werden. <br>  Lemmatisierung ist eine Art von Stemming, bei der die normale (Vokabular-) Form eines Wortes als Grundlage betrachtet wird. </blockquote><br><ul><li>  Falsche Worthäufigkeit.  Einige Relevanzbestimmungsmechanismen in ES berücksichtigen die Häufigkeit der gesuchten Wörter im Dokument (je häufiger, desto höher die Relevanz) und die Häufigkeit der gesuchten Wörter im Index (je häufiger, desto geringer die Relevanz).  Eine kleine Verbreitung der russischen Sprache in einem englischen Dokument, wenn die englischen Dokumente überwiegend im Index enthalten sind, hat ein hohes Gewicht, es lohnt sich jedoch, die englischen und russischen Dokumente im Index zu mischen, und das Gewicht nimmt ab. </li></ul><br><p>  Das erste Problem kann für den Fall gelöst werden, dass verschiedene Sprachen unterschiedliche Zeichensätze verwenden (russisch-englische Dokumente verwenden kyrillische und lateinische Buchstaben) - Sprachstemmer verarbeiten nur "ihre" Zeichen. </p><br><p>  Um das zweite Problem zu lösen, haben wir den Ansatz mit einem eigenen Index für jede Sprache verwendet. </p><br><p>  Wenn wir beide Ansätze kombinieren, erhalten wir Sprachindizes, die dennoch Analysatoren für mehrere Sprachen enthalten, die sich nicht in jedem Zeichensatz überschneiden: Russisch-Englisch (und separat Englisch-Russisch), Polnisch-Russisch, Deutsch-Russisch, Ukrainisch-Englisch usw. . </p><br><p>  Um nicht alle möglichen Indizes im Voraus zu erstellen, haben wir Indexvorlagen verwendet. Mit Elasticsearch können Sie eine Vorlage angeben, die Einstellungen und Zuordnungen enthält, und ein Indexnamenmuster angeben.  Wenn Sie versuchen, ein Dokument in einen nicht vorhandenen Index zu indizieren, dessen Name mit einem der Muster der Vorlage übereinstimmt, wird nicht nur ein neuer Index erstellt, sondern auch Einstellungen und Zuordnungen aus der entsprechenden Vorlage werden darauf angewendet. </p><br><h3 id="struktura-indeksov">  Indexstruktur </h3><br><p>  Für die Indizierung verwenden wir zwei Analysatoren gleichzeitig (über mehrere Felder): Standard für die Suche nach exakten Phrasen und benutzerdefiniert für alles andere: </p><br><pre><code class="json hljs"><span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"custom"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span>}</code> </pre> <br><p>  Mit dem Kleinbuchstabenfilter ist alles klar, ich erzähle Ihnen von dem Rest. </p><br><p>  Die Filter russian_morphology und english_morphology dienen zur morphologischen Analyse von russischem bzw. englischem Text.  Sie sind nicht Teil von Elasticsearch und Teil eines separaten Analyse-Morphologie-Plugins.  Dies sind Lemmatisierer, die den Vokabularansatz in Kombination mit einigen Heuristiken verwenden und wesentlich besser funktionieren als die eingebauten Filter für die entsprechenden Sprachen. </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"russian"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  Und: </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  Sehr merkwürdiger word_delimiter Filter.  Es hilft beispielsweise, Tippfehler zu beseitigen, wenn nach dem Punkt kein Leerzeichen steht.  Wir verwenden die folgende Konfiguration: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"catenate_all"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_original"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }</code> </pre> <br><p>  Mit yo_filter können Sie den Unterschied zwischen E und E ignorieren: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapping"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"mappings"</span></span>: [ <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span> ] }</code> </pre> <br><p>  ru_en_stopwords Filtertyp stop - unser Wörterbuch der Stoppwörter. </p><br><h3 id="process-indeksirovaniya">  Indizierungsprozess </h3><br><p>  Bei den Dokumenten in ECM handelt es sich in der Regel um Dateien mit Büroformaten: .docx, .pdf usw.  Um den Text zu extrahieren, wird das Ingest-Attachment-Plugin mit der folgenden Pipeline verwendet: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"document_version"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"attachment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target_field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_length"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_type"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"indexed_chars"</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"lang"</span></span>: <span class="hljs-string"><span class="hljs-string">"painless"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"languages"</span></span>: [<span class="hljs-string"><span class="hljs-string">"ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"language_delimeter"</span></span>: <span class="hljs-string"><span class="hljs-string">"_"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } ] } }</code> </pre> <br><p>  Aus dem Ungewöhnlichen in der Pipeline, Ignorieren von Fehlern der Abwesenheit des Körpers (dies geschieht bei verschlüsselten Dokumenten) und Bestimmen des Zielindex basierend auf der Sprache des Textes.  Letzteres geschieht in einer schmerzlosen Schrift, deren Körper ich separat geben werde, weil  Aufgrund von JSON-Einschränkungen muss es in eine Zeile geschrieben werden.  Zusammen mit Debugging-Schwierigkeiten (der empfohlene Weg ist, hier und da Ausnahmen auszulösen) wird es zu einer schmerzhaften. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.languages.contains(ctx.attachment.language)) ctx._index = ctx._index + <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.language_delimeter + ctx.attachment.language; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content = ctx.attachment.content; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_length != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_length = ctx.attachment.content_length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_type != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_type = ctx.attachment.content_type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.language != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.language = ctx.attachment.language; }</code> </pre> <br><p>  Daher senden wir das Dokument immer an <em>index_name</em> .  Wenn die Sprache nicht definiert ist oder nicht unterstützt wird, wird das Dokument in diesem Index <em>abgelegt</em> , andernfalls fällt es in die <em>Indexsprache</em> . </p><br><p>  Wir speichern nicht den ursprünglichen Hauptteil der Datei, aber das Feld _source ist aktiviert, weil  Es ist erforderlich, das Dokument teilweise zu aktualisieren und das gefundene zu markieren. </p><br><p>  Wenn sich nur die Karte seit der letzten Indizierung geändert hat, verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Update By Query-API</a> ohne Pipeline, um sie zu aktualisieren.  Dies ermöglicht es erstens, potenziell schwere Dokumentkörper nicht aus ECM zu ziehen, und zweitens beschleunigt es die Aktualisierung auf der Elasticsearch-Seite erheblich - Sie müssen den Text von Dokumenten nicht aus Office-Formaten extrahieren, was sehr ressourcenintensiv ist. </p><br><blockquote>  Daher gibt es in Elasticsearch überhaupt keine Aktualisierung des Dokuments. Technisch gesehen wird beim Aktualisieren aus dem Index das alte Dokument herausgenommen, geändert und wieder vollständig indiziert. </blockquote><p>  Wenn sich der Text jedoch ändert, wird das alte Dokument im Allgemeinen gelöscht und von Grund auf neu indiziert.  Dadurch können Dokumente von einem Sprachindex in einen anderen <em>verschoben werden</em> . </p><br><h2 id="poisk">  Suche </h2><br><p>  Um die Beschreibung zu vereinfachen, werde ich einen Screenshot des Endergebnisses geben </p><br><p><img src="https://habrastorage.org/webt/ni/l4/xm/nil4xm-qrg7meikrjbd16mt_ziq.png"></p><br><h3 id="polnotekst">  Volltext </h3><br><p>  Der Haupttyp der Abfrage ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simple Query String Query</a> : </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"simple_query_string"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"card.d*.*_text"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.d*.*_text.exact"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name.exact^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content.exact"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default_operator"</span></span>: <span class="hljs-string"><span class="hljs-string">"or"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyze_wildcard"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum_should_match"</span></span>: <span class="hljs-string"><span class="hljs-string">"-35%"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quote_field_suffix"</span></span>: <span class="hljs-string"><span class="hljs-string">".exact"</span></span> }</code> </pre> <br><p>  Dabei sind <em>.exact</em> die vom <em>Standardparser</em> indizierten Felder.  Die Wichtigkeit des Namens des Dokuments ist doppelt so hoch wie in den anderen Feldern.  Mit der Kombination von <code>"default_operator": "or"</code> und <code>"minimum_should_match": "-35%"</code> können Sie Dokumente finden, die nicht bis zu 35% der gesuchten Wörter enthalten. </p><br><h3 id="sinonimy">  Synonyme </h3><br><p>  Im Allgemeinen werden verschiedene Analysatoren für die Indizierung und Suche verwendet. Der einzige Unterschied besteht darin, dass ein Filter hinzugefügt wird, um der Suchabfrage Synonyme hinzuzufügen: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"search_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span> }</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonym_graph"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"synonyms_path"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonyms.txt"</span></span> }</code> </pre> <br><h3 id="uchyot-prav">  Buchhaltungsrechte </h3><br><p>  Bei rechtsbasierten Suchvorgängen ist die Hauptabfrage mit einem zusätzlichen Filter in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bool Query</a> eingebettet: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"simple_query_string"</span></span>: {...} } ], <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"rights"</span></span>: [           ] } } ] }</code> </pre> <br><p>  Wie wir uns aus dem Abschnitt über die Indizierung erinnern, enthält der Index ein Feld mit der ID von Benutzern und Gruppen, die Rechte an dem Dokument haben.  Wenn es einen Schnittpunkt dieses Feldes mit dem übergebenen Array gibt, gibt es Rechte. </p><br><h3 id="tyuning-relevantnosti">  Relevanz-Tuning </h3><br><p>  Standardmäßig bewertet Elasticsearch die Relevanz der Ergebnisse mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BM25-</a> Algorithmus anhand der Abfrage und des Textes des Dokuments.  Wir haben beschlossen, dass drei weitere Faktoren die Bewertung der Einhaltung des gewünschten und tatsächlichen Ergebnisses beeinflussen sollten: </p><br><ul><li>  der Zeitpunkt der letzten Bearbeitung des Dokuments - je weiter es in der Vergangenheit war, desto weniger wahrscheinlich ist es, dass dieses Dokument benötigt wird; </li><li>  die Anzahl der Aufrufe des Dokuments - je mehr, desto wahrscheinlicher ist es, dass dieses Dokument benötigt wird; </li><li><p>  ECM-Karosserieversionen haben mehrere mögliche Zustände: entwickelt, betriebsbereit und veraltet.  Es ist logisch, dass das Handeln wichtiger ist als die anderen. </p><br><p>  Sie können diesen Effekt mit Hilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Function Score Query</a> erzielen: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"function_score"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"functions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"gauss"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"modified_date"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"now"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"1095d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"offset"</span></span>: <span class="hljs-string"><span class="hljs-string">"31d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"decay"</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span> } } }, { <span class="hljs-attr"><span class="hljs-attr">"field_value_factor"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"access_count"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"modifier"</span></span>: <span class="hljs-string"><span class="hljs-string">"log2p"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"term"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"life_stage_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">1.1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: {...} } }</code> </pre> <br><p>  Als Ergebnis, ceteris paribus, erhalten wir ungefähr die folgende Abhängigkeit des Ergebnisbewertungsmodifikators vom Datum seiner letzten Änderung X und der Anzahl der Treffer Y: </p><br></li></ul><br><p></p><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/wa/wz/td/wawztd9zvlz-fetkplnfrjw8ddy.png"></a> </div><p></p><br><h3 id="vneshniy-intellekt">  Externe Intelligenz </h3><br><p>  Für einen Teil der Funktionalität der intelligenten Suche müssen wir verschiedene <em>Fakten</em> aus der Suchabfrage extrahieren: Daten mit ihrer Anwendung (Erstellung, Änderung, Genehmigung usw.), Namen von Organisationen, Arten von gesuchten Dokumenten usw. </p><br><p>  Es ist auch wünschenswert, die Anfrage in eine bestimmte Kategorie einzuteilen, z. B. Dokumente nach Organisation, Mitarbeiter, Aufsichtsbehörden usw. </p><br><p>  Diese beiden Vorgänge werden vom ECM Intelligent Module - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DIRECTUM Ario ausgeführt</a> . </p><br><h3 id="process-umnogo-poiska">  Intelligenter Suchprozess </h3><br><p>  Es ist an der Zeit, genauer zu überlegen, welche Mechanismen als Elemente der Intelligenz implementiert sind. </p><br><h4 id="ispravlenie-oshibok-polzovatelya">  Benutzerfehlerkorrektur </h4><br><p>  Die Richtigkeit des Layouts wird anhand des Trigramm-Sprachmodells bestimmt. Für eine Zeile wird berechnet, wie wahrscheinlich es ist, dass die dreistelligen Sequenzen in Texten in Englisch und Russisch erfüllt werden.  Wenn das aktuelle Layout als weniger wahrscheinlich angesehen wird, wird zunächst ein Hinweis mit einem korrekten Layout angezeigt: </p><br><p><img src="https://habrastorage.org/webt/ek/ow/c5/ekowc5ikjiwx1xe87b5wewhoohm.png"></p><br><p>  und zweitens werden die weiteren Schritte der Suche mit dem richtigen Layout ausgeführt: </p><br><p><img src="https://habrastorage.org/webt/ug/dr/tc/ugdrtchejvx024datttkc_zcxxw.png"></p><br><p>  Und wenn mit dem korrigierten Layout nichts gefunden werden kann, beginnt die Suche mit der ursprünglichen Zeile. </p><br><p>  Die Tippfehlerkorrektur wird mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phrase Suggester</a> implementiert.  Es liegt ein Problem vor: Wenn Sie eine Abfrage für mehrere Indizes gleichzeitig ausführen, wird vorgeschlagen, dass möglicherweise nichts zurückgegeben wird. Wenn Sie nur für einen Index ausführen, werden Ergebnisse angezeigt.  Dies <em>wird behandelt, indem</em> das Vertrauen auf 0 gesetzt wird. Dann wird jedoch vorgeschlagen, Wörter durch ihre normale Form zu ersetzen.  Stimmen Sie zu, es wird seltsam sein, wenn Sie nach "Buchstabe <strong>a</strong> " suchen, um eine Antwort im Geiste zu erhalten: <em>Vielleicht haben Sie nach einem Brief <strong>über</strong> gesucht?</em> </p><br><p>  Dies kann umgangen werden, indem zwei Eingabeaufforderungen in der Anforderung verwendet werden: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"content_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} } }, } }, <span class="hljs-string"><span class="hljs-string">"check_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} - ({{source_query}}) }, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source_query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } }, } } }</code> </pre> <br><p>  Von den gebräuchlichen Parametern </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"confidence"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-string"><span class="hljs-string">"max_errors"</span></span>: <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Wenn der erste Opinester das Ergebnis zurückgegeben hat, der zweite jedoch nicht, ist dieses Ergebnis die ursprüngliche Zeichenfolge selbst, möglicherweise mit Wörtern in anderen Formen, und es besteht keine Notwendigkeit, einen Hinweis anzuzeigen.  Wenn der Hinweis weiterhin benötigt wird, wird der ursprüngliche Suchbegriff mit dem Hinweis zusammengeführt.  Dies geschieht, indem nur die korrigierten Wörter ersetzt werden und nur diejenigen, die die Rechtschreibprüfung (mit Hunspell) als falsch erachtet. </p><br><p>  Wenn die Suche in der Quellzeichenfolge 0 Ergebnisse ergab, wird sie durch die durch die Zusammenführung erhaltene Zeichenfolge ersetzt und die Suche wird erneut ausgeführt: </p><br><p><img src="https://habrastorage.org/webt/up/r3/wx/upr3wxky4mkbeyy3exjocbwzocy.png"></p><br><p>  Andernfalls wird die resultierende Eingabeaufforderungszeichenfolge nur als Eingabeaufforderung für die Suche zurückgegeben: </p><br><p><img src="https://habrastorage.org/webt/qv/ts/4t/qvts4tauspo9yspwy_itbzcdttq.png"></p><br><h4 id="klassifikaciya-zaprosov-i-izvlechenie-faktov">  Abfrageklassifizierung und Faktenextraktion </h4><br><p>  Wie bereits erwähnt, verwenden wir DIRECTUM Ario, nämlich den Textklassifizierungsdienst und den Faktenextraktionsdienst.  Zu diesem Zweck haben wir Analysten anonyme Suchanfragen und eine Liste mit Fakten gestellt, an denen wir interessiert sind.  Basierend auf Abfragen und dem Wissen darüber, welche Dokumente sich im System befinden, identifizierten die Analysten mehrere Kategorien und schulten den Klassifizierungsdienst, um die Kategorie gemäß dem Abfragetext zu bestimmen.  Basierend auf den resultierenden Kategorien und der Liste der Fakten haben wir die Regeln für die Verwendung dieser Fakten formuliert.  Beispielsweise wird der Ausdruck <em><strong>für das letzte Jahr</strong></em> in der Kategorie <strong>Jeder</strong> als Erstellungsdatum des Dokuments und in der Kategorie <strong>Nach Organisation</strong> als Registrierungsdatum betrachtet.  Gleichzeitig sollten die im <em><strong>letzten Jahr erstellten</strong></em> in jeder Kategorie auf das Erstellungsdatum fallen. </p><br><p>  Von der Suchseite aus haben sie eine Konfiguration erstellt, in der sie die Kategorien registriert haben, welche Fakten auf welche Facettenfilter angewendet werden. </p><br><h4 id="avtodopolnenie-vvoda">  Eingabe abgeschlossen </h4><br><p>  Zusätzlich zu den bereits erwähnten Layoutkorrekturen werden frühere Suchanfragen des Benutzers und öffentliche Dokumente automatisch vervollständigt. </p><br><p><img src="https://habrastorage.org/webt/zc/52/yo/zc52yohihrkkrnny6ekla80-mro.png"></p><br><p>  Sie werden mit einem anderen Suggestertyp implementiert - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Completion Suggester</a> , aber jeder hat seine eigenen Nuancen. </p><br><h5 id="avtodopolnenie-istoriya-poiskov">  Autovervollständigung: Suchverlauf </h5><br><p>  ECM enthält weit weniger Benutzer als Suchmaschinen und weist ihnen genügend allgemeine Abfragen zu <del>  warum Lenin Pilz </del>  nicht möglich.  Alles in einer Reihe zu zeigen, lohnt sich aus Datenschutzgründen ebenfalls nicht.  Der übliche Vervollständigungsvorschlag kann nur den gesamten Satz von Dokumenten im Index durchsuchen, aber der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontextvorschlag hilft dabei</a> - eine Möglichkeit, einen Kontext für jeden Hinweis festzulegen und nach diesen Kontexten zu filtern.  Wenn Benutzernamen als Kontexte verwendet werden, kann jedem nur sein Verlauf angezeigt werden. </p><br><p>  Sie müssen dem Benutzer auch die Möglichkeit geben, die Eingabeaufforderung zu entfernen, für die er sich schämt.  Als Schlüssel zum Löschen haben wir den Benutzernamen und den QuickInfo-Text verwendet.  Als Ergebnis haben wir für den Index mit Hinweisen eine so leicht duplizierte Zuordnung erhalten: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"mappings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"document"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"completion"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"simple"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_separators"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_position_increments"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_input_length"</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">"contexts"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"CATEGORY"</span></span> } ] }, <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> } } } }</code> </pre> <br><p>  Die Gewichtung für jeden neuen Hinweis wird auf eins festgelegt und erhöht sich jedes Mal, wenn Sie ihn mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Update By Query-API</a> mit einem sehr einfachen Skript <code>ctx._source.suggest.weight++</code> . </p><br><h5 id="avtodopolnenie-dokumenty">  Autovervollständigung: Dokumente </h5><br><p>  Es kann jedoch viele Dokumente und mögliche Kombinationen von Rechten geben.  Im Gegenteil, wir haben uns hier entschieden, beim automatischen Ausfüllen nicht nach Rechten zu filtern, sondern nur öffentliche Dokumente zu indizieren.  Ja, und Sie müssen keine einzelnen Tipps aus diesem Index entfernen.  Es scheint, dass die Implementierung in allem einfacher ist als in der vorherigen, wenn nicht in zwei Punkten: </p><br><p>  Der erste - Completion Suggester unterstützt nur die Präfixsuche, und Kunden lieben es, <code>.01.01   </code> Artikelnummern und einigen <code>.01.01   </code> beim <code>.01.01   </code> einer Abfrage zuzuweisen. Es gibt <code>.01.01   </code> .  Hier können Sie neben dem vollständigen Namen auch davon abgeleitete n-Gramm indizieren: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"extension"</span></span>: <span class="hljs-string"><span class="hljs-string">"pdf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">90</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } ] }</code> </pre> <br><p>  Dies war bei der Geschichte nicht so kritisch, dennoch gibt derselbe Benutzer ungefähr dieselbe Zeile ein, wenn er erneut nach etwas sucht.  <em>Wahrscheinlich</em> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/rc/dv/bircdvzu2hvcblxhrryvauzajf0.png"></div><br><p>  Die zweite - standardmäßig sind alle Tipps gleich, aber wir möchten einige davon gleich und vorzugsweise so gestalten, dass dies mit der Rangfolge der Suchergebnisse übereinstimmt.  Wiederholen Sie dazu grob die in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktions-Score-Abfrage</a> verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen</a> gauss und field_value_factor. </p><br><p>  Es stellt sich heraus, dass hier eine solche Pipeline ist: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"dir_public_documents_pipeline"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ ... { <span class="hljs-attr"><span class="hljs-attr">"set"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{name}}"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"split"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"separator"</span></span>: <span class="hljs-string"><span class="hljs-string">"\\s+|$"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } } ] } }</code> </pre> <br><p>  mit folgendem Skript: </p><br><pre> <code class="cs hljs">Date modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.modified_date != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">'dd.MM.yyyy'</span></span>).parse(ctx.modified_date); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> dayCount = (System.currentTimeMillis() - modified.getTime())/(<span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> score = Math.exp((<span class="hljs-number"><span class="hljs-number">-0.7</span></span>*Math.max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dayCount - <span class="hljs-number"><span class="hljs-number">31</span></span>))/<span class="hljs-number"><span class="hljs-number">1095</span></span>) * Math.log10(ctx.access_count + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = ctx.terms_array.length; ctx.suggest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">'input'</span></span>: ctx.terms_array[count - <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'weight'</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - count + <span class="hljs-number"><span class="hljs-number">1</span></span>)) ]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = count - <span class="hljs-number"><span class="hljs-number">2</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ; --i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.terms_array[i].trim() != <span class="hljs-string"><span class="hljs-string">""</span></span>) { ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">"input"</span></span>: ctx.terms_array[i] + <span class="hljs-string"><span class="hljs-string">" "</span></span> + ctx.suggest[ctx.suggest.length - <span class="hljs-number"><span class="hljs-number">1</span></span>].input, <span class="hljs-string"><span class="hljs-string">"weight"</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - i))]); } } ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'terms_array'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'access_count'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'modified_date'</span></span>);</code> </pre> <br><p>  Warum sich mit einer schmerzlosen Pipeline beschäftigen, anstatt sie in einer bequemeren Sprache zu schreiben?  Mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reindex-API</a> können Sie jetzt den Inhalt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchindizes</a> in Indizes für Hinweise (indem Sie natürlich nur die erforderlichen Felder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angeben</a> ) in nur einem Befehl übernehmen. </p><br><p>  Die Zusammensetzung der wirklich benötigten öffentlichen Dokumente wird nicht oft aktualisiert, sodass dieser Befehl bei einem manuellen Start belassen werden kann. </p><br><h3 id="otobrazhenie-rezultatov">  Ergebnisse anzeigen </h3><br><h4 id="kategorii">  Kategorien </h4><br><p>  Die Kategorie bestimmt, welche Facetten verfügbar sind und wie das Snippet aussehen wird.  Es kann automatisch von <em>externer Intelligenz</em> erkannt oder manuell über der Suchleiste ausgewählt werden. </p><br><h4 id="fasety">  Facetten </h4><br><p>  Facetten sind so intuitiv für jeden, dessen Verhalten jedoch durch sehr nicht triviale Regeln beschrieben wird.  Hier sind einige davon: </p><br><ol><li><p>  Facettenwerte hängen von den Suchergebnissen ab, ABER und die Suchergebnisse hängen von den ausgewählten Facetten ab.  Wie vermeide ich eine Rekursion? </p><br></li><li><p>  Das Auswählen von Werten innerhalb einer Facette wirkt sich nicht auf andere Werte dieser Facette aus, wirkt sich jedoch auf Werte in anderen Facetten aus: </p><br></li></ol><br><p><img src="https://habrastorage.org/webt/60/ei/g6/60eig601ltskcwvcesh5zno8crc.png"></p><br><ol><li>  Vom Benutzer ausgewählte Facettenwerte sollten nicht verschwinden, selbst wenn eine Auswahl in einer anderen Facette sie auf 0 <em>vernichtet</em> oder sie nicht mehr oben stehen: </li></ol><br><p><img src="https://habrastorage.org/webt/mu/6u/e-/mu6ue-ybxh3sa9h6ymkj1idn_ti.png"></p><br><p>  In Bezug auf die Elastizität werden Facetten durch den Aggregationsmechanismus realisiert. Um jedoch den beschriebenen Regeln zu entsprechen, müssen diese Aggregationen ineinander investiert und voneinander gefiltert werden. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/jt/zu/zdjtzudyw9iei8x-tjarja-a5tm.jpeg"></div><br><p>  Betrachten Sie die dafür verantwortlichen Anforderungsfragmente: </p><br><div class="spoiler">  <b class="spoiler_title">Code zu groß</b> <div class="spoiler_text"><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"post_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } } ] } }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} <span class="hljs-string"><span class="hljs-string">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"editor_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... } }</code> </pre> </div></div><br><p>  Was ist hier das: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit post_filter</a> können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> den Ergebnissen einer bereits abgeschlossenen Abfrage eine zusätzliche Bedingung auferlegen, ohne die Ergebnisse von Aggregationen zu beeinflussen.  Dieselbe Rekursionslücke.  Beinhaltet alle ausgewählten Werte aller Facetten. </li><li>  Aggregationen der obersten Ebene im Beispiel <em>card.author_value_id</em> und <em>editor_value_id</em> .  Jeder hat: <br><ul><li>  Filtern Sie nach den Werten aller anderen Facetten mit Ausnahme Ihrer eigenen. </li><li>  verschachtelte Aggregation für ausgewählte Facettenwerte - <em>Schutz vor Vernichtung</em> ; </li><li>  verschachtelte Aggregation für andere Facettenwerte.  Wir zeigen die Top 10 an und fordern die Top 11 an, um zu bestimmen, ob die Schaltfläche <strong>Alle</strong> anzeigen angezeigt werden soll. </li></ul></li></ul><br><h4 id="snippety">  Schnipsel </h4><br><p>  Abhängig von der ausgewählten Kategorie kann das Snippet bei der Suche in einer Kategorie unterschiedlich aussehen, z. B. dasselbe Dokument </p><br><p>  <strong>Alle</strong> : </p><br><p><img src="https://habrastorage.org/webt/ka/_b/ia/ka_biaaygfgbsk2msyfhu-bnkse.png"></p><br><p>  und <strong>Mitarbeiter</strong> : </p><br><p><img src="https://habrastorage.org/webt/5i/po/k_/5ipok_qgkc9170ucyidespnnitc.png"></p><br><p>  Oder erinnern Sie sich, wir wollten das Thema eines kommerziellen Angebots sehen und von wem es kam? </p><br><p><img src="https://habrastorage.org/webt/-i/7z/g7/-i7zg7dwh7kbs9e9_2yk3fnxc6k.png"></p><br><p>  Um nicht die gesamte Karte aus dem Gummiband zu ziehen (dies verlangsamt die Suche), wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellfilterung verwendet</a> : </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"_source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"includes"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.card_type_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.life_stage_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"extension"</span></span>, ... ] }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... }</code> </pre> <br><p>  Um die im Text des Dokuments enthaltenen Wörter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hervorzuheben,</a> wird der Textmarker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fast Vector</a> verwendet, um die am besten geeigneten Snippets für große Texte zu generieren, und der Name <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unified Highlighter</a> als am wenigsten anspruchsvoll für Ressourcen und Indexstruktur: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"highlight"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pre_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"post_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;/strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"encoder"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.name"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"content"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fragment_size"</span></span>: <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"fvh"</span></span> } } },</code> </pre> <br><p>  In diesem Fall wird der Name vollständig hervorgehoben, und aus dem Text erhalten wir bis zu 3 Fragmente mit einer Länge von 300 Zeichen.  Der vom Fast Vector-Textmarker zurückgegebene Text wird durch einen provisorischen Algorithmus weiter komprimiert, um einen minimierten Snippet-Status zu erhalten. </p><br><h3 id="kollaps">  Zusammenbruch </h3><br><p>  In der Vergangenheit sind Benutzer dieses ECM daran gewöhnt, dass die Suche <em>Dokumente an</em> sie zurückgibt. Tatsächlich sucht Elasticsearch jedoch zwischen <em>Dokumentversionen</em> .  Es kann sich herausstellen, dass mehrere nahezu identische Versionen in derselben Abfrage gefunden werden.  Dies wird die Ergebnisse durcheinander bringen und den Benutzer verwirren.  Glücklicherweise kann dieses Verhalten vermieden werden, indem der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Field Collapsing-</a> Mechanismus verwendet wird - eine leichtgewichtige Version von Aggregationen, die bereits mit den fertigen Ergebnissen arbeitet (in dieser ähnelt es post_filter, <em>zwei Krücken sind ein Paar</em> ).  Der <em>Zusammenbruch</em> führt zu dem relevantesten der zusammenbrechenden Objekte. </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... <span class="hljs-string"><span class="hljs-string">"collapse"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"id"</span></span> } }</code> </pre> <br><p>  Leider hat der Zusammenbruch eine Reihe unangenehmer Auswirkungen, zum Beispiel kehren verschiedene numerische Merkmale des Suchergebnisses weiter zurück, als ob es keinen Zusammenbruch gegeben hätte.  Das heißt, die Anzahl der Ergebnisse, die Anzahl der Facettenwerte - alle sind <em>leicht</em> falsch, aber der Benutzer bemerkt dies normalerweise nicht, ebenso wie der müde Leser, der diesen Vorschlag wahrscheinlich noch nicht gelesen hat. </p><br><p>  Das Ende. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460263/">https://habr.com/ru/post/de460263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460253/index.html">10 Gründe, Ihre Fähigkeiten als Sprachassistent zu verbessern</a></li>
<li><a href="../de460255/index.html">Backdoor auf Node.js: warum, warum und wie es funktioniert</a></li>
<li><a href="../de460257/index.html">Hallo Welt! Tiefes Eintauchen in Terminals</a></li>
<li><a href="../de460259/index.html">Was ist UI- und UX-Design? Was ist gemeinsam und anders?</a></li>
<li><a href="../de460261/index.html">Amazon: 25 Jahre E-Commerce-Erfolg</a></li>
<li><a href="../de460265/index.html">Erstellen Sie eine Xcode-Projektvorlage</a></li>
<li><a href="../de460273/index.html">Autorisierung in Apple Pay für die Kleinsten</a></li>
<li><a href="../de460275/index.html">Warum brauchen Sie nicht die perfekte Lösung?</a></li>
<li><a href="../de460279/index.html">10-Milliarden-Vertrag: Wer wird sich mit der Cloud für das Pentagon befassen?</a></li>
<li><a href="../de460281/index.html">Wie UX Writer zur Produktverbesserung beiträgt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>