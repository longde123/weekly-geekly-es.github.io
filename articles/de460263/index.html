<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàπ üíáüèª ‚Ü©Ô∏è Eine wirklich intelligente Suche durchf√ºhren: Schritt-f√ºr-Schritt-Anleitung üë®üèª üë®üèø‚Äçüíª üßëüèæ‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suche im Unternehmensinformationssystem - schon von diesem Satz selbst bleibt es im Mund stecken. Es ist gut, wenn Sie √ºberhaupt eine haben, m√ºssen Si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine wirklich intelligente Suche durchf√ºhren: Schritt-f√ºr-Schritt-Anleitung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/460263/"><p>  <em>Suche im Unternehmensinformationssystem</em> - schon von diesem Satz selbst bleibt es im Mund stecken.  Es ist gut, wenn Sie √ºberhaupt eine haben, m√ºssen Sie nicht einmal √ºber eine positive Benutzererfahrung nachdenken.  Wie kann man die Einstellung der von Suchmaschinen verw√∂hnten Benutzer umkehren und ein schnelles, genaues und perfekt verst√§ndliches Produkt erstellen?  Wir m√ºssen ein gutes St√ºck Elasticsearch, eine Handvoll intelligenter Dienste, nehmen und sie in diesem Handbuch kneten. </p><br><p>  Es gibt viele Artikel dar√ºber, wie Sie die Volltextsuche basierend auf Elasticsearch in die vorhandene Datenbank integrieren k√∂nnen.  Aber es gibt eindeutig nicht genug Artikel dar√ºber, wie man eine wirklich kluge Suche durchf√ºhrt. </p><br><blockquote>  Gleichzeitig hat sich der Ausdruck "Smart Search" selbst bereits zu einem Schlagwort entwickelt und ist an den Ort gew√∂hnt und nicht.  Was sollte eine Suchmaschine tun, um als intelligent zu gelten?  Letztendlich kann dies so beschrieben werden, dass das Ergebnis angegeben wird, das der Benutzer tats√§chlich ben√∂tigt, auch wenn dieses Ergebnis nicht ganz mit dem Text der Anforderung √ºbereinstimmt.  Beliebte Suchmaschinen wie Google und Yandex gehen noch weiter und finden nicht nur die ben√∂tigten Informationen, sondern beantworten direkt Benutzerfragen. </blockquote><p>  Okay, wir werden nicht sofort eine Ultimatum-Entscheidung treffen, aber was kann getan werden, um eine <em>regelm√§√üige</em> Volltextsuche einer <em>intelligenten</em> n√§her zu bringen? </p><a name="habracut"></a><br><h2 id="elementy-intellektualnosti">  Elemente der Intelligenz </h2><br><p>  Intelligente Suche - Dies ist nur dann der Fall, wenn die Quantit√§t in Qualit√§t gehen kann und viele kleine und ziemlich einfache Funktionen ein Gef√ºhl der Magie erzeugen k√∂nnen. </p><br><ul><li>  Korrektur von Benutzerfehlern - ob es sich um einen Tippfehler, ein falsches Layout oder m√∂glicherweise eine Anfrage mit einer verd√§chtig geringen Anzahl von Ergebnissen handelt, die jedoch einer Anfrage √§hnelt, f√ºr die es viel mehr Informationen gibt. </li><li>  F√ºr <del>  th </del>  NLP-Chats (Verarbeitung nat√ºrlicher Sprache, nicht das, was Sie dachten) - Wenn der Benutzer <em><strong>im letzten Jahr kommerzielle Angebote</strong></em> eingegeben hat, wollte er wirklich im Text aller Dokumente nach diesen W√∂rtern suchen oder brauchte er wirklich nur kommerzielle Angebote und erst im letzten Jahr ? </li><li>  Prognostizieren Sie Eingaben basierend auf fr√ºheren Abfragen oder beliebten Dokumenten. </li><li> Die Pr√§sentation des Ergebnisses ist das √ºbliche Highlight des gefundenen Fragments. Zus√§tzliche Informationen h√§ngen davon ab, wonach Sie gesucht haben.  Da im vorherigen Absatz kommerzielle Vorschl√§ge erforderlich waren, ist es m√∂glicherweise sinnvoll, das Thema des Vorschlags und die Organisation, von der er stammt, sofort anzuzeigen. </li><li>  Einfacher Drilldown - die M√∂glichkeit, die Suchabfrage mithilfe zus√§tzlicher Filter und Facetten zu verfeinern. </li></ul><br><h2 id="vvodnaya">  Einf√ºhrung </h2><br><p>  Es gibt ein ECM-DIRECTUM mit vielen Dokumenten.  Das Dokument besteht aus einer Karte mit Metainformationen und einem Textk√∂rper, der mehrere Versionen haben kann. </p><br><p>  Ziel ist es, schnell und bequem nach Informationen in diesen Dokumenten zu suchen, wie es f√ºr einen Benutzer von Suchmaschinen √ºblich ist. </p><br><h2 id="indeksirovanie">  Indizierung </h2><br><blockquote>  Um nach etwas Gutem zu suchen, m√ºssen Sie es zuerst gut indizieren. </blockquote><p>  Dokumente in ECM sind nicht statisch. Benutzer √§ndern Text, erstellen neue Versionen und √§ndern Daten auf Karten.  Es werden st√§ndig neue Dokumente erstellt und alte manchmal gel√∂scht. <br>  Um die aktuellen Informationen in Elasticsearch auf dem neuesten Stand zu halten, m√ºssen Dokumente st√§ndig neu indiziert werden.  Gl√ºcklicherweise verf√ºgt ECM bereits √ºber eine eigene Warteschlange f√ºr asynchrone Ereignisse. Wenn Sie also ein Dokument √§ndern, f√ºgen Sie es einfach zur Indizierung in die Warteschlange ein. </p><br><h3 id="otobrazhenie-dokumentov-ecm-na-dokumenty-elasticsearch">  Zuordnen von ECM-Dokumenten zu Elasticsearch-Dokumenten </h3><br><p>  Ein Dokumentk√∂rper in ECM kann mehrere Versionen haben.  In Elasticsearch k√∂nnte dies als ein Array verschachtelter Objekte betrachtet werden, aber dann wird es unpraktisch, mit ihnen zu arbeiten. Es wird schwieriger, Abfragen zu schreiben. Wenn Sie eine der Versionen √§ndern, m√ºssen Sie alles neu indizieren. Verschiedene Versionen desselben Dokuments k√∂nnen nicht in verschiedenen Indizes gespeichert werden (warum ist dies m√∂glicherweise erforderlich?) im n√§chsten Abschnitt).  Daher denormalisieren wir ein Dokument aus ECM in mehrere Elasticsearch-Dokumente mit derselben Karte, aber unterschiedlichen K√∂rpern. </p><br><p>  Zus√§tzlich zu Karte und K√∂rper werden dem Elasticsearch-Dokument verschiedene Serviceinformationen hinzugef√ºgt, die separat erw√§hnt werden sollten: </p><br><ul><li>  eine Liste von IDs von Gruppen und Benutzern, die Rechte an dem Dokument haben - f√ºr Suchen mit Rechten; </li><li>  die Anzahl der Aufrufe des Dokuments - zur Optimierung der Relevanz; </li><li>  Zeitpunkt der letzten Indizierung. </li></ul><br><h3 id="sostav-indeksov">  Indexzusammensetzung </h3><br><p>  Ja, Pluralindizes.  Normalerweise werden mehrere Indizes zum Speichern von Informationen mit √§hnlicher Bedeutung in Elasticsearch nur verwendet, wenn diese Informationen unver√§nderlich und an einen bestimmten Zeitraum gebunden sind, z. B. Protokolle.  Dann werden die Indizes je nach Intensit√§t der Belastung jeden Monat / Tag oder h√§ufiger erstellt.  In unserem Fall kann jedes Dokument ge√§ndert werden, und es w√§re m√∂glich, alles in einem Index zu speichern. </p><br><p>  Aber - die Dokumente im System k√∂nnen in verschiedenen Sprachen vorliegen, und das Speichern mehrsprachiger Daten in Elasticsearch bringt zwei Probleme mit sich: </p><br><ul><li>  Falsches Stemming.  Bei einigen W√∂rtern wird die Basis korrekt gefunden, bei einigen - falsch (es gibt ein anderes Wort im Index), bei einigen - wird sie √ºberhaupt nicht gefunden (der Index wird mit Wortformen verstopft).  Bei einigen W√∂rtern aus verschiedenen Sprachen und mit unterschiedlichen Bedeutungen ist die Basis dieselbe, und dann geht die Bedeutung des Wortes verloren.  Die Verwendung mehrerer Stemmers hintereinander kann zu einer zus√§tzlichen Berechnung der Basis f√ºr einen bereits berechneten f√ºhren. </li></ul><br><blockquote>  Stamming - die Basis des Wortes finden.  Der Stamm muss nicht die Wurzel des Wortes oder seine normale Form sein.  Normalerweise reicht es aus, wenn die zugeh√∂rigen W√∂rter in ein Framework projiziert werden. <br>  Lemmatisierung ist eine Art von Stemming, bei der die normale (Vokabular-) Form eines Wortes als Grundlage betrachtet wird. </blockquote><br><ul><li>  Falsche Worth√§ufigkeit.  Einige Relevanzbestimmungsmechanismen in ES ber√ºcksichtigen die H√§ufigkeit der gesuchten W√∂rter im Dokument (je h√§ufiger, desto h√∂her die Relevanz) und die H√§ufigkeit der gesuchten W√∂rter im Index (je h√§ufiger, desto geringer die Relevanz).  Eine kleine Verbreitung der russischen Sprache in einem englischen Dokument, wenn die englischen Dokumente √ºberwiegend im Index enthalten sind, hat ein hohes Gewicht, es lohnt sich jedoch, die englischen und russischen Dokumente im Index zu mischen, und das Gewicht nimmt ab. </li></ul><br><p>  Das erste Problem kann f√ºr den Fall gel√∂st werden, dass verschiedene Sprachen unterschiedliche Zeichens√§tze verwenden (russisch-englische Dokumente verwenden kyrillische und lateinische Buchstaben) - Sprachstemmer verarbeiten nur "ihre" Zeichen. </p><br><p>  Um das zweite Problem zu l√∂sen, haben wir den Ansatz mit einem eigenen Index f√ºr jede Sprache verwendet. </p><br><p>  Wenn wir beide Ans√§tze kombinieren, erhalten wir Sprachindizes, die dennoch Analysatoren f√ºr mehrere Sprachen enthalten, die sich nicht in jedem Zeichensatz √ºberschneiden: Russisch-Englisch (und separat Englisch-Russisch), Polnisch-Russisch, Deutsch-Russisch, Ukrainisch-Englisch usw. . </p><br><p>  Um nicht alle m√∂glichen Indizes im Voraus zu erstellen, haben wir Indexvorlagen verwendet. Mit Elasticsearch k√∂nnen Sie eine Vorlage angeben, die Einstellungen und Zuordnungen enth√§lt, und ein Indexnamenmuster angeben.  Wenn Sie versuchen, ein Dokument in einen nicht vorhandenen Index zu indizieren, dessen Name mit einem der Muster der Vorlage √ºbereinstimmt, wird nicht nur ein neuer Index erstellt, sondern auch Einstellungen und Zuordnungen aus der entsprechenden Vorlage werden darauf angewendet. </p><br><h3 id="struktura-indeksov">  Indexstruktur </h3><br><p>  F√ºr die Indizierung verwenden wir zwei Analysatoren gleichzeitig (√ºber mehrere Felder): Standard f√ºr die Suche nach exakten Phrasen und benutzerdefiniert f√ºr alles andere: </p><br><pre><code class="json hljs"><span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"custom"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span>}</code> </pre> <br><p>  Mit dem Kleinbuchstabenfilter ist alles klar, ich erz√§hle Ihnen von dem Rest. </p><br><p>  Die Filter russian_morphology und english_morphology dienen zur morphologischen Analyse von russischem bzw. englischem Text.  Sie sind nicht Teil von Elasticsearch und Teil eines separaten Analyse-Morphologie-Plugins.  Dies sind Lemmatisierer, die den Vokabularansatz in Kombination mit einigen Heuristiken verwenden und wesentlich besser funktionieren als die eingebauten Filter f√ºr die entsprechenden Sprachen. </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"russian"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  Und: </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  Sehr merkw√ºrdiger word_delimiter Filter.  Es hilft beispielsweise, Tippfehler zu beseitigen, wenn nach dem Punkt kein Leerzeichen steht.  Wir verwenden die folgende Konfiguration: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"catenate_all"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_original"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }</code> </pre> <br><p>  Mit yo_filter k√∂nnen Sie den Unterschied zwischen E und E ignorieren: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapping"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"mappings"</span></span>: [ <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span> ] }</code> </pre> <br><p>  ru_en_stopwords Filtertyp stop - unser W√∂rterbuch der Stoppw√∂rter. </p><br><h3 id="process-indeksirovaniya">  Indizierungsprozess </h3><br><p>  Bei den Dokumenten in ECM handelt es sich in der Regel um Dateien mit B√ºroformaten: .docx, .pdf usw.  Um den Text zu extrahieren, wird das Ingest-Attachment-Plugin mit der folgenden Pipeline verwendet: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"document_version"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"attachment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target_field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_length"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_type"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"indexed_chars"</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"lang"</span></span>: <span class="hljs-string"><span class="hljs-string">"painless"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"languages"</span></span>: [<span class="hljs-string"><span class="hljs-string">"ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"language_delimeter"</span></span>: <span class="hljs-string"><span class="hljs-string">"_"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } ] } }</code> </pre> <br><p>  Aus dem Ungew√∂hnlichen in der Pipeline, Ignorieren von Fehlern der Abwesenheit des K√∂rpers (dies geschieht bei verschl√ºsselten Dokumenten) und Bestimmen des Zielindex basierend auf der Sprache des Textes.  Letzteres geschieht in einer schmerzlosen Schrift, deren K√∂rper ich separat geben werde, weil  Aufgrund von JSON-Einschr√§nkungen muss es in eine Zeile geschrieben werden.  Zusammen mit Debugging-Schwierigkeiten (der empfohlene Weg ist, hier und da Ausnahmen auszul√∂sen) wird es zu einer schmerzhaften. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.languages.contains(ctx.attachment.language)) ctx._index = ctx._index + <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.language_delimeter + ctx.attachment.language; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content = ctx.attachment.content; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_length != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_length = ctx.attachment.content_length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_type != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_type = ctx.attachment.content_type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.language != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.language = ctx.attachment.language; }</code> </pre> <br><p>  Daher senden wir das Dokument immer an <em>index_name</em> .  Wenn die Sprache nicht definiert ist oder nicht unterst√ºtzt wird, wird das Dokument in diesem Index <em>abgelegt</em> , andernfalls f√§llt es in die <em>Indexsprache</em> . </p><br><p>  Wir speichern nicht den urspr√ºnglichen Hauptteil der Datei, aber das Feld _source ist aktiviert, weil  Es ist erforderlich, das Dokument teilweise zu aktualisieren und das gefundene zu markieren. </p><br><p>  Wenn sich nur die Karte seit der letzten Indizierung ge√§ndert hat, verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Update By Query-API</a> ohne Pipeline, um sie zu aktualisieren.  Dies erm√∂glicht es erstens, potenziell schwere Dokumentk√∂rper nicht aus ECM zu ziehen, und zweitens beschleunigt es die Aktualisierung auf der Elasticsearch-Seite erheblich - Sie m√ºssen den Text von Dokumenten nicht aus Office-Formaten extrahieren, was sehr ressourcenintensiv ist. </p><br><blockquote>  Daher gibt es in Elasticsearch √ºberhaupt keine Aktualisierung des Dokuments. Technisch gesehen wird beim Aktualisieren aus dem Index das alte Dokument herausgenommen, ge√§ndert und wieder vollst√§ndig indiziert. </blockquote><p>  Wenn sich der Text jedoch √§ndert, wird das alte Dokument im Allgemeinen gel√∂scht und von Grund auf neu indiziert.  Dadurch k√∂nnen Dokumente von einem Sprachindex in einen anderen <em>verschoben werden</em> . </p><br><h2 id="poisk">  Suche </h2><br><p>  Um die Beschreibung zu vereinfachen, werde ich einen Screenshot des Endergebnisses geben </p><br><p><img src="https://habrastorage.org/webt/ni/l4/xm/nil4xm-qrg7meikrjbd16mt_ziq.png"></p><br><h3 id="polnotekst">  Volltext </h3><br><p>  Der Haupttyp der Abfrage ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simple Query String Query</a> : </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"simple_query_string"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"card.d*.*_text"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.d*.*_text.exact"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name.exact^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content.exact"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default_operator"</span></span>: <span class="hljs-string"><span class="hljs-string">"or"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyze_wildcard"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum_should_match"</span></span>: <span class="hljs-string"><span class="hljs-string">"-35%"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quote_field_suffix"</span></span>: <span class="hljs-string"><span class="hljs-string">".exact"</span></span> }</code> </pre> <br><p>  Dabei sind <em>.exact</em> die vom <em>Standardparser</em> indizierten Felder.  Die Wichtigkeit des Namens des Dokuments ist doppelt so hoch wie in den anderen Feldern.  Mit der Kombination von <code>"default_operator": "or"</code> und <code>"minimum_should_match": "-35%"</code> k√∂nnen Sie Dokumente finden, die nicht bis zu 35% der gesuchten W√∂rter enthalten. </p><br><h3 id="sinonimy">  Synonyme </h3><br><p>  Im Allgemeinen werden verschiedene Analysatoren f√ºr die Indizierung und Suche verwendet. Der einzige Unterschied besteht darin, dass ein Filter hinzugef√ºgt wird, um der Suchabfrage Synonyme hinzuzuf√ºgen: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"search_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span> }</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonym_graph"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"synonyms_path"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonyms.txt"</span></span> }</code> </pre> <br><h3 id="uchyot-prav">  Buchhaltungsrechte </h3><br><p>  Bei rechtsbasierten Suchvorg√§ngen ist die Hauptabfrage mit einem zus√§tzlichen Filter in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bool Query</a> eingebettet: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"simple_query_string"</span></span>: {...} } ], <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"rights"</span></span>: [           ] } } ] }</code> </pre> <br><p>  Wie wir uns aus dem Abschnitt √ºber die Indizierung erinnern, enth√§lt der Index ein Feld mit der ID von Benutzern und Gruppen, die Rechte an dem Dokument haben.  Wenn es einen Schnittpunkt dieses Feldes mit dem √ºbergebenen Array gibt, gibt es Rechte. </p><br><h3 id="tyuning-relevantnosti">  Relevanz-Tuning </h3><br><p>  Standardm√§√üig bewertet Elasticsearch die Relevanz der Ergebnisse mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BM25-</a> Algorithmus anhand der Abfrage und des Textes des Dokuments.  Wir haben beschlossen, dass drei weitere Faktoren die Bewertung der Einhaltung des gew√ºnschten und tats√§chlichen Ergebnisses beeinflussen sollten: </p><br><ul><li>  der Zeitpunkt der letzten Bearbeitung des Dokuments - je weiter es in der Vergangenheit war, desto weniger wahrscheinlich ist es, dass dieses Dokument ben√∂tigt wird; </li><li>  die Anzahl der Aufrufe des Dokuments - je mehr, desto wahrscheinlicher ist es, dass dieses Dokument ben√∂tigt wird; </li><li><p>  ECM-Karosserieversionen haben mehrere m√∂gliche Zust√§nde: entwickelt, betriebsbereit und veraltet.  Es ist logisch, dass das Handeln wichtiger ist als die anderen. </p><br><p>  Sie k√∂nnen diesen Effekt mit Hilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Function Score Query</a> erzielen: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"function_score"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"functions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"gauss"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"modified_date"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"now"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"1095d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"offset"</span></span>: <span class="hljs-string"><span class="hljs-string">"31d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"decay"</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span> } } }, { <span class="hljs-attr"><span class="hljs-attr">"field_value_factor"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"access_count"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"modifier"</span></span>: <span class="hljs-string"><span class="hljs-string">"log2p"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"term"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"life_stage_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">1.1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: {...} } }</code> </pre> <br><p>  Als Ergebnis, ceteris paribus, erhalten wir ungef√§hr die folgende Abh√§ngigkeit des Ergebnisbewertungsmodifikators vom Datum seiner letzten √Ñnderung X und der Anzahl der Treffer Y: </p><br></li></ul><br><p></p><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/wa/wz/td/wawztd9zvlz-fetkplnfrjw8ddy.png"></a> </div><p></p><br><h3 id="vneshniy-intellekt">  Externe Intelligenz </h3><br><p>  F√ºr einen Teil der Funktionalit√§t der intelligenten Suche m√ºssen wir verschiedene <em>Fakten</em> aus der Suchabfrage extrahieren: Daten mit ihrer Anwendung (Erstellung, √Ñnderung, Genehmigung usw.), Namen von Organisationen, Arten von gesuchten Dokumenten usw. </p><br><p>  Es ist auch w√ºnschenswert, die Anfrage in eine bestimmte Kategorie einzuteilen, z. B. Dokumente nach Organisation, Mitarbeiter, Aufsichtsbeh√∂rden usw. </p><br><p>  Diese beiden Vorg√§nge werden vom ECM Intelligent Module - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DIRECTUM Ario ausgef√ºhrt</a> . </p><br><h3 id="process-umnogo-poiska">  Intelligenter Suchprozess </h3><br><p>  Es ist an der Zeit, genauer zu √ºberlegen, welche Mechanismen als Elemente der Intelligenz implementiert sind. </p><br><h4 id="ispravlenie-oshibok-polzovatelya">  Benutzerfehlerkorrektur </h4><br><p>  Die Richtigkeit des Layouts wird anhand des Trigramm-Sprachmodells bestimmt. F√ºr eine Zeile wird berechnet, wie wahrscheinlich es ist, dass die dreistelligen Sequenzen in Texten in Englisch und Russisch erf√ºllt werden.  Wenn das aktuelle Layout als weniger wahrscheinlich angesehen wird, wird zun√§chst ein Hinweis mit einem korrekten Layout angezeigt: </p><br><p><img src="https://habrastorage.org/webt/ek/ow/c5/ekowc5ikjiwx1xe87b5wewhoohm.png"></p><br><p>  und zweitens werden die weiteren Schritte der Suche mit dem richtigen Layout ausgef√ºhrt: </p><br><p><img src="https://habrastorage.org/webt/ug/dr/tc/ugdrtchejvx024datttkc_zcxxw.png"></p><br><p>  Und wenn mit dem korrigierten Layout nichts gefunden werden kann, beginnt die Suche mit der urspr√ºnglichen Zeile. </p><br><p>  Die Tippfehlerkorrektur wird mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phrase Suggester</a> implementiert.  Es liegt ein Problem vor: Wenn Sie eine Abfrage f√ºr mehrere Indizes gleichzeitig ausf√ºhren, wird vorgeschlagen, dass m√∂glicherweise nichts zur√ºckgegeben wird. Wenn Sie nur f√ºr einen Index ausf√ºhren, werden Ergebnisse angezeigt.  Dies <em>wird behandelt, indem</em> das Vertrauen auf 0 gesetzt wird. Dann wird jedoch vorgeschlagen, W√∂rter durch ihre normale Form zu ersetzen.  Stimmen Sie zu, es wird seltsam sein, wenn Sie nach "Buchstabe <strong>a</strong> " suchen, um eine Antwort im Geiste zu erhalten: <em>Vielleicht haben Sie nach einem Brief <strong>√ºber</strong> gesucht?</em> </p><br><p>  Dies kann umgangen werden, indem zwei Eingabeaufforderungen in der Anforderung verwendet werden: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"content_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} } }, } }, <span class="hljs-string"><span class="hljs-string">"check_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} - ({{source_query}}) }, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source_query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } }, } } }</code> </pre> <br><p>  Von den gebr√§uchlichen Parametern </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"confidence"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-string"><span class="hljs-string">"max_errors"</span></span>: <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Wenn der erste Opinester das Ergebnis zur√ºckgegeben hat, der zweite jedoch nicht, ist dieses Ergebnis die urspr√ºngliche Zeichenfolge selbst, m√∂glicherweise mit W√∂rtern in anderen Formen, und es besteht keine Notwendigkeit, einen Hinweis anzuzeigen.  Wenn der Hinweis weiterhin ben√∂tigt wird, wird der urspr√ºngliche Suchbegriff mit dem Hinweis zusammengef√ºhrt.  Dies geschieht, indem nur die korrigierten W√∂rter ersetzt werden und nur diejenigen, die die Rechtschreibpr√ºfung (mit Hunspell) als falsch erachtet. </p><br><p>  Wenn die Suche in der Quellzeichenfolge 0 Ergebnisse ergab, wird sie durch die durch die Zusammenf√ºhrung erhaltene Zeichenfolge ersetzt und die Suche wird erneut ausgef√ºhrt: </p><br><p><img src="https://habrastorage.org/webt/up/r3/wx/upr3wxky4mkbeyy3exjocbwzocy.png"></p><br><p>  Andernfalls wird die resultierende Eingabeaufforderungszeichenfolge nur als Eingabeaufforderung f√ºr die Suche zur√ºckgegeben: </p><br><p><img src="https://habrastorage.org/webt/qv/ts/4t/qvts4tauspo9yspwy_itbzcdttq.png"></p><br><h4 id="klassifikaciya-zaprosov-i-izvlechenie-faktov">  Abfrageklassifizierung und Faktenextraktion </h4><br><p>  Wie bereits erw√§hnt, verwenden wir DIRECTUM Ario, n√§mlich den Textklassifizierungsdienst und den Faktenextraktionsdienst.  Zu diesem Zweck haben wir Analysten anonyme Suchanfragen und eine Liste mit Fakten gestellt, an denen wir interessiert sind.  Basierend auf Abfragen und dem Wissen dar√ºber, welche Dokumente sich im System befinden, identifizierten die Analysten mehrere Kategorien und schulten den Klassifizierungsdienst, um die Kategorie gem√§√ü dem Abfragetext zu bestimmen.  Basierend auf den resultierenden Kategorien und der Liste der Fakten haben wir die Regeln f√ºr die Verwendung dieser Fakten formuliert.  Beispielsweise wird der Ausdruck <em><strong>f√ºr das letzte Jahr</strong></em> in der Kategorie <strong>Jeder</strong> als Erstellungsdatum des Dokuments und in der Kategorie <strong>Nach Organisation</strong> als Registrierungsdatum betrachtet.  Gleichzeitig sollten die im <em><strong>letzten Jahr erstellten</strong></em> in jeder Kategorie auf das Erstellungsdatum fallen. </p><br><p>  Von der Suchseite aus haben sie eine Konfiguration erstellt, in der sie die Kategorien registriert haben, welche Fakten auf welche Facettenfilter angewendet werden. </p><br><h4 id="avtodopolnenie-vvoda">  Eingabe abgeschlossen </h4><br><p>  Zus√§tzlich zu den bereits erw√§hnten Layoutkorrekturen werden fr√ºhere Suchanfragen des Benutzers und √∂ffentliche Dokumente automatisch vervollst√§ndigt. </p><br><p><img src="https://habrastorage.org/webt/zc/52/yo/zc52yohihrkkrnny6ekla80-mro.png"></p><br><p>  Sie werden mit einem anderen Suggestertyp implementiert - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Completion Suggester</a> , aber jeder hat seine eigenen Nuancen. </p><br><h5 id="avtodopolnenie-istoriya-poiskov">  Autovervollst√§ndigung: Suchverlauf </h5><br><p>  ECM enth√§lt weit weniger Benutzer als Suchmaschinen und weist ihnen gen√ºgend allgemeine Abfragen zu <del>  warum Lenin Pilz </del>  nicht m√∂glich.  Alles in einer Reihe zu zeigen, lohnt sich aus Datenschutzgr√ºnden ebenfalls nicht.  Der √ºbliche Vervollst√§ndigungsvorschlag kann nur den gesamten Satz von Dokumenten im Index durchsuchen, aber der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontextvorschlag hilft dabei</a> - eine M√∂glichkeit, einen Kontext f√ºr jeden Hinweis festzulegen und nach diesen Kontexten zu filtern.  Wenn Benutzernamen als Kontexte verwendet werden, kann jedem nur sein Verlauf angezeigt werden. </p><br><p>  Sie m√ºssen dem Benutzer auch die M√∂glichkeit geben, die Eingabeaufforderung zu entfernen, f√ºr die er sich sch√§mt.  Als Schl√ºssel zum L√∂schen haben wir den Benutzernamen und den QuickInfo-Text verwendet.  Als Ergebnis haben wir f√ºr den Index mit Hinweisen eine so leicht duplizierte Zuordnung erhalten: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"mappings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"document"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"completion"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"simple"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_separators"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_position_increments"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_input_length"</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">"contexts"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"CATEGORY"</span></span> } ] }, <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> } } } }</code> </pre> <br><p>  Die Gewichtung f√ºr jeden neuen Hinweis wird auf eins festgelegt und erh√∂ht sich jedes Mal, wenn Sie ihn mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Update By Query-API</a> mit einem sehr einfachen Skript <code>ctx._source.suggest.weight++</code> . </p><br><h5 id="avtodopolnenie-dokumenty">  Autovervollst√§ndigung: Dokumente </h5><br><p>  Es kann jedoch viele Dokumente und m√∂gliche Kombinationen von Rechten geben.  Im Gegenteil, wir haben uns hier entschieden, beim automatischen Ausf√ºllen nicht nach Rechten zu filtern, sondern nur √∂ffentliche Dokumente zu indizieren.  Ja, und Sie m√ºssen keine einzelnen Tipps aus diesem Index entfernen.  Es scheint, dass die Implementierung in allem einfacher ist als in der vorherigen, wenn nicht in zwei Punkten: </p><br><p>  Der erste - Completion Suggester unterst√ºtzt nur die Pr√§fixsuche, und Kunden lieben es, <code>.01.01   </code> Artikelnummern und einigen <code>.01.01   </code> beim <code>.01.01   </code> einer Abfrage zuzuweisen. Es gibt <code>.01.01   </code> .  Hier k√∂nnen Sie neben dem vollst√§ndigen Namen auch davon abgeleitete n-Gramm indizieren: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"extension"</span></span>: <span class="hljs-string"><span class="hljs-string">"pdf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">90</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } ] }</code> </pre> <br><p>  Dies war bei der Geschichte nicht so kritisch, dennoch gibt derselbe Benutzer ungef√§hr dieselbe Zeile ein, wenn er erneut nach etwas sucht.  <em>Wahrscheinlich</em> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/rc/dv/bircdvzu2hvcblxhrryvauzajf0.png"></div><br><p>  Die zweite - standardm√§√üig sind alle Tipps gleich, aber wir m√∂chten einige davon gleich und vorzugsweise so gestalten, dass dies mit der Rangfolge der Suchergebnisse √ºbereinstimmt.  Wiederholen Sie dazu grob die in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktions-Score-Abfrage</a> verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen</a> gauss und field_value_factor. </p><br><p>  Es stellt sich heraus, dass hier eine solche Pipeline ist: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"dir_public_documents_pipeline"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ ... { <span class="hljs-attr"><span class="hljs-attr">"set"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{name}}"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"split"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"separator"</span></span>: <span class="hljs-string"><span class="hljs-string">"\\s+|$"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } } ] } }</code> </pre> <br><p>  mit folgendem Skript: </p><br><pre> <code class="cs hljs">Date modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.modified_date != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">'dd.MM.yyyy'</span></span>).parse(ctx.modified_date); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> dayCount = (System.currentTimeMillis() - modified.getTime())/(<span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> score = Math.exp((<span class="hljs-number"><span class="hljs-number">-0.7</span></span>*Math.max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dayCount - <span class="hljs-number"><span class="hljs-number">31</span></span>))/<span class="hljs-number"><span class="hljs-number">1095</span></span>) * Math.log10(ctx.access_count + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = ctx.terms_array.length; ctx.suggest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">'input'</span></span>: ctx.terms_array[count - <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'weight'</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - count + <span class="hljs-number"><span class="hljs-number">1</span></span>)) ]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = count - <span class="hljs-number"><span class="hljs-number">2</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ; --i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.terms_array[i].trim() != <span class="hljs-string"><span class="hljs-string">""</span></span>) { ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">"input"</span></span>: ctx.terms_array[i] + <span class="hljs-string"><span class="hljs-string">" "</span></span> + ctx.suggest[ctx.suggest.length - <span class="hljs-number"><span class="hljs-number">1</span></span>].input, <span class="hljs-string"><span class="hljs-string">"weight"</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - i))]); } } ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'terms_array'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'access_count'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'modified_date'</span></span>);</code> </pre> <br><p>  Warum sich mit einer schmerzlosen Pipeline besch√§ftigen, anstatt sie in einer bequemeren Sprache zu schreiben?  Mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reindex-API</a> k√∂nnen Sie jetzt den Inhalt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchindizes</a> in Indizes f√ºr Hinweise (indem Sie nat√ºrlich nur die erforderlichen Felder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angeben</a> ) in nur einem Befehl √ºbernehmen. </p><br><p>  Die Zusammensetzung der wirklich ben√∂tigten √∂ffentlichen Dokumente wird nicht oft aktualisiert, sodass dieser Befehl bei einem manuellen Start belassen werden kann. </p><br><h3 id="otobrazhenie-rezultatov">  Ergebnisse anzeigen </h3><br><h4 id="kategorii">  Kategorien </h4><br><p>  Die Kategorie bestimmt, welche Facetten verf√ºgbar sind und wie das Snippet aussehen wird.  Es kann automatisch von <em>externer Intelligenz</em> erkannt oder manuell √ºber der Suchleiste ausgew√§hlt werden. </p><br><h4 id="fasety">  Facetten </h4><br><p>  Facetten sind so intuitiv f√ºr jeden, dessen Verhalten jedoch durch sehr nicht triviale Regeln beschrieben wird.  Hier sind einige davon: </p><br><ol><li><p>  Facettenwerte h√§ngen von den Suchergebnissen ab, ABER und die Suchergebnisse h√§ngen von den ausgew√§hlten Facetten ab.  Wie vermeide ich eine Rekursion? </p><br></li><li><p>  Das Ausw√§hlen von Werten innerhalb einer Facette wirkt sich nicht auf andere Werte dieser Facette aus, wirkt sich jedoch auf Werte in anderen Facetten aus: </p><br></li></ol><br><p><img src="https://habrastorage.org/webt/60/ei/g6/60eig601ltskcwvcesh5zno8crc.png"></p><br><ol><li>  Vom Benutzer ausgew√§hlte Facettenwerte sollten nicht verschwinden, selbst wenn eine Auswahl in einer anderen Facette sie auf 0 <em>vernichtet</em> oder sie nicht mehr oben stehen: </li></ol><br><p><img src="https://habrastorage.org/webt/mu/6u/e-/mu6ue-ybxh3sa9h6ymkj1idn_ti.png"></p><br><p>  In Bezug auf die Elastizit√§t werden Facetten durch den Aggregationsmechanismus realisiert. Um jedoch den beschriebenen Regeln zu entsprechen, m√ºssen diese Aggregationen ineinander investiert und voneinander gefiltert werden. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/jt/zu/zdjtzudyw9iei8x-tjarja-a5tm.jpeg"></div><br><p>  Betrachten Sie die daf√ºr verantwortlichen Anforderungsfragmente: </p><br><div class="spoiler">  <b class="spoiler_title">Code zu gro√ü</b> <div class="spoiler_text"><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"post_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } } ] } }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} <span class="hljs-string"><span class="hljs-string">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"editor_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... } }</code> </pre> </div></div><br><p>  Was ist hier das: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit post_filter</a> k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> den Ergebnissen einer bereits abgeschlossenen Abfrage eine zus√§tzliche Bedingung auferlegen, ohne die Ergebnisse von Aggregationen zu beeinflussen.  Dieselbe Rekursionsl√ºcke.  Beinhaltet alle ausgew√§hlten Werte aller Facetten. </li><li>  Aggregationen der obersten Ebene im Beispiel <em>card.author_value_id</em> und <em>editor_value_id</em> .  Jeder hat: <br><ul><li>  Filtern Sie nach den Werten aller anderen Facetten mit Ausnahme Ihrer eigenen. </li><li>  verschachtelte Aggregation f√ºr ausgew√§hlte Facettenwerte - <em>Schutz vor Vernichtung</em> ; </li><li>  verschachtelte Aggregation f√ºr andere Facettenwerte.  Wir zeigen die Top 10 an und fordern die Top 11 an, um zu bestimmen, ob die Schaltfl√§che <strong>Alle</strong> anzeigen angezeigt werden soll. </li></ul></li></ul><br><h4 id="snippety">  Schnipsel </h4><br><p>  Abh√§ngig von der ausgew√§hlten Kategorie kann das Snippet bei der Suche in einer Kategorie unterschiedlich aussehen, z. B. dasselbe Dokument </p><br><p>  <strong>Alle</strong> : </p><br><p><img src="https://habrastorage.org/webt/ka/_b/ia/ka_biaaygfgbsk2msyfhu-bnkse.png"></p><br><p>  und <strong>Mitarbeiter</strong> : </p><br><p><img src="https://habrastorage.org/webt/5i/po/k_/5ipok_qgkc9170ucyidespnnitc.png"></p><br><p>  Oder erinnern Sie sich, wir wollten das Thema eines kommerziellen Angebots sehen und von wem es kam? </p><br><p><img src="https://habrastorage.org/webt/-i/7z/g7/-i7zg7dwh7kbs9e9_2yk3fnxc6k.png"></p><br><p>  Um nicht die gesamte Karte aus dem Gummiband zu ziehen (dies verlangsamt die Suche), wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellfilterung verwendet</a> : </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"_source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"includes"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.card_type_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.life_stage_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"extension"</span></span>, ... ] }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... }</code> </pre> <br><p>  Um die im Text des Dokuments enthaltenen W√∂rter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hervorzuheben,</a> wird der Textmarker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fast Vector</a> verwendet, um die am besten geeigneten Snippets f√ºr gro√üe Texte zu generieren, und der Name <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unified Highlighter</a> als am wenigsten anspruchsvoll f√ºr Ressourcen und Indexstruktur: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"highlight"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pre_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"post_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;/strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"encoder"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.name"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"content"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fragment_size"</span></span>: <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"fvh"</span></span> } } },</code> </pre> <br><p>  In diesem Fall wird der Name vollst√§ndig hervorgehoben, und aus dem Text erhalten wir bis zu 3 Fragmente mit einer L√§nge von 300 Zeichen.  Der vom Fast Vector-Textmarker zur√ºckgegebene Text wird durch einen provisorischen Algorithmus weiter komprimiert, um einen minimierten Snippet-Status zu erhalten. </p><br><h3 id="kollaps">  Zusammenbruch </h3><br><p>  In der Vergangenheit sind Benutzer dieses ECM daran gew√∂hnt, dass die Suche <em>Dokumente an</em> sie zur√ºckgibt. Tats√§chlich sucht Elasticsearch jedoch zwischen <em>Dokumentversionen</em> .  Es kann sich herausstellen, dass mehrere nahezu identische Versionen in derselben Abfrage gefunden werden.  Dies wird die Ergebnisse durcheinander bringen und den Benutzer verwirren.  Gl√ºcklicherweise kann dieses Verhalten vermieden werden, indem der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Field Collapsing-</a> Mechanismus verwendet wird - eine leichtgewichtige Version von Aggregationen, die bereits mit den fertigen Ergebnissen arbeitet (in dieser √§hnelt es post_filter, <em>zwei Kr√ºcken sind ein Paar</em> ).  Der <em>Zusammenbruch</em> f√ºhrt zu dem relevantesten der zusammenbrechenden Objekte. </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... <span class="hljs-string"><span class="hljs-string">"collapse"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"id"</span></span> } }</code> </pre> <br><p>  Leider hat der Zusammenbruch eine Reihe unangenehmer Auswirkungen, zum Beispiel kehren verschiedene numerische Merkmale des Suchergebnisses weiter zur√ºck, als ob es keinen Zusammenbruch gegeben h√§tte.  Das hei√üt, die Anzahl der Ergebnisse, die Anzahl der Facettenwerte - alle sind <em>leicht</em> falsch, aber der Benutzer bemerkt dies normalerweise nicht, ebenso wie der m√ºde Leser, der diesen Vorschlag wahrscheinlich noch nicht gelesen hat. </p><br><p>  Das Ende. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460263/">https://habr.com/ru/post/de460263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460253/index.html">10 Gr√ºnde, Ihre F√§higkeiten als Sprachassistent zu verbessern</a></li>
<li><a href="../de460255/index.html">Backdoor auf Node.js: warum, warum und wie es funktioniert</a></li>
<li><a href="../de460257/index.html">Hallo Welt! Tiefes Eintauchen in Terminals</a></li>
<li><a href="../de460259/index.html">Was ist UI- und UX-Design? Was ist gemeinsam und anders?</a></li>
<li><a href="../de460261/index.html">Amazon: 25 Jahre E-Commerce-Erfolg</a></li>
<li><a href="../de460265/index.html">Erstellen Sie eine Xcode-Projektvorlage</a></li>
<li><a href="../de460273/index.html">Autorisierung in Apple Pay f√ºr die Kleinsten</a></li>
<li><a href="../de460275/index.html">Warum brauchen Sie nicht die perfekte L√∂sung?</a></li>
<li><a href="../de460279/index.html">10-Milliarden-Vertrag: Wer wird sich mit der Cloud f√ºr das Pentagon befassen?</a></li>
<li><a href="../de460281/index.html">Wie UX Writer zur Produktverbesserung beitr√§gt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>