<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîï üì† ü¶é NodeMCU Simple Driver Model (SDM) Schaufenster: Dynamische Benutzeroberfl√§che üèÅ üèáüèª ‚èÆÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="NodeMCU ist eine interaktive Firmware , mit der der Lua- Interpreter auf dem ESP8266- Mikrocontroller ausgef√ºhrt werden kann ( ESP32- Unterst√ºtzung be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NodeMCU Simple Driver Model (SDM) Schaufenster: Dynamische Benutzeroberfl√§che</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449992/"><p><img src="https://habrastorage.org/webt/45/dq/e8/45dqe8yvyxvpg_kcien-88xslei.jpeg" alt="Bild"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NodeMCU</a> ist eine <em>interaktive Firmware</em> , mit der der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lua-</a> Interpreter auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ESP8266-</a> Mikrocontroller ausgef√ºhrt werden kann ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ESP32-</a> Unterst√ºtzung befindet sich in der Entwicklung).  Neben allen regul√§ren Hardwareschnittstellen verf√ºgt es √ºber ein WiFi-Modul und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SPIFFS-</a> Dateisystem. </p><br><p>  Dieser Artikel beschreibt das neue Modul f√ºr die NodeMCU - sdm.  SDM steht f√ºr einfaches Treibermodell und bietet eine Abstraktion des Ger√§tetreibermodells f√ºr das System.  Im ersten Teil dieses Artikels werden wir das Modell selbst diskutieren und im zweiten Teil werden einige dynamisch erstellte Webbenutzeroberfl√§chen mit sdm mit einigen Kommentaren vorgestellt. </p><a name="habracut"></a><br><h1 id="driver-model-basics">  Grundlagen des Fahrermodells </h1><br><p>  Zwei Hauptkomponenten des Modells sind <em>Ger√§te</em> und <em>Treiber</em> .  Ger√§t ist eine abstrakte Darstellung einer Hardware oder eines virtuellen Ger√§ts.  Es ist sinnvoll, Ger√§te in einer Baumhierarchie zu platzieren, mit dem Mikrocontroller oben, Bussen in der Mitte und Sensoren als Bl√§tter. </p><br><pre><code class="plaintext hljs">DEVICES + DRIVERS | +-----+ | +-----+ |1WIRE&lt;----------------------+1WIRE| ++-+-++ | +-----+ | | | | +---------+ | +--------+ | +------+ | | | +------+DS1820| +---v----+ +---v----+ +---v----+ | | +------+ |DS1820|0| |DS1820|1| |DS1822|0| | | +---^----+ +---^----+ +---^----+ | | +------+ | | +--------------+DS1822| | | | | +------+ +-----------+------------------+ +</code> </pre> <br><p>  Der Ger√§tetreiber ist eine Logik, die einem bestimmten Ger√§t zugeordnet ist.  Vom Treiber bereitgestellte Funktionen werden als <em>Methoden bezeichnet</em> , dem Treiber zugeordnete Datencontainer werden als <em>Attribute bezeichnet</em> .  Sowohl Methoden als auch Attribute befinden sich im Treiber. </p><br><p>  Mit Attributen sind zwei Funktionen verbunden: <em>Getter-</em> und <em>Setter-</em> Hooks.  Attribute also Superset-Methodenfunktionalit√§t, aber sie beanspruchen auch mehr Speicher (Mikrocontroller-Speicher ist knapp, erinnerst du dich?). </p><br><pre> <code class="lua hljs">sdm.attr_add(drv, <span class="hljs-comment"><span class="hljs-comment">-- device handle "ref", -- attribute name "Reference voltage", -- attribute description 5, function(dev) -- this is a getter function return sdm.attr_data(sdm.attr_handle(dev, "ref")) end, function(dev, value) -- this is a setter function sdm.attr_set(sdm.attr_handle(dev, "ref"), value) end )</span></span></code> </pre> <br><h2 id="device-binding">  Ger√§tebindung </h2><br><p>  Ein schwieriger Teil des Treibermodells ist die Ger√§te-Treiber-Bindung.  Der Vorgang selbst ist recht einfach: Wir passen das Ger√§t an jeden verf√ºgbaren Treiber an, bis es passt.  Es fehlen nur zwei Teile - die √úbereinstimmungslogik und einige Daten, mit denen abgeglichen werden soll. </p><br><p>  In SDM lebt die Matching-Logik in Treibern unter dem Namen <code>_poll()</code> .  Es handelt sich um eine regul√§re Methode, die mit dem Ger√§tehandle als Parameter aufgerufen wird und <code>true</code> oder <code>false</code> zur√ºckgibt <code>true</code> wenn das Ger√§t an den Treiber angeh√§ngt werden kann oder nicht. </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_poll"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_data(sdm.local_attr_handle(dev, <span class="hljs-string"><span class="hljs-string">"id"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">-- get device attribute "id" if attr == nil then return false end -- if it does not have one, driver does not match -- parent name must be "ESP8266_1W" and first byte of "id" must be "0x28" return (sdm.device_name(par) == "ESP8266_1W") and (attr:byte(1) == 0x28) end )</span></span></code> </pre> <br><p>  Wie im obigen Beispiel zu sehen ist, stimmt der Treiber mit dem Attribut des Ger√§ts √ºberein.  Wie oben erw√§hnt, werden Attribute jedoch nur dem Treiber zugeordnet.  Im Allgemeinen ist es wahr, aber es gibt einige Attribute, die nicht √ºber Software abgerufen werden k√∂nnen.  Dies sind Chip-IDs, gebrauchte Pins usw.  F√ºr diese wurde dem Attribut sdm - <em>local</em> ein spezieller Attributtyp hinzugef√ºgt.  Dieses Attribut ist einer Instanz des Ger√§ts zugeordnet und normalerweise unver√§nderlich. </p><br><p>  Das einzige, was noch √ºber die Treiberbindung zu sagen ist.  Normalerweise erfordern Ger√§te beim Start und bei der Bereinigung nach der Verwendung eine Art Initialisierung.  Zu diesem Zweck verwendet <code>_init()</code> Methoden <code>_init()</code> und <code>_free()</code> . <br>  Wenn der Treiber √ºber die Methode <code>_init()</code> , wird diese nach der <code>_init()</code> automatisch aufgerufen.  Gleiches gilt f√ºr <code>_free()</code> . </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_init"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> sdm.device_rename(dev, sdm.request_name(<span class="hljs-string"><span class="hljs-string">"DS18B20"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">-- rename device sdm.attr_copy(dev, "temp") -- copy attribute sdm.attr_copy(dev, "precision") -- copy attribute local met = sdm.method_dev_handle(par, "setup") -- get 1Wire bus pin init function .. local func = sdm.method_func(met) -- .. and .. func(par, dev) -- .. call it end ) sdm.method_add(drv, "_free", nil, function(dev, drv, par) local met = sdm.method_dev_handle(par, "free") -- get 1Wire bus pin free function .. local func = sdm.method_func(met) -- .. and .. func(par, dev) -- .. call it end )</span></span></code> </pre> <br><p>  Ein aufmerksamer Leser w√ºrde wahrscheinlich fragen: Was bedeutet "Attribut kopieren" im obigen Beispiel?  Und er h√§tte Recht, denn dies hat mit der dritten Art von Attribut zu tun, die wir noch nicht besprochen haben - dem <em>privaten Attribut</em> .  Es ist wenig sinnvoll, alle Attributdaten von allen Ger√§teinstanzen gemeinsam zu nutzen.  Zu diesem Zweck bietet sdm einen Mechanismus zum Kopieren von Attributen vom Treiber und zum Verkn√ºpfen mit dem Ger√§t.  Dadurch wird das Treiberattribut zu einem Prototyp oder einer Vorlage. </p><br><p>  Eine kurze Zusammenfassung: </p><br><ul><li>  <em>Lokale Attribute</em> werden f√ºr Daten verwendet, die von der Software nicht abgerufen werden k√∂nnen.  Wie Ger√§te-IDs, angeschlossene Pins usw. </li><li>  <em>Treiberattribute</em> werden f√ºr Daten verwendet, die von allen Instanzen von Ger√§ten gemeinsam genutzt werden, die an diesen Treiber angeschlossen sind. </li><li>  <em>Private Attribute</em> werden aus Treiberattributen kopiert und enthalten Daten, die nur einer Ger√§teinstanz zugeordnet sind.  Dieser Typ ist der h√§ufigste. </li></ul><br><div class="scrollable-table"><table><thead><tr><th>  Eigentum </th><th>  Lokales Attribut </th><th>  Privates Attribut </th><th>  Treiberattribut (√∂ffentlich) </th></tr></thead><tbody><tr><td>  Gespeichert in </td><td>  Ger√§t </td><td>  Ger√§t </td><td>  Fahrer </td></tr><tr><td>  Zug√§nglich mit Fahrergriff </td><td>  - - </td><td>  - - </td><td>  + </td></tr><tr><td>  Zugriff √ºber Ger√§tegriff </td><td>  + </td><td>  + </td><td>  + </td></tr><tr><td>  Zwischen Ger√§ten geteilt </td><td>  - - </td><td>  - - </td><td>  + </td></tr><tr><td>  Bleiben Sie beim Abnehmen des Fahrers bestehen </td><td>  + </td><td>  - - </td><td>  + </td></tr></tbody></table></div><br><h1 id="web-user-interface-implementation">  Implementierung der Webbenutzeroberfl√§che </h1><br><h2 id="server-code">  Servercode </h2><br><p>  Es gibt ein sch√∂nes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/marcoskirsch/nodemcu-">nodemcu-httpserver-</a> Projekt, das Servercode f√ºr NudeMCU implementiert.  Leider scheint es tot zu sein.  Es wurde als Basis f√ºr den Server verwendet.  Zun√§chst wurden die Serverfunktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitlab.com/matsievskiysv/nodemcu-">in LFS verschoben</a> und dann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitlab.com/matsievskiysv/nodemcu-pseudo">geringf√ºgig ge√§ndert</a> , um f√ºr jeden Aufruf eine statische Seite bereitzustellen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vue.js</a> ist die perfekte Wahl f√ºr vorlagenbasierte Webseiten.  Also wurde es f√ºr das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend verwendet</a> .  Es ist erw√§hnenswert, dass NodeMCU m√∂glicherweise nicht mit dem Internet verbunden ist.  Aus diesem <code>vue.js</code> Bibliothek <code>vue.js</code> lokal vorhanden sein und vom NodeMCU-Server bereitgestellt werden. </p><br><p>  Da alle Ger√§te in einer Baumstruktur organisiert sind, wird auf sie wie auf ein Verzeichnis zugegriffen: <code>/ESP8266/ESP8266_1W/DS18S20-0</code> .  Hier ist <code>/ESP8266</code> ESP8266 eine NodeMCU-Seite, <code>/ESP8266/ESP8266_1W</code> ist eine <em>1Wire-Busseite</em> und schlie√ülich ist <code>/ESP8266/ESP8266_1W/DS18S20-0</code> ein Temperatursensor. </p><br><p>  Wie bereits erw√§hnt, werden alle Ger√§teseiten aus einer Vorlagenseite erstellt, die bei jedem Aufruf bereitgestellt wird.  <em>Der JS-</em> Code auf dieser Seite fordert dann dieselbe URL an, der <code>/api</code> vorangestellt ist.  F√ºr das obige Beispiel w√§re die Aufruf-URL <code>/api/ESP8266/ESP8266_1W/DS18S20-0</code> .  Auf solche Anfragen antwortet der Server mit <em>JSON-</em> codierten ger√§tespezifischen Daten, die die Seite f√ºllen.  Nat√ºrlich kann die <em>HTML-</em> Seitenanforderung √ºbersprungen werden, wenn nur Rohdaten ben√∂tigt werden. </p><br><h2 id="device-tree">  Ger√§tebaum </h2><br><p>  Die anf√§ngliche Ger√§tekonfiguration erfolgt mithilfe einer <em>einfachen Ger√§tebaumstruktur</em> .  Es ist wie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ger√§tebaum</a> , aber einfacher.  Es beschreibt die Konfiguration der Hardware einschlie√ülich der lokalen Ger√§teattribute. </p><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> root={ <span class="hljs-comment"><span class="hljs-comment">-- local_attributes={}, children={ { name="ESP8266_1W", -- local_attributes={}, children = { { name="DS18S20-0", -- static declaration alternative to 1Wire poll method local_attributes={ { name="id", desc=nil, -- empty description to save space data=string.char(16) .. string.char(221) .. string.char(109) .. string.char(104) .. string.char(3) .. string.char(8) .. string.char(0) .. string.char(150) -- ugly way to create byte array }, { datapin=2 } } }, } }, { name="ESP8266_SPI", -- local_attributes={}, children = { { name="MCP3208-0" }, } }, } }</span></span></code> </pre> <br><h2 id="hardware-setup">  Hardware-Setup </h2><br><p>  Hier beginnt das Schaufenster.  Zu diesem Zweck wurden eine Reihe von Sensoren an die NodeMCU angeschlossen: </p><br><ul><li>  Temperatursensor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DS18B20</a> </li><li>  Temperatursensor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DS18S20</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MCP3208</a> ADC </li></ul><br><p>  <em>1Drahtsensoren</em> sind an denselben Pin angeschlossen. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/fb/sw/zi/fbswzi7xav_pj4waz6g19hktrso.jpeg"></a> </p><br><h2 id="web-pages-and-drivers">  Webseiten und Treiber </h2><br><h3 id="root-device">  Root-Ger√§t </h3><br><p>  Der Hauptzweck des Root-Ger√§ts (auch bekannt als ESP8266) besteht darin, seinen Kindern einen Platz zum Herstellen einer Verbindung zu bieten.  Es ist jedoch nicht darauf beschr√§nkt, Methoden oder Attribute zuzuordnen. </p><br><p>  Dieses Code-Snippet stammt von <a href="">hier</a> : </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_init"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_handle(dev, <span class="hljs-string"><span class="hljs-string">"id"</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- get device "id" attribute sdm.attr_set(attr, node.chipid()) -- set "id" value attr = sdm.attr_handle(dev, "float") -- get device "float" attribute sdm.attr_set(attr, 3 / 2 ~= 1) -- set to true if firmware supports floating point instructions end ) sdm.attr_add(drv, "float", "Floating point build", false, function(drv) -- attribute value is set inside "_init" function local attr = sdm.attr_drv_handle(drv, "float") return sdm.attr_data(attr) -- just return stored value end, nil )</span></span></code> </pre> <br><p>  Dieser Code f√ºgt das Attribut <code>float</code> hinzu, das zum Speichern des Firmware- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Build-Typs verwendet wird</a> .  Sein Wert wird im <code>_init()</code> Hook initialisiert, einer speziellen Funktion, die einmal ausgef√ºhrt wird, wenn der Treiber eine Verbindung zum Ger√§t herstellt. </p><br><p>  Dies ist die generierte Seite f√ºr das Root-Ger√§t. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mg/5q/lo/mg5qlog3-nwjkl6itrfw6ynyvuo.png"></a> </p><br><p>  Hier k√∂nnen wir sehen, dass das Root-Ger√§t einen Methodenheap, zwei Treiberattribute <code>float</code> und <code>id</code> .  Schlie√ülich sind zwei Ger√§te angeschlossen - <em>SPI-</em> und <em>1Wire-</em> Busse. </p><br><h3 id="spi">  SPI </h3><br><p>  <a href=""><em>SPI-</em> Treiber</a> ist nicht sehr interessant.  Es werden nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NodeMCU SPI-</a> Funktionen zugeordnet. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/qx/mx/g8/qxmxg8mnkmnl5aglfq7q5zhpnv0.png"></a> </p><br><h3 id="mcp3208">  Mcp3208 </h3><br><p>  <em>MCP3208</em> ist ein <em>ADC-</em> Chip.  Es misst Spannungen von Null bis <em>Ref</em> und gibt 12-Bit-Code zur√ºck.  Das Interessante an dieser <a href="">Treiberimplementierung</a> ist, dass die Attributreferenz nur dann vorhanden ist, wenn die Firmware Gleitkomma-Arithmetik unterst√ºtzt.  Wenn dies nicht unterst√ºtzt wird, wird anstelle der absoluten Spannung der Spannungscode sowohl mit <code>single</code> als auch mit <code>differential</code> . </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"single"</span></span>, <span class="hljs-string"><span class="hljs-string">"Single ended measure 0|1|2|3|4|5|6|7"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, channel)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- ... if ref ~= nil then -- this part is executed only if floating point arithmetic is enabled rv = ref * rv / 4096 end return rv end ) if 3/2~=1 then -- other alternative is to access ESP8266 "float" method sdm.attr_add(drv, "ref", "Reference voltage", 5, function(dev) return sdm.attr_data(sdm.attr_handle(dev, "ref")) end, function(dev, value) sdm.attr_set(sdm.attr_handle(dev, "ref"), value) end ) end</span></span></code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/m_/_l/cc/m__lccntxwsrorrujvky3opbm0s.png"></a> </p><br><p>  Beachten Sie auch, dass f√ºr dieses Ger√§t die Attributreferenz als <em>privat</em> markiert ist.  Es wird pro Ger√§t festgelegt. </p><br><h3 id="1wire">  1draht </h3><br><p>  <a href=""><em>1</em> Treiber Treiber</a> implementiert <code>poll</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dynamische Suche nach Ger√§ten</a> . </p><br><p>  Unmittelbar nach der Ger√§teerkennung ist der Typ nicht bekannt.  Daher wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eindeutige</a> <em>1Wire-</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Adresse</a> als neuer Ger√§tename verwendet (Bytes werden als durch <code>_</code> Zeichen getrennte Zahlen dargestellt). </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"poll"</span></span>, <span class="hljs-string"><span class="hljs-string">"Poll for devices"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bus, pin)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> children = sdm.device_children(bus) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> {} <span class="hljs-comment"><span class="hljs-comment">-- already attached local ids = {} -- get IDs of attached devices for name, handle in pairs(children) do local dpin = sdm.attr_data(sdm.local_attr_handle(handle, "pin")) if dpin == pin then ids[sdm.attr_data(sdm.local_attr_handle(handle, "id"))] = true end end ow.reset_search(pin) -- reset previous search while true do -- for all found devices local id = ow.search(pin) if id == nil then break end if ids[id] == nil then -- if not already present local name = "" for i=1,#id do name = name .. tostring(id:byte(i)) .. "_" end name = name:sub(1,-2) -- add to system with their ID used as name local device = sdm.device_add(name, bus) -- add "pin" attribute local rv = sdm.local_attr_add(device, "datapin", nil, pin, nil, nil) -- add "id" attribute local rv = sdm.local_attr_add(device, "id", nil, id, nil, nil) -- poll for driver local rv = sdm.device_poll(device) end end end )</span></span></code> </pre> <br><p>  Dies ist die erste Seite f√ºr den <em>1Wire-</em> Treiber. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/j2/uq/ax/j2uqaxkhqilv0k1fmwaq2hn0iwq.png"></a> </p><br><p>  Nach dem Ausgeben eines <code>poll</code> mit Argument <code>2</code> und dem Aktualisieren der Seite wird der untergeordnete Abschnitt angezeigt.  Beachten Sie, dass Kindernamen f√ºr Menschen lesbar sind.  Dies liegt daran, <code>device_rename()</code> Funktion <code>device_rename()</code> w√§hrend ihrer <code>_init</code> . </p><br><p> <a href=""><img src="https://habrastorage.org/webt/_z/2x/na/_z2xnadqlt_qgyokfxomwivtwkq.png"></a> </p><br><h3 id="ds18s20">  DS18S20 </h3><br><p>  Bei der Initialisierung √ºberpr√ºft der <a href="">DS18S20-Treiber</a> , ob die Ger√§te- <em>ID</em> mit <a href="">0x10</a> beginnt, einem Ger√§tefamiliencode.  Wenn das Ger√§t an den Treiber angeschlossen ist, wird es in <code>DS18S20-X</code> , wobei <code>DS18S20</code> ein Basisname und <code>X</code> eine <code>DS18S20</code> ist. </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_poll"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_data(sdm.local_attr_handle(dev, <span class="hljs-string"><span class="hljs-string">"id"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> attr == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (sdm.device_name(par) == <span class="hljs-string"><span class="hljs-string">"ESP8266_1W"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (attr:<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0x10</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- check family ID end ) sdm.method_add(drv, "_init", nil, function(dev, drv, par) sdm.device_rename(dev, sdm.request_name("DS18S20")) -- rename device sdm.attr_copy(dev, "temp") -- copy attribute to device local met = sdm.method_dev_handle(par, "setup") local func = sdm.method_func(met) -- use parent "setup" method on the device func(par, dev) end )</span></span></code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/bm/pk/41/bmpk419dphexm-xlvnxq7hw2jxc.png"></a> </p><br><p>  Die lokalen Attribute <code>id</code> und <code>datapin</code> haben keine <code>getter</code> und <code>setter</code> Hooks, daher sind nur deren Namen sichtbar. </p><br><h3 id="ds18b20">  DS18B20 </h3><br><p>  <a href="">Der DS18B20-Treiber</a> ist fast identisch mit dem <a href="">DS18S20-Treiber</a> .  Der einzige Unterschied ist die <code>precision</code> .  Beide <em>DS18-20-</em> Treiber gehen von einer Ganzzahlbildung aus und verwenden keine Gleitkommadivision. </p><br><pre> <code class="lua hljs">sdm.attr_add(drv, <span class="hljs-string"><span class="hljs-string">"precision"</span></span>, <span class="hljs-string"><span class="hljs-string">"Precision (9|10|11|12)"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, precision)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_dev_handle(dev, <span class="hljs-string"><span class="hljs-string">"precision"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdm.attr_data(attr) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, precision)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> par = sdm.device_parent(dev) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_dev_handle(dev, <span class="hljs-string"><span class="hljs-string">"precision"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ex = sdm.method_func(sdm.method_dev_handle(par, <span class="hljs-string"><span class="hljs-string">"exchange"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> modes = {[<span class="hljs-number"><span class="hljs-number">9</span></span>]=<span class="hljs-number"><span class="hljs-number">0x1f</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span>]=<span class="hljs-number"><span class="hljs-number">0x3f</span></span>, [<span class="hljs-number"><span class="hljs-number">11</span></span>]=<span class="hljs-number"><span class="hljs-number">0x5f</span></span>, [<span class="hljs-number"><span class="hljs-number">12</span></span>]=<span class="hljs-number"><span class="hljs-number">0x7f</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modes[precision] ~= <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ex(par, dev, {<span class="hljs-number"><span class="hljs-number">0x4e</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, modes[precision]}) sdm.attr_set(attr, precision) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> )</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/er/lj/gb/erljgbs9zby8767izkmsunyhdd8.png"></a> </p><br><h2 id="memory-usage">  Speichernutzung </h2><br><p>  <em>Der</em> freie Speicher des <em>ESP8266</em> betr√§gt ca. <em>40 KB</em> .  Der Servercode wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://gitlab.com/matsievskiysv/nodemcu-">LFS</a> verschoben, sodass zum Zeitpunkt der Initialisierung kein RAM-Speicherplatz ben√∂tigt wird (der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/marcoskirsch/nodemcu-">urspr√ºngliche Code ben√∂tigte</a> ca. <em>10.000 KB</em> ). </p><br><p>  <em>SDM</em> ben√∂tigt ungef√§hr 10 <em>KB</em> f√ºr 5 Ger√§tetreiber und 5 Ger√§te.  Etwas weniger f√ºr nicht schwebende Firmware-Builds.  Daher ist es vorzuziehen, im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Treibermanifest</a> nur Treiber auszuw√§hlen, die f√ºr die jeweilige Aufgabe ben√∂tigt werden.  Die speicherintensivste Aufgabe besteht darin, die Bibliothek <code>vue.js</code> . </p><br><p> <a href=""><img src="https://habrastorage.org/webt/yy/u-/_i/yyu-_idkp2osapmg3-jy5z2r8ly.png"></a> </p><br><p>  Im Fall der Anforderung von <em>JSON-</em> Rohdaten (unter Verwendung von <code>curl</code> ) kann der maximale Speicherverbrauch erheblich reduziert werden. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/w_/hu/xx/w_huxxzt4w2wszdqq04bgbonbt0.png"></a> </p><br><h2 id="instead-of-an-epilogue">  Anstelle eines Nachworts </h2><br><p>  Eine der ersten Methoden, die ich mit sdm implementiert habe, war die Bindung f√ºr <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>node.restart()</code></a> . <br>  Das Ausprobieren √ºber die Webbenutzeroberfl√§che f√ºhrte zu einem merkw√ºrdigen Ergebnis.  Unmittelbar nachdem der Webbrowser die Anforderung ausgegeben hatte, wurde der Chip wie erwartet neu gestartet.  Da NodeMCU jedoch nicht ordnungsgem√§√ü auf die HTTP-Anforderung reagiert hat, hat der Webbrowser dieselbe Anforderung erneut versucht.  Wenn der NodeMCU-Server neu gestartet wurde und wieder aktiv war, stellte der Browser eine Verbindung her, setzte den internen Z√§hler f√ºr <em>erneute Versuche zur√ºck</em> und rief die Methode <code>node.restart()</code> , wodurch eine Endlosschleife des Neustarts von NodeMCU gestartet wurde. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449992/">https://habr.com/ru/post/de449992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449976/index.html">Assoziative Multithread-Container in C ++. Yandex-Bericht</a></li>
<li><a href="../de449978/index.html">Igor Antarov vom Moskauer Tesla Club k√§mpft mit 20 Mythen √ºber Tesla und Elektroautos</a></li>
<li><a href="../de449984/index.html">Google News und Leo Tolstoy: Visualisierung von Word2Vec-Worteinbettungen mit t-SNE</a></li>
<li><a href="../de449986/index.html">Blockchain: Was sollen wir einen Fall bauen?</a></li>
<li><a href="../de449990/index.html">Wie kann man Latex, Formeln und Habr finden?</a></li>
<li><a href="../de449996/index.html">Den FFT-Algorithmus verstehen</a></li>
<li><a href="../de449998/index.html">FAQ: Was ein reisender Geek √ºber Impfungen wissen muss, bevor er reist</a></li>
<li><a href="../de450000/index.html">(Von rechts nach links (Durch den Spiegel</a></li>
<li><a href="../de450002/index.html">Suchen von Fehlern in LLVM 8 mit PVS-Studio</a></li>
<li><a href="../de450004/index.html">Schneller C / C ++ - Cache, Thread-Sicherheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>