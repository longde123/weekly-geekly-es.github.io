<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏾 👩🏾‍🏫 📌 Die ganze Wahrheit über RTOS. Artikel 28. Software-Timer 🐟 🕚 👨🏽‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Idee der Software-Timer wurde in einem früheren Artikel vorgestellt . Es handelt sich um Kernelobjekte, die Aufgaben eine einfache Möglichkeit bie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel 28. Software-Timer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455072/">  Die Idee der Software-Timer wurde in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel vorgestellt</a> .  Es handelt sich um Kernelobjekte, die Aufgaben eine einfache Möglichkeit bieten, Ereignisse rechtzeitig auszulösen, oder meistens eine Möglichkeit, Aktionen regelmäßig auszuführen.  Alle Details der zeitbezogenen Funktionalität (Genauigkeit, Interrupt-Behandlung usw.) in Nucleus SE wurden in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel</a> erörtert. <br><br><img src="https://habrastorage.org/webt/xu/5v/_s/xu5v_sdm50mq9i1ywof_lgsvqkw.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Frühere Artikel in der Reihe:</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemzeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kanäle: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenkanäle: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <br></div></div><br><h2>  Timer verwenden </h2><br>  Programm-Timer können so konfiguriert werden, dass sie einmal ausgelöst werden, dh sie starten und nach einer bestimmten Zeit einfach den Zyklus beenden.  Oder der Timer kann so konfiguriert werden, dass er neu startet: Nach Abschluss der Zählung wird der Timer automatisch neu gestartet.  Die Betriebszeit nach einem Neustart kann von der anfänglichen Betriebszeit abweichen.  Zusätzlich kann der Timer optional so konfiguriert werden, dass er eine spezielle Beendigungsfunktion ausführt, die ausgeführt wird, wenn (oder jedes Mal) der Timer den Arbeitszyklus abschließt. <br><br><h2>  Timer-Einstellungen </h2><br><h3>  Anzahl der Timer </h3><br>  Wie bei den meisten Aspekten von Nucleus SE werden die Timer-Einstellungen von den Anweisungen <b>#define</b> in <b>nuse_config.h gesteuert</b> .  Der Hauptparameter ist <b>NUSE_TIMER_NUMBER</b> , der die in der Anwendung konfigurierten Timer definiert.  Standardmäßig ist dieser Wert Null (dh Timer werden in der Anwendung nicht verwendet) und kann Werte bis zu 16 annehmen. Ein falscher Wert führt zu einem Kompilierungsfehler, der durch Einchecken der Datei <b>nuse_config_check.h</b> (diese Datei ist in <b>nuse_config.c enthalten</b> und kompiliert) <b>generiert wird</b> zusammen mit ihm), wodurch die Direktive <b>#error ausgelöst wird</b> . <br><br>  Die Auswahl eines Werts ungleich Null ist der Hauptaktivator des Timers.  Dieser Parameter wird beim Definieren von Datenstrukturen verwendet und ihre Größe hängt von ihrem Wert ab.  Darüber hinaus aktiviert ein Wert ungleich Null die API-Einstellungen. <br><br><h3>  Aktivierung der Abschlussfunktion </h3><br>  In Nucleus SE habe ich versucht, die Möglichkeit zu finden, die Funktionalität optional zu machen, wodurch Speicherplatz gespart wird.  Ein gutes Beispiel ist die Unterstützung von Timer-Abschlussfunktionen.  Zusätzlich zu der Tatsache, dass diese Funktion für jeden Timer optional ist, kann der Mechanismus für die gesamte Anwendung mithilfe des Parameters <b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b> in <b>nuse_config.h</b> aktiviert werden (oder nicht).  Wenn Sie diesen Parameter auf <b>FALSE setzen</b> , wird die Definition von zwei Datenstrukturen im ROM blockiert, die in diesem Artikel ausführlich beschrieben werden. <br><br><h3>  API-Aktivierung </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE verfügt über die Direktive #define enable in nuse_config.h.  Für Timer umfassen diese Symbole: <br>  <b>NUSE_TIMER_CONTROL</b> <b><br></b>  <b>NUSE_TIMER_GET_REMAINING</b> <b><br></b>  <b>NUSE_TIMER_RESET</b> <b><br></b>  <b>NUSE_TIMER_INFORMATION</b> <b><br></b>  <b>NUSE_TIMER_COUNT</b> <br><br>  Standardmäßig sind alle Aktivatoren auf <b>FALSE gesetzt</b> , sodass alle Serviceaufrufe deaktiviert sind und die Aufnahme von Code, der sie implementiert, blockiert wird.  Um Timer in der Anwendung einzurichten, müssen Sie die erforderlichen API-Serviceaufrufe auswählen und auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein <b>Codeausschnitt</b> aus der Standarddatei <b>nuse_config.h</b> . <br><br><pre><code class="plaintext hljs">#define NUSE_TIMER_NUMBER 0/*      0-16 */ /*    */ #define NUSE_TIMER_CONTROL FALSE #define NUSE_TIMER_GET_REMAINING FALSE #define NUSE_TIMER_RESET FALSE #define NUSE_TIMER_INFORMATION FALSE #define NUSE_TIMER_COUNT FALSE</code> </pre> <br>  Wenn die timerbezogene API-Funktion aktiviert ist und keine konfigurierten Timer in der Anwendung vorhanden sind (mit Ausnahme der Funktion <b>NUSE_Timer_Count ()</b> , die immer aktiviert ist), tritt ein Kompilierungsfehler auf.  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, tritt ein Layoutfehler auf, da der Implementierungscode nicht in der Anwendung enthalten war. <br><br><h2>  Timer-Serviceanrufe </h2><br>  Nucleus RTOS unterstützt acht timerbezogene Dienstprogrammaufrufe, die die folgenden Funktionen bieten: <br><br><ul><li>  Management-Timer (Start / Stopp).  Nucleus SE ist in der Funktion <b>NUSE_Timer_Control ()</b> implementiert. </li><li>  Abrufen der verbleibenden Timerzeit.  In Nucleus SE, implementiert in <b>NUSE_Timer_Get_Remaining ()</b> . </li><li>  Wiederherstellen des ursprünglichen Zustands des Timers (Zurücksetzen).  Nucleus SE in <b>NUSE_Timer_Reset ()</b> implementiert. </li><li>  Bereitstellung von Informationen zu einem bestimmten Timer.  Nucleus SE ist in <b>NUSE_Timer_Information ()</b> implementiert. </li><li>  Gibt die Anzahl der konfigurierten (derzeit) Timer in der Anwendung zurück.  Nucleus SE ist in <b>NUSE_Timer_Count ()</b> implementiert. </li><li>  Hinzufügen eines neuen Timers zur Anwendung (Erstellung).  Nucleus SE ist nicht implementiert. </li><li>  Entfernen eines Timers aus der Anwendung.  Nucleus SE ist nicht implementiert. </li><li>  Rückgabe von Zeigern auf alle Timer in der Anwendung.  Nucleus SE ist nicht implementiert. </li></ul><br>  Die Implementierung jedes Serviceabrufs wird nachstehend ausführlich erläutert. <br><br><h2>  Timer-Dienste </h2><br>  Die grundlegenden Operationen, die mit einem Timer ausgeführt werden können, sind die Steuerung (Start und Stopp) und das Lesen des aktuellen Werts.  Nucleus RTOS und Nucleus SE bieten zwei grundlegende API-Dienstprogrammaufrufe für diese Vorgänge. <br><br><h3>  Timer-Steuerung </h3><br>  Durch einen Dienstprogrammaufruf an die Nucleus RTOS-API zur Steuerung des Timers können Sie den Timer aktivieren und deaktivieren (Start und Stopp).  Nucleus SE bietet ähnliche Funktionen. <br><br>  <b><i>Timer Control Challenge in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Control_Timer (NU_TIMER * Timer, OPTION aktivieren);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Zeiger auf den vom Benutzer bereitgestellten Timer-Steuerblock; <br>  <b>enable</b> ist die erforderliche Funktion und kann die Werte <b>NU_ENABLE_TIMER</b> oder <b>NU_DISABLE_TIMER annehmen</b> . <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INAVLID_TIMER</b> - ungültiger <b>Timerzeiger</b> ; <br>  <b>NU_INAVLID_ENABLE</b> - ungültige Funktion. <br><br>  <b><i>Timer Control Challenge in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterstützt die volle Funktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Timer_Control (NUSE_TIMER-Timer, OPTION-Aktivierung);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Index (ID) des verwendeten Timers; <br>  <b>enable</b> ist die erforderliche Funktion und kann die Werte <b>NUSE_ENABLE_TIMER</b> oder <b>NUSE_DISABLE_TIMER annehmen</b> . <br><br>  Rückgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INCALID_TIMER</b> - ungültiger Timer-Index; <br>  <b>NUSE_INVALID_ENABLE</b> ist eine ungültige Funktion. <br><br>  <b><i>Implementieren Sie das Timer-Management in Nucleus SE</i></b> <br>  Der API-Funktionscode <b>NUSE_Timer_Control ()</b> (nach Überprüfung der Parameter) ist recht einfach: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; if (NUSE_Timer_Expirations_Counter[timer] == 0) { NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; } else { NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } } else /* enable == NUSE_DISABLE_TIMER */ { NUSE_Timer_Status[timer] = FALSE; } NUSE_CS_Exit();</code> </pre><br>  Wenn die Funktion <b>NUSE_DISABLE_TIMER</b> angegeben wurde, wird der Timer-Status (Parameter <b>NUSE_Timer_Status []</b> ) auf <b>FALSE gesetzt</b> , wodurch der Timer vom Interrupt-Handler ignoriert wird. <br><br>  Wenn Sie die Funktion <b>NUSE_ENABLE_TIMER</b> auswählen <b>, wird</b> der Timer-Zähler ( <b>NUSE_Timer_Value []</b> ) auf <b>NUSE_Timer_initial_Time [] gesetzt</b> , sofern der Timer seit dem letzten Zurücksetzen nie angehalten hat.  Andernfalls wird ihm der Wert <b>NUSE_Timer_Reschedule_Time []</b> zugewiesen.  Dann wird der Timer-Status (Parameter <b>NUSE_Timer_Status []</b> ) auf <b>TRUE gesetzt</b> , wodurch der Timer vom Interrupt-Handler verarbeitet wird. <br><br><h3>  Timer lesen </h3><br>  Um die verbleibende Zeitgeberzeit abzurufen, gibt der Nucleus RTOS API-Serviceaufruf die Anzahl der Kennzahlen zurück, bis er abläuft.  Nucleus SE bietet ähnliche Funktionen. <br><br>  <b><i>Rufen Sie an, um die verbleibende Zeit in Nucleus RTOS abzurufen</i></b> <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Get_Remaining_Time (NU_TIMER * Timer, UNSIGNED * verbleibende_Zeit);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Zeiger auf den vom Benutzer bereitgestellten Timer-Steuerblock; <br>  <b>verbleibende Zeit</b> - ein Zeiger auf die Speicherung des verbleibenden Zeitwerts, der eine Variable vom Typ <b>UNSIGNED ist</b> . <br><br>  Rückgabewert <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TIMER</b> - ungültiger <b>Timerzeiger</b> . <br><br>  <b><i>Rufen Sie an, um die verbleibende Zeit in Nucleus SE zu erhalten</i></b> <br>  Dieser API-Aufruf unterstützt die volle Funktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Timer_Get_Remaining (NUSE_TIMER-Timer, U16 * verbleibende_Zeit);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Index (ID) des verwendeten Timers; <br>  <b>verbleibende Zeit</b> - ein Zeiger auf die Speicherung des verbleibenden Zeitwerts, der eine Variable vom Typ <b>U16 ist</b> . <br><br>  Rückgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_TIMER</b> - ungültiger Timer-Index; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf die verbleibende Zeit ( <b>NULL</b> ). <br><br>  <b><i>Implementieren eines Timers Read in Nucleus SE</i></b> <br>  Die API-Funktionscodevariante <b>NUSE_Timer_Get_Remaining ()</b> (nach Überprüfung der Parameter) ist trivial einfach.  Der Wert <b>NUSE_Timer_Value [] wird</b> abgerufen und dann im kritischen Abschnitt zurückgegeben. <br><br><h2>  Auxiliary Timer Services </h2><br>  Nucleus RTOS verfügt über vier API-Aufrufe, die Zusatzfunktionen für Timer bereitstellen: Zurücksetzen eines Timers, Abrufen von Timerinformationen, Abrufen der Anzahl der Timer in einer Anwendung und Abrufen von Zeigern auf alle Timer in einer Anwendung.  Die ersten drei Funktionen sind in Nucleus SE implementiert. <br><br><h3>  Timer zurückgesetzt </h3><br>  Dieser API-Aufruf setzt den Timer auf seinen ursprünglichen, nicht verwendeten Zustand zurück.  Der Timer kann nach Beendigung dieses Anrufs aktiviert oder deaktiviert werden.  Es kann nur verwendet werden, nachdem der Timer deaktiviert wurde (mit <b>NUSE_Timer_Control ()</b> ).  <b>Wenn</b> der Timer das nächste Mal aktiviert wird, wird er mit dem Parameter <b>NUSE_Timer_Initial_Time []</b> initialisiert.  Mit Nucleus RTOS können Sie einen neuen Anfangszustand bereitstellen und die Zeit neu planen sowie die Abschlussfunktion angeben, wenn der Timer zurückgesetzt wird.  In Nucleus SE werden diese Werte während des Setups festgelegt und können nicht geändert werden, da sie im ROM gespeichert sind. <br><br>  <b><i>Aufruf zum Zurücksetzen eines Timers in Nucleus RTOS</i></b> <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Reset_Timer (NU_TIMER * Timer, VOID (* Ablaufdatum) (UNSIGNED), UNSIGNED initial_time, UNSIGNED reschedule_time, OPTION enable);</b> <br><br>  Parameter: <br>  <b>Timer</b> - ein Zeiger auf einen zurücksetzbaren Timer; <br>  <b>expiration_routine</b> - gibt die Funktion an, die ausgeführt wird, wenn die Schleife endet. <br>  <b>initial_time</b> - Die anfängliche Anzahl der Timer-Ticks bis zum Ende der Schleife. <br>  <b>reschedule_time</b> - Die Anzahl der Timer- <b>Ticks</b> bis zum Abschluss des zweiten und der folgenden Zyklen. <br>  <b>enable</b> - Der erforderliche Status des Timers nach einem Reset kann die Werte <b>NU_ENABLE_TIMER</b> oder <b>NU_DISABLE_TIMER annehmen</b> . <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TIMER</b> - ungültiger Zeiger auf die Timer-Steuereinheit; <br>  <b>NU_INVALID_FUNCTION</b> - Nullzeiger auf die Abschlussfunktion ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> - Der angegebene Status ist falsch. <br>  <b>NU_NOT_DISABLED</b> - Der Timer läuft bereits (er sollte vor dem Aufruf dieser Funktion gestoppt werden). <br><br>  <b><i>Rufen Sie an, um den Timer in Nucleus SE zurückzusetzen</i></b> <br>  Dieser API-Serviceaufruf unterstützt eine vereinfachte Version der Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Timer_Reset (NUSE_TIMER-Timer, OPTION-Aktivierung);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Index (ID) des Reset-Timers; <br>  <b>enable</b> - Der erforderliche Status nach dem Zurücksetzen kann die Werte <b>NUSE_ENABLE_TIMER</b> oder <b>NUSE_DISABLE_TIMER annehmen</b> . <br><br>  Rückgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_TIMER</b> - ungültiger Timer-Index; <br>  <b>NUSE_INVALID_ENABLE</b> - Der angegebene Status ist falsch. <br>  <b>NUSE_NOT_DISABLED</b> - Der Timer läuft bereits (er sollte vor dem Aufruf dieser Funktion gestoppt werden). <br><br>  <b><i>Implementieren eines Timer-Resets in Nucleus SE</i></b> <br>  Die Version des API-Funktionscodes <b>NUSE_Timer_Reset ()</b> (nach Überprüfung der Parameter und des aktuellen Status) ist recht einfach: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); NUSE_Init_Timer(timer); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; } /*  enable == NUSE_DISABLE_TIMER    FALSE */ NUSE_CS_Exit();</code> </pre><br>  Ein Aufruf von <b>NUSE_Init_Timer ()</b> initialisiert den Zeitwert und löscht den Abschlusszähler.  Danach wird bei Bedarf der Wert des erforderlichen Status überprüft und ob der Timer eingeschaltet ist. <br><br><h3>  Timer-Informationen </h3><br>  Mit diesem Serviceabruf können Sie eine Reihe von Timerinformationen abrufen.  Die Implementierung von Nucleus SE unterscheidet sich von Nucleus RTOS darin, dass weniger Informationen zurückgegeben werden, da die Objektbenennung nicht unterstützt wird. <br><br>  <b><i>Rufen Sie Timer-Informationen in Nucleus RTOS an</i></b> <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Timer_Information (NU_TIMER * Timer, CHAR * Name, OPTION * aktivieren, UNSIGNED * Ablauf, UNSIGNED * ID, UNSIGNED * initial_time, UNSIGNED * reschedule_time);</b> <br><br>  Parameter: <br>  <b>Timer</b> - ein Zeiger auf einen Timer, über den Informationen angefordert werden; <br>  <b>name</b> - Zeiger auf den 8-stelligen Bereich für den Timernamen; <br>  <b>enable</b> - Zeiger auf eine Variable, die den aktuellen Status des Timer-Aktivators <b>annimmt</b> : <b>NU_ENABLE_TIMER</b> oder <b>NU_DISABLE_TIMER</b> ; <br>  <b>Ablaufdatum</b> - ein Zeiger auf eine Variable, die einen Zähler für die Anzahl der Abschlüsse des Zeitgeberzyklus seit seinem letzten Zurücksetzen verwendet; <br>  <b>id</b> - Zeiger auf eine Variable, die den Wert des Parameters annimmt, der an die Endfunktion des Zeitgeberzyklus übergeben wird; <br>  <b>initial_time</b> - ein Zeiger auf eine Variable, die einen Wert annimmt, in den der Timer nach einem Reset initialisiert wird; <br>  <b>reschedule_time</b> - Ein Zeiger auf eine Variable, die einen Wert annimmt, in den der Timer nach Abschluss initialisiert wird. <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TIMER</b> - ungültiger <b>Timerzeiger</b> . <br><br>  <b><i>Rufen Sie in Nucleus SE nach Timer-Informationen</i></b> <br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Timer_Information (NUSE_TIMER-Timer, OPTION * aktivieren, U8 * Ablauf, U8 * ID, U16 * initial_time, U16 * reschedule_time);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Index des Timers, über den Informationen angefordert werden; <br>  <b>enable</b> - ein Zeiger auf eine Variable, die den Wert <b>TRUE</b> oder <b>FALSE</b> annimmt, je nachdem, ob der Timer aktiviert ist oder nicht; <br>  <b>Ablaufzeiten</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> , die den Wert der Anzahl der Timer-Abschlüsse seit ihrem letzten Zurücksetzen annimmt; <br>  <b>id</b> - Zeiger auf eine Variable vom Typ <b>U8</b> , die den Wert des an die Timer-Abschlussfunktion übergebenen Parameters annimmt (gibt einen leeren Wert zurück, wenn die Abschlussfunktionen deaktiviert sind); <br>  <b>initial_time</b> - ein Zeiger auf eine Variable vom Typ <b>U16</b> , die einen Wert annimmt, mit dem der Timer nach einem Zurücksetzen initialisiert wird; <br>  <b>reschedule_time</b> - Ein Zeiger auf eine Variable vom Typ <b>U16</b> , der den Wert annimmt, mit dem der Timer nach Abschluss initialisiert wird. <br><br>  Rückgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_TIMER</b> - ungültiger Timer-Index; <br>  <b>NUSE_INVALID_POINTER</b> - Ein oder mehrere <b>Zeigerparameter</b> sind falsch. <br><br>  <b><i>Implementieren von Timer-Informationen in Nucleus SE</i></b> <br>  Die Implementierung dieses API-Aufrufs ist ziemlich einfach: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (NUSE_Timer_Status[timer]) { *enable = NUSE_ENABLE_TIMER; } else { *enable = NUSE_DISABLE_TIMER; } *expirations = NUSE_Timer_Expirations_Counter[timer]; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT *id = NUSE_Timer_Expiration_Routine_Parameter[timer]; #endif *initial_time = NUSE_Timer_Initial_Time[timer]; *reschedule_time = NUSE_Timer_Reschedule_Time[timer]; NUSE_CS_Exit();</code> </pre><br>  Die Funktion gibt den Status des Timers zurück.  Der Parameterwert der Beendigungsfunktion wird nur zurückgegeben, wenn deren Unterstützung in der Anwendung aktiviert wurde. <br><br><h3>  Abrufen der Anzahl der Timer </h3><br>  Dieser Dienstprogrammaufruf gibt die Anzahl der in der Anwendung konfigurierten Timer zurück.  In Nucleus RTOS kann sich dieser Wert im Laufe der Zeit ändern, und der Rückgabewert zeigt die aktuelle Anzahl von Timern an.  In Nucleus SE wird der Rückgabewert während der Montagephase festgelegt und kann nicht geändert werden. <br><br>  <b><i>Fordern Sie einen Timer-Zähler in Nucleus RTOS an</i></b> <br><br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Established_Timers (VOID);</b> <br><br>  Parameter: keine <br><br>  Rückgabewert: Die Anzahl der im System erstellten Timer. <br><br>  <b><i>Aufruf des Timer-Zählers in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>U8 NUSE_Timer_Count (nichtig);</b> <br><br>  Parameter: keine <br><br>  Rückgabewert: <br>  Die Anzahl der konfigurierten Timer in der Anwendung <br><br><h3>  Implementierung des Timer-Zählers </h3><br>  Die Implementierung dieses API-Aufrufs ist recht einfach: Der Wert des Symbols #define <b>NUSE_TIMER_NUMBER</b> wird <b>zurückgegeben</b> . <br><br><h2>  Datenstrukturen </h2><br>  Timer verwenden fünf oder sieben Datenstrukturen (im RAM oder ROM), die (wie andere Nucleus SE-Objekte) eine Reihe von Tabellen sind, deren Größe und Anzahl der Anzahl der konfigurierten Timer und ausgewählten Parameter entspricht. <br><br>  Ich empfehle dringend, dass der Anwendungscode keinen direkten Zugriff auf diese Datenstrukturen verwendet, sondern über die bereitgestellten API-Funktionen auf sie verweist.  Dies vermeidet Inkompatibilität mit zukünftigen Versionen von Nucleus SE und unerwünschte Nebenwirkungen und vereinfacht die Portierung von Anwendungen auf Nucleus RTOS.  Das Folgende ist eine detaillierte Übersicht über Strukturen, um das Verständnis von Serviceabruf- und Debugging-Code zu vereinfachen. <br><br><h3>  RAM-Daten </h3><br>  Diese Daten haben folgende Struktur: <br>  <b>NUSE_Timer_Status []</b> ist ein Array vom Typ <b>U8</b> , das einen Eintrag für jeden konfigurierten Timer hat und den Status des Timers speichert (läuft oder gestoppt: <b>TRUE</b> oder <b>FALSE</b> ). <br>  <b>NUSE_Timer_Value []</b> ist ein Array vom Typ <b>U16</b> , das einen Eintrag für jeden konfigurierten Timer hat und den aktuellen Wert des Timer-Zählers speichert. <br>  <b>NUSE_Timer_Expirations_Counter []</b> - Ein Array vom Typ <b>U8</b> , das einen Zähler für die Anzahl der Fälle enthält, in denen die Timer das Ende des Zyklus seit ihrem letzten Zurücksetzen erreicht haben. <br><br>  Alle diese Datenstrukturen werden beim <b>Start von</b> Nucleus SE von der Funktion <b>NUSE_Init_Timer ()</b> initialisiert.  Einer der folgenden Artikel enthält eine vollständige Beschreibung der Startvorgänge für Nucleus SE. <br><br>  Im Folgenden sind die Definitionen dieser Datenstrukturen in der Datei <b>nuse_init.c aufgeführt</b> : <br>  <b>RAM U8 Timer_Status [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U16 NUSE_Timer_Value [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U8 NUSE_Timer_Expirations_Counter [NUSE_TIMER_NUMBER];</b> <br><br><h3>  ROM-Daten </h3><br>  Die Struktur dieser Daten: <br>  <b>NUSE_Timer_Initial_Time []</b> ist ein Array vom Typ <b>U16</b> , das einen Eintrag für jeden konfigurierten Timer enthält und den Wert jedes Timers speichert. <br>  <b>NUSE_Timer_Reschedule_Time []</b> - Ein Array vom Typ <b>U16</b> , das einen Eintrag für jeden konfigurierten Timer enthält und den Wert speichert, in dem der Timer nach Abschluss eingestellt wird.  Ein Wert von Null zeigt an, dass der Timer "einmalig" ist und nicht automatisch neu gestartet werden sollte. <br>  <b>NUSE_Timer_Expiration_Routine_Address []</b> - Ein Array vom Typ <b>ADDR,</b> das die Adresse der <b>Ablaufvorgänge</b> des Timers enthält.  Dieses Array ist nur vorhanden, wenn die Unterstützung für das Ablaufdatum des Timers aktiviert wurde. <br>  <b>NUSE_Timer_Expiration_Routine_Parameter []</b> - Ein Array vom Typ <b>U8,</b> das die Werte des Parameters enthält, der an die Timer-Abschlussfunktion übergeben wird.  Dieses Array ist nur vorhanden, wenn die Unterstützung für Abschlussfunktionen aktiviert wurde. <br><br>  Diese Datenstrukturen werden (statisch) in der Datei <b>nuse_config.c</b> deklariert und initialisiert. <br><br><pre> <code class="plaintext hljs">ROM U16 NUSE_Timer_Initial_Time[NUSE_TIMER_NUMBER] = { /*   ------ */ }; ROM U16 NUSE_Timer_Reschedule_Time[NUSE_TIMER_NUMBER] = { /*      ------ */ }; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING /*    */ ROM ADDR NUSE_Timer_Expiration_Routine_Address[NUSE_TIMER_NUMBER] = { /*     ------ */ /*   NULL */ }; ROM U8 NUSE_Timer_Expiration_Routine_Parameter[NUSE_TIMER_NUMBER] = { /*     ------ */ }; #endif</code> </pre><br><h3>  Die Speichermenge für den Timer </h3><br>  Wie bei allen anderen Nucleus SE-Objekten ist die für Timer erforderliche Datenmenge vorhersehbar. <br><br>  Die Datenmenge im RAM (in Byte) für alle Timer in der Anwendung kann wie folgt berechnet werden: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  Die Datenmenge im ROM (in Byte) für alle Timer in der Anwendung kann wie folgt berechnet werden, wenn die Unterstützung für Abschlussfunktionen deaktiviert ist: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  Ansonsten ist es gleich: <br>  <b>NUSE_TIMER_NUMBER * (Größe von (ADDR) + 5)</b> <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Nucleus SE implementiert die drei API-Aufrufe, die in RTOS enthalten sind, nicht. <br><br><h3>  Timer-Erstellung </h3><br>  Dieser API-Aufruf erstellt einen Timer.  Nucleus SE benötigt es nicht, da Timer statisch erstellt werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Create_Timer (NU_TIMER * timer, CHAR * name, VOID (* expiration_routine) (UNSIGNED), UNSIGNED id, UNSIGNED initial_time, UNSIGNED reschedule_time, OPTION enable);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Zeiger auf den vom Benutzer bereitgestellten Timer-Steuerblock;  Es wird verwendet, um Timer in anderen API-Aufrufen zu steuern. <br>  <b>name</b> - Zeiger auf den 7-stelligen Namen des Timers mit einer abschließenden Null; <br>  <b>expiration_routine</b> - gibt die Funktion an, die nach <b>Ablauf</b> des Timers ausgeführt werden soll. <br>  <b>id</b> - ein Datenelement vom Typ <b>UNSIGNED,</b> das an die Beendigungsfunktion übergeben wird: Dieser Parameter kann verwendet werden, um Timer mit derselben Beendigungsfunktion zu identifizieren; <br>  <b>initial_time</b> - gibt die anfängliche Anzahl von Timer-Ticks an, bevor der Timer endet; <br>  <b>reschedule_time</b> - Gibt die Anzahl der Timer- <b>Ticks an,</b> bis der zweite und die folgenden Zyklen abgeschlossen sind.  Wenn dieser Parameter gleich Null ist, stoppt der Timer nur einmal. <br>  <b>enable</b> - Dieser Parameter kann die Werte <b>NU_ENABLE_TIMER</b> und <b>NU_DISABLE_TIMER annehmen</b> .  <b>NU_ENABLE_TIMER</b> aktiviert einen Timer, nachdem er erstellt wurde.  <b>NU_DISABLE_TIMER</b> lässt den Timer deaktiviert.  Mit dem Parameter <b>NU_DISABLE_TIMER</b> erstellte Timer müssen durch Aufrufen von <b>NU_Control_Timer</b> aktiviert werden. <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TIMER</b> - ein Nullzeiger auf eine Timer-Steuereinheit ( <b>NULL</b> ) oder die Steuereinheit wird bereits verwendet; <br>  <b>NU_INVALID_FUNCTION</b> - Nullzeiger auf das Abschlussprogramm ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> - ungültiger <b>Aktivierungsparameter</b> ; <br>  <b>NU_INVALID_OPERATION</b> - Der Parameter <b>initial_time</b> war Null. <br><br><h3>  Timer löschen </h3><br>  Dieser API-Aufruf löscht einen zuvor erstellten Timer.  Nucleus SE benötigt es nicht, da Timer statisch erstellt werden und nicht gelöscht werden können. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Delete_Timer (NU_TIMER * Timer);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Zeiger auf den Timer-Steuerblock. <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TIMER</b> - ungültiger <b>Timerzeiger</b> ; <br>  <b>NU_NOT_DISABLED</b> - Der angegebene Timer ist nicht deaktiviert. <br><br><h3>  Timer-Zeiger </h3><br>  Dieser API-Aufruf bildet eine sequentielle Liste von Zeigern auf alle Timer im System.  Nucleus SE benötigt es nicht, da die Timer durch einen einfachen Index und nicht durch einen Zeiger bestimmt werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Timer_Pointers (NU_TIMER ** Zeigerliste, UNSIGNED Maximum_Pointers);</b> <br><br>  Parameter: <br>  <b>pointer_list</b> - Zeiger auf ein Array von Zeigern <b>NU_TIMER</b> ;  Es wird mit Zeigern auf im System konfigurierte Timer gefüllt. <br>  <b>Maximum_Pointers</b> - Die maximale Anzahl von Zeigern im Array. <br><br>  Rückgabewert: <br>  Die Anzahl der im Array platzierten <b>NU_TIMER-</b> Zeiger. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Wie bei allen anderen Nucleus SE-Objekten war es mein Ziel, die Kompatibilität des Anwendungscodes mit Nucleus RTOS zu maximieren.  Timer sind keine Ausnahme und werden aus Anwendersicht auf die gleiche Weise wie in Nucleus RTOS implementiert.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt auch eine gewisse Inkompatibilität, die ich für zulässig hielt, da der Code dadurch verständlicher und effizienter in Bezug auf den erforderlichen Speicher wird. </font><font style="vertical-align: inherit;">Andernfalls können Nucleus RTOS-API-Aufrufe fast direkt auf Nucleus SE portiert werden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objektkennungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Nucleus RTOS werden alle Objekte durch eine Datenstruktur beschrieben - einen Steuerblock mit einem bestimmten Datentyp. Ein Zeiger auf diese Steuereinheit ist eine Zeitgeberkennung. Ich entschied, dass in Nucleus SE ein anderer Ansatz für eine effiziente Speichernutzung erforderlich ist: Alle Kernelobjekte werden durch eine Reihe von Tabellen im RAM und / oder ROM beschrieben. Die Größe dieser Tabellen wird durch die Anzahl der konfigurierten Objekte jedes Typs bestimmt. Die Kennung eines bestimmten Objekts ist der Index in dieser Tabelle. Also habe ich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_TIMER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als das Äquivalent von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U8 definiert</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Variable (kein Zeiger) dieses Typs dient als Kennung des Timers. </font><font style="vertical-align: inherit;">Diese leichte Inkompatibilität ist leicht zu handhaben, wenn der Code von Nucleus SE nach Nucleus RTOS und umgekehrt portiert wird. </font><font style="vertical-align: inherit;">In der Regel werden keine anderen Operationen an Objektkennungen als Verschieben und Speichern ausgeführt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus RTOS unterstützt auch die Benennung von Timern. </font><font style="vertical-align: inherit;">Diese Namen werden nur zum Debuggen verwendet. </font><font style="vertical-align: inherit;">Ich habe sie von Nucleus SE ausgeschlossen, um Speicherplatz zu sparen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Timergröße </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Nucleus RTOS werden Timer mithilfe von 32-Bit-Zählern implementiert. </font><font style="vertical-align: inherit;">Ich habe beschlossen, diesen Wert in Nucleus SE auf 16 Bit zu reduzieren. </font><font style="vertical-align: inherit;">Dies hat zu erheblichen Verbesserungen der Speichereffizienz und der Laufzeit geführt. </font><font style="vertical-align: inherit;">Nucleus SE kann geändert werden, wenn die Anwendung eine längere Laufzeit erfordert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abschlussfunktionen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus SE implementiert Terminierungsfunktionen ähnlich wie Nucleus RTOS, nur können sie vollständig deaktiviert werden (wodurch Sie Speicherplatz sparen können) und sie werden auch statisch bestimmt. </font><font style="vertical-align: inherit;">Die Endfunktion kann nicht geändert werden, wenn der Timer zurückgesetzt wird.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nicht realisierte API-Aufrufe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus RTOS unterstützt acht Timer-Serviceanrufe. </font><font style="vertical-align: inherit;">Von diesen sind drei in Nucleus SE nicht implementiert. </font><font style="vertical-align: inherit;">Eine ausführliche Beschreibung dieser Aufrufe sowie die Gründe für diese Entscheidung finden Sie weiter oben in diesem Artikel im Abschnitt "Nicht realisierte API-Aufrufe". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der folgende Artikel untersucht Unterbrechungen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455072/">https://habr.com/ru/post/de455072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455060/index.html">Homer oder die erste OpenSource. Teil 1</a></li>
<li><a href="../de455062/index.html">Fälle erfolgreicher (und nicht so) Experimente mit Yandex.Navigator</a></li>
<li><a href="../de455064/index.html">Talent vs. Glück: Die Rolle des Zufalls für Erfolg und Misserfolg</a></li>
<li><a href="../de455066/index.html">Systemanalyse MeetUp UPD2 Broadcast und Präsentationen</a></li>
<li><a href="../de455068/index.html">Null-Fehler-Richtlinie. Keine Bugs - keine Probleme?</a></li>
<li><a href="../de455078/index.html">Wo kann man im Sommer über Apache Ignite und verteilte Systeme sprechen?</a></li>
<li><a href="../de455080/index.html">Alte Leute gehören nicht hierher? Programmierbar nach fünfunddreißig</a></li>
<li><a href="../de455094/index.html">So schützen Sie 5G in einer Smart City: Wenden Sie eine neue Sicherheitsarchitektur an</a></li>
<li><a href="../de455096/index.html">Kompetenzen mit Tests testen - warum und wie</a></li>
<li><a href="../de455098/index.html">Interview mit Alexander Makarov, Yii-Kernteam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>