<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë®üèæ üë©üèæ‚Äçüè´ üìå Die ganze Wahrheit √ºber RTOS. Artikel 28. Software-Timer üêü üïö üë®üèΩ‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Idee der Software-Timer wurde in einem fr√ºheren Artikel vorgestellt . Es handelt sich um Kernelobjekte, die Aufgaben eine einfache M√∂glichkeit bie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel 28. Software-Timer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455072/">  Die Idee der Software-Timer wurde in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel vorgestellt</a> .  Es handelt sich um Kernelobjekte, die Aufgaben eine einfache M√∂glichkeit bieten, Ereignisse rechtzeitig auszul√∂sen, oder meistens eine M√∂glichkeit, Aktionen regelm√§√üig auszuf√ºhren.  Alle Details der zeitbezogenen Funktionalit√§t (Genauigkeit, Interrupt-Behandlung usw.) in Nucleus SE wurden in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel</a> er√∂rtert. <br><br><img src="https://habrastorage.org/webt/xu/5v/_s/xu5v_sdm50mq9i1ywof_lgsvqkw.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Fr√ºhere Artikel in der Reihe:</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemzeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kan√§le: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenkan√§le: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <br></div></div><br><h2>  Timer verwenden </h2><br>  Programm-Timer k√∂nnen so konfiguriert werden, dass sie einmal ausgel√∂st werden, dh sie starten und nach einer bestimmten Zeit einfach den Zyklus beenden.  Oder der Timer kann so konfiguriert werden, dass er neu startet: Nach Abschluss der Z√§hlung wird der Timer automatisch neu gestartet.  Die Betriebszeit nach einem Neustart kann von der anf√§nglichen Betriebszeit abweichen.  Zus√§tzlich kann der Timer optional so konfiguriert werden, dass er eine spezielle Beendigungsfunktion ausf√ºhrt, die ausgef√ºhrt wird, wenn (oder jedes Mal) der Timer den Arbeitszyklus abschlie√üt. <br><br><h2>  Timer-Einstellungen </h2><br><h3>  Anzahl der Timer </h3><br>  Wie bei den meisten Aspekten von Nucleus SE werden die Timer-Einstellungen von den Anweisungen <b>#define</b> in <b>nuse_config.h gesteuert</b> .  Der Hauptparameter ist <b>NUSE_TIMER_NUMBER</b> , der die in der Anwendung konfigurierten Timer definiert.  Standardm√§√üig ist dieser Wert Null (dh Timer werden in der Anwendung nicht verwendet) und kann Werte bis zu 16 annehmen. Ein falscher Wert f√ºhrt zu einem Kompilierungsfehler, der durch Einchecken der Datei <b>nuse_config_check.h</b> (diese Datei ist in <b>nuse_config.c enthalten</b> und kompiliert) <b>generiert wird</b> zusammen mit ihm), wodurch die Direktive <b>#error ausgel√∂st wird</b> . <br><br>  Die Auswahl eines Werts ungleich Null ist der Hauptaktivator des Timers.  Dieser Parameter wird beim Definieren von Datenstrukturen verwendet und ihre Gr√∂√üe h√§ngt von ihrem Wert ab.  Dar√ºber hinaus aktiviert ein Wert ungleich Null die API-Einstellungen. <br><br><h3>  Aktivierung der Abschlussfunktion </h3><br>  In Nucleus SE habe ich versucht, die M√∂glichkeit zu finden, die Funktionalit√§t optional zu machen, wodurch Speicherplatz gespart wird.  Ein gutes Beispiel ist die Unterst√ºtzung von Timer-Abschlussfunktionen.  Zus√§tzlich zu der Tatsache, dass diese Funktion f√ºr jeden Timer optional ist, kann der Mechanismus f√ºr die gesamte Anwendung mithilfe des Parameters <b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b> in <b>nuse_config.h</b> aktiviert werden (oder nicht).  Wenn Sie diesen Parameter auf <b>FALSE setzen</b> , wird die Definition von zwei Datenstrukturen im ROM blockiert, die in diesem Artikel ausf√ºhrlich beschrieben werden. <br><br><h3>  API-Aktivierung </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE verf√ºgt √ºber die Direktive #define enable in nuse_config.h.  F√ºr Timer umfassen diese Symbole: <br>  <b>NUSE_TIMER_CONTROL</b> <b><br></b>  <b>NUSE_TIMER_GET_REMAINING</b> <b><br></b>  <b>NUSE_TIMER_RESET</b> <b><br></b>  <b>NUSE_TIMER_INFORMATION</b> <b><br></b>  <b>NUSE_TIMER_COUNT</b> <br><br>  Standardm√§√üig sind alle Aktivatoren auf <b>FALSE gesetzt</b> , sodass alle Serviceaufrufe deaktiviert sind und die Aufnahme von Code, der sie implementiert, blockiert wird.  Um Timer in der Anwendung einzurichten, m√ºssen Sie die erforderlichen API-Serviceaufrufe ausw√§hlen und auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein <b>Codeausschnitt</b> aus der Standarddatei <b>nuse_config.h</b> . <br><br><pre><code class="plaintext hljs">#define NUSE_TIMER_NUMBER 0/*      0-16 */ /*    */ #define NUSE_TIMER_CONTROL FALSE #define NUSE_TIMER_GET_REMAINING FALSE #define NUSE_TIMER_RESET FALSE #define NUSE_TIMER_INFORMATION FALSE #define NUSE_TIMER_COUNT FALSE</code> </pre> <br>  Wenn die timerbezogene API-Funktion aktiviert ist und keine konfigurierten Timer in der Anwendung vorhanden sind (mit Ausnahme der Funktion <b>NUSE_Timer_Count ()</b> , die immer aktiviert ist), tritt ein Kompilierungsfehler auf.  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, tritt ein Layoutfehler auf, da der Implementierungscode nicht in der Anwendung enthalten war. <br><br><h2>  Timer-Serviceanrufe </h2><br>  Nucleus RTOS unterst√ºtzt acht timerbezogene Dienstprogrammaufrufe, die die folgenden Funktionen bieten: <br><br><ul><li>  Management-Timer (Start / Stopp).  Nucleus SE ist in der Funktion <b>NUSE_Timer_Control ()</b> implementiert. </li><li>  Abrufen der verbleibenden Timerzeit.  In Nucleus SE, implementiert in <b>NUSE_Timer_Get_Remaining ()</b> . </li><li>  Wiederherstellen des urspr√ºnglichen Zustands des Timers (Zur√ºcksetzen).  Nucleus SE in <b>NUSE_Timer_Reset ()</b> implementiert. </li><li>  Bereitstellung von Informationen zu einem bestimmten Timer.  Nucleus SE ist in <b>NUSE_Timer_Information ()</b> implementiert. </li><li>  Gibt die Anzahl der konfigurierten (derzeit) Timer in der Anwendung zur√ºck.  Nucleus SE ist in <b>NUSE_Timer_Count ()</b> implementiert. </li><li>  Hinzuf√ºgen eines neuen Timers zur Anwendung (Erstellung).  Nucleus SE ist nicht implementiert. </li><li>  Entfernen eines Timers aus der Anwendung.  Nucleus SE ist nicht implementiert. </li><li>  R√ºckgabe von Zeigern auf alle Timer in der Anwendung.  Nucleus SE ist nicht implementiert. </li></ul><br>  Die Implementierung jedes Serviceabrufs wird nachstehend ausf√ºhrlich erl√§utert. <br><br><h2>  Timer-Dienste </h2><br>  Die grundlegenden Operationen, die mit einem Timer ausgef√ºhrt werden k√∂nnen, sind die Steuerung (Start und Stopp) und das Lesen des aktuellen Werts.  Nucleus RTOS und Nucleus SE bieten zwei grundlegende API-Dienstprogrammaufrufe f√ºr diese Vorg√§nge. <br><br><h3>  Timer-Steuerung </h3><br>  Durch einen Dienstprogrammaufruf an die Nucleus RTOS-API zur Steuerung des Timers k√∂nnen Sie den Timer aktivieren und deaktivieren (Start und Stopp).  Nucleus SE bietet √§hnliche Funktionen. <br><br>  <b><i>Timer Control Challenge in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Control_Timer (NU_TIMER * Timer, OPTION aktivieren);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Zeiger auf den vom Benutzer bereitgestellten Timer-Steuerblock; <br>  <b>enable</b> ist die erforderliche Funktion und kann die Werte <b>NU_ENABLE_TIMER</b> oder <b>NU_DISABLE_TIMER annehmen</b> . <br><br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INAVLID_TIMER</b> - ung√ºltiger <b>Timerzeiger</b> ; <br>  <b>NU_INAVLID_ENABLE</b> - ung√ºltige Funktion. <br><br>  <b><i>Timer Control Challenge in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die volle Funktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Timer_Control (NUSE_TIMER-Timer, OPTION-Aktivierung);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Index (ID) des verwendeten Timers; <br>  <b>enable</b> ist die erforderliche Funktion und kann die Werte <b>NUSE_ENABLE_TIMER</b> oder <b>NUSE_DISABLE_TIMER annehmen</b> . <br><br>  R√ºckgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INCALID_TIMER</b> - ung√ºltiger Timer-Index; <br>  <b>NUSE_INVALID_ENABLE</b> ist eine ung√ºltige Funktion. <br><br>  <b><i>Implementieren Sie das Timer-Management in Nucleus SE</i></b> <br>  Der API-Funktionscode <b>NUSE_Timer_Control ()</b> (nach √úberpr√ºfung der Parameter) ist recht einfach: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; if (NUSE_Timer_Expirations_Counter[timer] == 0) { NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; } else { NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } } else /* enable == NUSE_DISABLE_TIMER */ { NUSE_Timer_Status[timer] = FALSE; } NUSE_CS_Exit();</code> </pre><br>  Wenn die Funktion <b>NUSE_DISABLE_TIMER</b> angegeben wurde, wird der Timer-Status (Parameter <b>NUSE_Timer_Status []</b> ) auf <b>FALSE gesetzt</b> , wodurch der Timer vom Interrupt-Handler ignoriert wird. <br><br>  Wenn Sie die Funktion <b>NUSE_ENABLE_TIMER</b> ausw√§hlen <b>, wird</b> der Timer-Z√§hler ( <b>NUSE_Timer_Value []</b> ) auf <b>NUSE_Timer_initial_Time [] gesetzt</b> , sofern der Timer seit dem letzten Zur√ºcksetzen nie angehalten hat.  Andernfalls wird ihm der Wert <b>NUSE_Timer_Reschedule_Time []</b> zugewiesen.  Dann wird der Timer-Status (Parameter <b>NUSE_Timer_Status []</b> ) auf <b>TRUE gesetzt</b> , wodurch der Timer vom Interrupt-Handler verarbeitet wird. <br><br><h3>  Timer lesen </h3><br>  Um die verbleibende Zeitgeberzeit abzurufen, gibt der Nucleus RTOS API-Serviceaufruf die Anzahl der Kennzahlen zur√ºck, bis er abl√§uft.  Nucleus SE bietet √§hnliche Funktionen. <br><br>  <b><i>Rufen Sie an, um die verbleibende Zeit in Nucleus RTOS abzurufen</i></b> <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Get_Remaining_Time (NU_TIMER * Timer, UNSIGNED * verbleibende_Zeit);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Zeiger auf den vom Benutzer bereitgestellten Timer-Steuerblock; <br>  <b>verbleibende Zeit</b> - ein Zeiger auf die Speicherung des verbleibenden Zeitwerts, der eine Variable vom Typ <b>UNSIGNED ist</b> . <br><br>  R√ºckgabewert <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TIMER</b> - ung√ºltiger <b>Timerzeiger</b> . <br><br>  <b><i>Rufen Sie an, um die verbleibende Zeit in Nucleus SE zu erhalten</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die volle Funktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Timer_Get_Remaining (NUSE_TIMER-Timer, U16 * verbleibende_Zeit);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Index (ID) des verwendeten Timers; <br>  <b>verbleibende Zeit</b> - ein Zeiger auf die Speicherung des verbleibenden Zeitwerts, der eine Variable vom Typ <b>U16 ist</b> . <br><br>  R√ºckgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_TIMER</b> - ung√ºltiger Timer-Index; <br>  <b>NUSE_INVALID_POINTER</b> - Nullzeiger auf die verbleibende Zeit ( <b>NULL</b> ). <br><br>  <b><i>Implementieren eines Timers Read in Nucleus SE</i></b> <br>  Die API-Funktionscodevariante <b>NUSE_Timer_Get_Remaining ()</b> (nach √úberpr√ºfung der Parameter) ist trivial einfach.  Der Wert <b>NUSE_Timer_Value [] wird</b> abgerufen und dann im kritischen Abschnitt zur√ºckgegeben. <br><br><h2>  Auxiliary Timer Services </h2><br>  Nucleus RTOS verf√ºgt √ºber vier API-Aufrufe, die Zusatzfunktionen f√ºr Timer bereitstellen: Zur√ºcksetzen eines Timers, Abrufen von Timerinformationen, Abrufen der Anzahl der Timer in einer Anwendung und Abrufen von Zeigern auf alle Timer in einer Anwendung.  Die ersten drei Funktionen sind in Nucleus SE implementiert. <br><br><h3>  Timer zur√ºckgesetzt </h3><br>  Dieser API-Aufruf setzt den Timer auf seinen urspr√ºnglichen, nicht verwendeten Zustand zur√ºck.  Der Timer kann nach Beendigung dieses Anrufs aktiviert oder deaktiviert werden.  Es kann nur verwendet werden, nachdem der Timer deaktiviert wurde (mit <b>NUSE_Timer_Control ()</b> ).  <b>Wenn</b> der Timer das n√§chste Mal aktiviert wird, wird er mit dem Parameter <b>NUSE_Timer_Initial_Time []</b> initialisiert.  Mit Nucleus RTOS k√∂nnen Sie einen neuen Anfangszustand bereitstellen und die Zeit neu planen sowie die Abschlussfunktion angeben, wenn der Timer zur√ºckgesetzt wird.  In Nucleus SE werden diese Werte w√§hrend des Setups festgelegt und k√∂nnen nicht ge√§ndert werden, da sie im ROM gespeichert sind. <br><br>  <b><i>Aufruf zum Zur√ºcksetzen eines Timers in Nucleus RTOS</i></b> <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Reset_Timer (NU_TIMER * Timer, VOID (* Ablaufdatum) (UNSIGNED), UNSIGNED initial_time, UNSIGNED reschedule_time, OPTION enable);</b> <br><br>  Parameter: <br>  <b>Timer</b> - ein Zeiger auf einen zur√ºcksetzbaren Timer; <br>  <b>expiration_routine</b> - gibt die Funktion an, die ausgef√ºhrt wird, wenn die Schleife endet. <br>  <b>initial_time</b> - Die anf√§ngliche Anzahl der Timer-Ticks bis zum Ende der Schleife. <br>  <b>reschedule_time</b> - Die Anzahl der Timer- <b>Ticks</b> bis zum Abschluss des zweiten und der folgenden Zyklen. <br>  <b>enable</b> - Der erforderliche Status des Timers nach einem Reset kann die Werte <b>NU_ENABLE_TIMER</b> oder <b>NU_DISABLE_TIMER annehmen</b> . <br><br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TIMER</b> - ung√ºltiger Zeiger auf die Timer-Steuereinheit; <br>  <b>NU_INVALID_FUNCTION</b> - Nullzeiger auf die Abschlussfunktion ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> - Der angegebene Status ist falsch. <br>  <b>NU_NOT_DISABLED</b> - Der Timer l√§uft bereits (er sollte vor dem Aufruf dieser Funktion gestoppt werden). <br><br>  <b><i>Rufen Sie an, um den Timer in Nucleus SE zur√ºckzusetzen</i></b> <br>  Dieser API-Serviceaufruf unterst√ºtzt eine vereinfachte Version der Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Timer_Reset (NUSE_TIMER-Timer, OPTION-Aktivierung);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Index (ID) des Reset-Timers; <br>  <b>enable</b> - Der erforderliche Status nach dem Zur√ºcksetzen kann die Werte <b>NUSE_ENABLE_TIMER</b> oder <b>NUSE_DISABLE_TIMER annehmen</b> . <br><br>  R√ºckgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_TIMER</b> - ung√ºltiger Timer-Index; <br>  <b>NUSE_INVALID_ENABLE</b> - Der angegebene Status ist falsch. <br>  <b>NUSE_NOT_DISABLED</b> - Der Timer l√§uft bereits (er sollte vor dem Aufruf dieser Funktion gestoppt werden). <br><br>  <b><i>Implementieren eines Timer-Resets in Nucleus SE</i></b> <br>  Die Version des API-Funktionscodes <b>NUSE_Timer_Reset ()</b> (nach √úberpr√ºfung der Parameter und des aktuellen Status) ist recht einfach: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); NUSE_Init_Timer(timer); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; } /*  enable == NUSE_DISABLE_TIMER    FALSE */ NUSE_CS_Exit();</code> </pre><br>  Ein Aufruf von <b>NUSE_Init_Timer ()</b> initialisiert den Zeitwert und l√∂scht den Abschlussz√§hler.  Danach wird bei Bedarf der Wert des erforderlichen Status √ºberpr√ºft und ob der Timer eingeschaltet ist. <br><br><h3>  Timer-Informationen </h3><br>  Mit diesem Serviceabruf k√∂nnen Sie eine Reihe von Timerinformationen abrufen.  Die Implementierung von Nucleus SE unterscheidet sich von Nucleus RTOS darin, dass weniger Informationen zur√ºckgegeben werden, da die Objektbenennung nicht unterst√ºtzt wird. <br><br>  <b><i>Rufen Sie Timer-Informationen in Nucleus RTOS an</i></b> <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Timer_Information (NU_TIMER * Timer, CHAR * Name, OPTION * aktivieren, UNSIGNED * Ablauf, UNSIGNED * ID, UNSIGNED * initial_time, UNSIGNED * reschedule_time);</b> <br><br>  Parameter: <br>  <b>Timer</b> - ein Zeiger auf einen Timer, √ºber den Informationen angefordert werden; <br>  <b>name</b> - Zeiger auf den 8-stelligen Bereich f√ºr den Timernamen; <br>  <b>enable</b> - Zeiger auf eine Variable, die den aktuellen Status des Timer-Aktivators <b>annimmt</b> : <b>NU_ENABLE_TIMER</b> oder <b>NU_DISABLE_TIMER</b> ; <br>  <b>Ablaufdatum</b> - ein Zeiger auf eine Variable, die einen Z√§hler f√ºr die Anzahl der Abschl√ºsse des Zeitgeberzyklus seit seinem letzten Zur√ºcksetzen verwendet; <br>  <b>id</b> - Zeiger auf eine Variable, die den Wert des Parameters annimmt, der an die Endfunktion des Zeitgeberzyklus √ºbergeben wird; <br>  <b>initial_time</b> - ein Zeiger auf eine Variable, die einen Wert annimmt, in den der Timer nach einem Reset initialisiert wird; <br>  <b>reschedule_time</b> - Ein Zeiger auf eine Variable, die einen Wert annimmt, in den der Timer nach Abschluss initialisiert wird. <br><br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TIMER</b> - ung√ºltiger <b>Timerzeiger</b> . <br><br>  <b><i>Rufen Sie in Nucleus SE nach Timer-Informationen</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Timer_Information (NUSE_TIMER-Timer, OPTION * aktivieren, U8 * Ablauf, U8 * ID, U16 * initial_time, U16 * reschedule_time);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Index des Timers, √ºber den Informationen angefordert werden; <br>  <b>enable</b> - ein Zeiger auf eine Variable, die den Wert <b>TRUE</b> oder <b>FALSE</b> annimmt, je nachdem, ob der Timer aktiviert ist oder nicht; <br>  <b>Ablaufzeiten</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> , die den Wert der Anzahl der Timer-Abschl√ºsse seit ihrem letzten Zur√ºcksetzen annimmt; <br>  <b>id</b> - Zeiger auf eine Variable vom Typ <b>U8</b> , die den Wert des an die Timer-Abschlussfunktion √ºbergebenen Parameters annimmt (gibt einen leeren Wert zur√ºck, wenn die Abschlussfunktionen deaktiviert sind); <br>  <b>initial_time</b> - ein Zeiger auf eine Variable vom Typ <b>U16</b> , die einen Wert annimmt, mit dem der Timer nach einem Zur√ºcksetzen initialisiert wird; <br>  <b>reschedule_time</b> - Ein Zeiger auf eine Variable vom Typ <b>U16</b> , der den Wert annimmt, mit dem der Timer nach Abschluss initialisiert wird. <br><br>  R√ºckgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_TIMER</b> - ung√ºltiger Timer-Index; <br>  <b>NUSE_INVALID_POINTER</b> - Ein oder mehrere <b>Zeigerparameter</b> sind falsch. <br><br>  <b><i>Implementieren von Timer-Informationen in Nucleus SE</i></b> <br>  Die Implementierung dieses API-Aufrufs ist ziemlich einfach: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (NUSE_Timer_Status[timer]) { *enable = NUSE_ENABLE_TIMER; } else { *enable = NUSE_DISABLE_TIMER; } *expirations = NUSE_Timer_Expirations_Counter[timer]; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT *id = NUSE_Timer_Expiration_Routine_Parameter[timer]; #endif *initial_time = NUSE_Timer_Initial_Time[timer]; *reschedule_time = NUSE_Timer_Reschedule_Time[timer]; NUSE_CS_Exit();</code> </pre><br>  Die Funktion gibt den Status des Timers zur√ºck.  Der Parameterwert der Beendigungsfunktion wird nur zur√ºckgegeben, wenn deren Unterst√ºtzung in der Anwendung aktiviert wurde. <br><br><h3>  Abrufen der Anzahl der Timer </h3><br>  Dieser Dienstprogrammaufruf gibt die Anzahl der in der Anwendung konfigurierten Timer zur√ºck.  In Nucleus RTOS kann sich dieser Wert im Laufe der Zeit √§ndern, und der R√ºckgabewert zeigt die aktuelle Anzahl von Timern an.  In Nucleus SE wird der R√ºckgabewert w√§hrend der Montagephase festgelegt und kann nicht ge√§ndert werden. <br><br>  <b><i>Fordern Sie einen Timer-Z√§hler in Nucleus RTOS an</i></b> <br><br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Established_Timers (VOID);</b> <br><br>  Parameter: keine <br><br>  R√ºckgabewert: Die Anzahl der im System erstellten Timer. <br><br>  <b><i>Aufruf des Timer-Z√§hlers in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>U8 NUSE_Timer_Count (nichtig);</b> <br><br>  Parameter: keine <br><br>  R√ºckgabewert: <br>  Die Anzahl der konfigurierten Timer in der Anwendung <br><br><h3>  Implementierung des Timer-Z√§hlers </h3><br>  Die Implementierung dieses API-Aufrufs ist recht einfach: Der Wert des Symbols #define <b>NUSE_TIMER_NUMBER</b> wird <b>zur√ºckgegeben</b> . <br><br><h2>  Datenstrukturen </h2><br>  Timer verwenden f√ºnf oder sieben Datenstrukturen (im RAM oder ROM), die (wie andere Nucleus SE-Objekte) eine Reihe von Tabellen sind, deren Gr√∂√üe und Anzahl der Anzahl der konfigurierten Timer und ausgew√§hlten Parameter entspricht. <br><br>  Ich empfehle dringend, dass der Anwendungscode keinen direkten Zugriff auf diese Datenstrukturen verwendet, sondern √ºber die bereitgestellten API-Funktionen auf sie verweist.  Dies vermeidet Inkompatibilit√§t mit zuk√ºnftigen Versionen von Nucleus SE und unerw√ºnschte Nebenwirkungen und vereinfacht die Portierung von Anwendungen auf Nucleus RTOS.  Das Folgende ist eine detaillierte √úbersicht √ºber Strukturen, um das Verst√§ndnis von Serviceabruf- und Debugging-Code zu vereinfachen. <br><br><h3>  RAM-Daten </h3><br>  Diese Daten haben folgende Struktur: <br>  <b>NUSE_Timer_Status []</b> ist ein Array vom Typ <b>U8</b> , das einen Eintrag f√ºr jeden konfigurierten Timer hat und den Status des Timers speichert (l√§uft oder gestoppt: <b>TRUE</b> oder <b>FALSE</b> ). <br>  <b>NUSE_Timer_Value []</b> ist ein Array vom Typ <b>U16</b> , das einen Eintrag f√ºr jeden konfigurierten Timer hat und den aktuellen Wert des Timer-Z√§hlers speichert. <br>  <b>NUSE_Timer_Expirations_Counter []</b> - Ein Array vom Typ <b>U8</b> , das einen Z√§hler f√ºr die Anzahl der F√§lle enth√§lt, in denen die Timer das Ende des Zyklus seit ihrem letzten Zur√ºcksetzen erreicht haben. <br><br>  Alle diese Datenstrukturen werden beim <b>Start von</b> Nucleus SE von der Funktion <b>NUSE_Init_Timer ()</b> initialisiert.  Einer der folgenden Artikel enth√§lt eine vollst√§ndige Beschreibung der Startvorg√§nge f√ºr Nucleus SE. <br><br>  Im Folgenden sind die Definitionen dieser Datenstrukturen in der Datei <b>nuse_init.c aufgef√ºhrt</b> : <br>  <b>RAM U8 Timer_Status [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U16 NUSE_Timer_Value [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U8 NUSE_Timer_Expirations_Counter [NUSE_TIMER_NUMBER];</b> <br><br><h3>  ROM-Daten </h3><br>  Die Struktur dieser Daten: <br>  <b>NUSE_Timer_Initial_Time []</b> ist ein Array vom Typ <b>U16</b> , das einen Eintrag f√ºr jeden konfigurierten Timer enth√§lt und den Wert jedes Timers speichert. <br>  <b>NUSE_Timer_Reschedule_Time []</b> - Ein Array vom Typ <b>U16</b> , das einen Eintrag f√ºr jeden konfigurierten Timer enth√§lt und den Wert speichert, in dem der Timer nach Abschluss eingestellt wird.  Ein Wert von Null zeigt an, dass der Timer "einmalig" ist und nicht automatisch neu gestartet werden sollte. <br>  <b>NUSE_Timer_Expiration_Routine_Address []</b> - Ein Array vom Typ <b>ADDR,</b> das die Adresse der <b>Ablaufvorg√§nge</b> des Timers enth√§lt.  Dieses Array ist nur vorhanden, wenn die Unterst√ºtzung f√ºr das Ablaufdatum des Timers aktiviert wurde. <br>  <b>NUSE_Timer_Expiration_Routine_Parameter []</b> - Ein Array vom Typ <b>U8,</b> das die Werte des Parameters enth√§lt, der an die Timer-Abschlussfunktion √ºbergeben wird.  Dieses Array ist nur vorhanden, wenn die Unterst√ºtzung f√ºr Abschlussfunktionen aktiviert wurde. <br><br>  Diese Datenstrukturen werden (statisch) in der Datei <b>nuse_config.c</b> deklariert und initialisiert. <br><br><pre> <code class="plaintext hljs">ROM U16 NUSE_Timer_Initial_Time[NUSE_TIMER_NUMBER] = { /*   ------ */ }; ROM U16 NUSE_Timer_Reschedule_Time[NUSE_TIMER_NUMBER] = { /*      ------ */ }; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING /*    */ ROM ADDR NUSE_Timer_Expiration_Routine_Address[NUSE_TIMER_NUMBER] = { /*     ------ */ /*   NULL */ }; ROM U8 NUSE_Timer_Expiration_Routine_Parameter[NUSE_TIMER_NUMBER] = { /*     ------ */ }; #endif</code> </pre><br><h3>  Die Speichermenge f√ºr den Timer </h3><br>  Wie bei allen anderen Nucleus SE-Objekten ist die f√ºr Timer erforderliche Datenmenge vorhersehbar. <br><br>  Die Datenmenge im RAM (in Byte) f√ºr alle Timer in der Anwendung kann wie folgt berechnet werden: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  Die Datenmenge im ROM (in Byte) f√ºr alle Timer in der Anwendung kann wie folgt berechnet werden, wenn die Unterst√ºtzung f√ºr Abschlussfunktionen deaktiviert ist: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  Ansonsten ist es gleich: <br>  <b>NUSE_TIMER_NUMBER * (Gr√∂√üe von (ADDR) + 5)</b> <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Nucleus SE implementiert die drei API-Aufrufe, die in RTOS enthalten sind, nicht. <br><br><h3>  Timer-Erstellung </h3><br>  Dieser API-Aufruf erstellt einen Timer.  Nucleus SE ben√∂tigt es nicht, da Timer statisch erstellt werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Create_Timer (NU_TIMER * timer, CHAR * name, VOID (* expiration_routine) (UNSIGNED), UNSIGNED id, UNSIGNED initial_time, UNSIGNED reschedule_time, OPTION enable);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Zeiger auf den vom Benutzer bereitgestellten Timer-Steuerblock;  Es wird verwendet, um Timer in anderen API-Aufrufen zu steuern. <br>  <b>name</b> - Zeiger auf den 7-stelligen Namen des Timers mit einer abschlie√üenden Null; <br>  <b>expiration_routine</b> - gibt die Funktion an, die nach <b>Ablauf</b> des Timers ausgef√ºhrt werden soll. <br>  <b>id</b> - ein Datenelement vom Typ <b>UNSIGNED,</b> das an die Beendigungsfunktion √ºbergeben wird: Dieser Parameter kann verwendet werden, um Timer mit derselben Beendigungsfunktion zu identifizieren; <br>  <b>initial_time</b> - gibt die anf√§ngliche Anzahl von Timer-Ticks an, bevor der Timer endet; <br>  <b>reschedule_time</b> - Gibt die Anzahl der Timer- <b>Ticks an,</b> bis der zweite und die folgenden Zyklen abgeschlossen sind.  Wenn dieser Parameter gleich Null ist, stoppt der Timer nur einmal. <br>  <b>enable</b> - Dieser Parameter kann die Werte <b>NU_ENABLE_TIMER</b> und <b>NU_DISABLE_TIMER annehmen</b> .  <b>NU_ENABLE_TIMER</b> aktiviert einen Timer, nachdem er erstellt wurde.  <b>NU_DISABLE_TIMER</b> l√§sst den Timer deaktiviert.  Mit dem Parameter <b>NU_DISABLE_TIMER</b> erstellte Timer m√ºssen durch Aufrufen von <b>NU_Control_Timer</b> aktiviert werden. <br><br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TIMER</b> - ein Nullzeiger auf eine Timer-Steuereinheit ( <b>NULL</b> ) oder die Steuereinheit wird bereits verwendet; <br>  <b>NU_INVALID_FUNCTION</b> - Nullzeiger auf das Abschlussprogramm ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> - ung√ºltiger <b>Aktivierungsparameter</b> ; <br>  <b>NU_INVALID_OPERATION</b> - Der Parameter <b>initial_time</b> war Null. <br><br><h3>  Timer l√∂schen </h3><br>  Dieser API-Aufruf l√∂scht einen zuvor erstellten Timer.  Nucleus SE ben√∂tigt es nicht, da Timer statisch erstellt werden und nicht gel√∂scht werden k√∂nnen. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Delete_Timer (NU_TIMER * Timer);</b> <br><br>  Parameter: <br>  <b>Timer</b> - Zeiger auf den Timer-Steuerblock. <br><br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_TIMER</b> - ung√ºltiger <b>Timerzeiger</b> ; <br>  <b>NU_NOT_DISABLED</b> - Der angegebene Timer ist nicht deaktiviert. <br><br><h3>  Timer-Zeiger </h3><br>  Dieser API-Aufruf bildet eine sequentielle Liste von Zeigern auf alle Timer im System.  Nucleus SE ben√∂tigt es nicht, da die Timer durch einen einfachen Index und nicht durch einen Zeiger bestimmt werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Timer_Pointers (NU_TIMER ** Zeigerliste, UNSIGNED Maximum_Pointers);</b> <br><br>  Parameter: <br>  <b>pointer_list</b> - Zeiger auf ein Array von Zeigern <b>NU_TIMER</b> ;  Es wird mit Zeigern auf im System konfigurierte Timer gef√ºllt. <br>  <b>Maximum_Pointers</b> - Die maximale Anzahl von Zeigern im Array. <br><br>  R√ºckgabewert: <br>  Die Anzahl der im Array platzierten <b>NU_TIMER-</b> Zeiger. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Wie bei allen anderen Nucleus SE-Objekten war es mein Ziel, die Kompatibilit√§t des Anwendungscodes mit Nucleus RTOS zu maximieren.  Timer sind keine Ausnahme und werden aus Anwendersicht auf die gleiche Weise wie in Nucleus RTOS implementiert.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt auch eine gewisse Inkompatibilit√§t, die ich f√ºr zul√§ssig hielt, da der Code dadurch verst√§ndlicher und effizienter in Bezug auf den erforderlichen Speicher wird. </font><font style="vertical-align: inherit;">Andernfalls k√∂nnen Nucleus RTOS-API-Aufrufe fast direkt auf Nucleus SE portiert werden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objektkennungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Nucleus RTOS werden alle Objekte durch eine Datenstruktur beschrieben - einen Steuerblock mit einem bestimmten Datentyp. Ein Zeiger auf diese Steuereinheit ist eine Zeitgeberkennung. Ich entschied, dass in Nucleus SE ein anderer Ansatz f√ºr eine effiziente Speichernutzung erforderlich ist: Alle Kernelobjekte werden durch eine Reihe von Tabellen im RAM und / oder ROM beschrieben. Die Gr√∂√üe dieser Tabellen wird durch die Anzahl der konfigurierten Objekte jedes Typs bestimmt. Die Kennung eines bestimmten Objekts ist der Index in dieser Tabelle. Also habe ich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_TIMER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als das √Ñquivalent von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U8 definiert</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Variable (kein Zeiger) dieses Typs dient als Kennung des Timers. </font><font style="vertical-align: inherit;">Diese leichte Inkompatibilit√§t ist leicht zu handhaben, wenn der Code von Nucleus SE nach Nucleus RTOS und umgekehrt portiert wird. </font><font style="vertical-align: inherit;">In der Regel werden keine anderen Operationen an Objektkennungen als Verschieben und Speichern ausgef√ºhrt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus RTOS unterst√ºtzt auch die Benennung von Timern. </font><font style="vertical-align: inherit;">Diese Namen werden nur zum Debuggen verwendet. </font><font style="vertical-align: inherit;">Ich habe sie von Nucleus SE ausgeschlossen, um Speicherplatz zu sparen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Timergr√∂√üe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Nucleus RTOS werden Timer mithilfe von 32-Bit-Z√§hlern implementiert. </font><font style="vertical-align: inherit;">Ich habe beschlossen, diesen Wert in Nucleus SE auf 16 Bit zu reduzieren. </font><font style="vertical-align: inherit;">Dies hat zu erheblichen Verbesserungen der Speichereffizienz und der Laufzeit gef√ºhrt. </font><font style="vertical-align: inherit;">Nucleus SE kann ge√§ndert werden, wenn die Anwendung eine l√§ngere Laufzeit erfordert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abschlussfunktionen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus SE implementiert Terminierungsfunktionen √§hnlich wie Nucleus RTOS, nur k√∂nnen sie vollst√§ndig deaktiviert werden (wodurch Sie Speicherplatz sparen k√∂nnen) und sie werden auch statisch bestimmt. </font><font style="vertical-align: inherit;">Die Endfunktion kann nicht ge√§ndert werden, wenn der Timer zur√ºckgesetzt wird.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nicht realisierte API-Aufrufe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus RTOS unterst√ºtzt acht Timer-Serviceanrufe. </font><font style="vertical-align: inherit;">Von diesen sind drei in Nucleus SE nicht implementiert. </font><font style="vertical-align: inherit;">Eine ausf√ºhrliche Beschreibung dieser Aufrufe sowie die Gr√ºnde f√ºr diese Entscheidung finden Sie weiter oben in diesem Artikel im Abschnitt "Nicht realisierte API-Aufrufe". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der folgende Artikel untersucht Unterbrechungen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455072/">https://habr.com/ru/post/de455072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455060/index.html">Homer oder die erste OpenSource. Teil 1</a></li>
<li><a href="../de455062/index.html">F√§lle erfolgreicher (und nicht so) Experimente mit Yandex.Navigator</a></li>
<li><a href="../de455064/index.html">Talent vs. Gl√ºck: Die Rolle des Zufalls f√ºr Erfolg und Misserfolg</a></li>
<li><a href="../de455066/index.html">Systemanalyse MeetUp UPD2 Broadcast und Pr√§sentationen</a></li>
<li><a href="../de455068/index.html">Null-Fehler-Richtlinie. Keine Bugs - keine Probleme?</a></li>
<li><a href="../de455078/index.html">Wo kann man im Sommer √ºber Apache Ignite und verteilte Systeme sprechen?</a></li>
<li><a href="../de455080/index.html">Alte Leute geh√∂ren nicht hierher? Programmierbar nach f√ºnfunddrei√üig</a></li>
<li><a href="../de455094/index.html">So sch√ºtzen Sie 5G in einer Smart City: Wenden Sie eine neue Sicherheitsarchitektur an</a></li>
<li><a href="../de455096/index.html">Kompetenzen mit Tests testen - warum und wie</a></li>
<li><a href="../de455098/index.html">Interview mit Alexander Makarov, Yii-Kernteam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>