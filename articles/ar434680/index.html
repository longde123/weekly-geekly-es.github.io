<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😲 👩🏻‍🤝‍👨🏽 🍠 تطور جدولة المهام 👼🏿 👩🏼‍🤝‍👩🏻 🚶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="تطبيق iFunny الذي نعمل عليه متوفر في المتاجر لأكثر من خمس سنوات. خلال هذا الوقت ، كان على الفريق المتنقل متابعة العديد من الأساليب والهجرات المختلفة ب...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تطور جدولة المهام</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/434680/" style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/bv/mr/ps/bvmrpspwu-kyhojb5tiu4lqbdi8.jpeg"><br><br>  تطبيق iFunny الذي نعمل عليه متوفر في المتاجر لأكثر من خمس سنوات.  خلال هذا الوقت ، كان على الفريق المتنقل متابعة العديد من الأساليب والهجرات المختلفة بين الأدوات ، وقبل عام كان هناك وقت للتبديل من حل مكتوب ذاتيًا والبحث في اتجاه شيء "أكثر شيوعًا" وانتشارًا.  هذا المقال عبارة عن ضغط صغير حول ما تمت دراسته ، وما هي الحلول التي تم النظر فيها ، وما الذي انتهى إليه الأمر. <a name="habracut"></a><br><br>  <b>لماذا نحتاج كل هذا؟</b> <br><br>  لنقرر على الفور تكريمًا لماهية هذه المقالة ولماذا تبين أن هذا الموضوع مهم لفريق تطوير Android: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  هناك العديد من السيناريوهات عندما تحتاج إلى تشغيل المهام خارج إطار واجهة المستخدم النشطة </li><li style=";text-align:right;direction:rtl">  يفرض النظام عددًا كبيرًا من القيود على بدء هذه المهام ؛ </li><li style=";text-align:right;direction:rtl">  لقد أصبح من الصعب للغاية الاختيار بين الحلول الحالية ، حيث أن كل أداة لها مزاياها وعيوبها. </li></ol><br><h3 style=";text-align:right;direction:rtl">  <b>التسلسل الزمني لتطور الأحداث</b> </h3><br>  <b>أندرويد 0</b> <b><br></b> <h3 style=";text-align:right;direction:rtl">  AlarmManager ، معالج ، الخدمة </h3><br>  في البداية ، تم تنفيذ حلولهم لبدء المهام المستندة إلى الخلفية على أساس الخدمات.  كانت هناك أيضًا آلية تربط المهام بدورة الحياة وتمكنت من إلغاؤها واستعادتها.  يناسب هذا الفريق لفترة طويلة ، حيث أن المنصة لم تفرض أي قيود على مثل هذه المهام. <br>  تنصح Google بالقيام بذلك بناءً على المخطط التالي: <br><br><img src="https://habrastorage.org/webt/e-/46/zn/e-46znleyxvynpm35pbebgrkdhk.png"><br><br>  في نهاية عام 2018 ، لا يوجد أي معنى لفهم ذلك ، يكفي لتقييم حجم الكارثة. <br>  في الواقع ، لم يهتم أحد بحجم العمل الذي يحدث في الخلفية.  فعلت التطبيقات ما أرادوا وعندما أرادوا. <br><br>  <i><b>الايجابيات</b> :</i> <i><br></i>  <i>متاح في كل مكان</i> <i><br></i>  <i>في متناول الجميع.</i> <i><br><br></i>  <i><b>سلبيات</b> :</i> <i><br></i>  <i>يقيد النظام العمل بكل الطرق ؛</i> <i><br></i>  <i>لا تطلق من قبل الشرط.</i> <i><br></i>  <i>واجهة برمجة التطبيقات (API) ضئيلة للغاية وتحتاج إلى كتابة الكثير من التعليمات البرمجية.</i> <i><br></i> <br>  <b>أندرويد 5. المصاصة</b> <b><br></b> <h3 style=";text-align:right;direction:rtl">  Jobcheduler </h3><br>  بعد 5 (!) سنوات ، أقرب إلى عام 2015 ، لاحظت Google أن المهام قد تم إطلاقها بشكل غير فعال.  بدأ المستخدمون يتذمرون بانتظام من انخفاض هواتفهم ببساطة عن طريق الاستلقاء على طاولة أو في جيبهم. <br><br>  مع إصدار Android 5 ، ظهرت أداة مثل JobScheduler.  هذه هي الآلية التي يمكن من خلالها تنفيذ العديد من الأعمال في الخلفية ، والتي تم تحسينها وتبسيطها نظرًا للنظام المركزي لإطلاق هذه المهام والقدرة على وضع شروط لعملية الإطلاق هذه. <br><br>  في التعليمات البرمجية ، كل هذا يبدو بسيطًا للغاية: يتم الإعلان عن خدمة تأتي فيها أحداث البداية والنهاية. <br>  من الفروق الدقيقة: إذا كنت ترغب في أداء العمل بشكل غير متزامن ، فأنت بحاجة إلى بدء الدفق من onStartJob ؛  الشيء الرئيسي هو عدم نسيان استدعاء طريقة jobFinished في نهاية العمل ، وإلا فلن يترك النظام WakeLock ، لن تعتبر مهمتك مكتملة وستفقد. <br><br><pre style=";text-align:right;direction:rtl"><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  من أي مكان في التطبيق ، يمكنك بدء هذا العمل.  يتم تنفيذ المهام في عمليتنا ، ولكن يتم البدء بها على مستوى IPC.  هناك آلية مركزية تتحكم في تنفيذها وتستيقظ التطبيق فقط في اللحظات الضرورية لذلك.  يمكنك أيضًا ضبط العديد من شروط التشغيل ونقل البيانات من خلال Bundle. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">JobInfo task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobInfo.Builder(JOB_ID, serviceName) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); JobScheduler scheduler = (JobScheduler) context.getSystemService(JOB_SCHEDULER_SERVICE); scheduler.schedule(task);</code> </pre> <br>  بشكل عام ، بالمقارنة مع لا شيء ، كان هذا بالفعل شيء.  لكن هذه الآلية متوفرة فقط مع API 21 ، وعند إصدار Android 5.0 سيكون من الغريب التوقف عن دعم جميع الأجهزة القديمة (لقد مرت 3 سنوات ، وما زلنا ندعم أربع). <br><br>  <i><b>الايجابيات</b> :</i> <i><br></i>  <i>واجهة برمجة التطبيقات بسيطة ؛</i> <i><br></i>  <i>شروط الاطلاق.</i> <i><br></i> <br>  <b><i>سلبيات</i></b> : <br>  <s>متاح بدءا من API 21</s> <br>  في الواقع ، فقط مع API 23 ؛ <br>  من السهل أن نخطئ. <br><br>  <b>أندرويد 5. المصاصة</b> <b><br></b> <h3 style=";text-align:right;direction:rtl">  <b>مدير شبكة GCM</b> </h3><br>  تم تقديم عرض تمثيلي لـ JobScheduler - مدير شبكة GCM.  هذه مكتبة توفر وظائف مماثلة ، لكنها عملت بالفعل مع واجهة برمجة التطبيقات 9. صحيحًا ، لقد تطلب الأمر خدمات Google Play في المقابل.  على ما يبدو ، فإن الوظيفة اللازمة لتشغيل JobScheduler ، بدأت تقدم ليس فقط من خلال إصدار Android ، ولكن أيضًا على مستوى GPS.  تجدر الإشارة إلى أن مطوري الإطار غيروا رأيهم بسرعة كبيرة وقرروا عدم ربط مستقبلهم بنظام GPS.  شكرا لهم على ذلك. <br><br>  كل شيء يبدو متطابقة تماما.  نفس الخدمة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmNetworkManagerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmTaskService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TaskParams taskParams)</span></span></span><span class="hljs-function"> </span></span>{ doWork(taskParams); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  إطلاق المهمة نفسها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">OneoffTask task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OneoffTask.Builder() .setService(GcmNetworkManagerService.class) .setTag(TAG) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); GcmNetworkManager mGcmNetworkManager = GcmNetworkManager.getInstance(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); mGcmNetworkManager.schedule(task);</code> </pre> <br>  هذا التشابه في العمارة تمليه الوظيفة الموروثة والرغبة في الحصول على انتقال بسيط بين الأدوات. <br><br>  <i><b>الايجابيات</b> :</i> <i><br></i>  <i>API مماثلة ل JobScheduler.</i> <i><br></i>  <i>متاح بدءا من API 9.</i> <i><br><br></i>  <i><b>سلبيات</b> :</i> <i><br></i>  <i>يجب أن يكون لديك خدمات Google Play</i> <i><br></i>  <i>من السهل أن نخطئ.</i> <br><br>  <b>أندرويد 5. المصاصة</b> <b><br></b> <h3 style=";text-align:right;direction:rtl">  <b>WakefulBroadcastReceiver</b> </h3><br>  بعد ذلك ، سأكتب بضع كلمات عن إحدى الآليات الأساسية المستخدمة في JobScheduler ومتاحة مباشرة للمطورين.  هذا هو WakeLock ومقره WakefulBroadcastReceiver. <br><br>  باستخدام WakeLock ، يمكنك منع النظام من ترك التعليق ، أي إبقاء الجهاز في حالة نشطة.  هذا ضروري إذا أردنا القيام ببعض الأعمال المهمة. <br>  عند إنشاء WakeLock ، يمكنك تحديد إعداداته: اضغط على وحدة المعالجة المركزية أو الشاشة أو لوحة المفاتيح. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE) PowerManager.WakeLock wl = pm.newWakeLock(PARTIAL_WAKE_LOCK, <span class="hljs-string"><span class="hljs-string">"name"</span></span>) wl.acquire(timeout);</code> </pre> <br>  بناءً على هذه الآلية ، يعمل WakefulBroadcastReceiver.  نبدأ الخدمة وعقد WakeLock. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleWakefulReceiver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WakefulBroadcastReceiver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ Intent service = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, SimpleWakefulService.class); startWakefulService(context, service); } }</code> </pre> <br>  بعد انتهاء الخدمة اللازمة من العمل ، نطلقها من خلال طرق مماثلة. <br><br>  من خلال 4 إصدارات ، سيتم إهمال برنامج BroadcastReceiver هذا ، وسيتم وصف البدائل التالية على developer.android.com: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  JobScheduler </li><li style=";text-align:right;direction:rtl">  Syncadapter </li><li style=";text-align:right;direction:rtl">  DownloadManager </li><li style=";text-align:right;direction:rtl">  FLAG_KEEP_SCREEN_ON لـ Window. </li></ul><br>  <b>أندرويد 6. نسيم عليل</b> <b><br></b> <h3 style=";text-align:right;direction:rtl">  <b>DozeMode: النوم أثناء التنقل</b> </h3><br>  ثم بدأت Google في تطبيق تحسينات متعددة للتطبيقات التي تعمل على الجهاز.  ولكن ما هو الأمثل للمستخدم هو قيود للمطور. <br><br>  كانت الخطوة الأولى هي DozeMode ، والتي تضع الجهاز في وضع السكون إذا كان خاملاً لفترة معينة.  في الإصدارات الأولى ، استمرت ساعة ، في الإصدارات اللاحقة ، تم تخفيض مدة النوم إلى 30 دقيقة.  بشكل دوري ، يستيقظ الهاتف ، ويقوم بجميع المهام المعلقة وينام مرة أخرى.  نافذة DozeMode تتوسع بشكل كبير.  يمكن تتبع جميع التحولات بين وسائط من خلال بنك التنمية الآسيوي. <br><br>  عند حدوث DozeMode ، يتم فرض القيود التالية على التطبيق: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يتجاهل النظام كل WakeLock ؛ </li><li style=";text-align:right;direction:rtl">  AlarmManager تأخرت. </li><li style=";text-align:right;direction:rtl">  JobScheduler لا يعمل ؛ </li><li style=";text-align:right;direction:rtl">  SyncAdapter لا يعمل ؛ </li><li style=";text-align:right;direction:rtl">  الوصول إلى الشبكة محدود. </li></ul><br>  يمكنك أيضًا إضافة التطبيق الخاص بك إلى القائمة البيضاء بحيث لا يندرج تحت قيود DozeMode ، لكن على الأقل تجاهلت Samsung هذه القائمة تمامًا. <br><br>  <b>أندرويد 6. نسيم عليل</b> <b><br></b> <h3 style=";text-align:right;direction:rtl">  <b>AppStandby: التطبيقات غير النشطة</b> </h3><br>  يحدد النظام التطبيقات غير النشطة ويفرض جميع القيود نفسها عليها في DozeMode. <br>  يتم إرسال الطلب إلى العزلة إذا: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  ليس لديها عملية في المقدمة ؛ </li><li style=";text-align:right;direction:rtl">  ليس لديه إشعار نشط ؛ </li><li style=";text-align:right;direction:rtl">  لم تتم إضافته إلى قائمة الاستبعاد. </li></ul><br>  <b>أندرويد 7. نوغة</b> <b><br></b> <h3 style=";text-align:right;direction:rtl">  <b>تحسينات الخلفية.</b>  <b>Svelte</b> </h3><br>  Svelte هو مشروع تحاول Google من خلاله تحسين استهلاك ذاكرة الوصول العشوائي عن طريق التطبيقات والنظام نفسه. <br>  في Android 7 ، ضمن إطار هذا المشروع ، تقرر أن البث الضمني ليس فعالًا للغاية ، نظرًا لأن عددًا كبيرًا من التطبيقات يستمع إليها ، وينفق النظام قدرًا كبيرًا من الموارد عند حدوث هذه الأحداث.  لذلك ، تم حظر أنواع الأحداث التالية للإعلان في البيان: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  CONNECTIVITY_ACTION ؛ </li><li style=";text-align:right;direction:rtl">  ACTION_NEW_PICTURE ؛ </li><li style=";text-align:right;direction:rtl">  ACTION_NEW_VIDEO. </li></ul><br>  <b>أندرويد 7. نوغة</b> <b><br></b> <h3 style=";text-align:right;direction:rtl">  <b>FirebaseJobDispatcher</b> </h3><br>  في الوقت نفسه ، تم نشر نسخة جديدة من إطار عمل إطلاق المهمة - FirebaseJobDispatcher.  في الواقع ، كان GCM NetworkManager المكتمل ، والذي تم ترتيبه قليلاً وجعله أكثر مرونة قليلاً. <br><br>  بصريا ، بدا كل شيء هو نفسه تماما.  نفس الخدمة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  الفرق الوحيد بينه هو القدرة على تثبيت برنامج التشغيل الخاص به.  السائق هو الفئة التي كانت مسؤولة عن استراتيجية إطلاق المهمة. <br><br>  لم يتغير إطلاق المهام نفسها بمرور الوقت. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">FirebaseJobDispatcher dispatcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirebaseJobDispatcher(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GooglePlayDriver(context)); Job task = dispatcher.newJobBuilder() .setService(FirebaseJobDispatcherService.class) .setTag(TAG) .setConstraints(Constraint.ON_UNMETERED_NETWORK, Constraint.DEVICE_IDLE) .build(); dispatcher.mustSchedule(task);</code> </pre><br>  <i><b>الايجابيات</b> :</i> <i><br></i>  <i>API مماثلة ل JobScheduler.</i> <i><br></i>  <i>متاح بدءا من API 9.</i> <i><br><br></i>  <i><b>سلبيات</b> :</i> <i><br></i>  <i>يجب أن يكون لديك خدمات Google Play</i> <i><br></i>  <i>من السهل أن نخطئ.</i> <i><br></i> <br>  كان من المشجع تثبيت برنامج التشغيل الخاص بي للتخلص من GPS.  لقد بحثنا ، ولكن وجدنا في النهاية ما يلي: <br><br><img src="https://habrastorage.org/webt/3n/39/ua/3n39uanajermu--vb5qrzgfl8jq.png"><br><br><img src="https://habrastorage.org/webt/zm/rq/i3/zmrqi3pnt_0hx8lcspdy8k6xio8.png"><br><br>  تعرف Google ذلك ، لكن تظل هذه المهام مفتوحة لعدة سنوات. <br><br>  <b>أندرويد 7. نوغة</b> <b><br></b> <h3 style=";text-align:right;direction:rtl">  <b>وظيفة الروبوت من Evernote</b> </h3><br>  نتيجةً لذلك ، لم يتمكن المجتمع من الوقوف وظهر حل عصامي في شكل مكتبة من Evernote.  لم يكن الحل الوحيد ، ولكن كان الحل من Evernote هو الذي كان قادراً على ترسيخ نفسه و "الانخراط في الناس". <br><br>  من الناحية المعمارية ، كانت هذه المكتبة أكثر ملاءمة من سابقاتها. <br>  لقد ظهر الكيان المسؤول عن إنشاء المهام.  في حالة JobScheduler ، تم إنشاؤها من خلال التفكير. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJobCreator</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobCreator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tag: String)</span></span></span><span class="hljs-function">: Job? </span></span>{ when (tag) { SendLogsJob.TAG -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SendLogsJob() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } }</code> </pre> <br>  هناك فئة منفصلة ، وهي المهمة نفسها.  في JobScheduler ، تم إلقاء كل هذا في مفتاح داخل onStartJob. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Params)</span></span></span><span class="hljs-function">: Result </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doWork(params) } }</code> </pre> <br>  إطلاق المهام مطابق ، ولكن بالإضافة إلى الأحداث الموروثة ، أضاف Evernote أيضًا مهامه الخاصة ، مثل بدء تشغيل المهام اليومية والمهام الفريدة والتشغيل داخل النافذة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobRequest.Builder(JOB_ID) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED) .build() .scheduleAsync();</code> </pre> <br>  <i><b>الايجابيات</b> :</i> <i><br></i>  <i>API مريحة.</i> <i><br></i>  <i>مدعومة على جميع الإصدارات ؛</i> <i><br></i>  <i>لا تحتاج إلى خدمات Google Play.</i> <i><br><br></i>  <i><b>سلبيات</b> :</i> <i><br></i>  <i>حل الطرف الثالث.</i> <i><br></i> <br>  الرجال بنشاط دعم مكتبتهم.  على الرغم من وجود عدد قليل من المشكلات الحرجة ، إلا أنها عملت على جميع الإصدارات وعلى جميع الأجهزة.  ونتيجة لذلك ، اختار فريق Android لدينا في العام الماضي حلاً من Evernote ، نظرًا لأن المكتبات من Google تقطع طبقة كبيرة من الأجهزة التي لا يمكنها دعمها. <br>  في الداخل ، عملت على حلول من Google ، في الحالات القصوى - مع AlarmManager. <br><br>  <b>أندرويد 8. أوريو</b> <b><br></b> <h3 style=";text-align:right;direction:rtl">  <b>حدود تنفيذ الخلفية</b> </h3><br>  دعنا نعود إلى حدودنا.  مع ظهور Android الجديد ، ظهرت تحسينات جديدة.  وجد الرجال من Google مشكلة أخرى.  هذه المرة تحول كل شيء إلى الخدمات والبث (نعم ، لا شيء جديد). <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <s>startService إذا التطبيقات في الخلفية</s> </li><li style=";text-align:right;direction:rtl">  <s>البث الضمني في البيان</s> </li></ul><br>  أولاً ، تم حظر بدء الخدمات من الخلفية.  في "إطار القانون" ظلت الخدمات الأمامية فقط.  الخدمات الآن يمكن أن يقال أن يتم إهمالها. <br>  القيد الثاني هو نفس البث.  هذه المرة أصبح من المحظور تسجيل جميع البث الضمني في البيان.  البث الضمني هو بث ، ليس مخصصًا لتطبيقنا فقط.  على سبيل المثال ، هناك إجراء ACTION_PACKAGE_REPLACED ، وهناك ACTION_MY_PACKAGE_REPLACED.  لذلك ، أول واحد هو ضمني. <br><br>  ولكن لا يزال من الممكن تسجيل أي بث من خلال Context.registerBroadcast. <br><br>  <b>أندرويد 9. فطيرة</b> <b><br></b> <h3 style=";text-align:right;direction:rtl">  <b>العامل</b> </h3><br>  على هذا التحسين قد توقف بعد.  ربما بدأت الأجهزة تعمل بسرعة وبدقة من حيث استهلاك الطاقة ؛  ربما اشتكى المستخدمون أقل من ذلك. <br>  في Android 9 ، تعامل مطورو الإطار بدقة مع أداة بدء المهام.  في محاولة لحل جميع المشكلات الملحة ، تم تقديم مكتبة على Google I / O لبدء تشغيل المهام الأساسية لـ WorkManager. <br><br>  تحاول Google مؤخرًا تشكيل رؤيتها لبنية تطبيق Android وتمنح المطورين الأدوات اللازمة لذلك.  لذلك كانت هناك مكونات معمارية مع LiveData و ViewModel و Room.  WorkManager يشبه تكملة معقولة لنهجهم والنموذج. <br><br>  إذا تحدثنا عن كيفية ترتيب WorkManager بالداخل ، فلا يوجد تقدم تكنولوجي فيه.  في الواقع ، هذه مجموعة من الحلول الحالية: JobScheduler و FirebaseJobDispatcher و AlarmManager. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">createBestAvailableBackgroundScheduler</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Scheduler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBestAvailableBackgroundScheduler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context, WorkManager)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &gt;= MIN_JOB_SCHEDULER_API_LEVEL) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemJobScheduler(context, workManager); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tryCreateFirebaseJobScheduler(context); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemAlarmScheduler(context); } }</code> </pre> <br></div></div><br>  رمز الاختيار بسيط جدا.  ولكن تجدر الإشارة إلى أن JobScheduler متاح بدءًا من واجهة برمجة التطبيقات 21 ، لكنهم يستخدمونها فقط مع واجهة برمجة التطبيقات 23 ، نظرًا لأن الإصدارات الأولى كانت غير مستقرة إلى حد ما. <br><br>  إذا كان الإصدار أقل من 23 ، فمن خلال الانعكاس نحاول العثور على FirebaseJobDispatcher ، وإلا فإننا نستخدم AlarmManager. <br><br>  تجدر الإشارة إلى أن المجمع أصبح مرنا للغاية.  هذه المرة ، قام المطورون بتقسيم كل شيء إلى كيانات منفصلة ، ويبدو معمارياً أنه مناسب: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  العامل - منطق العمل ؛ </li><li style=";text-align:right;direction:rtl">  WorkRequest - منطق إطلاق المهمة ؛ </li><li style=";text-align:right;direction:rtl">  WorkRequest.Builder - المعلمات ؛ </li><li style=";text-align:right;direction:rtl">  القيود - الظروف ؛ </li><li style=";text-align:right;direction:rtl">  WorkManager - مدير يدير المهام ؛ </li><li style=";text-align:right;direction:rtl">  WorkStatus - حالة المهمة. </li></ul><br><br><img src="https://habrastorage.org/webt/n_/ts/xi/n_tsxiw0wsxv6a5abotzdzokcba.png"><br><br>  تم توريث شروط التشغيل من JobScheduler. <br>  تجدر الإشارة إلى أن المشغل لتغيير URI يظهر فقط مع API 23. بالإضافة إلى ذلك ، يمكنك الاشتراك في تغيير ليس فقط URI معين ، ولكن أيضًا كل المتداخلة فيه باستخدام العلامة في الطريقة. <br><br>  إذا تحدثنا عنا ، ثم في مرحلة ألفا ، فقد تقرر التبديل إلى WorkManager. <br>  هناك عدة أسباب لذلك.  يحتوي Evernote على بعض الأخطاء الهامة التي يعد مطورو المكتبة بإصلاحها مع الانتقال إلى إصدار مع WorkManager متكامل.  وهم أنفسهم متفقون على أن قرار Google ينفي مزايا Evernote.  بالإضافة إلى ذلك ، يتناسب هذا الحل مع هيكلنا ، حيث نستخدم مكونات الهندسة المعمارية. <br><br>  علاوة على ذلك ، أود أن أوضح مع مثال بسيط كيف نحاول استخدام هذا النهج.  في الوقت نفسه ، ليس من الأهمية بمكان أن يكون لديك WorkManager أو JobScheduler. <br><br><img src="https://habrastorage.org/webt/ox/yd/0p/oxyd0pizr6h8tx4egaz_kub5wqy.png" width="300" height="430"><img src="https://habrastorage.org/webt/6m/ec/hd/6mechdqawzamahgaij7df-isocg.png" width="300" height="430"><br><br>  دعونا نلقي نظرة على مثال لحالة بسيطة للغاية: النقر على إعادة النشر أو ما شابه. <br><br>  تحاول جميع التطبيقات الآن الابتعاد عن حظر الطلبات على الشبكة ، لأن هذا يجعل المستخدم يشعر بالتوتر ويجعله ينتظر ، على الرغم من أنه في الوقت الحالي يمكنه إجراء عمليات شراء داخل التطبيق أو مشاهدة الإعلانات. <br><br>  في مثل هذه الحالات ، تتغير البيانات المحلية أولاً - يرى المستخدم على الفور نتيجة تصرفه.  ثم في الخلفية يوجد طلب للخادم ، إذا فشل ، تتم إعادة تعيين البيانات إلى حالتها الأولية. <br><br>  بعد ذلك ، سأعرض مثالاً عن كيف يبدو معنا. <br><br>  JobRunner يحتوي على منطق لبدء المهام.  أساليبه تصف تكوين المهام وتمرير المعلمات. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">JobRunner.java</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">likePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(content: IFunnyContent)</span></span></span><span class="hljs-function"> </span></span>{ val constraints = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .build() val input = Data.Builder() .putString(LikeContentJob.ID, content.id) .build() val request = OneTimeWorkRequest.Builder(LikeContentJob::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setInputData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setConstraints</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constraints</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkManager</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getInstance</span></span></span><span class="hljs-class">().</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enqueue</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">) }</span></span></code> </pre><br></div></div><br>  المهمة نفسها داخل WorkManager هي كما يلي: نأخذ المعرّف من المعلمات ونستدعي الطريقة على الخادم لتعجب هذا المحتوى. <br><br>  لدينا فئة أساسية تحتوي على المنطق التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>{ val workerInjector = WorkerInjectorProvider.injector() workerInjector.inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performJob(inputData) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Data)</span></span></span><span class="hljs-function">: Result }</span></span></code> </pre><br>  أولاً ، يتيح لك الابتعاد قليلاً عن المعرفة الواضحة للعامل.  كما أنه يحتوي على منطق حقن التبعية من خلال WorkerInjector. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">WorkerInjectorImpl.java</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Ovierride</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Worker job)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> AppCrashedEventSendJob) { Injector.getAppComponent().inject((AppCrashedEventSendJob) job); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> CheckNativeCrashesJob) { Injector.getAppComponent().inject((CheckNativeCrashesJob) job); } } }</code> </pre><br></div></div><br>  إنه ببساطة يوجه المكالمات إلى Dagger ، لكنه يساعدنا في الاختبار: نحن نحل محل تطبيقات الحاقن وننفذ البيئة اللازمة في المهام. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testRegisterPushProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WorkManagerTestInitHelper.initializeTestWorkManager(context) val testDriver = WorkManagerTestInitHelper.getTestDriver() WorkerInjectorProvider.setInjector(TestInjector()) <span class="hljs-comment"><span class="hljs-comment">// mock dependencies val id = jobRunner.runPushRegisterJob() testDriver.setAllConstraintsMet(id) Assert.assertTrue(…) }</span></span></code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jobRunner</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobRunner</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interactor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ iFunnyContentDao.like(getContent().id) jobRunner.likePost(getContent()) } }</code> </pre> <br>  Interactor هو الكيان الذي يسحب ViewController لبدء مرور البرنامج النصي (في هذه الحالة ، مثله).  نضع علامة على المحتوى محليًا على أنه "تم الرفع" ونرسل المهمة للتنفيذ.  إذا فشلت المهمة ، تتم إزالة مثل. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class">() </span></span>{ val likeState = MediatorLiveData&lt;Boolean&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentId = MutableLiveData&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentState: LiveData&lt;IFunnyContent&gt; = attachLiveDataToContentId(); init { likeState.addSource(iFunnyContentState) { likeState.postValue(it!!.hasLike) } } }</code> </pre> <br>  نحن نستخدم مكونات الهندسة المعمارية من Google: ViewModel و LiveData.  هذا هو ما يشبه ViewModel لدينا.  نحن هنا نربط تحديث الكائن في DAO بحالة الإعجاب. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">IFunnyContentViewController.java</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewController</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">likePostInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">viewModel</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: View)</span></span></span><span class="hljs-function"> </span></span>{ viewModel.likeState.observe(lifecycleOwner, { updateLikeView(it!!) }) } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLikePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ likePostInteractor.setContent(getContent()) likePostInteractor.execute() } }</code> </pre> <br></div></div><br>  ViewController ، من ناحية ، تشترك في تغيير حالة ما شابه ، من ناحية أخرى ، يبدأ مرور النص الذي نحتاجه. <br><br>  وهذا عمليا هو الكود الذي نحتاجه.  يبقى لإضافة سلوك العرض نفسه مع ما شابه وتنفيذ DAO الخاص بك ؛  إذا كنت تستخدم Room ، فقم فقط بتسجيل الحقول في الكائن.  يبدو بسيط جدا وفعالة. <br><br><h3 style=";text-align:right;direction:rtl">  <b>لتلخيص</b> </h3><br>  <b>JobScheduler ، مدير شبكة GCM ، FirebaseJobDispatcher:</b> <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لا تستخدمها </li><li style=";text-align:right;direction:rtl">  لا تقرأ مقالات عنها بعد الآن </li><li style=";text-align:right;direction:rtl">  لا تشاهد التقارير </li><li style=";text-align:right;direction:rtl">  لا أعتقد أي واحد للاختيار. </li></ul><br>  <b>وظيفة Android بواسطة Evernote:</b> <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  داخل سوف يستخدمون WorkManager. </li><li style=";text-align:right;direction:rtl">  الأخطاء الحرجة غير واضحة بين الحلول. </li></ul><br>  <b>مدير العمل:</b> <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  واجهة برمجة تطبيقات المستوى 9+ ؛ </li><li style=";text-align:right;direction:rtl">  مستقلة عن خدمات Google Play ؛ </li><li style=";text-align:right;direction:rtl">  التسلسل / InputMergers. </li><li style=";text-align:right;direction:rtl">  نهج رد الفعل. </li><li style=";text-align:right;direction:rtl">  الدعم من جوجل (أريد أن أصدق ذلك). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar434680/">https://habr.com/ru/post/ar434680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar434670/index.html">Habrapost التقارير السنوية - 2018</a></li>
<li><a href="../ar434672/index.html">Fintech Digest: المنتجات الأكثر شعبية في عام 2018 ، أي مضاعفة حجم التحويلات من بطاقة إلى أخرى ، وضريبة على العملة المشفرة</a></li>
<li><a href="../ar434674/index.html">نرد على تخريب الكابلات بسرعة ، في كل مكان وبدون مصائد جسدية</a></li>
<li><a href="../ar434676/index.html">TOP-10 - ماذا تتعلم في عام 2019</a></li>
<li><a href="../ar434678/index.html">صباح المسؤول: إضافة مساحة على العشرات من خوادم القهوة</a></li>
<li><a href="../ar434682/index.html">شخصية مدينة Teleportator</a></li>
<li><a href="../ar434684/index.html">الصدأ 2019 وما بعده: قيود النمو</a></li>
<li><a href="../ar434686/index.html">دورة محاضرة في JavaScript و Node.js في KPI</a></li>
<li><a href="../ar434688/index.html">FreeBSD تخطط للتبديل إلى ZFSonLinux</a></li>
<li><a href="../ar434690/index.html">نظام التشغيل Haiku: ترقية التطبيقات وإنشاء الحزم</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>