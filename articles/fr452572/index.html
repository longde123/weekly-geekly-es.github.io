<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💭 👩‍⚖️ 🎥 EFORTH pour MK-161: Structures de données 🌈 👩‍🎤 💜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article est la fin d'une série d'articles eForth sur une calculatrice programmable. Commencez ici . 

 Les commandes du langage de saisie "Electro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EFORTH pour MK-161: Structures de données</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452572/">  <i>Cet article est la fin d'une série d'articles eForth sur une calculatrice programmable.</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Commencez ici</a> .</i> <br><br>  Les commandes du langage de saisie "Electronics MK-161" n'occupent que la moitié du fichier eForth0.mkl.  La seconde moitié est occupée par des tableaux dont le développement n'a pas été moins difficile que l'écriture de la partie algorithmique du traducteur.  Essayons de comprendre comment ces tables sont utilisées. <br><img src="https://habrastorage.org/webt/02/fk/fj/02fkfjzcgzqhki9p-xj7mwfmftw.jpeg"><br><a name="habracut"></a><br>  Le professeur Wirth enseigne que la «programmation dans le petit» consiste à développer deux composants tout aussi importants - les algorithmes et les structures de données. <br><br>  Nous avons déjà rencontré une structure de données eForth.  Il s'agit du corps de VCA (mots de haut niveau) situé dans la mémoire d'octets.  Quatre gestionnaires interprètent les champs de paramètres de «leur propre» VCA de différentes manières: <br><br><pre><code class="plaintext hljs">.DB DOVAR ;      .DB … ;      .DB DOCON ;    .DW _ ;   .DB DOCONM ;     .DW _ ;   .DB DOLST ;     .DW 1, 2,… EXITT ;  </code> </pre> <br>  La structure de données relativement simple suivante est associée aux TYPE "messages standard".  <b>Tous les messages eForth sont numérotés et transférés dans la mémoire du programme bon marché.</b>  Si le mot TYPE imprime une seule lettre, son code peut être le numéro d'un tel message, de 0 à 7. <br><br><pre> <code class="plaintext hljs">;   TYPE .BASE tblTYPE: .DBB str7,str6, str5, str4, str3, str2, str1, str0</code> </pre> <br>  Dans le langage MK étendu, la pseudo-commande .BASE définit la "base" de la commande .DBB, qui place séquentiellement les décalages de ligne de str7, str6, etc., en octets.  par rapport à l'étiquette de base tblTYPE.  En ajoutant des nombres de 0 à 7 à l'adresse de la table, ce décalage peut être lu à partir de celle-ci.  En ajoutant le décalage trouvé à tblTYPE, nous obtenons l'adresse de la ligne souhaitée. <br><br>  Le premier octet de la chaîne contient sa longueur.  eForth utilise largement ces <i>lignes de comptage</i> . <br><br>  Nous sommes également tombés sur la table tblTokens, qui répertorie les adresses de code des 208 mots intégrés.  Si le mot n'est pas primitif, le tableau contient 0. Aller à l'adresse 0 provoquera le redémarrage d'eForth, avec un grincement. <br><br>  La table tblNames a également été mentionnée, se référant aux noms des mêmes 208 mots.  Ces noms sous forme de lignes de comptage sont stockés dans la même mémoire de programme «caoutchouc».  La table tblNames elle-même ne sera pas disponible pendant l'exécution d'eForth, mais les informations qu'elle contient ne seront pas perdues.  Au moment de la compilation, eForth.f transférera l'adresse des noms vers une structure de données plus pratique stockée dans la mémoire décimale (voir 2). <br><br>  J'ai également parlé de tblCHPUT, un tableau associatif de codes de contrôle lors de l'affichage d'une lettre sur l'écran d'une calculatrice.  Sept autres tableaux, de tblKeyNum à tblKeyRusF, traduisent le code d'un bouton pressé dans différents modes de clavier en un code de lettre de 8 bits.  L'adresse du sous-programme responsable du mode clavier actif est dans le registre décimal ptrKbdInt. <br><br>  Au total, une seule structure de données n'est pas encore assemblée dans le fichier eForth0.mkl, ce sont des tables de reconnaissance de nom.  Laissons-les en dessert (voir 5) après le plat principal - deux tableaux de titres stockés dans la mémoire décimale.  Premièrement, nous nous armerons d'outils pour «bourrer» ces rubriques. <br><br><h3>  1. Travaillez avec les titres: HEAD!  et HEAD @ </h3><br><pre> <code class="plaintext hljs">HEAD! ( xt nfa r -- )     r,  xt  nfa. HEAD@ ( r -- xt nfa lex )     r,  xt, nfa  .</code> </pre><br>  Un registre décimal MK-161 peut mémoriser 12 décimales.  eForth utilise ce registre pour stocker trois petits nombres, chacun de 0 à 9999. Les <b>trois «champs» pour stocker ces nombres sont I appelés A, B et C: AAAABBBBCCCC.</b>  Le signe décimal fait uniquement référence au champ A. <br><br>  La primitive HEAD @ obtient le numéro de registre et en divise le nombre en champs, et HEAD!  recueille des champs dans un nombre long et écrit le "monstre" résultant dans le registre spécifié.  Mais il y a des nuances. <br><br>  La «rubrique décimale» du mot contient dans le champ A l'adresse de son nom (nfa).  Si cette adresse est négative, le nom est enregistré dans la mémoire du programme.  Le champ B contient le mot jeton (xt).  Le champ C est appelé un lexique.  Il stocke le bit IMMEDIATE et un signe que le mot est destiné uniquement à la compilation. <br><br>  HEAD @ divise l'en-tête en plusieurs parties.  En haut de la pile se trouve le champ de lexique C, en dessous se trouve le champ de nom A. Le champ B, dans lequel le jeton est généralement stocké, est tout en bas. <br><br>  HEAD!  réinitialise le champ C. <br><br><h3>  2. Rubriques intégrées </h3><br><img src="https://habrastorage.org/webt/ny/_t/g7/ny_tg7mxwoqm9h65nlq4ybfcazu.png"><br><br>  Les en-têtes de chacun des 208 mots intégrés (0 à 207) vont dans l'ordre, en commençant par R44.  Le champ A contient toujours un nombre négatif, car les noms de ces mots sont codés en dur dans la mémoire du programme. <br><br>  Les champs B et C sont modifiables.  Par conséquent, l'utilisateur peut redéfinir les mots intégrés et en faire IMMÉDIATEMENT le besoin (voir 4). <br><br><h3>  3. Rubriques utilisateur </h3><br><img src="https://habrastorage.org/webt/gh/lw/3v/ghlw3v8ajgu1dhgfiyoughzpngm.png"><br><br>  Travailler avec seulement 208 noms prédéfinis économise de la mémoire d'octets, mais est exceptionnellement ennuyeux.  Par conséquent, j'ai développé une autre structure de données où le fantasme dans le choix d'un nom est limité à seulement 32 lettres.  Cette structure se compose de 32 <i>listes</i> , dont chacune est responsable des mots utilisateurs d'une certaine longueur.  Chacune de ces 32 listes a un titre personnel.  Les listes elles-mêmes sautent sur la mémoire décimale, mais leurs en-têtes sont toujours stockés dans R301 ... R332. <br><br>  <b>Le tri des mots par longueur de nom est un point fort important de 161eForth.</b>  Le tri réduit considérablement le nombre de comparaisons lorsque vous recherchez un mot par son nom, ce qui accélère la compilation.  Qui a besoin de fonctions de hachage si chaque nom a une longueur connue? <br><br>  Par souci de simplicité, l'en- <i>tête de la liste</i> a la même structure avec les champs A, B et C que l'en-tête du mot.  Le but de ces champs est différent.  Le champ A contient le numéro du premier registre de la liste.  Le champ B contient le nombre de registres fournis dans la liste.  Le champ C stocke le nombre de mots dont les en-têtes sont déjà sur la liste. <br><br>  Au début du travail, les champs C sont égaux à zéro; les mots sont absents dans toutes les listes.  Les champs B sont 2, chaque liste reçoit deux registres pour commencer.  Les champs A indiquent des blocs de 2 registres commençant par R333. <br><br>  Chaque liste contient des titres de mots.  Nous les avons déjà démontés (voir. 1).  Ici, peut-être, l'adresse du nom (nfa) sera positive et pointera vers la ligne de comptage, traditionnellement stockée devant le corps du VCA.  En outre, le jeton dans le champ B est l'adresse du champ de code (cfa) qui va dans la mémoire binaire immédiatement après ce nom.  Il y a une exception - <b>si le mot a déjà été déterminé, le champ A pointera vers l'ancien nom.</b>  Pourquoi stocker à nouveau la chaîne?  La mémoire binaire coûte cher. <br><br>  Lorsque tous les registres de la liste sont pleins (B = C), le mot PUBLISH fournit 5 autres emplacements libres, poussant cette structure de données au bon endroit et ajustant les liens (A) dans les en-têtes de liste. <br><br><h3>  4. Publication d'un nouveau mot: TRAVAIL et PUBLICATION </h3><br><pre> <code class="plaintext hljs">LAST ( -- a )      . WORK ( -- a )     . PUBLISH ( -- )     . $,n ( nfa -- )     ,    nfa. ?UNIQUE ( a -- a )  ,    .</code> </pre><br>  La structure de données développée pour le MK-161 pour le stockage des titres de mots s'est avérée pratique et facilement intégrable dans eForth.  Lorsque CREATE, CONSTANT ou: crée un nouveau mot, ils accèdent au mot système $, n pour créer un titre pour le mot avec le nom donné.  $, n fait référence à? UNIQUE pour vérification - créons-nous un nouveau mot ou redéfinissons-nous l'ancien? <br><br>  Si un mot du même nom existe déjà ,? UNIQUE avertit l'utilisateur à ce sujet.  Dans le même temps, l'adresse de l'en-tête redéfini est entrée dans la dernière variable système.  Pour un nouveau mot, LAST est remis à zéro. <br><br>  Dans tous les cas, $, n crée un nouvel en-tête dans la variable WORK - c'est un registre décimal qui peut stocker 12 bits de l'en-tête.  Si le nom n'a pas été trouvé, il est inclus dans le dictionnaire avant le champ de code, comme cela se produit dans 86eForth et dans de nombreux autres Forts.  <b>Le MK-161 a réussi à se passer d'un «champ de communication»</b> , ce qui économise également de la mémoire binaire. <br><br>  La primitive PUBLISH complète la définition d'un mot.  Lors de la compilation des mots deux-points, PUBLISH est appelé à partir de ;; en conséquence, le bit SMUDGE n'était pas requis.  L'endroit où l'en-tête de WORK est copié est déterminé par la dernière variable.  Si LAST est nul, un nouvel en-tête est créé dans la liste correspondante (voir 3).  La liste est-elle complète?  Ensuite, PUBLISH y ajoutera 5 registres supplémentaires, dont quatre pour l'avenir. <br><br>  Après avoir exécuté PUBLISH, la dernière variable pointe toujours vers le titre du dernier mot.  Cela aide IMMEDIATE à faire son travail en changeant le champ du lexique. <br><br><h3>  5. (FIND) et tableaux de reconnaissance des noms </h3><br><pre> <code class="plaintext hljs">(FIND) ( a -- r T | a F )    r,        a. FIND ( a -- a F | xt 1 | xt -1)    .  1,  IMMEDIATE.</code> </pre><br>  Une primitive (FIND) gère la recherche d'un mot par son nom.  Tout d'abord, il recherche un nom parmi les mots intégrés avec des noms précédemment connus, puis vérifie la liste des mots utilisateur avec la longueur de nom souhaitée (voir 3).  Les tables de reconnaissance de noms accélèrent considérablement cette «première».  Voici comment ils fonctionnent. <br><br>  Au début (FIND), il trouve dans le tableau tblLen l'adresse de la table associative principale, dans laquelle des noms bien connus de la longueur requise sont "préparés".  Dans ce tableau (FIND) recherche le premier caractère du nom.  Dans la plupart des cas, cela vous permet immédiatement de trouver le <i>numéro de registre de titre du</i> mot recherché - par la première lettre et la longueur. <br><br>  Il arrive que plusieurs mots de même longueur aient les mêmes premières lettres.  Ensuite, au lieu du numéro de registre (FIND), il tombe sur l'adresse de la table associative suivante (le nombre lu est de 300 ou plus) et la recherche se poursuit sur la deuxième lettre.  Et ainsi de suite, jusqu'à ce que le mot soit trouvé ou qu'il soit établi qu'il n'y a pas un tel mot. <br><br>  Bien sûr, après une correspondance pour les premières lettres (FIND), le nom entier est vérifié.  Mais les <b>tables de reconnaissance ont rendu eForth rapide</b> .  Ce printemps, j'ai investi beaucoup de temps en eux, et maintenant ils économisent du temps de recherche.  Les "clés" y sont même triées par ordre alphabétique.  Désolé, le firmware MK-161 a craché dessus. <br><br>  Dans un souci de compatibilité, j'ai implémenté le mot FIND de Fort ANS [4], qui fait confiance à la primitive «black work» (FIND).  Le mot déjà considéré? UNIQUE recherche également son argumentation via (FIND). <br><br><h3>  6. Interprète externe </h3><br>  Le livre [1] contient une description exhaustive d'eForth, y compris un interprète «texte» externe.  C'est lui qui exécute ou compile le texte source en langue Fort.  Des différences par rapport aux interprètes textuels d'autres dialectes du fort ([2], [3]) sont apparues au cours des dernières décennies, mais il y en a peu. <br><br>  Ci-dessous est un schéma de principe d'un interpréteur de texte tiré de [1].  Attention, cet "interprète" a un mode de compilation!  Le mot $ COMPILE est responsable de la compilation du texte Forte en «code cousu», dont nous avons examiné l'exécution en détail dans le premier article.  Lorsque $ INTERPRET est exécuté à la place, les mots saisis sont exécutés immédiatement - mode d'interprétation.  EVAL "calcule" la chaîne entière entrée, en invoquant un de ces deux mots pour chaque mot entré. <br><br><img src="https://habrastorage.org/webt/fw/p0/lh/fwp0lhb3kpioz07jrwbrpz4-md8.jpeg"><br><br>  Après le diagramme, l'auteur décrypte celui des blocs.  Voici sa traduction.  Les noms de bloc correspondent généralement aux noms de mot eForth.  Le mot NOM?  est absent de mon implémentation, il est remplacé avec succès par fast (FIND) (voir. 5). <br><br><div class="scrollable-table"><table><tbody><tr><td>  MAIN </td><td>  Configurer un moteur Fort virtuel </td></tr><tr><td>  FROID </td><td>  Initialiser les variables système </td></tr><tr><td>  Abandonner </td><td>  Vider la pile de données.  Gestionnaire d'erreurs </td></tr><tr><td>  QUITTER </td><td>  Réinitialisez la pile de retour et entrez dans la boucle d'interprétation </td></tr><tr><td>  DEMANDER </td><td>  Accepter la saisie de texte du terminal </td></tr><tr><td>  EVAL </td><td>  Calculer ou interpréter une chaîne de texte </td></tr><tr><td>  PARSE </td><td>  Sélectionnez un mot dans le texte saisi </td></tr><tr><td>  $ INTERPRET </td><td>  Interpréter le mot </td></tr><tr><td>  $ COMPILER </td><td>  Compiler le mot </td></tr><tr><td>  NOM? </td><td>  Rechercher un mot dans un dictionnaire </td></tr><tr><td>  NUMBER? </td><td>  Convertir une chaîne de texte en entier </td></tr><tr><td>  EXÉCUTER </td><td>  Exécuter le mot </td></tr><tr><td>  IMMED? </td><td>  Ce mot est-il une commande immédiate? </td></tr><tr><td>  Littéral </td><td>  Compiler un littéral entier </td></tr><tr><td>  COMPILER </td><td>  Jeton de compilation </td></tr></tbody></table></div><br><br>  Le livre fournit également le code source de chaque mot eForth dans la version Windows, avec de brèves explications.  Quelle est la version différente pour MK-161, je vous l'ai déjà dit.  Le code source de mon implémentation est dans l'archive: <a href="">the-hacker.ru/2019/161eforth0.5b.zip</a> <br><br>  Enfin, je mentionnerai l'implémentation du mot <b>(PARSE) dans le langage MK-161</b> - sous Windows c'est VCA.  Le débogage a pris une semaine, mais il a <b>accéléré la compilation de moitié</b> .  Le mot (PARSE) fait tout le «sale boulot» pour PARSE pour isoler les mots individuels du flux de texte d'entrée. <br><br>  Mes ajouts à l'interpréteur externe sont deux mots, en plus du cycle QUIT habituel: le TLOAD déjà mentionné et tiré des anciennes versions de FILE.  Le mot FILE traduit les E / S sur la console, mais lit les lignes d'interprétation à partir du port RS-232.  Une fois le traitement de chaque ligne réussi, une lettre avec le code 11 est envoyée au port. Le fichier téléchargé depuis l'ordinateur doit se terminer par le mot QUIT. <br><br>  Je n'ai pas encore débogué le mot FILE.  Si quelqu'un en a besoin, partagez vos impressions. <br><br>  La révision 161eForth des points faibles est terminée, mais le Fort est un outil incroyablement flexible que chaque propriétaire peut personnaliser.  Même lorsque vous avez tout compris, quelqu'un quelque part sur la planète trouvera un autre truc qui peut vous surprendre. <br><br>  Voici les derniers mots de l'auteur eForth de [1]: <br><br><blockquote>  Depuis 26 ans, j'ai réécrit eForth plusieurs fois.  Dans chaque doublage, j'ai essayé de le rendre plus simple et plus clair.  Maintenant, dans 86eForth v5.2, je pense avoir atteint l'exactitude et je suis donc très heureux. <br><br>  Comme l'a dit Einstein: <br>  <b>Tout doit être fait aussi simple que possible, mais pas plus simple.</b> <br><br>  Rendre 86eForth v5.2 encore plus facile, peut-être le casser ou ne pas être utile comme outil de programmation. </blockquote><h3>  Littérature </h3><br><ol><li>  Dr.  Chen-Hanson Ting.  eForth et Zen - 3e édition, 2017. Disponible sur Amazon Kindle. </li><li>  Baranov S.N., Nozdrunov N.R.  Langage fort et sa mise en œuvre.  - L.: Génie mécanique.  Leningrad  Département, 1988. </li><li>  Semenov Yu.A.  Programmation en langage FORT.  - M.: Radio et communications, 1991. </li><li>  Norme ANS Forth.  X3.215-1994.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La traduction</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation SP-Forth</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Offete Enterprises (Dr Chen-Hanson Ting)</a> , auteur de 86eForth v5.2, est en anglais. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'histoire de Mikhail Pukhov "True Truth"</a> avec le programme "Moonwalker-1", où j'ai obtenu KDPV et l'amour pour les calculatrices soviétiques. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452572/">https://habr.com/ru/post/fr452572/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452562/index.html">Écrire du code JavaScript propre et évolutif: 12 conseils</a></li>
<li><a href="../fr452564/index.html">Les fonctionnalités de Python 3 méritent d'être utilisées</a></li>
<li><a href="../fr452566/index.html">Node.js pour les débutants: les bases de l'utilisation des fichiers</a></li>
<li><a href="../fr452568/index.html">Une analyse détaillée des nouvelles fonctionnalités de React 16+, partie 1: informations générales</a></li>
<li><a href="../fr452570/index.html">Linux Install Fest - vue latérale</a></li>
<li><a href="../fr452576/index.html">À propos des introvertis en informatique</a></li>
<li><a href="../fr452580/index.html">20 projets, 20 langues, date limite hier. 3e partie</a></li>
<li><a href="../fr452584/index.html">Idées fausses des programmeurs sur le temps Unix</a></li>
<li><a href="../fr452586/index.html">Comment démarrer la programmation dans Adobe Illustrator. Première partie</a></li>
<li><a href="../fr452590/index.html">L'Américain a créé une salle de classe mobile pour enseigner aux enfants des écoles d'impression 3D à petit budget, le projet en a déjà collecté plus de 100 000</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>