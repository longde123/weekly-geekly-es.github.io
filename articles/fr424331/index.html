<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍✈️ 🈲 🚭 Kubernetes 1.12: un aperçu des principales innovations 🚖 🦗 🛏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui est le 27 septembre, ce qui signifie que pendant les heures de travail (selon le fuseau horaire américain), nous pouvons nous attendre à l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes 1.12: un aperçu des principales innovations</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/424331/"><img src="https://habrastorage.org/files/48b/c2d/ec0/48bc2dec061e42928e98c92cbbadf968.png"><br><br>  Aujourd'hui est le 27 septembre, ce qui <a href="">signifie</a> que pendant les heures de travail (selon le fuseau horaire américain), nous pouvons nous attendre à la prochaine version de Kubernetes - 1.12 (cependant, son annonce officielle est parfois retardée).  En général, il est temps de poursuivre la glorieuse tradition et de parler des changements les plus importants, ce que nous ferons en fonction des informations publiques du projet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes présente le tableau de suivi</a> , <a href="">CHANGELOG-1.12</a> , de nombreux problèmes, demandes de tirage et propositions de conception.  Alors, quoi de neuf dans K8s 1.12? <a name="habracut"></a><br><br><h2>  Installations de stockage </h2><br>  Si vous identifiez une chose qui est mentionnée plus souvent que toute autre parmi tous les problèmes liés à la sortie de Kubernetes 1.12, ce sera peut-être l' <b>interface de stockage de conteneurs (CSI)</b> , dont nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déjà</a> parlé l'autre jour.  Pour cette raison, commençons par les modifications apportées à la prise en charge du stockage. <br><br>  En tant que tels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, les</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugins CSI</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ont conservé le</a> statut bêta et devraient être stables pour la prochaine version de Kubernetes (1.13).  Quoi de neuf dans le support CSI? <br><br>  En février de cette année <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, les</a> travaux sur <b>le concept de topologie ont</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commencé</a> dans la spécification CSI elle-même.  En bref, la topologie est une information sur la segmentation des clusters (par exemple, par «racks» pour les installations sur site ou par «régions» et «zones» pour les environnements cloud), que les systèmes d'orchestration doivent connaître et prendre en compte.  Pourquoi?  Les volumes alloués par les fournisseurs de stockage ne seront pas nécessairement également accessibles dans tout le cluster, et par conséquent, la connaissance de la topologie est nécessaire pour planifier efficacement les ressources et prendre des décisions de provisionnement. <br><br>  Le résultat de l'émergence des topologies dans CSI ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">adopté</a> dans la spécification le 1er juin) a été leur support dans Kubernetes 1.12: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">support en tant que tel</a> (enregistrement des informations de topologie de volume signalées par le pilote CSI) - version alpha; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prise en charge des topologies dans le provisionnement dynamique</a> (voir la documentation détaillée dans la proposition de conception intitulée « <a href="">Planification prenant en charge la topologie en volume</a> ») - version bêta immédiate; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge de la topologie GCE PD</a> - version alpha; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge de la topologie AWS EBS</a> - Bêta. </li></ul><br>  Mais cela ne se termine pas avec les mises à jour liées à CSI.  Une autre innovation importante dans la version 1.12 de Kubernetes est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>prise en charge des instantanés</b> pour CSI</a> (en état alpha).  Des instantanés des volumes en tant que tels sont apparus dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version de K8s 1.8</a> .  L'implémentation principale, qui comprend le contrôleur et le provisionneur (deux fichiers binaires séparés), a été décidée pour être transférée vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un référentiel externe</a> .  Depuis lors, la prise en charge des volumes de GCE PD, AWS EBS, OpenStack Cinder, GlusterFS et Kubernetes hostPath a été ajoutée. <br><br>  La nouvelle <a href="">proposition de conception</a> vise à «poursuivre cette initiative en ajoutant la prise en charge des instantanés pour les pilotes de volume CSI» (la prise en charge des instantanés dans la spécification CSI est décrite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  Étant donné que Kubernetes adhère au principe d'inclure un ensemble minimum de capacités dans l'API principale, cette implémentation (comme pour les instantanés dans le Volume Snapshot Controller) utilise CRD ( <code>CustomResourceDefinitions</code> ). <br><br>  Et quelques nouvelles fonctionnalités pour les pilotes CSI: <br><br><ul><li>  La version alpha de la capacité du pilote à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s’inscrire</a> dans l’API Kubernetes (afin de permettre aux utilisateurs de trouver plus facilement les pilotes installés dans le cluster et de permettre aux pilotes d’influencer les processus d’interaction de Kubernetes avec eux); </li><li>  Version alpha de la capacité du pilote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">à recevoir des informations sur le lecteur</a> demandant le volume via <code>NodePublish</code> . </li></ul><br>  Introduit dans la dernière version de Kubernetes, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mécanisme de limitation dynamique des</a> volumes sur les nœuds est passé de l'alpha à la bêta, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recevant</a> ... vous l'aurez deviné, la prise en charge de CSI, ainsi que d'Azure. <br><br>  Enfin, la fonctionnalité de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">propagation de l'espace de noms Mount</a> , qui vous permet de monter le volume en tant que <code>rshared</code> (de sorte que tous les répertoires de conteneurs montés soient visibles sur l'hôte) et a un statut bêta dans la version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">K8s 1.10</a> , est déclarée stable. <br><br><h2>  Planificateur </h2><br>  Dans le planificateur, Kubernetes 1.12 améliore les performances grâce à la version alpha du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mécanisme de restriction de</a> recherche dans un cluster de nœuds adapté à la planification de foyers <i>(nœuds réalisables)</i> .  Auparavant, pour chaque tentative de planification de chaque module, <i>kube-scheduler</i> vérifiait la disponibilité de tous les nœuds et les transmettait pour évaluation, mais maintenant le planificateur ne trouvera qu'un certain nombre d'entre eux, puis arrêtera son travail.  Dans le même temps, le mécanisme prévoit la sélection obligatoire de nœuds de différentes régions et zones, ainsi que la nécessité de visualiser différents nœuds dans différents cycles de planification (ne sélectionnez pas les 100 premiers nœuds à chaque démarrage).  La décision de mettre en œuvre ce mécanisme a été prise, guidée par les résultats de l'analyse des données sur les performances de l'ordonnanceur (si le 90e centile montrait un temps de 30 ms pour un foyer, alors le 99e centile déjà 60 ms). <br><br>  De plus, les fonctionnalités suivantes de l'ordonnanceur ont atteint la version bêta: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Taint node by Condition</a> , qui est apparu dans K8s 1.8 et permet de marquer un nœud avec un certain statut (pour d'autres actions) lorsque certains événements se produisent: maintenant le contrôleur de cycle de vie du nœud crée automatiquement des taches, et le planificateur les vérifie (au lieu de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conditions</a> ); </li><li>  <code>DaemonSet</code> foyer dans <code>DaemonSet</code> utilisant <i>kube-scheduler</i> (au lieu du contrôleur <code>DaemonSet</code> ): il a également été activé par défaut; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spécifiant une classe de priorité</a> dans <code>ResourceQuota</code> . </li></ul><br><h2>  Noeuds de cluster </h2><br>  Une innovation intéressante a été l'apparition (dans l'état de la version alpha) de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code><b>RuntimeClass</b></code></a> - une nouvelle ressource au niveau du cluster conçue pour servir les paramètres de l' <i>exécution</i> du <i>conteneur (exécution du conteneur)</i> .  <code>RuntimeClasses</code> sont attribuées aux pods via le même champ dans <code>PodSpec</code> et implémentent la prise en charge de l'utilisation de plusieurs environnements exécutables au sein d'un cluster ou d'un nœud.  Pourquoi? <br><br><blockquote>  <i>«L'intérêt pour l'utilisation de différents temps d'exécution dans un cluster augmente.</i>  <i>À l'heure actuelle, le principal facteur de motivation est les bacs à sable et le désir des conteneurs Kata et gVisor de s'intégrer à Kubernetes.</i>  <i>D'autres modèles d'exécution tels que les conteneurs Windows ou même les environnements d'exécution distants nécessiteront également une prise en charge à l'avenir.</i>  <i>RuntimeClass offre un moyen de choisir entre différents runtimes configurés dans un cluster et de modifier leurs propriétés (à la fois par le cluster et par l'utilisateur). »</i> </blockquote><br>  Pour choisir entre les configurations prédéfinies, le <a href=""><code>RuntimeHandler</code></a> passé au CRI (Container Runtime Interface), qui est destiné à remplacer les annotations actuelles du foyer: <br><br><img src="https://habrastorage.org/webt/wm/jm/yh/wmjmyh4_fivl7msyzb0ghzeqa68.png"><br><br>  Et la configuration dans containerd pour kata-runtime ressemble à ceci: <br><br><pre> <code class="plaintext hljs">[plugins.cri.containerd.kata-runtime] runtime_type = "io.containerd.runtime.v1.linux" runtime_engine = "/opt/kata/bin/kata-runtime" runtime_root = ""</code> </pre> <br>  Le critère <code>RuntimeClass</code> pour la version alpha est une <a href="">validation CRI</a> réussie. <br><br>  En outre, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mécanisme d'enregistrement des plug-ins locaux</a> (y compris CSI) dans <i>Kubelet</i> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>shareProcessNamespace</code></a> (la fonctionnalité est devenue activée par défaut) est passé au statut de version bêta. <br><br><h2>  Réseaux </h2><br>  La principale nouveauté dans la partie réseau de Kubernetes est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version alpha du</a> support <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SCTP</a></b> (Stream Control Transmission Protocol).  Ayant reçu un support dans <i>Pod</i> , <i>Service</i> , <i>Endpoint</i> et <i>NetworkPolicy</i> , ce protocole de télécommunication a rejoint les rangs de TCP et UDP.  Avec la nouvelle fonctionnalité «applications qui nécessitent SCTP comme protocole L4 pour leurs interfaces, il sera plus facile de déployer sur des clusters Kubernetes;  par exemple, ils pourront utiliser la découverte de services basée sur <i>kube-dns</i> , et leur interaction sera contrôlée via <i>NetworkPolicy</i> . "  Les détails d'implémentation sont disponibles dans <a href="">ce document</a> . <br><br>  Deux fonctionnalités réseau introduites dans K8s 1.8 ont également atteint un statut stable: la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prise en charge des stratégies</a> pour le trafic <code>EgressRules</code> sortant dans l'API NetworkPolicy et l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application des règles</a> CIDR pour la source / destination via <code>ipBlockRule</code> . <br><br><h2>  Mise à l'échelle </h2><br>  Les améliorations apportées à l'autoscaler horizontal Pod comprennent: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">algorithme mis à jour</a> pour atteindre plus rapidement la taille correcte (immédiatement alpha et bêta), pour plus de détails sur la lecture de la <a href="">nouvelle section de la documentation</a> ; </li><li>  développement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">métriques personnalisées / personnalisées</a> , dont la deuxième version bêta a reçu une API repensée et la prise en charge des sélecteurs d'étiquettes. </li></ul><br>  L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">échelle verticale des foyers</a> , qui avant d'atteindre la version bêta manquait de tests utilisateur, ne s'arrête pas.  Les auteurs l'ont jugée suffisante pour la sortie de K8s 1.12 et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rappellent</a> que cette fonctionnalité est plus susceptible d'être ajoutée à Kubernetes (non incluse dans le noyau).  Tout le développement est effectué dans un référentiel séparé, dans lequel la version bêta sera programmée pour coïncider avec la sortie de Kubernetes. <br><br><img src="https://habrastorage.org/webt/sl/0e/je/sl0ejeaihoybtqm8khj5y_tkffa.png"><br>  <i>Flux de travail Vertical Pod Autoscaler (VPA) pour Kubernetes</i> <br><br>  Enfin, K8s 1.12 inclut (sous forme alpha) les résultats des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">travaux</a> sur la "simplification de l'installation à l'aide de <code>ComponentConfig</code> " (dans le cadre du cycle de vie sig-cluster), qui dure depuis près de deux ans.  Malheureusement, pour une raison quelconque (une simple négligence?), L'accès au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">document de proposition de conception</a> avec des détails est fermé aux utilisateurs anonymes. <br><br><h2>  Autres changements </h2><br><h3>  API </h3><br>  Deux nouvelles fonctionnalités sont implémentées dans le groupe api-machines: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code> dry-run</code></a> à sec pour apiserver (version alpha), qui imite la validation et le traitement des demandes; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API de quota de ressources</a> (immédiatement bêta) qui définit les <b>ressources</b> qui sont <b>limitées par défaut</b> (au lieu du comportement actuel lorsque la consommation des ressources est illimitée si aucun quota n'est défini). </li></ul><br><h3>  Azure </h3><br>  Déclarée stable: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prise en charge des ensembles de</a> machines virtuelles virtuelles Azure (VMSS); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">charge</a> Azure dans cluster-autoscaler. </li></ul><br>  Les premières implémentations (versions alpha) sont ajoutées: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge des</a> zones de disponibilité Azure </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prise en charge de</a> nœuds tels que le <a href="">groupe de ressources croisées</a> (RG) et les nœuds non gérés (sur site). </li></ul><br><h3>  Kubectl </h3><br><ul><li>  Une version alpha du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>mécanisme de plug-in mis à jour a été</b></a> implémentée, ce qui vous permet d'ajouter de nouvelles commandes ou de réécrire des sous-commandes existantes de n'importe quel niveau d'imbrication.  Il est similaire à Git et examine les exécutables commençant par <code>kubectl-</code> dans le <code>$PATH</code> l'utilisateur.  Voir la <a href="">proposition de conception pour</a> plus de détails. </li><li>  Une version bêta de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">idée d'isoler le</a> <code>pkg/kubectl/genericclioptions</code> de kubectl dans un référentiel indépendant a été implémentée. </li><li>  La fonction d' <i>impression côté serveur</i> a été déclarée stable. </li></ul><br><h3>  Autre </h3><br><ul><li>  La version alpha du nouveau mécanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>TTL after finish</b></a> , conçue pour limiter la durée de vie des <i>Jobs</i> et <i>Pods qui ont</i> terminé leur exécution, est <i>présentée</i> .  Après l'expiration du TTL spécifié, les objets seront automatiquement nettoyés sans intervention de l'utilisateur. </li><li>  La génération d'une clé privée et d'un CSR (TLS Bootstrap) pour signer un certificat au niveau du cluster dans <i>Kubelet est</i> déclarée stable. </li><li>  La rotation du certificat TLS du serveur dans <i>Kubelet</i> est passée au statut bêta. </li></ul><br><h2>  PS </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.11: un aperçu des innovations clés</a> »; </li><li>  «L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intégration de containerd avec Kubernetes, en remplacement de Docker, est prête pour la production</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.10: aperçu des principales innovations</a> »; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.9: un aperçu des innovations clés</a> ; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quatre CNCF publient 1.0 et des annonces majeures sur Kubernetes avec KubeCon 2017</a> »; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.8: un aperçu des principales innovations</a> </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker 17.06 et Kubernetes 1.7: principales innovations</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424331/">https://habr.com/ru/post/fr424331/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424321/index.html">Mettre NetFlow bon marché et en colère</a></li>
<li><a href="../fr424323/index.html">Un exemple de travail avec la méthode ICE du chef de produit de Google et Microsoft</a></li>
<li><a href="../fr424325/index.html">Training Splunk - un centre de formation maintenant en Russie</a></li>
<li><a href="../fr424327/index.html">Fonds Zuckerberg: comment «se faire des amis» en technologie optique et biomédecine</a></li>
<li><a href="../fr424329/index.html">À faire et à faire: comment pomper dans la programmation et le développement</a></li>
<li><a href="../fr424333/index.html">Mon expérience de rencontres et de travail avec Robot Framework</a></li>
<li><a href="../fr424335/index.html">Que la lumière soit</a></li>
<li><a href="../fr424337/index.html">Code de style Ruby: avec compétence, beauté et efficacité. Exemple pour les débutants</a></li>
<li><a href="../fr424339/index.html">Tandem de l'auteur et expert: comment le rendre efficace?</a></li>
<li><a href="../fr424341/index.html">Orme. Confortable et maladroit. La composition</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>