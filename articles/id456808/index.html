<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ–‹ï¸ ğŸ‘²ğŸ¿ ğŸƒ Cara Meningkatkan Kinerja Aplikasi Web Front-End: Lima Tips âœŒğŸ½ ğŸ‘¨â€âœˆï¸ ğŸ’©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam banyak proyek front-end saya, pada titik tertentu saya dihadapkan dengan penurunan produktivitas - ini biasanya terjadi ketika kompleksitas apli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara Meningkatkan Kinerja Aplikasi Web Front-End: Lima Tips</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alconost/blog/456808/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/p2/n1/fh/p2n1fhon961as8f21unatry3hfi.jpeg"></a> <br><br>  Dalam banyak proyek front-end saya, pada titik tertentu saya dihadapkan dengan penurunan produktivitas - ini biasanya terjadi ketika kompleksitas aplikasi meningkat, dan ini normal.  Namun demikian, para pengembang masih bertanggung jawab untuk kinerja, jadi dalam artikel saya, saya akan memberikan lima tips untuk mengoptimalkan aplikasi yang saya terapkan sendiri: beberapa mungkin tampak jelas, beberapa memengaruhi prinsip dasar pemrograman - tetapi, saya pikir, menyegarkan memori tidak berlebihan. akan.  Setiap tip didukung oleh tes: Anda dapat menjalankannya sendiri dan menguji kinerjanya. <br><br>  <b>Diterjemahkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alconost</a></b> <br><a name="habracut"></a><br><h2>  Kata Pengantar </h2><br>  Ingat: jika kode tidak perlu dioptimalkan, jangan masuk ke dalamnya.  Tentu saja, kode yang Anda tulis harus bekerja dengan cepat, dan Anda selalu dapat menghasilkan algoritma yang lebih cepat - tetapi yang tertulis harus tetap jelas bagi pengembang lain.  Dalam kuliah "Pemrograman sebagai Seni," Donald Knuth mengungkapkan ide yang sangat penting tentang optimasi kode: <br><br><blockquote>  <i>Masalah sebenarnya adalah bahwa programmer menghabiskan terlalu banyak waktu untuk mengkhawatirkan efisiensi di tempat yang tidak pantas dan pada waktu yang tidak tepat.</i>  <i><b>Optimalisasi prematur adalah akar dari semua kesalahan</b> pemrograman (atau paling tidak sebagian besar).</i> <i><br></i> </blockquote><br><h2>  1. Cari: alih-alih array biasa - objek dan array asosiatif </h2><br>  Ketika bekerja dengan data, situasi sering muncul ketika, misalnya, Anda perlu menemukan objek, melakukan sesuatu dengannya, lalu menemukan objek lain, dan sebagainya.  Struktur data yang paling umum di JS adalah array, jadi menyimpan data di dalamnya adalah praktik biasa.  Namun, setiap kali Anda perlu menemukan sesuatu dalam array, Anda harus menggunakan metode seperti "find", "indexOf", "filter", atau beralih dengan loop - yaitu, Anda perlu beralih pada elemen dari awal hingga selesai.  Jadi, kami melakukan pencarian linier, kompleksitasnya adalah 0 (n) (dalam kasus terburuk, kami akan perlu melakukan perbandingan sebanyak yang ada elemen dalam array).  Jika Anda melakukan operasi ini beberapa kali pada array kecil, dampaknya pada kinerja akan kecil.  Namun, jika kita memiliki banyak elemen, dan operasi dilakukan berkali-kali, kinerja pasti akan gagal. <br><br>  Dalam hal ini, ini akan menjadi solusi yang baik untuk mengubah array biasa menjadi objek atau array asosiatif dan melakukan pencarian kunci: dalam struktur ini, elemen dapat diakses dengan kompleksitas O (1) - kita akan memiliki satu panggilan memori, terlepas dari ukurannya.  Meningkatkan kecepatan kerja dicapai melalui penggunaan struktur data yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel hash</a> . <br><br>  Anda dapat menguji kinerja di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://jsperf.com/finding-element-object-vs-map-vs-array/1</a> .  Di bawah ini adalah hasil saya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c0/3e0/62f/3c03e062f1990f348bdd5fb7084e7278.png"><br><br>  Perbedaannya sangat signifikan: untuk array asosiatif dan objek, saya mendapat jutaan operasi per detik, sedangkan untuk array, hasil terbaik adalah sedikit lebih dari seratus operasi.  Tentu saja, konversi data tidak diperhitungkan di sini, tetapi bahkan dengan mempertimbangkan operasinya akan jauh lebih cepat. <br><br><h2>  2. Alih-alih pengecualian - operator bersyarat "jika" </h2><br>  Kadang-kadang tampaknya lebih mudah untuk melewatkan cek nol dan menangkap pengecualian yang sesuai.  Ini, tentu saja, merupakan kebiasaan buruk - Anda tidak perlu melakukan ini, dan jika Anda memilikinya dalam kode Anda, cukup tulis ulang bagian yang sesuai.  Tetapi untuk meyakinkan Anda sepenuhnya, saya akan mendukung rekomendasi ini dengan tes.  Saya memutuskan untuk menguji tiga cara melakukan pemeriksaan: ekspresi "coba-coba", kondisi "jika", dan perhitungan "korsleting". <br><br>  Uji: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://jsperf.com/try-catch-vs-conditions/1</a> .  Di bawah ini adalah hasil saya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d74/4d8/9eb/d744d89eb0f25200abece3ccb5370f8b.png"><br><br>  Saya pikir dari sini jelas bahwa pemeriksaan untuk "null" diperlukan.  Selain itu, seperti yang Anda lihat, hampir tidak ada perbedaan antara kondisi "jika" dan perhitungan "korsleting" - kemudian terapkan pada apa yang ada dalam jiwa. <br><br><h2>  3. Semakin sedikit siklus, semakin baik </h2><br>  Pertimbangan lain yang jelas, tetapi mungkin kontroversial.  Ada banyak fungsi yang nyaman untuk array: "peta", "filter", "mengurangi", sehingga penggunaannya terlihat menarik, dan kode yang dengannya terlihat lebih rapi dan lebih mudah dibaca.  Tetapi ketika muncul pertanyaan untuk meningkatkan produktivitas, Anda dapat mencoba mengurangi jumlah fungsi yang dipanggil.  Saya memutuskan untuk menganalisis dua kasus: 1) "filter", lalu "peta", dan 2) "filter", lalu "kurangi" - dan bandingkan dengan rantai fungsional, "forEach" dan "tradisional" untuk loop.  Mengapa tepatnya kedua kasus ini?  Dari tes itu akan terlihat bahwa manfaat yang diperoleh mungkin tidak terlalu signifikan.  Selain itu, dalam kasus kedua, saya juga mencoba menggunakan "filter" saat memanggil "kurangi". <br><br>  Tes kinerja untuk "filter" dan "peta": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://jsperf.com/array-function-chains-vs-single-loop-filter-map/1</a> .  Hasil saya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/8f7/a78/6008f7a7819add9d68e1b4311d489461.png"><br><br>  Dapat dilihat bahwa satu siklus lebih cepat, tetapi perbedaannya kecil.  Alasan untuk celah kecil seperti ini adalah operasi "push", yang tidak diperlukan saat menggunakan "peta".  Oleh karena itu, dalam hal ini, Anda dapat memikirkan apakah perlu melanjutkan ke satu siklus. <br><br>  Sekarang mari kita periksa "filter" + "kurangi": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://jsperf.com/array-function-chains-vs-single-loop-filter-reduce/1</a> .  Hasil saya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6e/0ae/a22/b6e0aea22e9b87555180ed93a7b0bdad.png"><br><br>  Di sini perbedaannya sudah lebih besar: kombinasi dua fungsi menjadi satu mempercepat eksekusi hampir setengahnya.  Namun demikian, transisi ke siklus "untuk" tradisional memberikan peningkatan kecepatan yang jauh lebih signifikan. <br><br><h2>  4. Gunakan reguler untuk loop </h2><br>  Saran ini mungkin juga tampak kontroversial, karena pengembang menyukai siklus fungsional: mereka dibaca dengan baik dan dapat menyederhanakan pekerjaan.  Namun, mereka kurang efektif daripada siklus tradisional.  Saya pikir Anda mungkin sudah melihat perbedaan dalam penggunaan for loop, tetapi mari kita melihatnya dalam tes terpisah: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://jsperf.com/for-loops-in-few-different-ways/</a> .  Seperti yang Anda lihat, selain mekanisme bawaan, saya juga memeriksa "forEach" dari pustaka "Lodash" dan "masing-masing" dari "jQuery".  Hasil: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1d/06f/e3d/f1d06fe3d1ff046226ff524737538676.png"><br><br>  Dan lagi kita melihat bahwa loop "untuk" yang paling sederhana jauh lebih cepat daripada yang lainnya.  Benar, loop ini hanya baik untuk array - dalam kasus objek iterable lainnya, Anda harus menggunakan "forEach", "untuk ... of" atau iterator itu sendiri.  Tetapi "untuk ... dalam" harus diterapkan hanya jika tidak ada metode lain sama sekali.  Juga, ingat bahwa "untuk ... dalam" menerima semua properti objek (dan dalam array properti adalah indeks), yang dapat menyebabkan hasil yang tidak terduga.  Anehnya, metode dari Lodash dan jQuery tidak terlalu buruk dalam hal kinerja, jadi dalam beberapa kasus Anda dapat menggunakannya dengan aman alih-alih â€œforEachâ€ bawaan (menarik bahwa dalam pengujian loop dari Lodash bekerja lebih cepat daripada built-in). <br><br><h2>  5. Gunakan fungsi bawaan untuk bekerja dengan DOM </h2><br>  Terkadang Anda melihat kode orang lain dan melihat bahwa pengembang mengimpor jQuery hanya untuk memanipulasi DOM - Saya yakin Anda telah melihat ini juga, karena ini adalah salah satu perpustakaan JavaScript paling populer.  Jelas bahwa tidak ada yang salah dengan menggunakan perpustakaan untuk mengontrol DOM: hari ini kami menggunakan React dan Angular, dan mereka melakukan hal yang sama.  Namun, kadang-kadang tampaknya beberapa jQuery harus digunakan bahkan untuk operasi sederhana untuk mengekstrak elemen dari DOM dan membuat perubahan kecil untuk itu. <br><br>  Berikut ini adalah perbandingan dari fungsi bawaan untuk DOM dan operasi JQuery serupa dalam tiga kasus berbeda: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://jsperf.com/native-dom-functions-vs-jquery/1</a> .  Hasil saya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a1f/921/4ed/a1f9214ed02f914a5cf613d90bafb05c.png"><br><br>  Dan lagi, fungsi paling dasar - "getElementById" dan "getElementsByClassName" - ternyata menjadi yang tercepat saat melihat DOM.  Dalam hal pengidentifikasi dan penyeleksi tingkat lanjut, kueriSelektor juga lebih cepat dari jQuery.  Dan hanya dalam satu kasus "querySelectorAll" lebih lambat dari jQuery (mendapatkan elemen dengan nama kelas).  Untuk informasi lebih lanjut tentang cara dan cara mengganti jQuery, lihat di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://youmightnotneedjquery.com</a> . <br><br>  Jelas bahwa jika Anda sudah menggunakan perpustakaan untuk mengelola DOM, sangat disarankan agar Anda tetap menggunakannya - namun, untuk kasus sederhana, alat bawaan sudah cukup. <br><br><h2>  Bahan tambahan </h2><br>  Lima tips ini akan membantu Anda menulis kode JavaScript yang lebih cepat.  Tetapi jika Anda tertarik membaca lebih lanjut tentang pengoptimalan kinerja, berikut adalah beberapa rekomendasi: <br><br>  1. Optimalisasi bundel JavaScript menggunakan Webpack: ini adalah topik yang sangat luas, tetapi jika semuanya dilakukan dengan benar, memuat aplikasi dapat dipercepat secara signifikan. <br><br>  2. Struktur data, algoritma dasar dan kerumitannya: banyak yang percaya bahwa ini "hanya sebuah teori", tetapi pada paragraf pertama kita melihat bagaimana teori ini bekerja dalam praktiknya. <br><br>  3. Tes pada halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsPerf</a> : di sini Anda dapat membiasakan diri dengan perbandingan berbagai cara untuk menyelesaikan tugas yang sama dalam JavaScript dan pada saat yang sama melihat indikator penting dalam praktik - perbedaan dalam kecepatan. <br><br>  <b>Tentang penerjemah</b> <br><br>  Artikel ini diterjemahkan oleh Alconost. <br><br>  Alconost <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melokalkan game</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dan situs</a> dalam 70 bahasa.  Penerjemah asli bahasa, pengujian linguistik, platform cloud dengan API, pelokalan berkelanjutan, manajer proyek 24/7, segala format sumber daya string. <br><br>  Kami juga membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video iklan dan pelatihan</a> - untuk situs yang menjual, gambar, iklan, pelatihan, permainan asah, penjelajah, trailer untuk Google Play dan App Store. <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca lebih lanjut</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456808/">https://habr.com/ru/post/id456808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456792/index.html">Sebarkan Cluster Kubernetes di OpenStack dengan Kubespray</a></li>
<li><a href="../id456794/index.html">Arsitektur Web UI: Masa Lalu dari Kayu, Hadiah yang Aneh, dan Masa Depan yang Cerah</a></li>
<li><a href="../id456796/index.html">Svalbard - nama baru untuk proyek Have I Been Pwned sebelum dijual</a></li>
<li><a href="../id456804/index.html">Ikuti uang: bagaimana grup RTM mulai menyembunyikan alamat server C & C di dompet crypto</a></li>
<li><a href="../id456806/index.html">Satu bot dari semua kekhawatiran</a></li>
<li><a href="../id456810/index.html">Yang pertama. Kisah Bebas Tesla</a></li>
<li><a href="../id456812/index.html">Apa yang ada di ITMO University - festival IT, hackathons, konferensi, dan seminar terbuka</a></li>
<li><a href="../id456814/index.html">Pelajari Pemrograman Fungsional dalam Python dalam 10 Menit</a></li>
<li><a href="../id456818/index.html">Administrator sistem di perusahaan yang tidak dapat didekati. Beban makhluk yang tak tertahankan?</a></li>
<li><a href="../id456820/index.html">Clay â†’ Brick â†’ Kompor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>