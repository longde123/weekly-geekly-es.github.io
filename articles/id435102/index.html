<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊ 🏼 💄 Sedikit tentang analisis leksikal 🍼 👈🏻 👐🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suatu ketika, ketika langit biru, rumput lebih hijau dan dinosaurus menjelajahi bumi ... Tidak, lupakan dinosaurus. Secara umum, suatu ketika muncul i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sedikit tentang analisis leksikal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435102/"><img src="https://habrastorage.org/webt/93/ob/36/93ob36rkepacsoqhbmlu4bj3g0q.png"><br><br>  Suatu ketika, ketika langit biru, rumput lebih hijau dan dinosaurus menjelajahi bumi ... Tidak, lupakan dinosaurus.  Secara umum, suatu ketika muncul ide untuk mengalihkan perhatian dari pemrograman web standar dan melakukan sesuatu yang lebih gila.  Tentu saja bisa menjadi apa saja, tetapi pilihan ada pada menulis juru bahasa Anda sendiri.  Apa yang bisa saya katakan ... <i>Jangan pernah menulis bahasa pemrograman Anda sendiri</i> .  Tetapi saya mengambil beberapa pengalaman dari semua ini, jadi saya memutuskan untuk membagikannya.  Mari kita mulai dengan fondasi - lexer. <br><a name="habracut"></a><br><h2>  Kata Pengantar </h2><br>  Sebelum Anda mulai memahami apa jenis "lexer" binatang itu, ada baiknya mencari tahu apa yang terbuat dari YaPs. <br><br>  Di dunia modern, setiap kompiler / interpreter / transpiler / sesuatu-yang-ada-seperti (mari, saya sebut saja lebih lanjut "kompiler", tanpa perbedaan antar jenis) dibagi menjadi dua bagian.  Dalam terminologi paman yang pandai, bidak seperti itu disebut "frontend" dan "backend".  Tidak, ini sama sekali tidak apa, ketika bekerja dengan web, apa yang biasa kita panggil dan bagian depan tidak ditulis dalam JS dengan HTML.  Meskipun ... Oke. <br><br>  Tugas frontend pertama adalah untuk mengambil <b>teks</b> dan mengubahnya menjadi <b>AST</b> (pohon sintaksis abstrak), memeriksa sintaks (dan kadang-kadang semantik) di jalan.  Tugas backend kedua adalah membuat semuanya berfungsi.  Jika kode tersebut dirakit di dalam interpreter, maka AST membuat satu set instruksi untuk prosesor virtual (mesin virtual), jika kompiler, maka set instruksi untuk prosesor nyata.  Dalam kehidupan, semuanya cukup rumit dan mungkin tidak dapat diimplementasikan dengan cukup seperti itu.  Sebagai contoh, dalam kasus kompiler GCC, semuanya dicampuradukkan, tetapi Dentang sudah lebih kanonik, LLVM adalah perwakilan khas dari "backend" untuk kompiler. <br><br><img src="https://habrastorage.org/webt/un/ai/wa/unaiwa1kmx5jci6uxnhngor5ozs.png"><br><br>  Sekarang mari kita mengenal bagian yang disebut frontend. <br><br><h2>  Analisis leksikal </h2><br>  Tugas lexer dan tahap analisis leksikal adalah untuk mendapatkan banyak, banyak surat di pintu masuk dan mengelompokkannya ke dalam beberapa kategori - "token".  Oleh karena itu, analisis leksikal juga disebut "tokenization".  Ini adalah tahap pertama dari pemrosesan teks yang dihasilkan oleh setiap kompiler yang ada. <br><br>  Sesuatu seperti ini: <br><br><pre><code class="php hljs">$tokens = [<span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>]; var_dump(lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>, $tokens)); <span class="hljs-comment"><span class="hljs-comment">// array(4) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(1) "}" // }</span></span></code> </pre> <br>  Ngomong-ngomong, di sini kita telah menulis banyak alat untuk membuat hidup lebih mudah.  Fungsi <i>preg yang</i> sama yang kami gunakan untuk menguraikan teks cukup <i>mampu untuk</i> tugas ini.  Namun, ada alat yang lebih nyaman untuk masalah ini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Phlexy</a> , ditulis oleh Nikita Popov. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hoa</a> adalah toolkit yang terdiri dari Lexer + Parser + Grammar. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Port Yacc</a> , ditulis oleh Anthony Ferrara, yang juga merupakan toolkit komprehensif, dan di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parser PHP</a> Popov yang terkenal ditulis, dapat diterapkan dalam alat yang menggunakan analisis kode. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Railt Lexer</a> implementasi saya untuk PHP 7.1+ </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Parle</a> adalah ekstensi untuk PHP yang memungkinkan serangkaian ekspresi PCRE terbatas (tanpa lookahead dan beberapa konstruksi sintaks lainnya). </li><li>  Dan akhirnya, fungsi standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">token_get_all</a> php, yang dimaksudkan langsung untuk analisis leksikal PHP. </li></ul><br>  Ya, jelas bahwa ada banyak alat bantu yang dapat membagi teks dengan token, mungkin saya bahkan lupa sesuatu, seperti lexer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Doctrine</a> .  Tapi selanjutnya apa? <br><br><h2>  Jenis-Jenis Lexers </h2><br>  Dan seperti biasa, semuanya tidak sesederhana kelihatannya.  Setidaknya ada dua kategori berbeda dari lexers.  Ada opsi yang biasa, cukup sepele, di mana Anda menyelinap aturan, dan sudah membagi semuanya menjadi token.  Konfigurasi daripadanya tidak jauh berbeda dari contoh yang ditunjukkan oleh saya di atas.  Namun, ada opsi lain yang disebut <b>multistate</b> .  Lexer seperti itu sedikit lebih sulit untuk dipahami, oleh karena itu, saya ingin berbicara lebih banyak tentang mereka. <br><br>  Tugas multistate lexer adalah menampilkan berbagai token tergantung pada kondisi sebelumnya.  Sebagai contoh, dalam PHP, keadaan "transisi" tersebut dibentuk menggunakan tag &lt;? Php +?&gt;, Di dalam baris, komentar, dan konstruksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HEREDOC</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NOWDOC</a> . <br><br>  Ingat contoh sebelumnya dengan 4 token di atas?  Mari kita sedikit memodifikasinya untuk memahami status ini: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// class Example {} }</span></span></code> </pre><br>  Dalam hal ini, jika kita memiliki lexer yang paling sederhana tanpa kapabilitas PCRE yang luas, maka kita mendapatkan set token berikut: <br><br><pre> <code class="php hljs">var_dump(lex(...)); <span class="hljs-comment"><span class="hljs-comment">// array(9) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(2) "//" // [4] =&gt; string(5) "class" // [5] =&gt; string(7) "Example" // [6] =&gt; string(1) "{" // [7] =&gt; string(1) "}" // [8] =&gt; string(1) "}" //}</span></span></code> </pre><br>  Seperti yang dapat Anda lihat, kami mendapatkan kusen dangkal yang sepenuhnya pada elemen 3-5: Komentar diambil secara tak terduga dan dibagi menjadi token, meskipun seharusnya dianggap sebagai keseluruhan. <br><br>  Tentu saja, dengan fungsional PCRE, token semacam itu dapat dihancurkan dengan bantuan keteraturan sederhana " <i>// [^ \ n] * \ n</i> ", tetapi jika tidak?  Atau apakah kita ingin menghancurkannya dengan tangan kita?  Singkatnya, dalam kasus multistate lexer - kita dapat mengatakan bahwa semua token harus berada di grup <b>No1</b> , segera setelah token " <i>//</i> " ditemukan, maka transisi ke grup <b>No2</b> akan terjadi.  Dan di dalam grup kedua, transisi balik, jika token " <i>\ n</i> " ditemukan - transisi kembali ke grup pertama. <br><br>  Sesuatu seperti ini: <br><br><pre> <code class="php hljs">$tokens = [ <span class="hljs-string"><span class="hljs-string">'group-1'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'//'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'group-2'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      2 ], 'group-2' =&gt; [ "\n" =&gt; 'group-1', //    1    '.*' ] ];</span></span></code> </pre><br>  Saya pikir sekarang menjadi lebih jelas bagaimana beberapa HEREDOC diurai, karena bahkan dengan semua kekuatan PCRE, menulis reguler untuk kasus ini sangat bermasalah, mengingat bahwa sintaks HEREDOC ini mendukung interpolasi variabel.  Coba parsing sesuatu seperti ini dengan fungsi <i>token_get_all bawaan</i> (note&gt; 12 token): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $example = <span class="hljs-number"><span class="hljs-number">42</span></span>; $a = &lt;&lt;&lt;EOL Your answer is $example !!! EOL; var_dump(token_get_all(file_get_contents(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>)));</code> </pre><br>  Yah, sepertinya kita siap untuk mulai berlatih. <br><br><h2>  Berlatih </h2><br>  Mari kita ingat apa yang kita miliki di PHP untuk hal-hal seperti itu?  Yah, tentu saja, preg_match!  Oke, turunlah.  Algoritma berbasis preg_match diimplementasikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hoa</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam implementasi Phelxy ini</a> .  Tugasnya cukup sederhana: <br><br><ol><li>  Kami memiliki di tangan teks sumber dan berbagai pelanggan tetap. </li><li>  Kami cocok sampai sesuatu yang cocok ditemukan. </li><li>  Segera setelah Anda menemukan bagian, potong dari teks dan cocokkan lebih lanjut. </li></ol><br>  Dalam bentuk kode, akan terlihat seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">Lembar kode</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[$name] = \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G%s/isSum'</span></span>, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ [$offset, $length] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, \strlen($sources)]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($offset &lt; $length) { [$name, $token] = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;next($sources, $offset); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $token; $offset += \strlen($token); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $offset * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string,string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources, int $offset)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $pcre) { \preg_match($pcre, $sources, $matches, <span class="hljs-number"><span class="hljs-number">0</span></span>, $offset); $token = \reset($matches); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($matches) &amp;&amp; \strpos($sources, $token, $offset) === $offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [$name, $token]; } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \RuntimeException(<span class="hljs-string"><span class="hljs-string">'Unrecognized token at offset '</span></span> . $offset); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Menggunakan lembar kode</b> <div class="spoiler_text"><pre> <code class="php hljs">$lexer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleLexer([ <span class="hljs-string"><span class="hljs-string">'T_CLASS'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_CONST'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_OPEN'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_CLOSE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_WHITESPACE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\s+'</span></span>, ]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'VALUE'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME'</span></span>) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lexer-&gt;lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $token) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'"'</span></span> . \trim($token, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) . <span class="hljs-string"><span class="hljs-string">'"'</span></span>, $name) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre><br></div></div><br>  Pendekatan ini cukup sepele dan memungkinkan beberapa dorongan keyboard untuk memodifikasi lexer di wilayah metode berikutnya (), menambahkan transisi antara negara dan mengubah pembagian masturbasi ini menjadi lexer multistate primitif.  Di area <i>$ this-&gt; token,</i> tambahkan saja sesuatu seperti <i>$ this-&gt; token [$ this-&gt; state]</i> . <br><br>  Namun, di samping primitivisme itu sendiri, ada kelemahan lain, tidak fatal seperti yang mungkin terjadi, tetapi masih ... Implementasi seperti itu sangat lambat.  Pada i7 7600k, pemilik yang kebetulan saya kebetulan - sebuah algoritma yang sama memproses sekitar 400 token per detik, dan dengan peningkatan variasi mereka (yaitu, definisi yang kami sampaikan ke konstruktor) - dapat memperlambat kecepatan perubahan presiden di Rusia ... ahem maaf  Saya ingin mengatakan, tentu saja, bahwa itu akan bekerja <b>sangat lambat</b> . <br><br>  Oke, apa yang bisa kita lakukan?  Sebagai permulaan, Anda dapat memahami apa yang salah.  Faktanya adalah bahwa setiap kali kita memanggil <b>preg_match</b> di dalam belantara bahasa, kompiler dengan JIT yang disebut PCRE naik (Dan dengan PHP 7.3, PCRE2 sudah).  Setiap kali dia mem-parsing pelanggan tetap dan mengumpulkan parser untuk mereka, yang dengannya kita mem-parsing teks untuk membuat token.  Kedengarannya agak aneh dan tautologis.  Namun singkatnya, setiap token memerlukan kompilasi dari 1 ke N tetap, di mana N adalah jumlah definisi token ini.  Pada saat yang sama, perlu dicatat bahwa bahkan bendera " <i>S</i> " yang diterapkan dan pengoptimalan menggunakan " <i>\ G</i> " di konstruktor, di mana ekspresi reguler untuk token dihasilkan, tidak membantu. <br><br>  Hanya ada satu jalan keluar dari situasi ini - Anda harus menguraikan semua teks ini dalam satu pass, yaitu  dengan menjalankan hanya satu fungsi <b>preg_match</b> .  Tetap menyelesaikan dua masalah: <br><br><ol><li>  Bagaimana cara menunjukkan bahwa hasil dari ekspresi reguler N1 sesuai dengan token N2?  Yaitu  cara menunjukkan bahwa " <i>\ w +</i> ", misalnya, adalah <i>T_CONST</i> . </li><li>  Bagaimana menentukan urutan token sebagai hasilnya.  Seperti yang Anda ketahui, hasil <b>preg_match</b> atau <b>preg_match_all</b> akan berisi semua yang tercampur aduk.  Dan bahkan dengan bantuan bendera yang dilewati sebagai argumen keempat, situasinya tidak akan berubah. </li></ol><br>  Di sini Anda dapat berhenti sejenak dan berpikir sedikit.  Baik atau tidak. <br><br>  Solusi untuk masalah pertama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bernama kelompok PCRE</a> , yang juga disebut "submasks."  Dengan menggunakan aturan: " <i>(? &lt;T_WHITESPACE&gt; \ s + | &lt;T_WORD&gt; \ w + | ...)</i> " Anda bisa mendapatkan semua token dalam satu pass dengan membandingkannya dengan namanya.  Sebagai hasil dari pertandingan, array asosiatif akan dibentuk, terdiri dari pasangan " <i>[TOKEN_NAME =&gt; TOKEN_VALUE]</i> ". <br><br>  Yang kedua sedikit lebih rumit.  Tetapi di sini Anda dapat menerapkan trik taktis dan menggunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">preg_replace_callback</a> .  Keunikannya adalah bahwa anonim yang dilewatkan sebagai argumen kedua akan dipanggil secara ketat secara berurutan untuk setiap token, dari yang pertama hingga yang terakhir. <br><br>  Agar tidak merana - implementasinya adalah sebagai berikut: <br><br><div class="spoiler">  <b class="spoiler_title">Tutup kode lain</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PregReplaceLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[] = \sprintf(<span class="hljs-string"><span class="hljs-string">'(?&lt;%s&gt;%s)'</span></span>, $name, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string,string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ $result = []; \preg_replace_callback(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;compilePcre(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $matches)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (\array_reverse($matches) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_string($name) &amp;&amp; $value !== <span class="hljs-string"><span class="hljs-string">''</span></span>) { $result[] = [$name, $value]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }, $sources); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [$name, $value]) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $value; } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compilePcre</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G(?:%s)/isSum'</span></span>, \implode(<span class="hljs-string"><span class="hljs-string">'|'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens)); } }</code> </pre><br></div></div><br>  Dan penggunaannya tidak berbeda dengan versi sebelumnya.  Pada saat yang sama, kecepatan kerja meningkat dari <b>400</b> menjadi <b>57.000</b> token per detik.  Algoritme inilah yang saya terapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam implementasi saya</a> , mengambil penulisan ulang kode sumber Hoa.  Omong-omong, jika Anda menggunakan Parle, Anda dapat memeras hingga <b>600.000</b> token per detik.  Dan gambaran keseluruhan terlihat seperti ini (dengan XDebug dihidupkan di PHP 7.1, sehingga angkanya lebih rendah, tetapi rasionya dapat direpresentasikan secara kasar). <br><br> <a href=""><img src="https://habrastorage.org/webt/rr/yw/qr/rrywqr04hb7lt5zdhdpmu8ppdc8.png"></a> <br><br><ul><li>  Kuning adalah ekstensi asli Parle. </li><li>  Biru - implementasi melalui <i>preg_replace_callback</i> dengan pre-assembled regular. </li><li>  Merah - semuanya sama, tetapi dengan <i>keteraturan yang</i> dihasilkan selama panggilan ke <i>preg_replace_callback</i> . </li><li>  Hijau - implementasi melalui <i>preg_match</i> . </li></ul><br><h2>  Mengapa </h2><br>  Ya, semua ini, tentu saja, luar biasa, tetapi yang tidak sabar ingin sekali mengajukan pertanyaan: "Siapa yang butuh ini?"  Dalam dunia abstrak PHP, di mana prinsip "fig-fig-dan-site-ready" mendominasi - perpustakaan seperti itu tidak diperlukan, kita akan jujur.  Tetapi jika kita berbicara tentang ekosistem secara keseluruhan, maka kita dapat mengingat perpustakaan terkenal seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">symfony / yaml</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Doctrine</a> .  Anotasi dalam Symfony adalah sub-bahasa yang sama di dalam PHP, membutuhkan penguraian leksikal dan sintaksis yang terpisah.  Selain itu, ada transponder CoffeeScript, Less, dan Scss / Sass yang sedikit kurang terkenal yang ditulis dalam PHP.  Nah, atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yay</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">preproses</a> berdasarkan itu.  Saya bahkan tidak akan menyebutkan alat analisis kode seperti phpmd atau phpcs.  Dan generator dokumentasi seperti phpDocumentnor atau Sami cukup sepele.  Masing-masing proyek ini sampai tingkat tertentu menggunakan analisis leksikal pada tahap pertama penguraian teks / kode. <br><br>  Ini bukan daftar proyek yang lengkap dan mungkin saya harap cerita saya akan membantu Anda menemukan sesuatu yang baru dan mengisinya kembali. <br><br><h2>  Kata penutup </h2><br>  Ke depan, jika ada orang yang tertarik dengan topik parser dan kompiler, maka ada beberapa laporan menarik tentang topik ini, khususnya dari orang-orang dari JetBrains: <br><br><div class="spoiler">  <b class="spoiler_title">Video</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/zI1QmnRRBMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  Namun, tentu saja, sebagian besar pertunjukan Andrei Breslav ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">abreslav</a> ), yang dapat ditemukan di YouTube yang luas - saya sarankan Anda untuk menonton. <br><br>  Bagi penggemar fiksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada sumber daya</a> yang secara pribadi sangat berguna bagi saya. <br><br>  Posting tulisan skripum.  Jika Anda berada di suatu tempat yang tersegel dalam luasnya epik ini, maka Anda dapat dengan aman memberi tahu penulis dalam bentuk apa pun yang nyaman bagi Anda. <br><br>  Sebagai bonus, saya ingin memberikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh lexer PHP sederhana</a> , sepertinya tidak begitu menakutkan sekarang, dan sekarang bahkan jelas apa fungsinya, kan?  Meskipun aku menipu, mata berdarah dari pelanggan tetap.  =) <br><br>  Terima kasih </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435102/">https://habr.com/ru/post/id435102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435088/index.html">Raksasa streaming China, Tencent Music, go IPO ke publik - apa artinya dan apa yang diharapkan pesaing</a></li>
<li><a href="../id435090/index.html">Grup motor Hyundai memperkenalkan konsep pengisian nirkabel dan parkir mandiri</a></li>
<li><a href="../id435094/index.html">Gamepad dari Sega Mega Drive dan Raspberry Pi Part 2 (enam tombol terakhir)</a></li>
<li><a href="../id435096/index.html">Efek radio tabung hangat</a></li>
<li><a href="../id435098/index.html">ADB vs Spy Cam & Mic</a></li>
<li><a href="../id435106/index.html">Sekali lagi tentang passport.js</a></li>
<li><a href="../id435108/index.html">Menggunakan Prolog</a></li>
<li><a href="../id435112/index.html">Wawancara Perusahaan</a></li>
<li><a href="../id435114/index.html">Data pegas jpa</a></li>
<li><a href="../id435118/index.html">Save File Me - layanan cadangan gratis dengan enkripsi sisi klien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>