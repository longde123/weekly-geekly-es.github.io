<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎲 🥡 🥚 TelegramBot。 基本功能。 贴纸和图释。 （第3部分） 🙌 ♂️ 👨🏻‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PM中经常出现的问题之一是如何使用笑容（表情符号）和贴纸。 

 如何与他们合作，我使用什么工具，等等。 

 在这一部分中，我们将考虑以下方面：如何创建带有标签的消息，如何处理带有标签的接收消息，如何在消息文本中查找所有表情符号（表情符号），如何使用表情符号创建消息。 

 谁在乎，请在猫下。 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TelegramBot。 基本功能。 贴纸和图释。 （第3部分）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482260/"> PM中经常出现的问题之一是如何使用笑容（表情符号）和贴纸。 <br><br> 如何与他们合作，我使用什么工具，等等。 <br><br> 在这一部分中，我们将考虑以下方面：如何创建带有标签的消息，如何处理带有标签的接收消息，如何在消息文本中查找所有表情符号（表情符号），如何使用表情符号创建消息。 <br><br> 谁在乎，请在猫下。 <br><a name="habracut"></a><br> 按照传统，我们从文章的来源链接开始：) <br><br> 本文讨论的所有代码都在<a href="https://github.com/dp-ua/TelegramBotBase/tree/Part3-Stick_and_Emoji">Part3-Stick_and_Emoji分支中进行</a>编译。 <br><br><h3> 贴图 </h3><br> 电报一出现，我非常喜欢的一件事就是贴纸。 他们很酷，舒适，免费。 我们自然希望在机器人中使用所有这些种类繁多的贴纸。 实际上，此过程非常简单。 要将标签发送给用户，我们只需要知道标签的ID即可。 <br> 通常对于贴纸，我会创建自己的助手类，在其中存储有关机器人中使用的贴纸的数据： <br><br>  <a href="">Stickers.java</a> <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.methods.send.SendSticker; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Stickers { FUNNY_JIM_CARREY(<span class="hljs-string"><span class="hljs-string">"CAADBQADiQMAAukKyAPZH7wCI2BwFxYE"</span></span>), ; String stickerId; Stickers(String stickerId) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stickerId = stickerId; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SendSticker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSendSticker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>.equals(chatId)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"ChatId cant be null"</span></span>); SendSticker sendSticker = getSendSticker(); sendSticker.setChatId(chatId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sendSticker; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SendSticker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSendSticker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SendSticker sendSticker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SendSticker(); sendSticker.setSticker(stickerId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sendSticker; } }</code> </pre> <br> 这里的一切都很简单。 我们给标签贴一个我们可以理解的名称。 通过两种方法，我们获得了一个现成的对象，可以发送给用户。 <br><br> 为了回答这个问题：“我在哪里可以得到贴纸ID？”，让我们写一个助手给我们，该助手将在我们的机器人中向我们提供这些数据。 <br><br> 我们具有在此处创建的基本功能： <br>  <a href="https://habr.com/ru/post/481354/">TelegramBot。</a>  <a href="https://habr.com/ru/post/481354/">基本功能。</a>  <a href="https://habr.com/ru/post/481354/">（第二部分）</a> <br> 为了使我们的机器人开始以某种方式处理可接受的标签，我们需要： <br><br><ul><li> 确定他们给我们寄了一张贴纸 </li><li> 指出哪个处理程序负责处理带有贴纸的消息 </li><li> 运行一个处理程序，该处理程序将生成一条响应消息给用户 </li></ul><br>  <b>任务</b> ：机器人在聊天中收到贴纸时，应发送带有贴纸ID的文本消息作为响应。 <br><br> 我们将<a href="">STICKER</a>命令添加到命令列表中 <br><br> 在发送的更新的分析器中，我们将尝试确定是否有文本消息或其中是否包含标签： <br><br>  <a href="">MessageReciever.java第57行</a> <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message.hasText()) { parsedCommand = parser.getParsedCommand(message.getText()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Sticker sticker = message.getSticker(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sticker != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { parsedCommand = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParsedCommand(Command.STICKER, sticker.getFileId()); } }</code> </pre> <br> 因为 我们不需要对发送的消息进行复杂的处理，那么我们将把包含标签的消息的处理委托给负责处理所谓的“系统消息”的现有处理程序： <br>  <a href="">MessageReciever.java第86行</a> <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> START: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HELP: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> STICKER: SystemHandler systemHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemHandler(bot); log.info(<span class="hljs-string"><span class="hljs-string">"Handler for command["</span></span> + command.toString() + <span class="hljs-string"><span class="hljs-string">"] is: "</span></span> + systemHandler); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> systemHandler;</code> </pre> <br> 因此，在<b>SystemHandler中，</b>我们需要指定如何处理收到的<b>STICKER</b>命令： <br>  <a href="">SystemHandler.java第31行</a> <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> STICKER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"StickerID: "</span></span> + parsedCommand.getText();</code> </pre> <br> 结果，当向我们的机器人发送任何标签时，我们将收到其ID作为响应： <br><br><img src="https://habrastorage.org/webt/3i/56/dy/3i56dyf1gkch2j-xgy9o-gjk8si.png"><br><br><h3> 表情符号或表情符号 </h3><br> 它们是标准化的，几乎所有设备和操作系统都可以理解并能够显示它们。 使用它们装饰消息非常方便。 它们简洁地显示在消息下方的按钮上。 喜不喜欢-一些优点。 <br><br> 例如，在<a href="https://t.me/EventCheckPlanner_Bot">事件调度程序中</a> <br><br><img src="https://habrastorage.org/webt/r3/bq/bd/r3bqbdspnrch4-qy28vppzwxiks.png"><br><br> 使用按钮上和消息文本中的相同图标，可以使用户直观地理解您的界面，使消息和按钮上的多余文本变得混乱。 <br><br> 要在消息或按钮上显示表情符号，您需要知道其Unicode。  Internet上有很多资源，您可以在其中找到所有列出的表情符号，并在其中指示其标签，代码。 <br> 对于我自己，我选择了这种使用表情符号的方式：在电报本身中观看和选择表情符号更加方便。 <br><br> 好吧，当然，通过贴标的类比，让我们为自己写一个小帮手，他们将向我们展示必要的代码，甚至可以确保我们正确地处理它们。 <br><br> 首先，将以下依赖项添加到<a href="">pom.xml</a> ： <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>com.vdurmont<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>emoji-java<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>3.3.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 老实说，我不记得我遇到了什么地方，但是从那以后，我只在需要对机器人中的表情符号进行处理时才使用它。 <br><br> 该库包含许多不同的工具： <br><br><img src="https://habrastorage.org/webt/ri/4e/qm/ri4eqmdo2uiyrnwoxck1trfklim.png"><br><br> 好奇和好奇将在哪里转身:) <br><br> 使用漫游器发送表情符号需要什么？ 您需要在Unicode消息的文本中嵌入所需的表情符号。 <br><br> 是的，您可以找到提供带有表情符号的Unicode列表，显示表情符号在不同智能手机上外观的不同摘要表的资源。 <br><br> 我想向您展示一种最有效的微笑方式。 <br><br> 首先，让我们看看如何在电报本身中使用微笑。 您可以打开一个对话框，其中列出了所有表情并将其添加到消息中，只需单击它们的图标即可。 表情符号也可以使用标签添加到邮件中。 <br><br> 标签应该用冒号括起来，并包含某种独特的文本，指示所需的笑脸。 <br><br> 如果您在输入消息的字段中开始输入以冒号开头的消息，则电报本身将开始显示哪些表情符号包含输入的标签文本： <br><br><img src="https://habrastorage.org/webt/hr/s4/1o/hrs41orsvl1k4mkpt7mxlja-bnm.png"><br><br> 当您输入正确的表情符号标签并放入另一个冒号时，文本将变成笑脸。 如果在图释上按住鼠标左键，也会显示标签。 <br><br><img src="https://habrastorage.org/webt/t-/ib/ya/t-ibya9mw4829qau8wnz9h8uxwq.png"><br><br> 现在，图书馆为我们提供了帮助，我们在上面添加了对图书馆的依赖。 她知道如何使用表情符号标签。 这主要是为您提供方便，因为标签更具可读性，它们带有某种含义。 <br><br> 我们知道了标签之后，便可以得到Unicode表情符号，如下所示： <br><br><pre> <code class="java hljs">String emoji_kissing = EmojiParser.parseToUnicode(<span class="hljs-string"><span class="hljs-string">":kissing:"</span></span>);</code> </pre> <br> 您可以将自己设置为一个单独的类，在其中可以保留在bot中使用的表情符号。 以同一个<a href="https://t.me/EventCheckPlanner_Bot">活动策划者</a>为例，他的武器库中充满了这些微笑： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.vdurmont.emoji.EmojiParser; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Icon { PLUS(<span class="hljs-string"><span class="hljs-string">":heavy_plus_sign:"</span></span>), MINUS(<span class="hljs-string"><span class="hljs-string">":heavy_minus_sign:"</span></span>), CHECK(<span class="hljs-string"><span class="hljs-string">":white_check_mark:"</span></span>), NOT(<span class="hljs-string"><span class="hljs-string">":x:"</span></span>), DOUBT(<span class="hljs-string"><span class="hljs-string">":zzz:"</span></span>), FLAG(<span class="hljs-string"><span class="hljs-string">":checkered_flag:"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EmojiParser.parseToUnicode(value); } Icon(String value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } }</code> </pre> <br> 这就是使用此类和特定表情符号后代码的外观： <br><br><pre> <code class="java hljs"> row.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InlineKeyboardButton() .setText(Icon.CHECK.get() + <span class="hljs-string"><span class="hljs-string">" I'm going"</span></span>)</code> </pre> <br> 这是此按钮的代码： <br><br><img src="https://habrastorage.org/webt/bc/lw/ou/bclwou1ukoe0nosc7iyfnqw6zki.png"><br><br> 我注意到这个图书馆的一个细微差别。 库无法识别电报中的所有表情符号。 因此，请注意该库的新版本。 <br><br> 好吧，为了确切地确定我们可以显示哪些微笑，而不能显示哪些微笑，我们会将这项任务委托给我们的助手。 <br><br>  <b>任务：</b>如果发送的消息不包含任何特定命令，但在文本中包含微笑，请在屏幕上以向用户发送消息的形式显示这些微笑，并指示其属性（标签和描述）。 <br><br> 将命令<b>TEXT_CONTAIN_EMOJI</b>添加到命令列表中 <br>  <a href="">Command.java第8行</a> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Command { ... TEXT_CONTAIN_EMOJI, ... }</code> </pre> <br> 在确定消息中包含哪种命令的解析器中，添加以下文本： <br><br>  <a href="">Parser.java第38行</a> <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.getCommand() == Command.NONE) { List&lt;String&gt; emojiContainsInText = EmojiParser.extractEmojis(result.getText()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emojiContainsInText.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) result.setCommand(Command.TEXT_CONTAIN_EMOJI); }</code> </pre> <br> 如果确定该消息不包含任何特定命令，但其中包含表情符号，则返回我们已解析TEXT_CONTAIN_EMOJI命令。 <br><br> 创建一个单独的处理程序，该处理程序仅处理以下命令： <br>  <a href="">EmojiHandler.java</a> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.bot.Bot; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.telegrambot.command.ParsedCommand; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.vdurmont.emoji.Emoji; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.vdurmont.emoji.EmojiManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.vdurmont.emoji.EmojiParser; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.log4j.Logger; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.telegram.telegrambots.api.objects.Update; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.HashSet; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Set; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmojiHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = Logger.getLogger(EmojiHandler.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmojiHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bot bot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(bot); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chatId, ParsedCommand parsedCommand, Update update)</span></span></span><span class="hljs-function"> </span></span>{ String text = parsedCommand.getText(); StringBuilder result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); Set&lt;String&gt; emojisInTextUnique = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(EmojiParser.extractEmojis(text)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emojisInTextUnique.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) result.append(<span class="hljs-string"><span class="hljs-string">"Parsed emojies from message:"</span></span>).append(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String emojiUnicode : emojisInTextUnique) { Emoji byUnicode = EmojiManager.getByUnicode(emojiUnicode); log.debug(byUnicode.toString()); String emoji = byUnicode.getUnicode() + <span class="hljs-string"><span class="hljs-string">" "</span></span> + byUnicode.getAliases() + <span class="hljs-string"><span class="hljs-string">" "</span></span> + byUnicode.getDescription(); result.append(emoji).append(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.toString(); } }</code> </pre> <br> 此代码仅从消息文本中选择图释，形成具有唯一图释的集合，从其属性中选择标签和说明，并由此生成文本消息。 <br><br> 工作的结果如下所示： <br><br><img src="https://habrastorage.org/webt/ia/wy/sx/iawysxkxh3utfud9znjifqrgosm.png"><br><br> 在方括号中，我们获得了可用于插入图释的标签。 您会看到有时一个标签中有多个标签。 <br><br> 而且，在此助手的帮助下，我们可以准确地了解我们的库可以理解哪些表情符号，而忽略哪些表情符号。 <br><br> 例如，您可以在这里看到： <br><br><img src="https://habrastorage.org/webt/bz/f9/5i/bzf95i9alj3uqweuzdxfqg9ost0.png"><br><br> 使用以下代码微笑<i>：face_with_monocle：</i>由于某些原因，此库未检测到它。 <br><br> 因此，我们有一个处理程序。 我们如何将任务交给他？ <br><br> 因为 我们已经知道将带有表情符号的文本消息检测为TEXT_CONTAIN_EMOJI命令-在MessageReciever中，我们需要指出一个单独的EmojiHandler处理程序负责处理此命令。 <br><br>  <a href="">MessageReciever.java第94行</a> <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TEXT_CONTAIN_EMOJI: EmojiHandler emojiHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmojiHandler(bot); log.info(<span class="hljs-string"><span class="hljs-string">"Handler for command["</span></span> + command.toString() + <span class="hljs-string"><span class="hljs-string">"] is: "</span></span> + emojiHandler); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> emojiHandler;</code> </pre> <br> 程序愉快，不要犹豫，提出问题:) <br><br> 聚苯乙烯 <br> 您可以在这里感觉到具有此功能的机器人： <a href="https://t.me/test_habr_bot">https</a> : <a href="https://t.me/test_habr_bot">//t.me/test_habr_bot</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN482260/">https://habr.com/ru/post/zh-CN482260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN482250/index.html">一个简单的VueJS状态机</a></li>
<li><a href="../zh-CN482252/index.html">自动猫厕所-续</a></li>
<li><a href="../zh-CN482254/index.html">VonmoTrade实验。 第3部分：认股权书。 处理和存储贸易信息</a></li>
<li><a href="../zh-CN482256/index.html">人工智能和工作的未来：不久的将来的就业前景</a></li>
<li><a href="../zh-CN482258/index.html">神经网络如何工作以及为什么它们开始带来巨额资金</a></li>
<li><a href="../zh-CN482262/index.html">如何登录Talend Open Studio</a></li>
<li><a href="../zh-CN482264/index.html">巴西，黑魔法，真人快打，火星和15,000人。 Ontiko年业绩</a></li>
<li><a href="../zh-CN482268/index.html">未来的巨型结构：戴森球，恒星引擎和“黑洞炸弹”</a></li>
<li><a href="../zh-CN482270/index.html">虚拟现实及其周围的WebRTC流</a></li>
<li><a href="../zh-CN482272/index.html">为普罗米修斯选择数据仓库：Thanos vs VictoriaMetrics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>