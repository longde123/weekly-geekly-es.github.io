<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚊 📥 🙍🏿 Bug saat bekerja dengan keyboard sistem 🔁 🕉️ 👆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Berinteraksi dengan aplikasi, kami pada suatu titik mengaktifkan keyboard sistem untuk mengetik pesan atau mengisi kolom yang diperlukan. Pernahkah An...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bug saat bekerja dengan keyboard sistem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462515/">  <em>Berinteraksi dengan aplikasi, kami pada suatu titik mengaktifkan keyboard sistem untuk mengetik pesan atau mengisi kolom yang diperlukan.</em>  <em>Pernahkah Anda mengalami situasi ketika keyboard ditampilkan, tetapi tidak ada bidang untuk memasukkan pesan, atau sebaliknya - ada keyboard, di mana memasukkan teks, tidak terlihat?</em>  <em>Bug dapat dikaitkan dengan masalah dalam aplikasi tertentu, serta kekurangan umum pada keyboard sistem.</em> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Konstantin Mordan</em></a> <em>, pengembang iOS dari Mail.ru, melihat semuanya dalam karyanya: setelah menganalisis metode kontrol keyboard di iOS, ia memutuskan untuk berbagi bug utama dan pendekatan yang ia gunakan untuk mendeteksi dan memperbaikinya.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/wc/xg/fbwcxgdtopdtlj8_u7rkj1vnmne.jpeg" width="400"></div><br><br>  <i>Perhatian: di bawah potongan, kami menempatkan banyak gif untuk menunjukkan bug dengan jelas.</i>  <i>Anda akan menemukan lebih banyak contoh dalam laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> Konstantin di AppsConf.</i> <br><a name="habracut"></a><br><h1>  Menerapkan panggilan keyboard sistem </h1><br>  Mari kita mulai dengan memahami cara menerapkan panggilan keyboard secara umum. <br><br>  Bayangkan Anda sedang mengembangkan aplikasi yang tugasnya merakit Aika (karakter South Park) ke dalam seluruh Kanada menggunakan keyboard.  Ketika Aiku ditekan di perut, keyboard itu pergi, sehingga mengangkat kaki pahlawan kita ke kepala. <br><br>  Untuk mengimplementasikan tugas, Anda dapat menggunakan <i>InputAccessoryView</i> atau memproses pemberitahuan sistem. <br><br><h2>  InputAccessoryView </h2><br>  Mari kita lihat opsi pertama. <br><br>  Di ViewController, buat Tampilan yang akan naik bersama dengan keyboard, dan berikan bingkai.  Penting bahwa Tampilan ini tidak boleh ditambahkan sebagai subview.  Selanjutnya, kita menimpa properti <em>canBecomeFirstResponder</em> dan mengembalikan true.  Setelah kita mendefinisikan ulang properti <em>UIResponder</em> - <em>inputAccessoryView</em> dan meletakkan tampilan di sana.  Untuk menutup keyboard, tambahkan <em>tapGesture</em> dan di handlernya, <em>setel ulang responden pertama</em> , yang kami buat Lihat. <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tummyView: <span class="hljs-type"><span class="hljs-type">UIView</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frame = <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(x: x, y: y, width: width, height: height) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v = <span class="hljs-type"><span class="hljs-type">TummyView</span></span>(frame: frame) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canBecomeFirstResponder: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input <span class="hljs-type"><span class="hljs-type">AccessoryView</span></span>: <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tummyView } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tapHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { tummyView.resignFirstResponder ( ) } }</code> </pre> <br>  Tugas selesai, dan sistem itu sendiri memproses perubahan kondisi keyboard, menampilkannya dan memunculkan View, yang bergantung padanya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ew/mu/nd/ewmundnnrpbdgjgwvk_frx4qv6o.gif" width="200"></div><br><br><h2>  Pemrosesan Pemberitahuan Sistem </h2><br>  Dalam hal memproses pemberitahuan, kami harus memproses sendiri pemberitahuan dari grup berikut: <br><br><ul><li>  ketika keyboard akan / ditampilkan: keyboardWillShowNotification, keyboardDidShowNotification; </li><li>  ketika keyboard akan / disembunyikan: keyboardWillHideNotification, keyboardDidHideNotification; </li><li>  ketika bingkai keyboard akan / diubah: keyboardWilChangeFrameNotification, keyboardDidChangeFrameNotification. </li></ul><br>  Untuk menerapkan kasus kami, mari gunakan <em>keyboardWilChangeFrameNotification</em> , karena notifikasi ini dikirim baik saat keyboard ditampilkan dan ketika disembunyikan. <br><br>  Kami membuat <em>keyboardTracker,</em> di dalamnya kami berlangganan untuk menerima notifikasi <em>keyboardWillChangeFrame</em> , dan di handler kami mendapatkan bingkai keyboard, mengonversinya dari sistem koordinat layar ke sistem koordinat jendela, menghitung tinggi keyboard dan mengubah nilai Y dari Tampilan, yang harus dinaikkan oleh keyboard, ke ketinggian ini. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { notificationCenter.add0observer(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, seletor: #selector( keyboardWillChangeFrame), name: <span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardWillChangeFrameNotification, object: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenCoordinatedKeyboardFrame = (userInfo [ <span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardFrameEndUserInfoKey ] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSValue</span></span> ) .cgRectValue <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windowHeight = window.frame.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardHeight = windowHeight - keyboardFrame.minY delegate.keyboardWillChange ( keyboardHeight ) } }</code> </pre> <br>  Tentang ini, tugas kita selesai, keyboard naik, mengumpulkan Ike ke Kanada. <br><br>  Seperti yang bisa kita lihat, implementasi bekerja dengan keyboard cukup mudah di kedua kasus, sehingga semua orang bebas memilih metode yang sesuai sendiri.  Dalam proyek kami, kami membuat pilihan yang mendukung pemberitahuan, jadi contoh dan wawasan lebih lanjut akan dikaitkan dengan pemrosesan pemberitahuan. <br><br><h2>  Mencari bug </h2><br>  Jika cara memanggil keyboard sangat sederhana, lalu dari mana datangnya bug?  Tentu saja, jika aplikasi hanya mereproduksi skrip untuk membuka dan menutup keyboard, maka tidak akan ada masalah.  Tetapi jika Anda mengubah hal-hal yang biasa, ingatlah bahwa tidak hanya aplikasi kita dapat menggunakan keyboard, tetapi juga yang lain, dan pengguna juga dapat beralih di antara mereka, maka kejutan tidak dapat dihindari. <br><br>  Mari kita lihat sebuah contoh.  Untuk melakukan ini, gunakan aplikasi kami dengan Ike: buka keyboard, beralih ke Notes, cetak sesuatu dan kembali ke aplikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br><br>  Masalah apa yang sudah terlihat?  Pertama, tidak ada keyboard di App Switcher, meskipun ketika Anda meminimalkan aplikasi itu, dan bukannya itu, konten lain terlihat.  Kedua, ketika Anda kembali ke aplikasi, keyboard masih tidak ada, dan kaki Ike jatuh ke bawah layar. <br><br>  Mari kita lihat alasan perilaku ini.  Seperti yang kita semua ingat dari diagram siklus aplikasi, transisi aplikasi dari keadaan aktif ke keadaan tidak aktif pertama di latar depan dan kemudian di latar belakang membutuhkan waktu. <br><br>  Bagaimana dengan siklus hidup keyboard?  Di iOS, untuk setiap unit waktu, keyboard hanya dapat dimiliki oleh salah satu aplikasi yang sedang berjalan, tetapi pemberitahuan tentang perubahan status keyboard diterima oleh semua aplikasi yang menandatanganinya. <br><br>  Saat beralih dari satu aplikasi ke aplikasi lainnya, sistem akan mereset firstRespondernya, yang bertindak sebagai pemicu untuk menyembunyikan keyboard.  Sistem mengirimkan notifikasi keyboardWillHide pertama untuk keyboard menghilang dan kemudian keyboardDidHideNotification.  Pemberitahuan terbang ke aplikasi kedua.  Dalam aplikasi baru, kami membuka keyboard: sistem mengirimkan keyboardWillShowNotification untuk keyboard muncul dan kemudian mengirimkan keyboardDidShowNotification - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo</a> , dengan fase siklus. <br><br><img src="https://habrastorage.org/webt/gk/th/5c/gkth5chvrkyewmvhdrpc7eito9q.jpeg"><br><br>  Jika Anda melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fragmen laporan</a> (dari 8:39), Anda akan melihat saat ketika, setelah menyembunyikan keyboard, sistem mengirimkan keyboardDidHideNotification untuk meletakkan aplikasi pertama dalam keadaan tidak aktif.  Ketika Anda beralih ke aplikasi olahraga dan meluncurkan keyboard, sistem mengirimkan keyboardWillShowNotification.  Tetapi karena proses peralihan dan mulai cepat, dan waktu transisi antara fase siklus hidup dapat lebih lama, pemberitahuan yang diterima tidak hanya akan memproses aplikasi untuk olahraga, tetapi juga aplikasi untuk bir, yang belum berhasil beralih ke latar belakang. <br><br>  Setelah mengetahui alasannya, sekarang mari kita mencari solusi untuk masalah dengan Ike. <br><br><h3>  Keputusan yang buruk </h3><br>  Hal pertama yang terlintas dalam pikiran adalah ide berhenti berlangganan / berlangganan pemberitahuan ketika meminimalkan / memaksimalkan aplikasi melalui mengaktifkan / menonaktifkan KeyboardTracker. <br><br>  Untuk berhenti berlangganan, kami menggunakan metode applicationWillResignActive atau penangan notifikasi serupa dari sistem; untuk berlangganan, kami menggunakan applicationDidBecomeActive, tetapi agar tidak ketinggalan apa pun, kami juga akan memberi tahu metode applicationWillEnterForeground, yang dipanggil saat aplikasi masuk sebagai foreground tetapi belum menjadi aktif. <br><br>  Ketika Anda memulai keyboard di aplikasi, kemungkinan besar semuanya akan berhasil, tetapi dengan tes yang lebih kompleks, misalnya, membuka keyboard dan mencoba merekam panggilan melalui suara, solusinya tidak akan berfungsi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dy/0b/_e/dy0b_eiomhqtkuqimnsdew_es-c.gif" width="200"></div><br><br>  Apa yang terjadi  Setelah mengklik tombol panggilan pesan suara, aplikasi firstResponder aplikasi direset, keyboard ditutup, metode applicationWillResignActive dipanggil dan kami berhenti berlangganan.  Setelah menutup peringatan, sistem memulihkan keadaan aplikasi, tetapi sebelum metode applicationWillEnterForeground, dan terutama applicationDidBecomeActive, dipanggil. <br><br><h3>  Keputusan bagus </h3><br>  Solusi lain adalah penggunaan kaldu pelindung (Bool). <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wasTummyViewFirstResponderBeforeApp0idEnterBackground <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willResignActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { wasTextFieldFirstResponderBeforeAppDidEnterBackground = tummyView.isFirstResponder } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willEnterForeground</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> wasTextFieldFirstResponderBeforeAppDidEnterBackground { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.performWithourAnimation { tummyView.becomeFirstResponder ( ) } } }</code> </pre> <br>  Kami ingat apakah keyboard dibuka sebelum topik, bagaimana aplikasi berhenti aktif, dan dalam metode applicationWillEnterForeground kami mengembalikan keadaan sebelumnya.  Satu-satunya hal yang tersisa untuk diperbaiki adalah lubang di pengalih aplikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jc/sl/oc/jcsloczny6akuricp8x0bzwvbxo.jpeg" width="400"></div><br><br><h2>  pengalih aplikasi </h2><br>  Pengalih aplikasi menampilkan snapshot aplikasi yang dilakukan sistem setelah aplikasi masuk ke latar belakang.  Tangkapan layar menunjukkan bahwa snapshot aplikasi kita dibuat pada saat keyboard sudah digunakan oleh aplikasi lain.  Ini tidak kritis, tetapi hanya perlu beberapa klik untuk memperbaikinya. <br><br><h3>  Solusi yang bagus </h3><br>  Solusinya dapat dipinjam dari aplikasi perbankan yang telah belajar menyembunyikan data sensitif, dan juga membaca dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apple</a> . <br><br>  Anda dapat menyembunyikan data dalam metode applicationDidEnterBackground, mengaburkan dan menampilkan layar splash, dan dalam metode applicationWillEnterForeground kembali ke hierarki tampilan yang biasa. <br><br>  Opsi ini tidak sesuai dengan kita, karena pada saat metode applicationDidEnterBackground dipanggil, aplikasi kita tidak lagi memiliki keyboard. <br><br><h3>  Keputusan bagus </h3><br>  Kami akan menggunakan metode familiar willResignActive, willEnterForeground dan didBecomeActive. <br><br>  Meskipun aplikasi kami masih memiliki keyboard, Anda harus membuat snapshot aplikasi Anda sendiri dalam metode willResignActive dan memasukkannya ke dalam hierarki. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willResignActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notificaton: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyWindow = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.keyWindow imageView = <span class="hljs-type"><span class="hljs-type">UIImageView</span></span>( frame: keyWindow.bounds) imageView.image = snapshot ( ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastSubview = keyWindow.subviews.last lastSubview( imageView) }</code> </pre> <br>  Di metode willEnterForeground dan didBecomeActive, kami mengembalikan hierarki tampilan dan menghapus snapshot kami. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willEnterForeground</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { imageView.removeFromSuperview( ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didBecomeActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { imageView.removeFromSuperview( ) }</code> </pre> <br>  Hasilnya, kami memperbaiki kedua kasus: di pengalih aplikasi, gambar yang indah dan keyboard tidak lagi melompat ketika beralih.  Tampaknya ini bukan hal yang penting, tetapi untuk pengembangan produk, poin-poin ini sangat penting. <br><br><h2>  Berita buruk </h2><br>  Solusi sukses kami untuk masalah Ike terkait dengan kasus ketika keyboard dibuka sebelum meminimalkan aplikasi.  Jika peralihan terjadi tanpa memperluas keyboard, sekali lagi kita akan melihat bahwa kaki Ike kita jatuh di bawah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br><br>  Ini bukan hanya masalah bagi aplikasi kita, perilaku ini juga diamati untuk Facebook, yang berfungsi dengan notifikasi, dan bahkan untuk iMessage, yang menggunakan inputAccessoryView untuk mengontrol keyboard.  Hal ini disebabkan oleh fakta bahwa sebelum beralih ke latar belakang, aplikasi mengatur untuk memproses notifikasi keyboard orang lain. <br><br><h2>  pemberhentian keyboard secara interaktif </h2><br>  Tambahkan beberapa fungsi ke aplikasi kita dengan Ike, ajarkan program untuk menyembunyikan keyboard secara interaktif. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/cy/1g/g6cy1gparlfmqc0abfaz7rd_rr0.gif" width="200"></div><br><br><h3>  Keputusan yang buruk </h3><br>  Salah satu cara untuk membuat fungsi ini adalah mengubah bingkai tampilan keyboard.  Kami membuat panGestureRecognizer, dalam penangannya kami menghitung nilai baru koordinat Y untuk keyboard, tergantung pada posisi jari kami, menemukan tampilan keyboard dan memperbaruinya dengan nilai koordinat Y. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panGestureHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> yPosition: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = value keyboardView( )?.frame.origin.y = yPosition }</code> </pre> <br>  Keyboard ditampilkan di jendela terpisah, jadi Anda perlu memeriksa seluruh array windows di aplikasi, memeriksa setiap elemen array apakah itu jendela keyboard dan, jika demikian, dapatkan tampilan dari itu yang menunjukkan keyboard. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windows = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = windows.first { (window) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyboardView( fromWindow: window) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view }</code> </pre> <br>  Sayangnya, solusi ini tidak akan berfungsi secara normal pada iPhone X dan lebih tinggi, karena ketika Anda menggerakkan jari Anda, Anda dapat sedikit menyentuh indikator yang lebih rendah, yang bertanggung jawab untuk meminimalkan aplikasi.  Setelah itu, persembunyian interaktif berhenti bekerja. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eg/-o/iv/eg-oiv8yrssufcejelvxqj4ksrq.gif" width="200"></div><br><br>  Masalahnya terletak pada array windows. <br><br><img src="https://habrastorage.org/webt/vc/u6/9o/vcu69oekot0zgl31iikyy_0refo.jpeg" width="600"><br><br>  Setelah gerakan, sistem membuat jendela keyboard baru di atas yang sudah ada.  Itu tidak terpikirkan, tetapi benar.  Akibatnya, ternyata array berisi dua jendela keyboard dengan koordinat yang sama, tetapi yang pertama disembunyikan. <br><br><img src="https://habrastorage.org/webt/pp/0v/ha/pp0vhay6ionyekifnsg-9jvnpzg.jpeg"><br><br>  Ternyata, dengan mengulangi susunan jendela, kami menemukan yang pertama yang memenuhi persyaratan, dan mulai bekerja dengannya, meskipun fakta bahwa itu tersembunyi. <br><br>  Bagaimana ini diperbaiki?  Mengubah array windows. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panGeastureHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> yPosition: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">0.0</span></span> keyboardView( )?.frame.origin.y = yPosition } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windows = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows.reversed( ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = windows.first { (window) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyboardView( fromWindow: window) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view }</code> </pre> <br><h2>  Fitur Keyboard di iPad </h2><br>  Keyboard di iPad, di samping kondisi biasa, memiliki status tidak terkunci.  Pengguna dapat memindahkannya di sekitar layar, membaginya menjadi dua bagian dan bahkan meluncurkan aplikasi dalam mode slide over (di atas yang lain).  Tentu saja, penting bahwa dalam semua mode ini keyboard bekerja tanpa bug. <br><br>  Mari kita periksa Hayke kita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y1/4x/l5/y14xl5geuyxmkubopbkabplwbz4.gif"></div><br><br>  Sayangnya, ini bukan masalahnya sekarang.  Setelah pengguna mulai menggerakkan keyboard di sekitar layar, kaki Ike terbang di atas kepalanya dan muncul di tempatnya hanya setelah pembukaan keyboard berikutnya.  Mari kita coba memperbaikinya pada kasing dengan keyboard terpisah. <br><br><h3>  Alasan </h3><br>  Mari kita mulai dengan menganalisis notifikasi.  Setelah mengklik tombol split, kami mendapat dua grup pemberitahuan - keyboardWillChangeFrameNotification, keyboardWillHideNotification, keyboardDidChangeFrameNotification, keyboardDidHideNotification.  Perbedaan antar grup hanya ada pada koordinat keyboard. <br><br>  Ketika kami mengklik tombol split, keyboard berkurang dan grup pemberitahuan pertama tiba.  Saat keyboard terbelah dan naik - kami mendapat paket pemberitahuan kedua. <br><br>  Yang penting adalah kami menerima notifikasi bahwa keyboard telah menghilang, tetapi tidak ada yang ditampilkan.  Omong-omong, ini merupakan nilai tambah lain dalam penggunaan keyboardWillChangeFrameNotification. <br><br>  Lalu, mengapa kaki Ike terbang begitu kita mulai menggerakkan keyboard di sekitar layar? <br><br>  Pada saat ini, sistem mengirimi kami keyboardWillChangeFrameNotification, tetapi koordinat yang ada (0,0, 0,0, 0,0, 0,0), karena sistem tidak tahu pada titik mana keyboard akan setelah gerakan selesai. <br><br>  Jika kita mengganti nol dalam kode saat ini yang memproses perubahan bingkai keyboard, ternyata ketinggian keyboard sama dengan ketinggian jendela.  Itulah alasan mengapa kaki Ike terbang dari layar. <br><br><h3>  Keputusan bagus </h3><br>  Untuk mengatasi masalah kami, pertama-tama kita akan belajar untuk memahami kapan keyboard dalam mode tidak terkunci dan pengguna dapat memindahkannya di sekitar layar. <br><br>  Untuk melakukan ini, bandingkan saja ketinggian jendela dan keyboard maksimal.  Jika mereka sama, maka keyboard dalam keadaan normal, jika maxY kurang dari ketinggian jendela, maka pengguna memindahkan keyboard.  Akibatnya, kode berikut ini muncul di keyboardTracker: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { notificationCenter.addObserver( <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector:#selector( keyboardWillChangeFrame), name:<span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardWillChangeFrameNotification, object:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenCoordinatedKeyboardFrame = (userInfo[<span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardFrameEndUserInfoKey] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSValue</span></span>).cgRectValue <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windowHeight = window.frame.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardHeight = windowHeight - keyboardFrame.minY <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isKeyboardUnlocked = isIPad ( ) &amp;&amp; keyboardFrame/maxY &lt; windowHeight <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isKeyboardUnlocked { keyboardHeight = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } delegate.keyboardWillChange ( keyboardHeight) } }</code> </pre> <br>  Kami mengatur ketinggiannya menjadi nol, dan sekarang dengan gerakan keyboard, kaki Ike turun dan diperbaiki di sana. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/uv/u_/txuvu_-lhk01nhlzbcyfxc8g3k4.gif" width="400"></div><br><br>  Satu-satunya kesalahpahaman yang tersisa adalah fakta bahwa ketika membelah keyboard, kaki Ike tidak segera jatuh.  Bagaimana cara memperbaikinya? <br><br>  Kami akan mengajarkan keyboardTracker untuk bekerja tidak hanya dengan keyboardWillChangeFrameNotification, tetapi juga dengan keyboardDidChangeFrame.  Anda tidak perlu menulis kode baru, cukup tambahkan centang bahwa ini adalah iPad agar tidak melakukan perhitungan yang tidak perlu. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardDidChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isIPad ( ) == <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/-n/nv/jd-nnvrctruwlczh4ytw2ckfllu.gif" width="400"></div><br><br><h2>  Bagaimana cara mendeteksi bug? </h2><br><h3>  Penebangan yang melimpah </h3><br>  Pada proyek kami, log ditulis dalam format berikut: di kurung siku nama modul dan submodule, yang menjadi milik log, dan kemudian teks log itu sendiri.  Misalnya, seperti ini: <br> <code>[keyboard][tracker] keyboardWillChangeFrame: calculated height - 437.9</code> <br> <br>  Dalam kode tersebut, tampilannya adalah sebagai berikut - logger dibuat dengan tag tingkat atas dan dikirimkan ke pelacak.  Di dalam pelacak, logger dengan tag tingkat kedua, yang digunakan untuk masuk ke dalam kelas, dipisahkan dari logger. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(with logger: <span class="hljs-type"><span class="hljs-type">Logger</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.trackerLogger = logger.dequeue(withTag: <span class="hljs-string"><span class="hljs-string">"[tracker]"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> height = <span class="hljs-number"><span class="hljs-number">0.0</span></span> trackerLogger.debug(<span class="hljs-string"><span class="hljs-string">"\(#function): calculated height - \(height)"</span></span>) } }</code> </pre> <br>  Jadi saya berjanji seluruh keyboardTracker, yang bagus.  Jika penguji menemukan masalah, saya mengambil file log dan mencari di mana frame tidak cocok.  Ini terlalu banyak waktu, oleh karena itu, selain penebangan, metode lain mulai diterapkan. <br><br><h3>  Watchdog </h3><br>  Dalam proyek kami, Watchdog digunakan untuk mengoptimalkan aliran UI.  Ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diceritakan oleh Dmitry Kurkin di salah satu AppsConf sebelumnya</a> . <br><br>  Watchdog adalah proses atau utas yang <strong>mengawasi</strong> proses atau utas lainnya.  Mekanisme ini memungkinkan Anda untuk memantau status keyboard dan tampilan yang bergantung padanya dan melaporkan masalah. <br><br>  Untuk mengimplementasikan fungsionalitas seperti itu, kami membuat penghitung waktu yang satu detik sekali akan memeriksa lokasi tampilan yang benar dengan kaki Hayk atau mencatat ini jika ada kesalahan. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Watchdog</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer: <span class="hljs-type"><span class="hljs-type">Timer?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { timer = <span class="hljs-type"><span class="hljs-type">Timer</span></span> ( timeInterval: <span class="hljs-number"><span class="hljs-number">1.0</span></span>, repeats: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, block: { ( timer ) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.woof ( ) } ) } }</code> </pre> <br>  Omong-omong, Anda dapat mencatat tidak hanya hasil akhir, tetapi juga perhitungan menengah. <br><br>  Sebagai hasilnya, pencatatan yang melimpah + Watchdog memberikan data akurat tentang masalah, keadaan keyboard, dan mengurangi waktu untuk memperbaiki bug, tetapi tidak banyak membantu pengguna beta yang harus menanggung kesalahan hingga rilis berikutnya. <br><br>  Tetapi bagaimana jika anjing penjaga dapat dilatih tidak hanya untuk menemukan masalah, tetapi juga untuk memperbaikinya? <br><br>  Dalam kode di mana pengawas memberikan kesimpulan bahwa koordinat tampilan tidak menyatu, kami menambahkan metode fixTummyPosition dan secara otomatis menempatkan koordinat di tempat. <br><br>  Dalam opsi ini, banyak informasi berguna yang terakumulasi di log saya, dan pengguna tidak melihat masalah visual sama sekali.  Ini sepertinya hebat, tapi sekarang saya tidak bisa mengetahui tentang masalah dengan keyboard. <br><br>  Ini membantu untuk menambah metode pengawas kemampuan untuk menghasilkan cache tes ketika kesalahan terdeteksi.  Tentu saja, kode ini ditambahkan di bawah konfigurasi remout. <br><br>  Sekarang, setelah rilis berikutnya, Anda dapat mengaktifkan generasi uji crash dan, jika pengguna memiliki masalah dengan keyboard, aplikasinya crash dan berkat log yang dikumpulkan, Anda dapat memperbaiki bug. <br><br><h3>  Dasbor </h3><br>  Trik terakhir yang kami perkenalkan adalah mengirim statistik saat wahtchdog mencatat statistik.  Berdasarkan data yang diperoleh, kami merencanakan jumlah kesalahan yang terdeteksi dan setelah iterasi pertama, jumlah operasi berkurang empat kali.  Tentu saja, itu tidak mungkin untuk mengurangi masalah menjadi nol, tetapi keluhan utama dari pengguna berhenti. <br><br><blockquote>  Minggu depan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saint AppsConf</a> akan diadakan di St. Petersburg, di mana Anda dapat mengajukan pertanyaan tidak hanya kepada Konstantin, tetapi juga kepada banyak pembicara dari jalur iOS. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462515/">https://habr.com/ru/post/id462515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462505/index.html">Jangan membodohi saya dengan pemrograman fungsional Anda</a></li>
<li><a href="../id462507/index.html">Saat pengiriman surat: melawan hilangnya pemberitahuan push di iOS</a></li>
<li><a href="../id462509/index.html">Product Fest - konferensi manajemen produk TI yang ingin Anda kunjungi</a></li>
<li><a href="../id462511/index.html">Google Play Instan. Refactoring seumur hidup</a></li>
<li><a href="../id462513/index.html">Relokasi: persiapan, pemilihan, pengembangan wilayah</a></li>
<li><a href="../id462519/index.html">Buku "Layanan Mikro. Pengembangan dan pola refactoring »</a></li>
<li><a href="../id462523/index.html">Server Otorisasi Dua-faktor LinOTP</a></li>
<li><a href="../id462525/index.html">3CX Meluncurkan Softphones SIP Baru untuk iOS dan Android dengan Enkripsi Suara ujung ke ujung</a></li>
<li><a href="../id462527/index.html">Bagaimana SincNet Neural Network Mengalokasikan Frekuensi Signifikan dalam Suara melalui Propagasi Belakang</a></li>
<li><a href="../id462529/index.html">Ide Stasiun Lunar NASA Buruk dan Bagus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>