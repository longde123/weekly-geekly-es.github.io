<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÇ üé¥ ‚úçüèª Android Superf√≠cie üöâ ‚úåüèª üçÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Isen√ß√£o de responsabilidade 


 Este artigo √© destinado a desenvolvedores iniciantes de Android com pouca experi√™ncia em trabalhar com v√≠deo e / ou c√¢...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android Superf√≠cie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480878/"><h2 id="diskleymer">  Isen√ß√£o de responsabilidade </h2><br><p>  Este artigo √© destinado a desenvolvedores iniciantes de Android com pouca experi√™ncia em trabalhar com v√≠deo e / ou c√¢mera, especialmente aqueles que come√ßaram a analisar exemplos de <a href="https://github.com/google/grafika" rel="nofollow">grafika</a> e os acharam dif√≠ceis, aqui veremos c√≥digo semelhante com uma descri√ß√£o simplificada das etapas b√°sicas ilustradas pelos diagramas de estado. </p><br><p>  Por que a classe Surface √© renderizada no cabe√ßalho?  No android, muitas classes t√™m a palavra <em>Surface</em> em seu nome (Surface, SurfaceHolder, SurfaceTexture, SurfaceView, GLSurfaceView), elas n√£o s√£o conectadas por uma hierarquia comum; no entanto, s√£o combinadas por uma l√≥gica de baixo n√≠vel para trabalhar com sa√≠da de imagem.  Pareceu-me razo√°vel us√°-lo no t√≠tulo para enfatizar uma tentativa de divulgar trabalho com essa parte espec√≠fica do SDK. </p><a name="habracut"></a><br><h2 id="primer-ispolzovaniya-s-raznym-api">  Exemplo de uso com API diferente </h2><br><p>  Vamos tentar escrever o seguinte exemplo: <strong>tiraremos uma pr√©via da c√¢mera, sobreporemos um desenho animado, exibiremos tudo na tela e, se necess√°rio, gravaremos em um arquivo.</strong>  O c√≥digo completo ser√° <a href="https://github.com/tttzof351/AndroidSurfaceExample/" rel="nofollow">https://github.com/tttzof351/AndroidSurfaceExample/</a> </p><br><p>  Para sa√≠da para as telas, usaremos o <a href="https://developer.android.com/reference/android/opengl/GLSurfaceView" rel="nofollow">GLSurfaceView</a> , para gravar com as classes <a href="https://developer.android.com/reference/android/media/MediaCodec" rel="nofollow">MediaCodec</a> e <a href="https://developer.android.com/reference/android/opengl/EGLSurface" rel="nofollow">EGLSurface</a> , e nos comunicar com a c√¢mera via <a href="https://developer.android.com/reference/android/hardware/camera2/package-summary" rel="nofollow">API V2</a> .  O esquema geral √© aproximadamente o seguinte: </p><br><p><img src="https://habrastorage.org/webt/9o/rc/o5/9orco54m0chpg_og4db_qppsrjm.png"></p><br><h2 id="nalozhenie-neskolkih-surface">  Sobreposi√ß√µes de superf√≠cie m√∫ltiplas </h2><br><p>  A superf√≠cie √© realmente uma al√ßa para a √°rea na mem√≥ria que precisa ser preenchida com a imagem.  Provavelmente, tentamos exibir algo na tela ou em um arquivo, para que funcione como um buffer para algum "processo" que produz dados. </p><br><p>  Para criar uma sobreposi√ß√£o de v√°rios Surface, usaremos o OpenGL. <br>  Para fazer isso, criaremos duas texturas externas quadradas e obteremos delas Surface </p><br><p>  No c√≥digo, ser√° algo parecido com isto: </p><br><p>  <a href="" rel="nofollow">OpenGLExtarnalTexture.kt</a> </p><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> textures = IntArray(<span class="hljs-number"><span class="hljs-number">1</span></span>) GLES20.glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, textures, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> textureId = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">//    val textureWidth = ... val textureHeight = ... //  val surfaceTexture = SurfaceTexture(textureId) surfaceTexture.setDefaultBufferSize(textureWidth, textureHeight) //, surface  ""    val surface = Surface(surfaceTexture)</span></span></code> </pre> <br><p>  <strong>Coordenadas XYZ</strong> </p><br><p>  Agora precisamos entender como criar e organizar as texturas, e para isso teremos que lembrar como a grade de coordenadas √© estruturada no OpenGL: seu centro coincide com o centro da cena (janela) e as bordas s√£o normalizadas, ou seja, de -1 a 1. </p><br><p>  Nesta cena, queremos definir dois ret√¢ngulos (o trabalho est√° no plano, para que todas as coordenadas z sejam logicamente definidas como 0f) - em vermelho, indicaremos aquele em que colocaremos a visualiza√ß√£o da c√¢mera e em azul para o desenho animado: </p><br><p>  Anotamos nossas coordenadas explicitamente: </p><br><p><img src="https://habrastorage.org/webt/mu/fj/kr/mufjkrznafatofs4lsn-ywm_h7i.png"></p><br><pre> <code class="kotlin hljs">fullscreenTexture = floatArrayOf( <span class="hljs-comment"><span class="hljs-comment">// X, Y, Z -1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, -1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, ) smallTexture = floatArrayOf( // X, Y, Z 0.3f, 0.3f, 0.0f, 0.8f, 0.3f, 0.0f, 0.3f, 0.8f, 0.0f, 0.8f, 0.8f, 0.0f )</span></span></code> </pre> <br><p>  <strong>Coordenadas UV</strong> </p><br><p>  Isso √© suficiente?  Acontece que n√£o :( </p><br><p>  Uma textura √© um mapeamento de uma imagem para uma √°rea de cena e, para torn√°-la correta, voc√™ precisa especificar exatamente onde os pontos da imagem se encaixam nessa √°rea - para isso, o OpenGL usa coordenadas <strong>UV</strong> - eles saem do canto inferior esquerdo e t√™m bordas de 0 a 1 para cada eixos. </p><br><p>  Funciona da seguinte forma: definiremos as coordenadas <strong>UV</strong> para cada v√©rtice de nossa √°rea e procuraremos os pontos correspondentes na imagem, assumindo que a largura e a altura sejam iguais a 1. </p><br><p>  Considere um exemplo: assumiremos que a c√¢mera nos fornece a imagem em um estado invertido e refletido e, ao mesmo tempo, queremos mostrar apenas a parte superior direita, ou seja, obter 0,8 de latitude e altura da imagem. </p><br><p>  O ponto sutil - neste est√°gio, n√£o sabemos a propor√ß√£o da √°rea na tela - s√≥ temos um quadrado em coordenadas relativas, que preencher√£o toda a cena e, consequentemente, se estender√£o.  Se fiz√©ssemos uma c√¢mera de tela cheia, nossos tamanhos relativos (2 de cada lado) se estenderiam para o 1080x1920 convencional.  Assumimos que definimos as dimens√µes da cena de forma que sua propor√ß√£o seja igual √† propor√ß√£o da c√¢mera. <br>  Vamos ver para onde v√£o as coordenadas - o ponto superior direito da nossa √°rea (1, 1, 0) deve ir para a coordenada UV (0, 0), a parte inferior esquerda em (0.8f, 0.8f), etc. </p><br><p><img src="https://habrastorage.org/webt/fk/ur/ig/fkurigpfo4l_hnl1fonbgj1dao0.png"></p><br><p>  Assim, obtemos a correspond√™ncia de XYZ e UV: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// X, Y, Z, U, V -1.0f, -1.0f, 0.0f, 0.8f, 0.8f, 1.0f, -1.0f, 0.0f, 0.8f, 0.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.8f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f</span></span></code> </pre> <br><p>  Se a propor√ß√£o entre a visualiza√ß√£o da c√¢mera e a √°rea na tela coincidir inicialmente, ela obviamente continuar√° sendo salva, porque, no nosso caso, apenas multiplicamos por 0,8f. <br>  E o que vamos comer, vamos definir valores maiores que 1?  Dependendo das configura√ß√µes que passamos para o OpenGL, obteremos pontos de alguma parte da imagem.  Em nosso exemplo, a √∫ltima linha ser√° repetida ao longo do eixo correspondente e veremos artefatos na forma de "listras" </p><br><p>  <strong>Conclus√£o: se queremos compactar / cortar a imagem, mantendo a posi√ß√£o da √°rea na tela, as coordenadas UV s√£o a nossa escolha!</strong> </p><br><p>  <strong>Defina as coordenadas para as nossas texturas.</strong> </p><br><p><img src="https://habrastorage.org/webt/au/wp/zx/auwpzx9wgczhb79_4bbfu9nyk_a.png"></p><br><pre> <code class="kotlin hljs">fullscreenTexture = floatArrayOf( <span class="hljs-comment"><span class="hljs-comment">// X, Y, Z, U, V -1.0f, -1.0f, 0.0f, 1f, 0f, 1.0f, -1.0f, 0.0f, 0f, 0f, -1.0f, 1.0f, 0.0f, 1f, 1f, 1.0f, 1.0f, 0.0f, 0f, 1f ) smallTexture = floatArrayOf( // X, Y, Z, U, V 0.3f, 0.3f, 0.0f, 0f, 0f, 0.8f, 0.3f, 0.0f, 1f, 0f, 0.3f, 0.8f, 0.0f, 0f, 1f, 0.8f, 0.8f, 0.0f, 1f, 1f )</span></span></code> </pre> <br><p>  <strong>Shaders</strong> </p><br><p>  Ter coordenadas est√°ticas XYZ e UV n√£o √© muito conveniente - por exemplo, podemos querer mover e dimensionar nossas texturas com gestos.  Para transform√°-los, criaremos duas matrizes para cada textura: <strong>MVPMatrix</strong> e <strong>TexMatrix</strong> for para coordenadas XYZ e UV, respectivamente. </p><br><p>  Cada OpenGL2 deve conter shaders para exibir algo na tela.  Obviamente, esse n√£o √© um t√≥pico que possa ser divulgado em um par√°grafo; no entanto, no nosso caso, eles ser√£o triviais e, portanto, voc√™ poder√° entender rapidamente que eles s√£o o que est√£o fazendo, sem muito conhecimento do material. </p><br><p>  Primeiro de tudo, existem dois shaders - v√©rtice e fragmento. </p><br><p>  O primeiro (v√©rtice) processar√° nossos v√©rtices, ou seja, basta multiplicar nossas coordenadas XYZ / UV com suas matrizes correspondentes e preencher a vari√°vel OpenGL <strong>gl_Position,</strong> que √© exatamente respons√°vel pela posi√ß√£o final de nossa textura na tela. </p><br><p>  O segundo (fragmento) deve preencher <strong>gl_FragColor com</strong> pixels da imagem. </p><br><p>  Total que temos: as vari√°veis ‚Äã‚Äãdentro do vertex shader, devemos preencher os campos com nossos dados, a saber: </p><br><ul><li>  MVPMatrix -&gt; <strong>uMVPMatrix</strong> </li><li>  <strong>TexMatrix -&gt; uTexMatrix</strong> </li><li>  nossas coordenadas de v√©rtice XYZ -&gt; <strong>aPosition</strong> </li><li>  Coordenadas UV -&gt; <strong>aTextureCoord</strong> </li></ul><br><p>  <strong>vTextureCoord</strong> - necess√°rio para encaminhar dados do shader de v√©rtice para o shader de fragmento <br>  No shader de fragmento, pegamos as coordenadas UV convertidas e as usamos para exibir os pixels da imagem na √°rea de textura. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vertexShader = <span class="hljs-string"><span class="hljs-string">""" uniform mat4 uMVPMatrix; uniform mat4 uTexMatrix; attribute vec4 aPosition; attribute vec4 aTextureCoord; varying vec2 vTextureCoord; void main() { gl_Position = uMVPMatrix * aPosition; vTextureCoord = (uTexMatrix * aTextureCoord).xy; } """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fragmentShader = <span class="hljs-string"><span class="hljs-string">""" #extension GL_OES_EGL_image_external : require precision mediump float; varying vec2 vTextureCoord; uniform samplerExternalOES sTexture; void main() { gl_FragColor = texture2D(sTexture, vTextureCoord); } """</span></span></code> </pre> <br><p>  Para refer√™ncia, indicamos a diferen√ßa entre os tipos: </p><br><ul><li>  uniforme - uma vari√°vel desse tipo ret√©m valores durante chamadas repetidas, usamos um sombreador que √© chamado seq√ºencialmente para duas texturas, portanto, ainda o substituiremos a cada renderiza√ß√£o </li><li>  attribute - dados deste tipo s√£o lidos do buffer de v√©rtice, precisam ser carregados a cada renderiza√ß√£o </li><li>  variando - necess√°rio para transferir dados do shader de v√©rtice para o fragmento </li></ul><br><p>  Como passar par√¢metros para um shader?  Para fazer isso, voc√™ primeiro precisa obter o id (ponteiro) da vari√°vel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aPositionHandle = GLES20.glGetAttribLocation(programId, <span class="hljs-string"><span class="hljs-string">"aPosition"</span></span>)</code> </pre> <br><p>  Agora, para esse ID, voc√™ precisa carregar os dados: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//      floatbuffer val verticesBuffer = ByteBuffer.allocateDirect( fullscreenTexture.size * FLOAT_SIZE_BYTES ).order( ByteOrder.nativeOrder() ).asFloatBuffer() verticesBuffer.put(fullscreenTexture).position(0) /*    -  XYZ   0 .       id      ,     ,               - 5  - XYZUV,  4 - -   float */ verticesBuffer.position(0) GLES20.glVertexAttribPointer( aPositionHandle, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer )</span></span></code> </pre> <br><p>  <strong>Desenho direto</strong> </p><br><p>  Depois de preenchermos os shaders com todos os dados, devemos solicitar a textura para atualizar a imagem e o OpenGL para desenhar nossos v√©rtices: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { ... surfaceTexture.updateTexImage() GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) }</code> </pre> <br><p>  Em nosso exemplo, dividiremos o trabalho com a cena OpenGL em duas classes - diretamente cenas e texturas: </p><br><p>  <a href="https://github.com/tttzof351/AndroidSurfaceExample/blob/master/app/src/main/java/com/example/surfaces/helpers/OpenGLExternalTexture.kt/" rel="nofollow">OpenGLExternalTexture.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenGLExternalTexture</span></span></span></span>(verticesData: FloatArray, ...) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surfaceTexture: SurfaceTexture <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surface: Surface <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,    . } ... fun updateFrame(aPositionHandle: Int, ...) {...} // ,   fun release() {...} //   }</span></span></code> </pre> <br><p>  <a href="" rel="nofollow">OpenGLScene.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenGLScene</span></span></span></span>( sceneWidth: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, sceneHeight: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, ... ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullscreenTexture = OpenGLExternalTexture(...) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> smallTexture = OpenGLExternalTexture(..) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aPositionHandle: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,        . } fun updateFrame() { ... fullscreenTexture.updateFrame(aPositionHandle, ...) smallTexture.updateFrame(aPositionHandle, ...) } fun release() { fullscreenTexture.release() smallTexture.release() } }</span></span></code> </pre> <br><h2 id="statemachine--mashina-sostoyaniy--konechnyy-avtomat">  M√°quina de estado / M√°quina de estado / M√°quina de estado </h2><br><p>  Todas as APIs que pretendemos usar em nosso exemplo s√£o basicamente ass√≠ncronas (bem, talvez com exce√ß√£o do Drawable animado).  Envolvemos essas chamadas em StateMachines separados, uma abordagem em que o estado do sistema √© explicitamente gravado e as transi√ß√µes entre elas ocorrem atrav√©s do envio de eventos. </p><br><p>  Vejamos um exemplo simples de como isso ficar√°, suponha que tenhamos este c√≥digo: </p><br><pre> <code class="kotlin hljs">imageView.setOnClickListener { loadImage { bitmap -&gt; imageView.setBitmap(bitmap) } }</code> </pre> <br><p>  Em geral, est√° tudo bem - bonito e compacto, mas tentaremos reescrev√™-lo da seguinte maneira: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiMachine = UIMachine() imageView.setOnClickListener { uiMachine.send(Click(imageView)) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIMachine</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: State = WaitClick() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Action</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = transition(action) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Action</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitingClick &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Click -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitBitmap(imageView = action.imageView) loadImage { send(BitmapIsReady(bitmap = it)) } } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitingBitmap &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> BitmapIsReady -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitClick state.imageView.setImageBitmap(action.bitmap) } } } } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> WaitingClick : State() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaitingBitmap</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> imageView: ImageView): State() } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Click</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> imageView: ImageView): Action() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BitmapIsReady</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bitmap: Bitmap): Action() }</code> </pre> <br><p>  Por um lado, descobriu-se <strong><em>muito</em></strong> mais, no entanto, v√°rias propriedades impl√≠citas, mas √∫teis, apareceram: pressionar repetidamente agora n√£o leva a um <strong>carregamento</strong> desnecess√°rio de <strong>imagImage,</strong> embora n√£o seja √≥bvio com esse volume, mas nos livramos da chamada de retorno de chamada aninhada, que usaremos posteriormente , e o estilo de escrita do m√©todo de transi√ß√£o permite criar um diagrama de transi√ß√£o que repete o c√≥digo individualmente, ou seja, no nosso caso: </p><br><p><img src="https://habrastorage.org/webt/-n/2p/mq/-n2pmqdwfsps932me0wfsrvyj_q.png"><br>  Cinza indica transi√ß√µes que n√£o s√£o explicitamente gravadas.  Geralmente, eles s√£o registrados ou gerados uma exce√ß√£o, considerando-o um sinal de erro.  Por enquanto, conseguiremos simplesmente ignor√°-lo e, no futuro, n√£o apontaremos para os diagramas. </p><br><p>  Crie as interfaces base para StateMachine: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateMachine</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S : State, A : Action</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: S <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><h2 id="glsurfaceview">  GLSurfaceView </h2><br><p>  A maneira mais f√°cil de exibir algo usando o OpenGL no Android √© a classe GLSurfaceView - ela cria automaticamente um novo fluxo de desenho, que inicia / pausa usando os m√©todos GLSurfaceView :: onResume / onPause. </p><br><p>  Por uma quest√£o de simplicidade, definiremos nossa vis√£o para uma propor√ß√£o de 16: 9 </p><br><p>  O pr√≥prio processo de renderiza√ß√£o √© movido para um retorno de chamada separado - GLSurfaceView.Renderer. <br>  Embrulhando-o no StateMachine, temos algo parecido com isto: </p><br><p>  <a href="" rel="nofollow">GLSurfaceMachine.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLSurfaceMachine</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateMachine</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLSurfaceState, GLSurfaceAction</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: GLSurfaceState = WaitCreate() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLSurfaceAction</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = transition(action) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLSurfaceAction</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitCreate &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Create -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitSurfaceReady(...) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.glSurfaceView?.setRenderer(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> :Renderer { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, width: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, height: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> send(SurfaceReady(width, height, gl)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, config: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EGLConfig</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDrawFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { send(Draw) } }) } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitSurfaceReady &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SurfaceReady -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openGLScene = OpenGLScene(width, height) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = DrawingAvailable(openGLScene, ...) } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DrawingAvailable &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Draw -&gt; { state.openGLScene.updateFrame() } state !<span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitCreate &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Stop -&gt; { state.uiHolder.glSurfaceView?.onPause() state.uiHolder.openGLScene?.release() <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitSurfaceReady() } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitSurfaceReady &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Start -&gt; { state.uiHolder.glSurfaceView?.onResume() } } } } ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> glSurfaceMachine = GLSurfaceMachine() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> glSurfaceView = findViewById(R.id.gl_view) glSurfaceView.layoutParams.width = width glSurfaceView.layoutParams.height = ((<span class="hljs-number"><span class="hljs-number">16f</span></span>/<span class="hljs-number"><span class="hljs-number">9f</span></span>) * width).toInt() glSurfaceMachine.send(GLSurfaceAction.Create(glSurfaceView, ...))</code> </pre> <br><p>  Vamos desenhar um diagrama de transi√ß√£o: </p><br><p><img src="https://habrastorage.org/webt/mx/5i/xb/mx5ixbssfaqci1ktsmumu94jbz0.png"></p><br><p>  Agora, nosso c√≥digo est√° tentando exibir algo na tela, embora, por enquanto, ele o fa√ßa mal - n√£o veremos nada al√©m de uma tela preta.  N√£o √© dif√≠cil adivinhar o fato √© que nada est√° entrando em nossa superf√≠cie agora porque ainda n√£o implementamos fontes de imagem.  Vamos corrigir isso - primeiro, crie um CanvasDrawable: </p><br><p>  <a href="" rel="nofollow">CanvasDrawable.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanvasDrawable</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Drawable</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundPaint = Paint().apply { ... } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> circlePaint = Paint().apply { ... } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Canvas</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { canvas.drawRect(bounds, backgroundPaint) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> width = bounds.width() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> height = bounds.height() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> posX = ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> posY = ... canvas.drawCircle(posX, posY, <span class="hljs-number"><span class="hljs-number">0.1f</span></span> * width, circlePaint) } ... }</code> </pre> <br><p>  Agora podemos complementar a se√ß√£o no GLSurfaceMachine renderizando canvasDrawable na tela que fornece a superf√≠cie da textura correspondente: </p><br><pre> <code class="kotlin hljs">state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DrawingAvailable &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Draw -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> canvasDrawable = state.canvasDrawable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> smallTexture = state.openGLScene.smallTexture <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bounds = canvasDrawable.bounds <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> canvas = smallSurface.lockCanvas(bounds) canvasDrawable.draw(canvas) smallSurface.unlockCanvasAndPost(canvas) state.openGLScene.updateFrame() }</code> </pre> <br><p>  Ap√≥s o que veremos algo como: </p><br><p><img src="https://habrastorage.org/webt/vo/4r/-d/vo4r-dgpynjvynvxdomy2fezp9y.png"></p><br><h2 id="camera-api-v2">  API da c√¢mera V2 </h2><br><p>  O ret√¢ngulo verde √© certamente divertido e intrigante, mas √© hora de tentar trazer a visualiza√ß√£o da c√¢mera para a superf√≠cie restante. </p><br><p>  Vamos escrever as etapas para trabalhar com a c√¢mera: </p><br><ul><li>  Estamos aguardando permiss√£o.  Teremos esse estado <strong>WaitingStart</strong> </li><li>  Obtemos a inst√¢ncia do gerenciador de c√¢mera, encontramos o ID l√≥gico (geralmente existem dois deles - para tr√°s e frente, e o l√≥gico √© porque a c√¢mera pode consistir em muitos sensores em dispositivos modernos) da c√¢mera desejada, selecione o tamanho apropriado, abra a c√¢mera, obteremos o cameraDevice.  Status <strong>WaitingOpen</strong> </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> manager = getSystemService(Context.CAMERA_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CameraManager <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultCameraId: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultSize: Size? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cameraId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> manager.cameraIdList) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> chars = manager.getCameraCharacteristics(cameraId) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> facing = chars.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(CameraCharacteristics.LENS_FACING) ?: -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (facing == LENS_FACING_BACK) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> confMap = chars.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>( CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sizes = confMap?.getOutputSizes(SurfaceTexture::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resultSize</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">findSize</span></span></span></span>(sizes) resultCameraId = cameraId <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } resultCameraId?.let { cameraId -&gt; manager.openCamera(cameraId, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraDevice.StateCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOpened</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(camera: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CameraDevice</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//Success open camera ... } }) }</span></span></code> </pre> <br><ul><li>  Tendo uma c√¢mera aberta, nos voltamos para solicitar uma superf√≠cie para exibir a imagem.  <strong>WaitingSurface</strong> Status </li><li>  Agora que temos o cameraDevice, Surface, precisamos abrir uma sess√£o para que a c√¢mera finalmente comece a enviar dados.  Status <strong>WaitingSession</strong> </li></ul><br><pre> <code class="kotlin hljs">cameraDevice.createCaptureSession( arrayListOf(surface), <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraCaptureSession.StateCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(session: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CameraCaptureSession</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { send(CameraAction.SessionReady(session)) } }, handler )</code> </pre> <br><ul><li>  Agora podemos capturar a visualiza√ß√£o.  Status da <strong>visualiza√ß√£o inicial</strong> </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> request = cameraDevice.createCaptureRequest( CameraDevice.TEMPLATE_PREVIEW ).apply { addTarget(surface) } session.setRepeatingRequest( request.build(), <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraCaptureSession.CaptureCallback() {...} handler )</code> </pre> <br><p>  Ilustramos nosso esquema atual: </p><br><p>  <a href="" rel="nofollow">CameraMachine.kt</a> </p><br><p><img src="https://habrastorage.org/webt/i6/tj/q1/i6tjq12xls77hudocvpnt0m6qy0.png"></p><br><p><img src="https://habrastorage.org/webt/6w/ad/fp/6wadfpayduldvtqwcrjggkoce6y.png"></p><br><h2 id="mediacodec">  Mediacodec </h2><br><p>  MediaCodec √© uma classe para trabalho de baixo n√≠vel com codecs de sistema, em geral, sua API √© um conjunto de buffers de entrada / sa√≠da (parece, infelizmente, mais f√°cil do que trabalhar com ele) no qual os dados (brutos ou codificados dependem do modo de opera√ß√£o do codificador / decodificador) s√£o colocados, e na sa√≠da, obtemos o resultado. </p><br><p>  Apesar do ByteBuffer geralmente atuar como buffers, voc√™ pode usar o Surface para trabalhar com v√≠deo, que retornar√° o MediaCodec :: createInputSurface para n√≥s, nele devemos desenhar os quadros que queremos gravar (com essa abordagem, a documenta√ß√£o nos promete uma codifica√ß√£o mais r√°pida atrav√©s do uso de gpu ) </p><br><p>  Bem, agora precisamos aprender a desenhar a superf√≠cie existente que criamos no GLSurfaceMachine on Surface da MediaCodec.  √â importante lembrar: Surface √© um objeto que cria um consumidor e, em geral, √© imposs√≠vel ler algo dele, ou seja, n√£o h√° m√©todo condicional getBitmap / readImage / ... </p><br><p>  Vamos proceder da seguinte maneira: com base no contexto GL existente, criaremos um novo que ter√° uma mem√≥ria comum e, portanto, podemos us√°-lo para reutilizar os id-shniks das texturas que criamos anteriormente l√°.  Em seguida, usando o novo contexto GL e Surface do MediaCodec, criaremos um EGLSurface - um buffer fora da tela no qual tamb√©m podemos criar nossa classe OpenGLScene.  Ent√£o, a cada renderiza√ß√£o de quadro, tentaremos escrever o quadro no arquivo em paralelo. </p><br><p>  EGL significa a interface de intera√ß√£o da API OpenGL com o subsistema de janelas da plataforma; roubaremos o trabalho da grafika.  Tamb√©m n√£o descreverei o transportador (EncoderHelper) diretamente com o MediaCodec; darei apenas o esquema final de intera√ß√£o entre nossos componentes: </p><br><p>  <a href="" rel="nofollow">EncoderMachine.kt</a> <br>  <a href="" rel="nofollow">EncoderHelper.kt</a> </p><br><p><img src="https://habrastorage.org/webt/d1/gc/kf/d1gckfqligsrwynmmkq_bb2yzoy.png"></p><br><h2 id="itog">  O resultado: </h2><br><ul><li>  Trabalhar com v√≠deo requer pelo menos habilidades b√°sicas em OpenGL </li><li>  A API do Android Media √© de n√≠vel bastante baixo, o que oferece flexibilidade, mas √†s vezes obriga a escrever um pouco mais de c√≥digo do que voc√™ gostaria </li><li>  APIs ass√≠ncronas podem ser agrupadas em StateMachines </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480878/">https://habr.com/ru/post/pt480878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480866/index.html">Uma nova era de desenvolvimento web ou "tudo j√° est√° l√°"</a></li>
<li><a href="../pt480870/index.html">Resultados da d√©cada</a></li>
<li><a href="../pt480872/index.html">Intel fechou uma brecha de seguran√ßa relatada seis meses atr√°s</a></li>
<li><a href="../pt480874/index.html">O estudo dos neutrinos levou a uma descoberta inesperada na matem√°tica</a></li>
<li><a href="../pt480876/index.html">Limpamos o Dock e fazemos o aplicativo sem xCode</a></li>
<li><a href="../pt480884/index.html">GUI do Python em 5 minutos</a></li>
<li><a href="../pt480886/index.html">Redes neurais e a propor√ß√£o √°urea: segunda execu√ß√£o</a></li>
<li><a href="../pt480888/index.html">Corotinas DIY. Parte 1. Geradores Pregui√ßosos</a></li>
<li><a href="../pt480890/index.html">Resultados da pesquisa sobre o uso do painel Express</a></li>
<li><a href="../pt480892/index.html">Internet de bal√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>