<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨õÔ∏è üîΩ üë§ Depurando uma rede usando eBPF (RHEL 8 Beta) üê§ üë©üèæ‚Äç‚öñÔ∏è üßë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tudo com os feriados passados! 

 Decidimos dedicar nosso primeiro artigo ap√≥s as f√©rias ao Linux, ou seja, ao nosso maravilhoso curso de Administrado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Depurando uma rede usando eBPF (RHEL 8 Beta)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/436528/"> Tudo com os feriados passados! <br><br>  Decidimos dedicar nosso primeiro artigo ap√≥s as f√©rias ao Linux, ou seja, ao nosso maravilhoso curso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Administrador Linux</a> , que temos no grupo dos cursos mais din√¢micos, ou seja, com os materiais e pr√°ticas mais relevantes.  Bem, e, consequentemente, oferecemos artigos interessantes e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma li√ß√£o aberta</a> . <br><br>  <i>Postado por Matteo Croce</i> <i><br></i>  <i>T√≠tulo original: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Depura√ß√£o de rede com eBPF (RHEL 8 Beta)</a></i> <br><br>  <b>1. Introdu√ß√£o</b> <br><br>  O trabalho em rede √© uma experi√™ncia emocionante, mas nem sempre os problemas s√£o evitados.  A solu√ß√£o de problemas pode ser complicada, pois est√° tentando reproduzir o comportamento errado que acontece ‚Äúno campo‚Äù. <br><br>  Felizmente, existem ferramentas que podem ajudar com isso: namespaces de rede, m√°quinas virtuais, <code>tc</code> e <code>netfilter</code> .  Configura√ß√µes simples de rede podem ser reproduzidas usando namespaces de rede e dispositivos veth, enquanto configura√ß√µes mais complexas exigem a conex√£o de m√°quinas virtuais a uma ponte de software e o uso de ferramentas de rede padr√£o, como <code>iptables</code> ou <code>tc</code> , para simular comportamento incorreto.  Se houver um problema com as respostas ICMP geradas quando o servidor SSH <code>iptables -A INPUT -p tcp --dport 22 -j REJECT --reject-with icmp-host-unreachable</code> , o <code>iptables -A INPUT -p tcp --dport 22 -j REJECT --reject-with icmp-host-unreachable</code> no namespace correto pode ajudar a resolver o problema. <br><br>  Este artigo descreve como solucionar problemas complexos de rede com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eBPF (BPF estendido)</a> , uma vers√£o avan√ßada do Berkeley Packet Filter.  O eBPF √© uma tecnologia relativamente nova, o projeto est√° em um est√°gio inicial, portanto a documenta√ß√£o e o SDK ainda n√£o est√£o prontos.  Mas esperamos melhorias, especialmente porque o XDP (eXpress Data Path) √© fornecido com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Red Hat Enterprise Linux 8 Beta</a> , que voc√™ pode baixar e executar agora. <br><br>  O eBPF n√£o resolver√° todos os problemas, mas ainda √© uma ferramenta poderosa de depura√ß√£o de rede que merece aten√ß√£o.  Estou certo de que desempenhar√° um papel muito importante no futuro das redes. <br><br><img src="https://habrastorage.org/webt/qf/la/jo/qflajolwk-bjp2zwjzpnixmqlma.png"><a name="habracut"></a><br><br>  <b>O problema</b> <br><br>  Eu estava depurando um problema de rede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Open vSwitch (OVS)</a> que envolvia uma instala√ß√£o muito complicada: alguns pacotes TCP foram espalhados e entregues na ordem errada, e a largura de banda das m√°quinas virtuais caiu de 6 Gb / s est√°veis ‚Äã‚Äãpara 2-4 Gb / s flutuantes.  A an√°lise mostrou que o primeiro pacote TCP de cada conex√£o com o sinalizador PSH foi enviado na ordem errada: apenas o primeiro e o √∫nico por conex√£o. <br><br>  Tentei reproduzir essa configura√ß√£o com duas m√°quinas virtuais e, depois de muitos artigos de ajuda e consultas de pesquisa, descobri que nem o <code>iptables</code> nem o <code>nftables</code> podem manipular sinalizadores TCP, enquanto <code>tc</code> pode, mas apenas substituindo os sinalizadores e interrompendo novas conex√µes e TCP em geral <br><br>  Pode ser poss√≠vel resolver o problema com uma combina√ß√£o de <code>iptables</code> , <code>conntrack</code> e <code>tc</code> , mas decidi que esse √© um √≥timo trabalho para o eBPF. <br><br>  <b>O que √© o eBPF?</b> <br><br>  eBPF √© uma vers√£o aprimorada do Berkeley Packet Filter.  Ela traz muitas melhorias para o BPF.  Em particular, ele permite que voc√™ escreva na mem√≥ria, e n√£o apenas leia, para que os pacotes possam n√£o apenas ser filtrados, mas tamb√©m editados. <br><br>  Freq√ºentemente, o eBPF √© simplesmente chamado BPF, e o pr√≥prio BPF √© chamado cBPF (cl√°ssico (cl√°ssico) BPF), portanto a palavra "BPF" pode ser usada para significar as duas vers√µes, dependendo do contexto: neste artigo eu sempre falo sobre a vers√£o estendida. <br><br>  ‚ÄúUnder the hood‚Äù O eBPF possui uma m√°quina virtual muito simples que pode executar pequenos fragmentos de c√≥digo de bytes e editar alguns buffers de mem√≥ria.  Existem limita√ß√µes no eBPF que o protegem contra uso malicioso: <br><br><ul><li>  Os ciclos s√£o proibidos para que o programa sempre termine em um hor√°rio espec√≠fico; </li><li>  Ele s√≥ pode acessar a mem√≥ria atrav√©s da pilha e do buffer tempor√°rio; </li><li>  Somente fun√ß√µes permitidas do kernel podem ser chamadas. </li></ul><br>  Um programa pode ser carregado no kernel de v√°rias maneiras, usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">depura√ß√£o e rastreamento</a> .  No nosso caso, o eBPF est√° interessado em trabalhar com subsistemas de rede.  Existem duas maneiras de usar o programa eBPF: <br><br><ul><li>  Conectado via XDP ao in√≠cio do caminho RX de uma placa de rede f√≠sica ou virtual; </li><li>  Conectado via <code>tc</code> ao qdisc na entrada ou na sa√≠da. </li></ul><br>  Para criar um programa eBPF para conex√£o, basta escrever o c√≥digo C e convert√™-lo em bytecode.  A seguir, √© apresentado um exemplo simples usando XDP: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">SEC</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">prog</span></span>") <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xdp_main</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">struct</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xdp_md</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">ctx</span></span>) { void *data_end = (void *)(uintptr_t)ctx-&gt;data_end; void *data = (void *)(uintptr_t)ctx-&gt;data; struct ethhdr *eth = data; struct iphdr *iph = (struct iphdr *)(eth + 1); struct icmphdr *icmph = (struct icmphdr *)(iph + 1); <span class="hljs-comment"><span class="hljs-comment">/* sanity check needed by the eBPF verifier */</span></span> if (icmph + 1 &gt; data_end) return XDP_PASS; <span class="hljs-comment"><span class="hljs-comment">/* matched a pong packet */</span></span> if (eth-&gt;h_proto != ntohs(ETH_P_IP) || iph-&gt;protocol != IPPROTO_ICMP || icmph-&gt;type != ICMP_ECHOREPLY) return XDP_PASS; if (iph-&gt;ttl) { <span class="hljs-comment"><span class="hljs-comment">/* save the old TTL to recalculate the checksum */</span></span> uint16_t *ttlproto = (uint16_t *)&amp;iph-&gt;ttl; uint16_t old_ttlproto = *ttlproto; <span class="hljs-comment"><span class="hljs-comment">/* set the TTL to a pseudorandom number 1 &lt; x &lt; TTL */</span></span> iph-&gt;ttl = bpf_get_prandom_u32() % iph-&gt;ttl + 1; <span class="hljs-comment"><span class="hljs-comment">/* recalculate the checksum; otherwise, the IP stack will drop it */</span></span> csum_replace2(&amp;iph-&gt;check, old_ttlproto, *ttlproto); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">XDP_PASS</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">char</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">license</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SEC</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">license</span></span>") = "<span class="hljs-selector-tag"><span class="hljs-selector-tag">GPL</span></span>";</code> </pre> <br>  O snippet acima, sem <code>include</code> express√µes, auxiliares e c√≥digo opcional, √© um programa XDP que altera o TTL das respostas de eco ICMP recebidas, ou seja, pongs, por um n√∫mero aleat√≥rio.  A fun√ß√£o principal obt√©m a estrutura <code>xdp_md</code> , que cont√©m dois ponteiros para o in√≠cio e o fim do pacote. <br><br>  Para compilar nosso c√≥digo no bytecode do eBPF, √© necess√°rio um compilador com suporte apropriado.  O Clang suporta e cria o bytecode do eBPF especificando bpf como o destino no momento da compila√ß√£o: <br><br><pre> <code class="bash hljs">$ clang -O2 -target bpf -c xdp_manglepong.c -o xdp_manglepong.o</code> </pre> <br>  O comando acima cria um arquivo que, √† primeira vista, parece um arquivo de objeto normal, mas ap√≥s uma inspe√ß√£o mais detalhada, verifica-se que o tipo especificado de computador √© Linux eBPF e n√£o o tipo nativo de sistema operacional: <br><br><pre> <code class="bash hljs">$ readelf -h xdp_manglepong.o ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2<span class="hljs-string"><span class="hljs-string">'s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (Relocatable file) Machine: Linux BPF &lt;--- HERE [...]</span></span></code> </pre> <br>  Ap√≥s receber o inv√≥lucro de um arquivo de objeto comum, o programa eBPF est√° pronto para fazer o download e conectar-se ao dispositivo via XDP.  Isso pode ser feito usando o <code>ip</code> do pacote <code>iproute2</code> com a seguinte sintaxe: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ip -force link set dev wlan0 xdp object xdp_manglepong.o verbose</span></span></code> </pre> <br>  Este comando especifica a interface wlan0 de destino e, gra√ßas √† op√ß√£o -force, substitui qualquer c√≥digo eBPF existente que j√° tenha sido carregado.  Ap√≥s carregar o bytecode do eBPF, o sistema se comporta da seguinte maneira: <br><br><pre> <code class="bash hljs">$ ping -c10 192.168.85.1 PING 192.168.85.1 (192.168.85.1) 56(84) bytes of data. 64 bytes from 192.168.85.1: icmp_seq=1 ttl=41 time=0.929 ms 64 bytes from 192.168.85.1: icmp_seq=2 ttl=7 time=0.954 ms 64 bytes from 192.168.85.1: icmp_seq=3 ttl=17 time=0.944 ms 64 bytes from 192.168.85.1: icmp_seq=4 ttl=64 time=0.948 ms 64 bytes from 192.168.85.1: icmp_seq=5 ttl=9 time=0.803 ms 64 bytes from 192.168.85.1: icmp_seq=6 ttl=22 time=0.780 ms 64 bytes from 192.168.85.1: icmp_seq=7 ttl=32 time=0.847 ms 64 bytes from 192.168.85.1: icmp_seq=8 ttl=50 time=0.750 ms 64 bytes from 192.168.85.1: icmp_seq=9 ttl=24 time=0.744 ms 64 bytes from 192.168.85.1: icmp_seq=10 ttl=42 time=0.791 ms --- 192.168.85.1 ping statistics --- 10 packets transmitted, 10 received, 0% packet loss, time 125ms rtt min/avg/max/mdev = 0.744/0.849/0.954/0.082 ms</code> </pre> <br>  Cada pacote passa pelo eBPF, o que, em √∫ltima an√°lise, faz algumas altera√ß√µes e decide se deve ser descartado ou ignorado. <br><br>  <b>Como o eBPF pode ajudar</b> <br><br>  Voltando ao problema de rede original, lembramos que era necess√°rio marcar v√°rios sinalizadores TCP, um por conex√£o, e nem o <code>iptables</code> nem o <code>tc</code> poderiam fazer isso.  N√£o √© dif√≠cil escrever c√≥digo para esse cen√°rio: configure duas m√°quinas virtuais conectadas por uma ponte OVS e simplesmente conecte o eBPF a um dos dispositivos virtuais da VM. <br><br>  Parece uma √≥tima solu√ß√£o, mas lembre-se de que o XDP suporta apenas o processamento de pacotes recebidos e a conex√£o do eBPF ao caminho <code>rx</code> da m√°quina virtual receptora n√£o ter√° efeito no comutador. <br><br>  Para resolver esse problema, o eBPF deve ser carregado usando <code>tc</code> e conectado ao caminho de sa√≠da da VM, porque <code>tc</code> pode carregar e conectar programas eBPF ao qdisk.  Para marcar os pacotes que saem do host, o eBPF deve estar conectado ao qdisk de sa√≠da. <br><br>  Ao carregar o programa eBPF, existem algumas diferen√ßas entre a API <code>XDP</code> e a <code>tc</code> : por padr√£o, nomes de se√ß√µes diferentes, o tipo de estrutura do argumento da fun√ß√£o principal e diferentes valores de retorno.  Mas isso n√£o √© um problema.  Abaixo est√° um trecho de um programa que marca o TCP ao ingressar em uma a√ß√£o tc: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RATIO 10 SEC(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"action"</span></span></span><span class="hljs-meta">) int bpf_main(struct __sk_buff *skb) { void *data = (void *)(uintptr_t)skb-&gt;data; void *data_end = (void *)(uintptr_t)skb-&gt;data_end; struct ethhdr *eth = data; struct iphdr *iph = (struct iphdr *)(eth + 1); struct tcphdr *tcphdr = (struct tcphdr *)(iph + 1); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* sanity check needed by the eBPF verifier */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((void *)(tcphdr + 1) &gt; data_end) return TC_ACT_OK; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* skip non-TCP packets */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (eth-&gt;h_proto != __constant_htons(ETH_P_IP) || iph-&gt;protocol != IPPROTO_TCP) return TC_ACT_OK; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* incompatible flags, or PSH already set */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (tcphdr-&gt;syn || tcphdr-&gt;fin || tcphdr-&gt;rst || tcphdr-&gt;psh) return TC_ACT_OK; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bpf_get_prandom_u32() % RATIO == 0) tcphdr-&gt;psh = 1; return TC_ACT_OK; } char _license[] SEC(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"license"</span></span></span><span class="hljs-meta">) = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GPL"</span></span></span><span class="hljs-meta">;</span></span></code> </pre> <br>  A compila√ß√£o no bytecode √© feita conforme mostrado no exemplo XDP acima, usando o seguinte: <br><br><pre> <code class="bash hljs">clang -O2 -target bpf -c tcp_psh.c -o tcp_psh.o</code> </pre> <br>  Mas o download √© diferente: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># tc qdisc add dev eth0 clsact # tc filter add dev eth0 egress matchall action bpf object-file tcp_psh.o</span></span></code> </pre> <br>  Agora o eBPF est√° carregado no lugar certo e os pacotes que saem da VM est√£o marcados.  Depois de verificar os pacotes recebidos na segunda VM, veremos o seguinte: <br><br><img src="https://habrastorage.org/webt/iz/kd/dq/izkddqprcvumlcgvdxvtzrecbmg.png"><br><br>  <code>tcpdump</code> confirma que o novo c√≥digo eBPF est√° funcionando e aproximadamente 1 em cada 10 pacotes TCP possui o sinalizador PSH definido.  Foram necess√°rias apenas 20 linhas de c√≥digo C para marcar seletivamente os pacotes TCP que saem da m√°quina virtual, reproduzir o erro que ocorre "em batalha" e tudo sem recompilar ou mesmo reiniciar!  Isso simplificou bastante a verifica√ß√£o da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">corre√ß√£o Open vSwitch</a> , que era imposs√≠vel de obter com outras ferramentas. <br><br>  <b>Conclus√£o</b> <br><br>  O eBPF √© uma tecnologia relativamente nova e a comunidade tem uma opini√£o clara sobre sua implementa√ß√£o.  Tamb√©m √© importante notar que os projetos baseados no eBPF, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bpfilter</a> , est√£o se tornando mais populares e, como resultado, muitos fornecedores de equipamentos est√£o come√ßando a implementar o suporte ao eBPF diretamente nas placas de rede. <br><br>  O eBPF n√£o resolver√° todos os problemas; portanto, n√£o abuse, mas continua sendo uma ferramenta muito poderosa para depura√ß√£o de rede e merece aten√ß√£o.  Estou certo de que desempenhar√° um papel importante no futuro das redes. <br><br>  <b>O FIM</b> <br><br>  Estamos aguardando seus coment√°rios aqui e tamb√©m convidamos voc√™ a visitar nossa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">li√ß√£o aberta</a> , onde voc√™ tamb√©m pode fazer perguntas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436528/">https://habr.com/ru/post/pt436528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436514/index.html">Criando hist√≥rias para Instagram a partir do PHP</a></li>
<li><a href="../pt436518/index.html">Haiku Œ≤1 - torne o / b / OS √≥timo novamente</a></li>
<li><a href="../pt436520/index.html">N√£o use os servi√ßos de verifica√ß√£o online ao vazar dados pessoais</a></li>
<li><a href="../pt436522/index.html">Ao contr√°rio das instru√ß√µes</a></li>
<li><a href="../pt436524/index.html">Experi√™ncia em programa√ß√£o Unix *</a></li>
<li><a href="../pt436530/index.html">Ctrl-Alt-Del: aprendendo a amar o c√≥digo legado</a></li>
<li><a href="../pt436536/index.html">Como simplificar a implanta√ß√£o de aplicativos em nuvem - introduziu uma nova especifica√ß√£o aberta</a></li>
<li><a href="../pt436538/index.html">Dificuldades na opera√ß√£o do sistema de alarme de seguran√ßa</a></li>
<li><a href="../pt436542/index.html">Pinguim, virtualiza√ß√£o e US $ 23 bilh√µes: como e por que a tecnologia em nuvem mudou para sempre o mundo de TI</a></li>
<li><a href="../pt436544/index.html">O Marketplace responder√° por tudo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>