<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÑ üòó üà∫ So implementieren Sie Tinder Swipe Cards in SwiftUI üèçÔ∏è üëáüèª üßì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Juni h√∂rten wir zum ersten Mal von SwiftUI - einer v√∂llig neuen Methode zum Erstellen und Arbeiten mit UI-Elementen in iOS- und macOS-Apps (auch iP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So implementieren Sie Tinder Swipe Cards in SwiftUI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476494/">  Im Juni h√∂rten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir</a> zum ersten Mal von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SwiftUI</a> - einer v√∂llig neuen Methode zum Erstellen und Arbeiten mit UI-Elementen in iOS- und macOS-Apps (auch iPadOS).  Es f√ºhlte sich an wie Weihnachten im Sommer.  Es ist neu, deklarativ, sexy!  Und jetzt, nur wenige Wochen nach der Ver√∂ffentlichung von iOS 13, k√∂nnen wir SwiftUI in all unseren Projekten einsetzen.  Lassen Sie uns lernen, wie wir dieses erstaunliche Tool, das Apple uns gegeben hat, verwenden, um die klassischen zunderartigen Swipe-Karten zu erstellen. <br><br>  In diesem Artikel m√∂chte ich Ihnen zeigen, wie Sie mit nur wenigen Codezeilen eine zunder√§hnliche Kartenansicht und ein zunder√§hnliches Verhalten erzielen (Swipe to Action). <br><br>  Um dies zu erreichen, m√ºssen wir die folgenden Schritte ausf√ºhren: <br><br><ul><li>  Erstellen Sie UserView </li><li>  Navigationsansicht erstellen </li><li>  Erstellen Sie BottomBarView </li><li>  Swipeview erstellen </li><li>  F√ºgen Sie all dies in ContentView zusammen </li></ul><br>  Also fangen wir an. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/11/ezgif-6-6a1d3753a470.gif" alt="Zunder schnell" width="250"></div><br><h2>  Userview </h2><br>  UserView besteht aus zwei Unteransichten, eine ist <i>NameView,</i> die den Benutzernamen, das Alter und die Hobbys enth√§lt, und die zweite Ansicht ist nur eine Avataransicht, in der das Profilbild des Benutzers angezeigt wird. <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NameView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> age: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hobby: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">VStack</span></span>(alignment: .leading) { <span class="hljs-type"><span class="hljs-type">Spacer</span></span>() <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"\(name), \(age)"</span></span>) .font(.title) .fontWeight(.semibold) .foregroundColor(.white) <span class="hljs-type"><span class="hljs-type">Text</span></span>(hobby) .font(.system(size: <span class="hljs-number"><span class="hljs-number">16</span></span>)) .fontWeight(.regular) .foregroundColor(.white) } .padding() } }</code> </pre> <br>  Zuerst m√ºssen wir die <i>NameView</i> definieren, diese repr√§sentiert den Benutzernamen, das Alter und das Hobby.  <i>NameView</i> entspricht dem <i>View-</i> Protokoll, mit dem benutzerdefinierte Ansichten in SwiftUI definiert werden.  Das Ansichtsprotokoll hat nur eine Anforderung und definiert die K√∂rpereigenschaft, die die Ansichtsstruktur zur√ºckgeben und deren Verhalten beschreiben soll.  Weitere Informationen zum <i>View-</i> Protokoll finden Sie in der offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apple-Dokumentation</a> . <br><br>  Lassen Sie uns die Objekte aufschl√ºsseln, mit denen wir diese <i>Ansicht</i> definieren: <br><br><ul><li>  <i>VStack,</i> der wie ein Container f√ºr alle Objekte wirkt, die sie vertikal ausrichten </li><li>  <i>Spacer</i> , der SwiftUI mitteilt, dass diese Ansicht unten ausgerichtet werden soll </li><li>  <i>Text,</i> der die Bezeichnung mit Name und Alter mit den folgenden Eigenschaften darstellt: </li><li>  Zweites Textobjekt, das √§hnliche Eigenschaften aufweist und das Hobby des Benutzers anzeigt </li></ul><br>  Bitte beachten Sie, dass wir hier keine return-Anweisung innerhalb der body-Eigenschaft verwenden, sondern stattdessen einen VStack zur√ºckgeben.  SwiftUI verwendet den in Swift 5.0 implementierten Vorschlag zum Weglassen der R√ºckgabe.  Mehr dazu k√∂nnen Sie <a href="">hier nachlesen</a> . <br><br><h2>  Avataransicht </h2><br>  So wird <i>AvatarView</i> definiert: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AvatarView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image: <span class="hljs-type"><span class="hljs-type">UIImage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">Image</span></span>(uiImage: image) .resizable() .overlay( <span class="hljs-type"><span class="hljs-type">Rectangle</span></span>() .fill(<span class="hljs-type"><span class="hljs-type">LinearGradient</span></span>(gradient: <span class="hljs-type"><span class="hljs-type">Gradient</span></span>(colors: [.clear, .black]), startPoint: .center, endPoint: .bottom)) .clipped() ) .cornerRadius(<span class="hljs-number"><span class="hljs-number">12.0</span></span>) } }</code> </pre><br>  Kommen wir zu den Komponenten, aus denen diese Avatar-Einheit besteht: <br><br><ul><li>  <i>Bild</i> - Zeigt das Bild des Benutzers an </li><li>  <i>Gr√∂√üen√§nderung</i> - Diese Methode gibt an, dass die Gr√∂√üe des Bildes an die Stelle <i>angepasst werden</i> soll, an der es eingebettet ist </li><li>  <i>Overlay (Rechteck)</i> - hier definieren wir einen Farbverlauf, der ein sch√∂ner Hintergrund f√ºr NameView ist. Dieser Farbverlauf beginnt in der Bildmitte und endet unten. Er hat am Anfang eine klare Farbe und unten eine schwarze Farbe </li><li>  <i>cornerRadius</i> - das Bild hat einen Eckenradius </li></ul><br>  Lassen Sie uns nun diese beiden Ansichten in eine einzelne Containeransicht mit dem Namen <i>UserView einbetten</i> . <br><br><h2>  Userview </h2><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userModel: <span class="hljs-type"><span class="hljs-type">UserModel</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">ZStack</span></span>(alignment: .leading) { <span class="hljs-type"><span class="hljs-type">AvatarView</span></span>(image: userModel.image) <span class="hljs-type"><span class="hljs-type">NameView</span></span>(name: userModel.name, age: userModel.age, hobby: userModel.hobby) } .shadow(radius: <span class="hljs-number"><span class="hljs-number">12.0</span></span>) .cornerRadius(<span class="hljs-number"><span class="hljs-number">12.0</span></span>) } }</code> </pre><br>  Folgendes ist los: <br><br><ul><li>  <i>ZStack</i> - Dies ist eine <i>Stapelansicht, bei der die untergeordneten Elemente</i> auf derselben Achse ausgerichtet werden.  Mehr √ºber ZStack erfahren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> </li><li>  <i>AvatarView</i> - Unsere Avatar-Ansicht mit dem √ºber <i>UserModel</i> bereitgestellten <i>Bild</i> </li><li>  <i>Namensansicht</i> - Unsere Namensansicht zeigt den Namen basierend auf dem Benutzermodell an </li></ul><br>  F√ºhren Sie nach all diesen Schritten die App aus.  Sie erhalten folgenden Bildschirm: <br><br><div style="text-align:center;"><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/11/UserView.png" alt="Zunder Avatar" width="250"></div><br>  F√ºgen wir jetzt eine kleine Hilfsmethode hinzu.  Bevor ich Ihnen zeige, wie NavigationView definiert ist, erstellen wir eine Hilfsmethode, die wie folgt aussieht: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">button</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name: String, renderingMode: Image.TemplateRenderingMode = .original)</span></span></span></span> -&gt; some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">Button</span></span>(action: {}) { <span class="hljs-type"><span class="hljs-type">Image</span></span>(name) .renderingMode(renderingMode) } } }</code> </pre><br>  Hier haben wir eine Button Factory-Methode definiert, die aus einem bestimmten Bild und einem Rendermodus einen neuen Button erstellt.  Es gibt keinen Action-Handler, da dies f√ºr diesen Artikel nicht relevant ist. <br><br><h2>  Navigationsansicht </h2><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NavigationView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">HStack</span></span> { <span class="hljs-type"><span class="hljs-type">ViewFactory</span></span>.button(<span class="hljs-string"><span class="hljs-string">"profile_icon"</span></span>) <span class="hljs-type"><span class="hljs-type">Spacer</span></span>() <span class="hljs-type"><span class="hljs-type">ViewFactory</span></span>.button(<span class="hljs-string"><span class="hljs-string">"fire_icon"</span></span>) .scaleEffect(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-type"><span class="hljs-type">Spacer</span></span>() <span class="hljs-type"><span class="hljs-type">ViewFactory</span></span>.button(<span class="hljs-string"><span class="hljs-string">"chat_icon"</span></span>) } } }</code> </pre><br>  SwiftUI stellt die <i>Spacer</i> automatisch auf die gleiche Breite ein und gibt uns die folgende Navigationsansicht: <br><br><div style="text-align:center;"><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/11/NavigationView.png" alt="Navigationsansicht" width="250"></div><br><h2>  Bottombarview </h2><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BottomBarView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">HStack</span></span> { <span class="hljs-type"><span class="hljs-type">ViewFactory</span></span>.button(<span class="hljs-string"><span class="hljs-string">"back_icon"</span></span>, renderingMode: .template) .foregroundColor(.orange) .background( <span class="hljs-type"><span class="hljs-type">GeometryReader</span></span> { geometry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Circle</span></span>() .offset(x: <span class="hljs-number"><span class="hljs-number">2.5</span></span>) .foregroundColor(.white) .shadow(color: .gray, radius: <span class="hljs-number"><span class="hljs-number">12</span></span>) .frame(width: geometry.size.width * <span class="hljs-number"><span class="hljs-number">1.5</span></span>, height: geometry.size.height * <span class="hljs-number"><span class="hljs-number">1.5</span></span>) } ) <span class="hljs-type"><span class="hljs-type">Spacer</span></span>() ... }</code> </pre><br>  Im obigen Codeausschnitt haben wir die erste Schaltfl√§che in unserer Leistenansicht definiert.  Folgendes ist los: <br><br><ul><li>  ViewFactory.button - hier verwenden wir unsere Hilfsmethode, um einen Button mit einem Bild mit renderingMode .template zu definieren, mit dem Sie eine benutzerdefinierte Farbe f√ºr dieses Bild festlegen k√∂nnen <br></li><li>  <i>.foregroundColor</i> - Definiert die Farbe unserer Ansicht <br></li><li>  <i>.background</i> - Diese Methode definiert die Hintergrundansicht des angegebenen Objekts <br></li><li>  <i>GeometryReader</i> - eine Containeransicht, die ihren Inhalt als Funktion ihrer eigenen Gr√∂√üe und ihres eigenen Koordinatenraums definiert.  Wir verwenden dies, um die aktuelle Gr√∂√üe einer Schaltfl√§che abzurufen und den Hintergrundkreis mit dem angegebenen Rahmen zu definieren.  Erfahren Sie hier mehr √ºber Geometrieleser. </li><li>  <i>Kreis</i> - Definiert die Hintergrundform </li><li>  <i>.offset</i> - Versatz der x-Achse des Kreises </li><li>  <i>.foregroundColor</i> - <i>Kreist√∂nungsfarbe</i> <br></li><li>  <i>.shadow</i> - Kreisschatten </li><li>  <i>.frame</i> - <i>Definiert</i> den <i>Kreisrahmen</i> anhand der Gr√∂√üe des Geometrielesers (hier definieren wir einen Hintergrundkreis, der 1,5x gr√∂√üer als die aktuelle Schaltfl√§che ist). <br></li></ul><br>  Lassen Sie uns nun die restlichen Schaltfl√§chen implementieren: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BottomBarView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">HStack</span></span> { <span class="hljs-type"><span class="hljs-type">ViewFactory</span></span>.button(<span class="hljs-string"><span class="hljs-string">"back_icon"</span></span>, renderingMode: .template) .foregroundColor(.orange) .background( <span class="hljs-type"><span class="hljs-type">GeometryReader</span></span> { geometry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Circle</span></span>() .offset(x: <span class="hljs-number"><span class="hljs-number">2.5</span></span>) .foregroundColor(.white) .shadow(color: .gray, radius: <span class="hljs-number"><span class="hljs-number">12</span></span>) .frame(width: geometry.size.width * <span class="hljs-number"><span class="hljs-number">1.5</span></span>, height: geometry.size.height * <span class="hljs-number"><span class="hljs-number">1.5</span></span>) } ) <span class="hljs-type"><span class="hljs-type">Spacer</span></span>() <span class="hljs-type"><span class="hljs-type">ViewFactory</span></span>.button(<span class="hljs-string"><span class="hljs-string">"close_icon"</span></span>, renderingMode: .template) .foregroundColor(.red) .background( <span class="hljs-type"><span class="hljs-type">GeometryReader</span></span> { geometry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Circle</span></span>().foregroundColor(.white) .frame(width: geometry.size.width * <span class="hljs-number"><span class="hljs-number">2</span></span>, height: geometry.size.height * <span class="hljs-number"><span class="hljs-number">2</span></span>) .shadow(color: .gray, radius: <span class="hljs-number"><span class="hljs-number">12</span></span>) } ) <span class="hljs-type"><span class="hljs-type">Spacer</span></span>() <span class="hljs-type"><span class="hljs-type">ViewFactory</span></span>.button(<span class="hljs-string"><span class="hljs-string">"approve_icon"</span></span>, renderingMode: .template) .foregroundColor(.green) .background( <span class="hljs-type"><span class="hljs-type">GeometryReader</span></span> { geometry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Circle</span></span>() .foregroundColor(.white) .shadow(color: .gray, radius: <span class="hljs-number"><span class="hljs-number">12</span></span>) .frame(width: geometry.size.width * <span class="hljs-number"><span class="hljs-number">2</span></span>, height: geometry.size.height * <span class="hljs-number"><span class="hljs-number">2</span></span>) } ) <span class="hljs-type"><span class="hljs-type">Spacer</span></span>() <span class="hljs-type"><span class="hljs-type">ViewFactory</span></span>.button(<span class="hljs-string"><span class="hljs-string">"boost_icon"</span></span>, renderingMode: .template) .foregroundColor(.purple) .background( <span class="hljs-type"><span class="hljs-type">GeometryReader</span></span> { geometry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Circle</span></span>() .foregroundColor(.white) .shadow(color: .gray, radius: <span class="hljs-number"><span class="hljs-number">12</span></span>) .frame(width: geometry.size.width * <span class="hljs-number"><span class="hljs-number">1.5</span></span>, height: geometry.size.height * <span class="hljs-number"><span class="hljs-number">1.5</span></span>) } ) } .padding([.leading, .trailing]) } }</code> </pre><br>  Und als Ergebnis haben wir jetzt diese sch√∂ne Aussicht: <br><br><div style="text-align:center;"><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/11/BottomBarView.png" alt="tab bar dating view" width="250"></div><br><h2>  Swipeview </h2><br>  Dieser Abschnitt ist f√ºr fortgeschrittene SwiftUI.  Hier wird es wirklich interessant.  Wir m√∂chten die Wischgeste in der Aktionsansicht implementieren.  Dieses Verhalten ist ein n√ºtzlicher Anwendungsfall f√ºr einen PageViewController, aber dieser View-Controller wird bald in der Vergangenheit sein, sodass wir hier die wahre Leistungsf√§higkeit von SwiftUI zeigen k√∂nnen. <br><br>  Schauen wir uns also an, wie SwipeView implementiert ist: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwipeView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> users = [...] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> spacing: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">GeometryReader</span></span> { geometry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ScrollView</span></span>(.horizontal, showsIndicators: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-type"><span class="hljs-type">HStack</span></span>(spacing: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.spacing) { <span class="hljs-type"><span class="hljs-type">ForEach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.users) { user <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">UserView</span></span>(userModel: user) .frame(width: geometry.size.width) } } } .content.offset(x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.offset) .frame(width: geometry.size.width, alignment: .leading) .gesture( <span class="hljs-type"><span class="hljs-type">DragGesture</span></span>() .onChanged({ value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.offset = value.translation.width - geometry.size.width * <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.index) }) .onEnded({ value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> -value.predictedEndTranslation.width &gt; geometry.size.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.index &lt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.users.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.index += <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> value.predictedEndTranslation.width &gt; geometry.size.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.index &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.index -= <span class="hljs-number"><span class="hljs-number">1</span></span> } withAnimation { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.offset = -(geometry.size.width + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.spacing) * <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.index) } }) ) } } }</code> </pre><br>  Hier haben wir einige neue interessante SwiftUI-Konzepte verwendet: <br><br><ul><li>  <i>@ State</i> - Ein best√§ndiger Wert eines bestimmten Typs, √ºber den eine Ansicht den Wert liest und √ºberwacht. Dies bedeutet, dass die Ansicht bei jeder √Ñnderung dieser Eigenschaft neu geladen wird, um sie an die jeweilige Statusaktualisierung anzupassen.  Hier k√∂nnen Sie mehr √ºber State <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erfahren</a> . </li><li>  <i>DragGesture</i> - Dieses Objekt wird verwendet, um jeden Schlag zu erkennen, den der Benutzer auf dem Bildschirm macht.  Weitere Informationen hierzu finden Sie hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">developer.apple.com/documentation/swiftui/draggesture</a> </li><li>  <i>@ State Private Var Offset: CGFloat = 0</i> - Diese Eigenschaft wird verwendet, um den aktuellen Bildlauf-Ansichts-Offset zu definieren, wenn Benutzer √ºber den Bildschirm wischen </li><li>  <i>@ State Private Var Index = 0</i> - Diese Eigenschaft definiert, welche Benutzeransicht derzeit auf dem Bildschirm angezeigt wird </li><li>  <i>ScrollView</i> - horizontale Scroll-Ansicht ohne Indikatoren, die ein Container f√ºr unsere Benutzeransicht sein wird </li><li>  <i>HStack</i> - horizontale <i>Stapelansicht,</i> die alle Benutzeransichten enth√§lt </li><li>  <i>content.offset (self.offset)</i> - <i>Stellt</i> eine Verbindung zwischen dem Versatzstatus und dem Versatz des Inhalts der Bildlaufansicht her.  Dies bedeutet, dass bei jeder √Ñnderung der Versatzeigenschaft auch der Versatz der Bildlaufansicht aktualisiert wird </li></ul><br>  Wir z√§hlen die vorhandenen Benutzer auf, indem <i>wir</i> f√ºr jedes Element eine <i>UserView</i> erstellen: <br><br><ul><li>  <i>.frame</i> - hier definieren wir den Bildlauf-Ansichtsrahmen, der an die Breite des Bildschirms <i>angepasst</i> und ordnungsgem√§√ü an seinem Container ausgerichtet werden soll <br></li><li>  <i>.gesture</i> - hier <i>f√ºgen</i> wir unser <i>DragGesture-</i> Objekt hinzu <br></li></ul><br>  <i>DragGesture</i> ist etwas kompliziert, f√ºgt jedoch die gesamte Paginierungslogik in nur wenigen Codezeilen hinzu.  Lassen Sie uns <i>DragGesture aufschl√ºsseln</i> : <br><ul><li>  <i>onChanged ()</i> - Dieser Block wird immer dann <i>aufgerufen</i> , wenn der Benutzer startet, und befindet sich in der Zeit der Dragning-Geste. Hier wird der aktuelle Versatz der Benutzeransicht berechnet, der dem Finger des Benutzers folgt <br></li><li>  <i>onEnded ()</i> - hier werden wir informiert, wenn die <i>Ziehbewegung</i> endet, hier m√ºssen wir berechnen, ob der Benutzer diese Ansicht (links oder rechts) <i>streichen</i> m√∂chte oder ob diese Geste markiert wurde und der Benutzer auf diesem Bildschirm bleiben m√∂chte <br></li><li>  <i>withAnimation</i> - Dieser Abschluss wird mit Animation aufgerufen und erm√∂glicht eine sanfte √Ñnderung des Versatzes <br></li></ul><br><h2>  Inhaltsansicht </h2><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">VStack</span></span> { <span class="hljs-type"><span class="hljs-type">NavigationView</span></span>() .padding(.bottom) <span class="hljs-type"><span class="hljs-type">SwipeView</span></span>() .padding(.bottom) <span class="hljs-type"><span class="hljs-type">BottomBarView</span></span>() } .padding() } }</code> </pre><br>  Unsere Inhaltsansicht ist zu diesem Zeitpunkt √§u√üerst einfach: Sie setzt alle erstellten Ansichten, die wir zuvor erstellt haben, in einem vertikalen Stapel ( <i>VStack</i> ) zusammen.  F√ºr <i>NavigationView</i> und <i>SwipeView haben</i> wir am unteren Rand einige Standardabst√§nde hinzugef√ºgt, und f√ºr den gesamten <i>VStack</i> wurden an allen Kanten Abst√§nde hinzugef√ºgt. <br><br>  Das war's  Fertig  So sieht unsere App jetzt aus: <br><br><div style="text-align:center;"><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/11/ezgif-6-6a1d3753a470.gif" alt="Zunder schnell" width="250"></div><br><h2>  Letzte Gedanken </h2><br>  Wie wir sehen k√∂nnen, ist SwiftUI ein sehr leistungsf√§higes Tool, mit dem wir die Benutzeroberfl√§che auf einfache Weise in einem kurzen deklarativen Code definieren und bearbeiten k√∂nnen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reagieren Native</a> Entwickler w√ºrden dieses deklarative Paradigma sofort erkennen. <br><br>  Aber denken Sie daran: SwiftUI befindet sich noch in der Entwicklung und kann vorerst √§u√üerst instabil sein.  Wenn Sie die gesamte Codebasis f√ºr dieses Projekt √ºberpr√ºfen m√∂chten, finden Sie sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> . <br><br>  Wenn Sie irgendwelche Gedanken oder Fragen zu SwiftUI haben, teilen Sie diese gerne in Kommentaren mit.  Wenn dir dieser Artikel gefallen hat, teile ihn bitte mit deiner Community, damit wir ihn weiter verbreiten k√∂nnen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476494/">https://habr.com/ru/post/de476494/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476482/index.html">"Mit diesem Regenschirm muss man nichts Altmodisches tun, um das Wetter herauszufinden, zum Beispiel aus dem Fenster schauen." √úberpr√ºfen Sie Opus One</a></li>
<li><a href="../de476484/index.html">Vergleich der internen Suche nach Yandex-Produkten (Beta)</a></li>
<li><a href="../de476488/index.html">Ufa PHP Entwicklertreffen</a></li>
<li><a href="../de476490/index.html">Die Funktionalit√§t moderner Anwendungsschutzsysteme (WAF) sollte wesentlich breiter sein als die Liste der Sicherheitsl√ºcken aus OWASP Top 10</a></li>
<li><a href="../de476492/index.html">Speichern von Einstellungen im Speicher der Basisstation</a></li>
<li><a href="../de476500/index.html">Herausforderung mit TopCoder Open 2019: Schneiden Sie den Kuchen in sechs Teile</a></li>
<li><a href="../de476502/index.html">Was der Kunde w√ºnscht, wenn er √ºber die Implementierung eines √úberwachungssystems spricht</a></li>
<li><a href="../de476506/index.html">TechnoText, H√∂hepunkt: kurz vor dem Finale des Autorenwettbewerbs</a></li>
<li><a href="../de476508/index.html">PHP Microservice Framework: Ver√∂ffentlichung von Swoft v2.0.7 im Zeitplan</a></li>
<li><a href="../de476510/index.html">Das Pferd bewegt sich auf St√ºcken. Schach Bitboard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>