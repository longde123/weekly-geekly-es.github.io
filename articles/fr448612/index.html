<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì° üëë üèæ Ce qui a √©t√© gel√© au gel des fonctionnalit√©s 2019. Partie I. JSONPath üßñ ü§ô üññüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apr√®s le comit√© de 2019-03 , le gel des fonctionnalit√©s a eu lieu. Nous avons ici une chronique presque traditionnelle: nous avons d√©j√† √©crit sur le g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ce qui a √©t√© gel√© au gel des fonctionnalit√©s 2019. Partie I. JSONPath</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448612/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/kw/ra/ylkwraooftas8s1ft0ik4pgn5tc.jpeg"></div><br>  Apr√®s le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>comit√© de 2019-03</b></a> , le gel des fonctionnalit√©s a eu lieu.  Nous avons ici une chronique presque traditionnelle: nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©j√† √©crit</a> sur le gel de l‚Äôann√©e derni√®re.  Maintenant, les r√©sultats de 2019: lesquels des nouveaux seront inclus dans PostgreSQL 12. Dans cette partie de la revue JSONPath, des exemples et des fragments du rapport "Postgres 12 in Etudes", qu'Oleg Bartunov a lu √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Saint Highload ++</a> √† Saint-P√©tersbourg le 9 avril de cette ann√©e, sont utilis√©s. <br><a name="habracut"></a><br><h2>  Jsonpath </h2><br>  Tout ce qui concerne JSON (B) est pertinent, en demande dans le monde, en Russie, et c'est l'un des domaines de d√©veloppement les plus importants de Postgres Professional.  Le type jsonb, les fonctions et les op√©rateurs pour travailler avec JSON / JSONB sont apparus dans PostgreSQL version 9.4, ils ont √©t√© cr√©√©s par une √©quipe dirig√©e par Oleg Bartunov. <br><br>  La norme SQL / 2016 pr√©voit de travailler avec JSON: JSONPath y est mentionn√© - un ensemble d'outils d'adressage de donn√©es √† l'int√©rieur de JSON;  JSONTABLE - moyen de convertir JSON en tables r√©guli√®res;  Une grande famille de fonctions et d'op√©rateurs.  Malgr√© le fait que JSON √† Postgres soit soutenu depuis longtemps, en 2017 Oleg Bartunov et ses coll√®gues ont commenc√© √† travailler sur le soutien de la norme.  Se conformer √† la norme est toujours bon.  De tout ce qui est d√©crit dans la norme, un seul mais le correctif le plus important est JSONPath dans la version 12, nous en parlerons donc en premier lieu. <br><br>  Dans les temps anciens, les gens utilisaient JSON, le stockant dans des champs de texte.  Dans 9.3, un type de donn√©es sp√©cial pour JSON est apparu, mais la fonctionnalit√© qui lui √©tait associ√©e n'√©tait pas riche, et les demandes avec ce type fonctionnaient lentement en raison du temps pass√© √† analyser la repr√©sentation textuelle de JSON.  Cela a emp√™ch√© de nombreux utilisateurs Postgres potentiels qui pr√©f√©raient les bases de donn√©es NoSQL.  La productivit√© de Postgres a augment√© √† 9,4 lorsque, gr√¢ce √† O. Bartunov, A. Korotkov et F. Sigaev, Postgres a introduit une version binaire de JSON - le type jsonb. <br>  jsonb n'a pas besoin d'√™tre analys√© √† chaque fois, donc travailler avec lui est beaucoup plus rapide.  Parmi les nouvelles fonctions et op√©rateurs qui sont apparus en m√™me temps, certains ne fonctionnent qu'avec un nouveau type binaire, tel que l'op√©rateur important d'occurrence <b>@&gt;</b> , qui v√©rifie si un √©l√©ment ou un tableau est inclus dans un JSONB donn√©: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, 3]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  donne VRAI, puisque le tableau de droite entre dans le tableau de gauche.  Mais <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, [1, 3]]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  donnera FAUX, puisque le niveau d'imbrication est diff√©rent, il doit √™tre d√©fini explicitement.  Un op√©rateur d'existence est-il introduit pour le type jsonb <b>?</b>  (un point d'interrogation) qui v√©rifie si une cha√Æne est une cl√© d'objet ou un √©l√©ment d'un tableau au niveau sup√©rieur des valeurs JSONB, ainsi que deux autres op√©rateurs similaires (d√©tails <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  Ils sont pris en charge par les index GIN avec deux classes d'op√©rateurs GIN.  L'op√©rateur <b>-&gt;</b> (fl√®che) vous permet de "naviguer" dans JSONB, il retourne une valeur par cl√© ou, s'il s'agit d'un tableau, par index.  Il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">existe plusieurs autres</a> op√©rateurs pour se d√©placer.  Mais il n'y a aucun moyen d'organiser des filtres qui fonctionnent de mani√®re similaire √† WHERE.  C'√©tait une perc√©e: gr√¢ce √† jsonb, Postgres a commenc√© √† gagner en popularit√© en tant que SGBDR avec des fonctionnalit√©s NoSQL. <br><br>  En 2014, A. Korotkov, O. Bartunov et F. Sigaev ont d√©velopp√© l'extension jsquery, qui a √©t√© incluse √† la suite dans Postgres Pro Standard 9.5 (et dans les versions ult√©rieures de Standard et Enterprise).  Il fournit des fonctionnalit√©s suppl√©mentaires tr√®s larges pour travailler avec json (b).  Cette extension d√©finit le langage de requ√™te pour extraire les donn√©es de json (b) et les index pour acc√©l√©rer ces requ√™tes.  Cette fonctionnalit√© √©tait requise par les utilisateurs, ils n'√©taient pas pr√™ts √† attendre la norme et l'inclusion de nouvelles fonctionnalit√©s dans la version vanille.  Le fait que le d√©veloppement ait √©t√© parrain√© par Wargaming.net t√©moigne de la valeur pratique.  L'extension impl√©mente un type sp√©cial - jsquery. <br><br>  Une requ√™te dans ce langage est compacte et ressemble, par exemple, √† ceci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'{"apt":[{"no": 1, "rooms":2}, {"no": 2, "rooms":3}, {"no": 3, "rooms":2}]}'</span></span>::jsonb @@ <span class="hljs-string"><span class="hljs-string">'apt.#.rooms=3'</span></span>::jsquery;</code> </pre> <br>  Nous demandons ici s'il y a ¬´trois roubles¬ª dans l'immeuble.  Le type jsquery doit √™tre sp√©cifi√© car l'op√©rateur @@ est d√©sormais √©galement dans le type jsonb.  La description est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , et la pr√©sentation avec de nombreux exemples est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Total: Postgres avait d√©j√† tout pour travailler avec JSON, puis la norme SQL: 2016 est apparue.  Il s'est av√©r√© que sa s√©mantique n'est pas si diff√©rente de la n√¥tre dans l'extension jsquery.  Il est possible que les auteurs de la norme aient jet√© un coup d'≈ìil √† jsquery, inventant JSONPath.  Notre √©quipe a d√ª mettre en ≈ìuvre un peu diff√©remment ce que nous avions d√©j√† et, bien s√ªr, beaucoup de nouvelles choses aussi. <br><br>  Il y a plus d'un an, lors du commitfest de mars, les fruits de nos efforts de programmation ont √©t√© offerts √† la communaut√© sous forme de 3 gros correctifs avec prise en charge de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">norme SQL: 2016</a> : <br><br>  SQL / JSON: JSONPath; <br>  SQL / JSON: fonctions; <br>  SQL / JSON: JSON_TABLE. <br><br>  Mais d√©velopper un correctif n'est pas l'affaire de tous, leur promotion n'est pas non plus facile, surtout si les correctifs sont volumineux et affectent de nombreux modules.  De nombreuses it√©rations de r√©vision de r√©vision sont n√©cessaires, le patch doit √™tre promu, comme le font les soci√©t√©s commerciales, en investissant beaucoup de ressources (heures / homme).  L'architecte en chef de Postgres Professional, Alexander Korotkov, l'a pris sur lui (puisqu'il a maintenant le statut de committer) et a obtenu l'adoption du patch JSONPath - le principal de cette s√©rie de patchs.  Les deuxi√®me et troisi√®me sont maintenant au stade de l'examen des besoins.  Le JSONPath cibl√© vous permet de travailler avec la structure JSON (B) et est suffisamment flexible pour mettre en √©vidence ses fragments.  Sur les 15 points prescrits dans la norme, 14 sont mis en ≈ìuvre, ce qui est plus que dans Oracle, MySQL et MS SQL. <br><br>  La notation JSONPath diff√®re des instructions Postgres pour l'utilisation de la notation JSON et JSQuery.  La hi√©rarchie est indiqu√©e par des points: <br><br>  $ .abc (en notation postgres 11, je devrais √©crire 'a' -&gt; 'b' -&gt; 'c'); <br>  $ - le contexte actuel de l'√©l√©ment - en fait, l'expression avec $ d√©finit la r√©gion json (b) √† traiter, y compris celle du filtre, le reste n'est pas disponible pour le travail; <br>  @ - le contexte actuel dans l'expression de filtre - it√®re sur les chemins disponibles dans l'expression avec $; <br>  [*] - un tableau; <br>  * - caract√®re g√©n√©rique, dans l'expression avec $ ou @ signifie n'importe quelle valeur du segment de chemin, mais en tenant compte de la hi√©rarchie; <br>  ** - dans le cadre de l'expression avec $ ou @ peut signifier n'importe quelle valeur du segment de chemin sans tenir compte de la hi√©rarchie - il est pratique de l'utiliser si vous ne connaissez pas le niveau d'imbrication des √©l√©ments; <br>  op√©rateur "?"  vous permet d'organiser un filtre similaire √† OERE: <br>  $ .abc?  (@ .x&gt; 10); <br>  $ .abcxtype (), ainsi que size (), double (), plafond (), floor (), abs (), datetime (), keyvalue () sont des m√©thodes. <br>  Une requ√™te avec la fonction jsonb_path_query (sur les fonctions ci-dessous) pourrait ressembler √† ceci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; 3)'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [4, 5] (1 row)</span></span></code> </pre> <br>  Bien qu'un patch sp√©cial avec des fonctions ne soit pas valid√©, le patch JSONPath a d√©j√† des fonctions cl√©s pour travailler avec JSON (B): <br><br><br><pre> <code class="sql hljs">jsonb_path_exists('{"a": 1}', '$.a')  true (  "?") jsonb_path_exists('{"a": 1}', '$.b')  false jsonb_path_match('{"a": 1}', '$.a == 1')  true (  "@&gt;") jsonb_path_match('{"a": 1}', '$.a &gt;= 2')  false jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3, 4, 5 jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  0  jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  [3, 4, 5] jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  [] jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3 jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  NULL</code> </pre> <br>  Notez que l'√©galit√© dans les expressions JSONPath est un simple "=", tandis que dans jsquery, elle est double: "==". <br><br>  Pour des illustrations plus √©l√©gantes, nous allons g√©n√©rer JSONB dans une plaque de maison √† colonne unique: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> house(js jsonb); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'{ "address": { "city":"Moscow", "street": "Ulyanova, 7A" }, "lift": false, "floor": [ { "level": 1, "apt": [ {"no": 1, "area": 40, "rooms": 1}, {"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2} ] }, { "level": 2, "apt": [ {"no": 4, "area": 100, "rooms": 3}, {"no": 5, "area": 60, "rooms": 2} ] } ] }'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/u6/ob/nb/u6obnbokethtz5gatlcbdtvhjyi.png"><br>  <i>Fig. 1 Arbre JSON de logement avec appartements √† feuilles attribu√©es.</i> <br><br>  C'est un JSON √©trange: il a une hi√©rarchie confuse, mais il est tir√© de la vie, et dans la vie, il est souvent n√©cessaire de travailler avec ce qui est et non avec ce qui devrait √™tre.  Arm√©s des capacit√©s de la nouvelle version, nous trouverons des appartements au 1er et au 2√®me √©tage, mais pas le premier dans la liste des appartements de l'√©tage (sur l'arborescence ils sont surlign√©s en vert): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(js, <span class="hljs-string"><span class="hljs-string">'$.floor[0, 1].apt[1 to last]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; <span class="hljs-comment"><span class="hljs-comment">--------------------- [{"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2}, {"no": 5, "area": 60, "rooms": 2}]</span></span></code> </pre><br>  Dans PostgreSQL 11, vous devez demander ceci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_agg(apt) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> apt-&gt;generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, jsonb_array_length(apt) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> js-&gt;<span class="hljs-string"><span class="hljs-string">'floor'</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>])-&gt;<span class="hljs-string"><span class="hljs-string">'apt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house ) apts(apt) ) apts(apt);</code> </pre> <br>  Maintenant, une question tr√®s simple: y a-t-il des lignes contenant (n'importe o√π) la valeur "Moscou"?  Vraiment simple: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_exists(js, <span class="hljs-string"><span class="hljs-string">'$.** ? (@ == "Moscow")'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house;</code> </pre> <br>  Dans la version 11, vous devrez √©crire un √©norme script: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RECURSIVE</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(kv.value, e.value) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_each ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) kv <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_array_elements ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'array'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) e <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> kv.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> e.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">'"Moscow"'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/1k/uv/go/1kuvgo4f2bnjj_aylnvej76gltc.png"><br>  <i>Fig. 2 Arbre du logement JSON, Moscou a √©t√© trouv√©!</i> <br><br>  Nous recherchons n'importe quel appartement √† n'importe quel √©tage d'une superficie de 40 √† 90 m¬≤: <br><br><pre> <code class="plaintext hljs">select jsonb_path_query(js, '$.floor[*].apt[*] ? (@.area &gt; 40 &amp;&amp; @.area &lt; 90)') FROM house; jsonb_path_query ----------------------------------- {"no": 2, "area": 80, "rooms": 3} {"no": 3, "area": 50, "rooms": 2} {"no": 5, "area": 60, "rooms": 2} (3 rows)</code> </pre><br>  Nous recherchons des appartements avec chambres apr√®s le 3, en utilisant notre logement jason: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 4 5 (2 rows)</span></span></code> </pre> <br>  Et voici comment fonctionne jsonb_path_query_first: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_first(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query_first <span class="hljs-comment"><span class="hljs-comment">------------------------ 4 (1 row)</span></span></code> </pre> <br>  Nous voyons que seule la premi√®re valeur est s√©lectionn√©e qui satisfait la condition de filtre. <br><br>  L'op√©rateur bool√©en JSONPath pour JSONB @@ est appel√© l'op√©rateur correspondant.  Il calcule le pr√©dicat JSONPath en appelant la fonction jsonb_path_match_opr. <br><br>  Un autre op√©rateur bool√©en est @?  - ceci est un test d'existence, r√©pond √† la question de savoir si l'expression JSONPath retournera des objets SQL / JSON, il appelle la fonction jsonb_path_exists_opr: <br><br><pre> <code class="sql hljs"> '[1,2,3]' @@ '$[*] == 3'  true;  '[1,2,3]' @? '$[*] @? (@ == 3)' -  true</code> </pre> <br>  Le m√™me r√©sultat peut √™tre obtenu en utilisant diff√©rents op√©rateurs: <br><br><pre> <code class="sql hljs">js @? '$.a'  js @@ 'exists($.a)' js @@ '$.a == 1'  js @? '$ ? ($.a == 1)'</code> </pre> <br>  La beaut√© des op√©rateurs bool√©ens JSONPath est qu'ils sont pris en charge, acc√©l√©r√©s par les indices GIN.  jsonb_ops et jsonb_path_ops sont les classes d'op√©rateurs correspondantes.  Dans l'exemple, nous d√©sactivons SEQSCAN, car nous avons un microtable, sur les grandes tables, l'optimiseur lui-m√™me s√©lectionnera le Bitmap Index: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ENABLE_SEQSCAN <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gin (js); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (COSTS <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> js @? <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.rooms == 3)'</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Bitmap Heap Scan on house Recheck Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) -&gt; Bitmap Index Scan on house_js_idx Index Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) (4 rows)</span></span></code> </pre> <br>  Toutes les fonctions de la forme jsonb_path_xxx () ont la m√™me signature: <br><br><pre> <code class="sql hljs">jsonb_path_xxx( js jsonb, jsp jsonpath, vars jsonb DEFAULT '{}', silent boolean DEFAULT false )</code> </pre> <br>  vars est un objet JSONB pour transmettre des variables JSONPath: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; $x)'</span></span>, vars =&gt; <span class="hljs-string"><span class="hljs-string">'{"x": 2}'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [3, 4, 5]</span></span></code> </pre> <br>  Il est difficile de se passer de vars lorsque nous effectuons une jointure impliquant un champ de type jsonb dans l'une des tables.  Disons que nous faisons une demande qui recherche des appartements appropri√©s pour les employ√©s de cette m√™me maison qui ont √©crit leurs exigences pour la superficie minimale dans le questionnaire: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> demands(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">position</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">demand</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> demands <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">85</span></span>), (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.area &gt;= $min)'</span></span>, vars =&gt; jsonb_build_object(<span class="hljs-string"><span class="hljs-string">'min'</span></span>, demands.demand)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house, demands <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; -[ RECORD 1 ]<span class="hljs-comment"><span class="hljs-comment">----+----------------------------------- jsonb_path_query | {"no": 2, "area": 80, "rooms": 3} -[ RECORD 2 ]----+----------------------------------- jsonb_path_query | {"no": 3, "area": 50, "rooms": 2} -[ RECORD 3 ]----+----------------------------------- jsonb_path_query | {"no": 4, "area": 100, "rooms": 3} -[ RECORD 4 ]----+----------------------------------- jsonb_path_query | {"no": 5, "area": 60, "rooms": 2}</span></span></code> </pre> <br>  Lucky Pacha peut choisir parmi 4 appartements.  Mais cela vaut la peine de changer 1 lettre dans la demande - de "P" √† "C", et il n'y aura pas le choix!  Un seul appartement suffira. <br><br><br>  Un mot cl√© de plus reste: silent est un drapeau qui supprime la gestion des erreurs; ils sont sur la conscience du programmeur. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>); ERROR: SQL/JSON member not found DETAIL: jsonpath member accessor can only be applied to an object</code> </pre> <br>  L'erreur.  Mais ce ne sera pas une erreur: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>, silent =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ (0 rows)</span></span></code> </pre> <br>  Soit dit en passant, sur les erreurs: conform√©ment √† la norme, les erreurs arithm√©tiques dans les expressions ne donnent pas de messages d'erreur, elles sont sur la conscience du programmeur: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[1,0,2]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (1/ @ &gt;= 1)'</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 1 (1 row)</span></span></code> </pre> <br>  Lors du calcul de l'expression dans le filtre, les valeurs du tableau sont recherch√©es, parmi lesquelles il y a 0, mais la division par 0 ne g√©n√®re pas d'erreur. <br><br>  Les fonctions fonctionneront diff√©remment selon le mode s√©lectionn√©: Strict ou Lax (dans la traduction ¬´non strict¬ª ou m√™me ¬´l√¢che¬ª, il est s√©lectionn√© par d√©faut).  Supposons que nous recherchons une cl√© en mode Lax en JSON, o√π elle n'est √©videmment pas: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- f (1 row)</span></span></code> </pre> <br>  Maintenant en mode strict: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- (null) (1 row)</span></span></code> </pre> <br>  Autrement dit, o√π en mode lib√©ral, nous avons re√ßu FAUX, avec strict nous avons obtenu NULL. <br><br>  En mode Lax, un tableau avec une hi√©rarchie complexe [1,2, [3,4,5]] se d√©veloppe toujours en [1,2,3,4,5]: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $[*] ? (@ == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  En mode Strict, le nombre ¬´5¬ª ne sera pas trouv√©, car il n'est pas au bas de la hi√©rarchie.  Pour le trouver, vous devez modifier la requ√™te, en rempla√ßant "@" par "@ [*]": <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $[*] ? (@[*] == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  Dans PostgreSQL 12, JSONPath est un type de donn√©es.  La norme ne dit rien sur la n√©cessit√© d'un nouveau type, c'est une propri√©t√© d'impl√©mentation.  Avec le nouveau type, nous obtenons un travail √† part enti√®re avec jsonpath avec l'aide d'op√©rateurs et d'index acc√©l√©rant leur travail, qui existent d√©j√† pour JSONB.  Sinon, JSONPath devrait √™tre int√©gr√© au niveau du code ex√©cuteur et optimiseur. <br><br>  Vous pouvez lire sur la syntaxe SQL / JSON, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Le billet de blog d'Oleg Bartunov traite de la conformit√© √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">norme SQL / JSON-2016</a> pour PostgreSQL, Oracle, SQL Server et MySQL. <br><br>  Voici une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©sentation</a> sur SQL / JSON. <br><br>  Et voici une <a href="">introduction</a> √† SQL / JSON. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448612/">https://habr.com/ru/post/fr448612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448600/index.html">Comment Windows 10 Explore une vuln√©rabilit√© critique DHCP d√©tecte deux autres erreurs de s√©curit√©</a></li>
<li><a href="../fr448602/index.html">La surveillance est-elle morte? - Surveillance longue dur√©e</a></li>
<li><a href="../fr448606/index.html">Sidorin: KnowledgeConf est sur la fa√ßon de maintenir les connaissances avec une dur√©e moyenne de travail en un seul endroit en 2-3 ans</a></li>
<li><a href="../fr448608/index.html">Comment faire les premiers pas en robotique?</a></li>
<li><a href="../fr448610/index.html">DIY: Comment nous avons cr√©√© un programme en direct pour Codefest X</a></li>
<li><a href="../fr448618/index.html">Algorithme Douglas-Pecker</a></li>
<li><a href="../fr448622/index.html">PHP GR8: JIT am√©liorera-t-il les performances de PHP 8</a></li>
<li><a href="../fr448624/index.html">Voir les donn√©es? Non. Donc je ne vois pas, mais ils le sont. Nous d√©truisons les donn√©es sur les disques SSD et restaurons m√™me la vitesse</a></li>
<li><a href="../fr448626/index.html">DDoS pour aider: comment nous menons le stress et les tests de stress</a></li>
<li><a href="../fr448628/index.html">Esth√©tique et technologie technique sovi√©tique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>