<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìú üö¥üèº üëºüèæ Die Geschichte des gef√§hrlichen std :: enable_shared_from_this oder das Zombie-Antimuster üå¶Ô∏è ü•ö üÖ∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Artikel beschreibt das gef√§hrliche Antimuster "Zombies", das in einigen Situationen nat√ºrlich auftritt, wenn std :: enable_shared_from_this verwen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Geschichte des gef√§hrlichen std :: enable_shared_from_this oder das Zombie-Antimuster</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471326/">  Der Artikel beschreibt das gef√§hrliche Antimuster "Zombies", das in einigen Situationen nat√ºrlich auftritt, wenn std :: enable_shared_from_this verwendet wird.  Das Material befindet sich irgendwo an der Schnittstelle zwischen moderner C ++ - Technologie und Architektur. <br><a name="habracut"></a><br><h3>  Einf√ºhrung </h3><br>  C ++ 11 stellte dem Entwickler wunderbare Tools f√ºr die Arbeit mit Speicher zur Verf√ºgung - intelligente Zeiger std :: unique_ptr und eine Reihe von std :: shared_ptr + std :: schwach_ptr.  Die Verwendung von intelligenten Zeigern f√ºr Bequemlichkeit und Sicherheit √ºberwiegt bei weitem die Verwendung von Rohzeigern.  Intelligente Zeiger sind in der Praxis weit verbreitet  Erm√∂glichen Sie dem Entwickler, sich auf √ºbergeordnete Probleme zu konzentrieren, als die Richtigkeit der Erstellung / L√∂schung dynamisch erstellter Entit√§ten zu verfolgen. <br>  Die Klassenvorlage std :: enable_shared_from_this ist ebenfalls Teil des Standards, und es scheint ziemlich seltsam, wenn Sie sie zum ersten Mal treffen. <br>  In dem Artikel wird erl√§utert, wie Sie bei der Verwendung h√§ngen bleiben k√∂nnen. <br><br><h2>  Bildungsprogramm </h2><br><div class="spoiler">  <b class="spoiler_title">RAII und Smart Pointer</b> <div class="spoiler_text"> Der direkte Zweck von intelligenten Zeigern besteht darin, sich um ein <b>St√ºck RAM</b> zu k√ºmmern, das auf dem Heap zugewiesen ist.  Intelligente Zeiger implementieren das RAII-Idiom (Ressourcenerfassung ist Initialisierung) und k√∂nnen leicht angepasst werden, um andere Arten von Ressourcen zu verwalten, die eine Initialisierung und eine nicht triviale De-Initialisierung erfordern, wie z. <br>  - Dateien; <br>  - tempor√§re Ordner auf der Festplatte; <br>  - Netzwerkverbindungen (http, Websockets); <br>  - Ausf√ºhrungsthreads (Threads); <br>  - Mutexe; <br>  - andere (was f√ºr die Fantasie ausreicht). <br>  F√ºr eine solche Verallgemeinerung reicht es aus, eine Klasse zu schreiben (manchmal kann man sogar keine Klasse schreiben, sondern nur Deleter verwenden - aber heute geht es in der Geschichte nicht darum), was Folgendes implementiert: <br>  - Initialisierung im Konstruktor oder in einer separaten Methode; <br>  - Deinitialisierung im Destruktor, <br>  Wickeln Sie es dann in den entsprechenden Smart Pointer ein, abh√§ngig vom erforderlichen Eigentumsmodell - Joint (std :: shared_ptr) oder Sole (std :: unique_ptr).  Dies f√ºhrt zu einem ‚Äûzweischichtigen RAII‚Äú: Mit einem intelligenten Zeiger k√∂nnen Sie das Eigentum an der Ressource √ºbertragen / teilen, und die Benutzerklasse initialisiert / de-initialisiert eine nicht standardm√§√üige Ressource. <br>  std :: shared_ptr verwendet einen Linkz√§hlmechanismus.  Der Standard definiert den Z√§hler f√ºr starke Links (z√§hlt die Anzahl der vorhandenen Kopien von std :: shared_ptr) und den Z√§hler f√ºr schwache Links (z√§hlt die Anzahl der vorhandenen Kopien von std :: schwach_ptr, die f√ºr diese Instanz von std :: shared_ptr erstellt wurden).  Das Vorhandensein mindestens einer starken Verbindung stellt sicher, dass die Zerst√∂rung noch nicht erfolgt ist.  Diese std :: shared_ptr-Eigenschaft wird h√§ufig verwendet, um die G√ºltigkeit eines Objekts sicherzustellen, bis die Arbeit damit in allen Teilen des Programms abgeschlossen ist.  Das Vorhandensein eines schwachen Glieds verhindert nicht die Zerst√∂rung des Objekts und erm√∂glicht es Ihnen, ein starkes Glied nur zu erhalten, bis es zerst√∂rt wird. <br>  RAII garantiert, dass die Freigabe einer Ressource viel zuverl√§ssiger ist als ein expliziter Aufruf zum L√∂schen / L√∂schen [] / frei / schlie√üen / zur√ºcksetzen / entsperren, weil: <br>  - Sie k√∂nnen den expliziten Anruf einfach vergessen; <br>  - Ein expliziter Anruf kann f√§lschlicherweise mehrmals get√§tigt werden. <br>  - Eine explizite Herausforderung ist schwierig, wenn das gemeinsame Eigentum an einer Ressource implementiert wird. <br>  - Der Stack-Promotion-Mechanismus in c ++ garantiert den Aufruf von Destruktoren f√ºr alle Objekte, die im Ausnahmefall den G√ºltigkeitsbereich verlassen. <br>  Die Garantie der De-Initialisierung im Idiom ist so wichtig, dass sie neben der Initialisierung einen guten Platz im Namen des Idioms verdient. <br>  Intelligente Zeiger haben auch Nachteile: <br>  - das Vorhandensein von Overhead in Bezug auf Leistung und Speicher (f√ºr die meisten Anwendungen ist dies nicht signifikant); <br>  - die M√∂glichkeit, dass zyklische Verbindungen die Freisetzung der Ressource blockieren und zu deren Leck f√ºhren. <br>  Sicherlich hat jeder Entwickler mehr als einmal √ºber zirkul√§re Links gelesen und synthetische Beispiele f√ºr problematischen Code gesehen. <br>  Die Gefahr kann aus folgenden Gr√ºnden unbedeutend erscheinen: <br>  - Wenn der Speicher h√§ufig und h√§ufig leckt - dies macht sich im Verbrauch bemerkbar und wenn selten und wenig -, ist es unwahrscheinlich, dass das Problem auf der Ebene des Endbenutzers auftritt. <br>  - verwendet eine dynamische Code-Analyse f√ºr Lecks (Valgrind, Clang LeakSanitizer usw.); <br>  - "Ich schreibe nicht so"; <br>  - "meine Architektur ist korrekt"; <br>  "Unser Code wird √ºberpr√ºft." <br></div></div><br><div class="spoiler">  <b class="spoiler_title">std :: enable_shared_from_this</b> <div class="spoiler_text">  In C ++ 11 wird die Hilfsklasse std :: enable_shared_from_this eingef√ºhrt.  F√ºr einen Entwickler, der erfolgreich Code ohne std :: enable_shared_from_this erstellt, sind die m√∂glichen Verwendungen dieser Klasse m√∂glicherweise nicht offensichtlich. <br>  Was macht std :: enable_shared_from_this? <br>  Es erm√∂glicht Mitgliedsfunktionen der Klasse, die in std :: shared_ptr instanziiert ist, zus√§tzliche starke (shared_from_this ()) oder schwache (schwach_from_this (), beginnend mit C ++ 17) Kopien des std :: shared_ptr, in dem es erstellt wurde .  Sie k√∂nnen shared_from_this () und schwach_from_this () nicht vom Konstruktor und Destruktor aus aufrufen. <br><br>  <b>Warum so schwer?</b>  <b>Sie k√∂nnen einfach std :: shared_ptr &lt;T&gt; (this) erstellen.</b> <br>  Nein, geht nicht.  Alle std :: shared_ptrs, die sich um dieselbe Instanz der Klasse k√ºmmern, m√ºssen eine Verbindungsz√§hleinheit verwenden.  Ohne besondere Magie geht es nicht. <br><br>  Voraussetzung f√ºr die Verwendung von std :: enable_shared_from_this ist das erstmalige Erstellen eines Klassenobjekts in std :: shared_ptr.  Erstellen auf dem Stapel, dynamisches Zuweisen auf dem Heap, Erstellen auf std :: unique_ptr - all dies ist nicht geeignet.  Nur streng in std :: shared_ptr. <br><br>  <b>Ist es m√∂glich, den Benutzer beim Erstellen von Instanzen der Klasse einzuschr√§nken?</b> <br>  Ja, das kannst du.  Um dies zu tun, einfach: <br>  - Bereitstellung einer statischen Methode zum Erstellen von Instanzen, die urspr√ºnglich in std :: shared_ptr platziert wurden; <br>  - den Konstruktor privat oder gesch√ºtzt stellen; <br>  - Kopier- und Verschiebungssemantik verbieten. <br>  Die Klasse ging in den K√§fig, schloss ihn ab und schluckte den Schl√ºssel - von nun an leben alle seine Instanzen nur noch in std :: shared_ptr, und es gibt keine legalen M√∂glichkeiten, sie dort rauszuholen. <br>  Eine solche Einschr√§nkung kann nicht als gute architektonische L√∂sung bezeichnet werden, aber diese Methode entspricht vollst√§ndig dem Standard. <br>  Dar√ºber hinaus k√∂nnen Sie das PIMPL-Idiom verwenden: Der einzige Benutzer der launischen Klasse - die Fassade - erstellt die Implementierung ausschlie√ülich in std :: shared_ptr, und der Fassade selbst werden bereits solche Einschr√§nkungen entzogen. <br><br>  std :: enable_shared_from_this weist erhebliche Vererbungsnuancen auf, deren Er√∂rterung jedoch den Rahmen dieses Artikels sprengt. <br></div></div><br><h2>  Komm auf den Punkt </h2><br>  Alle im Artikel bereitgestellten Codebeispiele werden auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github ver√∂ffentlicht</a> . <br>  Der Code zeigt schlechte Techniken, die als die √ºbliche sichere Verwendung von modernem C ++ getarnt sind <br><br><h3>  Simplecyclic </h3><br>  Es scheint, dass nichts auf Probleme hindeutet.  Eine Klassendeklaration sieht einfach und unkompliziert aus.  Mit Ausnahme eines ‚Äûkleinen‚Äú Details wird aus irgendeinem Grund die Vererbung von std :: enable_shared_from_this angewendet. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;functional&gt; namespace SimpleCyclic { class Cyclic final : public std::enable_shared_from_this&lt;Cyclic&gt; { public: static std::shared_ptr&lt;Cyclic&gt; create(); Cyclic(const Cyclic&amp;) = delete; Cyclic(Cyclic&amp;&amp;) = delete; Cyclic&amp; operator=(const Cyclic&amp;) = delete; Cyclic&amp; operator=(Cyclic&amp;&amp;) = delete; ~Cyclic(); void doSomething(); private: Cyclic(); std::function&lt;void(void)&gt; _fn; }; } // namespace SimpleCyclic</span></span></span></span></code> </pre> <br></div></div><br>  Und in der Umsetzung: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "SimpleCyclic.h" namespace SimpleCyclic { Cyclic::Cyclic() = default; Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;Cyclic&gt; Cyclic::create() { return std::shared_ptr&lt;Cyclic&gt;(new Cyclic); } void Cyclic::doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace SimpleCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SimpleCyclic/SimpleCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto simpleCyclic = SimpleCyclic::Cyclic::create(); simpleCyclic-&gt;doSomething(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text"><blockquote>  N12SimpleCyclic6CyclicE :: doSomething <br></blockquote><br></div></div><br>  Im Hauptteil der Funktion doSomething () erstellt die Klasseninstanz <b>selbst</b> eine zus√§tzliche starke Kopie des std :: shared_ptr, in dem sie platziert wurde.  Dann wird diese Kopie unter Verwendung einer verallgemeinerten Erfassung in eine Lambda-Funktion gelegt, die dem Klassendatenfeld unter dem Deckmantel einer harmlosen std :: -Funktion zugewiesen ist.  Ein Aufruf von doSomething () f√ºhrt zu einem Zirkelverweis, und die Klasseninstanz wird auch nach der Zerst√∂rung aller externen starken Links nicht mehr zerst√∂rt. <br>  Es liegt ein Speicherverlust vor.  Der SimpleCyclic :: Cyclic :: ~ Cyclic-Destruktor wird nicht aufgerufen. <br><br>  <b>Die Klasseninstanz "beh√§lt" sich selbst.</b> <b><br></b>  <b>Der Code blieb in einem Knoten stecken.</b> <br><br><img src="https://habrastorage.org/webt/xp/jj/_a/xpjj_atj4bf0av8kar46ebxqqew.jpeg"><br>  (Bild <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier aufgenommen</a> ) <br><br>  <b>Und was, das ist das "Zombie" Antimuster?</b> <br>  Nein, das ist nur ein Training.  Das Interessanteste steht noch bevor. <br><br>  <b>Warum hat der Entwickler das geschrieben?</b> <br>  Synthetisches Beispiel.  Mir sind keine Situationen bekannt, in denen ein solcher Code harmonisch erhalten w√ºrde. <br><br>  <b>Hat die dynamische Code-Analyse also geschwiegen?</b> <br>  Nein, Valgrind hat ehrlich gesagt einen Speicherverlust gemeldet: <br><br><div class="spoiler">  <b class="spoiler_title">Post Valgrind</b> <div class="spoiler_text"><blockquote>  96 (64 direkte, 32 indirekte) Bytes in 1 Bl√∂cken gehen <b>definitiv</b> im Verlustrekord 29 von 46 verloren <br>  in SimpleCyclic :: Cyclic :: create () in /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  1: malloc in /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: Operator neu (vorzeichenlos lang) in /usr/lib/libc++abi.dylib <br>  3: SimpleCyclic :: Cyclic :: create () in /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  4: main in /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/main.cpphaps <br></blockquote><br></div></div><br><h3>  Pimplcyclic </h3><br>  In diesem Fall sieht die Header-Datei vollst√§ndig korrekt und pr√§zise aus.  Es wurde eine Fassade deklariert, die eine bestimmte Implementierung in std :: shared_ptr speichert.  Die Vererbung - auch von std :: enable_shared_from_this - fehlt im Gegensatz zum vorherigen Beispiel. <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace PimplCyclic { class Cyclic { public: Cyclic(); ~Cyclic(); private: class Impl; std::shared_ptr&lt;Impl&gt; _impl; }; } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br>  Und in der Umsetzung: <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "PimplCyclic.h" namespace PimplCyclic { class Cyclic::Impl : public std::enable_shared_from_this&lt;Cyclic::Impl&gt; { public: ~Impl() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } private: std::function&lt;void(void)&gt; _fn; }; Cyclic::Cyclic() : _impl(std::make_shared&lt;Impl&gt;()) { if (_impl) { _impl-&gt;doSomething(); } } Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PimplCyclic/PimplCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto pimplCyclic = PimplCyclic::Cyclic(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text"><blockquote>  N11PimplCyclic6Cyclic4ImplE :: doSomething <br>  N11PimplCyclic6CyclicE :: ~ Cyclic <br></blockquote><br></div></div><br>  Durch Aufrufen von Impl :: doSomething () wird ein Zirkelverweis in einer Instanz der Impl-Klasse erstellt.  Die Fassade ist korrekt zerst√∂rt, aber die Implementierung ist undicht.  Der Destruktor PimplCyclic :: Cyclic :: Impl :: ~ Impl wird nicht aufgerufen. <br>  Das Beispiel ist wieder synthetisch, aber diesmal gef√§hrlicher - alle schlechten Ger√§te befinden sich in der Implementierung und erscheinen nicht in der Anzeige. <br>  Dar√ºber hinaus erforderte der Benutzercode zum Erstellen einer zirkul√§ren Verkn√ºpfung keine andere Aktion als die Konstruktion. <br>  Eine dynamische Analyse angesichts von Valgrind und diesmal ergab ein Leck: <br><br><div class="spoiler">  <b class="spoiler_title">Post Valgrind</b> <div class="spoiler_text"><blockquote>  96 Bytes in 1 Bl√∂cken gehen <b>definitiv</b> im Verlustrekord 29 von 46 verloren <br>  in PimplCyclic :: Cyclic :: Cyclic () in /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  1: malloc in /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: Operator neu (vorzeichenlos lang) in /usr/lib/libc++abi.dylib <br>  3: std :: __ 1 :: __ libcpp_allocate (Long ohne Vorzeichen, Long ohne Vorzeichen) in /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/new:252 <br>  4: std :: __ 1 :: allocator &lt;std :: __ 1 :: __ shared_ptr_emplace &lt;PimplCyclic :: Cyclic :: Impl, std :: __ 1 :: allocator &lt;PimplCyclic :: Cyclic :: Impl &gt;&gt;&gt; allocate (unsigned long , void const *) in /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:1813 <br>  5: std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; :: make_shared &lt;&gt; () in /Applications/Xcode.app/Contents /Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4326 <br>  6: _ZNSt3__1L11make_sharedIN11PimplCyclic6Cyclic4ImplEJEEENS_9enable_ifIXntsr8is_arrayIT_EE5valueENS_10shared_ptrIS5_EEE4typeEDpOT0_ in /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4706 <br>  7: PimplCyclic :: Cyclic :: Cyclic () in /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  8: PimplCyclic :: Cyclic :: Cyclic () in /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:29 <br>  9: main in /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/main.cpphaps <br></blockquote><br></div></div><br>  <b>Es ist etwas verd√§chtig, Pimpl zu sehen, in dem die Implementierung in std :: shared_ptr gespeichert ist.</b> <br>  Der klassische Pimpl, der auf einem Rohzeiger basiert, ist zu archaisch, und std :: unique_ptr hat den Nebeneffekt, dass das Verbot der Kopiersemantik auf der Fassade verbreitet wird.  Eine solche Fassade wird die Redewendung des alleinigen Eigentums umsetzen, die m√∂glicherweise nicht der architektonischen Idee entspricht.  Aus der Verwendung von std :: shared_ptr zum Speichern der Implementierung schlie√üen wir, dass die Klasse so konzipiert ist, dass sie eine gemeinsame Eigent√ºmerschaft bietet. <br><br>  <b>Wie unterscheidet sich dies von der klassischen Leckage - Speicherzuweisung durch expliziten Aufruf von new ohne nachtr√§gliches L√∂schen?</b>  <b>Ebenso w√§re alles sch√∂n in der Oberfl√§che und in der Implementierung - ein Fehler.</b> <br>  Wir diskutieren <b>moderne</b> M√∂glichkeiten, sich in den Fu√ü zu schie√üen. <br><br><h2>  Antipattern "Zombies" </h2><br>  Aus dem obigen Material geht also klar hervor: <br>  - Intelligente Zeiger k√∂nnen in Knoten eingebunden werden. <br>  - Die Verwendung von std :: enable_shared_from_this kann dazu beitragen, weil  Erm√∂glicht es einer Instanz einer Klasse, sich ohne fremde Hilfe an einen Knoten zu binden. <br><br>  <b>Und jetzt - Aufmerksamkeit - die Schl√ºsselfrage des Artikels: Ist die Art der Ressource, die in einen intelligenten Zeiger eingeschlossen ist, von Bedeutung?</b>  <b>Gibt es einen Unterschied zwischen einer RAII-Dateipflege und einer asynchronen HTTPS-Verbindung?</b> <br><br><h3>  Simplezomby </h3><br>  Der Code, der allen nachfolgenden Beispielen von Zombies gemeinsam ist, wurde in die Common-Bibliothek verschoben. <br><br>  Abstrakte Zombie-Schnittstelle mit dem bescheidenen Namen Manager: <br><br><div class="spoiler">  <b class="spoiler_title">Common / Manager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace Common { class Listener; class Manager { public: Manager() = default; Manager(const Manager&amp;) = delete; Manager(Manager&amp;&amp;) = delete; Manager&amp; operator=(const Manager&amp;) = delete; Manager&amp; operator=(Manager&amp;&amp;) = delete; virtual ~Manager() = default; virtual void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Abstrakte Oberfl√§che des H√∂rers, bereit, threadsicheren Text zu akzeptieren: <br><br><div class="spoiler">  <b class="spoiler_title">Common / Listener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;memory&gt; namespace Common { class Listener { public: virtual ~Listener() = default; using Data = std::string; // thread-safe virtual void processData(const std::shared_ptr&lt;const Data&gt; data) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Listener, der der Konsole Text anzeigt.  Implementiert das SingletonShared-Konzept aus meinem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Technik zum Vermeiden von undefiniertem Verhalten beim Aufrufen eines Singleton</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; #include "Common/Listener.h" namespace Common { class WriteToConsoleListener final : public Listener { public: WriteToConsoleListener(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener(WriteToConsoleListener&amp;&amp;) = delete; WriteToConsoleListener&amp; operator=(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener&amp; operator=(WriteToConsoleListener&amp;&amp;) = delete; ~WriteToConsoleListener() override; static std::shared_ptr&lt;WriteToConsoleListener&gt; instance(); // blocking void processData(const std::shared_ptr&lt;const Data&gt; data) override; private: WriteToConsoleListener(); std::mutex _mutex; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "WriteToConsoleListener.h" namespace Common { WriteToConsoleListener::WriteToConsoleListener() = default; WriteToConsoleListener::~WriteToConsoleListener() { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;WriteToConsoleListener&gt; WriteToConsoleListener::instance() { static auto inst = std::shared_ptr&lt;WriteToConsoleListener&gt;(new WriteToConsoleListener); return inst; } void WriteToConsoleListener::processData(const std::shared_ptr&lt;const Data&gt; data) { if (data) { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; *data &lt;&lt; std::flush; } } } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Und schlie√ülich der erste Zombie, der einfachste und genialste. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SimpleZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; }; } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include "SimpleZomby.h" #include "Common/Listener.h" namespace SimpleZomby { std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::Zomby() = default; Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SimpleZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ while (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;("SimpleZomby is alive!\n")); std::this_thread::sleep_for(std::chrono::seconds(1)); } }); } } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br>  Ein Zombie f√ºhrt eine Lambda-Funktion in einem separaten Thread aus und sendet regelm√§√üig eine Zeichenfolge an den Listener.  Lambda-Funktionen f√ºr die Arbeit ben√∂tigen ein Semaphor und einen Listener, die Felder der Zombie-Klasse sind.  Die Lambda-Funktion erfasst sie nicht als separate Felder, sondern verwendet das Objekt als Aggregator.  Das Zerst√∂ren einer Instanz der Zombie-Klasse vor Abschluss der Lambda-Funktion f√ºhrt zu undefiniertem Verhalten.  Um dies zu vermeiden, erfasst die Lambda-Funktion eine starke Kopie von shared_from_this (). <br>  Im Zombie-Destruktor wird das Semaphor auf false gesetzt, woraufhin attach () f√ºr den Stream aufgerufen wird.  Durch das Festlegen des Semaphors wird der Thread angewiesen, herunterzufahren. <br><br>  <b>Im Destruktor musste nicht separ (), sondern join () aufgerufen werden!</b> <br>  ... und erhalten Sie einen Destruktor, der die Ausf√ºhrung auf unbestimmte Zeit blockiert, was m√∂glicherweise nicht akzeptabel ist. <br><br>  <b>Das ist also eine Verletzung von RAII!</b>  <b>RAII sollte den Destruktor erst nach Freigabe der Ressource verlassen!</b> <br>  Wenn streng - dann ja, der Zombie-Destruktor gibt die Ressource nicht frei, sondern <b>garantiert</b> nur <b>, dass die Freigabe erfolgt</b> .  Irgendwann produziert - vielleicht bald oder vielleicht nicht wirklich.  Und es ist sogar m√∂glich, dass main die Arbeit fr√ºher beendet - dann wird der Thread vom Betriebssystem zwangsweise gel√∂scht.  Tats√§chlich kann die Grenze zwischen ‚Äûrichtig‚Äú und ‚Äûfalsch‚Äú RAII jedoch sehr d√ºnn sein: Beispielsweise kann ‚Äûkorrektes‚Äú RAII, das std :: filesystem :: remove () in einem Destruktor f√ºr eine tempor√§re Datei aufruft, die Kontrolle dar√ºber zur√ºckgeben Der Moment, in dem sich der Schreibbefehl noch in einem der fl√ºchtigen Caches befindet und nicht ehrlich auf die Magnetplatte der Festplatte geschrieben wird. <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "Common/Impl/WriteToConsoleListener.h" #include "SimpleZomby/SimpleZomby.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto simpleZomby = SimpleZomby::Zomby::create(); simpleZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zomby should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text"><blockquote>  SimpleZomby lebt! <br>  SimpleZomby lebt! <br>  SimpleZomby lebt! <br>  SimpleZomby lebt! <br>  SimpleZomby lebt! <br>  ================================================== =========== <br>  |  Zomby wurde get√∂tet <br>  ================================================== =========== <br>  SimpleZomby lebt! <br>  SimpleZomby lebt! <br>  SimpleZomby lebt! <br>  SimpleZomby lebt! <br>  SimpleZomby lebt! <br></blockquote><br></div></div><br>  Was kann aus der Ausgabe des Programms gesehen werden: <br>  - Der Zombie arbeitete auch nach Verlassen des Sichtfeldes weiter. <br>  - Weder f√ºr Zombies noch f√ºr WriteToConsoleListener wurden Destruktoren aufgerufen. <br>  Ein Speicherverlust ist aufgetreten. <br>  Es gab ein Ressourcenleck.  Und die Ressource ist in diesem Fall der Thread der Ausf√ºhrung. <br>  Der Code, der aufh√∂ren sollte, funktionierte weiterhin in einem separaten Thread. <br>  Ein WriteToConsoleListener-Leck h√§tte durch die Verwendung der SingletonWeak-Technik aus meinem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vermeiden von unbestimmtem Verhalten beim Aufrufen eines Singleton verhindert werden k√∂nnen</a> , aber ich habe dies absichtlich nicht getan. <br><br><img src="https://habrastorage.org/webt/mg/qu/e3/mgque3fstboi4ot2hvdwniafixe.jpeg"><br>  (Bild <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier aufgenommen</a> ) <br><br>  <b>Warum Zombies?</b> <br>  Weil er get√∂tet wurde und noch lebt. <br><br>  <b>Wie unterscheidet sich dies von den Zirkelverweisen in den vorherigen Beispielen?</b> <br>  Die Tatsache, dass eine verlorene Ressource nicht nur ein Teil des Speichers ist, sondern etwas, das Code unabh√§ngig von dem Thread ausf√ºhrt, der ihn gestartet hat. <br><br>  <b>Ist es m√∂glich, die "Zombies" zu zerst√∂ren?</b> <br>  Nach dem Verlassen des Bereichs (d. H. Nach dem Zerst√∂ren aller externen starken und schwachen Verweise auf Zombies) ist dies unm√∂glich.  Ein Zombie wird zerst√∂rt, wenn er beschlie√üt, sich selbst zu zerst√∂ren (ja, es ist etwas mit aktivem Verhalten), vielleicht nie, d. H.  bleibt so lange bestehen, bis das Betriebssystem bereinigt wird, wenn die Anwendung beendet wird.  Nat√ºrlich kann Benutzercode einen gewissen Einfluss auf die Bedingung zum Beenden des Zombie-Codes haben, aber dieser Effekt ist indirekt und implementierungsabh√§ngig. <br><br>  <b>Und bevor Sie den Bereich verlassen?</b> <br>  Sie k√∂nnen den Zombie-Destruktor explizit aufrufen, aber es ist unwahrscheinlich, dass Sie undefiniertes Verhalten aufgrund der wiederholten Zerst√∂rung des Objekts durch den Smart-Pointer-Destruktor vermeiden k√∂nnen - dies ist ein Kampf gegen RAII.  Oder Sie k√∂nnen die Funktion der expliziten De-Initialisierung hinzuf√ºgen - und dies ist eine Ablehnung von RAII. <br><br>  <b>Wie unterscheidet sich das vom Starten eines Threads, gefolgt von remove ()?</b> <br>  Im Fall von Zombies besteht im Gegensatz zu einem einfachen Aufruf zum L√∂sen () die Idee, den Fluss zu stoppen.  Nur funktioniert es nicht.  Die richtige Idee hilft, das Problem zu maskieren. <br><br>  <b>Ist das Beispiel noch synthetisch?</b> <br>  Zum Teil.  In diesem einfachen Beispiel gab es nicht gen√ºgend Gr√ºnde, shared_from_this () zu verwenden. Sie k√∂nnen beispielsweise schwach_from_this () erfassen oder alle erforderlichen Felder in der Klasse erfassen.  Mit der Komplexit√§t der Aufgabe kann sich das Gleichgewicht jedoch zur Seite verschieben <br>  shared_from_this (). <br><br>  <b>Valgrind, Valgrind!</b>  <b>Wir haben eine zus√§tzliche Verteidigungslinie gegen Zombies!</b> <br>  Ach und ah - aber Valgrind hat kein Speicherleck aufgedeckt.  Warum - ich wei√ü es nicht.  In der Diagnose gibt es nur <b>‚Äûm√∂glicherweise verlorene‚Äú</b> Eintr√§ge, die auf Systemfunktionen hinweisen - ungef√§hr die gleiche und ungef√§hr die gleiche Menge wie beim Ausarbeiten einer leeren Hauptleitung.  Es gibt keine Benutzercode-Referenzen.  Andere dynamische Analysetools sind m√∂glicherweise besser, aber wenn Sie sich immer noch auf sie verlassen, lesen Sie weiter. <br><br><h3>  Steppingzomby </h3><br>  Der Code in diesem Beispiel f√ºhrt die Schritte auf: resolveDnsName ---&gt; connectTcp ---&gt; EstablishSsl ---&gt; sendHttpRequest ---&gt; readHttpReply und simuliert den Betrieb der Client-HTTPS-Verbindung in asynchroner Ausf√ºhrung.  Jeder Schritt dauert ungef√§hr eine Sekunde. <br><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SteppingZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; void resolveDnsName(); void connectTcp(); void establishSsl(); void sendHttpRequest(); void readHttpReply(); }; } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include &lt;string&gt; #include "SteppingZomby.h" #include "Common/Listener.h" namespace { void doSomething(Common::Listener&amp; listener, std::string&amp;&amp; callingFunctionName) { listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " started\n")); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " finished\n")); } } // namespace namespace SteppingZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SteppingZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;resolveDnsName(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;connectTcp(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;establishSsl(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;sendHttpRequest(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;readHttpReply(); } }); } void Zomby::resolveDnsName() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::connectTcp() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::establishSsl() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::sendHttpRequest() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::readHttpReply() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "SteppingZomby/SteppingZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto steppingZomby = SteppingZomby::Zomby::create(); steppingZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(1500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text"><blockquote>  N13SteppingZomby5ZombyE :: resolveDnsName gestartet <br>  N13SteppingZomby5ZombyE :: resolveDnsName beendet <br>  N13SteppingZomby5ZombyE :: connectTcp wurde gestartet <br>  ================================================== =========== <br>  |  Zomby wurde get√∂tet <br>  ================================================== =========== <br>  N13SteppingZomby5ZombyE :: connectTcp fertig <br>  N13SteppingZomby5ZombyE :: etablSsl wurde gestartet <br>  N13SteppingZomby5ZombyE :: etablSsl fertig <br>  N13SteppingZomby5ZombyE :: sendHttpRequest gestartet <br>  N13SteppingZomby5ZombyE :: sendHttpRequest beendet <br>  N13SteppingZomby5ZombyE :: readHttpReply gestartet <br>  N13SteppingZomby5ZombyE :: readHttpReply beendet <br>  N13SteppingZomby5ZombyE :: ~ Zomby <br>  N6Common22WriteToConsoleListenerE :: ~ WriteToConsoleListener <br></blockquote><br></div></div><br>  Wie im vorherigen Beispiel f√ºhrte ein Aufruf von runOnce () zu einem Zirkelverweis. <br>  Diesmal wurden jedoch die Destruktoren Zomby und WriteToConsoleListener aufgerufen.  Alle Ressourcen wurden korrekt freigegeben, bis die Anwendung beendet wurde.  Ein Speicherverlust ist nicht aufgetreten. <br><br>  <b>Was ist dann das Problem?</b> <br>  Das Problem ist, dass der Zombie zu lange lebte - ungef√§hr dreieinhalb Sekunden nach der Zerst√∂rung aller externen starken und schwachen Verbindungen zu ihm.  Etwa drei Sekunden l√§nger als er h√§tte leben sollen.  Und die ganze Zeit war er damit besch√§ftigt, die Implementierung der HTTPS-Verbindung zu f√∂rdern - bis er sie zu Ende brachte.  Trotz der Tatsache, dass das Ergebnis nicht mehr ben√∂tigt wurde.  Trotz der Tatsache, dass die √ºberlegene Gesch√§ftslogik versuchte, die Zombies aufzuhalten. <br><br>  <b>Denken Sie dar√ºber nach, Sie haben die Antwort, die Sie nicht brauchen ...</b> <br>  Im Falle einer Client-HTTPS-Verbindung k√∂nnen die Konsequenzen <b>f√ºr uns</b> folgende sein: <br>  - Speicherverbrauch; <br>  - CPU-Verbrauch; <br>  - TCP-Portverbrauch; <br>  - die Bandbreite des Kommunikationskanals (sowohl die Anforderung als auch die Antwort k√∂nnen ein Volumen in Megabyte sein); <br>  - Unerwartete Daten k√∂nnen den Betrieb der √ºbergeordneten Gesch√§ftslogik st√∂ren - bis zum √úbergang zum falschen Ausf√ºhrungszweig oder zu undefiniertem Verhalten, weil  Antwortverarbeitungsmechanismen k√∂nnen bereits zerst√∂rt sein. <br>  Und <b>auf der Remote-Seite</b> (nicht vergessen - die HTTPS-Anfrage war f√ºr jemanden bestimmt) - genau die gleiche Verschwendung von Ressourcen, und es ist m√∂glich: <br>  - Ver√∂ffentlichung von Fotos von Katzen auf einer Unternehmenswebsite; <br>  - Deaktivieren der Fu√übodenheizung in Ihrer K√ºche; <br>  - Ausf√ºhrung eines Handelsauftrags an der B√∂rse; <br>  - Geld√ºberweisung von Ihrem Konto; <br>  - Start einer Interkontinentalrakete. <br>  Die Gesch√§ftslogik versuchte, die Zombies zu stoppen, indem sie alle starken und schwachen Verbindungen zu ihnen entfernte.  Der Stopp des Fortschritts der HTTPS-Anforderung <b>sollte erfolgen</b> - es war nicht zu sp√§t, die Daten auf Anwendungsebene wurden noch nicht gesendet. <br>  Aber die Zombies entschieden auf ihre eigene Weise. <br><br>  Gesch√§ftslogik kann anstelle von Zombies neue Objekte erstellen und erneut versuchen, diese zu zerst√∂ren, wodurch der Ressourcenverbrauch vervielfacht wird. <br>  Im Fall eines kontinuierlichen Prozesses (z. B. einer Websocket-Verbindung) kann die Verschwendung von Ressourcen stundenlang andauern, und wenn in der Implementierung ein Mechanismus zum automatischen Wiederverbinden vorhanden ist, wenn die Verbindung getrennt wird, kann dieser im Allgemeinen gestoppt werden. <br><br>  <b>Valgrind?</b> <br>  Keine Chance.  Alles wird korrekt freigegeben und aufger√§umt.  Sp√§t und nicht vom Hauptfaden, aber v√∂llig korrekt. <br><br><h3>  Boozdedzomby </h3><br>  In diesem Beispiel wird die boozd :: azzio-Bibliothek verwendet, die eine Nachahmung von boost :: asio ist.  Trotz der Tatsache, dass die Nachahmung eher grob ist, k√∂nnen wir das Wesentliche des Problems demonstrieren.  Die Bibliothek hat eine Funktion io_context :: async_read (im Original ist sie kostenlos, √§ndert aber nichts an der Essenz), die Folgendes akzeptiert: <br>  - Stream, aus dem Daten stammen k√∂nnen; <br>  - einen Puffer, mit dem Sie diese Daten sammeln k√∂nnen; <br> ‚Äî callback-,       . <br>  io_context::async_read       callback,       (, ).        io_context::run() (     ,        ). <br><br><div class="spoiler"> <b class="spoiler_title">buffer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; namespace boozd::azzio { using buffer = std::vector&lt;int&gt;; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">stream.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;optional&gt; namespace boozd::azzio { class stream { public: virtual ~stream() = default; virtual std::optional&lt;int&gt; read() = 0; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">io_context.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; #include &lt;optional&gt; #include "buffer.h" namespace boozd::azzio { class stream; class io_context { public: ~io_context(); enum class error_code {no_error, good_error, bad_error, unknown_error, known_error, well_known_error}; using handler = std::function&lt;void(error_code)&gt;; // Start an asynchronous operation to read a certain amount of data from a stream. // This function is used to asynchronously read a certain number of bytes of data from a stream. // The function call always returns immediately. void async_read(stream&amp; s, buffer&amp; b, handler&amp;&amp; handler); // Run the io_context object's event processing loop. void run(); private: using pack = std::tuple&lt;stream&amp;, buffer&amp;&gt;; using pack_optional = std::optional&lt;pack&gt;; using handler_optional = std::optional&lt;handler&gt;; pack_optional _pack_optional; handler_optional _handler_optional; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">io_context.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;thread&gt; #include &lt;chrono&gt; #include "io_context.h" #include "stream.h" namespace boozd::azzio { io_context::~io_context() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void io_context::async_read(stream&amp; s, buffer&amp; b, io_context::handler&amp;&amp; handler) { _pack_optional.emplace(s, b); _handler_optional.emplace(std::move(handler)); } void io_context::run() { if (_pack_optional &amp;&amp; _handler_optional) { auto&amp; [s, b] = *_pack_optional; using namespace std::chrono; auto start = steady_clock::now(); while (duration_cast&lt;milliseconds&gt;(steady_clock::now() - start).count() &lt; 1000) { if (auto read = s.read()) b.emplace_back(*read); std::this_thread::sleep_for(milliseconds(100)); } (*_handler_optional)(error_code::no_error); } } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br>    boozd::azzio::stream,   : <br><br><div class="spoiler"> <b class="spoiler_title">impl/random_stream.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"boozd/azzio/stream.h"</span></span></span><span class="hljs-meta"> namespace boozd::azzio { class random_stream final : public stream { public: ~random_stream() override; std::optional</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int&gt; read() override; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">impl/random_stream.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "random_stream.h" namespace boozd::azzio { boozd::azzio::random_stream::~random_stream() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::optional&lt;int&gt; random_stream::read() { if (!(rand() &amp; 0x1)) return rand(); return std::nullopt; } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br> BoozdedZomby     -. -      async_read(),       boozd::azzio   run().     boozd::azzio        ( )      callback-.      ,    , -  shared_from_this. <br><br><div class="spoiler"> <b class="spoiler_title">BoozdedZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" #include "boozd/azzio/buffer.h" #include "boozd/azzio/io_context.h" #include "boozd/azzio/impl/random_stream.h" namespace Common { class Listener; } // namespace Common namespace BoozdedZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; Semaphore _semaphore = false; std::shared_ptr&lt;Common::Listener&gt; _listener; boozd::azzio::random_stream _stream; boozd::azzio::buffer _buffer; boozd::azzio::io_context _context; std::thread _thread; }; } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">BoozdedZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;sstream&gt; #include "boozd/azzio/impl/random_stream.h" #include "BoozdedZomby.h" #include "Common/Listener.h" namespace BoozdedZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("BoozdedZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()]() { while (shis &amp;&amp; shis-&gt;_semaphore &amp;&amp; shis-&gt;_listener) { auto handler = [shis](auto errorCode) { if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; errorCode == boozd::azzio::io_context::error_code::no_error) { std::ostringstream buf; buf &lt;&lt; "BoozdedZomby has got a fresh data: "; for (auto const &amp;elem : shis-&gt;_buffer) buf &lt;&lt; elem &lt;&lt; ' '; buf &lt;&lt; std::endl; shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } }; shis-&gt;_buffer.clear(); shis-&gt;_context.async_read(shis-&gt;_stream, shis-&gt;_buffer, handler); shis-&gt;_context.run(); } }); } } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "BoozdedZomby/BoozdedZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto boozdedZomby = BoozdedZomby::Zomby::create(); boozdedZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><blockquote> BoozdedZomby has got a fresh data: 1144108930 101027544 1458777923 1115438165 74243042 <br> BoozdedZomby has got a fresh data: 143542612 1131570933 <br> BoozdedZomby has got a fresh data: 893351816 563613512 704877633 <br> BoozdedZomby has got a fresh data: 1551901393 1399125485 1899894091 937186357 590357944 357571490 <br>  ================================================== =========== <br>  | Zomby was killed | <br>  ================================================== =========== <br> BoozdedZomby has got a fresh data: 1927702196 130060903 1083454666 2118797801 2035308228 824938981 <br> BoozdedZomby has got a fresh data: 2020739063 1635339425 34075629 <br> BoozdedZomby has got a fresh data: 2146319451 500782188 1269406752 884936716 892053144 <br> BoozdedZomby has got a fresh data: 330111137 1723153177 1070477904 <br> BoozdedZomby has got a fresh data: 343098142 280090412 589673557 889688008 2014119113 388471006 <br></blockquote><br></div></div><br>    run_once()   .         .       ,     : <br> ‚Äî boozdedZomby; <br> ‚Äî writeToConsoleListener; <br> ‚Äî   . <br>   . <br>   . <br><br> <b>     ?</b> <br>      .      .          boost::asio.  ,              ‚Äî        ( ). <br><br> <b>Valgrind?</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergangenheit. </font><font style="vertical-align: inherit;">Obwohl es scheint, Lecks zu erkennen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zombies in freier Wildbahn </font></font></h2><br> <b> !    !</b> <br>   . <br> <a href="https://www.boost.org/doc/libs/master/libs/beast/example/http/client/async/"> HTTP-</a> <br> <a href=""> Websocket-</a> <br>    boost ,    BoozdedZomby + SteppingZomby.   ,     .         ,      production ‚Äî       ,      . <br><br> <b>  ,   boost::asio::io_context!</b> <br> ‚Ä¶    n  (, -),    . <br><br>  : <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    stackoverflow ,        </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   ,      </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">         </a> <br><br><h2>  Fazit </h2><br> ,        ¬´¬ª. <br><br>         ,       . <br><br>        std::thread    ‚Äî          . <br><br>      ,   . <br><br>     event-driven,        (polling-based). <br><br>     . <br><br> ,  <b></b>           .       std::enable_shared_from_this,       (       ‚Äî       ). ,        :            -    . <br><br>           ,    SteppingZomby.       ‚Äî          shared_from_this (  ,   ,       ‚Äî   1  6  ). <br><br>           ‚Äî     ,  .   . <br><br>  ,   ,  .        std::enable_shared_from_this ‚Äî  <b></b> . <br><br> PS:    ‚Äî        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471326/">https://habr.com/ru/post/de471326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471310/index.html">Meine sehr subjektive Meinung √ºber berufliche und nicht nur IT-Ausbildung</a></li>
<li><a href="../de471312/index.html">Vorbereitung auf die Spring Professional-Zertifizierung. Fr√ºhlingsstiefel</a></li>
<li><a href="../de471318/index.html">September Maschinelles Lernen und k√ºnstliche Intelligenz News Digest</a></li>
<li><a href="../de471320/index.html">Tools f√ºr Softwareentwickler: Open Framework- und Machine Learning-Bibliotheken</a></li>
<li><a href="../de471324/index.html">Tr√§umen neuronale Netze von der Mona Lisa?</a></li>
<li><a href="../de471330/index.html">Geschichten vom Mondcomputer. Teil 2</a></li>
<li><a href="../de471332/index.html">Geschichten vom Mondcomputer. Teil 3</a></li>
<li><a href="../de471334/index.html">Auswendig lernen, aber nicht vollstopfen - ‚Äûmit Karten lernen‚Äú</a></li>
<li><a href="../de471336/index.html">Holivar. Geschichte von Runet. Teil 6. Schl√∂sser: Lurk, Tape, 282. und chinesischer Pfad</a></li>
<li><a href="../de471340/index.html">Drimsim gegen Mate 20 Pro Round! Aber f√ºr wen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>