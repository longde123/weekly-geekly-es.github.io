<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏼 🔗 🛠️ Nach Verteilung sortieren 🤳🏻 🐓 🎑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei Verteilungssortierungen werden Elemente verteilt und in Klassen neu verteilt, bis das Array sortiert ist. 

 Im allgemeinsten Fall geschieht dies ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nach Verteilung sortieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/472466/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="690" height="345" src="https://habrastorage.org/webt/vj/5g/69/vj5g69j-a8ai2v0bhirylzm9hvq.jpeg"></a> <br><br>  Bei Verteilungssortierungen werden Elemente verteilt und in Klassen neu verteilt, bis das Array sortiert ist. <a name="habracut"></a><br><br>  Im allgemeinsten Fall geschieht dies ungefähr auf die gleiche Weise.  Elemente werden nach einem bestimmten Kriterium nach Klassen gestreut.  Wenn dies nicht zur Reihenfolge des Arrays führt, werden die Attribute der Klasse verfeinert und die Elemente erneut auf die verfeinerten Klassen verteilt.  Und dies geschieht, bis das Array geordnet wird. <br><br>  Bei der Sortierung nach Verteilung gibt es fast immer keine Vergleiche von Elementen untereinander und deren Austausch.  Die Hauptsache ist, ob das Element zu einer bestimmten Klasse gehört oder nicht, sein Vergleich mit anderen Elementen spielt selten eine Rolle. <br><br>  Typischerweise weisen diese Sortierungen eine lineare Zeitkomplexität auf (und nicht logarithmisch, wie bei effizienten Arten von Austauschen, Zusammenführen, Auswählen oder Einfügen).  Außerdem benötigen die Algorithmen dieser Klasse fast immer viel zusätzlichen Speicher, da die nach Klassen gruppierten Elemente irgendwo gespeichert werden müssen. <br><br>  Verteilungssortierungen eignen sich zum Sortieren von Ganzzahlen und Zeichenfolgen.  Das Sortieren von reellen Zahlen mit ihnen ist normalerweise unpraktisch.  Außerdem sortiert die Verteilung Arrays, die aus sich wiederholenden Zahlen bestehen, perfekt - je mehr Wiederholungen, desto weniger unterschiedliche Klassen sind erforderlich. <br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a> <br clear="right">  Dieser Artikel wurde mit Unterstützung von EDISON verfasst. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kundenmeinung</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">10 Pluspunkte Programmierer von EDISON</a> <br>  Das ist interessant und nützlich zu wissen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frühstücksprogrammierer</a> </blockquote>  Stellen Sie sich einen Algorithmus vor, der die oben genannten Eigenschaften am konvexsten demonstriert. <br><br><h3>  Eimersortierung :: Eimersortierung </h3><br>  Andere Namen sind Korbsortierung, Blocksortierung, Taschensortierung. <br><br>  Wir streuen Zahlen in Körbe, dann in jeden Korb in kleinere Körbe und so weiter, bis auf einer bestimmten Ebene im Korb nur noch dieselben Elemente vorhanden sind.  Dann ist es aus solchen Körben der niedrigsten Ebene einfach, das Array in einem geordneten Zustand wiederherzustellen. <br><br>  Lassen Sie uns anhand eines konkreten Beispiels erklären.  Nehmen wir an, wir haben ein ungeordnetes Array.  Es ist bekannt, dass dieses Array Zahlen von 1 bis 8 enthält. <br><br><img width="608" height="303" src="https://habrastorage.org/webt/1w/dj/qh/1wdjqhl9ggh8ropzijjrvekcuom.gif"><br><br>  Wir werfen diese Zahlen in zwei Gruppen: Zahlen von 1 bis 4 fallen in eine Gruppe, von 5 bis 8 in die zweite. Dann verteilen wir die Zahlen im ersten Korb auf zwei Körbe: in eine Nummer 1 und 2 und in die anderen 3 und 4. Wir verteilen diese Körbe auch in Bastkörbe, die bereits gleich große Nummern enthalten.  Auf diesen großen Korb mit Zahlen von 5 bis 8 wenden wir eine ähnliche Rekursion an. <br><br>  Dann geben wir aus kleinen Körben, von denen jeder die gleichen Zahlen enthält, die Elemente in der Reihenfolge ihrer Priorität an das Hauptarray zurück. <br><br>  Die nukleare Sortierung in dieser Form ist in der Praxis nicht besonders anwendbar, zeigt jedoch standardmäßig, wie alle Sortierungen nach Verteilung im Allgemeinen funktionieren. <br><br><h3>  Thanos sort :: Thanos sort </h3><br>  Manchmal werden mir Autorensorten geschickt, und das ist genau so.  Der Autor Andrei Danilin nannte es "russische Sortierung in Hälften", aber ich nannte es die Sortierung von Thanos.  Wenn wir formal von den verwendeten Methoden ausgehen, können wir die arithmetische mittlere Sortierung nennen. <br><br><img width="608" height="251" src="https://habrastorage.org/webt/e-/le/9u/e-le9uxjeez1ng83tvwbr-eztea.gif"><br><br>  Das arithmetische Mittel der Elemente wird im Array berechnet und dann werden alle Elemente in 2 Gruppen verteilt.  Elemente, die kleiner als (oder gleich) dem arithmetischen Mittel sind, gehen an eine Gruppe, größer als das arithmetische Mittel an die zweite Gruppe.  Dann werden dieselben Aktionen rekursiv auf beide Gruppen angewendet - und so weiter bis zum bitteren Ende. <br><br>  Und was ist mit verrücktem Titan?  Wenn dies ein zufälliges Array ist, hat das Element im Vergleich zum arithmetischen Mittel im Großen und Ganzen eine 50/50-Chance, dass es in eine von zwei Gruppen geht. <br><br>  Im Internet bin ich übrigens auf einen anderen Comic-Algorithmus mit demselben Namen gestoßen.  Wenn das Array nicht sortiert ist, klicken Sie auf den Infinity-Handschuh und senden Sie die zufällig ausgewählte Hälfte der Array-Elemente an Nichtexistenz.  Wenn die Überlebenden eine geordnete Gruppe bilden, kann ihre große Mission als erfüllt betrachtet werden.  Wenn nicht bereits, können Sie noch ein paar Klicks machen. <br><br><img width="726" height="84" src="https://habrastorage.org/webt/on/ej/cz/onejczrz5o9mrtogqgocuteqshm.gif"><br><br>  Aber zurück zu unseren Verteilungssortierungen.  Alle können in nur zwei Gruppen unterteilt werden - <b>Sortieren</b> und <b>bitweise Sortieren</b> .  Wenn Sie möchten, können Sie auch <b>Zählbit-Sortierungen hervorheben</b> , d. H.  diejenigen, die beiden zugeschrieben werden können. <br><br>  Es gibt auch hybride Algorithmen (solche, die Methoden verschiedener Klassen verwenden, z. B. Tims Sortierung ist eine Kreuzung zwischen Zusammenführungssortierung und Einfügungssortierung, introspektive Sortierung ist eine schnelle Sortierung, die in eine Bündelsortierung usw. geht), einschließlich Verteilungssortierungen Hybriden sind jedoch ein separater Abschnitt.  Über sie später. <br><br>  Tausende Sortierungen und arithmetische Mittelsortierungen beziehen sich auf das Zählen von Sortierungen. <br><br><h2>  Sorten zählen </h2><br>  Die Grundidee ist, dass wir zählen, wie viele Zahlen in jeder Klasse sind. <br><br><h3>  Zählsortierung :: Zählsortierung </h3><br>  Wir zählen, wie oft die eine oder andere Zahl im Array vorkommt.  Wenn wir diese Mengen kennen, bilden wir schnell ein bereits geordnetes Array. <br><br><img width="684" height="173" src="https://habrastorage.org/webt/wf/oe/-d/wfoe-dctpt010wmbwqld6j2ab8a.gif"><br><br>  Für diese Sortierung müssen Sie das Minimum und Maximum im Array kennen.  Dann werden die Schlüssel für das Hilfsarray generiert, in dem wir festlegen, was und wie oft es getroffen wurde. <br><br>  Python-Code: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountingSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array, mn, mx)</span></span></span><span class="hljs-function">:</span></span> count = defaultdict(int) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array: count[i] += <span class="hljs-number"><span class="hljs-number">1</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mn,mx+<span class="hljs-number"><span class="hljs-number">1</span></span>): result += [j]* count[j] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre> <br><br><h3>  Pigeon Sort :: Pigeonhole sort </h3><br>  Wir gehen durch das Array, wenn eine neue Nummer gefunden wird, dann starten wir den Zähler (als Schlüssel der Hilfsliste) dieser Nummer.  Wenn die Nummer nicht zum ersten Mal gefunden wird, wird das Inkrement für diesen Zähler einfach ausgelöst. <br><br><img width="684" height="173" src="https://habrastorage.org/webt/wi/rc/ow/wircowxsbt7nauhkqurxoqvbyzo.gif"><br><br>  Der Unterschied zur vorherigen Methode besteht darin, dass wir beim Sortieren durch Zählen sofort Zähler für alle möglichen Zahlen starten, die im Array auftreten können (wir können es uns leisten, wenn das Maximum und das Minimum im Array bekannt sind).  Einige Zahlen erscheinen nie und ihre Zähler zeigen Null.  Bei der Taubensortierung starten wir Zähler nur für die Zahlen, die tatsächlich im Array vorkommen.  Bei der Zählsortierung für Zähler wird ein Array verwendet, und bei der Taubensortierung wird eine doppelt verknüpfte Liste verwendet, mit der Sie unterwegs neue Zähler hinzufügen können. <br><br>  Diese Methode wird manchmal alternativ als <b>Dirichlet-Sortierung bezeichnet</b> , da der Algorithmus selbst verschiedene Konsequenzen des Dirichlet-Prinzips veranschaulicht. <br><blockquote>  Wenn N Objekte auf M Container verteilt sind und N&gt; M, enthält mindestens ein Container mehr als ein Element. </blockquote><br>  Python-Code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PigeOnHoleSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> mi = min(a) size = max(a) - mi + <span class="hljs-number"><span class="hljs-number">1</span></span> holes = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a: holes[x - mi] += <span class="hljs-number"><span class="hljs-number">1</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> count <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(size): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> holes[count] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: holes[count] -= <span class="hljs-number"><span class="hljs-number">1</span></span> a[i] = count + mi i += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><br><h2>  Bitsortierung </h2><br>  Wir verteilen die Nummern abhängig davon, welche Ziffer in einer bestimmten Kategorie der Nummer enthalten ist.  Wenn wir dies mehrmals für verschiedene Ziffern tun, erhalten wir plötzlich ein sortiertes Array. <br><br><h3>  Bitweise Sortierung niedriger Ordnung :: LSD-Radix-Sortierung </h3><br><img align="right" width="380" height="407" src="https://habrastorage.org/webt/xt/ac/qu/xtacqu8pnxiji7ifh82ju8ldiog.gif"><br clear="left">  Wir wechseln von den unteren zu den älteren Ziffern und verteilen bei jeder Iteration die Elemente des Arrays, je nachdem, welche Ziffer in der Ziffer enthalten ist. <br><br>  Nach der nächsten Verteilung geben wir die Elemente in der Reihenfolge an das Hauptarray zurück, in der die Elemente bei der nächsten Umverteilung in die Klassen fielen. <br><br>  Für bitweise Sortierungen ist es wichtig, dass Elemente die gleiche Anzahl von Ziffern haben.  Wenn die tatsächliche Anzahl der Ziffern unterschiedlich ist, wird das Problem gelöst, indem zusätzliche Nullen als höhere Ziffern hinzugefügt werden. <br><br><h3>  Bitweise Sortierung höherer Ordnung :: MSD-Radix-Sortierung </h3><br><img align="right" width="380" height="407" src="https://habrastorage.org/webt/3c/ae/ge/3caege4fd6e17l_3p7qscvu6p7e.gif"><br clear="left">  Erstens verteilen wir uns auf die höheren Ränge, von denen wir zu den jüngeren wechseln. <br><br>  Diese Option ist schwieriger zu implementieren, da der Übergang zu den unteren Ziffern innerhalb der Klassen und nicht unter allen Elementen des Arrays rekursiv durchgeführt wird. <br><br>  Diese Komplexität wird jedoch durch die Tatsache belohnt, dass MSD schneller als LSD ist.  Wenn Sie von den unteren zu den älteren Ziffern wechseln, müssen Sie alle Ziffern aller Zahlen verarbeiten, um richtig zu sortieren.  Wenn Sie von älter zu jünger wechseln, müssen Sie tatsächlich nicht alle Ziffern aller Zahlen verarbeiten. Der sortierte Status kommt in der Regel früher. <br><br>  Die meisten bitweisen Sortierungen sind eine Variation der effizienteren MSD.  Dies ist besonders nützlich zum Sortieren von Zeichenfolgen. Hierzu wird normalerweise ein Suffixbaum verwendet.  Wir werden in einem der folgenden Artikel analysieren. <br><br><h2>  Bitweise Sortierung zählen </h2><br>  Manchmal ist die Verteilungssortierung gleichzeitig zählbar und bitweise. <br><br><h3>  Perlensortierung :: Perlensortierung </h3><br><img align="right" width="380" height="433" src="https://habrastorage.org/webt/df/tz/yd/dftzydlspf1ggnxzkzrzsgbvfpw.gif"><br clear="left">  Andere Namen des Algorithmus: Abakussortierung, Schwerkraftsortierung. <br><br>  Ich habe bereits einige Male über diese Sortierung geschrieben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> ), daher werde ich mich kurz fassen, nur die Essenz. <br><br>  Angenommen, jede Zahl in einem Array ist eine Reihe von Kugeln, die Anzahl der Kugeln ist der Wert einer Zahl.  Wenn wir die Zahlen als horizontale Reihen dieser Kugeln aufeinander anordnen und sie dann ganz vertikal verschieben, erhalten wir ein geordnetes Array. <br><br>  Der Trick dabei ist, dass wir jede Zahl mit Bällen in einem unären Zahlensystem darstellen.  Tatsächlich zählen wir einfach, wie oft alle Zahlen jede Ziffer haben. <br><br>  BeadSort in Python in einer Zeile: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/python3 from itertools import zip_longest def beadsort(l): return list(map(sum, zip_longest(*[[1] * e for e in l], fillvalue=0)))</span></span></code> </pre> <br><br>  Nach einer Weile werden wir komplexere zählbitweise Sortierungen analysieren, unter denen die Sortierung unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">amerikanischer Flagge</a> einen herausragenden Platz einnimmt. <br><br><h2>  Referenzen </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eimer</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eimer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zählen</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pigeonhole</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dirichlet</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Radix</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entladungen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perle</a> <br><br><h3>  Serienartikel: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Excel-Anwendung AlgoLab.xlsm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sorte austauschen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Insertion Sorts</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nach Auswahl sortieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sortierungen zusammenführen</a> </li><li>  <b>Nach Verteilung sortieren</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zählsorten mit ungefährer Verteilung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amerikanische Flagge sortieren</a> </li><li>  Suffixbaum in bitweiser Sortierung </li><li>  Vergleichen nach Sortierungen </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hybridsortierung</a> </li></ul><br>  Die AlgoLab Excel-Anwendung wurde erheblich aktualisiert.  Einige Algorithmen aus dem heutigen Artikel erschienen dort zum ersten Mal.  Aktualisieren Sie, wer verwendet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472466/">https://habr.com/ru/post/de472466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472448/index.html">Themen der Frontend-Sektion bei DUMP Kazan: ML für einen Front-End-Entwickler, Pixel Magic, SvelteJS, Lachen, Schweiß und Tränen</a></li>
<li><a href="../de472452/index.html">Wie füge ich Unterstützung für die Nachfrist (Billing Grace Period) in der iOS-Anwendung hinzu?</a></li>
<li><a href="../de472454/index.html">Übersicht über günstige VPS-Server</a></li>
<li><a href="../de472462/index.html">iFest in Nischni Nowgorod: IT ist beeindruckend</a></li>
<li><a href="../de472464/index.html">5 Möglichkeiten, einen Python-Server auf einem Raspberry Pi zu erstellen Teil 2</a></li>
<li><a href="../de472468/index.html">ClusterJ - Arbeiten mit MySQL NDB Cluster von Java</a></li>
<li><a href="../de472470/index.html">Transgene Mäuse und Anti-Aging</a></li>
<li><a href="../de472472/index.html">Ferienhaus im Winter: sein oder nicht sein?</a></li>
<li><a href="../de472474/index.html">Lustiger kosmetischer Fehler in Google Chrome</a></li>
<li><a href="../de472482/index.html">Radioaktiver Unfall: Entdeckung einer festen stabilen Phase von Plutonium</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>