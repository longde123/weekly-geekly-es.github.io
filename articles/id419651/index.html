<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👔 🅿️ 📗 Baik GA maupun YM. Bagaimana kami membuat clickstream kami sendiri 🕸️ 🚜 ♂️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami mengumpulkan lebih dari dua miliar peristiwa analitis per hari. Berkat ini, kita dapat menemukan banyak hal yang diperlukan: apakah mereka mengkl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Baik GA maupun YM. Bagaimana kami membuat clickstream kami sendiri</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/419651/"><p>  Kami mengumpulkan lebih dari dua miliar peristiwa analitis per hari.  Berkat ini, kita dapat menemukan banyak hal yang diperlukan: apakah mereka mengklik hati lebih dari pada bintang-bintang, jam berapa mereka menulis deskripsi yang lebih rinci, di daerah mana mereka sering kehilangan tombol hijau. </p><br><p>  Sistem pengumpulan dan analisis acara dapat secara umum disebut clickstream.  Saya akan memberi tahu Anda tentang sisi teknis dari clickstream di Avito: pengaturan acara, pengiriman dan pengirimannya, analitik, laporan.  Mengapa Anda menginginkannya sendiri, jika ada Google Analytics dan Yandex.Metrica, yang pengembang clickstream merusak kehidupan dan mengapa go-coders tidak bisa melupakan php. </p><br><p><img src="https://habrastorage.org/webt/b_/yj/uz/b_yjuzzjoz1p2bhzpwnnubrhrt0.png"></p><a name="habracut"></a><br><h1 id="obo-mne">  Tentang saya </h1><br><p>  Dmitry Khasanov, sepuluh tahun dalam pengembangan web, tiga tahun di Avito.  Saya bekerja di tim platform, mengembangkan alat infrastruktur umum.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saya suka hackathons</a> . </p><br><h1 id="zadacha">  Tantangan </h1><br><p>  Bisnis membutuhkan pemahaman yang mendalam tentang proses yang terjadi di situs.  Misalnya, saat mendaftar pengguna, saya ingin tahu dari wilayah mana, dari perangkat mana dan melalui browser mana pengguna telah login.  Bagaimana kolom isian diisi, apakah itu dikirimkan, atau pengguna menyerah.  Dan jika Anda menyerah, pada langkah apa.  Dan berapa banyak waktu yang dibutuhkan. </p><br><p> Saya ingin tahu apakah mereka akan mengklik tombol lebih sering jika dicat ulang dengan warna hijau.  Apakah tombol hijau akan lebih sering ditekan di Murmansk atau di Vladivostok, siang atau malam, oleh pengguna aplikasi seluler atau situs;  pengguna yang berasal dari utama atau dari pencarian;  yang membeli sebelumnya di Avito atau yang datang untuk pertama kalinya. </p><br><p>  Semua tanda-tanda ini: sistem operasi, ID pengguna, waktu permintaan, perangkat, browser, nilai-nilai di bidang - harus tersedia untuk analisis.  Kumpulkan, susun, berikan akses cepat ke data. </p><br><p>  Selain itu, seringkali diperlukan untuk membagi aliran acara.  Proyek perlu mengambil tindakan ketika peristiwa tertentu terjadi.  Misalnya, dengan cara ini, umpan balik diperoleh untuk melatih ulang model untuk pengenalan pola dan moderasi otomatis, dan statistik waktu nyata dikompilasi. </p><br><p>  Menggunakan clickstream sebagai produk, semestinya mudah bagi programmer untuk mengirim acara dari suatu proyek, dan bagi analis untuk mengelola acara yang dikumpulkan dan membuat berbagai laporan yang menunjukkan tren dan hipotesis pendukung. </p><br><p>  <strong>Laporan berdasarkan alur acara.</strong> <br>  <strong>Contoh 1</strong> <br><img src="https://habrastorage.org/webt/lt/vt/e3/ltvte3vhpz37df89hbwurg1gjno.png"></p><br><p>  <strong>Contoh 2</strong> <br><img src="https://habrastorage.org/webt/bl/he/wc/blhewctbesnuyilsxv4zozn7tlu.png"></p><br><h1 id="gotovye-instrumenty">  Alat jadi </h1><br><p>  Kami tahu tentang Yandex Metric dan Google Analytics, kami menggunakannya untuk beberapa tugas.  Dengan bantuan mereka, baik dan cepat untuk mengumpulkan data analitik dari ujung depan.  Tetapi untuk mengekspor data dari backends ke sistem analitik eksternal, Anda harus melakukan integrasi rumit. </p><br><p>  Dengan alat eksternal, Anda harus secara mandiri menyelesaikan masalah pemisahan aliran acara. </p><br><p>  Informasi analitis sangat berharga.  Kami telah mengumpulkannya selama bertahun-tahun, memungkinkan kami untuk mengetahui dengan sangat rinci bagaimana perilaku pengguna kami.  Saya tidak ingin berbagi pengetahuan seperti itu dengan dunia luar. </p><br><p>  Legislasi berkewajiban untuk menyimpan data di wilayah Rusia. </p><br><p>  Alasan-alasan ini cukup untuk mengembangkan solusi kami sendiri sebagai alat utama untuk mengumpulkan dan memproses data analitis. </p><br><h1 id="reshenie">  Solusi </h1><br><p>  Acara dikirim melalui transportasi berkinerja tinggi (Pemrosesan Streaming Acara, ESP) di penyimpanan (Data Warehouse, DWH).  Berdasarkan data dalam repositori, laporan analitis dibuat. </p><br><h3 id="sobytie">  Acara </h3><br><p>  Entitas pusat.  Dalam dirinya sendiri, itu berarti fakta.  Sesuatu yang konkrit terjadi dalam satuan waktu yang ditentukan. </p><br><p>  Penting untuk membedakan satu peristiwa dari yang lain.  Ini adalah pengidentifikasi unik acara tersebut. </p><br><p>  Juga tertarik dengan waktu terjadinya peristiwa.  Kami mengirimkannya di setiap acara dengan akurasi mikrodetik.  Dalam acara yang tiba dari frontend, kami juga memperbaiki waktu pada perangkat klien untuk mengembalikan urutan tindakan dengan lebih akurat. </p><br><h3 id="pole">  Lapangan </h3><br><p>  Acara terdiri dari bidang.  Field adalah unit semantik terkecil dari sistem analitik.  Dalam paragraf sebelumnya ada contoh bidang: pengidentifikasi acara, waktu pengiriman. </p><br><p>  Atribut bidang: tipe (string, angka, array), wajib. </p><br><h3 id="okruzhenie">  Lingkungan </h3><br><p>  Peristiwa yang sama dapat terjadi di berbagai bagian sistem: misalnya, otorisasi dimungkinkan di situs atau dalam aplikasi seluler.  Dalam hal ini, kami mengirim acara yang sama, tetapi selalu menambahkan pengidentifikasi unik dari sumber acara di dalam. </p><br><p>  Sumber sangat berbeda satu sama lain.  Ini bisa berupa setan internal dan mahkota, layanan frontend atau backend, aplikasi mobile.  Bagian dari bidang harus dikirim dengan setiap peristiwa dari sumber tertentu. </p><br><p>  Ada konsep "lingkungan."  Ini adalah pengelompokan logis peristiwa berdasarkan sumber dengan kemampuan untuk mengatur bidang umum untuk semua peristiwa sumber. </p><br><p>  Contoh lingkungan: "backend of service A", "frontend of service A", "ios-application of service A". </p><br><h3 id="spravochnik-sobytiy">  Direktori Acara </h3><br><p>  Semua peristiwa yang ada dijelaskan dalam direktori yang dapat diedit oleh pengembang dan analis.  Peristiwa secara logis dikelompokkan berdasarkan lingkungan, setiap peristiwa memiliki pemilik, log perubahan dalam direktori disimpan. </p><br><p>  Saat ini, direktori menggambarkan beberapa ratus bidang, beberapa puluhan lingkungan dan lebih dari seribu peristiwa. </p><br><h3 id="langpak">  Langpack </h3><br><p>  Kami menolak penyiksaan, dan kami tidak lagi memaksa pengembang untuk menulis kode pengiriman acara secara manual.  Sebagai gantinya, berdasarkan pada direktori, kami menghasilkan satu set file untuk masing-masing bahasa server yang didukung oleh perusahaan: php, go atau python.  Kode yang dihasilkan seperti itu disebut "langpack". </p><br><p>  File-file dalam langpack sesederhana mungkin, mereka tidak tahu tentang logika bisnis proyek.  Ini adalah seperangkat getter dan setter bidang untuk masing-masing acara dan kode untuk mengirim acara. </p><br><p>  Satu langpack dibuat untuk setiap lingkungan.  Ini terurai menjadi repositori paket (satis untuk php, pypi untuk python).  Itu diperbarui secara otomatis ketika perubahan dibuat ke direktori. </p><br><p>  Anda tidak bisa berhenti menulis dalam PHP.  Kode untuk layanan yang menghasilkan langpack ditulis dalam Go.  Perusahaan ini memiliki cukup proyek PHP, jadi saya harus mengingat bahasa pemrograman tiga huruf favorit saya dan menghasilkan kode PHP on Go.  Jika Anda sedikit terhanyut, Anda juga dapat membuat tes untuk menguji kode yang dihasilkan dengan tes ini. </p><br><h3 id="versionirovanie">  Versi </h3><br><p>  Referensi dapat diedit.  Kode dalam pertempuran tidak bisa dilanggar.  Kami menghasilkan kode tempur berdasarkan direktori.  Berbahaya. </p><br><p>  Setelah setiap perubahan acara, versi baru dibuat di direktori.  Semua versi peristiwa yang pernah dibuat hidup selamanya di direktori.  Jadi kami memecahkan masalah ketidakberubahan peristiwa tertentu.  Proyek selalu menunjukkan versi acara yang sedang kami tangani. </p><br><p>  Jika kode langpack berubah (misalnya, hanya ada setter, tapi sekarang kami juga memutuskan untuk menambahkan getter), buat versi baru dari langpack.  Dia juga akan hidup selamanya.  Proyek selalu meminta versi langpack khusus untuk lingkungannya.  Jadi kami memecahkan masalah invarian antarmuka langpack. </p><br><p>  Kami menggunakan semver.  Versi setiap bahasa terdiri dari tiga angka.  Yang pertama selalu nol, yang kedua adalah versi kode langpack, yang ketiga adalah kenaikan.  Digit ketiga paling sering berubah, setelah setiap perubahan peristiwa. </p><br><p>  Versi dua tingkat memungkinkan Anda untuk mengedit direktori tanpa melanggar kode dalam pertempuran.  Ini didasarkan pada dua prinsip: Anda tidak dapat menghapus apa pun;  Anda tidak dapat mengedit entitas yang dibuat, cukup buat salinan yang dimodifikasi berdampingan. </p><br><h3 id="transport">  Transportasi </h3><br><p>  Tidak seperti orang-orang dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Badoo di LSD</a> , kami tidak pernah belajar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis file dengan indah</a> .  Dan kami percaya bahwa NSQ tidak hanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">server antrian</a> , tetapi juga transportasi untuk acara. </p><br><p>  Mereka menyembunyikan NSQ di belakang lapisan kecil kode go, meletakkan kolektor untuk setiap node di cluster Kubernetes menggunakan set daemon, dan menulis konsumeris yang dapat menambahkan acara ke sumber yang berbeda. </p><br><p>  Saat ini, transportasi memberikan sekitar dua miliar peristiwa per hari.  Di bawah beban seperti itu, tiga puluh kolektor bekerja dengan sedikit margin.  Masing-masing mengkonsumsi lebih sedikit inti prosesor dan sedikit lebih dari satu gigabyte memori. </p><br><h3 id="routing-sobytiy">  Perutean acara </h3><br><p>  Pengirim acara dapat berupa proyek yang hidup di dalam atau di luar cluster kami.  Di dalam cluster, ini adalah backend layanan, mahkota, daemon, proyek infrastruktur, dan intranet.  Di luar, acara berasal dari ujung proyek publik, dari aplikasi seluler dan proyek mitra. </p><br><p>  Untuk menerima acara di luar cluster, kami menggunakan proxy.  Titik masuk umum dengan penyaringan kecil dari aliran peristiwa, dengan kemungkinan pengayaannya.  Pengiriman lebih lanjut untuk transportasi sesuai dengan skema umum. </p><br><p>  Skema perutean umum: setiap peristiwa dapat memiliki satu set penerima.  Kemungkinan penerima termasuk repositori analitik bersama (DWH), rebbits atau proyek monga yang tertarik pada peristiwa tertentu.  Kasing terakhir, misalnya, digunakan untuk melatih ulang model moderasi otomatis iklan.  Model mendengarkan acara tertentu, mendapatkan umpan balik yang diperlukan. </p><br><p>  Dari sisi proyek tidak ada pengetahuan tentang routing.  Mereka mengirim acara menggunakan langpacks di mana alamat kolektor umum dijahit. </p><br><h3 id="hranilische">  Penyimpanan </h3><br><p>  Repositori acara utama adalah HP Vertica, beberapa lusin terabyte.  Basis kolom dengan fitur yang sesuai untuk analis kami.  Antarmuka - Tablo untuk pelaporan. </p><br><p>  Lebih efisien untuk merekam acara di penyimpanan kami dalam jumlah besar.  Di depan penyimpanan adalah penyangga dalam bentuk Mongo.  Koleksi penghapusan otomatis yang dibuat secara otomatis untuk setiap jam.  Koleksi disimpan selama beberapa hari agar dapat memulai ulang proofreading di Vertica jika terjadi kesalahan. </p><br><p>  Pembacaan dari buffer Mongo pada skrip peliharaan.  Skrip dipandu oleh referensi, kami mencoba untuk tidak menjaga logika bisnis di sini.  Pada tahap ini, pengayaan acara dimungkinkan. </p><br><h1 id="evolyuciya">  Evolusi </h1><br><h3 id="ruchnye-tancy-v-temnote">  Menari dengan tangan dalam gelap </h3><br><p>  Kebutuhan untuk mencatat peristiwa muncul jauh lebih awal daripada kesadaran akan perlunya mempertahankan direktori.  Pengembang di masing-masing proyek datang dengan cara mengirim acara, mencari transportasi.  Ini menghasilkan banyak kode dalam bahasa yang berbeda, berbohong di proyek yang berbeda, tetapi menyelesaikan satu masalah. </p><br><p>  Seringkali di dalam kode pengiriman acara, bit logika bisnis tetap hidup.  Kode dengan pengetahuan ini tidak dapat diangkut ke proyek lain.  Saat refactoring, logika bisnis perlu dikembalikan ke proyek, hanya menyisakan kode acara sesuai dengan format data yang ditentukan. </p><br><p>  Pada tahap ini, tidak ada direktori acara.  Untuk memahami peristiwa apa yang sudah dicatat, bidang apa yang dimiliki peristiwa, itu hanya mungkin dengan melihat ke dalam kode.  Untuk mengetahui bahwa pengembang secara tidak sengaja berhenti menulis data di bidang yang diperlukan, dimungkinkan saat membuat laporan, jika Anda secara khusus memperhatikan hal ini. </p><br><p>  Tidak banyak acara.  Koleksi penyangga dalam mongo ditambahkan sesuai kebutuhan.  Ketika jumlah acara bertambah, perlu untuk mengarahkan kembali acara secara manual ke koleksi lain, untuk membuat koleksi yang diperlukan.  Keputusan untuk menempatkan acara dalam kumpulan penyangga tertentu dibuat pada saat pengiriman, di sisi proyek.  Transportasinya lancar, klien untuk itu adalah agen td. </p><br><h3 id="osvedomlyonnyy-rassinhron">  Sadar Asinkron </h3><br><p>  Diputuskan untuk membuat direktori semua acara yang ada.  Kami mengurai kode backends, mengeluarkan beberapa informasi dari sana.  Kami mewajibkan pengembang untuk mencatat ini di direktori dengan setiap perubahan dalam kode acara. </p><br><p>  Acara yang tiba dari frontend dan dari aplikasi seluler dijelaskan secara manual, kadang-kadang menangkap informasi yang diperlukan dari aliran acara di tingkat transportasi. </p><br><p>  Pengembang tahu bagaimana melupakan.  Ini menyebabkan desinkronisasi direktori dan kode, tetapi direktori menunjukkan gambaran umum. </p><br><p>  Jumlah koleksi buffer telah meningkat secara signifikan, pekerjaan manual untuk mempertahankannya telah meningkat secara signifikan.  Seseorang yang tak tergantikan muncul dengan banyak pengetahuan rahasia tentang penyimpanan buffer. </p><br><h3 id="novyy-transport">  Transportasi baru </h3><br><p>  Mereka menciptakan transportasi bersama, ESP, menyadari semua titik pengiriman acara.  Mereka menjadikannya satu titik penerimaan.  Ini memungkinkan untuk mengontrol semua aliran acara.  Proyek secara langsung berhenti mengakses penyimpanan buffer. </p><br><h3 id="prosveschyonnyy-klikstrimizm">  Clickstreamism yang Tercerahkan </h3><br><p>  Berdasarkan direktori, langpacks dihasilkan.  Mereka tidak mengizinkan pembuatan acara yang tidak valid. </p><br><p>  Diperkenalkan pemeriksaan otomatis untuk kebenaran acara yang tiba dari aplikasi frontend dan mobile.  Dalam hal ini, kami tidak berhenti menulis acara agar tidak kehilangan data, tetapi kami mencatat kesalahan dan memberi sinyal kepada pengembang. </p><br><p>  Peristiwa langka pada backend yang sulit untuk diperbaiki dan yang masih belum dikirim melalui langpack divalidasi oleh perpustakaan terpisah sesuai dengan aturan dari direktori.  Pada kesalahan, lempar pengecualian yang memblokir peluncuran. </p><br><p>  Punya sistem yang cenderung cocok dengan direktori.  Bonus: transparansi, pengelolaan, kecepatan pembuatan dan perubahan acara. </p><br><h1 id="posleslovie">  Kata penutup </h1><br><p>  Kesulitan dan pelajaran utama adalah organisasi.  Sulit untuk menghubungkan prakarsa yang melibatkan beberapa tim.  Tidak mudah untuk mengubah kode proyek lama yang besar.  Keterampilan berkomunikasi dengan tim lain, membagi tugas menjadi integrasi yang relatif independen dan dipikirkan sebelumnya dengan kemungkinan bantuan peluncuran independen.  Pengembang Clickstream tidak lagi menyukai tim produk ketika fase integrasi solusi baru dimulai.  Jika antarmuka berubah, pekerjaan ditambahkan ke semua orang. </p><br><p>  Membuat direktori adalah ide yang sangat bagus.  Dia menjadi satu-satunya sumber kebenaran, Anda selalu bisa memohon padanya jika ada perbedaan dalam kode.  Banyak otomatisasi terkait dengan direktori: cek, perutean acara, pembuatan kode. </p><br><p>  Infrastruktur tidak perlu tahu tentang logika bisnis.  Tanda-tanda munculnya logika bisnis: peristiwa berubah sepanjang jalan dari proyek ke repositori;  mengubah transportasi tanpa mengubah proyek menjadi tidak mungkin.  Di sisi infrastruktur, harus ada pengetahuan tentang komposisi acara, jenis bidang, dan kewajibannya.  Di sisi produk, makna logis dari bidang ini. </p><br><p>  Selalu ada ruang untuk tumbuh.  Secara teknis, ini merupakan peningkatan jumlah acara, penurunan waktu dari pembuatan acara hingga awal perekaman data, penghapusan pekerjaan manual di semua tahap. </p><br><p>  Ada beberapa ide yang berani.  Dapatkan grafik terperinci tentang transisi pengguna, mengonfigurasi acara dengan cepat tanpa meluncurkan layanan.  Tetapi lebih banyak tentang itu dalam artikel berikut. </p><br><p>  PS Saya berbicara tentang topik ini pada pertemuan Backend United # 1.  Vinaigrette.  Bisa melihat <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> dari rapat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419651/">https://habr.com/ru/post/id419651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419637/index.html">[Terjemahan] Bagaimana Graal - Java JVM JVM Compiler Bekerja</a></li>
<li><a href="../id419641/index.html">Membuat C # AI Sederhana di Unity</a></li>
<li><a href="../id419643/index.html">Konferensi Rekayasa Perangkat Lunak EPAM Minsk: Wujudkan</a></li>
<li><a href="../id419647/index.html">Seminar “Black Friday dalam e-commerce. Rahasia Bertahan Hidup, 16 Agustus, Moskow</a></li>
<li><a href="../id419649/index.html">Sedikit tentang kucing, atau yang CAT kami pilih untuk sinkronisasi podcast</a></li>
<li><a href="../id419653/index.html">Bagaimana melakukan pencarian pengguna di GitHub tanpa React + RxJS 6 + Komposisi Ulang</a></li>
<li><a href="../id419655/index.html">Musik di apartemen. Menanamkan</a></li>
<li><a href="../id419657/index.html">Bagaimana kecerdasan kolektif dikembangkan untuk sekawanan drone</a></li>
<li><a href="../id419659/index.html">Di mana Hollywood menggambarkan hacker dengan benar, dan di mana - secara keliru</a></li>
<li><a href="../id419661/index.html">Membuat stasiun radio dari GTA: San Andreas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>