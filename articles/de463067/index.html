<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷 🤹🏾 💆🏿 Zuerst die Vorderseite und dann die Rückseite (eines Tages) 🏇🏿 👧🏻 ⛪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bevor Sie mit der Implementierung einer neuen Funktion beginnen, müssen Sie sich den Kopf zerbrechen. 


 Die Entwicklung komplexer Funktionen erforde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zuerst die Vorderseite und dann die Rückseite (eines Tages)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463067/"><p>  Bevor Sie mit der Implementierung einer neuen Funktion beginnen, müssen Sie sich den Kopf zerbrechen. </p><br><p>  Die Entwicklung komplexer Funktionen erfordert eine genaue Koordination der Bemühungen eines Ingenieurteams. </p><br><p>  Und einer der wichtigsten Punkte ist das Problem der Parallelisierung von Aufgaben. </p><br><p>  Ist es möglich, Frontsoldaten davor zu bewahren, auf eine Back-End-Implementierung warten zu müssen?  Gibt es eine Möglichkeit, die Entwicklung einzelner Fragmente der Benutzeroberfläche zu parallelisieren? </p><br><p>  Das Thema Aufgabenparallelisierung in der Webentwicklung wird in diesem Artikel behandelt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/72d/93d/13b/72d93d13b21e705a101b21c359c3a565.png"></p><a name="habracut"></a><br><h3 id="problema">  Das Problem </h3><br><p> Beginnen wir also damit, das Problem zu identifizieren.  Stellen Sie sich vor, Sie haben ein erfahrenes Produkt (Internet-Service), in dem einige verschiedene Microservices gesammelt werden.  Jeder Microservice in Ihrem System ist eine Art Mini-Anwendung, die in die allgemeine Architektur integriert ist und ein bestimmtes Problem des Servicebenutzers löst.  Stellen Sie sich vor, heute Morgen (am letzten Tag des Sprints) hat der Product Owner Vasily Sie angerufen und angekündigt: „Im nächsten Sprint beginnen wir mit dem Datenimport, wodurch die Servicebenutzer noch glücklicher werden. Dadurch kann der Benutzer den Service sofort mit einem Stopizot von Dofigalliard-Positionen aus füllen dichtes 1C! ". </p><br><p>  Stellen Sie sich vor, Sie sind Manager oder Teamleiter und hören nicht all diese begeisterten Beschreibungen glücklicher Benutzer aus geschäftlicher Sicht.  Sie schätzen, wie viel Arbeit dies alles erfordert.  Als guter Manager bemühen Sie sich, den Appetit von Vasily auf Bewertungsaufgaben für MVP (im Folgenden: Minimum Viable Product) zu verringern.  Gleichzeitig können die beiden Hauptanforderungen für MVP - die Fähigkeit des Importsystems, einer großen Last standzuhalten und im Hintergrund zu arbeiten - nicht verworfen werden. </p><br><p>  Sie verstehen, dass der herkömmliche Ansatz, wenn alle Daten innerhalb derselben Benutzeranforderung verarbeitet werden, nicht funktioniert.  Hier muss man den Garten aller Hintergrundarbeiter umzäunen.  Sie müssen sich an den Event Bus binden und überlegen, wie der Load Balancer, die verteilte Datenbank usw. funktionieren.  Im Allgemeinen alle Freuden der Microservice-Architektur.  Infolgedessen kommen Sie zu dem Schluss, dass sich die Entwicklung des Backends für diese Funktion in die Länge zieht. Gehen Sie nicht zu Wahrsagern. </p><br><p>  Es stellt sich automatisch die Frage: "Was werden die Frontsoldaten die ganze Zeit tun, wenn es keine API gibt?". </p><br><p>  Außerdem stellt sich heraus, dass die Daten nicht sofort importiert werden dürfen.  Sie müssen sie zuerst validieren und den Benutzer alle gefundenen Fehler korrigieren lassen.  Auch im Frontend stellt sich ein schlauer Workflow heraus.  Und es ist notwendig, die Funktion wie üblich "gestern" zu sprengen.  Folglich müssen die Kriegsveteranen irgendwie koordiniert sein, damit sie nicht in einer Rübe drängeln, keine Konflikte verursachen und ruhig jedes Stück davon sehen (siehe KDPV am Anfang des Artikels). </p><br><p>  In einer anderen Situation könnten wir von hinten nach vorne sägen.  Implementieren Sie zuerst das Backend und stellen Sie sicher, dass es die Last hält, und hängen Sie dann das Frontend ruhig daran.  Der Haken ist jedoch, dass Spezifikationen das neue Feature allgemein beschreiben, Lücken und kontroverse Punkte in Bezug auf die Benutzerfreundlichkeit aufweisen.  Was aber, wenn sich am Ende der Front-Implementierung herausstellt, dass die Funktion in dieser Form den Benutzer nicht zufriedenstellt?  Änderungen der Benutzerfreundlichkeit können Änderungen am Datenmodell erforderlich machen.  Wir müssen sowohl die Vorder- als auch die Rückseite wiederholen, was sehr teuer sein wird. </p><br><h3 id="agile-pytaetsya-nam-pomoch">  Agile versucht uns zu helfen. </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b07/30c/c25/b0730cc25193b2363dbefb3b550d6f39.png"></p><br><p>  Flexible Methoden bieten kluge Ratschläge.  "Beginnen Sie mit dem Skateboard und zeigen Sie es dem Benutzer. Plötzlich wird es ihm gefallen. Wenn es Ihnen gefällt, fahren Sie auf die gleiche Weise fort und schrauben Sie neue Chips." <br>  Was aber, wenn der Benutzer sofort mindestens ein Motorrad benötigt und dies in zwei bis drei Wochen?  Was ist, wenn Sie, um mit der Arbeit an der Fassade des Motorrads zu beginnen, zumindest die Abmessungen des Motors und die Größe des Fahrgestells festlegen müssen? </p><br><p>  Wie kann sichergestellt werden, dass die Umsetzung der Fassade nicht verzögert wird, bis die anderen Schichten der Anwendung sicher sind? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ba2/5bc/5ad/ba25bc5ad7a863e7623f651f11eb12da.png"></p><br><p>  In unserer Situation ist es besser, einen anderen Ansatz zu verwenden.  Es ist besser, sofort mit der Erstellung einer Fassade (Vorderseite) zu beginnen, um sicherzustellen, dass die ursprüngliche Idee von MVP korrekt ist.  Auf der einen Seite scheint es ein Betrug zu sein, eine dekorative Fassade an Product Owner Vasily zu schieben, hinter der sich nichts befindet.  Auf der anderen Seite erhalten wir auf diese Weise sehr schnell Feedback zu dem Teil der Funktionalität, auf den der Benutzer überhaupt stoßen wird.  Sie haben vielleicht eine unglaublich coole Architektur, aber wenn es keine Benutzerfreundlichkeit gibt, wird die gesamte Anwendung über den Rand der App geworfen, ohne die Details zu verstehen.  Daher erscheint es mir wichtiger, so schnell wie möglich die funktionsfähigste Benutzeroberfläche bereitzustellen, anstatt den Fortschritt der Front mit dem Backend zu synchronisieren.  Es macht keinen Sinn, eine unvollendete Benutzeroberfläche und eine Sicherung zum Testen herauszugeben, deren Funktionalität die Hauptanforderungen nicht erfüllt.  Gleichzeitig kann sich die Ausgabe von 80% der erforderlichen UI-Funktionen, jedoch ohne funktionierendes Back-End, als rentabel herausstellen. </p><br><h3 id="nemnogo-tehnicheskih-detaley">  Einige technische Details </h3><br><p>  Daher habe ich bereits kurz beschrieben, welche Funktion wir implementieren werden.  Fügen Sie einige technische Details hinzu. </p><br><p>  Der Benutzer sollte in der Lage sein, eine große Datendatei in den Dienst hochzuladen.  Der Inhalt dieser Datei muss in einem bestimmten Format vorliegen (z. B. CSV).  Die Datei muss eine bestimmte Datenstruktur haben und es gibt Pflichtfelder, die nicht leer sein dürfen.  Mit anderen Worten, nach dem Entladen im Backend müssen Sie die Daten validieren.  Die Validierung kann eine beträchtliche Zeit dauern.  Sie können die Verbindung zum Backend nicht offen halten (sie wird durch das Timeout unterbrochen).  Daher müssen wir die Datei schnell akzeptieren und mit der Hintergrundverarbeitung beginnen.  Am Ende der Validierung müssen wir den Benutzer darüber informieren, dass er mit der Bearbeitung der Daten beginnen kann.  Der Benutzer muss die während der Validierung festgestellten Fehler korrigieren. </p><br><p>  Nachdem alle Fehler behoben wurden, klickt der Benutzer auf die Schaltfläche Importieren.  Korrigierte Daten werden an das Backend zurückgesendet.  um den Importvorgang abzuschließen.  Wir müssen das Frontend über den Fortschritt aller Importphasen informieren. </p><br><p>  Der effektivste Weg, um zu alarmieren, ist WebSockets.  Von vorne werden über Websocket mit einem bestimmten Zeitraum Anforderungen gesendet, um den aktuellen Status der Hintergrunddatenverarbeitung zu erhalten.  Für die Hintergrunddatenverarbeitung benötigen wir Hintergrundhandler, eine verteilte Befehlswarteschlange, einen Ereignisbus usw. </p><br><p>  Der Datenfluss wird wie folgt angezeigt (als Referenz): </p><br><ol><li>  Über die Dateibrowser-API bitten wir den Benutzer, die gewünschte Datei von der Festplatte auszuwählen. </li><li>  Über AJAX senden wir die Datei an das Backend. </li><li>  Wir warten auf den Abschluss der Validierung und Analyse der Datendatei (wir fragen den Status der Hintergrundoperation über Websocket ab). </li><li>  Nach Abschluss der Validierung laden wir die für den Import vorbereiteten Daten und rendern sie in die Tabelle auf der Importseite. </li><li>  Benutzer bearbeitet Daten, korrigiert Fehler.  Durch Klicken auf die Schaltfläche unten auf der Seite senden wir die korrigierten Daten an das Backend. </li><li>  Auch hier führen wir auf der Clientseite eine regelmäßige Abfrage des Hintergrundoperationsstatus durch. </li><li>  Bis zum Ende des aktuellen Imports sollte der Benutzer keinen neuen Import starten können (auch nicht im benachbarten Browserfenster oder auf dem benachbarten Computer). </li></ol><br><h3 id="plan-razrabotki">  Entwicklungsplan </h3><br><h4 id="mokap-ui-vs-prototip-ui">  Mocap UI vs.  Prototyp-Benutzeroberfläche </h4><br><p><img src="https://habrastorage.org/getpro/habr/post_images/908/3bc/f90/9083bcf90698b20014ec29e4580d3f08.jpg"></p><br><p>  Lassen Sie uns sofort den Unterschied zwischen Wireframe, Mockup und Prototype hervorheben. </p><br><p>  Das Bild oben zeigt das Drahtmodell.  Dies ist nur eine Zeichnung (in Zahlen oder auf Papier - das spielt keine Rolle).  Die beiden anderen Konzepte sind komplizierter. </p><br><p>  Mocap ist eine Präsentationsform der zukünftigen Oberfläche, die nur als Präsentation verwendet wird und anschließend vollständig ersetzt wird.  Dieses Formular wird in Zukunft als Beispiel archiviert.  Die eigentliche Benutzeroberfläche wird mit anderen Tools erstellt.  Ein Mocap kann in einem Vektoreditor mit ausreichenden Designdetails erstellt werden, aber dann legen Front-End-Entwickler es einfach beiseite und betrachten es als Modell.  Mocap kann sogar in spezialisierten Browser-Konstruktoren erstellt werden und ist nur eingeschränkt interaktiv.  Aber sein Schicksal ist unverändert.  Er wird ein Model im Design Guide Album. </p><br><p>  Der Prototyp wird mit denselben Tools wie die zukünftige Benutzeroberfläche erstellt (z. B. React).  Der Prototypcode wird im allgemeinen Anwendungsrepository gehostet.  Es wird nicht ersetzt, wie dies bei mocap der Fall ist.  Zunächst wird das Konzept getestet (Proof of Concept, PoC).  Wenn es den Test besteht, wird es entwickelt und schrittweise in eine vollwertige Benutzeroberfläche umgewandelt. </p><br><p>  Jetzt näher am Punkt ... </p><br><p>  Stellen Sie sich vor, Kollegen aus dem Design-Workshop präsentierten uns Artefakte ihres kreativen Prozesses: Modelle der zukünftigen Benutzeroberfläche.  Unsere Aufgabe ist es, die Arbeit so zu planen, dass die Parallelarbeit von Veteranen so schnell wie möglich möglich wird. </p><br><p>  Da die Kompilierung des Algorithmus mit einem Flussdiagramm beginnt, beginnen wir mit der Erstellung eines Prototyps mit einem minimalistischen Drahtmodell (siehe Abbildung oben).  In diesem Wireframe teilen wir zukünftige Funktionen in große Blöcke auf.  Das Hauptprinzip hierbei ist die Fokussierung der Verantwortung.  Sie sollten eine Funktionalität nicht in verschiedene Blöcke unterteilen.  Fliegen gehen zu einem Block und Schnitzel zu einem anderen. </p><br><p>  Als Nächstes müssen Sie so schnell wie möglich eine leere Seite (Dummy) erstellen, das Routing konfigurieren und einen Link zu dieser Seite in das Menü einfügen.  Anschließend müssen Sie Leerzeichen für die Basiskomponenten erstellen (eines für jeden Block im Prototyp Wireframe).  Und um diesen besonderen Rahmen in den Entwicklungszweig eines neuen Features einzubringen. </p><br><p>  Wir erhalten die folgende Hierarchie von Zweigen in Git: </p><br><pre><code class="plaintext hljs">master ---------------------- &gt; └ feature/import-dev ------ &gt;</code> </pre> <br><p>  Der Zweig "import-dev" wird für das gesamte Feature die Rolle des Entwicklungsbrunchs spielen.  Es ist ratsam, eine verantwortliche Person (Betreuer) in dieser Niederlassung zu beauftragen, die atomare Änderungen von allen Kollegen vornimmt, die parallel an der Funktion arbeiten.  Es ist auch ratsam, keine direkten Commits für diesen Zweig vorzunehmen, um die Wahrscheinlichkeit von Konflikten und unerwarteten Änderungen zu verringern, wenn in diesem Zweig Fusionen von atomaren Pull-Anforderungen stattfinden. </p><br><p>  Weil  In diesem Moment haben wir bereits Komponenten für die Hauptblöcke auf der Seite erstellt. Anschließend können Sie sofort separate Zweige für jeden UI-Block erstellen.  Die endgültige Hierarchie könnte folgendermaßen aussehen: </p><br><pre> <code class="plaintext hljs">master ----------------------- &gt; └ feature/import-dev ------- &gt; ├ feature/import-head ---- &gt; ├ feature/import-filter -- &gt; ├ feature/import-table --- &gt; ├ feature/import-pager --- &gt; └ feature/import-footer -- &gt;</code> </pre> <br><p>  <strong>Hinweis: Es</strong> <em>spielt keine Rolle, zu welchem ​​Zeitpunkt diese atomaren Brunchs erstellt werden, und die oben dargestellte Namenskonvention ist nicht die einzige geeignete.</em>  <em>Brunch kann unmittelbar vor Arbeitsbeginn erstellt werden.</em>  <em>Und die Namen der Brunchs sollten allen Teilnehmern an der Entwicklung klar sein.</em>  <em>Der Name sollte so kurz wie möglich sein und gleichzeitig explizit angeben, für welchen Teil der Funktionalität der Zweig verantwortlich ist.</em> </p><br><p>  Durch den oben beschriebenen Ansatz stellen wir den konfliktfreien Betrieb mehrerer UI-Entwickler sicher.  Jedes UI-Fragment hat ein eigenes Verzeichnis in der Projekthierarchie.  Der Fragmentkatalog enthält die Hauptkomponente, ihre Stile und ihre eigenen untergeordneten Komponenten.  Jedes Fragment kann auch einen eigenen Statusmanager haben (MobX-, Redux-, VueX-Parteien).  Möglicherweise verwenden die Komponenten des Fragments einige globale Stile.  Das Ändern globaler Stile beim Entwickeln eines Fragments einer neuen Seite ist jedoch untersagt.  Es lohnt sich auch nicht, das Standardverhalten und den Standardstil des allgemeinen Entwurfsatoms zu ändern. </p><br><p>  <strong>Hinweis:</strong> <em>„Design Atom“ bezeichnet ein Element aus dem Satz von Standardkomponenten unseres Service - siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Atomic Design</a> ;</em>  <em>In unserem Fall wird davon ausgegangen, dass das Atomic Design-System bereits implementiert wurde.</em> </p><br><p>  Also haben wir die Frontsoldaten physisch voneinander getrennt.  Jetzt kann jeder von ihnen ruhig arbeiten, ohne Angst vor Konflikten mit der Fusion zu haben.  Außerdem kann jeder jederzeit eine Pull-Anfrage aus seiner Filiale in <strong>feature / import-dev</strong> erstellen.  Bereits jetzt ist es möglich, statische Inhalte in aller Ruhe zu werfen und sogar interaktiv zu gestalten. </p><br><p>  Aber wie können wir die Möglichkeit der Interaktion zwischen UI-Fragmenten sicherstellen? </p><br><p>  Wir müssen die Verbindung zwischen den Fragmenten implementieren.  Der JS-Dienst, der als Gateway für den Datenaustausch mit dem Backing fungiert, eignet sich für die Rolle einer Verbindung zwischen Fragmenten.  Über denselben Dienst können Sie die Benachrichtigung über Ereignisse implementieren.  Durch das Abonnieren bestimmter Ereignisse enthalten die Fragmente implizit den gesamten Lebenszyklus des Mikrodienstes.  Änderungen an Daten in einem Fragment machen es erforderlich, den Status eines anderen Fragments zu aktualisieren.  Mit anderen Worten, wir haben die Integration von Fragmenten durch Daten und ein Ereignismodell durchgeführt. </p><br><p>  Um diesen Service zu erstellen, benötigen wir einen weiteren Zweig in git: </p><br><pre> <code class="plaintext hljs">master --------------------------- &gt; └ feature/import-dev ----------- &gt; ├ feature/import-js-service -- &gt; ├ feature/import-head -------- &gt; ├ feature/import-filter ------ &gt; ├ feature/import-table ------- &gt; ├ feature/import-pager ------- &gt; └ feature/import-footer ------ &gt;</code> </pre> <br><p>  <strong>Hinweis:</strong> <em>Haben Sie keine Angst vor der Anzahl der Filialen und zögern Sie nicht, Filialen zu produzieren.</em>  <em>Mit Git können Sie effizient mit einer großen Anzahl von Zweigen arbeiten.</em>  <em>Wenn sich eine Gewohnheit entwickelt, wird es leicht, sich zu verzweigen:</em> </p><br><pre> <code class="plaintext hljs">$/&gt; git checkout -b feature/import-service $/&gt; git commit . $/&gt; git push origin HEAD $/&gt; git checkout feature/import-dev $/&gt; git merge feature/import-service</code> </pre> <br><p>  <em>Dies wird einigen spannend erscheinen, aber der Gewinn der Minimierung von Konflikten ist bedeutender.</em>  <em>Während Sie der ausschließliche Eigentümer der Niederlassung sind, können <strong>Sie außerdem -f</strong> sicher <strong>drücken,</strong> ohne das Risiko <strong>einzugehen,</strong> dass die lokale Commit-Historie einer Person beschädigt wird.</em> </p><br><h4 id="feykovye-dannye">  Gefälschte Daten </h4><br><p>  In der vorherigen Phase haben wir den Integrations-JS-Dienst (importService) und die UI-Fragmente vorbereitet.  Ohne Daten funktioniert unser Prototyp jedoch nicht.  Außer statischen Dekorationen wird nichts gezeichnet. </p><br><p>  Jetzt müssen wir uns für ein ungefähres Datenmodell entscheiden und diese Daten in Form von JSON- oder JS-Dateien erstellen (die Wahl zugunsten der einen oder anderen hängt von den Importeinstellungen in Ihrem Projekt ab; ist json-loader konfiguriert).  Unser importService sowie seine Tests (wir werden später darüber nachdenken) importieren aus diesen Dateien die Daten, die zur Simulation von Antworten aus einem echten Backend erforderlich sind (es wurde noch nicht implementiert).  Wo diese Daten abgelegt werden sollen, ist nicht wichtig.  Die Hauptsache ist, dass sie einfach in importService selbst importiert und in unserem Microservice getestet werden können. </p><br><p>  Es ist ratsam, das Datenformat und die Feldbenennungskonvention sofort mit den Entwicklern der Rückseite zu besprechen.  Sie können beispielsweise zustimmen, ein Format zu verwenden, das der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAPI-Spezifikation entspricht</a> .  Unabhängig von den Spezifikationen für das Sicherungsformat erstellen wir gefälschte Daten genau in Übereinstimmung mit dem Sicherungsdatenformat. </p><br><p>  <strong>Hinweis:</strong> <em>Haben Sie keine Angst, einen Fehler mit dem gefälschten Datenmodell zu machen.</em>  <em>Ihre Aufgabe ist es, einen Entwurf des Datenvertrags zu erstellen, der dann noch mit den Backend-Entwicklern vereinbart wird.</em> </p><br><h4 id="kontrakty">  Verträge </h4><br><p>  Gefälschte Daten können als guter Ausgangspunkt für die Arbeit an der Spezifikation der zukünftigen API im Back-End dienen.  Und hier spielt es keine Rolle, wer und wie qualitativ der Entwurf des Modells umgesetzt wird.  Entscheidend ist die gemeinsame Diskussion und Koordination unter Beteiligung von Front- und Back-Entwicklern. </p><br><p>  Sie können spezielle Tools verwenden, um Verträge zu beschreiben (API-Spezifikationen).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zum</a> Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAPI / Swagger</a> .  Bei der Beschreibung einer API mit einem solchen Tool müssen nicht alle Entwickler anwesend sein.  Dies kann von einem Entwickler (Spezifikationseditor) durchgeführt werden.  Das Ergebnis einer gemeinsamen Diskussion über die neue API waren einige Artefakte wie MFU (Meeting Follow Up), nach denen der Spezifikationseditor auch eine Referenz für die zukünftige API erstellt. </p><br><p>  Am Ende des Spezifikationsentwurfs sollte es nicht lange dauern, bis die Richtigkeit überprüft wurde.  Jeder Teilnehmer an der kollektiven Diskussion kann unabhängig von den anderen eine flüchtige Prüfung durchführen, um zu überprüfen, ob seine Meinung berücksichtigt wurde.  Wenn etwas nicht stimmt, können Sie dies anhand der Editor-Spezifikationen (normale Arbeitskommunikation) klären.  Wenn alle mit der Spezifikation zufrieden sind, kann sie veröffentlicht und als Dokumentation für den Service verwendet werden. </p><br><h4 id="yunit-testirovanie">  Unit Testing </h4><br><p>  <strong>Hinweis:</strong> <em>Für mich ist der Wert von Unit-Tests ziemlich niedrig.</em>  <em>Hier stimme ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">David Heinemeier Hansson @ RailsConf zu</a> .</em>  <em>"Unit-Tests sind eine großartige Möglichkeit, um sicherzustellen, dass Ihr Programm das tut, was Sie können ... wie erwartet."</em>  <em>Aber ich gebe Sonderfälle zu, in denen Unit-Tests viel Nutzen bringen.</em> </p><br><p>  Nachdem wir uns für die gefälschten Daten entschieden haben, können wir mit dem Testen der Grundfunktionalität beginnen.  Zum Testen von Front-End-Komponenten können Sie Tools wie Karma, Scherz, Mokka, Chai, Jasmin verwenden.  Normalerweise wird die gleichnamige Datei mit dem Postfix "spec" oder "test" neben der zu testenden JS-Ressource platziert: </p><br><pre> <code class="plaintext hljs">importService ├ importService.js └ importService.test.js</code> </pre> <br><p>  Der spezifische Wert des Postfix hängt von den Einstellungen des JS-Paketkollektors in Ihrem Projekt ab. </p><br><p>  Natürlich ist es in einer Situation, in der sich der Rücken in einem „empfängnisverhütenden“ Zustand befindet, sehr schwierig, alle möglichen Fälle mit Unit-Tests abzudecken.  Der Zweck von Unit-Tests ist jedoch etwas anders.  Sie dienen zum Testen der Funktionsweise einzelner Logikelemente. </p><br><p>  Zum Beispiel ist es gut, verschiedene Arten von Helfern mit Komponententests abzudecken, durch die Logikelemente oder bestimmte Algorithmen zwischen JS-Komponenten und -Diensten gemeinsam genutzt werden.  Diese Tests können auch das Verhalten in den Komponenten und Speichern von MobX, Redux, VueX als Reaktion auf Änderungen der Benutzerdaten abdecken. </p><br><h4 id="integracionnoe-i-e2e-testirovanie">  Integration und E2E-Test </h4><br><p>  Integrationstests bedeuten, das Verhalten des Systems auf Übereinstimmung mit der Spezifikation zu überprüfen.  Das heißt,  Es wird überprüft, ob der Benutzer genau das Verhalten sieht, das in den Spezifikationen beschrieben ist.  Dies ist ein höheres Testniveau im Vergleich zu Unit-Tests. </p><br><p>  Zum Beispiel ein Test, der unter dem erforderlichen Feld nach einem Fehler sucht, wenn der Benutzer den gesamten Text gelöscht hat.  Oder ein Test, der überprüft, ob beim Speichern ungültiger Daten ein Fehler generiert wird. </p><br><p>  E2E-Tests (End-to-End) arbeiten auf einem noch höheren Niveau.  Sie überprüfen, ob das Verhalten der Benutzeroberfläche korrekt ist.  Wenn Sie beispielsweise überprüfen, ob dem Benutzer nach dem Senden der Datendatei an den Dienst eine Wendung angezeigt wird, die einen fortlaufenden asynchronen Prozess signalisiert.  Oder überprüfen Sie, ob die Visualisierung der Standardkomponenten des Dienstes mit den Anleitungen der Designer übereinstimmt. </p><br><p>  Diese Art von Test funktioniert mit einigen UI-Automatisierungsframeworks.  Zum Beispiel könnte es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Selen sein</a> .  Solche Tests werden zusammen mit Selenium WebDriver in einigen Browsern ausgeführt (normalerweise Chrome mit "Headless-Modus").  Sie arbeiten lange, entlasten aber die QS-Spezialisten und führen einen Rauchtest für sie durch. </p><br><p>  Das Schreiben dieser Art von Tests ist ziemlich zeitaufwändig.  Je früher wir anfangen, sie zu schreiben, desto besser.  Trotz der Tatsache, dass wir kein vollwertiges Backup haben, können wir bereits mit der Beschreibung von Integrationstests beginnen.  Wir haben bereits eine Spezifikation. </p><br><p>  Mit einer Beschreibung des E2E gibt es noch weniger Hindernistests.  Wir haben bereits die Standardkomponenten aus der Bibliothek der Designatome skizziert.  Implementierte bestimmte Teile der Benutzeroberfläche.  In importService wurden einige interaktive Daten zusätzlich zu gefälschten Daten und APIs erstellt.  Zumindest in einfachen Fällen hindert Sie nichts daran, die Automatisierung der Benutzeroberfläche zu starten. </p><br><p>  Wenn Sie diese Tests schreiben, können Sie einzelne Entwickler erneut verwirren, wenn es keine verwirrten Personen gibt.  Um die Tests zu beschreiben, können Sie einen separaten Zweig erstellen (wie oben beschrieben).  In den Zweigen für Tests müssen Updates aus dem Zweig " <strong>feature / import-dev</strong> " regelmäßig aktualisiert werden. </p><br><p>  Die allgemeine Reihenfolge der Zusammenführungen lautet wie folgt: </p><br><ol><li>  Beispielsweise hat ein Entwickler aus dem Zweig " <strong>Feature / Import-Filter</strong> " eine PR erstellt.  Diese PR wird in der Vorschau angezeigt, und der Betreuer des Zweigs " <strong>feature / import-dev</strong> " injiziert diese PR. </li><li>  Der Maintainer gibt bekannt, dass das Update veröffentlicht wurde. </li><li>  Der Entwickler in der Verzweigung " <strong>feature / import-tests-e2e</strong> " zieht beim Zusammenführen aus der <strong>Verzweigung</strong> " <strong>-dev</strong> " extreme Änderungen. </li></ol><br><h4 id="ci-i-avtomatizaciya-testirovaniya">  CI- und Testautomatisierung </h4><br><p>  Front-End-Tests werden mithilfe von Tools implementiert, die über die CLI funktionieren.  In package.json werden Befehle geschrieben, um verschiedene Arten von Tests auszuführen.  Diese Befehle werden nicht nur von Entwicklern in der lokalen Umgebung verwendet.  Sie werden auch benötigt, um Tests in der CI-Umgebung (Continuous Integration) auszuführen. </p><br><p>  Wenn wir jetzt den Build in CI ausführen und keine Fehler vorliegen, wird unser lang erwarteter Prototyp an die Testumgebung geliefert (80% der Funktionen an der Vorderseite mit einem noch nicht implementierten Back-End).  Wir können Vasily das ungefähre Verhalten des zukünftigen Mikrodienstes zeigen.  Vasiliy tritt gegen diesen Prototyp und wird vielleicht einige Bemerkungen machen (vielleicht sogar ernsthafte).  Zu diesem Zeitpunkt sind Anpassungen nicht teuer.  In unserem Fall erfordert die Unterlage ernsthafte architektonische Änderungen, sodass die Arbeit langsamer als auf der Vorderseite erfolgen kann.  Solange die Unterstützung nicht abgeschlossen ist, werden Änderungen am Plan für seine Entwicklung keine katastrophalen Folgen haben.  Falls erforderlich, ändern Sie zu diesem Zeitpunkt etwas. Wir werden Sie bitten, Anpassungen an der API-Spezifikation vorzunehmen (in swagger).  Danach werden die oben beschriebenen Schritte wiederholt.  Front-Line-Mitarbeiter sind immer noch nicht auf Backends angewiesen.  Einzelne Frontend-Spezialisten sind unabhängig voneinander. </p><br><h4 id="bekenda-kontrollery-zaglushki">  Backend.  Stub-Controller </h4><br><p>  Ausgangspunkt für die Entwicklung der API im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Backend</a> ist die genehmigte API-Spezifikation ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAPI / Swagger</a> ).  Wenn es eine Spezifikation gibt, lässt sich das Backing auch leichter parallelisieren.  Die Analyse der Spezifikation sollte Entwickler dazu veranlassen, über die Grundelemente der Architektur nachzudenken.  Welche allgemeinen Komponenten / Dienste müssen Sie erstellen, bevor Sie mit der Implementierung einzelner API-Aufrufe fortfahren können?  Und auch hier können Sie den Ansatz wie bei Leerzeichen für die Benutzeroberfläche anwenden. </p><br><p>  Wir können von oben beginnen, d.h.  von der äußeren Schicht unseres Rückens (von Controllern).  In dieser Phase beginnen wir mit Routing, Controller-Leerzeichen und gefälschten Daten.  Die Schicht von Diensten (BL) und Datenzugriff (DAL) haben wir noch nicht.  Wir übertragen einfach die Daten von JS an das Backend und programmieren die Controller so, dass sie die erwarteten Antworten für die Grundfälle implementieren und Teile aus den gefälschten Daten ausgeben. </p><br><p>  Nach Abschluss dieser Phase sollten Frontsoldaten ein funktionierendes Backend für statische Testdaten erhalten.  Darüber hinaus schreiben die Frontsoldaten genau die Integrationstests.  Im Prinzip sollte es derzeit nicht schwierig sein, das JS-Gateway (importService) auf die Verwendung von Controller-Leerzeichen im Hintergrund umzustellen. </p><br><p>  Der Antwortteil für Anforderungen über Websocket unterscheidet sich konzeptionell nicht von Web-API-Controllern.  Wir machen diese "Antwort" auch auf Testdaten und verbinden importService mit dieser Vorbereitung. </p><br><p>  Letztendlich müssen alle JS übertragen werden, um mit einem echten Server zu arbeiten. </p><br><h4 id="bekend-finalizaciya-kontrollerov-zaglushki-v-dao">  Backend.  Finalisierung der Controller.  DAO Stubs </h4><br><p>  Jetzt ist es an der Zeit, die externe Trägerschicht fertigzustellen.  Für Steuerungen werden Dienste einzeln in BL implementiert.  Jetzt arbeiten Dienste mit gefälschten Daten.  Der Zusatz in dieser Phase ist, dass wir in Services bereits echte Geschäftslogik implementieren.  In dieser Phase ist es ratsam, neue Tests gemäß der Geschäftslogik der Spezifikationen hinzuzufügen.  Es ist wichtig, dass kein Integrationstest fällt. </p><br><p>  <strong>Hinweis:</strong> Wir sind immer noch nicht davon abhängig, ob das Datenschema in der Datenbank implementiert ist. </p><br><h4 id="bekend-finalizaciya-dao-realnaya-bd">  Backend.  Finalisieren Sie DAO.  Echt db </h4><br><p>  Nachdem das Datenschema in der Datenbank implementiert wurde, können wir die Testdaten aus den vorherigen Schritten darauf übertragen und unsere rudimentäre DAL auf die Arbeit mit dem realen Datenbankserver umstellen.  Weil  Wir übertragen die für die Front erstellten Anfangsdaten in die Datenbank, alle Tests sollten relevant bleiben.  Wenn einer der Tests fällt, ist ein Fehler aufgetreten und Sie müssen verstehen. </p><br><p>  <strong>Hinweis:</strong> <em>Im Allgemeinen gibt es bei einer sehr hohen Wahrscheinlichkeit, mit dem Datenschema in der Datenbank zu arbeiten, wenig für eine neue Funktion.</em>  <em>Möglicherweise werden Änderungen an der Datenbank gleichzeitig mit der Implementierung von Diensten in BL vorgenommen.</em> </p><br><p>  Am Ende dieser Phase erhalten wir eine vollständige Alpha-Version des Mikroservices.  Diese Version kann bereits internen Benutzern (Product Owner, einem Produkttechnologen oder einer anderen Person) zur Bewertung als MVP angezeigt werden. </p><br><p>  Die Standarditerationen von Agile zur Behebung von Fehlern, zur Implementierung zusätzlicher Chips und zum endgültigen Polieren werden fortgesetzt. </p><br><h4 id="zaklyuchenie">  Fazit </h4><br><p>  Ich denke, Sie sollten das oben Gesagte nicht blind als Leitfaden für Maßnahmen verwenden.  Zuerst müssen Sie anprobieren und sich an Ihr Projekt anpassen.  Der oben beschriebene Ansatz kann einzelne Entwickler voneinander trennen und ihnen ermöglichen, unter bestimmten Bedingungen parallel zu arbeiten.  Alle Gesten mit Brunch und Datenübertragung, die Implementierung von Leerzeichen für gefälschte Daten scheinen ein erheblicher Aufwand zu sein.  Der Gewinn aus diesem Overhead ergibt sich aus der erhöhten Parallelität.  Wenn das Entwicklungsteam besteht <del>  eineinhalb Bagger </del>  Zwei Full Stacks oder ein Freotovik mit einem Backend, dann wird dieser Ansatz wahrscheinlich viel Gewinn bringen.  Obwohl in dieser Situation einige Punkte die Wirksamkeit der Entwicklung durchaus erhöhen können. </p><br><p>  Der Gewinn dieses Ansatzes zeigt sich, wenn wir zu Beginn schnell Werkstücke implementieren, die einer zukünftigen realen Implementierung so nahe wie möglich kommen, und die Arbeit an verschiedenen Teilen auf Dateistrukturebene im Projekt und auf der Ebene des Code-Management-Systems (git) physisch trennen. </p><br><p>  Ich hoffe, Sie fanden diesen Artikel hilfreich. </p><br><p>  Vielen Dank für Ihre Aufmerksamkeit! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463067/">https://habr.com/ru/post/de463067/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463055/index.html">Über Administratoren, Entwickler, endlose Verwirrung und DevOps-Transformation innerhalb des Unternehmens</a></li>
<li><a href="../de463057/index.html">Benutzerdefinierte Rechte für Yii Framework 2</a></li>
<li><a href="../de463059/index.html">Drei leben in der IT und nicht nur</a></li>
<li><a href="../de463061/index.html">Regeln für die Erstellung von Layouts in Figma</a></li>
<li><a href="../de463063/index.html">Wir beschäftigen uns mit Schnittstellen in Go</a></li>
<li><a href="../de463069/index.html">Reagieren Sie auf den animierten Leitfaden</a></li>
<li><a href="../de463071/index.html">Welche Auswirkungen haben Internetausfälle?</a></li>
<li><a href="../de463073/index.html">QUIC in Aktion: Wie Uber es implementiert hat, um die Leistung zu optimieren</a></li>
<li><a href="../de463075/index.html">Neue Open Source-Lizenzen</a></li>
<li><a href="../de463083/index.html">Schutz von iPhone-Backups</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>