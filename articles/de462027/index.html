<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëêüèΩ üë®üèæ‚ÄçüöÄ üé∫ Wie Dark 50ms Code einsetzt üßë üö£üèº üñïüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je schneller der Entwicklungsprozess ist, desto schneller entwickelt sich das Technologieunternehmen. 


 Leider arbeiten moderne Anwendungen gegen un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Dark 50ms Code einsetzt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/462027/"><p><img src="https://habrastorage.org/webt/o4/lk/bi/o4lkbi449pbpjqw84e0wt-tywlq.png"></p><br><p>  Je schneller der Entwicklungsprozess ist, desto schneller entwickelt sich das Technologieunternehmen. </p><br><p>  Leider arbeiten moderne Anwendungen gegen uns - unsere Systeme m√ºssen in Echtzeit aktualisiert werden und gleichzeitig niemanden st√∂ren und d√ºrfen nicht zu Ausfallzeiten und Unterbrechungen f√ºhren.  Die Bereitstellung in solchen Systemen wird zu einer komplexen Aufgabe und erfordert komplexe Pipelines f√ºr die kontinuierliche Lieferung, selbst in kleinen Teams. </p><br><p>  Diese Pipelines haben normalerweise eine enge Anwendung, arbeiten langsam und sind nicht zuverl√§ssig.  Entwickler m√ºssen sie zuerst manuell erstellen und dann verwalten, und Unternehmen stellen h√§ufig ganze DevOps-Teams daf√ºr ein. </p><br><p>  Die Entwicklungsgeschwindigkeit h√§ngt von der Geschwindigkeit dieser Pipelines ab.  F√ºr die besten Teams dauert die Bereitstellung 5-10 Minuten, normalerweise jedoch viel l√§nger und f√ºr eine Bereitstellung mehrere Stunden. </p><a name="habracut"></a><br><p>  In Dark dauert es 50 ms.  <em>F√ºnfzig.</em>  <em>Millisekunden</em>  Dark ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Komplettl√∂sung mit einer Programmiersprache, einem Editor und einer Infrastruktur,</a> die speziell f√ºr die kontinuierliche Bereitstellung entwickelt wurden. Alle Aspekte von Dark, einschlie√ülich der Sprache selbst, wurden im Hinblick auf eine sichere sofortige Bereitstellung erstellt. </p><br><h3 id="pochemu-konveyery-nepreryvnoy-postavki-takie-medlennye">  Warum sind kontinuierliche F√∂rderer so langsam? </h3><br><p> Angenommen, wir haben eine Python-Webanwendung und haben bereits eine wunderbare und moderne Pipeline f√ºr die kontinuierliche Bereitstellung erstellt.  F√ºr einen Entwickler, der jeden Tag mit diesem Projekt besch√§ftigt ist, sieht die Bereitstellung einer geringf√ºgigen √Ñnderung ungef√§hr so ‚Äã‚Äãaus: </p><br><h3 id="vnesenie-izmeneniy">  √Ñnderungen vornehmen </h3><br><ul><li>  Erstellen eines neuen Zweigs in Git </li><li>  √Ñnderungen hinter dem Funktionsschalter vornehmen </li><li>  Unit-Test zur √úberpr√ºfung von √Ñnderungen mit und ohne Funktionsschalter </li></ul><br><h3 id="pul-rekvest">  Poolanfrage </h3><br><ul><li>  Commit Commit </li><li>  Ver√∂ffentlichen von √Ñnderungen in einem Remote-Repository auf github </li><li>  Poolanfrage </li><li>  CI wird automatisch im Hintergrund erstellt </li><li>  Code√ºberpr√ºfung </li><li>  Falls erforderlich, noch ein paar Bewertungen </li><li>  √Ñnderungen mit dem Git-Assistenten zusammenf√ºhren. </li></ul><br><h3 id="ci-vypolnyaetsya-na-mastere">  CI wird auf dem Assistenten ausgef√ºhrt </h3><br><ul><li>  Festlegen von Frontend-Abh√§ngigkeiten √ºber npm </li><li>  Erstellen und Optimieren von HTML + CSS + JS-Ressourcen </li><li>  F√ºhren Sie das vordere Ende der Ger√§te- und Funktionstests aus </li><li>  Installieren Sie Python-Abh√§ngigkeiten von PyPI </li><li>  F√ºhren Sie das Backend von Unit- und Funktionstests aus </li><li>  Integrationstests an beiden Enden </li><li>  Senden Sie Frontend-Ressourcen an CDN </li><li>  Erstellen eines Containers f√ºr ein Python-Programm </li><li>  Senden eines Containers an die Registrierung </li><li>  Kubernetes Manifest Update </li></ul><br><h3 id="zamena-starogo-koda-novym">  Alten Code durch neuen ersetzen </h3><br><ul><li>  Kubernetes startet mehrere Instanzen eines neuen Containers </li><li>  Kubernetes wartet darauf, dass Instanzen betriebsbereit werden </li><li>  Kubernetes f√ºgt dem HTTP Load Balancer Instanzen hinzu </li><li>  Kubernetes wartet darauf, dass alte Instanzen nicht mehr verwendet werden </li><li>  Kubernetes stoppt alte Instanzen </li><li>  Kubernetes wiederholt diese Vorg√§nge, bis neue Instanzen alle alten ersetzen </li></ul><br><h3 id="vklyuchenie-novogo-pereklyuchatelya-funkcii">  Schalten Sie den neuen Funktionsschalter ein </h3><br><ul><li>  Der neue Code ist nur f√ºr mich enthalten, um sicherzustellen, dass alles in Ordnung ist </li><li>  F√ºr 10% der Benutzer ist neuer Code enthalten, Betriebs- und Gesch√§ftsmetriken werden nachverfolgt </li><li>  F√ºr 50% der Benutzer ist neuer Code enthalten, Betriebs- und Gesch√§ftsmetriken werden nachverfolgt </li><li>  Der neue Code ist f√ºr 100% der Benutzer enthalten. Betriebs- und Gesch√§ftsmetriken werden nachverfolgt </li><li>  Schlie√ülich wiederholen Sie den gesamten Vorgang, um den alten Code zu entfernen und zu wechseln </li></ul><br><p>  Der Prozess h√§ngt von den Tools, der Sprache und der Verwendung serviceorientierter Architekturen ab, sieht aber im Allgemeinen so aus.  Ich habe die Bereitstellung von Datenbankmigrationen nicht erw√§hnt, da dies eine sorgf√§ltige Planung erfordert. Im Folgenden werde ich jedoch beschreiben, wie Dark damit umgeht. </p><br><p>  Hier gibt es viele Komponenten, von denen viele leicht langsamer werden, abst√ºrzen, vor√ºbergehende Konkurrenz verursachen oder das funktionierende System zum Erliegen bringen k√∂nnen. </p><br><p>  Und da diese Pipelines fast immer f√ºr einen besonderen Anlass erstellt werden, ist es schwierig, sich auf sie zu verlassen.  Viele Menschen haben Tage, an denen der Code nicht bereitgestellt werden kann, weil es Probleme in der Docker-Datei gibt, einer der Dutzenden von Diensten abgest√ºrzt ist oder der richtige Spezialist im Urlaub. </p><br><p>  Schlimmer noch, viele dieser Schritte bewirken √ºberhaupt nichts.  Wir haben sie fr√ºher ben√∂tigt, als wir den Code sofort f√ºr Benutzer bereitgestellt haben, aber jetzt haben wir Schalter f√ºr den neuen Code, und diese Prozesse sind unterteilt.  Infolgedessen ist der Schritt, in dem der Code bereitgestellt wird (der alte wird durch den neuen ersetzt), nur noch ein zus√§tzliches Risiko. </p><br><p>  Dies ist nat√ºrlich eine sehr durchdachte Pipeline.  Das Team, das es erstellt hat, brauchte Zeit und Geld, um es schnell bereitzustellen.  Normalerweise sind Bereitstellungspipelines viel langsamer und unzuverl√§ssiger. </p><br><h3 id="realizaciya-nepreryvnoy-postavki-v-dark">  Kontinuierliche Lieferung im Dunkeln implementieren </h3><br><p>  Die kontinuierliche Lieferung ist f√ºr Dark so wichtig, dass wir die Zeit in weniger als einer Sekunde im Visier haben.  Wir gingen alle Schritte der Pipeline durch, um alles Unn√∂tige zu entfernen, und erinnerten uns an den Rest.  So haben wir die Schritte entfernt. </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jessie Frazelle</a> pr√§gte das neue Wort Deployless auf der Future of Software Development-Konferenz in Reykjavik </blockquote><p>  Wir entschieden sofort, dass Dark auf dem Konzept von ‚ÄûDeployless‚Äú basieren w√ºrde (danke an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jesse Frazel</a> f√ºr den Neologismus).  Deployless bedeutet, dass jeder Code sofort bereitgestellt und f√ºr die Produktion bereit ist.  Nat√ºrlich werden wir keinen fehlerhaften oder unvollst√§ndigen Code verpassen (ich werde die Sicherheitsprinzipien unten beschreiben). </p><br><p>  Bei der Dark-Demo wurden wir oft gefragt, wie wir die Bereitstellung beschleunigen konnten.  Komische Frage.  Die Leute denken wahrscheinlich, dass wir eine Art Supertechnologie entwickelt haben, die den Code vergleicht, kompiliert, in einen Container packt, eine virtuelle Maschine startet, einen Container auf eine kalte startet und √§hnliches - und das alles in 50 ms.  Das ist kaum m√∂glich.  Wir haben jedoch eine spezielle Deployment-Engine erstellt, die all dies nicht ben√∂tigt. </p><br><p>  Dark startet Dolmetscher in der Cloud.  Angenommen, Sie schreiben Code in eine Funktion oder einen Handler f√ºr HTTP oder Ereignisse.  Wir senden diff an den abstrakten Syntaxbaum (die Implementierung des von unserem Editor und unseren Servern intern verwendeten Codes) an unsere Server und f√ºhren diesen Code dann aus, wenn Anforderungen eingehen.  Die Bereitstellung sieht also wie ein bescheidener Datensatz in der Datenbank aus - sofort und elementar.  Die Bereitstellung ist so schnell, weil sie das N√∂tigste beinhaltet. </p><br><p>  In Zukunft planen wir, aus Dark einen Infrastruktur-Compiler zu machen, der die ideale Infrastruktur f√ºr hohe Leistung und Zuverl√§ssigkeit von Anwendungen erstellt und ausf√ºhrt.  Die sofortige Bereitstellung geht nat√ºrlich nirgendwo hin. </p><br><h2 id="bezopasnoe-razvertyvanie">  Sichere Bereitstellung </h2><br><h3 id="strukturirovannyy-redaktor">  Strukturierter Editor </h3><br><p>  Der Code in Dark wird im Dark-Editor geschrieben.  Der strukturierte Editor macht keine Syntaxfehler.  Tats√§chlich hat Dark nicht einmal einen Analysator.  W√§hrend der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eingabe</a> arbeiten wir direkt mit dem Abstract Syntax Tree (AST) wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paredit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sketch-n-Sketch</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tofu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prune</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MPS</a> . </p><br><p>  Jeder unvollst√§ndige Code in Dark hat eine g√ºltige Ausf√ºhrungssemantik, √§hnlich wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">typisierte L√∂cher in Hazel</a> .  Wenn Sie beispielsweise einen Funktionsaufruf √§ndern, behalten wir die alte Funktion bei, bis die neue verwendbar wird. </p><br><p>  Jedes Programm in Dark hat seine eigene Bedeutung, sodass unvollst√§ndiger Code die fertige Arbeit nicht beeintr√§chtigt. </p><br><h3 id="rezhimy-redaktirovaniya">  Bearbeitungsmodi </h3><br><p>  Sie schreiben in zwei F√§llen Code in Dark.  Erstens: Sie schreiben neuen Code und sind der einzige Benutzer.  Beispielsweise befindet es sich in der REPL, und andere Benutzer erhalten niemals Zugriff darauf, oder es handelt sich um eine neue HTTP-Route, auf die Sie nirgendwo verweisen.  Sie k√∂nnen hier ohne Vorsichtsma√ünahmen arbeiten, und jetzt arbeiten Sie ungef√§hr in der Entwicklungsumgebung. </p><br><p>  Zweite Situation: Der Code wird bereits verwendet.  Wenn der Datenverkehr durch den Code geleitet wird (Funktionen, Ereignishandler, Datenbanken, Typ), muss vorsichtig vorgegangen werden.  Zu diesem Zweck blockieren wir den gesamten verwendeten Code und ben√∂tigen strukturiertere Tools, um ihn zu bearbeiten.  Im Folgenden werde ich auf strukturelle Tools eingehen: Funktionsschalter f√ºr HTTP- und Ereignishandler, eine leistungsstarke Migrationsplattform f√ºr Datenbanken und eine neue Versionskontrollmethode f√ºr Funktionen und Typen. </p><br><h3 id="pereklyuchateli-funkciy">  Funktionsschalter </h3><br><p>  Eine M√∂glichkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, die zus√§tzliche Komplexit√§t</a> in Dark <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu beseitigen,</a> besteht darin, mehrere Probleme mit einer L√∂sung zu beheben.  Funktionsschalter f√ºhren viele verschiedene Aufgaben aus: Ersetzen der lokalen Entwicklungsumgebung, Git-Zweige, Bereitstellen von Code und nat√ºrlich die traditionelle langsame und kontrollierte Freigabe von neuem Code. </p><br><p>  Die Erstellung und Bereitstellung eines Funktionsschalters erfolgt in unserem Editor in einem Arbeitsgang.  Es erstellt einen leeren Bereich f√ºr neuen Code und bietet Zugriffssteuerungen f√ºr alten und neuen Code sowie Schaltfl√§chen und Befehle f√ºr den schrittweisen √úbergang zu neuem Code oder dessen Ausschluss. </p><br><p>  Funktionsschalter sind in die dunkle Sprache integriert, und selbst unvollst√§ndige Schalter erf√ºllen ihre Aufgabe. Wenn die Bedingung im Schalter nicht erf√ºllt ist, wird der alte blockierte Code ausgef√ºhrt. </p><br><h3 id="sreda-razrabotki">  Entwicklungsumgebung </h3><br><p>  Funktionsschalter ersetzen die lokale Entwicklungsumgebung.  Heutzutage ist es f√ºr Teams schwierig sicherzustellen, dass alle Benutzer dieselben Versionen von Tools und Bibliotheken verwenden (Code-Formatierer, Linters, Paketmanager, Compiler, Pr√§prozessoren, Testtools usw.). Mit Dark m√ºssen Sie keine Abh√§ngigkeiten lokal installieren, die lokale Installation von Docker oder steuern Ergreifen Sie andere Ma√ünahmen, um zumindest einen Anschein von Gleichheit zwischen Entwicklungsumgebung und Produktion zu gew√§hrleisten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angesichts der Tatsache, dass eine solche Gleichstellung immer noch unm√∂glich ist</a> , werden wir nicht einmal so tun, als w√ºrden wir danach streben. </p><br><p>  Anstatt eine geklonte lokale Umgebung zu erstellen, erstellen die Switches in Dark eine neue Sandbox in der Produktion, die die Entwicklungsumgebung ersetzt.  In Zukunft planen wir auch, eine Sandbox f√ºr andere Teile der Anwendung zu erstellen (z. B. sofortige Datenbankklone), obwohl dies derzeit nicht so wichtig erscheint. </p><br><h3 id="vetki-i-razvertyvaniya">  Niederlassungen und Bereitstellungen </h3><br><p>  Jetzt gibt es verschiedene M√∂glichkeiten, neuen Code in Systeme einzugeben: Git-Zweige, Bereitstellungsphase und Funktionsschalter.  Sie l√∂sen ein Problem in verschiedenen Teilen des Workflows: git - in den Phasen vor der Bereitstellung, Bereitstellung - zum Zeitpunkt des √úbergangs vom alten zum neuen Code und Funktionswechsel - f√ºr die kontrollierte Freigabe von neuem Code. </p><br><p>  Der effektivste Weg sind Funktionsschalter (gleichzeitig am einfachsten zu verstehen und zu verwenden).  Mit ihnen k√∂nnen Sie die beiden anderen Methoden vollst√§ndig aufgeben.  Es ist besonders n√ºtzlich, die Bereitstellung zu entfernen. Wenn wir ohnehin Funktionsschalter verwenden, um den Code einzuschlie√üen, birgt der Schritt der √úbertragung der Server auf den neuen Code nur unn√∂tige Risiken. </p><br><p>  Git ist schwer zu benutzen, besonders f√ºr Anf√§nger, und es schr√§nkt es wirklich ein, aber es hat praktische Zweige.  Wir haben viele der Git-M√§ngel behoben.  Dark wird in Echtzeit bearbeitet und bietet die M√∂glichkeit, im Stil von Google Text &amp; Tabellen zusammenzuarbeiten, sodass Sie keinen Code senden m√ºssen und weniger h√§ufig Umz√ºge und Zusammenf√ºhrungen durchf√ºhren k√∂nnen. </p><br><p>  Funktionsschalter unterst√ºtzen die sichere Bereitstellung.  Zusammen mit sofortigen Bereitstellungen k√∂nnen Sie Konzepte in kleinen Fragmenten mit geringem Risiko schnell testen, anstatt eine gr√∂√üere √Ñnderung vorzunehmen, die das System zum Erliegen bringen kann. </p><br><h3 id="versionirovanie">  Versionierung </h3><br><p>  Um Funktionen und Typen zu √§ndern, verwenden wir die Versionierung.  Wenn Sie eine Funktion √§ndern m√∂chten, erstellt Dark eine neue Version dieser Funktion.  Anschlie√üend k√∂nnen Sie diese Version √ºber den Schalter im HTTP- oder Ereignishandler aufrufen.  (Wenn es sich um eine Funktion handelt, die sich tief im Aufrufdiagramm befindet, wird unterwegs eine neue Version jeder Funktion erstellt. Es scheint, als w√§re sie zu viel, aber die Funktionen st√∂ren nicht, wenn Sie sie nicht verwenden, sodass Sie sie nicht einmal bemerken.) </p><br><p>  Aus den gleichen Gr√ºnden versionieren wir Typen.  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem fr√ºheren Beitrag</a> ausf√ºhrlich √ºber unser Typensystem gesprochen. </p><br><p>  Durch die Versionierung von Funktionen und Typen k√∂nnen Sie schrittweise √Ñnderungen an der Anwendung vornehmen.  Sie k√∂nnen √ºberpr√ºfen, ob jeder einzelne Handler mit der neuen Version funktioniert. Sie m√ºssen nicht sofort alle √Ñnderungen an den Anwendungen vornehmen (wir haben jedoch Tools, um dies schnell zu tun, wenn Sie m√∂chten). </p><br><p>  Dies ist viel sicherer, als alles auf einmal vollst√§ndig bereitzustellen. </p><br><h3 id="novye-versii-paketov-i-standartnaya-biblioteka">  Neue Paketversionen und Standardbibliothek </h3><br><p>  Wenn Sie ein Paket in Dark aktualisieren, ersetzen wir nicht sofort die Verwendung jeder Funktion oder jedes Typs in der gesamten Codebasis.  Das ist nicht sicher.  Der Code verwendet weiterhin dieselbe Version wie er, und Sie aktualisieren die Verwendung von Funktionen und Typen mithilfe der Schalter f√ºr jeden Einzelfall auf eine neue Version. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/rh/t3/4w/rht34wyibolrgracbz88tnqqhg0.png"></a> <br>  <em>Ein Screenshot eines Teils eines automatischen Prozesses in Dark mit zwei Versionen der Dict :: get-Funktion.</em>  <em>Dict :: get_v0 gab den Typ Any zur√ºck (den wir ablehnen), und Dict :: get_v1 gab den Typ Option zur√ºck.</em> </p><br><p>  Wir stellen h√§ufig eine neue Funktion in der Standardbibliothek bereit und schlie√üen √§ltere Versionen aus.  Benutzer mit alten Versionen im Code behalten den Zugriff auf sie, aber neue Benutzer k√∂nnen sie nicht erhalten.  Wir werden Tools bereitstellen, mit denen Benutzer in einem Schritt von alten auf neue Versionen √ºbertragen und wieder Funktionsschalter verwenden k√∂nnen. </p><br><p>  Dark bietet auch eine einzigartige M√∂glichkeit: Sobald wir Ihren Arbeitscode ausgef√ºhrt haben, k√∂nnen wir die neuen Versionen selbst testen und die Ausgabe f√ºr neue und alte Anforderungen vergleichen, um Sie √ºber die √Ñnderungen zu informieren.  Infolgedessen stellen Paketaktualisierungen, die h√§ufig blind durchgef√ºhrt werden (oder strenge Sicherheitstests erfordern), weitaus weniger Risiken dar und k√∂nnen automatisch erfolgen. </p><br><h3 id="novye-versii-dark">  Neue dunkle Versionen </h3><br><p>  Der √úbergang von Python 2 zu Python 3 hat sich √ºber ein Jahrzehnt erstreckt und ist nach wie vor ein Problem.  Sobald wir Dark f√ºr die kontinuierliche Bereitstellung erstellt haben, m√ºssen diese Sprach√§nderungen ber√ºcksichtigt werden. </p><br><p>  Wenn wir kleine √Ñnderungen an der Sprache vornehmen, erstellen wir eine neue Version von Dark.  Der alte Code bleibt in der alten Version von Dark und der neue Code wird in der neuen Version verwendet.  Um zur neuen Version von Dark zu wechseln, k√∂nnen Sie die Schalter oder Versionen von Funktionen verwenden. </p><br><p>  Dies ist besonders n√ºtzlich, wenn man bedenkt, dass Dark k√ºrzlich aufgetaucht ist.  Viele √Ñnderungen an der Sprache oder Bibliothek k√∂nnen fehlschlagen.  Die schrittweise Versionierung der Sprache erm√∂glicht es uns, kleinere Aktualisierungen vorzunehmen, dh wir k√∂nnen nicht viele Entscheidungen √ºber die Sprache beschleunigen, bis wir mehr Benutzer und damit mehr Informationen haben. </p><br><h3 id="migracii-baz-dannyh">  Datenbankmigrationen </h3><br><p>  Es gibt eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardformel</a> f√ºr die sichere Datenbankmigration: </p><br><ul><li>  Schreiben Sie den Code neu, um neue und alte Formate zu unterst√ºtzen </li><li>  Konvertieren Sie alle Daten in ein neues Format </li><li>  Alten Datenzugriff l√∂schen </li></ul><br><p>  Infolgedessen verz√∂gert sich die Datenbankmigration und erfordert viele Ressourcen.  Und wir sammeln veraltete Schemata an, weil selbst einfache Aufgaben wie das Korrigieren des Namens einer Tabelle oder Spalte die M√ºhe nicht wert sind. </p><br><p>  Dark verf√ºgt √ºber eine effektive Datenbankmigrationsplattform, die (wir hoffen) den Prozess so stark vereinfacht, dass Sie keine Angst mehr davor haben.  Alle Datenspeicher in Dark (Schl√ºssel-Wert-Paare oder persistente Hash-Tabellen) sind vom Typ.  Um ein Data Warehouse zu migrieren, weisen Sie ihm einfach einen neuen Typ und eine Rollback- und Rollback-Funktion zu, um Werte zwischen den beiden Typen zu konvertieren. </p><br><p>  Der Zugriff auf Data Warehouses in Dark erfolgt √ºber versionierte Variablennamen.  Beispielsweise w√ºrde der Benutzerdatenspeicher zun√§chst als Benutzer-v0 bezeichnet.  Wenn eine neue Version mit einem anderen Typ erstellt wird, √§ndert sich der Name in Users-v1.  Wenn die Daten √ºber Users-v0 gespeichert werden und Sie √ºber Users-v1 darauf zugreifen, wird die Rollover-Funktion angewendet.  Wenn die Daten √ºber Users-v1 gespeichert werden und Sie √ºber Users-v0 darauf zugreifen, wird die Rollback-Funktion verwendet. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ui/sl/wd/uislwdrfrvact0d1ts5icnk-4ka.png"></a> <br>  <em>Bildschirm f√ºr die Datenbankmigration mit Feldnamen f√ºr die alte Datenbank, Rollback- und Rollback-Ausdr√ºcken sowie Anweisungen zum Aktivieren der Migration.</em> </p><br><p>  Verwenden Sie die Funktionsschalter, um Anrufe an Users-v0 an Users-v1 weiterzuleiten.  Sie k√∂nnen jeweils einen HTTP-Handler ausf√ºhren, um Risiken zu reduzieren. Die Switches funktionieren auch f√ºr einzelne Benutzer, sodass Sie √ºberpr√ºfen k√∂nnen, ob alles wie erwartet funktioniert.  Wenn Users-v0 nicht verlassen wird, konvertiert Dark alle verbleibenden Daten im Hintergrund vom alten Format in das neue.  Sie werden es nicht einmal bemerken. </p><br><h3 id="testirovanie">  Testen </h3><br><p>  Dark ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktionale Programmiersprache mit statischer Typisierung</a> und unver√§nderlichen Werten. Daher ist ihre Testfl√§che im Vergleich zu objektorientierten Sprachen mit dynamischer Typisierung erheblich kleiner.  Aber Sie m√ºssen noch testen. <br>  In Dark f√ºhrt der Editor automatisch Unit-Tests im Hintergrund f√ºr bearbeitbaren Code aus und f√ºhrt diese Tests standardm√§√üig f√ºr alle Funktionsschalter aus.  In Zukunft m√∂chten wir die statischen Typen verwenden, um den Code automatisch zu fuzzeln, um Fehler zu finden. </p><br><p>  Dar√ºber hinaus betreibt Dark Ihre Infrastruktur in der Produktion, was neue M√∂glichkeiten er√∂ffnet.  Wir speichern HTTP-Anforderungen automatisch in der Dark-Infrastruktur (im Moment speichern wir alle Anforderungen, m√∂chten dann aber zum Abrufen wechseln).  Wir testen neuen Code auf ihnen und f√ºhren Unit-Tests durch. Wenn Sie m√∂chten, k√∂nnen Sie interessante Abfragen problemlos in Unit-Tests umwandeln. </p><br><h3 id="ot-chego-my-izbavilis">  Was wir losgeworden sind </h3><br><p>  Da wir keine Bereitstellung haben, aber Funktionsschalter vorhanden sind, bleiben etwa 60% der Bereitstellungspipeline √ºber Bord.  Wir ben√∂tigen keine Git-Zweige oder Pool-Anforderungen, um Backend-Ressourcen und -Container zu erstellen, Ressourcen und Container an Registries oder Bereitstellungsschritte in Kubernetes zu senden. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gc/9e/g-/gc9eg-szouq0dtrxxr8jd6c6dyo.jpeg"></a> <br>  <em>Vergleich der Standard-Pipeline f√ºr die kontinuierliche Lieferung (links) und der kontinuierlichen Versorgung mit Dark (rechts).</em>  <em>In Dark besteht die Lieferung aus 6 Schritten und einem Zyklus, w√§hrend die traditionelle Version 35 Schritte und 3 Zyklen umfasst.</em> </p><br><p>  In Dark gibt es nur 6 Schritte und 1 Zyklus in der Bereitstellung (Schritte, die mehrmals wiederholt werden), w√§hrend die moderne Pipeline f√ºr die kontinuierliche Versorgung aus 35 Schritten und 3 Zyklen besteht.  In Dark werden Tests automatisch ausgef√ºhrt und Sie sehen sie nicht einmal.  Abh√§ngigkeiten werden automatisch installiert.  Alles, was mit Git oder Github zu tun hat, wird nicht mehr ben√∂tigt.  Es ist nicht erforderlich, Docker-Container zu sammeln, zu testen und zu senden.  Die Bereitstellung von Kubernetes wird nicht mehr ben√∂tigt. </p><br><p>  Sogar die verbleibenden Schritte in Dark sind einfacher geworden.  Da Funktionsschalter in einer Aktion gesteuert werden k√∂nnen, m√ºssen Sie nicht ein zweites Mal die gesamte Bereitstellungspipeline durchlaufen, um den alten Code zu entfernen. </p><br><p>  Wir haben die Codebereitstellung so weit wie m√∂glich vereinfacht und so die Zeit und das Risiko einer kontinuierlichen Bereitstellung reduziert.  Wir haben au√üerdem Paketaktualisierungen, Datenbankmigrationen, Tests, Versionskontrolle, Abh√§ngigkeitsinstallation, Gleichheit zwischen Entwicklungsumgebung und Produktion sowie schnelle und sichere Sprachversionsaktualisierungen erheblich vereinfacht. </p><br><p>  Ich beantworte Fragen dazu auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HackerNews</a> . </p><br><p>  Um mehr √ºber das Dark-Ger√§t zu erfahren, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Dark-Artikel</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">folgen Sie uns auf Twitter</a> (oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mir</a> ) oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">melden Sie sich f√ºr eine Beta-Version an und erhalten Sie Benachrichtigungen √ºber die folgenden Beitr√§ge</a> .  Wenn Sie im September zu StrangeLoop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kommen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kommen Sie zu unserer Einf√ºhrung</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462027/">https://habr.com/ru/post/de462027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462013/index.html">Verlauf des Docker-Speicher-Migrationsproblems (Docker-Root)</a></li>
<li><a href="../de462015/index.html">SAP-Berichtsuniversum</a></li>
<li><a href="../de462021/index.html">Wie man aufh√∂rt, dasselbe zu tun</a></li>
<li><a href="../de462023/index.html">Cascadeur: Die Zukunft der Spielanimation</a></li>
<li><a href="../de462025/index.html">Relationales Netzwerkdatenmodell</a></li>
<li><a href="../de462029/index.html">19 n√ºtzliche Funktionen der .htaccess-Datei</a></li>
<li><a href="../de462031/index.html">Zum Beispiel, wenn Sie die Protokolle lesen !: Starten Sie Hotspot 2.0 im Wi-Fi-Netzwerk in der U-Bahn</a></li>
<li><a href="../de462033/index.html">Das letzte Abendmahl der Entwickler</a></li>
<li><a href="../de462035/index.html">Python gegen R - Data Science</a></li>
<li><a href="../de462041/index.html">Mobile Segmentierungsans√§tze - √úbersetzung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>