<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏽 👨🏾‍🚀 🎺 Wie Dark 50ms Code einsetzt 🧑 🚣🏼 🖕🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je schneller der Entwicklungsprozess ist, desto schneller entwickelt sich das Technologieunternehmen. 


 Leider arbeiten moderne Anwendungen gegen un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Dark 50ms Code einsetzt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/462027/"><p><img src="https://habrastorage.org/webt/o4/lk/bi/o4lkbi449pbpjqw84e0wt-tywlq.png"></p><br><p>  Je schneller der Entwicklungsprozess ist, desto schneller entwickelt sich das Technologieunternehmen. </p><br><p>  Leider arbeiten moderne Anwendungen gegen uns - unsere Systeme müssen in Echtzeit aktualisiert werden und gleichzeitig niemanden stören und dürfen nicht zu Ausfallzeiten und Unterbrechungen führen.  Die Bereitstellung in solchen Systemen wird zu einer komplexen Aufgabe und erfordert komplexe Pipelines für die kontinuierliche Lieferung, selbst in kleinen Teams. </p><br><p>  Diese Pipelines haben normalerweise eine enge Anwendung, arbeiten langsam und sind nicht zuverlässig.  Entwickler müssen sie zuerst manuell erstellen und dann verwalten, und Unternehmen stellen häufig ganze DevOps-Teams dafür ein. </p><br><p>  Die Entwicklungsgeschwindigkeit hängt von der Geschwindigkeit dieser Pipelines ab.  Für die besten Teams dauert die Bereitstellung 5-10 Minuten, normalerweise jedoch viel länger und für eine Bereitstellung mehrere Stunden. </p><a name="habracut"></a><br><p>  In Dark dauert es 50 ms.  <em>Fünfzig.</em>  <em>Millisekunden</em>  Dark ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Komplettlösung mit einer Programmiersprache, einem Editor und einer Infrastruktur,</a> die speziell für die kontinuierliche Bereitstellung entwickelt wurden. Alle Aspekte von Dark, einschließlich der Sprache selbst, wurden im Hinblick auf eine sichere sofortige Bereitstellung erstellt. </p><br><h3 id="pochemu-konveyery-nepreryvnoy-postavki-takie-medlennye">  Warum sind kontinuierliche Förderer so langsam? </h3><br><p> Angenommen, wir haben eine Python-Webanwendung und haben bereits eine wunderbare und moderne Pipeline für die kontinuierliche Bereitstellung erstellt.  Für einen Entwickler, der jeden Tag mit diesem Projekt beschäftigt ist, sieht die Bereitstellung einer geringfügigen Änderung ungefähr so ​​aus: </p><br><h3 id="vnesenie-izmeneniy">  Änderungen vornehmen </h3><br><ul><li>  Erstellen eines neuen Zweigs in Git </li><li>  Änderungen hinter dem Funktionsschalter vornehmen </li><li>  Unit-Test zur Überprüfung von Änderungen mit und ohne Funktionsschalter </li></ul><br><h3 id="pul-rekvest">  Poolanfrage </h3><br><ul><li>  Commit Commit </li><li>  Veröffentlichen von Änderungen in einem Remote-Repository auf github </li><li>  Poolanfrage </li><li>  CI wird automatisch im Hintergrund erstellt </li><li>  Codeüberprüfung </li><li>  Falls erforderlich, noch ein paar Bewertungen </li><li>  Änderungen mit dem Git-Assistenten zusammenführen. </li></ul><br><h3 id="ci-vypolnyaetsya-na-mastere">  CI wird auf dem Assistenten ausgeführt </h3><br><ul><li>  Festlegen von Frontend-Abhängigkeiten über npm </li><li>  Erstellen und Optimieren von HTML + CSS + JS-Ressourcen </li><li>  Führen Sie das vordere Ende der Geräte- und Funktionstests aus </li><li>  Installieren Sie Python-Abhängigkeiten von PyPI </li><li>  Führen Sie das Backend von Unit- und Funktionstests aus </li><li>  Integrationstests an beiden Enden </li><li>  Senden Sie Frontend-Ressourcen an CDN </li><li>  Erstellen eines Containers für ein Python-Programm </li><li>  Senden eines Containers an die Registrierung </li><li>  Kubernetes Manifest Update </li></ul><br><h3 id="zamena-starogo-koda-novym">  Alten Code durch neuen ersetzen </h3><br><ul><li>  Kubernetes startet mehrere Instanzen eines neuen Containers </li><li>  Kubernetes wartet darauf, dass Instanzen betriebsbereit werden </li><li>  Kubernetes fügt dem HTTP Load Balancer Instanzen hinzu </li><li>  Kubernetes wartet darauf, dass alte Instanzen nicht mehr verwendet werden </li><li>  Kubernetes stoppt alte Instanzen </li><li>  Kubernetes wiederholt diese Vorgänge, bis neue Instanzen alle alten ersetzen </li></ul><br><h3 id="vklyuchenie-novogo-pereklyuchatelya-funkcii">  Schalten Sie den neuen Funktionsschalter ein </h3><br><ul><li>  Der neue Code ist nur für mich enthalten, um sicherzustellen, dass alles in Ordnung ist </li><li>  Für 10% der Benutzer ist neuer Code enthalten, Betriebs- und Geschäftsmetriken werden nachverfolgt </li><li>  Für 50% der Benutzer ist neuer Code enthalten, Betriebs- und Geschäftsmetriken werden nachverfolgt </li><li>  Der neue Code ist für 100% der Benutzer enthalten. Betriebs- und Geschäftsmetriken werden nachverfolgt </li><li>  Schließlich wiederholen Sie den gesamten Vorgang, um den alten Code zu entfernen und zu wechseln </li></ul><br><p>  Der Prozess hängt von den Tools, der Sprache und der Verwendung serviceorientierter Architekturen ab, sieht aber im Allgemeinen so aus.  Ich habe die Bereitstellung von Datenbankmigrationen nicht erwähnt, da dies eine sorgfältige Planung erfordert. Im Folgenden werde ich jedoch beschreiben, wie Dark damit umgeht. </p><br><p>  Hier gibt es viele Komponenten, von denen viele leicht langsamer werden, abstürzen, vorübergehende Konkurrenz verursachen oder das funktionierende System zum Erliegen bringen können. </p><br><p>  Und da diese Pipelines fast immer für einen besonderen Anlass erstellt werden, ist es schwierig, sich auf sie zu verlassen.  Viele Menschen haben Tage, an denen der Code nicht bereitgestellt werden kann, weil es Probleme in der Docker-Datei gibt, einer der Dutzenden von Diensten abgestürzt ist oder der richtige Spezialist im Urlaub. </p><br><p>  Schlimmer noch, viele dieser Schritte bewirken überhaupt nichts.  Wir haben sie früher benötigt, als wir den Code sofort für Benutzer bereitgestellt haben, aber jetzt haben wir Schalter für den neuen Code, und diese Prozesse sind unterteilt.  Infolgedessen ist der Schritt, in dem der Code bereitgestellt wird (der alte wird durch den neuen ersetzt), nur noch ein zusätzliches Risiko. </p><br><p>  Dies ist natürlich eine sehr durchdachte Pipeline.  Das Team, das es erstellt hat, brauchte Zeit und Geld, um es schnell bereitzustellen.  Normalerweise sind Bereitstellungspipelines viel langsamer und unzuverlässiger. </p><br><h3 id="realizaciya-nepreryvnoy-postavki-v-dark">  Kontinuierliche Lieferung im Dunkeln implementieren </h3><br><p>  Die kontinuierliche Lieferung ist für Dark so wichtig, dass wir die Zeit in weniger als einer Sekunde im Visier haben.  Wir gingen alle Schritte der Pipeline durch, um alles Unnötige zu entfernen, und erinnerten uns an den Rest.  So haben wir die Schritte entfernt. </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jessie Frazelle</a> prägte das neue Wort Deployless auf der Future of Software Development-Konferenz in Reykjavik </blockquote><p>  Wir entschieden sofort, dass Dark auf dem Konzept von „Deployless“ basieren würde (danke an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jesse Frazel</a> für den Neologismus).  Deployless bedeutet, dass jeder Code sofort bereitgestellt und für die Produktion bereit ist.  Natürlich werden wir keinen fehlerhaften oder unvollständigen Code verpassen (ich werde die Sicherheitsprinzipien unten beschreiben). </p><br><p>  Bei der Dark-Demo wurden wir oft gefragt, wie wir die Bereitstellung beschleunigen konnten.  Komische Frage.  Die Leute denken wahrscheinlich, dass wir eine Art Supertechnologie entwickelt haben, die den Code vergleicht, kompiliert, in einen Container packt, eine virtuelle Maschine startet, einen Container auf eine kalte startet und ähnliches - und das alles in 50 ms.  Das ist kaum möglich.  Wir haben jedoch eine spezielle Deployment-Engine erstellt, die all dies nicht benötigt. </p><br><p>  Dark startet Dolmetscher in der Cloud.  Angenommen, Sie schreiben Code in eine Funktion oder einen Handler für HTTP oder Ereignisse.  Wir senden diff an den abstrakten Syntaxbaum (die Implementierung des von unserem Editor und unseren Servern intern verwendeten Codes) an unsere Server und führen diesen Code dann aus, wenn Anforderungen eingehen.  Die Bereitstellung sieht also wie ein bescheidener Datensatz in der Datenbank aus - sofort und elementar.  Die Bereitstellung ist so schnell, weil sie das Nötigste beinhaltet. </p><br><p>  In Zukunft planen wir, aus Dark einen Infrastruktur-Compiler zu machen, der die ideale Infrastruktur für hohe Leistung und Zuverlässigkeit von Anwendungen erstellt und ausführt.  Die sofortige Bereitstellung geht natürlich nirgendwo hin. </p><br><h2 id="bezopasnoe-razvertyvanie">  Sichere Bereitstellung </h2><br><h3 id="strukturirovannyy-redaktor">  Strukturierter Editor </h3><br><p>  Der Code in Dark wird im Dark-Editor geschrieben.  Der strukturierte Editor macht keine Syntaxfehler.  Tatsächlich hat Dark nicht einmal einen Analysator.  Während der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eingabe</a> arbeiten wir direkt mit dem Abstract Syntax Tree (AST) wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paredit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sketch-n-Sketch</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tofu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prune</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MPS</a> . </p><br><p>  Jeder unvollständige Code in Dark hat eine gültige Ausführungssemantik, ähnlich wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">typisierte Löcher in Hazel</a> .  Wenn Sie beispielsweise einen Funktionsaufruf ändern, behalten wir die alte Funktion bei, bis die neue verwendbar wird. </p><br><p>  Jedes Programm in Dark hat seine eigene Bedeutung, sodass unvollständiger Code die fertige Arbeit nicht beeinträchtigt. </p><br><h3 id="rezhimy-redaktirovaniya">  Bearbeitungsmodi </h3><br><p>  Sie schreiben in zwei Fällen Code in Dark.  Erstens: Sie schreiben neuen Code und sind der einzige Benutzer.  Beispielsweise befindet es sich in der REPL, und andere Benutzer erhalten niemals Zugriff darauf, oder es handelt sich um eine neue HTTP-Route, auf die Sie nirgendwo verweisen.  Sie können hier ohne Vorsichtsmaßnahmen arbeiten, und jetzt arbeiten Sie ungefähr in der Entwicklungsumgebung. </p><br><p>  Zweite Situation: Der Code wird bereits verwendet.  Wenn der Datenverkehr durch den Code geleitet wird (Funktionen, Ereignishandler, Datenbanken, Typ), muss vorsichtig vorgegangen werden.  Zu diesem Zweck blockieren wir den gesamten verwendeten Code und benötigen strukturiertere Tools, um ihn zu bearbeiten.  Im Folgenden werde ich auf strukturelle Tools eingehen: Funktionsschalter für HTTP- und Ereignishandler, eine leistungsstarke Migrationsplattform für Datenbanken und eine neue Versionskontrollmethode für Funktionen und Typen. </p><br><h3 id="pereklyuchateli-funkciy">  Funktionsschalter </h3><br><p>  Eine Möglichkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, die zusätzliche Komplexität</a> in Dark <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu beseitigen,</a> besteht darin, mehrere Probleme mit einer Lösung zu beheben.  Funktionsschalter führen viele verschiedene Aufgaben aus: Ersetzen der lokalen Entwicklungsumgebung, Git-Zweige, Bereitstellen von Code und natürlich die traditionelle langsame und kontrollierte Freigabe von neuem Code. </p><br><p>  Die Erstellung und Bereitstellung eines Funktionsschalters erfolgt in unserem Editor in einem Arbeitsgang.  Es erstellt einen leeren Bereich für neuen Code und bietet Zugriffssteuerungen für alten und neuen Code sowie Schaltflächen und Befehle für den schrittweisen Übergang zu neuem Code oder dessen Ausschluss. </p><br><p>  Funktionsschalter sind in die dunkle Sprache integriert, und selbst unvollständige Schalter erfüllen ihre Aufgabe. Wenn die Bedingung im Schalter nicht erfüllt ist, wird der alte blockierte Code ausgeführt. </p><br><h3 id="sreda-razrabotki">  Entwicklungsumgebung </h3><br><p>  Funktionsschalter ersetzen die lokale Entwicklungsumgebung.  Heutzutage ist es für Teams schwierig sicherzustellen, dass alle Benutzer dieselben Versionen von Tools und Bibliotheken verwenden (Code-Formatierer, Linters, Paketmanager, Compiler, Präprozessoren, Testtools usw.). Mit Dark müssen Sie keine Abhängigkeiten lokal installieren, die lokale Installation von Docker oder steuern Ergreifen Sie andere Maßnahmen, um zumindest einen Anschein von Gleichheit zwischen Entwicklungsumgebung und Produktion zu gewährleisten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angesichts der Tatsache, dass eine solche Gleichstellung immer noch unmöglich ist</a> , werden wir nicht einmal so tun, als würden wir danach streben. </p><br><p>  Anstatt eine geklonte lokale Umgebung zu erstellen, erstellen die Switches in Dark eine neue Sandbox in der Produktion, die die Entwicklungsumgebung ersetzt.  In Zukunft planen wir auch, eine Sandbox für andere Teile der Anwendung zu erstellen (z. B. sofortige Datenbankklone), obwohl dies derzeit nicht so wichtig erscheint. </p><br><h3 id="vetki-i-razvertyvaniya">  Niederlassungen und Bereitstellungen </h3><br><p>  Jetzt gibt es verschiedene Möglichkeiten, neuen Code in Systeme einzugeben: Git-Zweige, Bereitstellungsphase und Funktionsschalter.  Sie lösen ein Problem in verschiedenen Teilen des Workflows: git - in den Phasen vor der Bereitstellung, Bereitstellung - zum Zeitpunkt des Übergangs vom alten zum neuen Code und Funktionswechsel - für die kontrollierte Freigabe von neuem Code. </p><br><p>  Der effektivste Weg sind Funktionsschalter (gleichzeitig am einfachsten zu verstehen und zu verwenden).  Mit ihnen können Sie die beiden anderen Methoden vollständig aufgeben.  Es ist besonders nützlich, die Bereitstellung zu entfernen. Wenn wir ohnehin Funktionsschalter verwenden, um den Code einzuschließen, birgt der Schritt der Übertragung der Server auf den neuen Code nur unnötige Risiken. </p><br><p>  Git ist schwer zu benutzen, besonders für Anfänger, und es schränkt es wirklich ein, aber es hat praktische Zweige.  Wir haben viele der Git-Mängel behoben.  Dark wird in Echtzeit bearbeitet und bietet die Möglichkeit, im Stil von Google Text &amp; Tabellen zusammenzuarbeiten, sodass Sie keinen Code senden müssen und weniger häufig Umzüge und Zusammenführungen durchführen können. </p><br><p>  Funktionsschalter unterstützen die sichere Bereitstellung.  Zusammen mit sofortigen Bereitstellungen können Sie Konzepte in kleinen Fragmenten mit geringem Risiko schnell testen, anstatt eine größere Änderung vorzunehmen, die das System zum Erliegen bringen kann. </p><br><h3 id="versionirovanie">  Versionierung </h3><br><p>  Um Funktionen und Typen zu ändern, verwenden wir die Versionierung.  Wenn Sie eine Funktion ändern möchten, erstellt Dark eine neue Version dieser Funktion.  Anschließend können Sie diese Version über den Schalter im HTTP- oder Ereignishandler aufrufen.  (Wenn es sich um eine Funktion handelt, die sich tief im Aufrufdiagramm befindet, wird unterwegs eine neue Version jeder Funktion erstellt. Es scheint, als wäre sie zu viel, aber die Funktionen stören nicht, wenn Sie sie nicht verwenden, sodass Sie sie nicht einmal bemerken.) </p><br><p>  Aus den gleichen Gründen versionieren wir Typen.  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem früheren Beitrag</a> ausführlich über unser Typensystem gesprochen. </p><br><p>  Durch die Versionierung von Funktionen und Typen können Sie schrittweise Änderungen an der Anwendung vornehmen.  Sie können überprüfen, ob jeder einzelne Handler mit der neuen Version funktioniert. Sie müssen nicht sofort alle Änderungen an den Anwendungen vornehmen (wir haben jedoch Tools, um dies schnell zu tun, wenn Sie möchten). </p><br><p>  Dies ist viel sicherer, als alles auf einmal vollständig bereitzustellen. </p><br><h3 id="novye-versii-paketov-i-standartnaya-biblioteka">  Neue Paketversionen und Standardbibliothek </h3><br><p>  Wenn Sie ein Paket in Dark aktualisieren, ersetzen wir nicht sofort die Verwendung jeder Funktion oder jedes Typs in der gesamten Codebasis.  Das ist nicht sicher.  Der Code verwendet weiterhin dieselbe Version wie er, und Sie aktualisieren die Verwendung von Funktionen und Typen mithilfe der Schalter für jeden Einzelfall auf eine neue Version. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/rh/t3/4w/rht34wyibolrgracbz88tnqqhg0.png"></a> <br>  <em>Ein Screenshot eines Teils eines automatischen Prozesses in Dark mit zwei Versionen der Dict :: get-Funktion.</em>  <em>Dict :: get_v0 gab den Typ Any zurück (den wir ablehnen), und Dict :: get_v1 gab den Typ Option zurück.</em> </p><br><p>  Wir stellen häufig eine neue Funktion in der Standardbibliothek bereit und schließen ältere Versionen aus.  Benutzer mit alten Versionen im Code behalten den Zugriff auf sie, aber neue Benutzer können sie nicht erhalten.  Wir werden Tools bereitstellen, mit denen Benutzer in einem Schritt von alten auf neue Versionen übertragen und wieder Funktionsschalter verwenden können. </p><br><p>  Dark bietet auch eine einzigartige Möglichkeit: Sobald wir Ihren Arbeitscode ausgeführt haben, können wir die neuen Versionen selbst testen und die Ausgabe für neue und alte Anforderungen vergleichen, um Sie über die Änderungen zu informieren.  Infolgedessen stellen Paketaktualisierungen, die häufig blind durchgeführt werden (oder strenge Sicherheitstests erfordern), weitaus weniger Risiken dar und können automatisch erfolgen. </p><br><h3 id="novye-versii-dark">  Neue dunkle Versionen </h3><br><p>  Der Übergang von Python 2 zu Python 3 hat sich über ein Jahrzehnt erstreckt und ist nach wie vor ein Problem.  Sobald wir Dark für die kontinuierliche Bereitstellung erstellt haben, müssen diese Sprachänderungen berücksichtigt werden. </p><br><p>  Wenn wir kleine Änderungen an der Sprache vornehmen, erstellen wir eine neue Version von Dark.  Der alte Code bleibt in der alten Version von Dark und der neue Code wird in der neuen Version verwendet.  Um zur neuen Version von Dark zu wechseln, können Sie die Schalter oder Versionen von Funktionen verwenden. </p><br><p>  Dies ist besonders nützlich, wenn man bedenkt, dass Dark kürzlich aufgetaucht ist.  Viele Änderungen an der Sprache oder Bibliothek können fehlschlagen.  Die schrittweise Versionierung der Sprache ermöglicht es uns, kleinere Aktualisierungen vorzunehmen, dh wir können nicht viele Entscheidungen über die Sprache beschleunigen, bis wir mehr Benutzer und damit mehr Informationen haben. </p><br><h3 id="migracii-baz-dannyh">  Datenbankmigrationen </h3><br><p>  Es gibt eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardformel</a> für die sichere Datenbankmigration: </p><br><ul><li>  Schreiben Sie den Code neu, um neue und alte Formate zu unterstützen </li><li>  Konvertieren Sie alle Daten in ein neues Format </li><li>  Alten Datenzugriff löschen </li></ul><br><p>  Infolgedessen verzögert sich die Datenbankmigration und erfordert viele Ressourcen.  Und wir sammeln veraltete Schemata an, weil selbst einfache Aufgaben wie das Korrigieren des Namens einer Tabelle oder Spalte die Mühe nicht wert sind. </p><br><p>  Dark verfügt über eine effektive Datenbankmigrationsplattform, die (wir hoffen) den Prozess so stark vereinfacht, dass Sie keine Angst mehr davor haben.  Alle Datenspeicher in Dark (Schlüssel-Wert-Paare oder persistente Hash-Tabellen) sind vom Typ.  Um ein Data Warehouse zu migrieren, weisen Sie ihm einfach einen neuen Typ und eine Rollback- und Rollback-Funktion zu, um Werte zwischen den beiden Typen zu konvertieren. </p><br><p>  Der Zugriff auf Data Warehouses in Dark erfolgt über versionierte Variablennamen.  Beispielsweise würde der Benutzerdatenspeicher zunächst als Benutzer-v0 bezeichnet.  Wenn eine neue Version mit einem anderen Typ erstellt wird, ändert sich der Name in Users-v1.  Wenn die Daten über Users-v0 gespeichert werden und Sie über Users-v1 darauf zugreifen, wird die Rollover-Funktion angewendet.  Wenn die Daten über Users-v1 gespeichert werden und Sie über Users-v0 darauf zugreifen, wird die Rollback-Funktion verwendet. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ui/sl/wd/uislwdrfrvact0d1ts5icnk-4ka.png"></a> <br>  <em>Bildschirm für die Datenbankmigration mit Feldnamen für die alte Datenbank, Rollback- und Rollback-Ausdrücken sowie Anweisungen zum Aktivieren der Migration.</em> </p><br><p>  Verwenden Sie die Funktionsschalter, um Anrufe an Users-v0 an Users-v1 weiterzuleiten.  Sie können jeweils einen HTTP-Handler ausführen, um Risiken zu reduzieren. Die Switches funktionieren auch für einzelne Benutzer, sodass Sie überprüfen können, ob alles wie erwartet funktioniert.  Wenn Users-v0 nicht verlassen wird, konvertiert Dark alle verbleibenden Daten im Hintergrund vom alten Format in das neue.  Sie werden es nicht einmal bemerken. </p><br><h3 id="testirovanie">  Testen </h3><br><p>  Dark ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktionale Programmiersprache mit statischer Typisierung</a> und unveränderlichen Werten. Daher ist ihre Testfläche im Vergleich zu objektorientierten Sprachen mit dynamischer Typisierung erheblich kleiner.  Aber Sie müssen noch testen. <br>  In Dark führt der Editor automatisch Unit-Tests im Hintergrund für bearbeitbaren Code aus und führt diese Tests standardmäßig für alle Funktionsschalter aus.  In Zukunft möchten wir die statischen Typen verwenden, um den Code automatisch zu fuzzeln, um Fehler zu finden. </p><br><p>  Darüber hinaus betreibt Dark Ihre Infrastruktur in der Produktion, was neue Möglichkeiten eröffnet.  Wir speichern HTTP-Anforderungen automatisch in der Dark-Infrastruktur (im Moment speichern wir alle Anforderungen, möchten dann aber zum Abrufen wechseln).  Wir testen neuen Code auf ihnen und führen Unit-Tests durch. Wenn Sie möchten, können Sie interessante Abfragen problemlos in Unit-Tests umwandeln. </p><br><h3 id="ot-chego-my-izbavilis">  Was wir losgeworden sind </h3><br><p>  Da wir keine Bereitstellung haben, aber Funktionsschalter vorhanden sind, bleiben etwa 60% der Bereitstellungspipeline über Bord.  Wir benötigen keine Git-Zweige oder Pool-Anforderungen, um Backend-Ressourcen und -Container zu erstellen, Ressourcen und Container an Registries oder Bereitstellungsschritte in Kubernetes zu senden. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gc/9e/g-/gc9eg-szouq0dtrxxr8jd6c6dyo.jpeg"></a> <br>  <em>Vergleich der Standard-Pipeline für die kontinuierliche Lieferung (links) und der kontinuierlichen Versorgung mit Dark (rechts).</em>  <em>In Dark besteht die Lieferung aus 6 Schritten und einem Zyklus, während die traditionelle Version 35 Schritte und 3 Zyklen umfasst.</em> </p><br><p>  In Dark gibt es nur 6 Schritte und 1 Zyklus in der Bereitstellung (Schritte, die mehrmals wiederholt werden), während die moderne Pipeline für die kontinuierliche Versorgung aus 35 Schritten und 3 Zyklen besteht.  In Dark werden Tests automatisch ausgeführt und Sie sehen sie nicht einmal.  Abhängigkeiten werden automatisch installiert.  Alles, was mit Git oder Github zu tun hat, wird nicht mehr benötigt.  Es ist nicht erforderlich, Docker-Container zu sammeln, zu testen und zu senden.  Die Bereitstellung von Kubernetes wird nicht mehr benötigt. </p><br><p>  Sogar die verbleibenden Schritte in Dark sind einfacher geworden.  Da Funktionsschalter in einer Aktion gesteuert werden können, müssen Sie nicht ein zweites Mal die gesamte Bereitstellungspipeline durchlaufen, um den alten Code zu entfernen. </p><br><p>  Wir haben die Codebereitstellung so weit wie möglich vereinfacht und so die Zeit und das Risiko einer kontinuierlichen Bereitstellung reduziert.  Wir haben außerdem Paketaktualisierungen, Datenbankmigrationen, Tests, Versionskontrolle, Abhängigkeitsinstallation, Gleichheit zwischen Entwicklungsumgebung und Produktion sowie schnelle und sichere Sprachversionsaktualisierungen erheblich vereinfacht. </p><br><p>  Ich beantworte Fragen dazu auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HackerNews</a> . </p><br><p>  Um mehr über das Dark-Gerät zu erfahren, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Dark-Artikel</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">folgen Sie uns auf Twitter</a> (oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mir</a> ) oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">melden Sie sich für eine Beta-Version an und erhalten Sie Benachrichtigungen über die folgenden Beiträge</a> .  Wenn Sie im September zu StrangeLoop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kommen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kommen Sie zu unserer Einführung</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462027/">https://habr.com/ru/post/de462027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462013/index.html">Verlauf des Docker-Speicher-Migrationsproblems (Docker-Root)</a></li>
<li><a href="../de462015/index.html">SAP-Berichtsuniversum</a></li>
<li><a href="../de462021/index.html">Wie man aufhört, dasselbe zu tun</a></li>
<li><a href="../de462023/index.html">Cascadeur: Die Zukunft der Spielanimation</a></li>
<li><a href="../de462025/index.html">Relationales Netzwerkdatenmodell</a></li>
<li><a href="../de462029/index.html">19 nützliche Funktionen der .htaccess-Datei</a></li>
<li><a href="../de462031/index.html">Zum Beispiel, wenn Sie die Protokolle lesen !: Starten Sie Hotspot 2.0 im Wi-Fi-Netzwerk in der U-Bahn</a></li>
<li><a href="../de462033/index.html">Das letzte Abendmahl der Entwickler</a></li>
<li><a href="../de462035/index.html">Python gegen R - Data Science</a></li>
<li><a href="../de462041/index.html">Mobile Segmentierungsansätze - Übersetzung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>