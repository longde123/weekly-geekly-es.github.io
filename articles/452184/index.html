<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹 🔯 🚵 Sobre el anonimato en blockchains basados ​​en cuentas 👣 👐 🎭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante mucho tiempo hemos estado interesados ​​en el tema del anonimato en las criptomonedas y tratamos de seguir el desarrollo de tecnologías en est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sobre el anonimato en blockchains basados ​​en cuentas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/exante/blog/452184/">  Durante mucho tiempo hemos estado interesados ​​en el tema del anonimato en las criptomonedas y tratamos de seguir el desarrollo de tecnologías en esta área.  En nuestros artículos, ya hemos examinado en detalle los principios de operación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transacciones confidenciales</a> en Monero, y también hemos realizado una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">revisión comparativa de las</a> tecnologías que existen en este campo.  Sin embargo, todas las criptomonedas anónimas de hoy se basan en el modelo de datos propuesto por Bitcoin: Salida de transacciones no gastadas (en adelante, UTXO).  Para blockchains basadas en cuentas como Ethereum, las soluciones existentes para la implementación del anonimato y la privacidad (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mobius</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aztec</a> ) intentaron repetir el modelo UTXO en los contratos inteligentes. <br><br>  En febrero de 2019, un grupo de investigadores de la Universidad de Stanford y Visa Research <a name="habracut"></a>  lanzó el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">preprint</a> "Zether: hacia la privacidad en el mundo de los contratos inteligentes".  Los autores primero propusieron un enfoque para garantizar el anonimato en blockchains basados ​​en cuentas y presentaron dos opciones para un contrato inteligente: para transacciones confidenciales (ocultando saldos y cantidades de transferencia) y anónimas (ocultando destinatario y remitente).  Consideramos que la tecnología propuesta es interesante y nos gustaría compartir su dispositivo, así como hablar sobre por qué el problema del anonimato en blockchains basados ​​en cuentas se considera muy complejo y si los autores lograron resolverlo por completo. <br><br><cut></cut><br><br><h3>  Sobre el dispositivo de estos modelos de datos </h3><br>  En el modelo UTXO, una transacción consta de "entradas" y "salidas".  Un análogo directo a las "salidas" es el billete en su billetera: cada "salida" tiene una cierta denominación.  Cuando paga con alguien (forma una transacción), gasta uno o más "resultados", mientras se convierten en "entradas" de la transacción, y la cadena de bloques los marca como gastados.  Al mismo tiempo, el destinatario de su pago (o usted mismo, si necesita un cambio) recibe los "resultados" recién generados.  Esquemáticamente, esto se puede representar de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/tj/ed/8o/tjed8olalcrirbjpupoms6bwejo.png" alt="imagen"><br><br>  Las blockchains basadas en cuentas están estructuradas como su cuenta bancaria.  Solo operan sobre el monto en su cuenta y el monto de la transferencia.  Cuando transfiere una cierta cantidad de su cuenta, no quema ninguna "salida", la red no necesita recordar qué monedas se gastan y cuáles no.  En el caso más simple, la verificación de una transacción se reduce a verificar la firma del remitente y el monto en su balance: <br><br><img src="https://habrastorage.org/webt/kw/pg/zn/kwpgzn1wg1mmztznetqntcdfbca.png" alt="imagen"><br><br><h3>  Análisis de tecnología </h3><br>  A continuación, hablaremos sobre cómo Zether oculta la cantidad de transacciones, el destinatario y el remitente.  En el curso de la descripción de los principios de su trabajo, notaremos las diferencias en la versión confidencial y anónima.  Dado que es mucho más fácil garantizar la confidencialidad en blockchains basados ​​en cuentas, algunas de las restricciones impuestas por el anonimato no serán relevantes para una versión confidencial de la tecnología. <br><br><h4>  Ocultación de saldos e importes de transferencia. </h4><br>  Zether utiliza el esquema de encriptación <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El Gamal</a> para encriptar saldos y transferir cantidades.  Funciona de la siguiente manera.  Cuando Alice quiere enviar monedas de Bob <i><b>b</b></i> a la dirección (su clave pública) <i><b>Y</b></i> , elige un número aleatorio <i><b>r</b></i> y cifra la cantidad: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ky/t6/3x/kyt63xxqcoleppvesgfpoubyj8y.png" alt="imagen"></div><br>  donde <i><b>C</b></i> es la suma cifrada, <i><b>D</b></i> es el valor auxiliar necesario para descifrar esta suma, <i><b>G</b></i> es el punto fijo en la curva elíptica, cuando la clave secreta se multiplica por la cual se obtiene la clave pública. <br><br>  Cuando Bob recibe estos valores, simplemente los agrega a su saldo, encriptados de la misma manera, lo cual es conveniente para este esquema. <br><br>  De manera similar, Alice resta los mismos valores de su balance general, solo usa <i><b>Y</b></i> como su clave pública. <br><br><h4>  Ocultamiento del destinatario y remitente. </h4><br>  La mezcla de "salidas" en UTXO apareció en los albores de las criptomonedas y ayuda a ocultar al remitente.  Para hacer esto, el remitente, cuando realiza una transferencia, recoge "salidas" aleatorias en la cadena de bloques y las amasa con las suyas.  Luego firma las "salidas" con una firma de anillo, un mecanismo criptográfico que le permite convencer al verificador de que entre las "salidas" involucradas hay monedas emisoras.  Las monedas implicadas, por supuesto, no se desperdician. <br><br>  Sin embargo, para ocultar al destinatario, no podremos generar "salidas" falsas.  Por lo tanto, en UTXO, cada "salida" tiene su propia dirección única, y está criptográficamente asociada con la dirección del destinatario de estas monedas.  Por el momento, no hay forma de identificar la relación entre la dirección de "salida" única y la dirección del destinatario sin conocer sus claves secretas. <br><br>  En un modelo basado en cuentas, no podemos usar direcciones de una sola vez (de lo contrario, ya será un modelo de "salidas").  Por lo tanto, el destinatario y el remitente deben ser amasados ​​entre otras cuentas en la cadena de bloques.  Al mismo tiempo, las monedas cifradas 0 se debitan de las cuentas amasadas (o se agrega 0, en el caso de un amasador del destinatario), sin cambiar realmente su saldo real. <br><br>  Dado que tanto el remitente como el destinatario siempre tienen una dirección permanente, aquí es necesario usar los mismos grupos para mezclar con las mismas direcciones.  Es más fácil considerar esto con un ejemplo. <br><br>  Supongamos que Alice decide contribuir a la organización benéfica de Bob, pero prefiere que la transferencia permanezca anónima a un observador externo.  Luego, para disfrazarse en el campo del remitente, también ingresa a las cuentas de Adam y Adele.  Y para ocultar a Bob, en el campo del destinatario, además de las cuentas de Ben y Bill.  Al hacer la próxima entrega, Alice decidió ingresar a Alex y Amanda junto a ella, y Bruce y Bengen junto a Bob.  En este caso, al analizar la cadena de bloques en estas dos transacciones, solo hay un par de participantes que se entrecruzan: Alice y Bob, que desanonimizan estas transacciones. <br><br><img src="https://habrastorage.org/webt/dj/o6/x0/djo6x0r31q3_bzpa78t0cklzt_i.png" alt="imagen"><br><br><h4>  Carreras de transacciones </h4><br>  Como ya mencionamos, para ocultar su saldo en sistemas basados ​​en cuentas, el usuario cifra su saldo y el monto de la transferencia.  Además, debe demostrar que el saldo en su cuenta no es negativo.  El problema es que cuando se forma una transacción, el usuario crea evidencia con respecto a su estado actual de la cuenta.  ¿Y qué sucede si Bob envía una transacción a Alice, y será aceptada antes de que Alice la envíe?  Entonces la transacción de Alice se considerará inválida, porque la prueba de saldo se creó antes de la adopción de la transacción Bob. <br><br><img src="https://habrastorage.org/webt/bn/d0/7z/bnd07z43bu5m76fbbvjlvda7ek0.png" alt="imagen"><br><br>  La primera solución que se presenta en tal situación es congelar su cuenta antes de la transacción.  Pero este enfoque no es adecuado, porque además de la complejidad de resolver un problema de este tipo en un sistema distribuido, en un esquema anónimo no quedará claro qué cuenta bloquear. <br><br>  Para resolver este problema, la tecnología separa las transacciones entrantes y salientes: gastar dinero tiene un efecto inmediato en el balance general y los ingresos se difieren.  Para esto, se introduce el concepto de "era": un grupo de bloques de un tamaño fijo.  La "era" actual se determina dividiendo la altura del bloque por el tamaño del grupo.  Al procesar la transacción, la red actualiza el saldo del remitente de inmediato y agrega los fondos del destinatario a la unidad.  Los fondos acumulados están disponibles para el beneficiario solo cuando se establece una nueva "era". <br><br>  Como resultado, el usuario puede enviar transacciones independientemente de la frecuencia con la que recibe fondos (siempre que su saldo lo permita, por supuesto).  El tamaño de una época se determina en función de la rapidez con que los bloques se extienden por la red y la rapidez con que la transacción cae en el bloque. <br><br>  Esta solución funciona bien en el caso de transferencias confidenciales, pero con transacciones anónimas, como veremos más adelante, crea serios problemas. <br><br><h4>  Reproducción de protección contra ataques </h4><br>  En blockchains basados ​​en cuentas, cada transacción está firmada por la clave privada del remitente, lo que convence al verificador de que la transacción no ha sido modificada y fue creada por el propietario de esta clave.  Pero, ¿qué pasa si el atacante que estaba escuchando el canal de transmisión intercepta este mensaje y envía exactamente el mismo segundo?  El verificador verificará la firma de la transacción y se convencerá de su autoría, y la red debitará nuevamente la misma cantidad del saldo del remitente. <br><br>  Este ataque se llama ataque de repetición.  En el modelo UTXO, tales ataques no son relevantes, porque el atacante intentará usar las salidas gastadas, que en sí mismas no son válidas y son rechazadas por la red. <br><br>  Para evitar que esto suceda, se inserta un campo de datos aleatorio en la transacción, que se llama nonce o simplemente "salt".  Al volver a enviar una transacción con sal, el revisor busca para ver si este nonce se ha utilizado antes y, si no, considera que esta transacción es válida.  Para no almacenar todo el historial de usuarios que no son usuarios en la cadena de bloques, generalmente se considera cero en la primera transacción, y luego se incrementa en uno.  La red solo puede verificar que el nonce de la nueva transacción difiere del pasado en uno. <br><br>  En un esquema de traducción anónimo, surge el problema de validar las transacciones nonce.  No podemos vincular nonce explícitamente a la dirección del remitente, porque, obviamente, esto desanoniza la traducción.  Tampoco podemos agregar una unidad al nonce de todas las cuentas participantes, ya que esto puede entrar en conflicto con otras traducciones que se están procesando. <br><br>  Los autores de Zether proponen generar nonce criptográficamente, dependiendo de la "era".  Por ejemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5q/ku/zu/5qkuzus5hr-5168x4ieihiwtbjw.png" alt="imagen"></div><br>  Aquí <b><i>x</i></b> es la clave secreta del remitente, y <b><i>G <sub>epoch</sub></i></b> es un generador adicional para la era, obtenido al trocear una cadena de la forma 'Zether +'.  Ahora parece que el problema se está resolviendo: no revelamos el nonce del remitente y no interferimos con el nonce de los participantes no involucrados.  Pero este enfoque impone una seria limitación: una cuenta no puede enviar más de una transacción en la "era".  Este problema, desafortunadamente, sigue sin resolverse y actualmente hace que una versión anónima de Zether, en nuestra opinión, sea poco adecuada para su uso. <br><br><h4>  Evidencia de confianza cero </h4><br>  En UTXO, el remitente debe demostrar a la red que no está gastando una cantidad negativa, de lo contrario, es posible generar nuevas monedas desde el aire (por qué esto fue posible, escribimos en uno de los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículos</a> anteriores).  Y también firme las "entradas" con una firma de anillo para demostrar que entre las monedas de amasado hay fondos que le pertenecen. <br><br>  En la versión anónima de blockchain basada en cuentas, las expresiones de prueba son mucho más complicadas.  El remitente prueba que: <br><br><ol><li>  La cantidad enviada es positiva; </li><li>  El saldo sigue siendo no negativo; </li><li>  El remitente cifró correctamente la cantidad de transferencias (incluido cero); </li><li>  El saldo se cambia solo por el remitente y el destinatario; </li><li>  El remitente posee la clave secreta de su cuenta y él realmente está en la lista de remitentes (entre los involucrados); </li><li>  El nonce utilizado en la transacción está compuesto correctamente. </li></ol><br>  Para una prueba tan compleja, los autores usan una mezcla de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bulletproof</a> (uno de los autores, por cierto, participó en su creación) y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">protocolo Sigma</a> , que se llama Sigma-bullets.  La prueba formal de tal declaración es una tarea bastante difícil, y limita severamente el número de personas que desean asumir la implementación de la tecnología. <br><br><h4>  Cual es el resultado? </h4><br>  En nuestra opinión, la parte de Zether, que agrega privacidad a las blockchains basadas en cuentas, bien puede usarse ahora.  Pero en este momento, una versión anónima de la tecnología impone restricciones serias en su uso y su complejidad en la implementación.  Sin embargo, no olvide que los autores lo lanzaron hace solo unos meses, y tal vez alguien más encuentre una solución a los problemas hoy.  De hecho, así es como se hace la ciencia. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452184/">https://habr.com/ru/post/452184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452172/index.html">Sistemas complejos Alcanzando un nivel crítico</a></li>
<li><a href="../452174/index.html">El no te necesita</a></li>
<li><a href="../452178/index.html">Análisis: 23 errores populares en inglés escrito y cómo evitarlos</a></li>
<li><a href="../452180/index.html">Elevamos el rendimiento de SSD desde las rodillas, dónde hacer clic y por qué</a></li>
<li><a href="../452182/index.html">Encuesta de empleados. El principal error</a></li>
<li><a href="../452186/index.html">Los lenguajes de programación más raros y caros</a></li>
<li><a href="../452188/index.html">Prueba de la unidad de serialización Json en Spring Boot</a></li>
<li><a href="../452190/index.html">Uso de la aplicación web WebAssembly 20x acelerada</a></li>
<li><a href="../452192/index.html">¿Qué es esto aquí? Operación interna de objetos JavaScript</a></li>
<li><a href="../452198/index.html">¿Qué debe saber todo ingeniero de control de calidad sobre Selenium 4?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>