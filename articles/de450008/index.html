<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∏üèΩ üì´ üëì Suchen Sie mit dem PVS-Studio-Analyseger√§t nach Fehlern in LLVM 8 üë®‚Äçüé§ üñ®Ô∏è ‚ûó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit der letzten √úberpr√ºfung des LLVM-Projektcodes mit unserem PVS-Studio-Analyseger√§t sind mehr als zwei Jahre vergangen. Stellen wir sicher, dass de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suchen Sie mit dem PVS-Studio-Analyseger√§t nach Fehlern in LLVM 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/450008/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f2/8d4/5bf/2f28d45bf369270d9330bfbe2ea78f00.png" alt="PVS-Studio und LLVM 8.0.0"></div><br>  Seit der letzten √úberpr√ºfung des LLVM-Projektcodes mit unserem PVS-Studio-Analyseger√§t sind mehr als zwei Jahre vergangen.  Stellen wir sicher, dass der PVS-Studio-Analysator immer noch das f√ºhrende Tool zum Erkennen von Fehlern und potenziellen Schwachstellen ist.  √úberpr√ºfen und √ºberpr√ºfen Sie dazu neue Fehler in der Version LLVM 8.0.0. <br><a name="habracut"></a><br><h2>  Artikel geschrieben werden </h2><br>  Um ehrlich zu sein, wollte ich diesen Artikel nicht schreiben.  Es ist nicht interessant, √ºber ein Projekt zu schreiben, das wir bereits wiederholt getestet haben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> ).  Es ist besser, √ºber etwas Neues zu schreiben, aber ich habe keine Wahl. <br><br>  Jedes Mal, wenn eine neue Version von LLVM ver√∂ffentlicht oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clang Static Analyzer</a> aktualisiert wird, erscheinen die folgenden Fragen in unserer E-Mail: <br><br>  <i>Schauen Sie, die neue Version von Clang Static Analyzer hat gelernt, neue Fehler zu finden!</i>  <i>Es scheint mir, dass die Relevanz der Verwendung von PVS-Studio abnimmt.</i>  <i>Clang findet mehr Fehler als zuvor und holt die Funktionen von PVS-Studio ein.</i>  <i>Was denkst du dar√ºber?</i> <br><br>  Darauf m√∂chte ich immer etwas im Geiste beantworten: <br><br>  <b>Wir sitzen auch nicht unt√§tig!</b>  Wir haben die Funktionen des PVS-Studio-Analysators erheblich verbessert.  Also keine Sorge, wir f√ºhren weiter wie bisher. <br><br>  Leider ist dies eine schlechte Antwort.  Es gibt keine Beweise darin.  Und deshalb schreibe ich jetzt diesen Artikel.  Daher wurde das LLVM-Projekt erneut getestet und es wurden verschiedene Fehler gefunden.  Diejenigen, die mir interessant erschienen, werde ich jetzt demonstrieren.  Diese Fehler k√∂nnen vom Clang Static Analyzer nicht gefunden werden (oder es ist √§u√üerst unpraktisch, dies zu tun).  Und wir k√∂nnen.  Und ich habe all diese Fehler an einem Abend gefunden und aufgeschrieben. <br><br>  Aber das Schreiben des Artikels dauerte mehrere Wochen.  Ich konnte mich nicht zwingen, dies alles in Form von Text zu arrangieren :). <br><br>  √úbrigens, wenn Sie daran interessiert sind, welche Technologien im PVS-Studio-Analyseger√§t verwendet werden, um Fehler und potenzielle Schwachstellen zu erkennen, sollten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sich</a> mit diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinweis</a> vertraut machen. <br><br><h2>  Neue und alte Diagnose </h2><br>  Wie bereits erw√§hnt, wurde das LLVM-Projekt vor etwa zwei Jahren erneut verifiziert und die gefundenen Fehler korrigiert.  In diesem Artikel wird nun ein neuer Teil der Fehler vorgestellt.  Warum wurden neue Fehler gefunden?  Daf√ºr gibt es 3 Gr√ºnde: <br><br><ol><li>  Das LLVM-Projekt entwickelt sich, der alte Code √§ndert sich darin und ein neuer wird angezeigt.  Nat√ºrlich gibt es neue Fehler im ge√§nderten und geschriebenen Code.  Dies zeigt gut, dass die statische Analyse regelm√§√üig und nicht von Fall zu Fall angewendet werden sollte.  Unsere Artikel zeigen die Funktionen des PVS-Studio-Analysators gut, dies hat jedoch nichts mit der Verbesserung der Codequalit√§t und der Reduzierung der Kosten f√ºr die Fehlerbehebung zu tun.  Verwenden Sie regelm√§√üig einen statischen Code-Analysator! </li><li>  Wir schlie√üen die bestehende Diagnose ab und verbessern sie.  Daher kann der Analysator Fehler erkennen, die bei fr√ºheren √úberpr√ºfungen nicht bemerkt wurden. </li><li>  PVS-Studio f√ºhrte neue Diagnosen ein, die noch keine 2 Jahre alt waren.  Ich habe beschlossen, sie in einen separaten Abschnitt zu unterteilen, um die Entwicklung von PVS-Studio klar zu demonstrieren. </li></ol><br><h2>  Durch Diagnose diagnostizierte Fehler, die vor 2 Jahren bestanden haben </h2><br>  <b>Fragment N1: Kopieren-Einf√ºgen</b> <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldUpgradeX86Intrinsic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function *F, StringRef Name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Name == <span class="hljs-string"><span class="hljs-string">"addcarryx.u32"</span></span> || <span class="hljs-comment"><span class="hljs-comment">// Added in 8.0 .... Name == "avx512.mask.cvtps2pd.128" || // Added in 7.0 Name == "avx512.mask.cvtps2pd.256" || // Added in 7.0 Name == "avx512.cvtusi2sd" || // Added in 7.0 Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name == "sse2.pmulu.dq" || // Added in 7.0 Name == "sse41.pmuldq" || // Added in 7.0 Name == "avx2.pmulu.dq" || // Added in 7.0 .... }</span></span></code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> [CWE-570] Es gibt identische Unterausdr√ºcke 'Name.startswith ("avx512.mask.permvar.")' Links und rechts vom '||'  Betreiber.  AutoUpgrade.cpp 73 <br><br>  Es wird doppelt √ºberpr√ºft, ob der Name mit der Teilzeichenfolge "avx512.mask.permvar" beginnt.  Im zweiten Test wollten sie eindeutig etwas anderes schreiben, verga√üen jedoch, den kopierten Text zu korrigieren. <br><br>  <b>Fragment N2: Tippfehler</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CXNameRefFlags { CXNameRange_WantQualifier = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, CXNameRange_WantTemplateArgs = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, CXNameRange_WantSinglePiece = <span class="hljs-number"><span class="hljs-number">0x4</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnnotateTokensWorker::HandlePostPonedChildCursor( CXCursor Cursor, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> StartTokenIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> flags = CXNameRange_WantQualifier | CXNameRange_WantQualifier; .... }</code> </pre> <br>  PVS-Studio Warnung: V501 Links und rechts vom '|' befinden sich identische Unterausdr√ºcke 'CXNameRange_WantQualifier'.  Betreiber.  CIndex.cpp 7245 <br><br>  Aufgrund eines Tippfehlers wird die gleichnamige Konstante <i>CXNameRange_WantQualifier zweimal verwendet</i> . <br><br>  <b>Snippet N3: Verwirrung √ºber die Priorit√§ten des Bedieners</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PPCTTIImpl::getVectorInstrCost(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Opcode, Type *Val, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Index) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V502</a> [CWE-783] M√∂glicherweise funktioniert der Operator '?:' Anders als erwartet.  Der Operator '?:' Hat eine niedrigere Priorit√§t als der Operator '=='.  PPCTargetTransformInfo.cpp 404 <br><br>  Meiner Meinung nach ist dies ein sehr sch√∂ner Fehler.  Ja, ich wei√ü, dass ich seltsame Vorstellungen von Sch√∂nheit habe :). <br><br>  Entsprechend den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Priorit√§ten der Operatoren</a> wird der Ausdruck nun wie folgt berechnet: <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; (Index == ST-&gt;isLittleEndian())) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Aus praktischer Sicht ist diese Bedingung nicht sinnvoll, da sie reduziert werden kann auf: <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian())</code> </pre> <br>  Dies ist ein klarer Fehler.  H√∂chstwahrscheinlich wollte 0/1 mit der Indexvariablen vergleichen.  F√ºgen Sie Klammern um den tern√§ren Operator hinzu, um den Code zu korrigieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == (ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre> <br>  Der tern√§re Operator ist √ºbrigens sehr gef√§hrlich und provoziert logische Fehler.  Seien Sie sehr vorsichtig damit und seien Sie nicht gierig, Klammern zu setzen.  Ich habe dieses Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> im Kapitel ‚ÄûF√ºrchte den Operator?: Und f√ºge es in Klammern ein‚Äú ausf√ºhrlicher behandelt. <br><br>  <b>Fragment N4, N5: Nullzeiger</b> <br><br><pre> <code class="cpp hljs">Init *TGParser::ParseValue(Record *CurRec, RecTy *ItemType, IDParseMode Mode) { .... TypedInit *LHS = dyn_cast&lt;TypedInit&gt;(Result); .... LHS = dyn_cast&lt;TypedInit&gt;( UnOpInit::get(UnOpInit::CAST, LHS, StringRecTy::get()) -&gt;Fold(CurRec)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LHS) { Error(PasteLoc, Twine(<span class="hljs-string"><span class="hljs-string">"can't cast '"</span></span>) + LHS-&gt;getAsString() + <span class="hljs-string"><span class="hljs-string">"' to string"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V522</a> [CWE-476] Es kann zu einer Dereferenzierung des Nullzeigers 'LHS' kommen.  TGParser.cpp 2152 <br><br>  Wenn der <i>LHS-</i> Zeiger null ist, sollte eine Warnung ausgegeben werden.  Stattdessen wird jedoch dieser Nullzeiger dereferenziert: <i>LHS-&gt; getAsString ()</i> . <br><br>  Dies ist eine sehr typische Situation, wenn der Fehler im Fehlerhandler versteckt ist, da niemand sie testet.  Statische Analyseger√§te √ºberpr√ºfen den gesamten erreichbaren Code, unabh√§ngig davon, wie oft er verwendet wird.  Dies ist ein sehr gutes Beispiel daf√ºr, wie die statische Analyse andere Test- und Fehlerschutztechniken erg√§nzt. <br><br>  Ein √§hnlicher Fehler bei der Verarbeitung des <i>RHS-</i> Zeigers wurde im folgenden Code gemacht: V522 [CWE-476] Eine Dereferenzierung des Nullzeigers 'RHS' kann stattfinden.  TGParser.cpp 2186 <br><br>  <b>Fragment N6: Verwenden des Cursors nach dem Bewegen</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; ExtractBlocks(....) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; ProgClone = CloneModule(BD.getProgram(), VMap); .... BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= MiscompiledFunctions.clear(); for (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) { Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first); // &lt;= assert(NewF &amp;&amp; "Function not found??"); MiscompiledFunctions.push_back(NewF); } .... }</span></span></code> </pre> <br>  PVS-Studio Warnung: V522 [CWE-476] M√∂glicherweise findet eine Dereferenzierung des Nullzeigers 'ProgClone' statt.  Miscompilation.cpp 601 <br><br>  Zu Beginn besitzt der <i>ProgClone-</i> Smart-Zeiger nicht mehr das Objekt: <br><br><pre> <code class="cpp hljs">BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone));</code> </pre> <br>  Tats√§chlich ist <i>ProgClone</i> jetzt ein Nullzeiger.  Daher sollte eine Dereferenzierung des Nullzeigers direkt darunter erfolgen: <br><br><pre> <code class="cpp hljs">Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first);</code> </pre> <br>  Aber in der Tat wird dies nicht passieren!  Beachten Sie, dass die Schleife nicht ausgef√ºhrt wird. <br><br>  Zu Beginn wird der Container <i>MiscompiledFunctions</i> gel√∂scht: <br><br><pre> <code class="cpp hljs">MiscompiledFunctions.clear();</code> </pre> <br>  Als n√§chstes wird die Gr√∂√üe dieses Containers in der Schleifenbedingung verwendet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, e = MisCompFunctions.size(); i != e; ++i) {</code> </pre> <br>  Es ist leicht zu erkennen, dass die Schleife nicht startet.  Ich denke, das ist auch ein Fehler, und der Code sollte anders geschrieben werden. <br><br>  Es scheint, dass wir diese sehr ber√ºhmte Parit√§t von Fehlern getroffen haben!  Ein Fehler verschleiert einen anderen :). <br><br>  <b>Fragment N7: Verwenden des Cursors nach dem Bewegen</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; TestOptimizer(BugDriver &amp;BD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Test, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Safe) { outs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Optimizing functions being tested: "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Optimized = BD.runPassesOn(Test.get(), BD.getPassesToRun()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Optimized) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Error running this sequence of passes"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" on the input program!\n"</span></span>; BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Test)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= BD.EmitProgressBitcode(*Test, "pass-error", false); // &lt;= if (Error E = BD.debugOptimizerCrash()) return std::move(E); return false; } .... }</span></span></code> </pre> <br>  PVS-Studio Warnung: V522 [CWE-476] Es kann zu einer Dereferenzierung des Nullzeigers 'Test' kommen.  Miscompilation.cpp 709 <br><br>  Wieder die gleiche Situation.  Zuerst wird der Inhalt des Objekts verschoben, und dann wird es so verwendet, als w√§re nichts passiert.  Ich sehe diese Situation zunehmend im Programmcode, nachdem die Semantik der Bewegung in C ++ erschienen ist.  Daf√ºr liebe ich die C ++ Sprache!  Es gibt immer mehr neue M√∂glichkeiten, um sein eigenes Bein zu schie√üen.  PVS-Studio Analyzer funktioniert immer :). <br><br>  <b>Fragment N8: Nullzeiger</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FunctionDumper::dump(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PDBSymbolTypeFunctionArg &amp;Symbol) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TypeId = Symbol.getTypeId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type = Symbol.getSession().getSymbolById(TypeId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  PVS-Studio Warnung: V522 [CWE-476] Es kann zu einer Dereferenzierung des Nullzeigers 'Typ' kommen.  PrettyFunctionDumper.cpp 233 <br><br>  Zus√§tzlich zu den Fehlerbehandlungsroutinen werden Funktionen zum Debuggen von Ausdrucken normalerweise nicht getestet.  Vor uns liegt genau so ein Fall.  Die Funktion wartet auf einen Benutzer, der gezwungen ist, das Problem zu beheben, anstatt es zu l√∂sen. <br><br>  Richtig: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>;</code> </pre> <br>  <b>Fragment N9: Nullzeiger</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SearchableTableEmitter::collectTableEntries( GenericTable &amp;Table, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Record *&gt; &amp;Items) { .... RecTy *Ty = resolveTypes(Field.RecType, TI-&gt;getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Ty) <span class="hljs-comment"><span class="hljs-comment">// &lt;= PrintFatalError(Twine("Field '") + Field.Name + "' of table '" + Table.Name + "' has incompatible type: " + Ty-&gt;getAsString() + " vs. " + // &lt;= TI-&gt;getType()-&gt;getAsString()); .... }</span></span></code> </pre> <br>  PVS-Studio Warnung: V522 [CWE-476] Es kann zu einer Dereferenzierung des Nullzeigers 'Ty' kommen.  SearchableTableEmitter.cpp 614 <br><br>  Ich denke, und so ist alles klar und bedarf keiner Erkl√§rung. <br><br>  <b>Fragment N10: Tippfehler</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FormatTokenLexer::tryMergeCSharpNullConditionals() { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Identifier = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Question = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... Identifier-&gt;ColumnWidth += Question-&gt;ColumnWidth; Identifier-&gt;Type = Identifier-&gt;Type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= Tokens.erase(Tokens.end() - 1); return true; }</span></span></code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V570</a> Die Variable 'Identifier-&gt; Type' wird sich selbst zugewiesen.  FormatTokenLexer.cpp 249 <br><br>  Es macht keinen Sinn, sich selbst eine Variable zuzuweisen.  H√∂chstwahrscheinlich wollten sie schreiben: <br><br><pre> <code class="cpp hljs">Identifier-&gt;Type = Question-&gt;Type;</code> </pre> <br>  <b>Fragment N11: Verd√§chtige Pause</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SystemZOperand::print(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindToken: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Token:"</span></span> &lt;&lt; getToken(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindReg: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Reg:"</span></span> &lt;&lt; SystemZInstPrinter::getRegisterName(getReg()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V622</a> [CWE-478] √úberpr√ºfen Sie die Anweisung 'switch'.  M√∂glicherweise fehlt der erste 'case'-Operator.  SystemZAsmParser.cpp 652 <br><br>  Am Anfang steht eine sehr verd√§chtige <i>Pausenerkl√§rung</i> .  Hast du vergessen, hier etwas anderes zu schreiben? <br><br>  <b>Fragment N12: √úberpr√ºfen des Zeigers nach der Dereferenzierung</b> <br><br><pre> <code class="cpp hljs">InlineCost AMDGPUInliner::getInlineCost(CallSite CS) { Function *Callee = CS.getCalledFunction(); Function *Caller = CS.getCaller(); TargetTransformInfo &amp;TTI = TTIWP-&gt;getTTI(*Callee); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> llvm::InlineCost::getNever(<span class="hljs-string"><span class="hljs-string">"undefined callee"</span></span>); .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595</a> [CWE-476] Der 'Callee'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 172, 174. AMDGPUInline.cpp 172 <br><br>  Der <i>Callee-</i> Zeiger am Anfang wird dereferenziert, wenn die Funktion <i>getTTI aufgerufen wird</i> . <br><br>  Und dann stellt sich heraus, dass dieser Zeiger auf <i>nullptr-</i> Gleichheit √ºberpr√ºft werden <i>sollte</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration())</code> </pre> <br>  Aber es ist zu sp√§t ... <br><br>  <b>Fragment N13 - N ...: √úberpr√ºfen des Zeigers nach der Dereferenzierung</b> <br><br>  Die im vorherigen Codefragment beschriebene Situation ist nicht eindeutig.  Sie ist hier zu finden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Value *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeDoubleFP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallInst *CI, IRBuilder&lt;&gt; &amp;B, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isBinary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isPrecise = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... Function *CalleeFn = CI-&gt;getCalledFunction(); StringRef CalleeNm = CalleeFn-&gt;getName(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= AttributeList CalleeAt = CalleeFn-&gt;getAttributes(); if (CalleeFn &amp;&amp; !CalleeFn-&gt;isIntrinsic()) { // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio Warnung: V595 [CWE-476] Der 'CalleeFn'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 1079, 1081. SimplifyLibCalls.cpp 1079 <br><br>  Und hier: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Sema::InstantiateAttrs(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MultiLevelTemplateArgumentList &amp;TemplateArgs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Decl *Tmpl, Decl *New, LateInstantiatedAttrVec *LateAttrs, LocalInstantiationScope *OuterMostScope) { .... NamedDecl *ND = dyn_cast&lt;NamedDecl&gt;(New); CXXRecordDecl *ThisContext = dyn_cast_or_null&lt;CXXRecordDecl&gt;(ND-&gt;getDeclContext()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= CXXThisScopeRAII ThisScope(*this, ThisContext, Qualifiers(), ND &amp;&amp; ND-&gt;isCXXInstanceMember()); // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio Warnung: V595 [CWE-476] Der 'ND'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 532, 534. SemaTemplateInstantiateDecl.cpp 532 <br><br>  Und hier: <br><br><ul><li>  V595 [CWE-476] Der 'U'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 404, 407. DWARFFormValue.cpp 404 </li><li>  V595 [CWE-476] Der 'ND'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2149, 2151. SemaTemplateInstantiate.cpp 2149 </li></ul><br>  Und dann interessierte es mich nicht mehr, die Warnungen mit der Nummer V595 zu studieren.  Ich wei√ü also nicht, ob es neben den hier aufgef√ºhrten √§hnliche Fehler gibt.  H√∂chstwahrscheinlich gibt es. <br><br>  <b>Fragment N17, N18: Verd√§chtige Verschiebung</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processLogicalImmediate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Imm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;Encoding)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Size = RegSize; .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V629</a> [CWE-190] √úberpr√ºfen Sie den Ausdruck '~ (Gr√∂√üe - 1) &lt;&lt; 1'.  Bitverschiebung des 32-Bit-Werts mit anschlie√üender Erweiterung auf den 64-Bit-Typ.  AArch64AddressingModes.h 260 <br><br>  Vielleicht ist dies kein Fehler, und der Code funktioniert genau wie beabsichtigt.  Dies ist jedoch eindeutig ein sehr verd√§chtiger Ort, der √ºberpr√ºft werden muss. <br><br>  Angenommen, die Variable <i>Size</i> ist 16, und dann plant der Autor des Codes, den Wert in der Variablen <i>NImms abzurufen</i> : <br><br>  1111111111111111111111111111111111111111111111111111111111111100000000 <br><br>  Tats√§chlich ist das Ergebnis jedoch: <br><br>  000000000000000000000000000000000000111111111111111111111111111111000000 <br><br>  Tatsache ist, dass alle Berechnungen mit dem vorzeichenlosen 32-Bit-Typ erfolgen.  Und nur dann wird dieser vorzeichenlose 32-Bit-Typ implizit auf <i>uint64_t</i> erweitert.  In diesem Fall sind die h√∂chstwertigen Bits Null. <br><br>  Sie k√∂nnen die Situation folgenderma√üen beheben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  √Ñhnliche Situation: V629 [CWE-190] √úberpr√ºfen Sie den Ausdruck 'Immr &lt;&lt; 6'.  Bitverschiebung des 32-Bit-Werts mit anschlie√üender Erweiterung auf den 64-Bit-Typ.  AArch64AddressingModes.h 269 <br><br>  <b>Snippet N19: Fehlt</b> <b><i>sonst ein</i></b> <b>Schl√ºsselwort</b> <b>?</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AMDGPUAsmParser::cvtDPP(MCInst &amp;Inst, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OperandVector &amp;Operands) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Op.isReg() &amp;&amp; Op.Reg.RegNo == AMDGPU::VCC) { <span class="hljs-comment"><span class="hljs-comment">// VOP2b (v_add_u32, v_sub_u32 ...) dpp use "vcc" token. // Skip it. continue; } if (isRegOrImmWithInputMods(Desc, Inst.getNumOperands())) { // &lt;= Op.addRegWithFPInputModsOperands(Inst, 2); } else if (Op.isDPPCtrl()) { Op.addImmOperands(Inst, 1); } else if (Op.isImm()) { // Handle optional arguments OptionalIdx[Op.getImmTy()] = I; } else { llvm_unreachable("Invalid operand type"); } .... }</span></span></code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V646</a> [CWE-670] √úberpr√ºfen Sie die Logik der Anwendung.  M√∂glicherweise fehlt das Schl√ºsselwort "else".  AMDGPUAsmParser.cpp 5655 <br><br>  Hier gibt es keinen Fehler.  Da der then-Block des ersten <i>if</i> mit <i>continue</i> endet, spielt es keine Rolle, <i>ob</i> ein <i>else-</i> Schl√ºsselwort vorhanden ist oder nicht.  In jedem Fall funktioniert der Code genauso.  Das Fehlen eines <i>anderen</i> macht den Code jedoch dunkler und gef√§hrlicher.  Wenn in Zukunft <i>weiterhin fortf√§hrt</i> , funktioniert der Code auf v√∂llig andere Weise.  Meiner Meinung nach ist es besser, noch <i>etwas</i> hinzuzuf√ºgen. <br><br>  <b>Fragment N20: Vier Tippfehler des gleichen Typs</b> <br><br><pre> <code class="cpp hljs">LLVM_DUMP_METHOD <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Symbol::dump(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUndefined()) Result += <span class="hljs-string"><span class="hljs-string">"(undef) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakDefined()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-def) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakReferenced()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-ref) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isThreadLocalValue()) Result += <span class="hljs-string"><span class="hljs-string">"(tlv) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SymbolKind::GlobalSymbol: Result + Name.str(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case SymbolKind::ObjectiveCClass: Result + "(ObjC Class) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCClassEHType: Result + "(ObjC Class EH) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCInstanceVariable: Result + "(ObjC IVar) " + Name.str(); // &lt;= break; } OS &lt;&lt; Result; }</span></span></code> </pre> <br>  PVS-Studio-Warnungen: <br><br><ul><li>  V655 [CWE-480] Die Zeichenfolgen wurden verkettet, aber nicht verwendet.  √úberpr√ºfen Sie den Ausdruck 'Ergebnis + Name.str ()'.  Symbol.cpp 32 </li><li>  V655 [CWE-480] Die Zeichenfolgen wurden verkettet, aber nicht verwendet.  √úberpr√ºfen Sie den Ausdruck 'Ergebnis + "(ObjC-Klasse)" + Name.str ()'.  Symbol.cpp 35 </li><li>  V655 [CWE-480] Die Zeichenfolgen wurden verkettet, aber nicht verwendet.  √úberpr√ºfen Sie den Ausdruck 'Ergebnis + "(ObjC-Klasse EH)" + Name.str ()'.  Symbol.cpp 38 </li><li>  V655 [CWE-480] Die Zeichenfolgen wurden verkettet, aber nicht verwendet.  √úberpr√ºfen Sie den Ausdruck 'Ergebnis + "(ObjC IVar)" + Name.str ()'.  Symbol.cpp 41 </li></ul><br>  Zuf√§llig wird der Operator + anstelle des Operators + = verwendet.  Das Ergebnis sind bedeutungslose Designs. <br><br>  <b>Fragment N21: Undefiniertes Verhalten</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReqFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;StringRef, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;FeaturesMap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Record *&gt; &amp;ReqFeatures)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;R : ReqFeatures) { StringRef AsmCondString = R-&gt;getValueAsString(<span class="hljs-string"><span class="hljs-string">"AssemblerCondString"</span></span>); SmallVector&lt;StringRef, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; Ops; SplitString(AsmCondString, Ops, <span class="hljs-string"><span class="hljs-string">","</span></span>); assert(!Ops.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"AssemblerCondString cannot be empty"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Op : Ops) { assert(!Op.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Empty operator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FeaturesMap.find(Op) == FeaturesMap.end()) FeaturesMap[Op] = FeaturesMap.size(); } } }</code> </pre> <br>  Versuchen Sie, den gef√§hrlichen Code selbst zu finden.  Und dies ist ein Bild zur Ablenkung, um die Antwort nicht sofort zu sehen: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5d/183/d4e/d5d183d4e2d3107bc512e52d893fda25.png" alt="Hmmm ..."></div><br><br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V708</a> [CWE-758] Es wird eine gef√§hrliche Konstruktion verwendet: 'FeaturesMap [Op] = FeaturesMap.size ()', wobei 'FeaturesMap' zur Klasse 'map' geh√∂rt.  Dies kann zu undefiniertem Verhalten f√ºhren.  RISCVCompressInstEmitter.cpp 490 <br><br>  Problemlinie: <br><br><pre> <code class="cpp hljs">FeaturesMap[Op] = FeaturesMap.size();</code> </pre> <br>  Wenn das <i>Op-</i> Element nicht gefunden wird, wird ein neues Element in der Karte erstellt und die Anzahl der Elemente in dieser Karte wird dort geschrieben.  Es ist nur nicht bekannt, ob die <i>Gr√∂√üenfunktion</i> vor oder nach dem Hinzuf√ºgen eines neuen Elements aufgerufen wird. <br><br>  <b>Fragment N22-N24: Neuzuweisungen</b> <br><br><pre> <code class="cpp hljs">Error MachOObjectFile::checkSymbolTable() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MachO::nlist STE = getSymbolTableEntry(SymDRI); NType = STE.n_type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= NType = STE.n_type; // &lt;= NSect = STE.n_sect; NDesc = STE.n_desc; NStrx = STE.n_strx; NValue = STE.n_value; } .... }</span></span></code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V519</a> [CWE-563] Der Variablen 'NType' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 1663, 1664. MachOObjectFile.cpp 1664 <br><br>  Ich denke, hier gibt es keinen wirklichen Fehler.  Nur √ºberfl√ºssige wiederholte Zuordnung.  Aber immer noch ein Fehler. <br><br>  √Ñhnlich: <br><br><ul><li>  V519 [CWE-563] Der Variablen 'B.NDesc' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  Pr√ºflinien: 1488, 1489. llvm-nm.cpp 1489 </li><li>  V519 [CWE-563] Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 59, 61. coff2yaml.cpp 61 </li></ul><br>  <b>Fragment N25-N27: Weitere Neuzuweisungen</b> <br><br>  Betrachten Sie nun eine etwas andere Neuzuweisungsoption. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Vectorizer::vectorizeLoadChain( ArrayRef&lt;Instruction *&gt; Chain, SmallPtrSet&lt;Instruction *, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; *InstructionsProcessed) { .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Alignment = getAlignment(L0); .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> NewAlign = getOrEnforceKnownAlignment(L0-&gt;getPointerOperand(), StackAdjustedAlignment, DL, L0, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, &amp;DT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NewAlign != <span class="hljs-number"><span class="hljs-number">0</span></span>) Alignment = NewAlign; Alignment = NewAlign; .... }</code> </pre> <br>  PVS-Studio Warnung: V519 [CWE-563] Der Variablen 'Alignment' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 1158, 1160. LoadStoreVectorizer.cpp 1160 <br><br>  Dies ist ein sehr seltsamer Code, der einen logischen Fehler zu enthalten scheint.  Zu Beginn wird der <i>Ausrichtungsvariablen</i> je nach Bedingung ein Wert zugewiesen.  Und dann erfolgt die Zuordnung erneut, jedoch jetzt ohne √úberpr√ºfung. <br><br>  √Ñhnliche Situationen sind hier zu sehen: <br><br><ul><li>  V519 [CWE-563] Der Variablen 'Effekte' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 152, 165. WebAssemblyRegStackify.cpp 165 </li><li>  V519 [CWE-563] Der Variablen 'ExpectNoDerefChunk' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 4970, 4973. SemaType.cpp 4973 </li></ul><br>  <b>Fragment N28: Immer eine echte Bedingung</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrefixes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct InternalInstruction* insn)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byte = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> nextByte; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byte == <span class="hljs-number"><span class="hljs-number">0xf3</span></span> &amp;&amp; (nextByte == <span class="hljs-number"><span class="hljs-number">0x88</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0x89</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc6</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc7</span></span>)) { insn-&gt;xAcquireRelease = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextByte != <span class="hljs-number"><span class="hljs-number">0x90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// PAUSE instruction support // &lt;= break; } .... }</span></span></code> </pre> <br>  PVS-Studio- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warnung</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547</a> [CWE-571] Der Ausdruck 'nextByte! = 0x90' ist immer wahr.  X86DisassemblerDecoder.cpp 379 <br><br>  √úberpr√ºfung macht keinen Sinn.  Die Variable <i>nextByte ist</i> immer ungleich <i>0x90</i> , was sich aus der vorherigen Pr√ºfung ergibt.  Dies ist eine Art logischer Fehler. <br><br>  <b>Fragment N29 - N ...: Immer wahre / falsche Bedingungen</b> <br><br>  Der Analysator gibt viele Warnungen aus, dass der gesamte Zustand ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547</a> ) oder ein Teil davon ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V560</a> ) immer wahr oder falsch ist.  Oft sind dies keine wirklichen Fehler, sondern einfach ungenauer Code, das Ergebnis der Bereitstellung von Makros und dergleichen.  Trotzdem ist es sinnvoll, all diese Warnungen zu betrachten, da es von Zeit zu Zeit echte logische Fehler gibt.  Zum Beispiel ist dieser Code verd√§chtig: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DecodeStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeGPRPairRegisterClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MCInst &amp;Inst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegNo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Decoder)</span></span></span><span class="hljs-function"> </span></span>{ DecodeStatus S = MCDisassembler::Success; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RegNo &gt; <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCDisassembler::Fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((RegNo &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) || RegNo == <span class="hljs-number"><span class="hljs-number">0xe</span></span>) S = MCDisassembler::SoftFail; .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V560</a> [CWE-570] Ein Teil des bedingten Ausdrucks ist immer falsch: RegNo == 0xe.  ARMDisassembler.cpp 939 <br><br>  Die Konstante 0xE ist der Wert 14 im Dezimalsystem.  Das √úberpr√ºfen von <i>RegNo == 0xe</i> ist nicht sinnvoll, da bei <i>RegNo&gt; 13</i> die Ausf√ºhrung der Funktion abgeschlossen wird. <br><br>  Es gab viele andere Warnungen mit den Kennungen V547 und V560, aber wie im Fall von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595</a> war ich nicht daran interessiert, diese Warnungen zu untersuchen.  Es war schon klar, dass ich genug Material hatte, um einen Artikel zu schreiben :).  Daher ist nicht bekannt, wie viele Fehler dieses Typs mit PVS-Studio in LLVM erkannt werden k√∂nnen. <br><br>  Ich werde ein Beispiel geben, warum es langweilig ist, diese Antworten zu studieren.  Der Analysator gibt absolut richtig eine Warnung f√ºr den folgenden Code aus.  Das ist aber kein Fehler. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> UnwrappedLineParser::parseBracedList(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ContinueOnSemicolons, tok::TokenKind ClosingBraceKind) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasError = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... HasError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ContinueOnSemicolons) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !HasError; .... }</code> </pre> <br>  PVS-Studio-Warnung: V547 [CWE-570] Der Ausdruck '! HasError' ist immer falsch.  UnwrappedLineParser.cpp 1635 <br><br>  <b>Fragment N30: ‚Äã‚ÄãVerd√§chtige R√ºckkehr</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isImplicitlyDef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MachineRegisterInfo &amp;MRI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MachineRegisterInfo::def_instr_iterator It = MRI.def_instr_begin(Reg), E = MRI.def_instr_end(); It != E; ++It) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*It).isImplicitDef(); } .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V612</a> [CWE-670] Eine bedingungslose 'R√ºckkehr' innerhalb einer Schleife.  R600OptimizeVectorRegisters.cpp 63 <br><br>  Dies ist entweder ein Fehler oder ein bestimmter Trick, der Programmierern, die den Code lesen, etwas erkl√§ren soll.  Dieser Entwurf erkl√§rt mir nichts und sieht sehr verd√§chtig aus.  Es ist besser, nicht so zu schreiben :). <br><br>  Bist du m√ºde  Dann Zeit, Tee oder Kaffee zu machen. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/f86/58f/8a2f8658fdacb0dde918807666d1cd39.png" alt="Kaffee"></div><br><br><h2>  Durch neue Diagnose erkannte Fehler </h2><br>  Ich denke, 30 Ausl√∂sen alter Diagnosen ist genug.  Lassen Sie uns nun sehen, was interessant ist, wenn neue Diagnosen erstellt werden, die nach einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen</a> √úberpr√ºfung im Analyseger√§t angezeigt wurden.  Insgesamt wurden in dieser Zeit 66 Allzweckdiagnosen zum C ++ - Analyseger√§t hinzugef√ºgt. <br><br>  <b>Fragment N31: Nicht erreichbarer Code</b> <br><br><pre> <code class="cpp hljs">Error CtorDtorRunner::run() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> CtorDtorMap = ES.lookup(JITDylibSearchList({{&amp;JD, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}}), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Names), NoDependenciesToRegister, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CtorDtorMap.takeError(); CtorDtorsByPriority.clear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V779</a> [CWE-561] Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  ExecutionUtils.cpp 146 <br><br>  Wie Sie sehen k√∂nnen, enden beide Zweige der <i>if-Anweisung</i> mit einem Aufruf der <i>return-Anweisung</i> .  Dementsprechend wird der <i>CtorDtorsByPriority-</i> Container niemals <i>geleert</i> . <br><br>  <b>Snippet N32: Nicht erreichbarer Code</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LLParser::ParseSummaryEntry() { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Lex.getKind()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_gv: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseGVEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_module: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseModuleEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_typeid: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; // &lt;= default: return Error(Lex.getLoc(), "unexpected summary kind"); } Lex.setIgnoreColonInIdentifiers(false); // &lt;= return false; }</span></span></code> </pre> <br>  PVS-Studio Warnung: V779 [CWE-561] Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  LLParser.cpp 835 <br><br>  Eine interessante Situation.  Schauen wir uns den Anfang dieses Ortes an: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br>  Auf den ersten Blick scheint es keinen Fehler zu geben.  Es scheint, dass die <i>break-</i> Anweisung hier √ºberfl√ºssig ist und Sie sie einfach l√∂schen k√∂nnen.  Es ist jedoch nicht alles so einfach. <br><br>  Der Analysator generiert eine Warnung in den Zeilen: <br><br><pre> <code class="cpp hljs">Lex.setIgnoreColonInIdentifiers(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  In der Tat ist dieser Code nicht erreichbar.  Alle F√§lle in <i>switch</i> enden mit einem Aufruf der <i>return-Anweisung</i> .  Und jetzt sieht die sinnlose einsame <i>Pause</i> nicht mehr so ‚Äã‚Äãharmlos aus!  Vielleicht sollte einer der Zweige mit einer <i>Pause</i> enden und nicht mit einer <i>R√ºckkehr</i> ? <br><br>  <b>Fragment N33: Accidentalisation von hohen Bits</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStubAlignment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Arch == Triple::systemz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt; RuntimeDyldImpl::emitSection(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjectFile &amp;Obj, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SectionRef &amp;Section, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCode) { .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> DataSize = Section.getSize(); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StubBufSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V784</a> Die Gr√∂√üe der Bitmaske ist kleiner als die Gr√∂√üe des ersten Operanden.  Dies f√ºhrt zum Verlust h√∂herer Bits.  RuntimeDyld.cpp 815 <br><br>  Beachten Sie, dass die Funktion <i>getStubAlignment</i> einen <i>vorzeichenlosen</i> Typ zur√ºckgibt.  Wir berechnen den Wert des Ausdrucks, wenn wir annehmen, dass die Funktion den Wert 8 zur√ºckgibt: <br><br>  ~ (getStubAlignment () - 1) <br><br>  ~ (8u-1) <br><br>  0xFFFFFFF8u <br><br>  <i>Beachten Sie</i> nun, dass die <i>DataSize-</i> Variable einen 64-Bit-Typ ohne Vorzeichen hat.  Es stellt sich heraus, dass w√§hrend der Operation DataSize &amp; 0xFFFFFFF88 alle zweiunddrei√üig h√∂herwertigen Bits zur√ºckgesetzt werden.  Dies ist h√∂chstwahrscheinlich nicht das, was der Programmierer wollte.  Ich vermute, dass er berechnen wollte: DataSize &amp; 0xFFFFFFFFFFFFFFFFF8u. <br><br>  Um den Fehler zu beheben, sollten Sie wie folgt schreiben: <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(getStubAlignment()) - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Oder so: <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1U</span></span>LL);</code> </pre> <br>  <b>Fragment N34: Explizite Besetzung fehlgeschlagen</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scaleShuffleMask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Scale, ArrayRef&lt;T&gt; Mask, SmallVectorImpl&lt;T&gt; &amp;ScaledMask)</span></span></span><span class="hljs-function"> </span></span>{ assert(<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; Scale &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Unexpected scaling factor"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumElts = Mask.size(); ScaledMask.assign(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(NumElts * Scale), <span class="hljs-number"><span class="hljs-number">-1</span></span>); .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1028</a> [CWE-190] M√∂glicher √úberlauf.  Ziehen Sie in Betracht, Operanden des Operators 'NumElts * Scale' in den Typ 'size_t' umzuwandeln, nicht in das Ergebnis.  X86ISelLowering.h 1577 <br><br>  Die explizite Typkonvertierung wird verwendet, um einen √úberlauf beim Multiplizieren von Variablen vom Typ <i>int</i> zu verhindern.  Das explizite Gie√üen hier sch√ºtzt jedoch nicht vor √úberlauf.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu Beginn werden die Variablen multipliziert, und erst dann wird das 32-Bit-Multiplikationsergebnis auf den Typ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size_t</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erweitert </font><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment N35: Erfolgloses Kopieren und Einf√ºgen</font></font></b> <br><br><pre> <code class="cpp hljs">Instruction *InstCombiner::visitFCmpInst(FCmpInst &amp;I) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op0, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op0, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return &amp;I; } .... }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V778</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [CWE-682] Es wurden zwei √§hnliche Codefragmente gefunden. </font><font style="vertical-align: inherit;">M√∂glicherweise ist dies ein Tippfehler und die Variable 'Op1' sollte anstelle von 'Op0' verwendet werden. </font><font style="vertical-align: inherit;">InstCombineCompares.cpp 5507 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese neue interessante Diagnose zeigt Situationen auf, in denen ein Codefragment kopiert wurde und einige Namen sich darin zu √§ndern begannen, aber nicht an einer Stelle korrigiert wurden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte beachten Sie, dass im zweiten Block </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ge√§ndert wurde </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber an einem Ort haben sie es nicht behoben. </font><font style="vertical-align: inherit;">H√∂chstwahrscheinlich h√§tte es so geschrieben werden sollen:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op1-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment N36: Verwirrung in Variablen</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Status</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode; Status() : Mask(<span class="hljs-number"><span class="hljs-number">0</span></span>), Mode(<span class="hljs-number"><span class="hljs-number">0</span></span>){}; Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { Mode &amp;= Mask; }; .... };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1001</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [CWE-563] Die Variable 'Mode' wird zugewiesen, aber am Ende der Funktion nicht verwendet. </font><font style="vertical-align: inherit;">SIModeRegister.cpp 48 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist sehr gef√§hrlich, Funktionsargumenten dieselben Namen wie Klassenmitgliedern zu geben. </font><font style="vertical-align: inherit;">Sehr leicht zu verwirren. </font><font style="vertical-align: inherit;">Vor uns liegt genau so ein Fall. </font><font style="vertical-align: inherit;">Dieser Ausdruck macht keinen Sinn:</font></font><br><br><pre> <code class="cpp hljs">Mode &amp;= Mask;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Argument der Funktion √§ndert sich. </font><font style="vertical-align: inherit;">Und alle. </font><font style="vertical-align: inherit;">Dieses Argument wird nicht mehr verwendet. </font><font style="vertical-align: inherit;">H√∂chstwahrscheinlich musste man so schreiben:</font></font><br><br><pre> <code class="cpp hljs">Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Mode &amp;= Mask; };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment N37: Verwirrung in Variablen</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionBase</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SymbolTableSection</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SectionBase { .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SymbolTableSection::addSymbol(Twine Name, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Bind, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Type, SectionBase *DefinedIn, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Visibility, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Shndx, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size) { .... Sym.Value = Value; Sym.Visibility = Visibility; Sym.Size = Size; Sym.Index = Symbols.size(); Symbols.emplace_back(llvm::make_unique&lt;Symbol&gt;(Sym)); Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V1001 [CWE-563] Die Variable 'Gr√∂√üe' wird zugewiesen, aber am Ende der Funktion nicht verwendet. </font><font style="vertical-align: inherit;">Object.cpp 424 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Situation ist √§hnlich wie in der vorherigen. </font><font style="vertical-align: inherit;">Es sollte geschrieben werden:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize;</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment N38-N47: Zeiger hat die √úberpr√ºfung vergessen.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zuvor haben wir Beispiele f√ºr </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diagnostische </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Ausl√∂sung</font></a><font style="vertical-align: inherit;"> von </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">V595</font></a><font style="vertical-align: inherit;"> untersucht </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das Wesentliche ist, dass der Zeiger am Anfang dereferenziert und erst dann √ºberpr√ºft wird. </font><font style="vertical-align: inherit;">Die junge Diagnose des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Umkehrung seiner Bedeutung, erkennt aber auch viele Fehler. </font><font style="vertical-align: inherit;">Es identifiziert Situationen, in denen der Zeiger zu Beginn √ºberpr√ºft und dann vergessen wurde, dies zu tun. </font><font style="vertical-align: inherit;">Betrachten Sie solche F√§lle innerhalb von LLVM.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGEPCost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type *PointeeType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *Ptr, ArrayRef&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *&gt; Operands)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= assert(....); BaseGV = dyn_cast&lt;GlobalValue&gt;(Ptr-&gt;stripPointerCasts()); } bool HasBaseReg = (BaseGV == nullptr); auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType()); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V1004 [CWE-476] Der 'Ptr'-Zeiger wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde. </font><font style="vertical-align: inherit;">Pr√ºfzeilen: 729, 738. TargetTransformInfoImpl.h 738 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptr-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">kann </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullptr sein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie aus der Pr√ºfung hervorgeht:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterhalb dieses Zeigers wird jedoch ohne vorherige √úberpr√ºfung dereferenziert: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrachten Sie einen anderen √§hnlichen Fall. </font></font><br><br><pre> <code class="cpp hljs">llvm::DISubprogram *CGDebugInfo::getFunctionFwdDeclOrStub(GlobalDecl GD, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Stub) { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> *FD = dyn_cast&lt;FunctionDecl&gt;(GD.getDecl()); SmallVector&lt;QualType, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; ArgTypes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FD) <span class="hljs-comment"><span class="hljs-comment">// &lt;= for (const ParmVarDecl *Parm : FD-&gt;parameters()) ArgTypes.push_back(Parm-&gt;getType()); CallingConv CC = FD-&gt;getType()-&gt;castAs&lt;FunctionType&gt;()-&gt;getCallConv(); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V1004 [CWE-476] Der 'FD'-Zeiger wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 3228, 3231. CGDebugInfo.cpp 3231 Achten Sie </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf den Zeiger </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich bin sicher, dass das Problem deutlich sichtbar ist und keine besondere Erkl√§rung erforderlich ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und auch:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computePolynomialFromPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value &amp;Ptr, Polynomial &amp;Result, Value *&amp;BasePtr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL)</span></span></span><span class="hljs-function"> </span></span>{ PointerType *PtrTy = dyn_cast&lt;PointerType&gt;(Ptr.getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PtrTy) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= Result = Polynomial(); BasePtr = nullptr; } unsigned PointerBits = DL.getIndexSizeInBits(PtrTy-&gt;getPointerAddressSpace()); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V1004 [CWE-476] Der 'PtrTy'-Zeiger wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 960, 965. InterleavedLoadCombinePass.cpp 965 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie sch√ºtzen Sie sich vor solchen Fehlern? </font><font style="vertical-align: inherit;">Seien Sie bei der Code√ºberpr√ºfung vorsichtig und √ºberpr√ºfen Sie Ihren Code regelm√§√üig mit dem statischen Analyseger√§t PVS-Studio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es macht keinen Sinn, andere Codefragmente mit Fehlern dieses Typs mitzubringen. </font><font style="vertical-align: inherit;">Ich werde nur eine Liste von Warnungen im Artikel hinterlassen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004 [CWE-476] Der Zeiger 'Expr' wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 1049, 1078. DebugInfoMetadata.cpp 1078</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004 [CWE-476] Der 'PI'-Zeiger wurde unsicher verwendet, nachdem er gegen nullptr verifiziert wurde. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 733, 753. LegacyPassManager.cpp 753</font></font></li><li> V1004 [CWE-476] The 'StatepointCall' pointer was used unsafely after it was verified against nullptr. Check lines: 4371, 4379. Verifier.cpp 4379 </li><li> V1004 [CWE-476] The 'RV' pointer was used unsafely after it was verified against nullptr. Check lines: 2263, 2268. TGParser.cpp 2268 </li><li> V1004 [CWE-476] The 'CalleeFn' pointer was used unsafely after it was verified against nullptr. Check lines: 1081, 1096. SimplifyLibCalls.cpp 1096 </li><li> V1004 [CWE-476] The 'TC' pointer was used unsafely after it was verified against nullptr. Check lines: 1819, 1824. Driver.cpp 1824 </li></ul><br> <b> N48-N60:  ,   (  )</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutator&gt; createISelMutator() { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutationStrategy&gt;&gt; Strategies; Strategies.emplace_back( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectorIRStrategy(InjectorIRStrategy::getDefaultOps())); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1023</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [CWE-460] Ein Zeiger ohne Eigent√ºmer wird durch die Methode 'emplace_back' zum Container 'Strategies' hinzugef√ºgt. Im Ausnahmefall tritt ein Speicherverlust auf. llvm-isel-fuzzer.cpp 58 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein Element am Ende eines Containers wie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: vector &lt;std :: unique_ptr &lt;X&gt;&gt; </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hinzuzuf√ºgen,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen Sie nicht einfach </font><i><font style="vertical-align: inherit;">xxx.push_back (neues X)</font></i><font style="vertical-align: inherit;"> schreiben </font><font style="vertical-align: inherit;">, da keine implizite Konvertierung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X *</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nach </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std erfolgt: : unique_ptr &lt;X&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine √ºbliche L√∂sung besteht darin, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxx.emplace_back (neues X)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu schreiben </font><font style="vertical-align: inherit;">, da es kompiliert: Die Methode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emplace_back</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellt </font><font style="vertical-align: inherit;">ein Element direkt aus den Argumenten und kann daher explizite Konstruktoren verwenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist nicht sicher. </font><font style="vertical-align: inherit;">Wenn der Vektor voll ist, wird Speicher zugewiesen. </font><font style="vertical-align: inherit;">Eine Speicherzuweisungsoperation kann fehlschlagen, was dazu f√ºhrt, dass eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: bad_alloc-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausnahme </font><i><font style="vertical-align: inherit;">ausgel√∂st wird</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In diesem Fall geht der Zeiger verloren und das erstellte Objekt wird niemals gel√∂scht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine sichere L√∂sung besteht darin, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu erstellen </font><font style="vertical-align: inherit;">, dem der Zeiger geh√∂rt, bevor der Vektor versucht, den Speicher neu zuzuweisen:</font></font><br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ab C ++ 14 k√∂nnen Sie 'std :: make_unique' verwenden: </font></font><br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;X&gt;())</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Art von Defekt ist f√ºr LLVM nicht kritisch. </font><font style="vertical-align: inherit;">Wenn kein Speicher zugewiesen werden kann, funktioniert der Compiler einfach nicht mehr. </font><font style="vertical-align: inherit;">F√ºr Anwendungen mit einer langen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betriebszeit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die nicht einfach enden k√∂nnen, wenn die Speicherzuweisung fehlschl√§gt, kann dies jedoch ein wirklich b√∂ser Fehler sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl dieser Code keine praktische Gefahr f√ºr LLVM darstellt, fand ich es n√ºtzlich, √ºber dieses Fehlermuster zu sprechen und dass der PVS-Studio-Analysator gelernt hat, es zu erkennen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Warnungen dieses Typs:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1023 [CWE-460] Ein Zeiger ohne Eigent√ºmer wird dem Container 'Passes' durch die Methode 'emplace_back' hinzugef√ºgt. </font><font style="vertical-align: inherit;">Im Ausnahmefall tritt ein Speicherverlust auf. </font><font style="vertical-align: inherit;">PassManager.h 546</font></font></li><li> V1023 [CWE-460] A pointer without owner is added to the 'AAs' container by the 'emplace_back' method. A memory leak will occur in case of an exception. AliasAnalysis.h 324 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Entries' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DWARFDebugFrame.cpp 519 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'AllEdges' container by the 'emplace_back' method. A memory leak will occur in case of an exception. CFGMST.h 268 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'VMaps' container by the 'emplace_back' method. A memory leak will occur in case of an exception. SimpleLoopUnswitch.cpp 2012 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Records' container by the 'emplace_back' method. A memory leak will occur in case of an exception. FDRLogBuilder.h 30 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'PendingSubmodules' container by the 'emplace_back' method. A memory leak will occur in case of an exception. ModuleMap.cpp 810 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Objects' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DebugMap.cpp 88 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 60 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 685 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 686 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 688 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 689 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 690 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 691 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 692 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 693 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 694 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Operands' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 1911 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Stash' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2100 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Matchers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2702 </li></ul><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insgesamt schrieb ich 60 Warnungen aus, danach h√∂rte ich auf. </font><font style="vertical-align: inherit;">Gibt es andere Fehler, die der PVS-Studio-Analysator in LLVM erkennt?</font></font> Ja, gibt es.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als ich jedoch die Codefragmente f√ºr den Artikel schrieb, war es sp√§ter Abend oder besser gesagt sogar Nacht, und ich entschied, dass es Zeit war, abzurunden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, Sie waren interessiert und m√∂chten den PVS-Studio-Analysator ausprobieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser Seite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen Sie den Analysator herunterladen und einen Testschl√ºssel erhalten </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie vor allem regelm√§√üig statische Analysen. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einmalige √úberpr√ºfungen,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die von uns durchgef√ºhrt werden, um die Methodik der statischen Analyse und von PVS-Studio bekannt zu machen, sind kein normales Szenario. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viel Gl√ºck bei der Verbesserung der Qualit√§t und Zuverl√§ssigkeit des Codes!</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Andrey Karpov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suchen von Fehlern in LLVM 8 mit PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450008/">https://habr.com/ru/post/de450008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449998/index.html">FAQ: Was ein reisender Geek √ºber Impfungen wissen muss, bevor er reist</a></li>
<li><a href="../de450000/index.html">(Von rechts nach links (Durch den Spiegel</a></li>
<li><a href="../de450002/index.html">Suchen von Fehlern in LLVM 8 mit PVS-Studio</a></li>
<li><a href="../de450004/index.html">Schneller C / C ++ - Cache, Thread-Sicherheit</a></li>
<li><a href="../de450006/index.html">K√ºhlung des K√ºhler-Rechenzentrums: Welches K√ºhlmittel soll gew√§hlt werden?</a></li>
<li><a href="../de450010/index.html">Speicherung, Sicherung und Katalogisierung von Fotos</a></li>
<li><a href="../de450016/index.html">Erstellung eines formalen Verifizierungssystems von Grund auf neu. Teil 1: Virtuelle Zeichenmaschine in PHP und Python</a></li>
<li><a href="../de450018/index.html">Ein Mathe-Duo kartierte ein endloses Gebiet mit minimalen Oberfl√§chen</a></li>
<li><a href="../de450020/index.html">Silicon Valley kam zu Schulkindern aus Kansas. Dies f√ºhrte zu Protesten.</a></li>
<li><a href="../de450024/index.html">Informationen zu Open-Source-Implementierungen der Hash-Funktion GOST R 34.11-2012 und deren Auswirkungen auf die elektronische Signatur von GOST R 34.10-2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>