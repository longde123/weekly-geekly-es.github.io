<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèª üõÄüèø üì¶ Meine Erfahrung von Fehlern üõåüèæ üèõÔ∏è üÜô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Meine Erfahrung von Fehlern 
 Fehlerliste 


1. Allm√§chtige Klasse MCManager 
2. Unsere Navigation zwischen den Bildschirmen erfinden 
3. Es gibt nie ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meine Erfahrung von Fehlern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451996/"><h3>  Meine Erfahrung von Fehlern </h3><br><h4>  Fehlerliste </h4><br><ol><li>  Allm√§chtige Klasse MCManager </li><li>  Unsere Navigation zwischen den Bildschirmen erfinden </li><li>  Es gibt nie viel Vererbung </li><li>  Architektur aus eigener Produktion oder weiterhin Fahrr√§der herstellen </li><li>  MVVM mit Soul MVP </li><li>  Der zweite Versuch mit Navigation oder Router und der Kr√ºmmung der Navigation </li><li>  Hartn√§ckiger Manager </li></ol><br>  Viele Menschen, auch ich, schreiben, wie man in einer bestimmten Situation das Richtige tut, wie man Code richtig schreibt, wie man architektonische L√∂sungen anwendet usw. Aber ich m√∂chte meine Erfahrungen dar√ºber teilen, wie es falsch gemacht wurde und welche Schlussfolgerungen ich gezogen habe basierend auf seinen Fehlern gemacht.  H√∂chstwahrscheinlich sind dies h√§ufige Fehler aller, die dem Weg des Entwicklers folgen, oder vielleicht ist etwas Neues.  Ich m√∂chte nur meine Erfahrungen teilen und die Kommentare anderer Leute lesen. <br><a name="habracut"></a><br><h4>  Allm√§chtige Klasse MCManager </h4><br>  Nach dem ersten Jahr der Arbeit in der IT und insbesondere der iOS-Entwicklung entschied ich, dass ich bereits Architekt genug und bereit war, etwas zu erstellen.  Schon damals habe ich intuitiv verstanden, dass es notwendig ist, die Gesch√§ftslogik von der Pr√§sentationsschicht zu trennen.  Aber die Qualit√§t meiner Vorstellung davon war weit von der Realit√§t entfernt. <br><br>  Ich zog an einen neuen Arbeitsplatz, wo ich beauftragt wurde, eigenst√§ndig eine neue Funktion f√ºr ein bestehendes Projekt zu entwickeln.  Es war ein Analogon zur Aufnahme von Videos auf Instagram, bei der die Aufnahme durchgef√ºhrt wird, w√§hrend der Benutzer seinen Finger auf der Schaltfl√§che h√§lt, und dann mehrere Fragmente des Videos miteinander verbunden werden.  Zun√§chst wurde beschlossen, diese Funktion als separates Projekt oder vielmehr in Form eines Beispiels zu erstellen.  So wie ich es verstehe, beginnt die Quelle meiner architektonischen Probleme, die mehr als ein Jahr dauerten. <br><br>  In Zukunft hat sich dieses Beispiel zu einer vollwertigen Anwendung zum Aufnehmen und Bearbeiten von Videos entwickelt.  Es ist lustig, dass die Probe urspr√ºnglich einen Namen hatte, von dessen Abk√ºrzung das MC-Pr√§fix gesammelt wurde.  Das Projekt wurde zwar bald umbenannt, aber das Pr√§fix gem√§√ü der Namenskonvention in Objective-C blieb MC erhalten.  So wurde die allm√§chtige MCManager-Klasse geboren. <br><br><img src="https://habrastorage.org/webt/sz/jw/m_/szjwm_hbfvtxjbovprczya2jyca.jpeg"><br><br>  Da es sich um ein Beispiel handelte und die Funktionalit√§t zun√§chst einfach war, entschied ich, dass eine Managerklasse ausreichen w√ºrde.  Wie bereits erw√§hnt, umfasste die Funktionalit√§t das Aufzeichnen eines Videofragments mit Start / Stopp-Optionen und das weitere Kombinieren dieser Fragmente zu einem ganzen Video.  Und in diesem Moment kann ich meinen ersten Fehler nennen - den Namen der MCManager-Klasse.  MCManager, Karl!  Was sollte ein Klassenname anderen Entwicklern √ºber seinen Zweck, seine F√§higkeiten und seine Verwendung sagen?  Richtig, absolut nichts!  Und das steht im Anhang, dessen Name nicht einmal die Buchstaben M und seine Mutter C enth√§lt. Obwohl dies nicht mein Hauptfehler ist, da die Klasse mit dem Partisanennamen alles getan hat, ist alles aus dem Wort absolut alles, was der Hauptfehler war. <br><br>  Die Videoaufzeichnung ist ein kleiner Dienst. Die Verwaltung der Speicherung von Videodateien im Dateisystem ist der zweite und zus√§tzliche Dienst zum Kombinieren mehrerer Videos zu einem.  Die Arbeit dieser drei unabh√§ngigen Dienste wurde beschlossen, in einem Manager zu kombinieren.  Die Idee war nobel, unter Verwendung des Fassadenmusters eine einfache Schnittstelle f√ºr die Gesch√§ftslogik zu erstellen und alle unn√∂tigen Details √ºber das Zusammenspiel verschiedener Komponenten zu verbergen.  Selbst der Name einer solchen Fassadenklasse lie√ü in der Anfangsphase keinen Verdacht aufkommen, insbesondere in der Stichprobe. <br>  Aber der Kunde mochte die Demo und bald verwandelte sich das Beispiel in eine vollwertige Anwendung.  Sie k√∂nnen rechtfertigen, dass nicht gen√ºgend Zeit f√ºr das Refactoring vorhanden war, dass der Kunde den Arbeitscode nicht wiederholen wollte, aber ehrlich gesagt dachte ich in diesem Moment selbst, ich h√§tte eine hervorragende Architektur festgelegt.  In Wahrheit war die Idee, Gesch√§ftslogik und Pr√§sentation zu trennen, ein Erfolg.  Die Architektur war eine Klasse von Singleton MCManager, die die Fassade f√ºr ein paar Dutzend Services und andere Manager war.  Ja, es war auch ein Singleton, der in allen Ecken der Anwendung verf√ºgbar war. <br><br>  Man kann bereits das Ausma√ü der gesamten Katastrophe verstehen.  Eine Klasse mit mehreren tausend Codezeilen, die schwer zu lesen und zu pflegen ist.  Ich schweige bereits √ºber die M√∂glichkeit, einzelne Funktionen hervorzuheben, um sie auf eine andere Anwendung zu √ºbertragen, was in der mobilen Entwicklung durchaus √ºblich ist. <br>  Die Schlussfolgerungen, die ich nach einer Weile f√ºr mich selbst gezogen habe, sind nicht, universelle Klassen mit obskuren Namen zu schaffen.  Mir wurde klar, dass Logik in Teile zerlegt werden muss und nicht f√ºr alles eine universelle Schnittstelle schaffen muss.  Tats√§chlich war dies ein Beispiel daf√ºr, was passieren w√ºrde, wenn Sie eines der SOLID-Prinzipien, das Prinzip der Schnittstellentrennung, nicht einhalten. <br><br><h4>  Unsere Navigation zwischen den Bildschirmen erfinden </h4><br>  Die Trennung von Logik und Schnittstelle ist nicht das einzige Problem, das mich √ºber das obige Projekt beunruhigt hat.  Ich werde nicht sagen, dass ich in diesem Moment den Bildschirmcode und den Navigationscode trennen wollte, aber es stellte sich heraus, dass ich mein Fahrrad f√ºr die Navigation entwickelt hatte. <br><br><img src="https://habrastorage.org/webt/ab/dt/j1/abdtj1sogyy-j7ppjfbk9uhshge.jpeg"><br><br>  Die Stichprobe hatte nur drei Bildschirme: ein Men√º mit einer Tabelle mit aufgezeichneten Videos, einen Aufzeichnungsbildschirm und einen Nachbearbeitungsbildschirm.  Um nicht zu beachten, dass der Navigationsstapel doppelte ViewController enth√§lt, habe ich beschlossen, den UINavigationController nicht zu verwenden.  Ich habe den RootViewcontroller hinzugef√ºgt. Aufmerksame Leser haben bereits vermutet, dass es sich um den MCRootViewController handelt, der in den Projekteinstellungen als Hauptversion festgelegt wurde.  Gleichzeitig war der Root-Controller nicht einer der Anwendungsbildschirme, sondern pr√§sentierte lediglich den gew√ºnschten UIViewController.  Als ob dies nicht genug w√§re, war der Root-Controller auch ein Delegat aller vertretenen Controller.  Infolgedessen gab es zu jedem Zeitpunkt nur zwei VC in der Hierarchie, und die gesamte Navigation wurde unter Verwendung des Delegatenmusters implementiert. <br><br>  So sah es aus: Jeder Bildschirm hatte ein eigenes Delegatenprotokoll, in dem Navigationsmethoden angegeben waren, und der Root-Controller implementierte diese Methoden und √§nderte die Bildschirme.  RootViewController dissmisil current controller, erstellte einen neuen und pr√§sentierte ihn, w√§hrend es m√∂glich war, Informationen von einem Bildschirm auf einen anderen zu √ºbertragen.  Gl√ºcklicherweise geh√∂rte die Gesch√§ftslogik zur coolsten Singleton-Klasse, sodass auf keinem der Bildschirme etwas gespeichert war und schmerzlos zerst√∂rt werden konnte.  Wieder wurde eine gute Absicht verwirklicht, obwohl die Erkenntnis auf beiden Beinen humpelte und manchmal stolperte. <br><br>  Wie Sie vielleicht erraten haben, wurde die Methode aufgerufen, wenn Sie vom Videoaufzeichnungsbildschirm zur√ºck zum Hauptmen√º wechseln m√ºssen: <br><br><pre><code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)cancel;</code> </pre> <br>  oder so √§hnlich, und der Root-Controller erledigt bereits die ganze Drecksarbeit. <br>  Am Ende wurde MCRootViewController ein Analogon zu MCManager, aber bei der Navigation zwischen den Bildschirmen wurden, wie mit dem Wachstum der Anwendung und dem Hinzuf√ºgen neuer Funktionen, neue Bildschirme hinzugef√ºgt. <br><br>  Die Fahrradfabrik funktionierte unaufhaltsam und ich ignorierte weiterhin Artikel √ºber Architekturen mobiler Anwendungen.  Aber ich habe nie die Idee aufgegeben, die Navigation von den Bildschirmen zu trennen. <br><br>  Der Vorteil war, dass die Bildschirme unabh√§ngig waren und wiederverwendet werden konnten, aber dies ist nicht genau.  Zu den Nachteilen geh√∂rt jedoch die Schwierigkeit, solche Klassen aufrechtzuerhalten.  Das Problem mit dem Fehlen eines Stapels von Bildschirmen, wenn Sie zur√ºckkehren m√ºssen, indem Sie durch zuvor ausgew√§hlte Bildschirme scrollen.  Die komplexe Logik des √úbergangs zwischen Bildschirmen, der Root-Controller, wirkte sich auf einen Teil der Gesch√§ftslogik aus, um einen neuen Bildschirm korrekt anzuzeigen. <br><br>  Im Allgemeinen sollten Sie nicht die gesamte Navigation in der Anwendung auf diese Weise implementieren, da mein MCRootViewController gegen das Open-Closed-Prinzip verst√∂√üt.  Es ist fast unm√∂glich zu erweitern, und alle √Ñnderungen m√ºssen st√§ndig an der Klasse selbst vorgenommen werden. <br>  Ich begann mehr √ºber die Navigation zwischen Bildschirmen in einer mobilen Anwendung zu lesen und lernte Ans√§tze wie Router und Koordinator kennen.  Ich werde etwas sp√§ter √ºber Router schreiben, da es etwas zu teilen gibt. <br><br><h4>  Es gibt nie viel Vererbung </h4><br>  Ich m√∂chte auch nicht nur meine Perlen teilen, sondern auch die lustigen Ans√§tze und L√∂sungen anderer Leute, mit denen ich mich befassen musste. An derselben Stelle, an der ich meine Meisterwerke schuf, vertrauten sie mir eine einfache Aufgabe an.  Die Aufgabe bestand darin, meinem Projekt einen Bildschirm aus einem anderen Projekt hinzuzuf√ºgen.  Wie wir mit PM festgestellt haben, sollte dies nach einer flachen Analyse und ein wenig √úberlegung zwei oder drei Stunden und nicht l√§nger dauern, denn was daran falsch ist, m√ºssen Sie Ihrer Anwendung lediglich eine vorgefertigte Bildschirmklasse hinzuf√ºgen.  In der Tat wurde bereits alles f√ºr uns getan, wir m√ºssen Strg + C und Strg + V tun.  Hier nur eine kleine Nuance: Der Entwickler, der diese Anwendung geschrieben hat, hat die Vererbung wirklich geliebt. <br><br><img src="https://habrastorage.org/webt/bv/e7/h8/bve7h8vugtvsjzyw_ml4esh5vbe.jpeg"><br><br>  Ich fand schnell den ViewController, den ich brauchte. Ich hatte Gl√ºck, dass es keine Trennung zwischen Logik und Pr√§sentation gab.  Es war ein guter alter Ansatz, als der Controller den gesamten erforderlichen Code enthielt.  Ich kopierte es in mein Projekt und begann herauszufinden, wie es funktioniert.  Und das erste, was ich entdeckt habe, ist, dass der Controller, den ich brauche, von einem anderen Controller erbt.  Eine h√§ufige Sache, ein ziemlich erwartetes Ereignis.  Da ich nicht viel Zeit hatte, fand ich einfach die Klasse, die ich brauchte, und zog sie in mein Projekt.  Nun sollte es funktionieren, dachte ich, und ich hatte mich noch nie so geirrt! <br><br>  Die Klasse, die ich brauchte, hatte nicht nur viele Variablen von benutzerdefinierten Klassen, die auch in mein Projekt kopiert werden mussten, sodass jede von ihnen etwas erbte.  Im Gegenzug waren die Basisklassen entweder geerbt oder enthielten Felder mit benutzerdefinierten Typen, die, wie viele vermutet haben, etwas geerbt haben, und dies war leider nicht NSObject, UIViewController oder UIView.  Somit ist ein gutes Drittel des unn√∂tigen Projekts im Projekt auf mich migriert. <br><br>  Da nicht viel Zeit f√ºr die Ausf√ºhrung dieser Aufgabe erwartet wurde, sah ich keinen anderen Ausweg, wie ich einfach die erforderlichen Klassen hinzuf√ºgen konnte, die xCode ben√∂tigte, um mein Projekt schmerzlos zu starten.  Infolgedessen zogen sich zwei oder drei Stunden etwas hin, als ich mich am Ende wie ein wahrer Bildhauer in das gesamte Netz der Vererbungshierarchie vertiefen musste, um den √úberschuss abzuschneiden. <br><br>  Infolgedessen kam ich zu dem Schluss, dass alle guten Dinge in Ma√üen sein sollten, selbst eine so ‚Äûwunderbare‚Äú Sache wie das Erbe.  Dann begann ich die Nachteile der Vererbung zu verstehen.  Ich kam zu dem Schluss, wenn ich wiederverwendbare Module herstellen m√∂chte, sollte ich sie unabh√§ngiger machen. <br><br><h4>  Architektur aus eigener Produktion oder weiterhin Fahrr√§der herstellen </h4><br>  Als ich an einen neuen Arbeitsplatz zog und ein neues Projekt startete, ber√ºcksichtigte ich alle verf√ºgbaren Erfahrungen in der Gestaltung von Architektur und schuf weiter.  Nat√ºrlich ignorierte ich weiterhin die bereits erfundenen Architekturen, hielt mich aber gleichzeitig beharrlich an das Prinzip ‚ÄûTeilen und Erobern‚Äú. <br><br>  Es dauerte nicht lange, bis Swift aufkam, und so ging ich auf die M√∂glichkeiten von Objective-c ein.  Ich habe mich f√ºr die Abh√§ngigkeitsinjektion mit den Sprachfunktionen entschieden.  Ich habe mich vom lib-Erweiterungstool inspirieren lassen und kann mich nicht einmal an seinen Namen erinnern. <br><br>  Das Fazit lautet: In der BaseViewController-Basisklasse habe ich ein BaseViewModel-Klassenfeld hinzugef√ºgt.  Dementsprechend habe ich f√ºr jeden Bildschirm meinen eigenen Controller erstellt, der die grundlegenden geerbt hat, und ein Protokoll hinzugef√ºgt, damit der Controller mit dem viewModel interagieren kann.  Dann kam die Magie.  Ich habe die viewModel-Eigenschaften neu definiert und Unterst√ºtzung f√ºr das gew√ºnschte Protokoll hinzugef√ºgt.  Im Gegenzug habe ich eine neue ViewModel-Klasse f√ºr einen bestimmten Bildschirm erstellt, der dieses Protokoll implementiert hat.  Als Ergebnis √ºberpr√ºfte ich im BaseViewController in der viewDidLoad-Methode den Typ des Protokolls des Modells, √ºberpr√ºfte die Liste aller Nachkommen von BaseViewModel, fand die ben√∂tigte Klasse und erstellte das viewModel des ben√∂tigten Typs. <br><br><div class="spoiler">  <b class="spoiler_title">Grundlegendes ViewController-Beispiel</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><span class="hljs-meta"> // MVC model #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BaseMVCModel.h"</span></span></span><span class="hljs-meta"> @class BaseViewController; @protocol BaseViewControllerDelegate </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NSObject&gt;</span></span></span><span class="hljs-meta"> @required - (void)backFromNextViewController:(BaseViewController *)aNextViewController withOptions:(NSDictionary *)anOptionsDictionary; @end @interface BaseViewController : UIViewController </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;BaseViewControllerDelegate&gt;</span></span></span><span class="hljs-meta"> @property (nonatomic, weak) BaseMVCModel *model; @property (nonatomic, assign) id</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;BaseViewControllerDelegate&gt;</span></span></span><span class="hljs-meta"> prevViewController; - (void)backWithOptions:(NSDictionary *)anOptionsDictionary; + (void)setupUIStyle; @end import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BaseViewController.h"</span></span></span><span class="hljs-meta"> // Helpers #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RuntimeHelper.h"</span></span></span><span class="hljs-meta"> @interface BaseViewController () @end @implementation BaseViewController + (void)setupUIStyle { } #pragma mark - #pragma mark Life cycle - (void)viewDidLoad { [super viewDidLoad]; self.model = [BaseMVCModel getModel:FindPropertyProtocol(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"model"</span></span></span><span class="hljs-meta">, [self class])]; } #pragma mark - #pragma mark Navigation - (void)backWithOptions:(NSDictionary *)anOptionsDictionary { if (self.prevViewController) { [self.prevViewController performSelector:@selector(backFromNextViewController:withOptions:) withObject:self withObject:anOptionsDictionary]; } } #pragma mark - #pragma mark Seque - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { if ([segue.destinationViewController isKindOfClass:[BaseViewController class]] { ((BaseViewController *)segue.destinationViewController).prevViewController = self; } } #pragma mark - #pragma mark BaseViewControllerDelegate - (void)backFromNextViewController:(BaseViewController *)aNextViewController withOptions:(NSDictionary *)anOptionsDictionary { [self doesNotRecognizeSelector:_cmd]; } @end</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Grundlegendes ViewModel-Beispiel</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> @interface BaseMVCModel : NSObject @property (nonatomic, assign) id delegate; + (id)getModel:(NSString *)someProtocol; @end #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BaseMVCModel.h"</span></span></span><span class="hljs-meta"> // IoC #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IoCContainer.h"</span></span></span><span class="hljs-meta"> @implementation BaseMVCModel + (id)getModel:(NSString *)someProtocol { return [[IoCContainer sharedIoCContainer] getModel:NSProtocolFromString(someProtocol)]; } @end</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Hilfsklassen</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> @interface IoCContainer : NSObject + (instancetype)sharedIoCContainer; - (id)getModel:(Protocol *)someProtocol; @end #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IoCContainer.h"</span></span></span><span class="hljs-meta"> // Helpers #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RuntimeHelper.h"</span></span></span><span class="hljs-meta"> // Models #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BaseMVCModel.h"</span></span></span><span class="hljs-meta"> @interface IoCContainer () @property (nonatomic, strong) NSMutableSet *models; @end @implementation IoCContainer #pragma mark - #pragma mark Singleton + (instancetype)sharedIoCContainer { static IoCContainer *_sharedIoCContainer = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _sharedIoCContainer = [IoCContainer new]; }); return _sharedIoCContainer; } - (id)getModel:(Protocol *)someProtocol { if (!someProtocol) { return [BaseMVCModel new]; } NSArray *modelClasses = ClassGetSubclasses([BaseMVCModel class]); __block Class currentClass = NULL; [modelClasses enumerateObjectsUsingBlock:^(Class class, NSUInteger idx, BOOL *stop) { if ([class conformsToProtocol:someProtocol]) { currentClass = class; } }]; if (currentClass == nil) { return [BaseMVCModel new]; } __block BaseMVCModel *currentModel = nil; [self.models enumerateObjectsUsingBlock:^(id model, BOOL *stop) { if ([model isKindOfClass:currentClass]) { currentModel = model; } }]; if (!currentModel) { currentModel = [currentClass new]; [self.models addObject:currentModel]; } return currentModel; } - (NSMutableSet *)models { if (!_models) { _models = [NSMutableSet set]; } return _models; } @end #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> NSString * FindPropertyProtocol(NSString *propertyName, Class class); NSArray * ClassGetSubclasses(Class parentClass); #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RuntimeHelper.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span></span><span class="hljs-meta"> #pragma mark - #pragma mark Functions NSString * FindPropertyProtocol(NSString *aPropertyName, Class class) { unsigned int propertyCount; objc_property_t *properties = class_copyPropertyList(class, &amp;propertyCount); for (unsigned int i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; propertyCount; i++) { objc_property_t property = properties[i]; const char *propertyName = property_getName(property); if ([@(propertyName) isEqualToString:aPropertyName]) { const char *attrs = property_getAttributes(property); NSString* propertyAttributes = @(attrs); NSScanner *scanner = [NSScanner scannerWithString: propertyAttributes]; [scanner scanUpToString:@"&lt;" intoString:NULL]; [scanner scanString:@"&lt;" intoString:NULL]; NSString* protocolName = nil; [scanner scanUpToString:@"&gt;</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" intoString: &amp;protocolName]; return protocolName; } } return nil; } NSArray * ClassGetSubclasses(Class parentClass) { int numClasses = objc_getClassList(NULL, 0); Class *classes = NULL; classes = (Class *)malloc(sizeof(Class) * numClasses); numClasses = objc_getClassList(classes, numClasses); NSMutableArray *result = [NSMutableArray array]; for (NSInteger i = 0; i &lt; numClasses; i++) { Class superClass = classes[i]; do { superClass = class_getSuperclass(superClass); } while(superClass &amp;&amp; superClass != parentClass); if (superClass == nil) { continue; } [result addObject:classes[i]]; } free(classes); return result; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Beispiel f√ºr einen Anmeldebildschirm</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BaseViewController.h"</span></span></span><span class="hljs-meta"> @protocol LoginProtocol </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NSObject&gt;</span></span></span><span class="hljs-meta"> @required - (void)login:(NSString *)aLoginString password:(NSString *)aPasswordString completionBlock:(DefaultCompletionBlock)aCompletionBlock; @end @interface LoginVC : BaseViewController @end #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"LoginVC.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UIViewController+Alert.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UIViewController+HUD.h"</span></span></span><span class="hljs-meta"> @interface LoginVC () @property id</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;LoginProtocol&gt;</span></span></span><span class="hljs-meta"> model; @property (weak, nonatomic) IBOutlet UITextField *emailTF; @property (weak, nonatomic) IBOutlet UITextField *passTF; @end @implementation LoginVC @synthesize model = _model; #pragma mark - #pragma mark IBActions - (IBAction)loginAction:(id)sender { [self login]; } #pragma mark - #pragma mark UITextFieldDelegate - (BOOL)textFieldShouldReturn:(UITextField *)textField { if (textField == self.emailTF) { [self.passTF becomeFirstResponder]; } else { [self login]; } return YES; } #pragma mark - #pragma mark Login - (void)login { NSString *email = self.emailTF.text; NSString *pass = self.passTF.text; if (email.length == 0 || pass.length == 0) { [self showAlertOkWithMessage:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Please, input info!"</span></span></span><span class="hljs-meta">]; return; } __weak __typeof(self)weakSelf = self; [self showHUD]; [self.model login:self.emailTF.text password:self.passTF.text completionBlock:^(BOOL isDone, NSError *anError) { [weakSelf hideHUD]; if (isDone) { [weakSelf backWithOptions:nil]; } }]; } @end</span></span></code> </pre> <br></div></div><br>  Auf diese einfache Weise habe ich viewModel nur schleppend initialisiert und die Ansicht √ºber Protokolle schlecht mit Modellen verbunden.  Bei alledem wusste ich zu diesem Zeitpunkt noch nichts √ºber die MVP-Architektur, obwohl sich etwas √Ñhnliches √ºber mir abzeichnete. <br>  Die Navigation zwischen den Bildschirmen lag im Ermessen von ‚ÄûviewModel‚Äú, da ich dem Controller einen schwachen Link hinzugef√ºgt habe. <br><br>  Wenn ich mich jetzt an diese Implementierung erinnere, kann ich nicht sicher sagen, dass alles schlecht war.  Die Idee, Ebenen zu trennen, war ein Erfolg. Der Moment des Erstellens und Zuweisen von Modellen zur Steuerung wurde vereinfacht. <br>  Aber f√ºr mich selbst habe ich mich entschlossen, mehr √ºber vorgefertigte Ans√§tze und Architekturen zu lernen, da ich mich bei der Entwicklung einer Anwendung mit meiner eigenen Architektur mit vielen Nuancen auseinandersetzen musste.  Zum Beispiel Wiederverwendung von Bildschirmen und Modellen, Vererbung, komplexe √úberg√§nge zwischen Bildschirmen.  In diesem Moment schien mir viewModel Teil der Gesch√§ftslogik zu sein, obwohl ich jetzt verstehe, dass es immer noch eine Pr√§sentationsschicht ist.  Ich habe w√§hrend dieses Experiments gro√üartige Erfahrungen gemacht. <br><br><h4>  MVVM mit Soul MVP </h4><br>  Nachdem ich bereits Erfahrungen gesammelt hatte, entschied ich mich, eine bestimmte Architektur f√ºr mich zu w√§hlen und dieser zu folgen, anstatt Fahrr√§der zu erfinden.  Ich begann mehr √ºber Architekturen zu lesen, mich eingehend mit den damals beliebten Themen zu befassen und entschied mich f√ºr MVVM.  Ehrlich gesagt habe ich das Wesentliche nicht sofort verstanden, aber ich habe es gew√§hlt, weil mir der Name gefallen hat. <br><br>  Ich verstand die Essenz der Architektur und die Beziehung zwischen ViewModel und View (ViewController) nicht sofort, sondern begann zu tun, was ich verstand.  Die Augen haben Angst und die H√§nde tippen verzweifelt den Code. <br><br>  Zu meiner Verteidigung m√∂chte ich hinzuf√ºgen, dass zu dieser Zeit die Zeit und die Zeit zum Nachdenken und Analysieren der von mir geschaffenen Sch√∂pfung sehr eng waren.  Daher habe ich anstelle von Ordnern im ViewModel direkte Links zur entsprechenden Ansicht erstellt.  Und bereits in ViewModel selbst habe ich die Pr√§sentation eingerichtet. <br><br>  In Bezug auf MVP hatte ich die gleiche Idee wie in Bezug auf andere Architekturen, daher war ich fest davon √ºberzeugt, dass es MVVM war, bei dem sich ViewModel als die realistischsten Pr√§sentationen herausstellte. <br><br><div class="spoiler">  <b class="spoiler_title">Ein Beispiel f√ºr meine ‚ÄûMVVM‚Äú -Architektur und ja, mir hat die Idee mit RootViewController gefallen, der f√ºr die h√∂chste Navigationsebene in der Anwendung verantwortlich ist.</b>  <b class="spoiler_title">√úber den Router wird unten geschrieben.</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class RootViewController: UIViewController { var viewModel: RootViewModel? override func viewDidLoad() { super.viewDidLoad() let router = (UIApplication.shared.delegate as? AppDelegate)!.router viewModel = RootViewModel(with: self, router: router) viewModel?.setup() } } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit protocol ViewModelProtocol: class { func setup() func backAction() } class RootViewModel: NSObject, ViewModelProtocol { unowned var router : RootRouter unowned var view: RootViewController init(with view: RootViewController, router: RootRouter) { self.view = view self.router = router } <span class="hljs-comment"><span class="hljs-comment">// MARK: - ViewModelProtocol func setup() { if AccountManager.shared.isLoggedIn() { router.route(to: RootRoutes.launch.rawValue, from: view, parameters: nil) } else { router.route(to: RootRoutes.loginregistartion.rawValue, from: view, parameters: nil) } } func backAction() { } }</span></span></code> </pre> <br></div></div><br>  Dies hatte keinen besonderen Einfluss auf die Qualit√§t des Projekts, da die Reihenfolge und ein einziger Ansatz eingehalten wurden.  Aber die Erfahrung war von unsch√§tzbarem Wert.  Nach den von mir entworfenen Fahrr√§dern begann ich endlich, mich nach allgemein anerkannter Architektur zu richten.  Es sei denn, Moderatoren wurden als Moderatoren bezeichnet, was einen Drittentwickler verwirren k√∂nnte. <br><br>  Ich entschied, dass es sich in Zukunft lohnt, kleine Testprojekte durchzuf√ºhren, um die Essenz eines bestimmten Ansatzes im Design genauer zu untersuchen.  Sozusagen erst in der Praxis f√ºhlen und dann in den Kampf einbrechen.  Dies ist die Schlussfolgerung, die ich f√ºr mich selbst gezogen habe. <br><br><h4>  Der zweite Versuch mit Navigation oder Router und der Kr√ºmmung der Navigation </h4><br>  Im selben Projekt, in dem ich MVVM tapfer und naiv implementiert habe, habe ich beschlossen, einen neuen Ansatz f√ºr die Navigation zwischen Bildschirmen auszuprobieren.  Wie ich bereits erw√§hnt habe, habe ich mich immer noch an die Idee gehalten, Bildschirme und die Logik des √úbergangs zwischen ihnen zu trennen. <br><br>  Als ich √ºber MVVM las, interessierte mich ein Muster wie Router.  Nachdem ich die Beschreibung erneut √ºberpr√ºft hatte, begann ich, die L√∂sung in meinem Projekt zu implementieren. <br><br><div class="spoiler">  <b class="spoiler_title">Router Beispiel</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit protocol Router: class { func route(to routeID: String, from view: UIViewController, parameters: Any?) func back(from view: UIViewController, parameters: Any?) } extension Router { func back(from view: UIViewController, parameters: Any?) { let navigationController: UINavigationController = checkNavigationController(for: view) navigationController.popViewController(animated: false) } } enum RootRoutes: String { case launch = "Launch" case loginregistartion = "LoginRegistartionRout" case mainmenu = "MainMenu" } class RootRouter: Router { var loginRegistartionRouter: LoginRegistartionRouter? var mainMenuRouter: MainMenuRouter? <span class="hljs-comment"><span class="hljs-comment">// MARK: Router func route(to routeID: String, from view: UIViewController, parameters: Any?) { var rootView = view if view is EPLaunchViewController { rootView = (view.navigationController?.viewControllers.first)! view.navigationController?.popViewController(animated: false) } if routeID == RootRoutes.loginregistartion.rawValue { loginRegistartionRouter = LoginRegistartionRouter(with: self) loginRegistartionRouter?.route(to: LRRouteID.phoneNumber.rawValue, from: rootView, parameters: nil) } else if routeID == RootRoutes.mainmenu.rawValue { if mainMenuRouter == nil { mainMenuRouter = MainMenuRouter(with: self) } mainMenuRouter?.route(to: MMRouteID.start.rawValue, from: rootView, parameters: nil) } else if routeID == RootRoutes.launch.rawValue { let storyboard = UIStoryboard(name: "RootStoryboard", bundle: nil) let launchView = storyboard.instantiateViewController(withIdentifier: "LaunchViewController") as! LaunchViewController let navigationController: UINavigationController = checkNavigationController(for: view) launchView.viewModel = LaunchViewModel(with: launchView, router: self) navigationController.pushViewController(launchView, animated: false) } } }</span></span></code> </pre><br></div></div><br>  Der Mangel an Erfahrung bei der Umsetzung eines solchen Musters hat sich bemerkbar gemacht.  Alles schien ordentlich und klar zu sein, der Router erstellte eine neue UIViewController-Klasse, erstellte ein ViewModel daf√ºr und f√ºhrte die Logik zum Umschalten auf diesen Bildschirm aus.  Dennoch machten sich viele M√§ngel bemerkbar. <br>  Schwierigkeiten traten auf, als es notwendig war, eine Anwendung mit einem bestimmten Bildschirm nach einer Push-Benachrichtigung zu √∂ffnen.  Infolgedessen haben wir an einigen Stellen eine verwirrende Logik f√ºr die Auswahl des richtigen Bildschirms und weitere Schwierigkeiten bei der Unterst√ºtzung eines solchen Ansatzes. <br><br>  Ich habe die Idee der Implementierung von Router nicht aufgegeben, sondern bin in diese Richtung weitergegangen und habe immer mehr Erfahrung gesammelt.  Geben Sie nach dem ersten fehlgeschlagenen Versuch nichts auf. <br><br><h4>  Hartn√§ckiger Manager </h4><br>  Eine weitere interessante Managerklasse in meiner Praxis.  Aber dieser ist relativ jung.  Trotzdem besteht der Entwicklungsprozess aus Versuch und Irrtum, und da wir alle, oder die meisten von uns, st√§ndig im Entwicklungsprozess sind, treten immer Fehler auf. <br><br>  Das Wesentliche des Problems ist, dass die Anwendung √ºber Dienste verf√ºgt, die st√§ndig h√§ngen bleiben m√ºssen und gleichzeitig an vielen Stellen verf√ºgbar sein sollten. <br><br>  Beispiel: Ermitteln des Bluetooth-Status.  In meiner Anwendung muss ich in mehreren Diensten verstehen, ob Bluetooth aktiviert oder deaktiviert ist, und Statusaktualisierungen abonnieren.  Da es mehrere solcher Stellen gibt: einige Bildschirme, mehrere zus√§tzliche Gesch√§ftslogikmanager usw., muss jeder von ihnen den Delegierten CBPeripheralManager (oder CBCentralManager) abonnieren. <br><br>  Die L√∂sung scheint offensichtlich zu sein. Wir erstellen eine separate Klasse, die den Status von Bluetooth √ºberwacht und alle, die ihn ben√∂tigen, √ºber das Observer-Muster benachrichtigt.  Aber dann stellt sich die Frage, wer diesen Service dauerhaft speichern wird.  Das erste, was mir in diesem Moment einf√§llt, ist, es zu einem Singleton zu machen!  Alles scheint in Ordnung zu sein! <br><br>  Aber hier kommt der Moment, in dem sich mehr als ein solcher Dienst in meiner Bewerbung angesammelt hat.  Ich m√∂chte auch keine 100500 Singletones im Projekt machen. <br><br>  Und dann ging ein weiteres Licht √ºber meinem bereits hellen kleinen Kopf an.  Erstellen Sie einen Singleton, der alle diese Dienste speichert und in der gesamten Anwendung Zugriff darauf bietet.  Und so wurde der "st√§ndige Manager" geboren.  Mit dem Namen habe ich lange nicht nachgedacht und ihn, wie jeder schon erraten konnte, PersistentManager genannt. <br><br>  Wie Sie sehen k√∂nnen, habe ich auch einen sehr originellen Ansatz f√ºr die Benennung von Klassen.  Ich denke, ich muss eine Modeerscheinung √ºber den Namen der Klassen in meinen Entwicklungsplan aufnehmen. <br><br>  Das Hauptproblem bei dieser Implementierung ist der Singleton, der √ºberall im Projekt verf√ºgbar ist.  Dies f√ºhrt dazu, dass Manager, die einen der permanenten Dienste nutzen, innerhalb ihrer Methoden darauf zugreifen, was nicht offensichtlich ist.  Zum ersten Mal bin ich darauf gesto√üen, als ich ein gro√ües komplexes Feature in einem separaten Demo-Projekt erstellt und einen Teil der Gesch√§ftslogik aus dem Hauptprojekt √ºbertragen habe.  Dann erhielt ich Nachrichten mit Fehlern √ºber fehlende Dienste. <br><br>  Die Schlussfolgerung, die ich danach gezogen habe, ist, dass Sie Ihre Klassen so gestalten m√ºssen, dass es keine versteckten Abh√§ngigkeiten gibt.  Die erforderlichen Dienste m√ºssen beim Initialisieren der Klasse als Parameter √ºbergeben werden, d√ºrfen jedoch keinen Singleton verwenden, auf den von √ºberall aus zugegriffen werden kann.  Und noch sch√∂ner ist es, Protokolle zu verwenden. <br>  Dies stellte sich als eine weitere Best√§tigung f√ºr das Fehlen eines Singleton-Musters heraus. <br><br><h4>  Zusammenfassung </h4><br>  Und das, ich stehe nicht still, sondern gehe voran und beherrsche neue Ans√§tze in der Programmierung.  Die Hauptsache ist, sich zu bewegen, zu suchen und zu experimentieren.  Fehler werden immer sein, es gibt kein Entrinnen davon.  Aber nur weil man seine Fehler erkennt, kann man sich qualitativ entwickeln. <br><br><img src="https://habrastorage.org/webt/xe/xr/wf/xexrwfhf0_i5cpoxtv3kjrqxsne.gif"><br><br>  In den meisten F√§llen sind die Probleme Superklassen, die viel bewirken, oder die falschen Abh√§ngigkeiten zwischen Klassen.  Was darauf hindeutet, dass es notwendig ist, die Logik kompetenter zu zerlegen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451996/">https://habr.com/ru/post/de451996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451974/index.html">AMD-Geschichte: 50 Jahre rasante Entwicklung</a></li>
<li><a href="../de451976/index.html">Was kostet ein "souver√§ner" Runet?</a></li>
<li><a href="../de451982/index.html">Je schneller Sie OOP vergessen, desto besser f√ºr Sie und Ihre Programme.</a></li>
<li><a href="../de451986/index.html">Das Abrufen von Daten mit ORM ist einfach! Oder nicht?</a></li>
<li><a href="../de451990/index.html">FAQ zu Transfers und Anschlussfl√ºgen: Was ist der Unterschied, den ein Passagier machen kann und was nicht</a></li>
<li><a href="../de451998/index.html">Probleme der Pr√§zisionslandwirtschaft und wie man damit umgeht</a></li>
<li><a href="../de452000/index.html">Wie Sie in Leroy Merlin Waren aus dem Lager eines Lieferanten kaufen k√∂nnen, der sich nicht im Sortiment des Gesch√§fts befindet</a></li>
<li><a href="../de452004/index.html">Fand die Absturzstelle des Bereshit auf dem Mond</a></li>
<li><a href="../de452006/index.html">Epic Metaverse: Warum Fortnite-Autoren es bekommen sollten</a></li>
<li><a href="../de452008/index.html">Technische Ans√§tze und Checkliste: Wie man im Chaos der Aufgaben nicht verr√ºckt wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>