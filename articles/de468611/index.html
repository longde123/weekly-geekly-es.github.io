<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚐 👩🏼‍🏭 🈸 .NET-Multithreading: Wenn die Leistung fehlt ☔️ 👜 👩🏻‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die .NET-Plattform bietet viele vorgefertigte Synchronisationsprimitive und threadsichere Sammlungen. Wenn Sie beispielsweise bei der Entwicklung eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET-Multithreading: Wenn die Leistung fehlt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/468611/"><img src="https://habrastorage.org/webt/rn/su/tj/rnsutjjvg7sllluahknu8brlnbc.jpeg"><br><br>  Die .NET-Plattform bietet viele vorgefertigte Synchronisationsprimitive und threadsichere Sammlungen.  Wenn Sie beispielsweise bei der Entwicklung einer Anwendung einen thread-sicheren Cache oder eine Anforderungswarteschlange implementieren müssen, werden normalerweise diese vorgefertigten Lösungen verwendet, manchmal mehrere gleichzeitig.  In einigen Fällen führt dies zu Leistungsproblemen: langes Warten auf Sperren, übermäßiger Speicherverbrauch und lange Speicherbereinigung. <br><br>  Diese Probleme können gelöst werden, wenn wir berücksichtigen, dass Standardlösungen recht allgemein gehalten werden - sie können in unseren redundanten Szenarien einen Overhead verursachen.  Dementsprechend können Sie beispielsweise Ihre eigene effektive thread-sichere Sammlung für einen bestimmten Fall schreiben. <br><br>  Unter der Zwischensequenz befindet sich ein Video und eine Abschrift meines Berichts von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNext-</a> Konferenz, in der ich einige Beispiele analysiere, wenn Tools aus der Standard-.NET-Bibliothek (Task.Delay, SemaphoreSlim, ConcurrentDictionary) zu Leistungseinbußen führen, und ich schlage Lösungen vor, die auf bestimmte Aufgaben zugeschnitten sind und keine haben diese Mängel. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-tNeYjRNJtY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Zum Zeitpunkt des Berichts arbeitete er in Kontur.  Kontur entwickelt verschiedene Anwendungen für Unternehmen. Das Team, in dem ich gearbeitet habe, befasst sich mit der Infrastruktur und entwickelt verschiedene Support-Services und Bibliotheken, die Entwicklern in anderen Teams bei der Erstellung von Produkt-Services helfen. <br><br>  Das Infrastructure-Team baut sein Data Warehouse, ein Anwendungshosting-System für Windows und verschiedene Bibliotheken für die Entwicklung von Microservices auf.  Unsere Anwendungen basieren auf einer Microservice-Architektur - alle Services interagieren über das Netzwerk miteinander und verwenden natürlich ziemlich viel asynchronen Code und Multithread-Code.  Einige dieser Anwendungen sind sehr leistungskritisch und müssen in der Lage sein, viele Anforderungen zu verarbeiten. <br><br>  Worüber werden wir heute sprechen? <br><br><ul><li>  Multithreading und Asynchronität in .NET; </li><li>  Füllen von Synchronisationsprimitiven und Sammlungen; </li><li>  Was tun, wenn Standardansätze die Last nicht bewältigen können? </li></ul><br>  Lassen Sie uns einige Funktionen der Arbeit mit Multithread- und asynchronem Code in .NET analysieren.  Schauen wir uns einige Synchronisationsprimitive und gleichzeitige Sammlungen an und sehen, wie sie im Inneren angeordnet sind.  Wir werden diskutieren, was zu tun ist, wenn nicht genügend Leistung vorhanden ist, wenn die Standardklassen die Last nicht bewältigen können und ob in dieser Situation etwas getan werden kann. <br><br>  Ich werde Ihnen vier Geschichten erzählen, die an unserem Produktionsstandort passiert sind. <br><br><h2>  Verlauf 1: Task.Delay &amp; TimerQueue </h2><br>  Diese Geschichte ist bereits ziemlich bekannt, auch bei DotNext.  Es hat jedoch eine ziemlich interessante Fortsetzung bekommen, also habe ich sie hinzugefügt.  Worum geht es also? <br><br><h3>  1.1 Polling und Long Polling </h3><br>  Der Server führt lange Operationen aus, der Client wartet auf sie. <br>  <b>Abfrage: Der</b> Client fragt den Server regelmäßig nach dem Ergebnis. <br>  <b>Lange Abfrage: Der</b> Client sendet eine Anforderung mit einer langen Zeitüberschreitung, und der Server antwortet, wenn der Vorgang abgeschlossen ist. <br><br>  Vorteile: <br><br><ul><li>  Weniger Verkehr </li><li>  Der Kunde erfährt schneller von dem Ergebnis </li></ul><br>  Stellen Sie sich vor, wir haben einen Server, der einige lange Anforderungen verarbeiten kann, z. B. eine Anwendung, die XML-Dateien in PDF konvertiert, und es gibt Clients, die diese Aufgaben zur Verarbeitung ausführen und asynchron auf ihr Ergebnis warten möchten.  Wie kann eine solche Erwartung verwirklicht werden? <br><br>  Der erste Weg ist das <b>Abrufen</b> .  Der Client startet die Aufgabe auf dem Server und überprüft dann regelmäßig den Status dieser Aufgabe, während der Server den Status der Aufgabe zurückgibt ("abgeschlossen" / "fehlgeschlagen" / "mit einem Fehler abgeschlossen").  Der Client sendet regelmäßig Anforderungen, bis das Ergebnis angezeigt wird. <br><br>  Der zweite Weg ist <b>langes Polling</b> .  Der Unterschied besteht darin, dass der Client Anforderungen mit langen Zeitüberschreitungen sendet.  Der Server, der eine solche Anfrage erhält, meldet nicht sofort, dass die Aufgabe nicht abgeschlossen wurde, sondern versucht eine Weile zu warten, bis das Ergebnis angezeigt wird. <br>  Was ist der Vorteil einer langen Abfrage gegenüber einer regulären Abfrage?  Erstens wird weniger Verkehr erzeugt.  Wir stellen weniger Netzwerkanforderungen - weniger Verkehr wird über das Netzwerk gejagt.  Außerdem kann der Client das Ergebnis schneller als bei regulären Abfragen ermitteln, da er nicht auf das Intervall zwischen mehreren Abfrageanforderungen warten muss.  Was wir bekommen wollen, ist verständlich.  Wie werden wir dies in Code implementieren? <br><blockquote>  Aufgabe: Zeitüberschreitung <br>  Wir möchten mit einer Zeitüberschreitung auf Task warten <br>  warte auf SendAsync (); </blockquote>  Zum Beispiel haben wir eine Aufgabe, die eine Anfrage an den Server sendet, und wir möchten mit einem Timeout auf das Ergebnis warten. Das heißt, wir geben entweder das Ergebnis dieser Aufgabe zurück oder senden eine Art Fehler.  Der C # -Code sieht folgendermaßen aus: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sendTask = SendAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayTask = Task.Delay(timeout); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(sendTask, delayTask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task == delayTask) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Timeout;</code> </pre> <br>  Dieser Code startet unsere Task, deren Ergebnis wir warten möchten, und Task.Delay.  Als nächstes warten wir mit Task.WhenAny entweder auf unsere Task oder auf Task.Delay.  Wenn sich herausstellt, dass Task.Delay zuerst ausgeführt wird, die Zeit abgelaufen ist und wir eine Zeitüberschreitung haben, müssen wir einen Fehler zurückgeben. <br><br>  Dieser Code ist natürlich nicht perfekt und kann verbessert werden.  Zum Beispiel würde es nicht schaden, Task.Delay abzubrechen, wenn SendAsync früher zurückkehrt, aber das ist für uns jetzt nicht sehr interessant.  Das Fazit ist, dass wir einige Leistungsprobleme bekommen, wenn wir einen solchen Code schreiben und ihn für lange Abfragen mit langen Zeitüberschreitungen anwenden. <br><br><h3>  1.2 Probleme mit langen Abfragen </h3><br><ul><li>  Große Auszeiten </li><li>  Viele gleichzeitige Abfragen </li><li>  =&gt; Hohe CPU-Auslastung </li></ul><br>  In diesem Fall ist das Problem der hohe Verbrauch an Prozessorressourcen.  Es kann vorkommen, dass der Prozessor zu 100% voll ausgelastet ist und die Anwendung im Allgemeinen nicht mehr funktioniert.  Es scheint, dass wir überhaupt keine Prozessorressourcen verbrauchen: Wir führen einige asynchrone Vorgänge durch, warten auf eine Antwort vom Server, und der Prozessor ist immer noch mit uns geladen. <br><br>  In dieser Situation haben wir einen Speicherauszug aus unserer Anwendung entfernt: <br><br><pre> <code class="cs hljs"> ~*e!clrstack System.Threading.Monitor.Enter(System.Object) System.Threading.TimerQueueTimer.Change(…) System.Threading.Timer.TimerSetup(…) System.Threading.Timer..ctor(…) System.Threading.Tasks.Task.Delay(…)</code> </pre> <br>  Um den Dump zu analysieren, haben wir das WinDbg-Tool verwendet.  Wir haben einen Befehl eingegeben, der Stapelspuren aller verwalteten Threads anzeigt, und ein solches Ergebnis gesehen.  Wir haben viele Threads in Bearbeitung, die auf eine Sperre warten.  Die Monitor.Enter-Methode ist das, in das das Sperrkonstrukt in C # erweitert wird.  Diese Sperre wird in Klassen namens Timer und TimerQueueTimer erfasst.  In Timer kamen wir von Task.Delay, als wir versuchten, sie zu erstellen.  Was ist das  Wenn Task.Delay gestartet wird, wird die Sperre in der TimerQueue erfasst. <br><br><h3>  1.3 Konvoi sperren </h3><br><ul><li>  Viele Threads versuchen, eine Sperre zu sperren </li><li>  Unter der Sperre wird wenig Code ausgeführt </li><li>  Die Zeit wird für die Thread-Synchronisation und nicht für die Codeausführung aufgewendet. </li><li>  Threadblocks sind blockiert - sie sind nicht unendlich </li></ul><br>  Wir hatten einen Schlosskonvoi in der Anwendung.  Viele Threads versuchen, dieselbe Sperre zu erfassen.  Unter dieser Sperre wird ziemlich viel Code ausgeführt.  Prozessorressourcen werden hier nicht für den Anwendungscode selbst ausgegeben, sondern für Vorgänge zum Synchronisieren von Threads untereinander für diese Sperre.  Beachten Sie auch eine Funktion in Bezug auf .NET: Die Threads, die am Lock Convoi teilnehmen, sind Threads aus dem Thread-Pool. <br><br>  Wenn Threads aus dem Thread-Pool blockiert werden, können sie dementsprechend enden - die Anzahl der Threads im Thread-Pool ist begrenzt.  Es kann konfiguriert werden, es gibt jedoch noch eine Obergrenze.  Sobald es erreicht ist, nehmen alle Threadpool-Threads am Sperrkonvoi teil, und jeglicher Code, der den Threadpool betrifft, wird nicht mehr in der Anwendung ausgeführt.  Dies verschlechtert die Situation erheblich. <br><br><h3>  1.4 TimerQueue </h3><br><ul><li>  Verwaltet Timer in einer .NET-Anwendung. </li><li>  Timer werden verwendet in: <br>  - Task.Delay <br>  - CancellationTocken.CancelAfter <br>  - HttpClient </li></ul><br>  TimerQueue ist eine Klasse, die alle Timer in einer .NET-Anwendung verwaltet.  Wenn Sie einmal in WinForms programmiert haben, haben Sie möglicherweise Timer manuell erstellt.  Für diejenigen, die nicht wissen, was Timer sind: Sie werden in Task.Delay verwendet (dies ist nur unser Fall), sie werden auch im CancellationToken in der CancelAfter-Methode verwendet.  Das Ersetzen von Task.Delay durch CancellationToken.CancelAfter würde uns in keiner Weise helfen.  Darüber hinaus werden Timer in vielen internen .NET-Klassen verwendet, z. B. in HttpClient. <br><br>  Soweit ich weiß, haben einige Implementierungen von HttpClient-Handlern Timer.  Auch wenn Sie sie nicht explizit verwenden, starten Sie Task.Delay nicht. Wahrscheinlich verwenden Sie sie trotzdem. <br><br>  Schauen wir uns nun an, wie TimerQueue im Inneren angeordnet ist. <br><br><ul><li>  Globaler Status (pro Appdomain): <br>  - Doppelt verknüpfte Liste von TimerQueueTimer <br>  - Objekt sperren </li><li>  Routine-Timer-Rückrufe </li><li>  Timer nicht nach Antwortzeit sortiert </li><li>  Hinzufügen eines Timers: O (1) + Sperre </li><li>  Timer entfernen: O (1) + Sperre </li><li>  Timer starten: O (N) + Sperre </li></ul><br>  In TimerQueue gibt es einen globalen Status. Es handelt sich um eine doppelt verknüpfte Liste von Objekten vom Typ TimerQueueTimer.  TimerQueueTimer enthält einen Link zu anderen TimerQueueTimer, zu Nachbarn in einer verknüpften Liste sowie den Timer und die Rückrufzeit, die beim Auslösen des Timers aufgerufen werden.  Diese doppelt verknüpfte Liste ist durch ein Sperrobjekt geschützt, genau das, auf dem der Sperrkonvoi in unserer Anwendung stattgefunden hat.  Ebenfalls in TimerQueue gibt es eine Routine, die Rückrufe startet, die an unsere Timer gebunden sind. <br><br>  Timer sind in keiner Weise nach Antwortzeit geordnet, die gesamte Struktur ist für das Hinzufügen / Entfernen neuer Timer optimiert.  Wenn die Routine gestartet wird, durchläuft sie die gesamte doppelt verknüpfte Liste, wählt die Timer aus, die funktionieren sollen, und ruft sie zurück. <br><br>  Die Komplexität der Operation ist hier so.  Das Hinzufügen und Entfernen eines Timers erfolgt O pro Einheit, und der Start der Timer erfolgt pro Zeile.  Wenn mit der algorithmischen Komplexität alles akzeptabel ist, gibt es außerdem ein Problem: Alle diese Operationen erfassen die Sperre, was nicht sehr gut ist. <br><br>  Welche Situation kann passieren?  In TimerQueue sind zu viele Timer angesammelt. Wenn die Routine gestartet wird, wird die lange lineare Operation gesperrt. Zu diesem Zeitpunkt können diejenigen, die versuchen, Timer aus TimerQueue zu starten oder zu entfernen, nichts dagegen tun.  Aus diesem Grund tritt ein Schleusenkonvoi auf.  Dieses Problem wurde in .NET Core behoben. <br><blockquote>  Reduzieren Sie Timer-Sperrenkonflikte (coreclr # 14527) <br><ul><li>  Scherben sperren <br>  - TimerQueueTimer von Environment.ProcessorCount TimerQueue </li><li>  Separate Warteschlangen für kurz- / langlebige Timer </li><li>  Kurzer Timer: Zeit &lt;= 1/3 Sekunde </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/dotnet/coreclr/issues/14462</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/dotnet/coreclr/pull/14527</a> <br></blockquote>  Wie wurde es behoben?  Sie haben TimerQueue durchsucht: Anstelle einer TimerQueue, die für die gesamte AppDomain statisch war, wurden für die gesamte Anwendung mehrere TimerQueue erstellt.  Wenn Threads dort ankommen und versuchen, ihre Timer zu starten, fallen diese Timer in eine zufällige TimerQueue, und die Threads haben weniger Chancen, auf einer Sperre zusammenzustoßen. <br><br>  Auch in .NET Core wurden einige Optimierungen angewendet.  Timer wurden in langlebige und kurzlebige unterteilt. Für sie werden jetzt separate TimerQueue verwendet.  Der kurzlebige Timer wird auf weniger als 1/3 Sekunde eingestellt.  Ich weiß nicht, warum eine solche Konstante gewählt wurde.  In .NET Core konnten wir keine Probleme mit Timern feststellen. <br><br><img src="https://habrastorage.org/webt/f_/am/cv/f_amcv6bohiq54ciyuunvtrr0ei.jpeg"><br><br>  <a href="">https://github.com/Microsoft/dotnet-framework-early-access/blob/master/release-notes/NET48/dotnet-48-changes.md</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/dotnet/coreclr/labels/netfx-port-consider</a> <br><br>  Dieser Fix wurde auf .NET Framework, Version 4.8, zurückportiert.  Das netfx-port-Consider-Tag ist im obigen Link angegeben. Wenn Sie zum .NET Core-, CoreCLR- und CoreFX-Repository wechseln, können Sie nach diesem Problem suchen, das in das .NET Framework zurückportiert wird. Es gibt jetzt ungefähr fünfzig davon.  Das heißt, das Open Source .NET hat sehr geholfen, einige Fehler wurden behoben.  Sie können Changelog .NET Framework 4.8 lesen: Viele Fehler wurden behoben, viel mehr als in anderen .NET-Versionen.  Interessanterweise ist dieses Update in .NET Framework 4.8 standardmäßig deaktiviert.  Es ist in der gesamten Ihnen bekannten Datei namens App.config enthalten <br><br>  Die Einstellung in App.config, die diesen Fix aktiviert, heißt UseNetCoreTimer.  Bevor .NET Framework 4.8 herauskam, mussten Sie Ihre Implementierung von Task.Delay verwenden, damit unsere Anwendung funktioniert und nicht in den Sperrkonvoi wechselt.  Darin haben wir versucht, einen binären Heap zu verwenden, um effizienter zu verstehen, welche Timer jetzt aufgerufen werden sollten. <br><br><h3>  1.5 Task.Delay: native Implementierung </h3><br><ul><li>  Binärhaufen </li><li>  Scherben </li><li>  Es hat geholfen, aber nicht in allen Fällen </li></ul><br>  Durch die Verwendung eines binären Heaps können Sie die Routine optimieren, die Rückrufe aufruft, aber die Zeit verkürzt, die zum Entfernen eines beliebigen Timers aus der Warteschlange erforderlich ist. Dazu müssen Sie den Heap neu erstellen.  Dies ist höchstwahrscheinlich der Grund, warum .NET eine doppelt verknüpfte Liste verwendet.  Natürlich würde es uns hier nicht helfen, nur einen binären Heap zu verwenden. Wir mussten auch TimerQueue ausarbeiten.  Diese Lösung funktionierte einige Zeit, aber trotzdem fiel alles wieder in einen Sperrkonvoi, da Timer nicht nur dort verwendet werden, wo sie explizit im Code gestartet werden, sondern auch in Bibliotheken von Drittanbietern und im .NET-Code.  Um dieses Problem vollständig zu beheben, müssen Sie ein Upgrade auf .NET Framework Version 4.8 durchführen und das Update von .NET-Entwicklern aktivieren. <br><br><h3>  1.6 Task.Delay: Schlussfolgerungen </h3><br><ul><li>  Überall Fallstricke - auch bei den am häufigsten verwendeten Dingen </li><li>  Stresstests durchführen </li><li>  Wechseln Sie zu Core, holen Sie sich zuerst Fehlerbehebungen (und neue Fehler) :) </li></ul><br>  Was sind die Schlussfolgerungen aus dieser ganzen Geschichte?  Erstens können die Fallstricke wirklich überall lokalisiert werden, selbst in den Klassen, die Sie jeden Tag verwenden, ohne beispielsweise an dieselbe Aufgabe, Task.Delay, zu denken. <br><br>  Ich empfehle, Stresstests Ihrer Vorschläge durchzuführen.  Dieses Problem haben wir gerade in der Phase des Lasttests festgestellt.  Wir haben es dann mehrmals in der Produktion in anderen Anwendungen gedreht, aber Stresstests haben uns trotzdem geholfen, die Zeit zu verzögern, bevor wir auf dieses Problem in der Realität gestoßen sind. <br><br>  Wechseln Sie zu .NET Core - Sie erhalten als Erster Fehlerbehebungen (und neue Fehler).  Wo ohne neue Bugs? <br><br>  Die Geschichte über die Timer ist vorbei und wir fahren mit dem nächsten fort. <br><br><h2>  Geschichte 2: SemaphoreSlim </h2><br>  Die folgende Geschichte handelt von dem bekannten SemaphoreSlim. <br><br><h3>  2.1 Serverdrosselung </h3><br><ul><li>  Es ist erforderlich, die Anzahl der gleichzeitig verarbeiteten Anforderungen auf dem Server zu begrenzen </li></ul><br>  Wir wollten die Drosselung auf dem Server implementieren.  Was ist das?  Sie alle kennen wahrscheinlich die Drosselung der CPU: Wenn der Prozessor überhitzt, senkt er seine Frequenz, um sich abzukühlen, und dies schränkt seine Leistung ein.  So ist es hier.  Wir wissen, dass unser Server N Anfragen parallel verarbeiten kann und nicht fallen kann.  Was wollen wir machen  Begrenzen Sie die Anzahl der gleichzeitig verarbeiteten Anforderungen auf diese Konstante und stellen Sie sie so ein, dass, wenn weitere Anforderungen eingehen, diese in die Warteschlange gestellt werden und warten, bis die zuvor eingegangenen Anforderungen ausgeführt werden.  Wie kann dieses Problem gelöst werden?  Es ist notwendig, eine Art Synchronisationsprimitiv zu verwenden. <br><br>  Semaphore ist ein Synchronisationsprimitiv, auf das Sie N-mal warten können. Danach wartet derjenige, der zuerst N + usw. ankommt, darauf, bis diejenigen, die es früher eingegeben haben, Semaphore freigeben.  Es stellt sich ungefähr so ​​heraus: Zwei Hinrichtungsfäden, zwei Arbeiter gingen unter Semaphore, der Rest stand in der Schlange. <br><br><img src="https://habrastorage.org/webt/6s/bu/h7/6sbuh77p4temzi5yiofjlh-rxoi.png"><br><br>  Natürlich ist Semaphore für uns nicht sehr geeignet, es ist in .NET synchron, also haben wir SemaphoreSlim genommen und diesen Code geschrieben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(N); … <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> semaphore.WaitAsync(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> HandleRequestAsync(request); semaphore.Release();</code> </pre> <br>  Wir erstellen SemaphoreSlim, warten Sie, unter Semaphore bearbeiten wir Ihre Anfrage, danach veröffentlichen wir Semaphore.  Es scheint, dass dies eine ideale Implementierung der Server-Drosselung ist und nicht mehr besser sein kann.  Aber alles ist viel komplizierter. <br><br><h3>  2.2 Serverdrosselung: Komplikation </h3><br><ul><li>  Anfragen in LIFO-Reihenfolge bearbeiten </li><li>  SemaphoreSlim </li><li>  Concurrentstack </li><li>  TaskCompletionSource </li></ul><br>  Wir haben die Geschäftslogik ein wenig vergessen.  Die Anforderungen, die zur Drosselung kommen, sind echte http-Anforderungen.  In der Regel haben sie eine Zeitüberschreitung, die von denjenigen festgelegt wird, die diese Anforderung automatisch gesendet haben, oder eine Zeitüberschreitung des Benutzers, der nach einiger Zeit F5 drückt.  Wenn Sie also Anforderungen in einer Warteschlangenreihenfolge wie ein reguläres Semaphor verarbeiten, werden möglicherweise zuerst die Anforderungen aus der Warteschlange verarbeitet, für die eine Zeitüberschreitung aufgetreten ist.  Wenn Sie in Stapelreihenfolge arbeiten und zuerst die zuletzt verarbeiteten Anforderungen verarbeiten, tritt ein solches Problem nicht auf. <br><br>  Zusätzlich zu SemaphoreSlim mussten wir ConcurrentStack, TaskCompletionSource, verwenden, um viel Code um all dies zu wickeln, damit alles in der von uns benötigten Reihenfolge funktionierte.  TaskCompletionSource ist so etwas wie CancellationTokenSource, jedoch nicht für CancellationToken, sondern für Task.  Sie können eine TaskCompletionSource erstellen, eine Aufgabe daraus ziehen, sie ausgeben und dann TaskCompletionSource mitteilen, dass Sie das Ergebnis für diese Aufgabe festlegen müssen. Diejenigen, die auf diese Aufgabe warten, werden von diesem Ergebnis erfahren. <br><br>  Wir haben es alle umgesetzt.  Der Code ist schrecklich.  und am schlimmsten war, dass es nicht funktionierte. <br><br>  Einige Monate nach dem Start der Verwendung in einer ziemlich stark ausgelasteten Anwendung ist ein Problem aufgetreten.  Auf die gleiche Weise wie im vorherigen Fall ist der CPU-Verbrauch auf 100% gestiegen.  Wir haben das Gleiche getan, den Dump entfernt, ihn in WinDbg angeschaut und wieder den Schleusenkonvoi gefunden. <br><br><img src="https://habrastorage.org/webt/h_/ef/as/h_efasuul34r0fm7vwopo2hm1bc.jpeg"><br><br>  Diesmal fand der Lock-Konvoi in SemaphoreSlim.WaitAsync und SemaphoreSlim.Release statt.  Es stellte sich heraus, dass es in SemaphoreSlim eine Sperre gibt, die nicht sperrenfrei ist.  Dies stellte sich für uns als ziemlich schwerwiegender Nachteil heraus. <br><br><img src="https://habrastorage.org/webt/0h/-k/qq/0h-kqqxojlujm3dglokmacabvwq.jpeg"><br><br>  In SemaphoreSlim gibt es einen internen Zustand (ein Zähler dafür, wie viele Arbeiter noch darunter gehen können) und eine doppelt verknüpfte Liste derer, die auf dieses Semaphor warten.  Die Ideen hier sind ungefähr gleich: Sie können an diesem Semaphor warten, Sie können Ihre Erwartung stornieren - diese Warteschlange zu verlassen.  Es gibt ein Schloss, das unser Leben ruiniert hat. <br><br>  Wir entschieden uns: runter mit all dem schrecklichen Code, den wir schreiben mussten. <br><br><img src="https://habrastorage.org/webt/ax/ls/3i/axls3iseuxmgjt-vqkeiqs7hvtq.jpeg"><br><br>  Schreiben wir unser Semaphor, das sofort sperrfrei ist und sofort in Stapelreihenfolge funktioniert.  Das Warten abzubrechen ist uns nicht wichtig. <br><br><img src="https://habrastorage.org/webt/rv/rg/wv/rvrgwv8apebibtiymhxpvm5giti.jpeg"><br><br>  Definieren Sie diese Bedingung.  Hier ist die Nummer currentCount - so viele Plätze sind noch im Semaphor übrig.  Wenn in Semaphore keine Plätze mehr vorhanden sind, ist diese Zahl negativ und zeigt an, wie viele Mitarbeiter sich in der Warteschlange befinden.  Es wird auch einen ConcurrentStack geben, der aus TaskCompletionSource'ov besteht - dies ist nur ein Stapel Kellner'ov, aus dem sie bei Bedarf gezogen werden.  Schreiben wir die WaitAsync-Methode. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> decrementedCount = Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decrementedCount &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.CompletedTask; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(); waiters.Push(waiter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waiter.Task;</code> </pre> <br>  Zuerst verringern wir den Zähler, nehmen einen Platz für uns im Semaphor ein, wenn wir freie Plätze hatten, und dann sagen wir: „Das war's, du bist unter das Semaphor gegangen“. <br><br>  Wenn es in Semaphore keine Stellen gab, erstellen wir eine TaskCompletionSource, werfen sie auf den Stapel von waiter'ov und geben Task an die Außenwelt zurück.  Wenn die Zeit gekommen ist, wird diese Aufgabe funktionieren, und der Arbeiter kann seine Arbeit fortsetzen und wird unter Semaphor gehen. <br><br>  Schreiben wir nun die Release-Methode. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waiters.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter)) waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Die Freigabemethode lautet wie folgt: <br><br><ul><li>  Freier Platz im Semaphor </li><li>  Inkrementiere currentCount </li></ul><br>  Wenn wir anhand von currentCount erkennen können, ob sich im Stapel ein Kellner befindet, über den wir signalisieren müssen, ziehen wir diesen Kellner aus dem Stapel und signalisieren.  Hier ist der Kellner eine TaskCompletionSource.  Frage zu diesem Code: Es scheint logisch zu sein, aber funktioniert es überhaupt?  Welche Probleme gibt es?  Es gibt eine Nuance in Bezug darauf, wo Continuation'y und TaskCompletionSource'y gestartet werden. <br><br><img src="https://habrastorage.org/webt/_1/zo/hu/_1zohu07rqeiemrkwrcubv7gwhe.png"><br><br>  Betrachten Sie diesen Code.  Wir haben eine TaskCompletionSource erstellt und zwei Tasks gestartet.  Die erste Aufgabe zeigt eine Einheit an, setzt das Ergebnis auf eine TaskCompletionSource und zeigt dann eine Zwei auf der Konsole an.  Die zweite Task wartet auf diese TaskCompletionSource, auf ihre Task und blockiert dann für immer ihren Thread aus dem Thread-Pool. <br><br>  Was wird hier passieren?  Aufgabe 2 bei der Kompilierung wird in zwei Methoden unterteilt, von denen die zweite eine Fortsetzung ist, die Thread.Sleep enthält.  Nach dem Festlegen des Ergebnisses der TaskCompletionSource wird diese Fortsetzung in demselben Thread ausgeführt, in dem die erste Task ausgeführt wurde.  Dementsprechend wird der Fluss der ersten Aufgabe für immer blockiert und die Zwei zur Konsole werden nicht mehr gedruckt. <br><br>  Interessanterweise habe ich versucht, diesen Code zu ändern, und wenn ich die Ausgabe an die Konsoleneinheit entfernt habe, wurde die Fortsetzung für einen anderen Thread aus dem Thread-Pool gestartet und die Zwei gedruckt.  In welchen Fällen wird die Fortsetzung im selben Thread ausgeführt und in welchen - zum Thread-Pool gelangen - eine Frage an die Leser. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;( TaskCreationOptions.RunContinuationsAsynchronously); <span class="hljs-comment"><span class="hljs-comment">/* OR */</span></span> Task.Run(() =&gt; tcs.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>));</code> </pre> <br>  Um dieses Problem zu lösen, können wir entweder eine TaskCompletionSource mit dem entsprechenden RunContinuationsAsynchronously-Flag erstellen oder die TrySetResult-Methode in Task.Run/ThreadPool.QueueUserWorkItem aufrufen, damit sie nicht in unserem Thread ausgeführt wird.  Wenn es in unserem Thread ausgeführt wird, können unerwünschte Nebenwirkungen auftreten.  Darüber hinaus gibt es ein zweites Problem, auf das wir noch näher eingehen werden. <br><br><img src="https://habrastorage.org/webt/m9/x8/gx/m9x8gxz7x5tw3mjcps7nygdmkjs.jpeg"><br><br>  Schauen Sie sich die WaitAsync- und Release-Methoden an und versuchen Sie, ein anderes Problem in der Release-Methode zu finden. <br><br>  Höchstwahrscheinlich ist es so einfach unmöglich, sie zu finden.  Hier gibt es ein Rennen. <br><br><img src="https://habrastorage.org/webt/cs/1e/4q/cs1e4q3yaz4d3084_24z2ucsd6y.jpeg"><br><br>  Dies liegt an der Tatsache, dass bei der WaitAsync-Methode die Statusänderung nicht atomar ist.  Zuerst dekrementieren wir den Zähler und schieben erst dann den Kellner auf den Stapel.  Wenn es so kommt, dass Release zwischen Dekrement und Push ausgeführt wird, wird es möglicherweise beendet, damit nichts aus dem Stapel gezogen wird.  Dies muss berücksichtigt werden, und warten Sie bei der Freigabemethode, bis der Kellner auf dem Stapel angezeigt wird. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Waiter waiter; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spinner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!waiter.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> waiter)) spinner.SpinOnce(); waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Hier machen wir es in einer Schleife, bis wir es schaffen, es herauszuziehen.  Um Prozessorzyklen nicht noch einmal zu verschwenden, verwenden wir SpinWait. <br><br>  In den ersten Iterationen dreht es sich in einer Schleife.  Wenn es viele Iterationen gibt, wird der Kellner lange Zeit nicht angezeigt, und unser Thread wechselt zu Thread.Sleep, um keine CPU-Ressourcen erneut zu verschwenden. <br><br>  Tatsächlich ist das Semaphor der LIFO-Ordnung nicht nur unsere Idee. <br><blockquote>  <b>LowLevelLifoSemaphore</b> <br><ul><li>  Synchron </li><li>  Unter Windows wird der E / A-Abschlussport als Windows-Stapel verwendet </li></ul><br>  <a href="">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Threading/LowLevelLifoSemaphore.cs</a> </blockquote>  Es gibt ein solches Semaphor in .NET selbst, aber nicht in CoreCLR, nicht in CoreFX, sondern in CoreRT.  Es ist manchmal sehr nützlich, einen Blick in das .NET-Repository zu werfen.  Es gibt ein Semaphor namens LowLevelLifoSemaphore.  Dieses Semaphor würde uns sowieso nicht passen: Es ist synchron. <br><br>  Bemerkenswerterweise funktioniert es unter Windows über IO Completion-Ports.  Sie haben die Eigenschaft, dass Threads auf sie warten können, und diese Threads werden nur in der LIFO-Reihenfolge freigegeben.  Diese Funktion wird dort verwendet, es ist wirklich LowLevel. <br><br><h3>  2.3 Schlussfolgerungen: </h3><br><ul><li>  Hoffen Sie nicht, dass die Füllung des Frameworks unter Ihrer Last überlebt </li><li>  Es ist einfacher, ein bestimmtes Problem zu lösen als im allgemeinen Fall. </li><li>  Stresstests helfen nicht immer </li><li>  Vorsicht vor Blockierung </li></ul><br>  Was sind die Schlussfolgerungen aus dieser ganzen Geschichte?  Hoffen Sie zunächst nicht, dass einige Klassen aus dem Framework, das Sie aus der Standardbibliothek verwenden, mit Ihrer Last fertig werden.  Ich möchte nicht sagen, dass SemaphoreSlim schlecht ist, es hat sich gerade in diesem Szenario als ungeeignet herausgestellt. <br><br>  Es stellte sich heraus, dass es für uns viel einfacher war, unser Semaphor für eine bestimmte Aufgabe zu schreiben.  Beispielsweise wird das Abbrechen des Wartens nicht unterstützt.  Diese Funktion ist im üblichen SemaphoreSlim verfügbar, wir haben sie nicht, aber dies ermöglichte es uns, den Code zu vereinfachen. <br><br>  Lasttests helfen zwar, helfen aber möglicherweise nicht immer. <br><br> .NET  ,           —   .        lock,  : «    ?»     CPU 100%,     lock', , ,   -  .NET.      . <br><br>    . <br><br><h2>  3: (A)sync IO </h2><br>    /,      . <br><br><img src="https://habrastorage.org/webt/84/qh/sz/84qhsz9je7twmgbswt5so0dfx2q.jpeg"><br><br>    lock convoy,    stack trace     Overlapped  PinnableBufferCache.   lock.     : Overlapped  PinnableBufferCache? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OVERLAPPED</a> —    Windows,      /.      ,        .        ,  .       ,     lock convoy.   ,      lock convoy,    ,   . <br><br><img src="https://habrastorage.org/webt/if/j_/fc/ifj_fclqmvkfgfff7zedxpj63mo.jpeg"><br><br>  ,       ,   .NET 4.5.1  4.5.2.     .NET 4.5.2,     ,    .NET 4.5.2.  .NET 4.5.1     OverlappedDataCache,      Overlapped — ,       ,   .    ,  lock-free,   ConcurrentStack,       .  .NET 4.5.2     :  OverlappedDataCache   PinnableBufferCache. <br><br>   ? PinnableBufferCache     ,   Overlapped     ,    ,       —      . ,     ,      . PinnableBufferCache     .   , lock-free,   ConcurrentStack.     ,      .        ,        ,  -    lock-free    list  lock'. <br><br><h3> 3.1 PinnableBufferCache </h3><br> LockConvoy: <br><br><ul><li>    </li><li>      </li></ul><br>  lock convoy  ,   -     .        list      ,     lock   ,  ,                . <br><br>     PinnableBufferCache  ,         .    : <br><br><pre> <code class="plaintext hljs">PinnableBufferCache_System.ThreadingOverlappedData_MinCount</code> </pre> <br>      ,      .  : « !         -  ».         -: <br><br><pre> <code class="cs hljs">Environment.SetEnvironmentVariable( <span class="hljs-string"><span class="hljs-string">"PinnableBufferCache_System.Threading.OverlappedData_MinCount"</span></span>, <span class="hljs-string"><span class="hljs-string">"10000"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Overlapped().GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);</code> </pre> <br>    ?     ,    Overlapped  ,   ,        .     ,   ,     ,     ,  PinnableBufferCache      lock convoy'.    ,           . <br><br>  .NET Core  PinnableBufferCache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,   OverlappedData   . ,        , Garbage collector     ,      .     .NET Core  .  .NET Framework,   ,     . <br><br><h3> 3.2 : </h3><br><ul><li>      </li><li>      </li><li>   .NET Core </li></ul><br>      ,     .   ,   .NET            ,       . ,  ,  .NET Core. ,     ,         -. <br><br>    key-value . <br><br><h2>  4: Concurrent key-value collections </h2><br>  .NET   concurrent-.  lock-free  ConcurrentStack  ConcurrentQueu,       .   ConcurrentDictionary,    .   lock-free  ,   ,      .    ConcurrentDictionary? <br><br><h3> 4.1 ConcurrentDictionary </h3><br> : <br><br><ul><li>  Cache </li><li>  </li></ul><br>  Vorteile: <br><br><ul><li>     </li><li>   (TryAdd/TryUpdate/AddOrUpdate) </li><li> Lock-free  </li><li> Lock-free enumeration </li></ul><br>      , memory-,  ,        .    ,    ,    .NET Framework.            . ,  ,      (enumeration) lock-free. ,   . <br><br>  ,   ,   -  .NET.  key-value    -    : <br><br><img src="https://habrastorage.org/webt/ff/9f/g_/ff9fg_qzzuzvafep8c-p3seyigm.jpeg"><br><br>  -,     bucket'.      bucket',    .   ,    bucket   ,       . <br><br>    —   ,  ConcurrentDictionary.  ConcurrentDictionary    «-»   .    ,      ,   ,       memory traffic.     ConcurrentDictionary,   lock'.   —   . <br><br>    ,    Dictionary. <br><br><img src="https://habrastorage.org/webt/-_/dw/jo/-_dwjoxswmd1kecoi3aln8m7bow.jpeg"><br><br>  Dictionary  ,  Concurrent,      .     :  buckets,  entries.   buckets       bucket'   entries.   «-»    entries.          .      «-»   int,     bucket'. <br><br>   memory overhead,     ConcurrentDictionary   Dictionary. <br><br><img src="https://habrastorage.org/webt/em/aa/ch/emaachor-z_xxt7m_1wc7ntqupm.jpeg"><br><br>    Dictionary. Memory overhea'    ,       .    Dictionary  overhead  -    ,  int'.  8 . <br><br>    ConcurrentDictionary.  ConcurrentDictionary     ConcurrentDictionary.Node.   , .     int hashCode        .       ,    table (  16 ),  int hashCode     .      ,   64-    28  overhead'.       Dictionary. <br><br>  memory overhead', ConcurrentDictionary     GC   ,       .     Benchmark.   ConcurrentDictionary  ,       GC.Collect.    ? <br><br><img src="https://habrastorage.org/webt/on/yj/uq/onyjuq1rqgfkv8iav5x4z8nrnq8.jpeg"><br><br>     .       ConcurrentDictionary  10  ,        ,             ,      .   Dictionary   .      ,   ,  ,    .       . <br><br>     ,     ConcurrentDictionary? <br><br><h3> 4.2   </h3><br><ul><li>    </li><li> TTL </li><li> Dictionary+lock </li><li> Sharding </li></ul><br>     .      ConcurrentDictionary.        10  .   ,     .   TTL  ,    .        Dictionary  lock'. ,  ,  lock    .       Dictionary  lock'      ,   -     ,           lock.      ,     . <br><br><h3> 4.3  </h3><br><ul><li>   in-memory  &lt;Guid,Guid&gt; </li><li>   &gt;10 <sup>6</sup>  </li><li>       </li><li>   </li><li>        </li></ul><br>     .      —      ,       in-memory   Guid'  Guid,     .       .     - - ,     .  ,            15    .   .     Semaphore     ConcurrentDictionary. <br><br><img src="https://habrastorage.org/webt/u4/kw/kt/u4kwkttmxwpyelqlqoqp9zxahaa.jpeg"><br><br> ,    lock-free    ,    overhead      GC.   ,          .      ,    ,       ,   .   ,     -  ,       ,    .  ,  ,      Large Object Heap.    ? <br><br>       ,     ,     Dictionary   . <br><br><img src="https://habrastorage.org/webt/kx/yn/oi/kxynoiatsy8zcyrc5dei-xohlk4.jpeg"><br><br>   Dictionary   bucket',  Entry.  Entry  , ,   ,   . <br><br><img src="https://habrastorage.org/webt/n8/7a/5r/n87a5rlkgdk62nw82qysi3fmi18.png"><br><br>  Dictionary   ,   ,      . ,     - . <br><br>      ,  -     ? -,  ,       ,     ,      .     .    Dictionary,     , buckets, entries,              Interlocked. ,         . <br><blockquote> <b>Dictionary</b> <br><ul><li>   ,    </li><li>     ,   ? <br> —  Resize  buckets  entries   <br> —      - <br> —    Dictionary.Entry <br> —   -   </li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://blogs.msdn.microsoft.com/tess/2009/12/21/high-cpu-in-net-app-using-a-static-generic-dictionary/</a> </blockquote>     ,       Dictionary       -  bucket'.       ,      .    ,     ,        .       ,       ,    . <br><br>      Entry  Dictionary.     - -    .  ,     . <br><br><img src="https://habrastorage.org/webt/4p/xb/aq/4pxbaqil2cd4jaxnayxjqz-5yae.jpeg"><br><br>    .NET Framework  1.1.     Hashtable,   Dictionary,    object'.     MSDN ,      .  ,             -.   .  ,  Hashtable  .  ,      . <br><br><h3> 4.4    Dictionary.Entry </h3><br><img src="https://habrastorage.org/webt/y2/ww/rs/y2wwrslyuqpioqcalmpnt8dh6cw.jpeg"><br>    ? Dictionary.Entry ,  ,  8 , ,  ,   ,     .  Wie kann man das machen? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; buckets[index] = …; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version++; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>   :  (    ,    )  int-.   ,  .   ,     , ,  ,  . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version; bucket = bickets[index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing || version != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>    ,     ,         .       ,   .       ,  8 . <br><br><h3> 4.5   -   </h3><br>  ,   . <br><br><img src="https://habrastorage.org/webt/hh/bp/0l/hhbp0leb95qndz4bmg-2gtvmeue.jpeg"><br><br>  Dictionary     bucket    ,     . <br><br>  Dictionary,    .      : 0  2.   bucket, 1       2.   ?     0.   ,       ,    2.     .   ,  2,       , , 1. 1       2 —     bucket.   ,      ,   .    1 — ,     bucket.  Hashtable     ,     bucket'  -.        — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">double hashing</a> . <br><br><h3> 4.6   </h3><br><ul><li>     </li><li>      </li></ul><br> <b></b> <br><br><ul><li>        </li><li>    ,  resize </li></ul><br> <b></b> <br><br><ul><li>     ,      </li></ul><br>        .         ,       Buckets,     Entries (   Buckets,     Entries).   -  ,       ,   ,          ,    . <br><br>             .    ,    . <br><br>  :     ,      ,    ,     ,     . ,       ,   . <br><br><img src="https://habrastorage.org/webt/pm/lo/ah/pmloah0wlfbq7ilvlnrvbh3pyuu.png"><br><br>     ,   , —  . <br><br>   ?   ,  -    2.   -   Capacity  ,            .    — 2.       ,   .      2.    ?  ,  ,     ,   .    -  ,        ,       3. ,    ,  ,    ,  ,  . <br><br>  ,    Hashtable,  .   ,     double hashing.     ,       ,   ,     . <br><br>   ,      ,     —   ,            .     Hashtable.   ,    —     —       .                 .  ,     bucket',       -  ,       .  . <br><br>     ,  ,   lock-free      LOH. <br><br><img src="https://habrastorage.org/webt/pg/2b/6b/pg2b6bbfkm_3nnkds27g2krziz8.jpeg"><br><br>   lock-free ?  MSDN    Hashtable ,      .    ,            ,            . <br><br><img src="https://habrastorage.org/webt/yu/sg/he/yusghe0crfu9ywaic0aozpr7wri.jpeg"><br><br>      ,     ,        ,   bucket'.         Dictionary  bucket',  -,   bucket'      .    -    bucket,  bucket  .      ,     . <br><br>  ,       Large Object Heap. <br><br><img src="https://habrastorage.org/webt/wf/po/8o/wfpo8ou1_fpzhdkgcdbjzw-7u9q.jpeg"><br><br>      .  CustomDictionary  CustomDictionarySegment    .   Dictionary,    ,      .   —   Dictionary,      .       ,      Large Object Heap.        ,   bucket'   . ,      ,    ,   bucket,     - - . <br><br>           .       ConcurrentDictionary,     .NET,        ,      . <br><br><h3> 4.7  </h3><br><ul><li> .NET   </li><li>    </li><li>   </li><li> ,     </li><li>   </li><li>   </li></ul><br>     ? .NET  .   .   ,     ,       .    -   —   - .   ,  , ,     . <br><br>  -   , ,   ,     ,   .   ,   ,   ,        , ,          .   —   , ,   . <br><br><h3>  Nützliche Links </h3><br><ul><li>   ConcurrentDictionary: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/ru/company/skbkontur/blog/348508/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/vostok/commons.threading</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/epeshk/dotnext-2019-threading</a> </li></ul><br>   —          ConcurrentDictionary. ,      ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Diafilm</a> ),       . <br><br>      GitHub.   —     ,    ,    LIFO-Semaphore,    .       ,    . <br><blockquote> 6-7     <b>DotNext 2019 Moscow</b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«.NET:  »</a>    ,        .NET Framework  .NET Core,  ,        . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468611/">https://habr.com/ru/post/de468611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468601/index.html">Schätzung der Projektlaufzeit. Warum ist es fast immer sehr untertrieben und was tun?</a></li>
<li><a href="../de468603/index.html">Rutracker hat eSNI aufgenommen. Ende der DPI-Ära und Ende der Sperren</a></li>
<li><a href="../de468605/index.html">Konstante Zeiger auf Zeiger auf Zeiger ...</a></li>
<li><a href="../de468607/index.html">Android für den Funkingenieur (Teil zwei)</a></li>
<li><a href="../de468609/index.html">Die unverständliche Leistung der Mehrfachplanung</a></li>
<li><a href="../de468615/index.html">Die Top 10 Sprachen für die App-Lokalisierung</a></li>
<li><a href="../de468621/index.html">Wir übersetzen das Heimnetzwerk in DoH oder einen weiteren Klick auf die Filternase</a></li>
<li><a href="../de468623/index.html">Ich möchte Bewertungen zu Habr</a></li>
<li><a href="../de468625/index.html">Serverlos: 15% langsamer und achtmal teurer</a></li>
<li><a href="../de468627/index.html">ADAM-6200 E / A-Module</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>