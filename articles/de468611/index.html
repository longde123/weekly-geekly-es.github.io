<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöê üë©üèº‚Äçüè≠ üà∏ .NET-Multithreading: Wenn die Leistung fehlt ‚òîÔ∏è üëú üë©üèª‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die .NET-Plattform bietet viele vorgefertigte Synchronisationsprimitive und threadsichere Sammlungen. Wenn Sie beispielsweise bei der Entwicklung eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET-Multithreading: Wenn die Leistung fehlt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/468611/"><img src="https://habrastorage.org/webt/rn/su/tj/rnsutjjvg7sllluahknu8brlnbc.jpeg"><br><br>  Die .NET-Plattform bietet viele vorgefertigte Synchronisationsprimitive und threadsichere Sammlungen.  Wenn Sie beispielsweise bei der Entwicklung einer Anwendung einen thread-sicheren Cache oder eine Anforderungswarteschlange implementieren m√ºssen, werden normalerweise diese vorgefertigten L√∂sungen verwendet, manchmal mehrere gleichzeitig.  In einigen F√§llen f√ºhrt dies zu Leistungsproblemen: langes Warten auf Sperren, √ºberm√§√üiger Speicherverbrauch und lange Speicherbereinigung. <br><br>  Diese Probleme k√∂nnen gel√∂st werden, wenn wir ber√ºcksichtigen, dass Standardl√∂sungen recht allgemein gehalten werden - sie k√∂nnen in unseren redundanten Szenarien einen Overhead verursachen.  Dementsprechend k√∂nnen Sie beispielsweise Ihre eigene effektive thread-sichere Sammlung f√ºr einen bestimmten Fall schreiben. <br><br>  Unter der Zwischensequenz befindet sich ein Video und eine Abschrift meines Berichts von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNext-</a> Konferenz, in der ich einige Beispiele analysiere, wenn Tools aus der Standard-.NET-Bibliothek (Task.Delay, SemaphoreSlim, ConcurrentDictionary) zu Leistungseinbu√üen f√ºhren, und ich schlage L√∂sungen vor, die auf bestimmte Aufgaben zugeschnitten sind und keine haben diese M√§ngel. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-tNeYjRNJtY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Zum Zeitpunkt des Berichts arbeitete er in Kontur.  Kontur entwickelt verschiedene Anwendungen f√ºr Unternehmen. Das Team, in dem ich gearbeitet habe, befasst sich mit der Infrastruktur und entwickelt verschiedene Support-Services und Bibliotheken, die Entwicklern in anderen Teams bei der Erstellung von Produkt-Services helfen. <br><br>  Das Infrastructure-Team baut sein Data Warehouse, ein Anwendungshosting-System f√ºr Windows und verschiedene Bibliotheken f√ºr die Entwicklung von Microservices auf.  Unsere Anwendungen basieren auf einer Microservice-Architektur - alle Services interagieren √ºber das Netzwerk miteinander und verwenden nat√ºrlich ziemlich viel asynchronen Code und Multithread-Code.  Einige dieser Anwendungen sind sehr leistungskritisch und m√ºssen in der Lage sein, viele Anforderungen zu verarbeiten. <br><br>  Wor√ºber werden wir heute sprechen? <br><br><ul><li>  Multithreading und Asynchronit√§t in .NET; </li><li>  F√ºllen von Synchronisationsprimitiven und Sammlungen; </li><li>  Was tun, wenn Standardans√§tze die Last nicht bew√§ltigen k√∂nnen? </li></ul><br>  Lassen Sie uns einige Funktionen der Arbeit mit Multithread- und asynchronem Code in .NET analysieren.  Schauen wir uns einige Synchronisationsprimitive und gleichzeitige Sammlungen an und sehen, wie sie im Inneren angeordnet sind.  Wir werden diskutieren, was zu tun ist, wenn nicht gen√ºgend Leistung vorhanden ist, wenn die Standardklassen die Last nicht bew√§ltigen k√∂nnen und ob in dieser Situation etwas getan werden kann. <br><br>  Ich werde Ihnen vier Geschichten erz√§hlen, die an unserem Produktionsstandort passiert sind. <br><br><h2>  Verlauf 1: Task.Delay &amp; TimerQueue </h2><br>  Diese Geschichte ist bereits ziemlich bekannt, auch bei DotNext.  Es hat jedoch eine ziemlich interessante Fortsetzung bekommen, also habe ich sie hinzugef√ºgt.  Worum geht es also? <br><br><h3>  1.1 Polling und Long Polling </h3><br>  Der Server f√ºhrt lange Operationen aus, der Client wartet auf sie. <br>  <b>Abfrage: Der</b> Client fragt den Server regelm√§√üig nach dem Ergebnis. <br>  <b>Lange Abfrage: Der</b> Client sendet eine Anforderung mit einer langen Zeit√ºberschreitung, und der Server antwortet, wenn der Vorgang abgeschlossen ist. <br><br>  Vorteile: <br><br><ul><li>  Weniger Verkehr </li><li>  Der Kunde erf√§hrt schneller von dem Ergebnis </li></ul><br>  Stellen Sie sich vor, wir haben einen Server, der einige lange Anforderungen verarbeiten kann, z. B. eine Anwendung, die XML-Dateien in PDF konvertiert, und es gibt Clients, die diese Aufgaben zur Verarbeitung ausf√ºhren und asynchron auf ihr Ergebnis warten m√∂chten.  Wie kann eine solche Erwartung verwirklicht werden? <br><br>  Der erste Weg ist das <b>Abrufen</b> .  Der Client startet die Aufgabe auf dem Server und √ºberpr√ºft dann regelm√§√üig den Status dieser Aufgabe, w√§hrend der Server den Status der Aufgabe zur√ºckgibt ("abgeschlossen" / "fehlgeschlagen" / "mit einem Fehler abgeschlossen").  Der Client sendet regelm√§√üig Anforderungen, bis das Ergebnis angezeigt wird. <br><br>  Der zweite Weg ist <b>langes Polling</b> .  Der Unterschied besteht darin, dass der Client Anforderungen mit langen Zeit√ºberschreitungen sendet.  Der Server, der eine solche Anfrage erh√§lt, meldet nicht sofort, dass die Aufgabe nicht abgeschlossen wurde, sondern versucht eine Weile zu warten, bis das Ergebnis angezeigt wird. <br>  Was ist der Vorteil einer langen Abfrage gegen√ºber einer regul√§ren Abfrage?  Erstens wird weniger Verkehr erzeugt.  Wir stellen weniger Netzwerkanforderungen - weniger Verkehr wird √ºber das Netzwerk gejagt.  Au√üerdem kann der Client das Ergebnis schneller als bei regul√§ren Abfragen ermitteln, da er nicht auf das Intervall zwischen mehreren Abfrageanforderungen warten muss.  Was wir bekommen wollen, ist verst√§ndlich.  Wie werden wir dies in Code implementieren? <br><blockquote>  Aufgabe: Zeit√ºberschreitung <br>  Wir m√∂chten mit einer Zeit√ºberschreitung auf Task warten <br>  warte auf SendAsync (); </blockquote>  Zum Beispiel haben wir eine Aufgabe, die eine Anfrage an den Server sendet, und wir m√∂chten mit einem Timeout auf das Ergebnis warten. Das hei√üt, wir geben entweder das Ergebnis dieser Aufgabe zur√ºck oder senden eine Art Fehler.  Der C # -Code sieht folgenderma√üen aus: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sendTask = SendAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayTask = Task.Delay(timeout); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(sendTask, delayTask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task == delayTask) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Timeout;</code> </pre> <br>  Dieser Code startet unsere Task, deren Ergebnis wir warten m√∂chten, und Task.Delay.  Als n√§chstes warten wir mit Task.WhenAny entweder auf unsere Task oder auf Task.Delay.  Wenn sich herausstellt, dass Task.Delay zuerst ausgef√ºhrt wird, die Zeit abgelaufen ist und wir eine Zeit√ºberschreitung haben, m√ºssen wir einen Fehler zur√ºckgeben. <br><br>  Dieser Code ist nat√ºrlich nicht perfekt und kann verbessert werden.  Zum Beispiel w√ºrde es nicht schaden, Task.Delay abzubrechen, wenn SendAsync fr√ºher zur√ºckkehrt, aber das ist f√ºr uns jetzt nicht sehr interessant.  Das Fazit ist, dass wir einige Leistungsprobleme bekommen, wenn wir einen solchen Code schreiben und ihn f√ºr lange Abfragen mit langen Zeit√ºberschreitungen anwenden. <br><br><h3>  1.2 Probleme mit langen Abfragen </h3><br><ul><li>  Gro√üe Auszeiten </li><li>  Viele gleichzeitige Abfragen </li><li>  =&gt; Hohe CPU-Auslastung </li></ul><br>  In diesem Fall ist das Problem der hohe Verbrauch an Prozessorressourcen.  Es kann vorkommen, dass der Prozessor zu 100% voll ausgelastet ist und die Anwendung im Allgemeinen nicht mehr funktioniert.  Es scheint, dass wir √ºberhaupt keine Prozessorressourcen verbrauchen: Wir f√ºhren einige asynchrone Vorg√§nge durch, warten auf eine Antwort vom Server, und der Prozessor ist immer noch mit uns geladen. <br><br>  In dieser Situation haben wir einen Speicherauszug aus unserer Anwendung entfernt: <br><br><pre> <code class="cs hljs"> ~*e!clrstack System.Threading.Monitor.Enter(System.Object) System.Threading.TimerQueueTimer.Change(‚Ä¶) System.Threading.Timer.TimerSetup(‚Ä¶) System.Threading.Timer..ctor(‚Ä¶) System.Threading.Tasks.Task.Delay(‚Ä¶)</code> </pre> <br>  Um den Dump zu analysieren, haben wir das WinDbg-Tool verwendet.  Wir haben einen Befehl eingegeben, der Stapelspuren aller verwalteten Threads anzeigt, und ein solches Ergebnis gesehen.  Wir haben viele Threads in Bearbeitung, die auf eine Sperre warten.  Die Monitor.Enter-Methode ist das, in das das Sperrkonstrukt in C # erweitert wird.  Diese Sperre wird in Klassen namens Timer und TimerQueueTimer erfasst.  In Timer kamen wir von Task.Delay, als wir versuchten, sie zu erstellen.  Was ist das  Wenn Task.Delay gestartet wird, wird die Sperre in der TimerQueue erfasst. <br><br><h3>  1.3 Konvoi sperren </h3><br><ul><li>  Viele Threads versuchen, eine Sperre zu sperren </li><li>  Unter der Sperre wird wenig Code ausgef√ºhrt </li><li>  Die Zeit wird f√ºr die Thread-Synchronisation und nicht f√ºr die Codeausf√ºhrung aufgewendet. </li><li>  Threadblocks sind blockiert - sie sind nicht unendlich </li></ul><br>  Wir hatten einen Schlosskonvoi in der Anwendung.  Viele Threads versuchen, dieselbe Sperre zu erfassen.  Unter dieser Sperre wird ziemlich viel Code ausgef√ºhrt.  Prozessorressourcen werden hier nicht f√ºr den Anwendungscode selbst ausgegeben, sondern f√ºr Vorg√§nge zum Synchronisieren von Threads untereinander f√ºr diese Sperre.  Beachten Sie auch eine Funktion in Bezug auf .NET: Die Threads, die am Lock Convoi teilnehmen, sind Threads aus dem Thread-Pool. <br><br>  Wenn Threads aus dem Thread-Pool blockiert werden, k√∂nnen sie dementsprechend enden - die Anzahl der Threads im Thread-Pool ist begrenzt.  Es kann konfiguriert werden, es gibt jedoch noch eine Obergrenze.  Sobald es erreicht ist, nehmen alle Threadpool-Threads am Sperrkonvoi teil, und jeglicher Code, der den Threadpool betrifft, wird nicht mehr in der Anwendung ausgef√ºhrt.  Dies verschlechtert die Situation erheblich. <br><br><h3>  1.4 TimerQueue </h3><br><ul><li>  Verwaltet Timer in einer .NET-Anwendung. </li><li>  Timer werden verwendet in: <br>  - Task.Delay <br>  - CancellationTocken.CancelAfter <br>  - HttpClient </li></ul><br>  TimerQueue ist eine Klasse, die alle Timer in einer .NET-Anwendung verwaltet.  Wenn Sie einmal in WinForms programmiert haben, haben Sie m√∂glicherweise Timer manuell erstellt.  F√ºr diejenigen, die nicht wissen, was Timer sind: Sie werden in Task.Delay verwendet (dies ist nur unser Fall), sie werden auch im CancellationToken in der CancelAfter-Methode verwendet.  Das Ersetzen von Task.Delay durch CancellationToken.CancelAfter w√ºrde uns in keiner Weise helfen.  Dar√ºber hinaus werden Timer in vielen internen .NET-Klassen verwendet, z. B. in HttpClient. <br><br>  Soweit ich wei√ü, haben einige Implementierungen von HttpClient-Handlern Timer.  Auch wenn Sie sie nicht explizit verwenden, starten Sie Task.Delay nicht. Wahrscheinlich verwenden Sie sie trotzdem. <br><br>  Schauen wir uns nun an, wie TimerQueue im Inneren angeordnet ist. <br><br><ul><li>  Globaler Status (pro Appdomain): <br>  - Doppelt verkn√ºpfte Liste von TimerQueueTimer <br>  - Objekt sperren </li><li>  Routine-Timer-R√ºckrufe </li><li>  Timer nicht nach Antwortzeit sortiert </li><li>  Hinzuf√ºgen eines Timers: O (1) + Sperre </li><li>  Timer entfernen: O (1) + Sperre </li><li>  Timer starten: O (N) + Sperre </li></ul><br>  In TimerQueue gibt es einen globalen Status. Es handelt sich um eine doppelt verkn√ºpfte Liste von Objekten vom Typ TimerQueueTimer.  TimerQueueTimer enth√§lt einen Link zu anderen TimerQueueTimer, zu Nachbarn in einer verkn√ºpften Liste sowie den Timer und die R√ºckrufzeit, die beim Ausl√∂sen des Timers aufgerufen werden.  Diese doppelt verkn√ºpfte Liste ist durch ein Sperrobjekt gesch√ºtzt, genau das, auf dem der Sperrkonvoi in unserer Anwendung stattgefunden hat.  Ebenfalls in TimerQueue gibt es eine Routine, die R√ºckrufe startet, die an unsere Timer gebunden sind. <br><br>  Timer sind in keiner Weise nach Antwortzeit geordnet, die gesamte Struktur ist f√ºr das Hinzuf√ºgen / Entfernen neuer Timer optimiert.  Wenn die Routine gestartet wird, durchl√§uft sie die gesamte doppelt verkn√ºpfte Liste, w√§hlt die Timer aus, die funktionieren sollen, und ruft sie zur√ºck. <br><br>  Die Komplexit√§t der Operation ist hier so.  Das Hinzuf√ºgen und Entfernen eines Timers erfolgt O pro Einheit, und der Start der Timer erfolgt pro Zeile.  Wenn mit der algorithmischen Komplexit√§t alles akzeptabel ist, gibt es au√üerdem ein Problem: Alle diese Operationen erfassen die Sperre, was nicht sehr gut ist. <br><br>  Welche Situation kann passieren?  In TimerQueue sind zu viele Timer angesammelt. Wenn die Routine gestartet wird, wird die lange lineare Operation gesperrt. Zu diesem Zeitpunkt k√∂nnen diejenigen, die versuchen, Timer aus TimerQueue zu starten oder zu entfernen, nichts dagegen tun.  Aus diesem Grund tritt ein Schleusenkonvoi auf.  Dieses Problem wurde in .NET Core behoben. <br><blockquote>  Reduzieren Sie Timer-Sperrenkonflikte (coreclr # 14527) <br><ul><li>  Scherben sperren <br>  - TimerQueueTimer von Environment.ProcessorCount TimerQueue </li><li>  Separate Warteschlangen f√ºr kurz- / langlebige Timer </li><li>  Kurzer Timer: Zeit &lt;= 1/3 Sekunde </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/dotnet/coreclr/issues/14462</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/dotnet/coreclr/pull/14527</a> <br></blockquote>  Wie wurde es behoben?  Sie haben TimerQueue durchsucht: Anstelle einer TimerQueue, die f√ºr die gesamte AppDomain statisch war, wurden f√ºr die gesamte Anwendung mehrere TimerQueue erstellt.  Wenn Threads dort ankommen und versuchen, ihre Timer zu starten, fallen diese Timer in eine zuf√§llige TimerQueue, und die Threads haben weniger Chancen, auf einer Sperre zusammenzusto√üen. <br><br>  Auch in .NET Core wurden einige Optimierungen angewendet.  Timer wurden in langlebige und kurzlebige unterteilt. F√ºr sie werden jetzt separate TimerQueue verwendet.  Der kurzlebige Timer wird auf weniger als 1/3 Sekunde eingestellt.  Ich wei√ü nicht, warum eine solche Konstante gew√§hlt wurde.  In .NET Core konnten wir keine Probleme mit Timern feststellen. <br><br><img src="https://habrastorage.org/webt/f_/am/cv/f_amcv6bohiq54ciyuunvtrr0ei.jpeg"><br><br>  <a href="">https://github.com/Microsoft/dotnet-framework-early-access/blob/master/release-notes/NET48/dotnet-48-changes.md</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/dotnet/coreclr/labels/netfx-port-consider</a> <br><br>  Dieser Fix wurde auf .NET Framework, Version 4.8, zur√ºckportiert.  Das netfx-port-Consider-Tag ist im obigen Link angegeben. Wenn Sie zum .NET Core-, CoreCLR- und CoreFX-Repository wechseln, k√∂nnen Sie nach diesem Problem suchen, das in das .NET Framework zur√ºckportiert wird. Es gibt jetzt ungef√§hr f√ºnfzig davon.  Das hei√üt, das Open Source .NET hat sehr geholfen, einige Fehler wurden behoben.  Sie k√∂nnen Changelog .NET Framework 4.8 lesen: Viele Fehler wurden behoben, viel mehr als in anderen .NET-Versionen.  Interessanterweise ist dieses Update in .NET Framework 4.8 standardm√§√üig deaktiviert.  Es ist in der gesamten Ihnen bekannten Datei namens App.config enthalten <br><br>  Die Einstellung in App.config, die diesen Fix aktiviert, hei√üt UseNetCoreTimer.  Bevor .NET Framework 4.8 herauskam, mussten Sie Ihre Implementierung von Task.Delay verwenden, damit unsere Anwendung funktioniert und nicht in den Sperrkonvoi wechselt.  Darin haben wir versucht, einen bin√§ren Heap zu verwenden, um effizienter zu verstehen, welche Timer jetzt aufgerufen werden sollten. <br><br><h3>  1.5 Task.Delay: native Implementierung </h3><br><ul><li>  Bin√§rhaufen </li><li>  Scherben </li><li>  Es hat geholfen, aber nicht in allen F√§llen </li></ul><br>  Durch die Verwendung eines bin√§ren Heaps k√∂nnen Sie die Routine optimieren, die R√ºckrufe aufruft, aber die Zeit verk√ºrzt, die zum Entfernen eines beliebigen Timers aus der Warteschlange erforderlich ist. Dazu m√ºssen Sie den Heap neu erstellen.  Dies ist h√∂chstwahrscheinlich der Grund, warum .NET eine doppelt verkn√ºpfte Liste verwendet.  Nat√ºrlich w√ºrde es uns hier nicht helfen, nur einen bin√§ren Heap zu verwenden. Wir mussten auch TimerQueue ausarbeiten.  Diese L√∂sung funktionierte einige Zeit, aber trotzdem fiel alles wieder in einen Sperrkonvoi, da Timer nicht nur dort verwendet werden, wo sie explizit im Code gestartet werden, sondern auch in Bibliotheken von Drittanbietern und im .NET-Code.  Um dieses Problem vollst√§ndig zu beheben, m√ºssen Sie ein Upgrade auf .NET Framework Version 4.8 durchf√ºhren und das Update von .NET-Entwicklern aktivieren. <br><br><h3>  1.6 Task.Delay: Schlussfolgerungen </h3><br><ul><li>  √úberall Fallstricke - auch bei den am h√§ufigsten verwendeten Dingen </li><li>  Stresstests durchf√ºhren </li><li>  Wechseln Sie zu Core, holen Sie sich zuerst Fehlerbehebungen (und neue Fehler) :) </li></ul><br>  Was sind die Schlussfolgerungen aus dieser ganzen Geschichte?  Erstens k√∂nnen die Fallstricke wirklich √ºberall lokalisiert werden, selbst in den Klassen, die Sie jeden Tag verwenden, ohne beispielsweise an dieselbe Aufgabe, Task.Delay, zu denken. <br><br>  Ich empfehle, Stresstests Ihrer Vorschl√§ge durchzuf√ºhren.  Dieses Problem haben wir gerade in der Phase des Lasttests festgestellt.  Wir haben es dann mehrmals in der Produktion in anderen Anwendungen gedreht, aber Stresstests haben uns trotzdem geholfen, die Zeit zu verz√∂gern, bevor wir auf dieses Problem in der Realit√§t gesto√üen sind. <br><br>  Wechseln Sie zu .NET Core - Sie erhalten als Erster Fehlerbehebungen (und neue Fehler).  Wo ohne neue Bugs? <br><br>  Die Geschichte √ºber die Timer ist vorbei und wir fahren mit dem n√§chsten fort. <br><br><h2>  Geschichte 2: SemaphoreSlim </h2><br>  Die folgende Geschichte handelt von dem bekannten SemaphoreSlim. <br><br><h3>  2.1 Serverdrosselung </h3><br><ul><li>  Es ist erforderlich, die Anzahl der gleichzeitig verarbeiteten Anforderungen auf dem Server zu begrenzen </li></ul><br>  Wir wollten die Drosselung auf dem Server implementieren.  Was ist das?  Sie alle kennen wahrscheinlich die Drosselung der CPU: Wenn der Prozessor √ºberhitzt, senkt er seine Frequenz, um sich abzuk√ºhlen, und dies schr√§nkt seine Leistung ein.  So ist es hier.  Wir wissen, dass unser Server N Anfragen parallel verarbeiten kann und nicht fallen kann.  Was wollen wir machen  Begrenzen Sie die Anzahl der gleichzeitig verarbeiteten Anforderungen auf diese Konstante und stellen Sie sie so ein, dass, wenn weitere Anforderungen eingehen, diese in die Warteschlange gestellt werden und warten, bis die zuvor eingegangenen Anforderungen ausgef√ºhrt werden.  Wie kann dieses Problem gel√∂st werden?  Es ist notwendig, eine Art Synchronisationsprimitiv zu verwenden. <br><br>  Semaphore ist ein Synchronisationsprimitiv, auf das Sie N-mal warten k√∂nnen. Danach wartet derjenige, der zuerst N + usw. ankommt, darauf, bis diejenigen, die es fr√ºher eingegeben haben, Semaphore freigeben.  Es stellt sich ungef√§hr so ‚Äã‚Äãheraus: Zwei Hinrichtungsf√§den, zwei Arbeiter gingen unter Semaphore, der Rest stand in der Schlange. <br><br><img src="https://habrastorage.org/webt/6s/bu/h7/6sbuh77p4temzi5yiofjlh-rxoi.png"><br><br>  Nat√ºrlich ist Semaphore f√ºr uns nicht sehr geeignet, es ist in .NET synchron, also haben wir SemaphoreSlim genommen und diesen Code geschrieben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(N); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> semaphore.WaitAsync(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> HandleRequestAsync(request); semaphore.Release();</code> </pre> <br>  Wir erstellen SemaphoreSlim, warten Sie, unter Semaphore bearbeiten wir Ihre Anfrage, danach ver√∂ffentlichen wir Semaphore.  Es scheint, dass dies eine ideale Implementierung der Server-Drosselung ist und nicht mehr besser sein kann.  Aber alles ist viel komplizierter. <br><br><h3>  2.2 Serverdrosselung: Komplikation </h3><br><ul><li>  Anfragen in LIFO-Reihenfolge bearbeiten </li><li>  SemaphoreSlim </li><li>  Concurrentstack </li><li>  TaskCompletionSource </li></ul><br>  Wir haben die Gesch√§ftslogik ein wenig vergessen.  Die Anforderungen, die zur Drosselung kommen, sind echte http-Anforderungen.  In der Regel haben sie eine Zeit√ºberschreitung, die von denjenigen festgelegt wird, die diese Anforderung automatisch gesendet haben, oder eine Zeit√ºberschreitung des Benutzers, der nach einiger Zeit F5 dr√ºckt.  Wenn Sie also Anforderungen in einer Warteschlangenreihenfolge wie ein regul√§res Semaphor verarbeiten, werden m√∂glicherweise zuerst die Anforderungen aus der Warteschlange verarbeitet, f√ºr die eine Zeit√ºberschreitung aufgetreten ist.  Wenn Sie in Stapelreihenfolge arbeiten und zuerst die zuletzt verarbeiteten Anforderungen verarbeiten, tritt ein solches Problem nicht auf. <br><br>  Zus√§tzlich zu SemaphoreSlim mussten wir ConcurrentStack, TaskCompletionSource, verwenden, um viel Code um all dies zu wickeln, damit alles in der von uns ben√∂tigten Reihenfolge funktionierte.  TaskCompletionSource ist so etwas wie CancellationTokenSource, jedoch nicht f√ºr CancellationToken, sondern f√ºr Task.  Sie k√∂nnen eine TaskCompletionSource erstellen, eine Aufgabe daraus ziehen, sie ausgeben und dann TaskCompletionSource mitteilen, dass Sie das Ergebnis f√ºr diese Aufgabe festlegen m√ºssen. Diejenigen, die auf diese Aufgabe warten, werden von diesem Ergebnis erfahren. <br><br>  Wir haben es alle umgesetzt.  Der Code ist schrecklich.  und am schlimmsten war, dass es nicht funktionierte. <br><br>  Einige Monate nach dem Start der Verwendung in einer ziemlich stark ausgelasteten Anwendung ist ein Problem aufgetreten.  Auf die gleiche Weise wie im vorherigen Fall ist der CPU-Verbrauch auf 100% gestiegen.  Wir haben das Gleiche getan, den Dump entfernt, ihn in WinDbg angeschaut und wieder den Schleusenkonvoi gefunden. <br><br><img src="https://habrastorage.org/webt/h_/ef/as/h_efasuul34r0fm7vwopo2hm1bc.jpeg"><br><br>  Diesmal fand der Lock-Konvoi in SemaphoreSlim.WaitAsync und SemaphoreSlim.Release statt.  Es stellte sich heraus, dass es in SemaphoreSlim eine Sperre gibt, die nicht sperrenfrei ist.  Dies stellte sich f√ºr uns als ziemlich schwerwiegender Nachteil heraus. <br><br><img src="https://habrastorage.org/webt/0h/-k/qq/0h-kqqxojlujm3dglokmacabvwq.jpeg"><br><br>  In SemaphoreSlim gibt es einen internen Zustand (ein Z√§hler daf√ºr, wie viele Arbeiter noch darunter gehen k√∂nnen) und eine doppelt verkn√ºpfte Liste derer, die auf dieses Semaphor warten.  Die Ideen hier sind ungef√§hr gleich: Sie k√∂nnen an diesem Semaphor warten, Sie k√∂nnen Ihre Erwartung stornieren - diese Warteschlange zu verlassen.  Es gibt ein Schloss, das unser Leben ruiniert hat. <br><br>  Wir entschieden uns: runter mit all dem schrecklichen Code, den wir schreiben mussten. <br><br><img src="https://habrastorage.org/webt/ax/ls/3i/axls3iseuxmgjt-vqkeiqs7hvtq.jpeg"><br><br>  Schreiben wir unser Semaphor, das sofort sperrfrei ist und sofort in Stapelreihenfolge funktioniert.  Das Warten abzubrechen ist uns nicht wichtig. <br><br><img src="https://habrastorage.org/webt/rv/rg/wv/rvrgwv8apebibtiymhxpvm5giti.jpeg"><br><br>  Definieren Sie diese Bedingung.  Hier ist die Nummer currentCount - so viele Pl√§tze sind noch im Semaphor √ºbrig.  Wenn in Semaphore keine Pl√§tze mehr vorhanden sind, ist diese Zahl negativ und zeigt an, wie viele Mitarbeiter sich in der Warteschlange befinden.  Es wird auch einen ConcurrentStack geben, der aus TaskCompletionSource'ov besteht - dies ist nur ein Stapel Kellner'ov, aus dem sie bei Bedarf gezogen werden.  Schreiben wir die WaitAsync-Methode. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> decrementedCount = Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decrementedCount &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.CompletedTask; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(); waiters.Push(waiter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waiter.Task;</code> </pre> <br>  Zuerst verringern wir den Z√§hler, nehmen einen Platz f√ºr uns im Semaphor ein, wenn wir freie Pl√§tze hatten, und dann sagen wir: ‚ÄûDas war's, du bist unter das Semaphor gegangen‚Äú. <br><br>  Wenn es in Semaphore keine Stellen gab, erstellen wir eine TaskCompletionSource, werfen sie auf den Stapel von waiter'ov und geben Task an die Au√üenwelt zur√ºck.  Wenn die Zeit gekommen ist, wird diese Aufgabe funktionieren, und der Arbeiter kann seine Arbeit fortsetzen und wird unter Semaphor gehen. <br><br>  Schreiben wir nun die Release-Methode. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waiters.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter)) waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Die Freigabemethode lautet wie folgt: <br><br><ul><li>  Freier Platz im Semaphor </li><li>  Inkrementiere currentCount </li></ul><br>  Wenn wir anhand von currentCount erkennen k√∂nnen, ob sich im Stapel ein Kellner befindet, √ºber den wir signalisieren m√ºssen, ziehen wir diesen Kellner aus dem Stapel und signalisieren.  Hier ist der Kellner eine TaskCompletionSource.  Frage zu diesem Code: Es scheint logisch zu sein, aber funktioniert es √ºberhaupt?  Welche Probleme gibt es?  Es gibt eine Nuance in Bezug darauf, wo Continuation'y und TaskCompletionSource'y gestartet werden. <br><br><img src="https://habrastorage.org/webt/_1/zo/hu/_1zohu07rqeiemrkwrcubv7gwhe.png"><br><br>  Betrachten Sie diesen Code.  Wir haben eine TaskCompletionSource erstellt und zwei Tasks gestartet.  Die erste Aufgabe zeigt eine Einheit an, setzt das Ergebnis auf eine TaskCompletionSource und zeigt dann eine Zwei auf der Konsole an.  Die zweite Task wartet auf diese TaskCompletionSource, auf ihre Task und blockiert dann f√ºr immer ihren Thread aus dem Thread-Pool. <br><br>  Was wird hier passieren?  Aufgabe 2 bei der Kompilierung wird in zwei Methoden unterteilt, von denen die zweite eine Fortsetzung ist, die Thread.Sleep enth√§lt.  Nach dem Festlegen des Ergebnisses der TaskCompletionSource wird diese Fortsetzung in demselben Thread ausgef√ºhrt, in dem die erste Task ausgef√ºhrt wurde.  Dementsprechend wird der Fluss der ersten Aufgabe f√ºr immer blockiert und die Zwei zur Konsole werden nicht mehr gedruckt. <br><br>  Interessanterweise habe ich versucht, diesen Code zu √§ndern, und wenn ich die Ausgabe an die Konsoleneinheit entfernt habe, wurde die Fortsetzung f√ºr einen anderen Thread aus dem Thread-Pool gestartet und die Zwei gedruckt.  In welchen F√§llen wird die Fortsetzung im selben Thread ausgef√ºhrt und in welchen - zum Thread-Pool gelangen - eine Frage an die Leser. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;( TaskCreationOptions.RunContinuationsAsynchronously); <span class="hljs-comment"><span class="hljs-comment">/* OR */</span></span> Task.Run(() =&gt; tcs.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>));</code> </pre> <br>  Um dieses Problem zu l√∂sen, k√∂nnen wir entweder eine TaskCompletionSource mit dem entsprechenden RunContinuationsAsynchronously-Flag erstellen oder die TrySetResult-Methode in Task.Run/ThreadPool.QueueUserWorkItem aufrufen, damit sie nicht in unserem Thread ausgef√ºhrt wird.  Wenn es in unserem Thread ausgef√ºhrt wird, k√∂nnen unerw√ºnschte Nebenwirkungen auftreten.  Dar√ºber hinaus gibt es ein zweites Problem, auf das wir noch n√§her eingehen werden. <br><br><img src="https://habrastorage.org/webt/m9/x8/gx/m9x8gxz7x5tw3mjcps7nygdmkjs.jpeg"><br><br>  Schauen Sie sich die WaitAsync- und Release-Methoden an und versuchen Sie, ein anderes Problem in der Release-Methode zu finden. <br><br>  H√∂chstwahrscheinlich ist es so einfach unm√∂glich, sie zu finden.  Hier gibt es ein Rennen. <br><br><img src="https://habrastorage.org/webt/cs/1e/4q/cs1e4q3yaz4d3084_24z2ucsd6y.jpeg"><br><br>  Dies liegt an der Tatsache, dass bei der WaitAsync-Methode die Status√§nderung nicht atomar ist.  Zuerst dekrementieren wir den Z√§hler und schieben erst dann den Kellner auf den Stapel.  Wenn es so kommt, dass Release zwischen Dekrement und Push ausgef√ºhrt wird, wird es m√∂glicherweise beendet, damit nichts aus dem Stapel gezogen wird.  Dies muss ber√ºcksichtigt werden, und warten Sie bei der Freigabemethode, bis der Kellner auf dem Stapel angezeigt wird. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Waiter waiter; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spinner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!waiter.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> waiter)) spinner.SpinOnce(); waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Hier machen wir es in einer Schleife, bis wir es schaffen, es herauszuziehen.  Um Prozessorzyklen nicht noch einmal zu verschwenden, verwenden wir SpinWait. <br><br>  In den ersten Iterationen dreht es sich in einer Schleife.  Wenn es viele Iterationen gibt, wird der Kellner lange Zeit nicht angezeigt, und unser Thread wechselt zu Thread.Sleep, um keine CPU-Ressourcen erneut zu verschwenden. <br><br>  Tats√§chlich ist das Semaphor der LIFO-Ordnung nicht nur unsere Idee. <br><blockquote>  <b>LowLevelLifoSemaphore</b> <br><ul><li>  Synchron </li><li>  Unter Windows wird der E / A-Abschlussport als Windows-Stapel verwendet </li></ul><br>  <a href="">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Threading/LowLevelLifoSemaphore.cs</a> </blockquote>  Es gibt ein solches Semaphor in .NET selbst, aber nicht in CoreCLR, nicht in CoreFX, sondern in CoreRT.  Es ist manchmal sehr n√ºtzlich, einen Blick in das .NET-Repository zu werfen.  Es gibt ein Semaphor namens LowLevelLifoSemaphore.  Dieses Semaphor w√ºrde uns sowieso nicht passen: Es ist synchron. <br><br>  Bemerkenswerterweise funktioniert es unter Windows √ºber IO Completion-Ports.  Sie haben die Eigenschaft, dass Threads auf sie warten k√∂nnen, und diese Threads werden nur in der LIFO-Reihenfolge freigegeben.  Diese Funktion wird dort verwendet, es ist wirklich LowLevel. <br><br><h3>  2.3 Schlussfolgerungen: </h3><br><ul><li>  Hoffen Sie nicht, dass die F√ºllung des Frameworks unter Ihrer Last √ºberlebt </li><li>  Es ist einfacher, ein bestimmtes Problem zu l√∂sen als im allgemeinen Fall. </li><li>  Stresstests helfen nicht immer </li><li>  Vorsicht vor Blockierung </li></ul><br>  Was sind die Schlussfolgerungen aus dieser ganzen Geschichte?  Hoffen Sie zun√§chst nicht, dass einige Klassen aus dem Framework, das Sie aus der Standardbibliothek verwenden, mit Ihrer Last fertig werden.  Ich m√∂chte nicht sagen, dass SemaphoreSlim schlecht ist, es hat sich gerade in diesem Szenario als ungeeignet herausgestellt. <br><br>  Es stellte sich heraus, dass es f√ºr uns viel einfacher war, unser Semaphor f√ºr eine bestimmte Aufgabe zu schreiben.  Beispielsweise wird das Abbrechen des Wartens nicht unterst√ºtzt.  Diese Funktion ist im √ºblichen SemaphoreSlim verf√ºgbar, wir haben sie nicht, aber dies erm√∂glichte es uns, den Code zu vereinfachen. <br><br>  Lasttests helfen zwar, helfen aber m√∂glicherweise nicht immer. <br><br> .NET  ,           ‚Äî   .        lock,  : ¬´    ?¬ª     CPU 100%,     lock', , ,   -  .NET.      . <br><br>    . <br><br><h2>  3: (A)sync IO </h2><br>    /,      . <br><br><img src="https://habrastorage.org/webt/84/qh/sz/84qhsz9je7twmgbswt5so0dfx2q.jpeg"><br><br>    lock convoy,    stack trace     Overlapped  PinnableBufferCache.   lock.     : Overlapped  PinnableBufferCache? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OVERLAPPED</a> ‚Äî    Windows,      /.      ,        .        ,  .       ,     lock convoy.   ,      lock convoy,    ,   . <br><br><img src="https://habrastorage.org/webt/if/j_/fc/ifj_fclqmvkfgfff7zedxpj63mo.jpeg"><br><br>  ,       ,   .NET 4.5.1  4.5.2.     .NET 4.5.2,     ,    .NET 4.5.2.  .NET 4.5.1     OverlappedDataCache,      Overlapped ‚Äî ,       ,   .    ,  lock-free,   ConcurrentStack,       .  .NET 4.5.2     :  OverlappedDataCache   PinnableBufferCache. <br><br>   ? PinnableBufferCache     ,   Overlapped     ,    ,       ‚Äî      . ,     ,      . PinnableBufferCache     .   , lock-free,   ConcurrentStack.     ,      .        ,        ,  -    lock-free    list  lock'. <br><br><h3> 3.1 PinnableBufferCache </h3><br> LockConvoy: <br><br><ul><li>    </li><li>      </li></ul><br>  lock convoy  ,   -     .        list      ,     lock   ,  ,                . <br><br>     PinnableBufferCache  ,         .    : <br><br><pre> <code class="plaintext hljs">PinnableBufferCache_System.ThreadingOverlappedData_MinCount</code> </pre> <br>      ,      .  : ¬´ !         -  ¬ª.         -: <br><br><pre> <code class="cs hljs">Environment.SetEnvironmentVariable( <span class="hljs-string"><span class="hljs-string">"PinnableBufferCache_System.Threading.OverlappedData_MinCount"</span></span>, <span class="hljs-string"><span class="hljs-string">"10000"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Overlapped().GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);</code> </pre> <br>    ?     ,    Overlapped  ,   ,        .     ,   ,     ,     ,  PinnableBufferCache      lock convoy'.    ,           . <br><br>  .NET Core  PinnableBufferCache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,   OverlappedData   . ,        , Garbage collector     ,      .     .NET Core  .  .NET Framework,   ,     . <br><br><h3> 3.2 : </h3><br><ul><li>      </li><li>      </li><li>   .NET Core </li></ul><br>      ,     .   ,   .NET            ,       . ,  ,  .NET Core. ,     ,         -. <br><br>    key-value . <br><br><h2>  4: Concurrent key-value collections </h2><br>  .NET   concurrent-.  lock-free  ConcurrentStack  ConcurrentQueu,       .   ConcurrentDictionary,    .   lock-free  ,   ,      .    ConcurrentDictionary? <br><br><h3> 4.1 ConcurrentDictionary </h3><br> : <br><br><ul><li>  Cache </li><li>  </li></ul><br>  Vorteile: <br><br><ul><li>     </li><li>   (TryAdd/TryUpdate/AddOrUpdate) </li><li> Lock-free  </li><li> Lock-free enumeration </li></ul><br>      , memory-,  ,        .    ,    ,    .NET Framework.            . ,  ,      (enumeration) lock-free. ,   . <br><br>  ,   ,   -  .NET.  key-value    -    : <br><br><img src="https://habrastorage.org/webt/ff/9f/g_/ff9fg_qzzuzvafep8c-p3seyigm.jpeg"><br><br>  -,     bucket'.      bucket',    .   ,    bucket   ,       . <br><br>    ‚Äî   ,  ConcurrentDictionary.  ConcurrentDictionary    ¬´-¬ª   .    ,      ,   ,       memory traffic.     ConcurrentDictionary,   lock'.   ‚Äî   . <br><br>    ,    Dictionary. <br><br><img src="https://habrastorage.org/webt/-_/dw/jo/-_dwjoxswmd1kecoi3aln8m7bow.jpeg"><br><br>  Dictionary  ,  Concurrent,      .     :  buckets,  entries.   buckets       bucket'   entries.   ¬´-¬ª    entries.          .      ¬´-¬ª   int,     bucket'. <br><br>   memory overhead,     ConcurrentDictionary   Dictionary. <br><br><img src="https://habrastorage.org/webt/em/aa/ch/emaachor-z_xxt7m_1wc7ntqupm.jpeg"><br><br>    Dictionary. Memory overhea'    ,       .    Dictionary  overhead  -    ,  int'.  8 . <br><br>    ConcurrentDictionary.  ConcurrentDictionary     ConcurrentDictionary.Node.   , .     int hashCode        .       ,    table (  16 ),  int hashCode     .      ,   64-    28  overhead'.       Dictionary. <br><br>  memory overhead', ConcurrentDictionary     GC   ,       .     Benchmark.   ConcurrentDictionary  ,       GC.Collect.    ? <br><br><img src="https://habrastorage.org/webt/on/yj/uq/onyjuq1rqgfkv8iav5x4z8nrnq8.jpeg"><br><br>     .       ConcurrentDictionary  10  ,        ,             ,      .   Dictionary   .      ,   ,  ,    .       . <br><br>     ,     ConcurrentDictionary? <br><br><h3> 4.2   </h3><br><ul><li>    </li><li> TTL </li><li> Dictionary+lock </li><li> Sharding </li></ul><br>     .      ConcurrentDictionary.        10  .   ,     .   TTL  ,    .        Dictionary  lock'. ,  ,  lock    .       Dictionary  lock'      ,   -     ,           lock.      ,     . <br><br><h3> 4.3  </h3><br><ul><li>   in-memory  &lt;Guid,Guid&gt; </li><li>   &gt;10 <sup>6</sup>  </li><li>       </li><li>   </li><li>        </li></ul><br>     .      ‚Äî      ,       in-memory   Guid'  Guid,     .       .     - - ,     .  ,            15    .   .     Semaphore     ConcurrentDictionary. <br><br><img src="https://habrastorage.org/webt/u4/kw/kt/u4kwkttmxwpyelqlqoqp9zxahaa.jpeg"><br><br> ,    lock-free    ,    overhead      GC.   ,          .      ,    ,       ,   .   ,     -  ,       ,    .  ,  ,      Large Object Heap.    ? <br><br>       ,     ,     Dictionary   . <br><br><img src="https://habrastorage.org/webt/kx/yn/oi/kxynoiatsy8zcyrc5dei-xohlk4.jpeg"><br><br>   Dictionary   bucket',  Entry.  Entry  , ,   ,   . <br><br><img src="https://habrastorage.org/webt/n8/7a/5r/n87a5rlkgdk62nw82qysi3fmi18.png"><br><br>  Dictionary   ,   ,      . ,     - . <br><br>      ,  -     ? -,  ,       ,     ,      .     .    Dictionary,     , buckets, entries,              Interlocked. ,         . <br><blockquote> <b>Dictionary</b> <br><ul><li>   ,    </li><li>     ,   ? <br> ‚Äî  Resize  buckets  entries   <br> ‚Äî      - <br> ‚Äî    Dictionary.Entry <br> ‚Äî   -   </li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://blogs.msdn.microsoft.com/tess/2009/12/21/high-cpu-in-net-app-using-a-static-generic-dictionary/</a> </blockquote>     ,       Dictionary       -  bucket'.       ,      .    ,     ,        .       ,       ,    . <br><br>      Entry  Dictionary.     - -    .  ,     . <br><br><img src="https://habrastorage.org/webt/4p/xb/aq/4pxbaqil2cd4jaxnayxjqz-5yae.jpeg"><br><br>    .NET Framework  1.1.     Hashtable,   Dictionary,    object'.     MSDN ,      .  ,             -.   .  ,  Hashtable  .  ,      . <br><br><h3> 4.4    Dictionary.Entry </h3><br><img src="https://habrastorage.org/webt/y2/ww/rs/y2wwrslyuqpioqcalmpnt8dh6cw.jpeg"><br>    ? Dictionary.Entry ,  ,  8 , ,  ,   ,     .  Wie kann man das machen? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; buckets[index] = ‚Ä¶; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version++; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>   :  (    ,    )  int-.   ,  .   ,     , ,  ,  . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version; bucket = bickets[index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing || version != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>    ,     ,         .       ,   .       ,  8 . <br><br><h3> 4.5   -   </h3><br>  ,   . <br><br><img src="https://habrastorage.org/webt/hh/bp/0l/hhbp0leb95qndz4bmg-2gtvmeue.jpeg"><br><br>  Dictionary     bucket    ,     . <br><br>  Dictionary,    .      : 0  2.   bucket, 1       2.   ?     0.   ,       ,    2.     .   ,  2,       , , 1. 1       2 ‚Äî     bucket.   ,      ,   .    1 ‚Äî ,     bucket.  Hashtable     ,     bucket'  -.        ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">double hashing</a> . <br><br><h3> 4.6   </h3><br><ul><li>     </li><li>      </li></ul><br> <b></b> <br><br><ul><li>        </li><li>    ,  resize </li></ul><br> <b></b> <br><br><ul><li>     ,      </li></ul><br>        .         ,       Buckets,     Entries (   Buckets,     Entries).   -  ,       ,   ,          ,    . <br><br>             .    ,    . <br><br>  :     ,      ,    ,     ,     . ,       ,   . <br><br><img src="https://habrastorage.org/webt/pm/lo/ah/pmloah0wlfbq7ilvlnrvbh3pyuu.png"><br><br>     ,   , ‚Äî  . <br><br>   ?   ,  -    2.   -   Capacity  ,            .    ‚Äî 2.       ,   .      2.    ?  ,  ,     ,   .    -  ,        ,       3. ,    ,  ,    ,  ,  . <br><br>  ,    Hashtable,  .   ,     double hashing.     ,       ,   ,     . <br><br>   ,      ,     ‚Äî   ,            .     Hashtable.   ,    ‚Äî     ‚Äî       .                 .  ,     bucket',       -  ,       .  . <br><br>     ,  ,   lock-free      LOH. <br><br><img src="https://habrastorage.org/webt/pg/2b/6b/pg2b6bbfkm_3nnkds27g2krziz8.jpeg"><br><br>   lock-free ?  MSDN    Hashtable ,      .    ,            ,            . <br><br><img src="https://habrastorage.org/webt/yu/sg/he/yusghe0crfu9ywaic0aozpr7wri.jpeg"><br><br>      ,     ,        ,   bucket'.         Dictionary  bucket',  -,   bucket'      .    -    bucket,  bucket  .      ,     . <br><br>  ,       Large Object Heap. <br><br><img src="https://habrastorage.org/webt/wf/po/8o/wfpo8ou1_fpzhdkgcdbjzw-7u9q.jpeg"><br><br>      .  CustomDictionary  CustomDictionarySegment    .   Dictionary,    ,      .   ‚Äî   Dictionary,      .       ,      Large Object Heap.        ,   bucket'   . ,      ,    ,   bucket,     - - . <br><br>           .       ConcurrentDictionary,     .NET,        ,      . <br><br><h3> 4.7  </h3><br><ul><li> .NET   </li><li>    </li><li>   </li><li> ,     </li><li>   </li><li>   </li></ul><br>     ? .NET  .   .   ,     ,       .    -   ‚Äî   - .   ,  , ,     . <br><br>  -   , ,   ,     ,   .   ,   ,   ,        , ,          .   ‚Äî   , ,   . <br><br><h3>  N√ºtzliche Links </h3><br><ul><li>   ConcurrentDictionary: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/ru/company/skbkontur/blog/348508/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/vostok/commons.threading</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/epeshk/dotnext-2019-threading</a> </li></ul><br>   ‚Äî          ConcurrentDictionary. ,      ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Diafilm</a> ),       . <br><br>      GitHub.   ‚Äî     ,    ,    LIFO-Semaphore,    .       ,    . <br><blockquote> 6-7     <b>DotNext 2019 Moscow</b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´.NET:  ¬ª</a>    ,        .NET Framework  .NET Core,  ,        . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468611/">https://habr.com/ru/post/de468611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468601/index.html">Sch√§tzung der Projektlaufzeit. Warum ist es fast immer sehr untertrieben und was tun?</a></li>
<li><a href="../de468603/index.html">Rutracker hat eSNI aufgenommen. Ende der DPI-√Ñra und Ende der Sperren</a></li>
<li><a href="../de468605/index.html">Konstante Zeiger auf Zeiger auf Zeiger ...</a></li>
<li><a href="../de468607/index.html">Android f√ºr den Funkingenieur (Teil zwei)</a></li>
<li><a href="../de468609/index.html">Die unverst√§ndliche Leistung der Mehrfachplanung</a></li>
<li><a href="../de468615/index.html">Die Top 10 Sprachen f√ºr die App-Lokalisierung</a></li>
<li><a href="../de468621/index.html">Wir √ºbersetzen das Heimnetzwerk in DoH oder einen weiteren Klick auf die Filternase</a></li>
<li><a href="../de468623/index.html">Ich m√∂chte Bewertungen zu Habr</a></li>
<li><a href="../de468625/index.html">Serverlos: 15% langsamer und achtmal teurer</a></li>
<li><a href="../de468627/index.html">ADAM-6200 E / A-Module</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>