<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòø üàµ ‚õÖÔ∏è Desbloqueo autom√°tico del contenedor LUKS ra√≠z despu√©s de un arranque en caliente üö£üèº üà≥ ü§∂üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øPor qu√© la gente generalmente encripta unidades de sus computadoras personales y, a veces, servidores? ¬°Est√° claro que nadie ha robado fotos de sus g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desbloqueo autom√°tico del contenedor LUKS ra√≠z despu√©s de un arranque en caliente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457396/"><p>  ¬øPor qu√© la gente generalmente encripta unidades de sus computadoras personales y, a veces, servidores?  ¬°Est√° claro que nadie ha robado fotos de sus gatos favoritos del disco!  Eso es solo mala suerte: una unidad encriptada requiere que ingrese una frase clave del teclado en cada arranque, y es larga y aburrida.  Eliminarlo para que al menos a veces no sea necesario reclutarlo.  S√≠, para que no se pierda el significado del cifrado. </p><br><div class="spoiler">  <b class="spoiler_title">Gato para llamar la atenci√≥n</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sr/rt/ny/srrtnywyggbrscsufm8ux8tvxmu.jpeg" alt="Gato"></p></div></div><br><p>  Bueno, eliminarlo por completo no funcionar√°.  En su lugar, puede crear un archivo de clave en una unidad flash USB, y tambi√©n funcionar√°.  Y sin una unidad flash (y sin una segunda computadora en la red) ¬øes posible?  Si tienes suerte con el BIOS, ¬°casi puedes!  Debajo del corte habr√° una gu√≠a sobre c√≥mo configurar el cifrado de disco a trav√©s de LUKS con las siguientes propiedades: </p><br><ol><li>  La frase de contrase√±a o el archivo de clave no se almacenan en ning√∫n lugar en forma abierta (o en la forma equivalente a abrir) cuando la computadora est√° apagada. </li><li> La primera vez que enciende su computadora, debe ingresar una frase de contrase√±a. </li><li>  En reinicios posteriores (antes de cerrar), no se requiere una frase de contrase√±a. </li></ol><br><p>  Las instrucciones se han probado en CentOS 7.6, Ubuntu 19.04 y openSUSE Leap 15.1 en m√°quinas virtuales y en hardware real (computadora de escritorio, computadora port√°til y dos servidores).  Deber√≠an trabajar en otras distribuciones que tengan una versi√≥n funcional de Dracut. </p><br><p>  Y s√≠, en el buen sentido, esto deber√≠a haber terminado en el centro de "administraci√≥n anormal del sistema", pero no existe dicho centro. </p><a name="habracut"></a><br><p>  Sugiero usar una ranura separada en el contenedor LUKS y almacenar la clave ... ¬°en la RAM! </p><br><div class="spoiler">  <b class="spoiler_title">¬øQu√© tipo de tragamonedas?</b> <div class="spoiler_text"><p> El contenedor LUKS implementa el cifrado multinivel.  Los datos √∫tiles en el disco se cifran con un cifrado sim√©trico, generalmente <code>aes-xts-plain64</code> .  La clave de este cifrado sim√©trico (clave maestra) se genera en la etapa de creaci√≥n del contenedor como una secuencia aleatoria de bytes.  La clave maestra se almacena en forma cifrada, en el caso general, en varias copias (ranuras).  Por defecto, solo uno de los ocho espacios est√° activo.  Cada ranura activa tiene una frase clave separada (o un archivo de clave separado), con el que puede descifrar la clave maestra.  Desde el punto de vista del usuario, resulta que puede desbloquear el disco usando cualquiera de las diferentes frases clave (o archivos clave).  En nuestro caso, usando una frase clave (ranura 0) o usando una pieza de memoria utilizada como archivo clave (ranura 6). </p></div></div><br><p>  El BIOS en la mayor√≠a de las placas base no limpia la memoria durante el reinicio, o puede configurarlo para que no limpie (excepci√≥n conocida: "Intel Corporation S1200SP / S1200SP, BIOS S1200SP.86B.03.01.0042.013020190050 30/01/2019").  Por lo tanto, puede almacenar la clave all√≠.  Cuando se apaga la alimentaci√≥n, el contenido de la RAM se borra despu√©s de un tiempo, junto con una copia insegura de la clave. </p><br><p>  Entonces vamos. </p><br><h3 id="shag-pervyy-ustanovit-sistemu-na-zashifrovannyy-s-pomoschyu-luks-disk">  Paso uno: instale el sistema en un disco cifrado con LUKS </h3><br><p>  En este caso, la partici√≥n del disco (por ejemplo, <code>/dev/sda1</code> ) montada en <code>/boot</code> debe permanecer sin cifrar, y la otra partici√≥n en la que todo lo dem√°s (por ejemplo, <code>/dev/sda2</code> ) debe cifrarse.  El sistema de archivos en la partici√≥n encriptada puede ser cualquiera, tambi√©n puede usar LVM para que el sistema de archivos ra√≠z, el volumen para el intercambio y todo lo dem√°s excepto <code>/boot</code> en el mismo contenedor.  Esto corresponde a la partici√≥n de disco predeterminada en CentOS 7 y Debian al elegir la opci√≥n de cifrado.  SUSE hace todo de manera diferente (encriptaci√≥n <code>/boot</code> ) y, por lo tanto, requiere la partici√≥n manual del disco. </p><br><p>  El resultado deber√≠a ser algo como lo siguiente: </p><br><pre> <code class="plaintext hljs">$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 10G 0 disk ‚îú‚îÄsda1 8:1 0 1G 0 part /boot ‚îî‚îÄsda2 8:2 0 9G 0 part ‚îî‚îÄluks-d07a97d7-3258-408c-a17c-e2fb56701c69 253:0 0 9G 0 crypt ‚îú‚îÄcentos_centos--encrypt2-root 253:1 0 8G 0 lvm / ‚îî‚îÄcentos_centos--encrypt2-swap 253:2 0 1G 0 lvm [SWAP]</code> </pre> <br><p>  En el caso de utilizar UEFI, tambi√©n habr√° una partici√≥n del sistema EFI. </p><br><blockquote>  Para usuarios de Debian y Ubuntu: reemplace el paquete <code>initramfs-tools</code> con <code>dracut</code> . <br><pre> <code class="plaintext hljs"># apt install --no-install-recommends dracut</code> </pre> <br><br>  <code>initramfs-tools</code> implementa una l√≥gica incorrecta en nuestro caso, aplicada a secciones encriptadas con un archivo de clave.  Dichas secciones se ignoran por completo o el contenido del archivo de clave se copia en initramfs (es decir, como resultado, en el disco) en claro, lo que no necesitamos. </blockquote><br><h3 id="shag-vtoroy-sozdat-klyuchevoy-fayl-kotoryy-budet-ispolzovatsya-dlya-avtomaticheskogo-razblokirovaniya-diska-posle-goryachey-perezagruzki">  Paso dos: cree un archivo de clave que se usar√° para desbloquear autom√°ticamente la unidad despu√©s de un reinicio en caliente </h3><br><p>  128 bits aleatorios son suficientes para nosotros, es decir  16 bytes.  El archivo se almacenar√° en un disco cifrado, por lo que nadie que no conozca la clave de cifrado y no tenga acceso de root al sistema cargado no lo leer√°. </p><br><pre> <code class="plaintext hljs"># touch -m 0600 /root/key # head -c16 /dev/urandom &gt; /root/key</code> </pre> <br><p>  Hay suficientes bits verdaderamente aleatorios en el archivo de claves para que el algoritmo lento PBKDF, que hace una clave de cifrado dif√≠cil de elegir a partir de una frase clave potencialmente d√©bil, no sea realmente necesaria.  Por lo tanto, al agregar una clave, puede reducir el n√∫mero de iteraciones: </p><br><pre> <code class="plaintext hljs"># cryptsetup luksAddKey --key-slot=6 --iter-time=1 /dev/sda2 /root/key Enter any existing passphrase:</code> </pre> <br><p>  Como puede ver, el archivo de clave se almacena en un disco encriptado y, por lo tanto, no representa ning√∫n riesgo de seguridad si la computadora est√° apagada. </p><br><h3 id="shag-tretiy-vydelit-mesto-v-fizicheskoy-pamyati-dlya-hraneniya-klyucha">  Paso tres: asigne espacio en la memoria f√≠sica para almacenar la clave </h3><br><p>  Linux tiene al menos tres controladores diferentes que le permiten acceder a la memoria f√≠sica en una direcci√≥n conocida.  Este es <code>linux/drivers/char/mem.c</code> , que tambi√©n es responsable del dispositivo <code>/dev/mem</code> , as√≠ como de los m√≥dulos <code>phram</code> (emula un chip MTD, proporciona el dispositivo <code>/dev/mtd0</code> ) y <code>nd_e820</code> (utilizado cuando se trabaja con NVDIMM, proporciona <code>/dev/pmem0</code> ).  Todos tienen sus caracter√≠sticas desagradables: </p><br><ul><li>  <code>/dev/mem</code> no se puede escribir cuando se utiliza el Arranque seguro si la distribuci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usa el conjunto de parches LOCKDOWN</a> de Matthew Garrett (y este conjunto de parches es necesario si la distribuci√≥n va a admitir Arranque seguro con un gestor de arranque firmado por Microsoft); </li><li>  <code>phram</code> no <code>phram</code> disponible en CentOS y Fedora: el mantenedor simplemente no habilit√≥ la opci√≥n correspondiente al construir el n√∫cleo; </li><li>  <code>nd_e820</code> necesita reservar al menos 128 megabytes de memoria: as√≠ es como funciona NVDIMM.  Pero esta es la √∫nica opci√≥n que se ejecuta en CentOS con arranque seguro. </li></ul><br><p>  Como no hay una opci√≥n ideal, las tres se consideran a continuaci√≥n. </p><br><blockquote>  Cuando se usa cualquiera de los m√©todos, se necesita un cuidado extremo para no afectar accidentalmente los dispositivos o rangos de memoria que no sean los necesarios.  Esto es especialmente cierto para las computadoras que ya tienen chips MTD o m√≥dulos NVDIMM.  Es decir, <code>/dev/mtd0</code> o <code>/dev/pmem0</code> pueden no ser el dispositivo que corresponde al √°rea de memoria reservada para almacenar la clave.  La numeraci√≥n de los dispositivos existentes, en los que se basan los archivos de configuraci√≥n y los scripts, tambi√©n puede confundirse.  En consecuencia, se recomienda que deshabilite temporalmente todos los servicios que dependen de los dispositivos existentes <code>/dev/mtd*</code> y <code>/dev/pmem*</code> . </blockquote><p>  Se realiza una <code>memmap</code> memoria f√≠sica de Linux pasando la opci√≥n <code>memmap</code> al <code>memmap</code> .  Estamos interesados ‚Äã‚Äãen dos tipos de esta opci√≥n: </p><br><ul><li>  <code>memmap=4K$0x10000000</code> reservas (es decir, marcas reservadas para que el n√∫cleo en s√≠ no use) 4 kilobytes de memoria, comenzando con la direcci√≥n f√≠sica 0x10000000; </li><li>  <code>memmap=128M!0x10000000</code> marca 128 megabytes de memoria f√≠sica, comenzando en la direcci√≥n 0x10000000, como NVDIMM (obviamente falso, pero ser√° suficiente para nosotros). </li></ul><br><p>  La opci√≥n c <code>$</code> es adecuada para usar con <code>/dev/mem</code> y <code>phram</code> , ¬°la opci√≥n c <code>!</code>  - para <code>nd_e820</code> .  Cuando se usa <code>$</code> direcci√≥n inicial de la memoria reservada debe ser un m√∫ltiplo de <code>0x1000</code> (es decir, 4 kilobytes), cuando se usa <code>!</code>  - un m√∫ltiplo de <code>0x8000000</code> (es decir, 128 megabytes). </p><br><p>  Importante: el signo de d√≥lar ( <code>$</code> ) en los archivos de configuraci√≥n de GRUB es un car√°cter especial y debe ser escapado.  Y dos veces: una vez, al generar <code>grub.cfg</code> desde <code>/etc/default/grub</code> , una segunda vez, al interpretar el archivo de configuraci√≥n resultante en la etapa de arranque.  Es decir  en <code>/etc/default/grub</code> , la siguiente l√≠nea deber√≠a aparecer finalmente: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 ...  ..."</code> </pre> <br><p>  Sin doble escape del signo <code>$</code> , el sistema simplemente no arrancar√°, ya que pensar√° que solo tiene 4 kilobytes de memoria.  No existen tales dificultades con un signo de exclamaci√≥n: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=128M!0x10000000 ...  ..."</code> </pre> <br><p>  El <code>root</code> puede acceder a la tarjeta de memoria f√≠sica (y es necesaria para averiguar qu√© direcciones reservar) en el <code>/proc/iomem</code> : </p><br><pre> <code class="plaintext hljs"># cat /proc/iomem ... 000f0000-000fffff : reserved 000f0000-000fffff : System ROM 00100000-7ffddfff : System RAM 2b000000-350fffff : Crash kernel 73a00000-7417c25e : Kernel code 7417c25f-747661ff : Kernel data 74945000-74c50fff : Kernel bss 7ffde000-7fffffff : reserved 80000000-febfffff : PCI Bus 0000:00 fd000000-fdffffff : 0000:00:02.0 ...</code> </pre> <br><p>  La RAM est√° marcada como "RAM del sistema", es suficiente para nosotros reservar una de sus p√°ginas para almacenar la clave.  Adivinar qu√© parte de la memoria del BIOS no toca al reiniciar no funcionar√° de manera confiable por adelantado.  A menos que haya otra computadora con exactamente la misma versi√≥n de BIOS y la misma configuraci√≥n de memoria en la que ya se ha completado este manual.  Por lo tanto, en el caso general, deber√° actuar por prueba y error.  Como regla general, cuando el BIOS se reinicia, cambia los datos solo al principio y al final de cada rango de memoria.  Por lo general, es suficiente retirarse 128 megabytes ( <code>0x8000000</code> ) de los bordes.  Para m√°quinas virtuales KVM con 1 GB de memoria o m√°s, las opciones propuestas ( <code>memmap=4K$0x10000000</code> y <code>memmap=128M!0x10000000</code> ) funcionan. </p><br><p>  Al usar el m√≥dulo <code>phram</code> , necesitamos otro par√°metro de l√≠nea de comando del n√∫cleo, que, de hecho, le dice al m√≥dulo qu√© parte de la memoria f√≠sica debe usar: la nuestra, reservada.  El par√°metro se llama <code>phram.phram</code> y contiene tres partes: el nombre (arbitrario de hasta 63 caracteres, ser√° visible en <code>sysfs</code> ), la direcci√≥n inicial y la longitud.  La direcci√≥n de inicio y la longitud deben ser las mismas que en <code>memmap</code> , pero los sufijos <code>K</code> y <code>M</code> no <code>M</code> compatibles. </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 phram.phram=savedkey,0x10000000,4096 ..."</code> </pre> <br><p>  Despu√©s de editar <code>/etc/default/grub</code> necesita regenerar el archivo de configuraci√≥n real que GRUB lee en el arranque.  El comando correcto para esto depende de la distribuci√≥n. </p><br><pre> <code class="plaintext hljs"># grub2-mkconfig -o /boot/grub2/grub.cfg # CentOS (Legacy BIOS) # grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg # CentOS (UEFI) # update-grub # Debian, Ubuntu # update-bootloader --reinit # SUSE</code> </pre> <br><p>  Despu√©s de actualizar la configuraci√≥n de GRUB, la computadora debe reiniciarse, pero lo haremos m√°s adelante cuando actualicemos initramfs. </p><br><h3 id="shag-chetvertyy-nastroit-luks-na-chtenie-klyucha-iz-pamyati">  Cuarto paso: configurar LUKS para leer la clave de la memoria </h3><br><p>  <code>/etc/crypttab</code> configuraci√≥n de cifrado de la <code>/etc/crypttab</code> se almacena en el <code>/etc/crypttab</code> .  Cada fila consta de cuatro campos: </p><br><ul><li>  el dispositivo que se debe obtener al desbloquear, </li><li>  dispositivo encriptado </li><li>  d√≥nde obtener el archivo de clave ( <code>none</code> significa ingresar una frase clave desde el teclado), </li><li>  campo opcional para opciones. </li></ul><br><p>  Si el archivo de clave existe, pero no cabe, entonces Dracut solicita la frase clave.  Lo que, de hecho, ser√° necesario en el primer arranque. </p><br><p>  Un ejemplo del <code>/etc/crypttab</code> de una distribuci√≥n reci√©n instalada: </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   luks-d07....69 UUID=d07....69 none</code> </pre> <br><p>  El archivo clave en nuestro caso ser√° una pieza de memoria f√≠sica.  Es decir  <code>/dev/mem</code> , <code>/dev/mtd0</code> o <code>/dev/pmem0</code> , dependiendo de la tecnolog√≠a de acceso a memoria seleccionada.  Se necesitan opciones para indicar qu√© parte del archivo es la clave. </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   #   /dev/mem: luks-d07....69 UUID=d07....69 /dev/mem keyfile-offset=0x10000000,keyfile-size=16 #   phram: luks-d07....69 UUID=d07....69 /dev/mtd0 keyfile-size=16 #   nd_e820: luks-d07....69 UUID=d07....69 /dev/pmem0 keyfile-size=16</code> </pre> <br><p>  Eso es solo que no funcionar√° as√≠. </p><br><p>  El punto es c√≥mo systemd determina cu√°ndo se puede desbloquear un dispositivo.  Es decir, toma el dispositivo de la tercera columna y espera a que la unidad de dispositivo correspondiente se active.  Parece l√≥gico: no tiene sentido intentar desbloquear el contenedor LUKS hasta que aparezca un dispositivo con un archivo de clave.  Pero la unidad del dispositivo no es lo mismo que el dispositivo en s√≠.  Systemd por defecto crea unidades de dispositivo solo para dispositivos kernel relacionados con subsistemas de dispositivos de bloque e interfaces de red.  Los dispositivos <code>/dev/mem</code> y <code>/dev/mtd0</code> son caracteres por car√°cter, por lo tanto, no se supervisan de forma predeterminada y nunca se reconocer√°n como listos. </p><br><p>  Tendr√° que decirle a systemd que debe rastrearlos creando reglas udev en el archivo <code>/etc/udev/rules.d/99-mem.rules</code> : </p><br><pre> <code class="plaintext hljs"># /dev/mem KERNEL=="mem", TAG+="systemd" # /dev/mtd* KERNEL=="mtd*", TAG+="systemd" #  /dev/pmem*      </code> </pre> <br><h3 id="shag-pyatyy-peregenerirovat-initramfs">  Paso cinco: regenerar initramfs </h3><br><blockquote>  Te recuerdo: este art√≠culo solo trata las distribuciones que usan Dracut.  Incluyendo aquellos donde no se usa por defecto, pero es accesible y eficiente. </blockquote><p>  Necesita regenerar initramfs para actualizar el <code>/etc/crypttab</code> all√≠.  Y tambi√©n, para incluir m√≥dulos de kernel adicionales y reglas udev all√≠.  De lo contrario, no se crear√° el dispositivo <code>/dev/mtd0</code> o <code>/dev/pmem0</code> .  El par√°metro de configuraci√≥n Dracut <code>force_drivers</code> es responsable de habilitar y cargar m√≥dulos de kernel adicionales, y <code>install_items</code> es responsable de archivos adicionales.  Creamos el archivo <code>/etc/dracut.conf.d/mem.conf</code> con los siguientes contenidos (se necesita un espacio despu√©s de la comilla de apertura, este es un separador): </p><br><pre> <code class="plaintext hljs">#   /dev/mem: install_items+=" /etc/udev/rules.d/99-mem.rules" #   phram: install_items+=" /etc/udev/rules.d/99-mem.rules" force_drivers+=" phram" #   nd_e820: force_drivers+=" nd_e820 nd_pmem"</code> </pre> <br><p>  En realidad, la regeneraci√≥n initramfs: </p><br><pre> <code class="plaintext hljs"># dracut -f</code> </pre> <br><blockquote>  Para los usuarios de Debian y Ubuntu, el responsable puso un rastrillo: el archivo resultante se llama incorrectamente.  Debe cambiarle el nombre para que tenga el mismo nombre que se prescribe en la configuraci√≥n de GRUB: <br><pre> <code class="plaintext hljs"># mv /boot/initramfs-5.0.0-19-generic.img /boot/initrd.img-5.0.0-19-generic</code> </pre> <br><br>  Al instalar nuevos n√∫cleos, la creaci√≥n autom√°tica de initramfs a trav√©s de Dracut se lleva a cabo correctamente, el error afecta solo el inicio manual de <code>dracut -f</code> . </blockquote><br><h3 id="shag-shestoy-perezagruzit-kompyuter">  Paso seis: reinicie su computadora </h3><br><p>  Es necesario reiniciar para que los cambios en la configuraci√≥n de GRUB y Dracut surtan efecto. </p><br><pre> <code class="plaintext hljs"># reboot</code> </pre> <br><p>  En esta etapa, no hay una clave en la memoria, por lo que deber√° ingresar una frase de contrase√±a. </p><br><p>  Despu√©s de reiniciar, debe verificar si la copia de seguridad de la memoria funcion√≥ correctamente.  Como m√≠nimo, en el <code>/proc/iomem</code> memoria requerida debe marcarse como "reservada" (cuando se usa <code>/dev/mem</code> o <code>phram</code> ) o como "Memoria persistente (heredada)". </p><br><p>  Incluso cuando use <code>phram</code> o <code>nd_e820</code> debe asegurarse de que el dispositivo <code>/dev/mtd0</code> o <code>/dev/pmem0</code> realmente se refiera al √°rea de memoria previamente reservada, y no a otra cosa. </p><br><pre> <code class="plaintext hljs"># cat /sys/class/mtd/mtd0/name #  : "savedkey" # cat /sys/block/pmem0/device/resource #    </code> </pre> <br><p>  Si esto no es as√≠, entonces necesita encontrar cu√°l de los dispositivos <code>/dev/mtd*</code> o <code>/dev/pmem*</code> "nuestro", y luego arreglar / etc / crypttab, regenerar initramfs y volver a verificar el resultado despu√©s de otro reinicio. </p><br><h3 id="shag-sedmoy-nastroit-kopirovanie-klyuchevogo-fayla-v-pamyat">  S√©ptimo paso: configure la copia del archivo de clave a la memoria </h3><br><p>  El archivo de clave se copiar√° en la memoria antes de reiniciar.  Una de las formas de ejecutar cualquier comando en la etapa de apagado del sistema es registrarlo en la directiva <code>ExecStop</code> en el servicio systemd.  Para que systemd entienda que esto no es un demonio y no jure por la falta de la directiva <code>ExecStart</code> , debe especificar el tipo de servicio como <code>oneshot</code> y tambi√©n sugerir que se considera que el servicio se est√° ejecutando, incluso si no hay ning√∫n proceso de trabajo asociado.  Entonces, aqu√≠ est√° el archivo <code>/etc/systemd/system/savekey.service</code> .  Es necesario dejar solo una de las variantes dadas de la directiva <code>ExecStop</code> . </p><br><pre> <code class="plaintext hljs">[Unit] Description=Saving LUKS key into RAM Documentation=https://habr.com/ru/post/457396/ [Service] Type=oneshot RemainAfterExit=true #   /dev/mem: ExecStop=/bin/sh -c 'dd if=/root/key of=/dev/mem bs=1 seek=$((0x10000000))' #   /dev/mtd0: ExecStop=/bin/dd if=/root/key of=/dev/mtd0 #   /dev/pmem0: ExecStop=/bin/dd if=/root/key of=/dev/pmem0 [Install] WantedBy=default.target</code> </pre> <br><p>  La construcci√≥n con <code>/bin/sh</code> necesaria ya que <code>dd</code> no entiende la notaci√≥n hexadecimal. </p><br><p>  Activamos el servicio, verificamos: </p><br><pre> <code class="plaintext hljs"># systemctl enable savekey # systemctl start savekey # reboot</code> </pre> <br><p>  Durante el reinicio posterior, no es necesario que ingrese la frase de contrase√±a desde el disco.  Y si es necesario, esto generalmente significa que la direcci√≥n de inicio del √°rea de memoria reservada se selecciona incorrectamente.  Est√° bien arreglar y regenerar varios archivos y reiniciar la computadora dos veces. </p><br><p>  Cuando se utiliza <code>phram</code> o <code>nd_e820</code> solo se tendr√° que editar la configuraci√≥n de GRUB.  Cuando se usa <code>/dev/mem</code> direcci√≥n de inicio tambi√©n se menciona en <code>/etc/crypttab</code> (por lo tanto, initramfs tendr√° que ser regenerado) y en el servicio systemd. </p><br><p>  Pero eso no es todo. </p><br><h3 id="voprosy-bezopasnosti">  Problemas de seguridad </h3><br><p>  Cualquier discusi√≥n sobre problemas de seguridad se basa en un modelo de amenaza.  Es decir  sobre los objetivos y los medios del atacante.  Soy consciente de que algunos de los ejemplos a continuaci√≥n son descabellados. </p><br><p>  Las situaciones con acceso f√≠sico a una computadora apagada no son diferentes de las que no tienen un almacenamiento de claves configurado en la memoria.  Existen los mismos tipos de ataques destinados a obtener frases clave, incluida <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Evil Maid</a> , y las mismas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">caracter√≠sticas de seguridad</a> .  No nos detenemos en ellos, ya que no hay nada nuevo. </p><br><p>  Las situaciones m√°s interesantes son cuando la computadora est√° encendida. </p><br><p>  <strong>Situaci√≥n 1</strong> .  El atacante no tiene acceso f√≠sico a la computadora, no conoce la frase de contrase√±a, pero tiene acceso ra√≠z a trav√©s de ssh.  El objetivo es la clave para descifrar el disco.  Por ejemplo, para acceder a copias de seguridad antiguas sector por sector de una imagen de disco de m√°quina virtual. </p><br><p>  En realidad, la clave en el platillo est√° en el archivo <code>/root/key</code> .  La pregunta es c√≥mo se relaciona esto con lo que sucedi√≥ antes de la implementaci√≥n de esta instrucci√≥n.  Respuesta: para luks1, la amenaza no es nueva.  Hay una <code>dmsetup table --target crypt --showkeys</code> que muestra la clave maestra, es decir  Tambi√©n datos que permiten el acceso a copias de seguridad antiguas.  Para luks2, la reducci√≥n de seguridad en este escenario realmente tiene lugar: las claves dm-crypt se almacenan en el llavero a nivel del n√∫cleo, y es imposible mirarlas desde el espacio del usuario. </p><br><p>  <strong>Situaci√≥n 2</strong> .  El atacante puede usar el teclado y mirar la pantalla, pero no est√° listo para abrir la carcasa.  Por ejemplo, us√© la contrase√±a filtrada de IPMI o intercept√© una sesi√≥n de noVNC en la nube.  No conoce la frase clave, tampoco conoce otras contrase√±as.  El objetivo es el acceso de root. </p><br><p>  Por favor: reinicie a trav√©s de <code>Ctrl-Alt-Del</code> , agregando la opci√≥n de kernel <code>init=/bin/sh</code> trav√©s de GRUB.  La frase de contrase√±a no era necesaria, ya que la clave se ley√≥ con √©xito desde la memoria.  Para protegerte de esto, deber√≠as evitar que GRUB cargue lo que no est√° en el men√∫.  Desafortunadamente, esta funcionalidad se implementa de manera diferente en diferentes distribuciones. </p><br><p>  A partir de la versi√≥n 7.2, CentOS tiene el <code>grub2-setpassword</code> , que en realidad protege a GRUB con una contrase√±a.  Otras distribuciones pueden tener sus propias utilidades para la misma tarea.  Si no lo est√°n, puede editar directamente los archivos en el directorio <code>/etc/grub.d</code> y regenerar <code>grub.cfg</code> . </p><br><p>  En el archivo <code>/etc/grub.d/10_linux</code> , cambie la variable CLASS, agregue la opci√≥n <code>--unrestricted</code> al final, si no estaba all√≠: </p><br><pre> <code class="plaintext hljs">CLASS="--class gnu-linux --class gnu --class os --unrestricted"</code> </pre> <br><p>  En el archivo <code>/etc/grub.d/40_custom</code> agregue las l√≠neas que especifican el nombre de usuario y la contrase√±a que se necesitan para editar la l√≠nea de comando del n√∫cleo: </p><br><pre> <code class="plaintext hljs">set superusers="root" password_pbkdf2 root grub.pbkdf2....... #    grub2-mkpasswd-pbkdf2</code> </pre> <br><p>  O, si es necesario deshabilitar dicha funcionalidad, aqu√≠ hay una l√≠nea como esta: </p><br><pre> <code class="plaintext hljs">set superusers=""</code> </pre> <br><p>  <strong>Situaci√≥n 3</strong> .  El atacante tiene acceso a la computadora incluida, lo que le permite iniciar desde medios no confiables.  Esto puede ser acceso f√≠sico sin abrir el caso o acceso a trav√©s de IPMI.  El objetivo es el acceso de root. </p><br><p>  Puede cargar su GRUB desde una unidad flash USB o CD-ROM y agregar <code>init=/bin/sh</code> a los par√°metros de su n√∫cleo, como en el ejemplo anterior.  En consecuencia, el arranque desde cualquier medio horrible deber√≠a estar prohibido en el BIOS.  Y tambi√©n proteja el cambio de la configuraci√≥n del BIOS con una contrase√±a. </p><br><p>  <strong>Situaci√≥n 4</strong> .  El atacante tiene acceso f√≠sico a la computadora incluida, incluida la capacidad de abrir el caso.  El objetivo es encontrar la clave u obtener acceso de root. </p><br><p>  En general, esta es una situaci√≥n perdedora de todos modos.  El ataque a los m√≥dulos de memoria enfri√°ndolos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ataque de arranque en fr√≠o</a> ) no se ha cancelado.  Tambi√©n te√≥ricamente (no se verific√≥), puede aprovechar el hecho de que los discos SATA modernos admiten la reconexi√≥n en caliente.  Cuando la computadora se reinicie, desconecte el disco, cambie <code>grub.cfg</code> por <code>init=/bin/sh</code> , vuelva a conectar, permita que el sistema se reinicie.  Resulta (si entiendo correctamente) el acceso a la ra√≠z. </p><br><p>  Un empleado sin escr√∫pulos de un alojamiento en la nube puede hacer lo mismo haciendo una instant√°nea de una m√°quina virtual con su posterior modificaci√≥n. </p><br><h3 id="prochie-voprosy">  Otros asuntos </h3><br><p>  <strong>Mantener la clave en la memoria durante un reinicio es una burla.</strong>  <strong>Use-after-free en su forma m√°s pura.</strong>  <strong>Una soluci√≥n m√°s limpia es usar kexec y agregar la clave a initramfs generados din√°micamente.</strong>  <strong>Tambi√©n protege contra la sustituci√≥n de los par√°metros del kernel</strong> .  S√≠, si kexec est√° funcionando.  Las distribuciones modernas han hecho que la configuraci√≥n de kexec sea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">demasiado complicada</a> . </p><br><p>  <strong>En los centros de datos, y m√°s a√∫n en la nube, la energ√≠a nunca desaparece.</strong>  <strong>Resulta que la frase clave ya no es necesaria?</strong>  De hecho, <em>si</em> est√° tan seguro de esto, puede eliminarlo.  Resultar√° ser un servidor en funcionamiento, la clave del disco que nadie conoce¬π y, por lo tanto, no ceder√°, pero el sistema en el que se puede actualizar utilizando medios regulares.    ‚Äî        <code>sudo poweroff</code> . </p><br><p> ¬π    <code>/root/key</code> ‚Äî         ,        cron. </p><br><p> <strong>   ?  IPMI,       </strong> .    IPMI      Java.        . </p><br><p> <strong>   ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> SSH</a></strong> . !    .  ,      <code>sudo reboot</code> ,      ? </p><br><p>             ,         .     SSH       ,      .       ,      ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457396/">https://habr.com/ru/post/457396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457380/index.html">OpenGL ultramoderno. Parte 2</a></li>
<li><a href="../457382/index.html">7 h√°bitos de programadores de alto rendimiento</a></li>
<li><a href="../457386/index.html">Presentaci√≥n de las interfaces virtuales de Linux: t√∫neles</a></li>
<li><a href="../457390/index.html">Madagascar - isla de contrastes</a></li>
<li><a href="../457392/index.html">Ahorros en el desarrollo multiplataforma m√≥vil: estudio de caso de Skyeng</a></li>
<li><a href="../457398/index.html">¬øPero estoy haciendo estupideces? ¬øPor qu√© los desarrolladores van a gemba?</a></li>
<li><a href="../457400/index.html">El n√∫mero de v√≠ctimas en desastres nucleares como Chernobyl es muy exagerado para el drama</a></li>
<li><a href="../457402/index.html">C√≥mo organizar el desarrollo y soporte de un blog en WordPress en el 2T19 y no arreglarlo</a></li>
<li><a href="../457404/index.html">Noticias del mundo de OpenStreetMap No. 465 (11/06/2019 - 17/06/2019)</a></li>
<li><a href="../457406/index.html">¬øCu√°nto ganan los graduados de varias universidades rusas?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>