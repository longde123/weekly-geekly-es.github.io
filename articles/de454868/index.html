<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèº üë®üèª‚Äçüé§ ü§Ωüèº Kompilieren von C in WebAssembly ohne Emscripten ‚óæÔ∏è üí∑ üôãüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Compiler ist Teil von Emscripten . Aber was ist, wenn Sie alle Pfeifen entfernen und nur sie lassen? 

 Emscripten ist erforderlich, um C / C ++ i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompilieren von C in WebAssembly ohne Emscripten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454868/"> Der Compiler ist Teil von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emscripten</a> .  Aber was ist, wenn Sie alle Pfeifen entfernen und nur sie lassen? <br><br>  Emscripten ist erforderlich, um C / C ++ in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAssembly</a> zu kompilieren.  Dies ist jedoch viel mehr als nur ein Compiler.  Das Ziel von Emscripten ist es, Ihren C / C ++ - Compiler vollst√§ndig zu ersetzen und Code im Web auszuf√ºhren, der urspr√ºnglich <b>nicht</b> f√ºr das Web entwickelt wurde.  Zu diesem Zweck emuliert Emscripten das gesamte POSIX-Betriebssystem.  Wenn das Programm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fopen () verwendet</a> , stellt Emscripten die Dateisystememulation bereit.  Wenn OpenGL verwendet wird, stellt Emscripten einen C-kompatiblen GL-Kontext bereit, der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebGL</a> unterst√ºtzt wird.  Dies ist viel Arbeit und viel Code, der im endg√ºltigen Paket implementiert werden muss.  Aber k√∂nnen Sie es einfach ... entfernen? <br><a name="habracut"></a><br>  Der eigentliche <i>Compiler</i> im Emscripten-Toolkit ist LLVM.  Er ist es, der den C-Code in WebAssembly-Bytecode √ºbersetzt.  Dies ist ein moderner modularer Rahmen f√ºr die Analyse, Transformation und Optimierung von Programmen.  LLVM ist modular in dem Sinne, dass es niemals direkt in Maschinencode kompiliert wird.  Stattdessen generiert der integrierte <i>Front-End-Compiler</i> <i>eine Zwischendarstellung</i> (IR).  Diese Zwischendarstellung wird in der Tat als LLVM bezeichnet, eine Abk√ºrzung f√ºr Low-Level Virtual Machine, daher der Name des Projekts. <br><br>  Der <i>Backend-Compiler</i> √ºbersetzt <i>dann</i> die IR in den Code des Host-Computers.  Der Vorteil dieser strengen Trennung besteht darin, dass neue Architekturen durch das ‚Äûeinfache‚Äú Hinzuf√ºgen eines neuen Compilers unterst√ºtzt werden.  In diesem Sinne ist WebAssembly nur eines von vielen Kompilierungszielen, die LLVM unterst√ºtzt, und seit einiger Zeit wird es mit einem speziellen Flag aktiviert.  Ab LLVM 8 ist das WebAssembly-Kompilierungsziel standardm√§√üig verf√ºgbar. <br><br>  Unter MacOS k√∂nnen Sie LLVM mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Homebrew</a> installieren: <br><br><pre><code class="bash hljs">$ brew install llvm $ brew link --force llvm</code> </pre> <br>  √úberpr√ºfen Sie die WebAssembly-Unterst√ºtzung: <br><br><pre> <code class="bash hljs">$ llc --version LLVM (http://llvm.org/): LLVM version 8.0.0 Optimized build. Default target: x86_64-apple-darwin18.5.0 Host CPU: skylake Registered Targets: <span class="hljs-comment"><span class="hljs-comment"># ‚Ä¶,  ‚Ä¶ systemz - SystemZ thumb - Thumb thumbeb - Thumb (big endian) wasm32 - WebAssembly 32-bit # ! ! ! wasm64 - WebAssembly 64-bit x86 - 32-bit X86: Pentium-Pro and above x86-64 - 64-bit X86: EM64T and AMD64 xcore - XCore</span></span></code> </pre> <br>  Es scheint, wir sind bereit! <br><br><h1>  C auf die harte Tour kompilieren </h1><br><blockquote>  <b>Hinweis:</b> Hier finden Sie einige einfache RAW-WebAssembly-Formate.  Wenn Sie es schwer zu verstehen finden, ist dies normal.  <b>F√ºr eine gute Verwendung von WebAssembly ist kein Verst√§ndnis des gesamten Textes in diesem Artikel erforderlich.</b>  <b>Wenn Sie nach Code zum Einf√ºgen von Kopien suchen, lesen Sie den Aufruf des Compilers im Abschnitt Optimierung</b> .  Aber wenn Sie interessiert sind, lesen Sie weiter!  Ich habe zuvor eine Einf√ºhrung in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reine Webassembly</a> und WAT geschrieben: Dies sind die Grundlagen, die zum Verst√§ndnis dieses Beitrags erforderlich sind. </blockquote>  Warnung: Ich werde geringf√ºgig vom Standard abweichen und versuchen, bei jedem Schritt (soweit m√∂glich) f√ºr Menschen lesbare Formate zu verwenden.  Unser Programm hier wird sehr einfach sein, um Grenzsituationen zu vermeiden und nicht abgelenkt zu werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Filename: add.c int add(int a, int b) { return a*a + b; }</span></span></code> </pre> <br>  Was f√ºr eine gro√üartige technische Leistung!  Vor allem, weil das Programm <i>add</i> hei√üt, aber in Wirklichkeit nichts <i>hinzuf√ºgt</i> (nicht hinzuf√ºgt).  Noch wichtiger: Das Programm verwendet nicht die Standardbibliothek und von den hier genannten Typen nur 'int'. <br><br><h3>  C in eine interne LLVM-Ansicht verwandeln </h3><br>  Der erste Schritt besteht darin, unser C-Programm in LLVM IR umzuwandeln.  Dies ist die Aufgabe des <code>clang</code> Frontend-Compilers, der mit LLVM installiert wird: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ <span class="hljs-comment"><span class="hljs-comment"># Target WebAssembly -emit-llvm \ # Emit LLVM IR (instead of host machine code) -c \ # Only compile, no linking just yet -S \ # Emit human-readable assembly rather than binary add.c</span></span></code> </pre> <br>  Als Ergebnis erhalten wir <code>add.ll</code> mit einer internen Darstellung von LLVM IR.  <b>Ich zeige es nur der Vollst√§ndigkeit halber</b> .  Wenn Sie mit WebAssembly arbeiten oder sogar klirren, werden Sie als C-Entwickler niemals mit LLVM IR in Kontakt kommen. <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'add.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"add.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:ep:32:32-i64:64-n32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"wasm32"</span></span> ; Function Attrs: norecurse nounwind readnone define hidden i32 @add(i32, i32) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">3</span></span> = mul nsw i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = add nsw i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">4</span></span> } attributes #<span class="hljs-number"><span class="hljs-number">0</span></span> = { norecurse nounwind readnone <span class="hljs-string"><span class="hljs-string">"correctly-rounded-divide-sqrt-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"disable-tail-calls"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"less-precise-fpmad"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"min-legal-vector-width"</span></span>=<span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-string"><span class="hljs-string">"no-frame-pointer-elim"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-infs-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-jump-tables"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-nans-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-signed-zeros-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-trapping-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"stack-protector-buffer-size"</span></span>=<span class="hljs-string"><span class="hljs-string">"8"</span></span> <span class="hljs-string"><span class="hljs-string">"target-cpu"</span></span>=<span class="hljs-string"><span class="hljs-string">"generic"</span></span> <span class="hljs-string"><span class="hljs-string">"unsafe-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"use-soft-float"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> } !llvm.<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.flags = !{!<span class="hljs-number"><span class="hljs-number">0</span></span>} !llvm.ident = !{!<span class="hljs-number"><span class="hljs-number">1</span></span>} !<span class="hljs-number"><span class="hljs-number">0</span></span> = !{i32 <span class="hljs-number"><span class="hljs-number">1</span></span>, !<span class="hljs-string"><span class="hljs-string">"wchar_size"</span></span>, i32 <span class="hljs-number"><span class="hljs-number">4</span></span>} !<span class="hljs-number"><span class="hljs-number">1</span></span> = !{!<span class="hljs-string"><span class="hljs-string">"clang version 8.0.0 (tags/RELEASE_800/final)"</span></span>}</code> </pre> <br>  <i>LLVM IR ist voll von zus√§tzlichen Metadaten und Anmerkungen, die es dem Compiler erm√∂glichen, fundiertere Entscheidungen beim Generieren von Maschinencode zu treffen.</i> <br><br><h3>  Verwandeln Sie LLVM IR in Objektdateien </h3><br>  Der n√§chste Schritt besteht darin, den <code>llc</code> Backend-Compiler <code>llc</code> , um aus der internen Darstellung eine Objektdatei zu erstellen. <br><br>  Die <code>add.o</code> ist bereits ein g√ºltiges WebAssembly-Modul, das den gesamten kompilierten Code unserer C-Datei enth√§lt. In der Regel k√∂nnen Sie jedoch keine Objektdateien ausf√ºhren, da ihnen wesentliche Teile fehlen. <br><br>  Wenn wir <code>-filetype=obj</code> im Befehl <code>-filetype=obj</code> , erhalten wir den LLVM-Assembler f√ºr WebAssembly, ein f√ºr Menschen lesbares Format, das WAT etwas √§hnlich ist.  Das <code>llvm-mc</code> Tool zum Arbeiten mit solchen Dateien unterst√ºtzt das Format jedoch noch nicht vollst√§ndig und kann h√§ufig keine Dateien verarbeiten.  Daher zerlegen wir die Objektdateien nachtr√§glich.  Zum √úberpr√ºfen dieser Objektdateien wird ein spezielles Tool ben√∂tigt.  Im Fall von WebAssembly war es <code>wasm-objdump</code> , Teil des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAssembly Binary Toolkit</a> oder kurz wabt. <br><br><pre> <code class="bash hljs">$ brew install wabt <span class="hljs-comment"><span class="hljs-comment"># in case you haven't $ wasm-objdump -x add.o add.o: file format wasm 0x1 Section Details: Type[1]: - type[0] (i32, i32) -&gt; i32 Import[3]: - memory[0] pages: initial=0 &lt;- env.__linear_memory - table[0] elem_type=funcref init=0 max=0 &lt;- env.__indirect_function_table - global[0] i32 mutable=1 &lt;- env.__stack_pointer Function[1]: - func[0] sig=0 &lt;add&gt; Code[1]: - func[0] size=75 &lt;add&gt; Custom: - name: "linking" - symbol table [count=2] - 0: F &lt;add&gt; func=0 binding=global vis=hidden - 1: G &lt;env.__stack_pointer&gt; global=0 undefined binding=global vis=default Custom: - name: "reloc.CODE" - relocations for section: 3 (Code) [1] R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x000080) symbol=1 &lt;env.__stack_pointer&gt;</span></span></code> </pre> <br>  Die Ausgabe zeigt, dass sich unsere Funktion add () in diesem Modul befindet, enth√§lt jedoch auch <i>benutzerdefinierte</i> Abschnitte mit Metadaten und √ºberraschenderweise mehrere Importe.  In der n√§chsten Phase der <i>Verkn√ºpfung werden</i> benutzerdefinierte Abschnitte analysiert und gel√∂scht, und der Linker (Linker) √ºbernimmt den Import. <br><br><h3>  Layout </h3><br>  Traditionell besteht die Aufgabe des Linkers darin, mehrere Objektdateien zu einer ausf√ºhrbaren Datei zusammenzuf√ºgen.  Der LLVM-Linker hei√üt <code>lld</code> und wird mit dem <code>lld</code> aufgerufen.  F√ºr WebAssembly war dies <code>wasm-ld</code> . <br><br><pre> <code class="bash hljs">wasm-ld \ --no-entry \ <span class="hljs-comment"><span class="hljs-comment"># We don't have an entry function --export-all \ # Export everything (for now) -o add.wasm \ add.o</span></span></code> </pre> <br>  Das Ergebnis ist ein WebAssembly-Modul mit einer Gr√∂√üe von 262 Byte. <br><br><h3>  Starten </h3><br>  Das Wichtigste ist nat√ºrlich, dass alles <i>wirklich</i> funktioniert.  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel</a> k√∂nnen Sie dieses WebAssembly-Modul mit einigen Zeilen eingebetteten JavaScript laden und ausf√ºhren. <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(instance.exports.add(</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">)); } init(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Wenn alles in Ordnung ist, sehen Sie die Nummer 17 in der DevTool-Konsole. <b>Wir haben gerade C erfolgreich in WebAssembly kompiliert, ohne Emscripten zu ber√ºhren.</b>  Es ist auch erw√§hnenswert, dass es keine Middleware zum Konfigurieren und Laden des WebAssembly-Moduls gibt. <br><br><h1>  Das Kompilieren von C ist etwas einfacher </h1><br>  Um C in WebAssembly zu kompilieren, haben wir viele Schritte unternommen.  Wie gesagt, wir haben zu Bildungszwecken alle Phasen im Detail untersucht.  √úberspringen wir f√ºr Menschen lesbare Zwischenformate und wenden den C-Compiler sofort als Schweizer Taschenmesser an, wie er entwickelt wurde: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -nostdlib \ <span class="hljs-comment"><span class="hljs-comment"># Don't try and link against a standard library -Wl,--no-entry \ # Flags passed to the linker -Wl,--export-all \ -o add.wasm \ add.c</span></span></code> </pre> <br>  Hier erhalten wir die gleiche <code>.wasm</code> Datei, jedoch mit einem Befehl. <br><br><h1>  Optimierung </h1><br>  Schauen Sie sich das WAT unseres WebAssembly-Moduls an, indem Sie <code>wasm2wat</code> : <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) (local i32 i32 i32 i32 i32 i32 i32 i32) global.get 0 local.set 2 i32.const 16 local.set 3 local.get 2 local.get 3 i32.sub local.set 4 local.get 4 local.get 0 i32.store offset=12 local.get 4 local.get 1 i32.store offset=8 local.get 4 i32.load offset=12 local.set 5 local.get 4 i32.load offset=12 local.set 6 local.get 5 local.get 6 i32.mul local.set 7 local.get 4 i32.load offset=8 local.set 8 local.get 7 local.get 8 i32.add local.set 9 local.get 9 return) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br>  Wow, was f√ºr ein gro√üartiger Code.  Zu meiner √úberraschung verwendet das Modul Speicher (wie aus den <code>i32.store</code> <code>i32.load</code> und <code>i32.store</code> ), acht lokale und mehrere globale Variablen.  Wahrscheinlich k√∂nnen Sie manuell eine pr√§zisere Version schreiben.  Dieses Programm ist so gro√ü, weil wir keine Optimierungen vorgenommen haben.  Lass es uns tun: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ + -O3 \ <span class="hljs-comment"><span class="hljs-comment"># Agressive optimizations + -flto \ # Add metadata for link-time optimizations -nostdlib \ -Wl,--no-entry \ -Wl,--export-all \ + -Wl,--lto-O3 \ # Aggressive link-time optimizations -o add.wasm \ add.c</span></span></code> </pre> <br><blockquote>  <b>Hinweis:</b> Technisch gesehen bietet die Layoutoptimierung (LTO) keine Vorteile, da wir nur eine Datei erstellen.  In gro√üen Projekten hilft LTO dabei, die Dateigr√∂√üe erheblich zu reduzieren. </blockquote>  Nach dem Ausf√ºhren dieser Befehle wurde die <code>.wasm</code> Datei von 262 auf 197 Byte verringert, und WAT wurde auch viel einfacher: <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) local.get 0 local.get 0 i32.mul local.get 1 i32.add) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br><h1>  Rufen Sie die Standardbibliothek auf </h1><br>  Die Verwendung von C ohne die Standardbibliothek libc erscheint eher unh√∂flich.  Es ist logisch, es hinzuzuf√ºgen, aber ich werde ehrlich sein: Es wird <i>nicht</i> einfach sein.  <b>Tats√§chlich rufen wir keine libc-Bibliotheken im Artikel direkt auf</b> .  Es gibt mehrere geeignete, insbesondere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Glibc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mussl</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dietlibc</a> .  Die meisten dieser Bibliotheken sollen jedoch unter dem POSIX-Betriebssystem ausgef√ºhrt werden, das bestimmte Systemaufrufe implementiert.  Da wir in JavaScript keine Kernel-Oberfl√§che haben, m√ºssen wir diese POSIX-Systemaufrufe selbst implementieren, wahrscheinlich √ºber JavaScript.  Dies ist eine schwierige Aufgabe und ich werde sie hier nicht erledigen.  Die gute Nachricht ist, dass <b>Emscripten dies f√ºr Sie tut</b> . <br><br>  Nat√ºrlich sind nicht alle libc-Funktionen auf Systemaufrufe angewiesen.  Funktionen wie <code>strlen()</code> , <code>sin()</code> oder sogar <code>memset()</code> sind in einfachem C implementiert. Dies bedeutet, dass Sie diese Funktionen verwenden oder ihre Implementierung einfach aus einer der genannten Bibliotheken kopieren / einf√ºgen k√∂nnen. <br><br><h1>  Dynamischer Speicher </h1><br>  Ohne libc stehen uns C-Grundschnittstellen wie <code>malloc()</code> und <code>free()</code> nicht zur Verf√ºgung.  Im nicht optimierten WAT haben wir gesehen, dass der Compiler bei Bedarf Speicher verwendet.  Dies bedeutet, dass wir den Speicher nicht einfach so verwenden k√∂nnen, wie wir m√∂chten, ohne das Risiko einzugehen, ihn zu besch√§digen.  Sie m√ºssen verstehen, wie es verwendet wird. <br><br><h3>  LLVM-Speichermodelle </h3><br>  Die WebAssembly-Speichersegmentierungsmethode wird erfahrene Programmierer ein wenig √ºberraschen.  Erstens ist in WebAssembly eine Nulladresse technisch zul√§ssig, wird jedoch h√§ufig immer noch als Fehler behandelt.  Zweitens kommt der Stapel zuerst und w√§chst nach unten (zu niedrigeren Adressen), und der Heap erscheint sp√§ter und w√§chst nach oben.  Der Grund daf√ºr ist, dass der Speicher von WebAssembly zur Laufzeit zunehmen kann.  Dies bedeutet, dass es kein festes Ende gibt, um den Stapel oder den Heap aufzunehmen. <br><br>  Hier ist das <code>wasm-ld</code> Layout: <br><br><img src="https://habrastorage.org/webt/kz/xv/z6/kzxvz60tlxzqdv_9tvxlm4m3gca.png"><br><br>  <i><font color="gray">Der Stapel w√§chst nach unten und der Haufen w√§chst nach oben.</font></i>  <i><font color="gray">Der Stack beginnt mit <code>__data_end</code> und der Heap <code>__heap_base</code> mit <code>__heap_base</code> .</font></i>  <i><font color="gray">Da der Stapel an erster Stelle steht, ist er durch die maximale Gr√∂√üe begrenzt, die w√§hrend der Kompilierung festgelegt wurde, d. H. <code>__heap_base</code> minus <code>__data_end</code></font></i> <br><br>  Wenn wir uns den globalen Abschnitt in unserem WAT ansehen, finden wir folgende Werte: <code>__heap_base</code> auf 66560 und <code>__data_end</code> auf 1024 festgelegt. Dies bedeutet, dass der Stapel auf maximal 64 KiB wachsen kann, was nicht viel ist.  Gl√ºcklicherweise k√∂nnen Sie mit <code>wasm-ld</code> diesen Wert √§ndern: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -O3 \ -flto \ -nostdlib \ -Wl,--no-entry \ -Wl,--<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>-all \ -Wl,--lto-O3 \ + -Wl,-z,stack-size=$[8 * 1024 * 1024] \ <span class="hljs-comment"><span class="hljs-comment"># Set maximum stack size to 8MiB -o add.wasm \ add.c</span></span></code> </pre> <br><h3>  Allokatorbaugruppe </h3><br>  Es ist bekannt, dass der Heap-Bereich mit <code>__heap_base</code> .  Da die Funktion <code>malloc()</code> fehlt, wissen wir, dass der n√§chste Speicherbereich sicher verwendet werden kann.  Wir k√∂nnen die Daten dort platzieren, wie wir m√∂chten, und es besteht kein Grund zur Angst vor Speicherbesch√§digung, da der Stapel in die andere Richtung w√§chst.  Ein f√ºr alle kostenloser Heap kann jedoch schnell verstopfen, sodass normalerweise eine Art dynamisches Speichermanagement erforderlich ist.  Eine M√∂glichkeit besteht darin, eine vollst√§ndige Implementierung von malloc () zu √ºbernehmen, beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Malloc-Implementierung von Doug Lee</a> , die in Emscripten verwendet wird.  Es gibt mehrere weitere kleine Implementierungen mit verschiedenen Kompromissen. <br><br>  Aber warum nicht dein eigenes <code>malloc()</code> schreiben?  Wir sind so tief verwurzelt, dass es keinen Unterschied macht.  Eines der einfachsten ist ein Bump Allocator: Es ist superschnell, extrem klein und einfach zu implementieren.  Es gibt jedoch einen Nachteil: Sie k√∂nnen keinen Speicher freigeben.  Obwohl ein solcher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allokator</a> auf den ersten Blick unglaublich nutzlos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erscheint,</a> bin ich bei der Entwicklung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Squoosh</a> auf Pr√§zedenzf√§lle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesto√üen, bei</a> denen dies eine ausgezeichnete Wahl w√§re.  Das Konzept eines Bump-Allokators besteht darin, dass wir die Startadresse des nicht verwendeten Speichers als global speichern.  Wenn das Programm <code>n</code> Bytes Speicher anfordert, verschieben wir den Marker auf <code>n</code> und geben den vorherigen Wert zur√ºck: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_base; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bump_pointer = &amp;__heap_base; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = bump_pointer; bump_pointer += n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// lol }</span></span></code> </pre> <br>  Die globalen Variablen von WAT werden tats√§chlich von <code>wasm-ld</code> , sodass wir von unserem C-Code aus als normale Variablen darauf zugreifen k√∂nnen, wenn wir sie <code>extern</code> deklarieren.  Also haben <b>wir gerade unser eigenes <code>malloc()</code> ... in f√ºnf Zeilen von C.</b> <br><br><blockquote>  <b>Hinweis:</b> Unser Bump Allocator ist nicht vollst√§ndig mit <code>malloc()</code> von C kompatibel. Beispielsweise geben wir keine Ausrichtungsgarantien.  Aber es funktioniert gut genug, also ... </blockquote><h3>  Dynamische Speichernutzung </h3><br>  Zum Testen erstellen wir eine Funktion C, die ein Array von Zahlen beliebiger Gr√∂√üe verwendet und die Summe berechnet.  Nicht sehr interessant, aber dies zwingt uns, dynamischen Speicher zu verwenden, da wir die Gr√∂√üe des Arrays w√§hrend der Montage nicht kennen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { sum += a[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Die sum () -Funktion ist hoffentlich ziemlich einfach.  Eine interessantere Frage ist, wie ein Array von JavaScript an WebAssembly √ºbergeben wird. Schlie√ülich versteht WebAssembly nur Zahlen.  Die allgemeine Idee ist, mit <code>malloc()</code> <i>aus JavaScript</i> einen Speicherplatz zuzuweisen, die Werte dort zu kopieren und die Adresse (Nummer!) Zu √ºbergeben, an der sich <i>das</i> Array befindet: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> jsArray = [</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">2</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">3</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">5</span></span></span><span class="javascript">]; </span><span class="hljs-comment"><span class="javascript"><span class="hljs-comment">// Allocate memory for 5 32-bit integers // and return get starting address. const cArrayPointer = instance.exports.malloc(jsArray.length * 4); // Turn that sequence of 32-bit integers // into a Uint32Array, starting at that address. const cArray = new Uint32Array( instance.exports.memory.buffer, cArrayPointer, jsArray.length ); // Copy the values from JS to C. cArray.set(jsArray); // Run the function, passing the starting address and length. console.log(instance.exports.sum(cArrayPointer, cArray.length)); } init(); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Nach dem Start sollte die Antwort 15 in der DevTools-Konsole angezeigt werden. Dies ist die Summe aller Zahlen von 1 bis 5. <br><br><h1>  Fazit </h1><br>  Sie lesen also bis zum Ende.  Gl√ºckwunsch!  Auch hier ist alles in Ordnung, wenn Sie sich etwas √ºberlastet f√ºhlen.  <b>Es ist nicht notwendig, alle Details zu lesen.</b>  <b>Das Verst√§ndnis dieser Informationen ist f√ºr einen guten Webentwickler v√∂llig optional und f√ºr die hervorragende Verwendung von WebAssembly nicht einmal erforderlich</b> .  Aber ich wollte diese Informationen teilen, weil Sie so die ganze Arbeit, die ein Projekt wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emscripten</a> f√ºr Sie leistet, wirklich sch√§tzen k√∂nnen.  Gleichzeitig erhalten Sie ein Verst√§ndnis daf√ºr, wie klein die rein rechnerischen Module von WebAssembly sein k√∂nnen.  Das Wasm-Modul zum Summieren des Arrays ist nur 230 Byte gro√ü, <i>einschlie√ülich eines dynamischen Speicherzuweisers</i> .  Wenn Sie denselben Code mit Emscripten kompilieren, werden 100 Byte WebAssembly-Code und 11 KB JavaScript-Verkn√ºpfungscode erzeugt.  Wir m√ºssen es f√ºr ein solches Ergebnis versuchen, aber es gibt Situationen, in denen es sich lohnt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454868/">https://habr.com/ru/post/de454868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454844/index.html">Odigest: interessant f√ºr Designer der Woche</a></li>
<li><a href="../de454850/index.html">Die Entwicklung eines einzelnen Algorithmus</a></li>
<li><a href="../de454856/index.html">Wir analysieren Schwachstellen bei der Validierung von SSL / TLS-Zertifikaten in Nicht-Browser-Software</a></li>
<li><a href="../de454860/index.html">Lassen Sie uns QueryProvider beim Umgang mit interpolierten Zeichenfolgen unterst√ºtzen</a></li>
<li><a href="../de454864/index.html">Wie sind die Entwicklungsprozesse in verschiedenen Unternehmen</a></li>
<li><a href="../de454872/index.html">Space Invaders: jetzt in 512 Bytes (Assembler x86)</a></li>
<li><a href="../de454874/index.html">Ein bisschen √ºber Multitasking in Mikrocontrollern</a></li>
<li><a href="../de454876/index.html">√úber das Entwerfen eines flexiblen Systems von Charakterf√§higkeiten in Spielen</a></li>
<li><a href="../de454878/index.html">Wir studieren MITRE ATT & CK. Mobile Matrizen: Ger√§tezugriff. Teil 3</a></li>
<li><a href="../de454880/index.html">"Nebensaison" im Leben eines Freiberuflers: Wie kann man √ºberleben und √ºberleben?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>