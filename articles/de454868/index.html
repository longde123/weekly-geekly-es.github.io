<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏼 👨🏻‍🎤 🤽🏼 Kompilieren von C in WebAssembly ohne Emscripten ◾️ 💷 🙋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Compiler ist Teil von Emscripten . Aber was ist, wenn Sie alle Pfeifen entfernen und nur sie lassen? 

 Emscripten ist erforderlich, um C / C ++ i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompilieren von C in WebAssembly ohne Emscripten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454868/"> Der Compiler ist Teil von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emscripten</a> .  Aber was ist, wenn Sie alle Pfeifen entfernen und nur sie lassen? <br><br>  Emscripten ist erforderlich, um C / C ++ in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAssembly</a> zu kompilieren.  Dies ist jedoch viel mehr als nur ein Compiler.  Das Ziel von Emscripten ist es, Ihren C / C ++ - Compiler vollständig zu ersetzen und Code im Web auszuführen, der ursprünglich <b>nicht</b> für das Web entwickelt wurde.  Zu diesem Zweck emuliert Emscripten das gesamte POSIX-Betriebssystem.  Wenn das Programm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fopen () verwendet</a> , stellt Emscripten die Dateisystememulation bereit.  Wenn OpenGL verwendet wird, stellt Emscripten einen C-kompatiblen GL-Kontext bereit, der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebGL</a> unterstützt wird.  Dies ist viel Arbeit und viel Code, der im endgültigen Paket implementiert werden muss.  Aber können Sie es einfach ... entfernen? <br><a name="habracut"></a><br>  Der eigentliche <i>Compiler</i> im Emscripten-Toolkit ist LLVM.  Er ist es, der den C-Code in WebAssembly-Bytecode übersetzt.  Dies ist ein moderner modularer Rahmen für die Analyse, Transformation und Optimierung von Programmen.  LLVM ist modular in dem Sinne, dass es niemals direkt in Maschinencode kompiliert wird.  Stattdessen generiert der integrierte <i>Front-End-Compiler</i> <i>eine Zwischendarstellung</i> (IR).  Diese Zwischendarstellung wird in der Tat als LLVM bezeichnet, eine Abkürzung für Low-Level Virtual Machine, daher der Name des Projekts. <br><br>  Der <i>Backend-Compiler</i> übersetzt <i>dann</i> die IR in den Code des Host-Computers.  Der Vorteil dieser strengen Trennung besteht darin, dass neue Architekturen durch das „einfache“ Hinzufügen eines neuen Compilers unterstützt werden.  In diesem Sinne ist WebAssembly nur eines von vielen Kompilierungszielen, die LLVM unterstützt, und seit einiger Zeit wird es mit einem speziellen Flag aktiviert.  Ab LLVM 8 ist das WebAssembly-Kompilierungsziel standardmäßig verfügbar. <br><br>  Unter MacOS können Sie LLVM mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Homebrew</a> installieren: <br><br><pre><code class="bash hljs">$ brew install llvm $ brew link --force llvm</code> </pre> <br>  Überprüfen Sie die WebAssembly-Unterstützung: <br><br><pre> <code class="bash hljs">$ llc --version LLVM (http://llvm.org/): LLVM version 8.0.0 Optimized build. Default target: x86_64-apple-darwin18.5.0 Host CPU: skylake Registered Targets: <span class="hljs-comment"><span class="hljs-comment"># …,  … systemz - SystemZ thumb - Thumb thumbeb - Thumb (big endian) wasm32 - WebAssembly 32-bit # ! ! ! wasm64 - WebAssembly 64-bit x86 - 32-bit X86: Pentium-Pro and above x86-64 - 64-bit X86: EM64T and AMD64 xcore - XCore</span></span></code> </pre> <br>  Es scheint, wir sind bereit! <br><br><h1>  C auf die harte Tour kompilieren </h1><br><blockquote>  <b>Hinweis:</b> Hier finden Sie einige einfache RAW-WebAssembly-Formate.  Wenn Sie es schwer zu verstehen finden, ist dies normal.  <b>Für eine gute Verwendung von WebAssembly ist kein Verständnis des gesamten Textes in diesem Artikel erforderlich.</b>  <b>Wenn Sie nach Code zum Einfügen von Kopien suchen, lesen Sie den Aufruf des Compilers im Abschnitt Optimierung</b> .  Aber wenn Sie interessiert sind, lesen Sie weiter!  Ich habe zuvor eine Einführung in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reine Webassembly</a> und WAT geschrieben: Dies sind die Grundlagen, die zum Verständnis dieses Beitrags erforderlich sind. </blockquote>  Warnung: Ich werde geringfügig vom Standard abweichen und versuchen, bei jedem Schritt (soweit möglich) für Menschen lesbare Formate zu verwenden.  Unser Programm hier wird sehr einfach sein, um Grenzsituationen zu vermeiden und nicht abgelenkt zu werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Filename: add.c int add(int a, int b) { return a*a + b; }</span></span></code> </pre> <br>  Was für eine großartige technische Leistung!  Vor allem, weil das Programm <i>add</i> heißt, aber in Wirklichkeit nichts <i>hinzufügt</i> (nicht hinzufügt).  Noch wichtiger: Das Programm verwendet nicht die Standardbibliothek und von den hier genannten Typen nur 'int'. <br><br><h3>  C in eine interne LLVM-Ansicht verwandeln </h3><br>  Der erste Schritt besteht darin, unser C-Programm in LLVM IR umzuwandeln.  Dies ist die Aufgabe des <code>clang</code> Frontend-Compilers, der mit LLVM installiert wird: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ <span class="hljs-comment"><span class="hljs-comment"># Target WebAssembly -emit-llvm \ # Emit LLVM IR (instead of host machine code) -c \ # Only compile, no linking just yet -S \ # Emit human-readable assembly rather than binary add.c</span></span></code> </pre> <br>  Als Ergebnis erhalten wir <code>add.ll</code> mit einer internen Darstellung von LLVM IR.  <b>Ich zeige es nur der Vollständigkeit halber</b> .  Wenn Sie mit WebAssembly arbeiten oder sogar klirren, werden Sie als C-Entwickler niemals mit LLVM IR in Kontakt kommen. <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'add.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"add.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:ep:32:32-i64:64-n32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"wasm32"</span></span> ; Function Attrs: norecurse nounwind readnone define hidden i32 @add(i32, i32) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">3</span></span> = mul nsw i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = add nsw i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">4</span></span> } attributes #<span class="hljs-number"><span class="hljs-number">0</span></span> = { norecurse nounwind readnone <span class="hljs-string"><span class="hljs-string">"correctly-rounded-divide-sqrt-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"disable-tail-calls"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"less-precise-fpmad"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"min-legal-vector-width"</span></span>=<span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-string"><span class="hljs-string">"no-frame-pointer-elim"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-infs-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-jump-tables"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-nans-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-signed-zeros-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-trapping-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"stack-protector-buffer-size"</span></span>=<span class="hljs-string"><span class="hljs-string">"8"</span></span> <span class="hljs-string"><span class="hljs-string">"target-cpu"</span></span>=<span class="hljs-string"><span class="hljs-string">"generic"</span></span> <span class="hljs-string"><span class="hljs-string">"unsafe-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"use-soft-float"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> } !llvm.<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.flags = !{!<span class="hljs-number"><span class="hljs-number">0</span></span>} !llvm.ident = !{!<span class="hljs-number"><span class="hljs-number">1</span></span>} !<span class="hljs-number"><span class="hljs-number">0</span></span> = !{i32 <span class="hljs-number"><span class="hljs-number">1</span></span>, !<span class="hljs-string"><span class="hljs-string">"wchar_size"</span></span>, i32 <span class="hljs-number"><span class="hljs-number">4</span></span>} !<span class="hljs-number"><span class="hljs-number">1</span></span> = !{!<span class="hljs-string"><span class="hljs-string">"clang version 8.0.0 (tags/RELEASE_800/final)"</span></span>}</code> </pre> <br>  <i>LLVM IR ist voll von zusätzlichen Metadaten und Anmerkungen, die es dem Compiler ermöglichen, fundiertere Entscheidungen beim Generieren von Maschinencode zu treffen.</i> <br><br><h3>  Verwandeln Sie LLVM IR in Objektdateien </h3><br>  Der nächste Schritt besteht darin, den <code>llc</code> Backend-Compiler <code>llc</code> , um aus der internen Darstellung eine Objektdatei zu erstellen. <br><br>  Die <code>add.o</code> ist bereits ein gültiges WebAssembly-Modul, das den gesamten kompilierten Code unserer C-Datei enthält. In der Regel können Sie jedoch keine Objektdateien ausführen, da ihnen wesentliche Teile fehlen. <br><br>  Wenn wir <code>-filetype=obj</code> im Befehl <code>-filetype=obj</code> , erhalten wir den LLVM-Assembler für WebAssembly, ein für Menschen lesbares Format, das WAT etwas ähnlich ist.  Das <code>llvm-mc</code> Tool zum Arbeiten mit solchen Dateien unterstützt das Format jedoch noch nicht vollständig und kann häufig keine Dateien verarbeiten.  Daher zerlegen wir die Objektdateien nachträglich.  Zum Überprüfen dieser Objektdateien wird ein spezielles Tool benötigt.  Im Fall von WebAssembly war es <code>wasm-objdump</code> , Teil des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAssembly Binary Toolkit</a> oder kurz wabt. <br><br><pre> <code class="bash hljs">$ brew install wabt <span class="hljs-comment"><span class="hljs-comment"># in case you haven't $ wasm-objdump -x add.o add.o: file format wasm 0x1 Section Details: Type[1]: - type[0] (i32, i32) -&gt; i32 Import[3]: - memory[0] pages: initial=0 &lt;- env.__linear_memory - table[0] elem_type=funcref init=0 max=0 &lt;- env.__indirect_function_table - global[0] i32 mutable=1 &lt;- env.__stack_pointer Function[1]: - func[0] sig=0 &lt;add&gt; Code[1]: - func[0] size=75 &lt;add&gt; Custom: - name: "linking" - symbol table [count=2] - 0: F &lt;add&gt; func=0 binding=global vis=hidden - 1: G &lt;env.__stack_pointer&gt; global=0 undefined binding=global vis=default Custom: - name: "reloc.CODE" - relocations for section: 3 (Code) [1] R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x000080) symbol=1 &lt;env.__stack_pointer&gt;</span></span></code> </pre> <br>  Die Ausgabe zeigt, dass sich unsere Funktion add () in diesem Modul befindet, enthält jedoch auch <i>benutzerdefinierte</i> Abschnitte mit Metadaten und überraschenderweise mehrere Importe.  In der nächsten Phase der <i>Verknüpfung werden</i> benutzerdefinierte Abschnitte analysiert und gelöscht, und der Linker (Linker) übernimmt den Import. <br><br><h3>  Layout </h3><br>  Traditionell besteht die Aufgabe des Linkers darin, mehrere Objektdateien zu einer ausführbaren Datei zusammenzufügen.  Der LLVM-Linker heißt <code>lld</code> und wird mit dem <code>lld</code> aufgerufen.  Für WebAssembly war dies <code>wasm-ld</code> . <br><br><pre> <code class="bash hljs">wasm-ld \ --no-entry \ <span class="hljs-comment"><span class="hljs-comment"># We don't have an entry function --export-all \ # Export everything (for now) -o add.wasm \ add.o</span></span></code> </pre> <br>  Das Ergebnis ist ein WebAssembly-Modul mit einer Größe von 262 Byte. <br><br><h3>  Starten </h3><br>  Das Wichtigste ist natürlich, dass alles <i>wirklich</i> funktioniert.  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel</a> können Sie dieses WebAssembly-Modul mit einigen Zeilen eingebetteten JavaScript laden und ausführen. <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(instance.exports.add(</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">)); } init(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Wenn alles in Ordnung ist, sehen Sie die Nummer 17 in der DevTool-Konsole. <b>Wir haben gerade C erfolgreich in WebAssembly kompiliert, ohne Emscripten zu berühren.</b>  Es ist auch erwähnenswert, dass es keine Middleware zum Konfigurieren und Laden des WebAssembly-Moduls gibt. <br><br><h1>  Das Kompilieren von C ist etwas einfacher </h1><br>  Um C in WebAssembly zu kompilieren, haben wir viele Schritte unternommen.  Wie gesagt, wir haben zu Bildungszwecken alle Phasen im Detail untersucht.  Überspringen wir für Menschen lesbare Zwischenformate und wenden den C-Compiler sofort als Schweizer Taschenmesser an, wie er entwickelt wurde: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -nostdlib \ <span class="hljs-comment"><span class="hljs-comment"># Don't try and link against a standard library -Wl,--no-entry \ # Flags passed to the linker -Wl,--export-all \ -o add.wasm \ add.c</span></span></code> </pre> <br>  Hier erhalten wir die gleiche <code>.wasm</code> Datei, jedoch mit einem Befehl. <br><br><h1>  Optimierung </h1><br>  Schauen Sie sich das WAT unseres WebAssembly-Moduls an, indem Sie <code>wasm2wat</code> : <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) (local i32 i32 i32 i32 i32 i32 i32 i32) global.get 0 local.set 2 i32.const 16 local.set 3 local.get 2 local.get 3 i32.sub local.set 4 local.get 4 local.get 0 i32.store offset=12 local.get 4 local.get 1 i32.store offset=8 local.get 4 i32.load offset=12 local.set 5 local.get 4 i32.load offset=12 local.set 6 local.get 5 local.get 6 i32.mul local.set 7 local.get 4 i32.load offset=8 local.set 8 local.get 7 local.get 8 i32.add local.set 9 local.get 9 return) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br>  Wow, was für ein großartiger Code.  Zu meiner Überraschung verwendet das Modul Speicher (wie aus den <code>i32.store</code> <code>i32.load</code> und <code>i32.store</code> ), acht lokale und mehrere globale Variablen.  Wahrscheinlich können Sie manuell eine präzisere Version schreiben.  Dieses Programm ist so groß, weil wir keine Optimierungen vorgenommen haben.  Lass es uns tun: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ + -O3 \ <span class="hljs-comment"><span class="hljs-comment"># Agressive optimizations + -flto \ # Add metadata for link-time optimizations -nostdlib \ -Wl,--no-entry \ -Wl,--export-all \ + -Wl,--lto-O3 \ # Aggressive link-time optimizations -o add.wasm \ add.c</span></span></code> </pre> <br><blockquote>  <b>Hinweis:</b> Technisch gesehen bietet die Layoutoptimierung (LTO) keine Vorteile, da wir nur eine Datei erstellen.  In großen Projekten hilft LTO dabei, die Dateigröße erheblich zu reduzieren. </blockquote>  Nach dem Ausführen dieser Befehle wurde die <code>.wasm</code> Datei von 262 auf 197 Byte verringert, und WAT wurde auch viel einfacher: <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) local.get 0 local.get 0 i32.mul local.get 1 i32.add) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br><h1>  Rufen Sie die Standardbibliothek auf </h1><br>  Die Verwendung von C ohne die Standardbibliothek libc erscheint eher unhöflich.  Es ist logisch, es hinzuzufügen, aber ich werde ehrlich sein: Es wird <i>nicht</i> einfach sein.  <b>Tatsächlich rufen wir keine libc-Bibliotheken im Artikel direkt auf</b> .  Es gibt mehrere geeignete, insbesondere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Glibc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mussl</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dietlibc</a> .  Die meisten dieser Bibliotheken sollen jedoch unter dem POSIX-Betriebssystem ausgeführt werden, das bestimmte Systemaufrufe implementiert.  Da wir in JavaScript keine Kernel-Oberfläche haben, müssen wir diese POSIX-Systemaufrufe selbst implementieren, wahrscheinlich über JavaScript.  Dies ist eine schwierige Aufgabe und ich werde sie hier nicht erledigen.  Die gute Nachricht ist, dass <b>Emscripten dies für Sie tut</b> . <br><br>  Natürlich sind nicht alle libc-Funktionen auf Systemaufrufe angewiesen.  Funktionen wie <code>strlen()</code> , <code>sin()</code> oder sogar <code>memset()</code> sind in einfachem C implementiert. Dies bedeutet, dass Sie diese Funktionen verwenden oder ihre Implementierung einfach aus einer der genannten Bibliotheken kopieren / einfügen können. <br><br><h1>  Dynamischer Speicher </h1><br>  Ohne libc stehen uns C-Grundschnittstellen wie <code>malloc()</code> und <code>free()</code> nicht zur Verfügung.  Im nicht optimierten WAT haben wir gesehen, dass der Compiler bei Bedarf Speicher verwendet.  Dies bedeutet, dass wir den Speicher nicht einfach so verwenden können, wie wir möchten, ohne das Risiko einzugehen, ihn zu beschädigen.  Sie müssen verstehen, wie es verwendet wird. <br><br><h3>  LLVM-Speichermodelle </h3><br>  Die WebAssembly-Speichersegmentierungsmethode wird erfahrene Programmierer ein wenig überraschen.  Erstens ist in WebAssembly eine Nulladresse technisch zulässig, wird jedoch häufig immer noch als Fehler behandelt.  Zweitens kommt der Stapel zuerst und wächst nach unten (zu niedrigeren Adressen), und der Heap erscheint später und wächst nach oben.  Der Grund dafür ist, dass der Speicher von WebAssembly zur Laufzeit zunehmen kann.  Dies bedeutet, dass es kein festes Ende gibt, um den Stapel oder den Heap aufzunehmen. <br><br>  Hier ist das <code>wasm-ld</code> Layout: <br><br><img src="https://habrastorage.org/webt/kz/xv/z6/kzxvz60tlxzqdv_9tvxlm4m3gca.png"><br><br>  <i><font color="gray">Der Stapel wächst nach unten und der Haufen wächst nach oben.</font></i>  <i><font color="gray">Der Stack beginnt mit <code>__data_end</code> und der Heap <code>__heap_base</code> mit <code>__heap_base</code> .</font></i>  <i><font color="gray">Da der Stapel an erster Stelle steht, ist er durch die maximale Größe begrenzt, die während der Kompilierung festgelegt wurde, d. H. <code>__heap_base</code> minus <code>__data_end</code></font></i> <br><br>  Wenn wir uns den globalen Abschnitt in unserem WAT ansehen, finden wir folgende Werte: <code>__heap_base</code> auf 66560 und <code>__data_end</code> auf 1024 festgelegt. Dies bedeutet, dass der Stapel auf maximal 64 KiB wachsen kann, was nicht viel ist.  Glücklicherweise können Sie mit <code>wasm-ld</code> diesen Wert ändern: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -O3 \ -flto \ -nostdlib \ -Wl,--no-entry \ -Wl,--<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>-all \ -Wl,--lto-O3 \ + -Wl,-z,stack-size=$[8 * 1024 * 1024] \ <span class="hljs-comment"><span class="hljs-comment"># Set maximum stack size to 8MiB -o add.wasm \ add.c</span></span></code> </pre> <br><h3>  Allokatorbaugruppe </h3><br>  Es ist bekannt, dass der Heap-Bereich mit <code>__heap_base</code> .  Da die Funktion <code>malloc()</code> fehlt, wissen wir, dass der nächste Speicherbereich sicher verwendet werden kann.  Wir können die Daten dort platzieren, wie wir möchten, und es besteht kein Grund zur Angst vor Speicherbeschädigung, da der Stapel in die andere Richtung wächst.  Ein für alle kostenloser Heap kann jedoch schnell verstopfen, sodass normalerweise eine Art dynamisches Speichermanagement erforderlich ist.  Eine Möglichkeit besteht darin, eine vollständige Implementierung von malloc () zu übernehmen, beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Malloc-Implementierung von Doug Lee</a> , die in Emscripten verwendet wird.  Es gibt mehrere weitere kleine Implementierungen mit verschiedenen Kompromissen. <br><br>  Aber warum nicht dein eigenes <code>malloc()</code> schreiben?  Wir sind so tief verwurzelt, dass es keinen Unterschied macht.  Eines der einfachsten ist ein Bump Allocator: Es ist superschnell, extrem klein und einfach zu implementieren.  Es gibt jedoch einen Nachteil: Sie können keinen Speicher freigeben.  Obwohl ein solcher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allokator</a> auf den ersten Blick unglaublich nutzlos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erscheint,</a> bin ich bei der Entwicklung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Squoosh</a> auf Präzedenzfälle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gestoßen, bei</a> denen dies eine ausgezeichnete Wahl wäre.  Das Konzept eines Bump-Allokators besteht darin, dass wir die Startadresse des nicht verwendeten Speichers als global speichern.  Wenn das Programm <code>n</code> Bytes Speicher anfordert, verschieben wir den Marker auf <code>n</code> und geben den vorherigen Wert zurück: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_base; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bump_pointer = &amp;__heap_base; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = bump_pointer; bump_pointer += n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// lol }</span></span></code> </pre> <br>  Die globalen Variablen von WAT werden tatsächlich von <code>wasm-ld</code> , sodass wir von unserem C-Code aus als normale Variablen darauf zugreifen können, wenn wir sie <code>extern</code> deklarieren.  Also haben <b>wir gerade unser eigenes <code>malloc()</code> ... in fünf Zeilen von C.</b> <br><br><blockquote>  <b>Hinweis:</b> Unser Bump Allocator ist nicht vollständig mit <code>malloc()</code> von C kompatibel. Beispielsweise geben wir keine Ausrichtungsgarantien.  Aber es funktioniert gut genug, also ... </blockquote><h3>  Dynamische Speichernutzung </h3><br>  Zum Testen erstellen wir eine Funktion C, die ein Array von Zahlen beliebiger Größe verwendet und die Summe berechnet.  Nicht sehr interessant, aber dies zwingt uns, dynamischen Speicher zu verwenden, da wir die Größe des Arrays während der Montage nicht kennen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { sum += a[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Die sum () -Funktion ist hoffentlich ziemlich einfach.  Eine interessantere Frage ist, wie ein Array von JavaScript an WebAssembly übergeben wird. Schließlich versteht WebAssembly nur Zahlen.  Die allgemeine Idee ist, mit <code>malloc()</code> <i>aus JavaScript</i> einen Speicherplatz zuzuweisen, die Werte dort zu kopieren und die Adresse (Nummer!) Zu übergeben, an der sich <i>das</i> Array befindet: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> jsArray = [</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">2</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">3</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">5</span></span></span><span class="javascript">]; </span><span class="hljs-comment"><span class="javascript"><span class="hljs-comment">// Allocate memory for 5 32-bit integers // and return get starting address. const cArrayPointer = instance.exports.malloc(jsArray.length * 4); // Turn that sequence of 32-bit integers // into a Uint32Array, starting at that address. const cArray = new Uint32Array( instance.exports.memory.buffer, cArrayPointer, jsArray.length ); // Copy the values from JS to C. cArray.set(jsArray); // Run the function, passing the starting address and length. console.log(instance.exports.sum(cArrayPointer, cArray.length)); } init(); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Nach dem Start sollte die Antwort 15 in der DevTools-Konsole angezeigt werden. Dies ist die Summe aller Zahlen von 1 bis 5. <br><br><h1>  Fazit </h1><br>  Sie lesen also bis zum Ende.  Glückwunsch!  Auch hier ist alles in Ordnung, wenn Sie sich etwas überlastet fühlen.  <b>Es ist nicht notwendig, alle Details zu lesen.</b>  <b>Das Verständnis dieser Informationen ist für einen guten Webentwickler völlig optional und für die hervorragende Verwendung von WebAssembly nicht einmal erforderlich</b> .  Aber ich wollte diese Informationen teilen, weil Sie so die ganze Arbeit, die ein Projekt wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emscripten</a> für Sie leistet, wirklich schätzen können.  Gleichzeitig erhalten Sie ein Verständnis dafür, wie klein die rein rechnerischen Module von WebAssembly sein können.  Das Wasm-Modul zum Summieren des Arrays ist nur 230 Byte groß, <i>einschließlich eines dynamischen Speicherzuweisers</i> .  Wenn Sie denselben Code mit Emscripten kompilieren, werden 100 Byte WebAssembly-Code und 11 KB JavaScript-Verknüpfungscode erzeugt.  Wir müssen es für ein solches Ergebnis versuchen, aber es gibt Situationen, in denen es sich lohnt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454868/">https://habr.com/ru/post/de454868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454844/index.html">Odigest: interessant für Designer der Woche</a></li>
<li><a href="../de454850/index.html">Die Entwicklung eines einzelnen Algorithmus</a></li>
<li><a href="../de454856/index.html">Wir analysieren Schwachstellen bei der Validierung von SSL / TLS-Zertifikaten in Nicht-Browser-Software</a></li>
<li><a href="../de454860/index.html">Lassen Sie uns QueryProvider beim Umgang mit interpolierten Zeichenfolgen unterstützen</a></li>
<li><a href="../de454864/index.html">Wie sind die Entwicklungsprozesse in verschiedenen Unternehmen</a></li>
<li><a href="../de454872/index.html">Space Invaders: jetzt in 512 Bytes (Assembler x86)</a></li>
<li><a href="../de454874/index.html">Ein bisschen über Multitasking in Mikrocontrollern</a></li>
<li><a href="../de454876/index.html">Über das Entwerfen eines flexiblen Systems von Charakterfähigkeiten in Spielen</a></li>
<li><a href="../de454878/index.html">Wir studieren MITRE ATT & CK. Mobile Matrizen: Gerätezugriff. Teil 3</a></li>
<li><a href="../de454880/index.html">"Nebensaison" im Leben eines Freiberuflers: Wie kann man überleben und überleben?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>