<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèº üõèÔ∏è üïå Consultas paralelas en PostgreSQL üç• ü§≥üèª ‚öúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay muchos n√∫cleos en las CPU modernas. Durante a√±os, las aplicaciones han enviado consultas a bases de datos en paralelo. Si se trata de una consulta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Consultas paralelas en PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/446706/"><p><img src="https://habrastorage.org/webt/kx/ht/dl/kxhtdlsry_f8p1jv2ve_1ziks7e.jpeg"></p><br><p>  Hay muchos n√∫cleos en las CPU modernas.  Durante a√±os, las aplicaciones han enviado consultas a bases de datos en paralelo.  Si se trata de una consulta de informes para varias filas en una tabla, se ejecuta m√°s r√°pido cuando usa m√∫ltiples CPU, y en PostgreSQL es posible a partir de la versi√≥n 9.6. </p><br><p>  Me llev√≥ 3 a√±os implementar la funci√≥n de consulta paralela. Tuve que reescribir el c√≥digo en diferentes etapas de la ejecuci√≥n de la consulta.  PostgreSQL 9.6 introdujo una infraestructura para mejorar a√∫n m√°s el c√≥digo.  En versiones posteriores, otros tipos de consultas se ejecutan en paralelo. </p><a name="habracut"></a><br><h3 id="ogranicheniya">  Limitaciones </h3><br><ul><li>  No habilite la ejecuci√≥n paralela si todos los n√∫cleos ya est√°n ocupados, de lo contrario, otras solicitudes se ralentizar√°n. </li><li>  Lo m√°s importante es que el procesamiento en paralelo con valores altos de WORK_MEM consume mucha memoria: cada hash join u sort ocupa memoria en la cantidad de work_mem. </li><li>  Las solicitudes OLTP de baja latencia no pueden acelerarse mediante ejecuci√≥n paralela.  Y si la consulta devuelve una fila, el procesamiento paralelo solo la ralentizar√°. </li><li>  A los desarrolladores les gusta usar el punto de referencia TPC-H.  Quiz√°s tenga consultas similares para una ejecuci√≥n paralela perfecta. </li><li>  Solo las consultas SELECT sin bloqueos de predicado se ejecutan en paralelo. </li><li>  A veces, la indexaci√≥n correcta es mejor que los escaneos de tablas secuenciales en paralelo. </li><li>  Suspender consultas y cursores no son compatibles. </li><li>  Las funciones de ventana y las funciones agregadas de conjuntos ordenados no son paralelas. </li><li>  No gana nada en la carga de trabajo de E / S. </li><li>  No hay algoritmos de clasificaci√≥n paralelos.  Pero las consultas ordenadas se pueden ejecutar en paralelo en algunos aspectos. </li><li>  Reemplace CTE (WITH ...) con un SELECT anidado para habilitar el procesamiento en paralelo. </li><li>  Los contenedores de datos de terceros a√∫n no admiten el procesamiento paralelo (¬°pero podr√≠an hacerlo!) </li><li>  FULL OUTER JOIN no es compatible. </li><li>  max_rows deshabilita el procesamiento paralelo. </li><li>  Si la solicitud tiene una funci√≥n que no est√° marcada como PARALELO SEGURO, ser√° de un solo subproceso. </li><li>  El nivel de aislamiento de transacci√≥n SERIALIZABLE deshabilita el procesamiento paralelo. </li></ul><br><h3 id="testovaya-sreda">  Entorno de prueba </h3><br><p>  Los desarrolladores de PostgreSQL han intentado reducir el tiempo de respuesta de las consultas de referencia TPC-H.  Descargue el punto de referencia y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ad√°ptelo a PostgreSQL</a> .  Este es un uso no oficial del punto de referencia TPC-H, no para comparar bases de datos o hardware. </p><br><ol><li>  Descargue TPC-H_Tools_v2.17.3.zip (o una versi√≥n m√°s reciente) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del TPC externo</a> . </li><li>  Cambie el nombre de makefile.suite a Makefile y c√°mbielo como se describe aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/tvondra/pg_tpch</a> .  Compile el c√≥digo con el comando make. </li><li> Generar datos: <code>./dbgen -s 10</code> crea una base de datos de 23 GB.  Esto es suficiente para ver la diferencia en el rendimiento de las consultas paralelas y no paralelas. </li><li>  Convierte archivos <code>tbl</code> a <code>csv  for</code> y <code>sed</code> . </li><li>  Clone el repositorio pg_tpch y copie los <code>csv</code> a <code>pg_tpch/dss/data</code> . </li><li>  Crea consultas con el comando <code>qgen</code> . </li><li>  Suba datos a la base de datos con el comando <code>./tpch.sh</code> . </li></ol><br><h3 id="parallelnoe-posledovatelnoe-skanirovanie">  Exploraci√≥n secuencial paralela </h3><br><p>  Puede ser m√°s r√°pido no debido a la lectura paralela, sino a que los datos est√°n dispersos en muchos n√∫cleos de CPU.  En los sistemas operativos modernos, los archivos de datos PostgreSQL est√°n bien almacenados en cach√©.  Con la lectura anticipada, puede obtener m√°s del almacenamiento que las solicitudes del demonio PG.  Por lo tanto, el rendimiento de la consulta no est√° limitado por la E / S de disco.  Consume ciclos de CPU para: </p><br><ul><li>  lea las l√≠neas una por una de las p√°ginas de la tabla; </li><li>  Compare los valores de cadena y las cl√°usulas <code>WHERE</code> . </li></ul><br><p>  Ejecutemos una consulta de <code>select</code> simple: </p><br><pre> <code class="plaintext hljs">tpch=# explain analyze select l_quantity as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day; QUERY PLAN -------------------------------------------------------------------------------------------------------------------------- Seq Scan on lineitem (cost=0.00..1964772.00 rows=58856235 width=5) (actual time=0.014..16951.669 rows=58839715 loops=1) Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone) Rows Removed by Filter: 1146337 Planning Time: 0.203 ms Execution Time: 19035.100 ms</code> </pre> <br><p>  Una exploraci√≥n secuencial produce demasiadas filas sin agregaci√≥n, por lo que la solicitud la ejecuta un solo n√∫cleo de CPU. </p><br><p>  Si agrega <code>SUM()</code> , ver√° que dos flujos de trabajo ayudar√°n a acelerar la solicitud: </p><br><pre> <code class="plaintext hljs">explain analyze select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------------------------- Finalize Aggregate (cost=1589702.14..1589702.15 rows=1 width=32) (actual time=8553.365..8553.365 rows=1 loops=1) -&gt; Gather (cost=1589701.91..1589702.12 rows=2 width=32) (actual time=8553.241..8555.067 rows=3 loops=1) Workers Planned: 2 Workers Launched: 2 -&gt; Partial Aggregate (cost=1588701.91..1588701.92 rows=1 width=32) (actual time=8547.546..8547.546 rows=1 loops=3) -&gt; Parallel Seq Scan on lineitem (cost=0.00..1527393.33 rows=24523431 width=5) (actual time=0.038..5998.417 rows=19613238 loops=3) Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone) Rows Removed by Filter: 382112 Planning Time: 0.241 ms Execution Time: 8555.131 ms</code> </pre> <br><h3 id="parallelnaya-agregaciya">  Agregaci√≥n Paralela </h3><br><p>  El nodo Parallel Seq Scan produce cadenas para la agregaci√≥n parcial.  El nodo Agregado parcial trunca estas l√≠neas usando <code>SUM()</code> .  Al final, el contador Gather recopila el contador SUMA de cada flujo de trabajo. </p><br><p>  El resultado final se calcula mediante el nodo "Finalizar agregado".  Si tiene sus propias funciones de agregaci√≥n, aseg√∫rese de marcarlas como "seguridad paralela". </p><br><h3 id="kolichestvo-rabochih-processov">  Cantidad de flujos de trabajo </h3><br><p>  La cantidad de flujos de trabajo se puede aumentar sin reiniciar el servidor: </p><br><pre> <code class="plaintext hljs">alter system set max_parallel_workers_per_gather=4; select * from pg_reload_conf();</code> </pre> <br><p>  Ahora vemos 4 trabajadores en la salida de explicaci√≥n: </p><br><pre> <code class="plaintext hljs">tpch=# explain analyze select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------------------------- Finalize Aggregate (cost=1440213.58..1440213.59 rows=1 width=32) (actual time=5152.072..5152.072 rows=1 loops=1) -&gt; Gather (cost=1440213.15..1440213.56 rows=4 width=32) (actual time=5151.807..5153.900 rows=5 loops=1) Workers Planned: 4 Workers Launched: 4 -&gt; Partial Aggregate (cost=1439213.15..1439213.16 rows=1 width=32) (actual time=5147.238..5147.239 rows=1 loops=5) -&gt; Parallel Seq Scan on lineitem (cost=0.00..1402428.00 rows=14714059 width=5) (actual time=0.037..3601.882 rows=11767943 loops=5) Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone) Rows Removed by Filter: 229267 Planning Time: 0.218 ms Execution Time: 5153.967 ms</code> </pre> <br><p>  ¬øQu√© est√° pasando aqu√≠?  Hubo 2 veces m√°s flujos de trabajo, y la solicitud fue solo 1.6599 veces m√°s r√°pida.  Los c√°lculos son interesantes.  Tuvimos 2 procesos de trabajo y 1 l√≠der.  Despu√©s del cambio, se convirti√≥ en 4 + 1. </p><br><p>  Nuestra aceleraci√≥n m√°xima del procesamiento en paralelo: 5/3 = 1.66 (6) veces. </p><br><h2 id="kak-eto-rabotaet">  Como funciona </h2><br><h3 id="processy">  Los procesos </h3><br><p>  La ejecuci√≥n de una solicitud siempre comienza con un proceso l√≠der.  El l√≠der hace todo lo que no es paralelo y parte del procesamiento paralelo.  Otros procesos que realizan las mismas solicitudes se denominan flujos de trabajo.  El procesamiento en paralelo utiliza una infraestructura de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">flujos de trabajo din√°micos en segundo plano</a> (desde la versi√≥n 9.4).  Dado que otras partes de PostgreSQL usan procesos en lugar de hilos, una consulta con 3 flujos de trabajo podr√≠a ser 4 veces m√°s r√°pida que el procesamiento tradicional. </p><br><h3 id="vzaimodeystvie">  Interacci√≥n </h3><br><p>  Los flujos de trabajo se comunican con el l√≠der a trav√©s de una cola de mensajes (basada en la memoria compartida).  Cada proceso tiene 2 colas: para errores y para tuplas. </p><br><h3 id="skolko-nuzhno-rabochih-processov">  ¬øCu√°ntos procesos de trabajo necesitas? </h3><br><p>  El l√≠mite m√≠nimo lo establece el par√°metro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>max_parallel_workers_per_gather</code></a> .  Luego, el ejecutor de consultas toma flujos de trabajo del grupo limitado por el par√°metro de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>max_parallel_workers size</code></a> .  La √∫ltima limitaci√≥n es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>max_worker_processes</code></a> , es decir, el n√∫mero total de procesos en segundo plano. </p><br><p>  Si no fue posible asignar un flujo de trabajo, el procesamiento ser√° de un solo proceso. </p><br><p>  El planificador de consultas puede reducir los flujos de trabajo seg√∫n el tama√±o de la tabla o √≠ndice.  Hay par√°metros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>min_parallel_table_scan_size</code></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>min_parallel_index_scan_size</code></a> para esto. </p><br><pre> <code class="plaintext hljs">set min_parallel_table_scan_size='8MB' 8MB table =&gt; 1 worker 24MB table =&gt; 2 workers 72MB table =&gt; 3 workers x =&gt; log(x / min_parallel_table_scan_size) / log(3) + 1 worker</code> </pre> <br><p>  Cada vez que una tabla es 3 veces m√°s grande que <code>min_parallel_(index|table)_scan_size</code> , Postgres agrega un flujo de trabajo.  El n√∫mero de procesos de trabajo no se basa en el costo.  La dependencia circular complica las implementaciones complejas.  En cambio, el planificador usa reglas simples. </p><br><p>  En la pr√°ctica, estas reglas no siempre son adecuadas para la producci√≥n, por lo que puede cambiar el n√∫mero de flujos de trabajo para una tabla en particular: ALTER TABLE ... SET ( <code>parallel_workers = N</code> ). </p><br><h3 id="pochemu-parallelnaya-obrabotka-ne-ispolzuetsya">  ¬øPor qu√© no se usa el procesamiento paralelo? </h3><br><p>  Adem√°s de una larga lista de restricciones, tambi√©n hay controles de costos: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>parallel_setup_cost</code></a> : prescindir del procesamiento paralelo de solicitudes cortas.  Este par√°metro estima el tiempo para preparar la memoria, iniciar el proceso y el intercambio de datos inicial. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>parallel_tuple_cost</code></a> : la comunicaci√≥n entre un l√≠der y los trabajadores puede retrasarse en proporci√≥n al n√∫mero de tuplas de los procesos de trabajo.  Este par√°metro calcula los costos de intercambio de datos. </p><br><h3 id="soedineniya-vlozhennyh-ciklov--nested-loop-join">  Uni√≥n de bucle anidado </h3><br><pre> <code class="plaintext hljs">PostgreSQL 9.6+      ‚Äî   . explain (costs off) select c_custkey, count(o_orderkey) from customer left outer join orders on c_custkey = o_custkey and o_comment not like '%special%deposits%' group by c_custkey; QUERY PLAN -------------------------------------------------------------------------------------- Finalize GroupAggregate Group Key: customer.c_custkey -&gt; Gather Merge Workers Planned: 4 -&gt; Partial GroupAggregate Group Key: customer.c_custkey -&gt; Nested Loop Left Join -&gt; Parallel Index Only Scan using customer_pkey on customer -&gt; Index Scan using idx_orders_custkey on orders Index Cond: (customer.c_custkey = o_custkey) Filter: ((o_comment)::text !~~ '%special%deposits%'::text)</code> </pre> <br><p>  La recolecci√≥n se lleva a cabo en la √∫ltima etapa, por lo que la uni√≥n izquierda del bucle anidado es una operaci√≥n paralela.  La exploraci√≥n de solo √≠ndice paralelo apareci√≥ solo en la versi√≥n 10. Funciona de manera similar a la exploraci√≥n en serie paralela.  La condici√≥n <code>c_custkey = o_custkey</code> lee un pedido para cada l√≠nea de cliente.  Entonces no es paralelo. </p><br><h3 id="hesh-soedinenie--hash-join">  Hash Join - Hash Join </h3><br><p>  Cada flujo de trabajo crea su propia tabla hash antes de PostgreSQL 11. Y si hay m√°s de cuatro de estos procesos, el rendimiento no mejorar√°.  En la nueva versi√≥n, la tabla hash se comparte.  Cada flujo de trabajo puede usar WORK_MEM para crear una tabla hash. </p><br><pre> <code class="plaintext hljs">select l_shipmode, sum(case when o_orderpriority = '1-URGENT' or o_orderpriority = '2-HIGH' then 1 else 0 end) as high_line_count, sum(case when o_orderpriority &lt;&gt; '1-URGENT' and o_orderpriority &lt;&gt; '2-HIGH' then 1 else 0 end) as low_line_count from orders, lineitem where o_orderkey = l_orderkey and l_shipmode in ('MAIL', 'AIR') and l_commitdate &lt; l_receiptdate and l_shipdate &lt; l_commitdate and l_receiptdate &gt;= date '1996-01-01' and l_receiptdate &lt; date '1996-01-01' + interval '1' year group by l_shipmode order by l_shipmode LIMIT 1; QUERY PLAN ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=1964755.66..1964961.44 rows=1 width=27) (actual time=7579.592..7922.997 rows=1 loops=1) -&gt; Finalize GroupAggregate (cost=1964755.66..1966196.11 rows=7 width=27) (actual time=7579.590..7579.591 rows=1 loops=1) Group Key: lineitem.l_shipmode -&gt; Gather Merge (cost=1964755.66..1966195.83 rows=28 width=27) (actual time=7559.593..7922.319 rows=6 loops=1) Workers Planned: 4 Workers Launched: 4 -&gt; Partial GroupAggregate (cost=1963755.61..1965192.44 rows=7 width=27) (actual time=7548.103..7564.592 rows=2 loops=5) Group Key: lineitem.l_shipmode -&gt; Sort (cost=1963755.61..1963935.20 rows=71838 width=27) (actual time=7530.280..7539.688 rows=62519 loops=5) Sort Key: lineitem.l_shipmode Sort Method: external merge Disk: 2304kB Worker 0: Sort Method: external merge Disk: 2064kB Worker 1: Sort Method: external merge Disk: 2384kB Worker 2: Sort Method: external merge Disk: 2264kB Worker 3: Sort Method: external merge Disk: 2336kB -&gt; Parallel Hash Join (cost=382571.01..1957960.99 rows=71838 width=27) (actual time=7036.917..7499.692 rows=62519 loops=5) Hash Cond: (lineitem.l_orderkey = orders.o_orderkey) -&gt; Parallel Seq Scan on lineitem (cost=0.00..1552386.40 rows=71838 width=19) (actual time=0.583..4901.063 rows=62519 loops=5) Filter: ((l_shipmode = ANY ('{MAIL,AIR}'::bpchar[])) AND (l_commitdate &lt; l_receiptdate) AND (l_shipdate &lt; l_commitdate) AND (l_receiptdate &gt;= '1996-01-01'::date) AND (l_receiptdate &lt; '1997-01-01 00:00:00'::timestamp without time zone)) Rows Removed by Filter: 11934691 -&gt; Parallel Hash (cost=313722.45..313722.45 rows=3750045 width=20) (actual time=2011.518..2011.518 rows=3000000 loops=5) Buckets: 65536 Batches: 256 Memory Usage: 3840kB -&gt; Parallel Seq Scan on orders (cost=0.00..313722.45 rows=3750045 width=20) (actual time=0.029..995.948 rows=3000000 loops=5) Planning Time: 0.977 ms Execution Time: 7923.770 ms</code> </pre> <br><p>  La solicitud 12 de TPC-H ilustra una conexi√≥n de hash paralela.  Cada flujo de trabajo participa en la creaci√≥n de una tabla hash compartida. </p><br><h3 id="soedinenie-sliyaniem--merge-join">  Fusionar unirse </h3><br><p>  Una combinaci√≥n de fusi√≥n no es paralela en la naturaleza.  No se preocupe si esta es la √∫ltima etapa de la solicitud, a√∫n puede ejecutarse en paralelo. </p><br><pre> <code class="plaintext hljs">-- Query 2 from TPC-H explain (costs off) select s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment from part, supplier, partsupp, nation, region where p_partkey = ps_partkey and s_suppkey = ps_suppkey and p_size = 36 and p_type like '%BRASS' and s_nationkey = n_nationkey and n_regionkey = r_regionkey and r_name = 'AMERICA' and ps_supplycost = ( select min(ps_supplycost) from partsupp, supplier, nation, region where p_partkey = ps_partkey and s_suppkey = ps_suppkey and s_nationkey = n_nationkey and n_regionkey = r_regionkey and r_name = 'AMERICA' ) order by s_acctbal desc, n_name, s_name, p_partkey LIMIT 100; QUERY PLAN ---------------------------------------------------------------------------------------------------------- Limit -&gt; Sort Sort Key: supplier.s_acctbal DESC, nation.n_name, supplier.s_name, part.p_partkey -&gt; Merge Join Merge Cond: (part.p_partkey = partsupp.ps_partkey) Join Filter: (partsupp.ps_supplycost = (SubPlan 1)) -&gt; Gather Merge Workers Planned: 4 -&gt; Parallel Index Scan using &lt;strong&gt;part_pkey&lt;/strong&gt; on part Filter: (((p_type)::text ~~ '%BRASS'::text) AND (p_size = 36)) -&gt; Materialize -&gt; Sort Sort Key: partsupp.ps_partkey -&gt; Nested Loop -&gt; Nested Loop Join Filter: (nation.n_regionkey = region.r_regionkey) -&gt; Seq Scan on region Filter: (r_name = 'AMERICA'::bpchar) -&gt; Hash Join Hash Cond: (supplier.s_nationkey = nation.n_nationkey) -&gt; Seq Scan on supplier -&gt; Hash -&gt; Seq Scan on nation -&gt; Index Scan using idx_partsupp_suppkey on partsupp Index Cond: (ps_suppkey = supplier.s_suppkey) SubPlan 1 -&gt; Aggregate -&gt; Nested Loop Join Filter: (nation_1.n_regionkey = region_1.r_regionkey) -&gt; Seq Scan on region region_1 Filter: (r_name = 'AMERICA'::bpchar) -&gt; Nested Loop -&gt; Nested Loop -&gt; Index Scan using idx_partsupp_partkey on partsupp partsupp_1 Index Cond: (part.p_partkey = ps_partkey) -&gt; Index Scan using supplier_pkey on supplier supplier_1 Index Cond: (s_suppkey = partsupp_1.ps_suppkey) -&gt; Index Scan using nation_pkey on nation nation_1 Index Cond: (n_nationkey = supplier_1.s_nationkey)</code> </pre> <br><p>  El nodo Merge Join se encuentra sobre Gather Merge.  Por lo tanto, la fusi√≥n no usa procesamiento paralelo.  Pero el nodo Parallel Index Scan todav√≠a ayuda con el segmento <code>part_pkey</code> . </p><br><h3 id="soedinenie-po-sekciyam">  Conexi√≥n de secci√≥n </h3><br><p>  En PostgreSQL 11, la partici√≥n est√° deshabilitada de manera predeterminada: tiene una programaci√≥n muy costosa.  Las tablas con particiones similares se pueden unir secci√≥n por secci√≥n.  Entonces Postgres usar√° tablas hash m√°s peque√±as.  Cada conexi√≥n de secci√≥n puede ser paralela. </p><br><pre> <code class="plaintext hljs">tpch=# set enable_partitionwise_join=t; tpch=# explain (costs off) select * from prt1 t1, prt2 t2 where t1.a = t2.b and t1.b = 0 and t2.b between 0 and 10000; QUERY PLAN --------------------------------------------------- Append -&gt; Hash Join Hash Cond: (t2.b = t1.a) -&gt; Seq Scan on prt2_p1 t2 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Hash -&gt; Seq Scan on prt1_p1 t1 Filter: (b = 0) -&gt; Hash Join Hash Cond: (t2_1.b = t1_1.a) -&gt; Seq Scan on prt2_p2 t2_1 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Hash -&gt; Seq Scan on prt1_p2 t1_1 Filter: (b = 0) tpch=# set parallel_setup_cost = 1; tpch=# set parallel_tuple_cost = 0.01; tpch=# explain (costs off) select * from prt1 t1, prt2 t2 where t1.a = t2.b and t1.b = 0 and t2.b between 0 and 10000; QUERY PLAN ----------------------------------------------------------- Gather Workers Planned: 4 -&gt; Parallel Append -&gt; Parallel Hash Join Hash Cond: (t2_1.b = t1_1.a) -&gt; Parallel Seq Scan on prt2_p2 t2_1 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Parallel Hash -&gt; Parallel Seq Scan on prt1_p2 t1_1 Filter: (b = 0) -&gt; Parallel Hash Join Hash Cond: (t2.b = t1.a) -&gt; Parallel Seq Scan on prt2_p1 t2 Filter: ((b &gt;= 0) AND (b &lt;= 10000)) -&gt; Parallel Hash -&gt; Parallel Seq Scan on prt1_p1 t1 Filter: (b = 0)</code> </pre> <br><p>  Lo principal es que la conexi√≥n en secciones es paralela solo si estas secciones son lo suficientemente grandes. </p><br><h3 id="parallelnoe-dopolnenie--parallel-append">  Anexos paralelos - Anexos paralelos </h3><br><p>  Se puede utilizar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anexo paralelo en</a> lugar de diferentes bloques en diferentes flujos de trabajo.  Esto suele suceder con UNION TODAS las consultas.  La desventaja es menos paralelismo, porque cada flujo de trabajo procesa solo 1 solicitud. </p><br><p>  Aqu√≠ se ejecutan 2 flujos de trabajo, aunque se incluyen 4. </p><br><pre> <code class="plaintext hljs">tpch=# explain (costs off) select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '1998-12-01' - interval '105' day union all select sum(l_quantity) as sum_qty from lineitem where l_shipdate &lt;= date '2000-12-01' - interval '105' day; QUERY PLAN ------------------------------------------------------------------------------------------------ Gather Workers Planned: 2 -&gt; Parallel Append -&gt; Aggregate -&gt; Seq Scan on lineitem Filter: (l_shipdate &lt;= '2000-08-18 00:00:00'::timestamp without time zone) -&gt; Aggregate -&gt; Seq Scan on lineitem lineitem_1 Filter: (l_shipdate &lt;= '1998-08-18 00:00:00'::timestamp without time zone)</code> </pre> <br><h3 id="samye-vazhnye-peremennye">  Las variables mas importantes </h3><br><ul><li>  WORK_MEM limita la cantidad de memoria para cada proceso, no solo para las solicitudes: <em>procesos de</em> conexi√≥n work_mem = mucha memoria. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>max_parallel_workers_per_gather</code></a> : cu√°ntos procesos de trabajo utilizar√° el programa en ejecuci√≥n para el procesamiento paralelo del plan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>max_worker_processes</code></a> : ajusta el n√∫mero total de procesos de trabajo al n√∫mero de n√∫cleos de CPU en el servidor. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>max_parallel_workers</code></a> es lo mismo, pero para flujos de trabajo paralelos. </li></ul><br><h3 id="itogi">  Resumen </h3><br><p>  A partir de la versi√≥n 9.6, el procesamiento paralelo puede mejorar seriamente el rendimiento de consultas complejas que analizan muchas filas o √≠ndices.  En PostgreSQL 10, el procesamiento paralelo est√° habilitado de forma predeterminada.  Recuerde deshabilitarlo en servidores con una gran carga de trabajo OLTP.  Los escaneos secuenciales o los escaneos de √≠ndice consumen muchos recursos.  Si no est√° informando en todo el conjunto de datos, las consultas pueden hacerse m√°s eficientes simplemente agregando los √≠ndices que faltan o utilizando la partici√≥n correcta. </p><br><h3 id="ssylki">  Referencias </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.postgresql.org/docs/11/how-parallel-query-works.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.postgresql.org/docs/11/parallel-plans.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://ashutoshpg.blogspot.com/2017/12/partition-wise-joins-divide-and-conquer.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://rhaas.blogspot.com/2016/04/postgresql-96-with-parallel-query-vs.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://amitkapila16.blogspot.com/2015/11/parallel-sequential-scans-in-play.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://write-skew.blogspot.com/2018/01/parallel-hash-for-postgresql.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://rhaas.blogspot.com/2017/03/parallel-query-v2.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://blog.2ndquadrant.com/parallel-monster-benchmark/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://blog.2ndquadrant.com/parallel-aggregate/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.depesz.com/2018/02/12/waiting-for-postgresql-11-support-parallel-btree-index-builds/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Concurrencia en PostgreSQL 11</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446706/">https://habr.com/ru/post/446706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446690/index.html">Electrolux lanza un purificador de aire inteligente para las ciudades m√°s contaminadas</a></li>
<li><a href="../446694/index.html">Almacenamiento modular JBOD y grados de libertad</a></li>
<li><a href="../446696/index.html">Mitos sobre 152-FZ, que pueden ser costosos para el operador de datos personales</a></li>
<li><a href="../446700/index.html">Lazydocker - GUI para Docker directamente en la terminal</a></li>
<li><a href="../446702/index.html">Y otro auricular extra√±o, para dormir</a></li>
<li><a href="../446708/index.html">Comparaci√≥n de sistemas de comunicaci√≥n espacial.</a></li>
<li><a href="../446710/index.html">Cuatro historias reales de trabajo con arquitectura de microservicios: informe del mitap de Backend United 3: Kholodets</a></li>
<li><a href="../446712/index.html">HTTPS no siempre es tan seguro como parece. Vulnerabilidades encontradas en el 5.5% de los sitios HTTPS</a></li>
<li><a href="../446714/index.html">Perversiones curiosas del mundo de TI - 4</a></li>
<li><a href="../446716/index.html">Conciencia y argumento del fin del mundo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>