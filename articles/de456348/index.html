<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🍳 👨🏾‍🤝‍👨🏻 🎻 AERODISK Motor: Katastrophal. Teil 1 🎅 💨 👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Leser von Habr! Das Thema dieses Artikels ist die Implementierung von Katastrophenschutz in AERODISK Engine-Speichersystemen. Anfangs wollten wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AERODISK Motor: Katastrophal. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/aerodisk/blog/456348/"><p><img src="https://habrastorage.org/webt/2b/54/ub/2b54ub9jta3knw6ff5eseo1buyu.jpeg"></p><br><p> Hallo Leser von Habr!  Das Thema dieses Artikels ist die Implementierung von Katastrophenschutz in AERODISK Engine-Speichersystemen.  Anfangs wollten wir in einem Artikel über beide Mittel schreiben: Replikation und Metro-Cluster, aber leider stellte sich heraus, dass der Artikel zu groß war, und so teilten wir den Artikel in zwei Teile.  Gehen wir von einfach zu komplex.  In diesem Artikel konfigurieren und testen wir die synchrone Replikation - löschen Sie ein Rechenzentrum und unterbrechen Sie den Kommunikationskanal zwischen den Rechenzentren, um zu sehen, was passiert. </p><a name="habracut"></a><br><p>  Unsere Kunden stellen uns häufig unterschiedliche Fragen zur Replikation. Bevor Sie mit dem Einrichten und Testen der Replikationsimplementierung fortfahren, werden wir Ihnen ein wenig über die Replikation in Speichersystemen erzählen. </p><br><h2 id="nemnogo-teorii">  Ein bisschen Theorie </h2><br><p>  Die Replikation in den Speicher ist ein fortlaufender Prozess zur Sicherstellung der Datenidentität auf mehreren Speichersystemen gleichzeitig.  Technisch wird die Replikation mit zwei Methoden durchgeführt. </p><br><p>  <strong>Die synchrone Replikation</strong> ist das Kopieren von Daten vom Hauptspeichersystem in das Sicherungssystem, gefolgt von der obligatorischen Bestätigung beider Speichersysteme, dass die Daten aufgezeichnet und bestätigt wurden.  Nach Bestätigung von beiden Seiten (auf beiden Speichersystemen) gelten die Daten als aufgezeichnet, und Sie können mit ihnen arbeiten.  Dies stellt eine garantierte Datenidentität auf allen am Replikat beteiligten Speichersystemen sicher. </p><br><p>  Die Vorteile dieser Methode: </p><br><ul><li>  Die Daten sind auf allen Speichersystemen immer identisch. </li></ul><br><p>  Nachteile: </p><br><ul><li>  Hohe Kosten der Lösung (schnelle Kommunikationskanäle, teure Glasfaser, langwellige Transceiver usw.) </li><li>  Entfernungsbeschränkungen (innerhalb weniger zehn Kilometer) </li><li>  Es gibt keinen Schutz gegen logische Datenbeschädigung (wenn die Daten (wissentlich oder versehentlich) auf dem Hauptspeichersystem beschädigt sind, werden sie automatisch und sofort im Sicherungsspeicher beschädigt, da die Daten immer identisch sind (dies ist ein Paradoxon). </li></ul><br><p>  <strong>Bei der asynchronen Replikation</strong> werden auch Daten vom Hauptspeicher in die Sicherung kopiert, jedoch mit einer gewissen Verzögerung und ohne dass der Datensatz auf der anderen Seite bestätigt werden muss.  Sie können sofort nach dem Schreiben in den Hauptspeicher mit Daten arbeiten. Im Sicherungsspeicher sind die Daten nach einer Weile verfügbar.  Die Identität der Daten wird in diesem Fall natürlich überhaupt nicht angegeben.  Daten im Backup-Speicher sind immer etwas "in der Vergangenheit". </p><br><p>  Vorteile der asynchronen Replikation: </p><br><ul><li>  Niedrige Lösungskosten (alle Kommunikationskanäle, Optik optional) </li><li>  Keine Entfernungsbegrenzung </li><li>  Daten im Sicherungsspeicher sind nicht beschädigt, wenn sie auf dem Hauptspeicher beschädigt sind (zumindest für einige Zeit). Wenn die Daten beschädigt wurden, können Sie das Replikat jederzeit stoppen, um eine Beschädigung der Daten im Sicherungsspeicher zu verhindern </li></ul><br><p>  Nachteile: </p><br><ul><li>  Daten in verschiedenen Rechenzentren sind immer nicht identisch </li></ul><br><p>  Daher hängt die Wahl des Replikationsmodus von den Aufgaben des Unternehmens ab.  Wenn es für Sie von entscheidender Bedeutung ist, dass das Backup-Rechenzentrum genau dieselben Daten wie die Hauptdaten enthält (d. H. Geschäftsanforderung für RPO = 0), müssen Sie die Einschränkungen des synchronen Replikats in Kauf nehmen.  Und wenn die Verzögerung des Status der Daten zulässig ist oder einfach kein Geld vorhanden ist, müssen Sie auf jeden Fall die asynchrone Methode verwenden. </p><br><p>  Wir unterscheiden ein solches Regime (genauer gesagt bereits eine Topologie) auch separat als Metro-Cluster.  Der Metro-Cluster-Modus verwendet die synchrone Replikation. Im Gegensatz zu einem regulären Replikat ermöglicht der Metro-Cluster jedoch, dass beide Speichersysteme im aktiven Modus arbeiten.  Das heißt,  Sie haben keine Trennung von Active-Standby-Rechenzentren.  Anwendungen arbeiten gleichzeitig mit zwei Speichersystemen, die sich physisch in verschiedenen Rechenzentren befinden.  Unfallausfallzeiten in einer solchen Topologie sind sehr gering (RTO, normalerweise Minuten).  In diesem Artikel werden wir unsere Implementierung des U-Bahn-Clusters nicht berücksichtigen, da dies ein sehr großes und umfangreiches Thema ist. Daher werden wir ihm in Fortsetzung einen separaten, folgenden Artikel widmen. </p><br><p>  Auch wenn wir sehr oft über die Replikation mit Speichersystemen sprechen, haben viele eine vernünftige Frage:&gt; „Viele Anwendungen haben ihre eigenen Replikationstools. Warum sollte die Replikation auf Speichersystemen verwendet werden?  Ist es besser oder schlechter? " </p><br><p>  Es gibt keine einzige Antwort, daher hier die Vor- und Nachteile: </p><br><p>  Argumente für die Speicherreplikation: </p><br><ul><li>  Die Einfachheit der Lösung.  Auf eine Weise können Sie ein ganzes Datenarray replizieren, unabhängig vom Lasttyp oder der Anwendung.  Wenn Sie ein Replikat von Anwendungen verwenden, müssen Sie jede Anwendung separat konfigurieren.  Wenn es mehr als zwei davon gibt, ist dies äußerst zeitaufwändig und teuer (für die Anwendungsreplikation ist in der Regel eine separate und nicht kostenlose Lizenz für jede Anwendung erforderlich. Mehr dazu weiter unten). </li><li>  Sie können alles replizieren - alle Anwendungen, alle Daten - und sie sind immer konsistent.  Viele (die meisten) Anwendungen verfügen nicht über Replikationsfunktionen, und Replikate von der Speicherseite sind die einzige Möglichkeit, Schutz vor Katastrophen zu bieten. </li><li>  Keine Überzahlung für Anwendungsreplikationsfunktionen erforderlich.  In der Regel kostet es viel, genau wie Lizenzen für ein Replikatspeichersystem.  Sie müssen die Speicherreplikationslizenz jedoch nur einmal bezahlen und die Lizenz für das Anwendungsreplikat für jede Anwendung separat erwerben.  Wenn es viele solcher Anwendungen gibt, kostet es einen hübschen Cent und die Kosten für Lizenzen für die Replikation von Speicher werden zu einem Tropfen auf den heißen Stein. </li></ul><br><p>  Argumente GEGEN Speicherreplikation: </p><br><ul><li>  Das Replikat, das Anwendungstools verwendet, verfügt aus Sicht der Anwendungen selbst über mehr Funktionen. Die Anwendung kennt ihre Daten besser (was offensichtlich ist), sodass mehr Optionen für die Arbeit mit ihnen vorhanden sind. </li><li>  Hersteller einiger Anwendungen garantieren nicht die Konsistenz ihrer Daten, wenn die Replikation mit Tools von Drittanbietern erfolgt.  * * </li></ul><br><p>  * - eine kontroverse These.  Zum Beispiel hat ein bekanntes DBMS-Fertigungsunternehmen lange Zeit offiziell erklärt, dass sein DBMS normalerweise nur mit seinen Mitteln repliziert werden kann und der Rest der Replikation (einschließlich SHD-shnaya) „nicht wahr“ ist.  Aber das Leben hat gezeigt, dass dies nicht so ist.  Höchstwahrscheinlich (aber das ist nicht korrekt) ist dies einfach nicht der ehrlichste Versuch, mehr Lizenzen an Kunden zu verkaufen. </p><br><p>  Infolgedessen ist die Replikation von der Speicherseite in den meisten Fällen besser, weil  Dies ist eine einfachere und kostengünstigere Option. Es gibt jedoch komplexe Fälle, in denen Sie bestimmte Anwendungsfunktionen benötigen und mit der Replikation auf Anwendungsebene arbeiten müssen. </p><br><h2 id="s-teoriey-zakonchili-teper-praktika">  Wenn die Theorie fertig ist, jetzt die Praxis </h2><br><p>  Wir werden in unserem Labor eine Replik erstellen.  Im Labor haben wir zwei Rechenzentren emuliert (tatsächlich zwei benachbarte Racks, die sich in unterschiedlichen Gebäuden zu befinden scheinen).  Der Stand besteht aus zwei Engine N2-Speichersystemen, die durch optische Kabel miteinander verbunden sind.  Ein physischer Server unter Windows Server 2016 mit 10-Gbit-Ethernet ist mit beiden Speichersystemen verbunden.  Der Stand ist recht einfach, ändert aber nichts an der Essenz. </p><br><p>  Schematisch sieht es so aus: </p><br><p><img src="https://habrastorage.org/webt/wj/u4/rc/wju4rcak9ilbms68pnffyvsb6ly.png"></p><br><p>  Die logische Replikation ist wie folgt organisiert: </p><br><p><img src="https://habrastorage.org/webt/yf/yh/dy/yfyhdy19cbj3sc0gpzp8jx6liz0.jpeg"></p><br><p>  Schauen wir uns nun die Replikationsfunktionalität an, die wir jetzt haben. <br>  Es werden zwei Modi unterstützt: asynchron und synchron.  Es ist logisch, dass der Synchronmodus durch die Entfernung und den Kommunikationskanal begrenzt ist.  Insbesondere erfordert der synchrone Modus die Verwendung von Glasfaser als Physik und 10-Gigabit-Ethernet (oder höher). </p><br><p>  Die unterstützte Entfernung für die synchrone Replikation beträgt 40 Kilometer, die Verzögerung des Optikkanals zwischen den Rechenzentren beträgt bis zu 2 Millisekunden.  Im Allgemeinen funktioniert es mit großen Verzögerungen, aber während der Aufzeichnung treten starke Bremsen auf (was ebenfalls logisch ist). Wenn Sie also eine synchrone Replikation zwischen Rechenzentren in Betracht ziehen, sollten Sie die Qualität der Optik und Verzögerungen überprüfen. </p><br><p>  Asynchrone Replikationsanforderungen sind nicht so ernst.  Genauer gesagt sind sie überhaupt nicht.  Jede funktionierende Ethernet-Verbindung ist geeignet. </p><br><p>  Derzeit unterstützt der AERODISK ENGINE-Speicher die Replikation für Blockgeräte (LUNs) mithilfe des Ethernet-Protokolls (Kupfer oder Optik).  Für Projekte, die notwendigerweise eine Replikation über die Fibre Channel SAN-Factory erfordern, schließen wir jetzt die entsprechende Lösung ab, aber bisher ist sie noch nicht fertig, in unserem Fall nur Ethernet. </p><br><p>  Die Replikation kann zwischen allen Speichersystemen der ENGINE-Serie (N1, N2, N4) von niedrigeren Systemen zu älteren und umgekehrt funktionieren. </p><br><p>  Die Funktionalität beider Replikationsmodi ist völlig identisch.  Im Folgenden erfahren Sie mehr darüber, was ist: </p><br><ul><li>  Replikation "eins zu eins" oder "eins zu eins", dh die klassische Version mit zwei Rechenzentren, dem Haupt- und dem Backup </li><li>  Die Replikation ist "eins zu viele" oder "eins zu viele", d.h.  Eine LUN kann gleichzeitig auf mehrere Speichersysteme repliziert werden </li><li>  Aktivierung, Deaktivierung und "Umkehrung" der Replikation, um die Replikationsrichtung zu aktivieren, zu deaktivieren oder zu ändern </li><li>  Die Replikation ist sowohl für RDG-Pools (Raid Distributed Group) als auch für DDP-Pools (Dynamic Disk Pool) verfügbar.  Die RDG-Pool-LUN kann jedoch nur auf eine andere RDG repliziert werden.  C DDP ist ähnlich. </li></ul><br><p>  Es gibt viel mehr kleine Funktionen, aber die Auflistung macht nicht viel Sinn. Wir werden sie während des Setups erwähnen. </p><br><h2 id="nastroyka-replikacii">  Replikationssetup </h2><br><p>  Der Einrichtungsprozess ist recht einfach und besteht aus drei Schritten. </p><br><ol><li>  Netzwerkeinrichtung </li><li>  Speicher-Setup </li><li>  Regeln (Links) einrichten und zuordnen </li></ol><br><p>  Ein wichtiger Punkt bei der Konfiguration der Replikation ist, dass die ersten beiden Stufen auf einem Remote-Speichersystem wiederholt werden sollten, die dritte Stufe - nur auf der Hauptstufe. </p><br><h3 id="nastroyka-setevyh-resursov">  Konfiguration der Netzwerkressourcen </h3><br><p>  Der erste Schritt besteht darin, die Netzwerkports zu konfigurieren, über die der Replikationsverkehr übertragen wird.  Dazu müssen Sie die Ports aktivieren und im Abschnitt Front-End-Adapter IP-Adressen festlegen. </p><br><p>  Danach müssen wir einen Pool (in unserem Fall RDG) und eine virtuelle IP für die Replikation (VIP) erstellen.  VIP ist eine Floating-IP-Adresse, die an zwei „physische“ Adressen von Speichercontrollern gebunden ist (die Ports, die wir gerade konfiguriert haben).  Es wird die primäre Replikationsschnittstelle sein.  Sie können auch nicht mit VIP, sondern mit VLAN arbeiten, wenn Sie mit markiertem Datenverkehr arbeiten müssen. </p><br><p><img src="https://habrastorage.org/webt/di/ye/5f/diye5fvbzya3cvtebg7memcs5jo.jpeg"></p><br><p>  Das Erstellen eines VIP für ein Replikat unterscheidet sich nicht wesentlich vom Erstellen eines VIP für E / A (NFS, SMB, iSCSI).  In diesem Fall erstellen wir ein VIP (ohne VLAN), geben jedoch unbedingt an, dass es für die Replikation vorgesehen ist (ohne diesen Zeiger können wir der Regel im nächsten Schritt kein VIP hinzufügen). </p><br><p><img src="https://habrastorage.org/webt/nd/i9/2d/ndi92dbmjvxuqjidju802r-vl7s.png"></p><br><p>  VIP muss sich im selben Subnetz befinden wie die IP-Ports, zwischen denen es „schwebt“. </p><br><p><img src="https://habrastorage.org/webt/vm/no/9m/vmno9ms_uas_guk28o1etun7kg4.png"></p><br><p>  Wir wiederholen diese Einstellungen auf dem Remote-Speichersystem mit einem anderen IP-Shnik für sich. <br>  VIPs aus verschiedenen Speichersystemen können sich in verschiedenen Subnetzen befinden. Hauptsache, es sollte ein Routing zwischen ihnen bestehen.  In unserem Fall wird dieses Beispiel nur gezeigt (192.168.3.XX und 192.168.2.XX). </p><br><p><img src="https://habrastorage.org/webt/w5/r6/re/w5r6rexidxqry4rnfdrvgp5gzcq.jpeg"></p><br><p>  Damit ist die Vorbereitung des Netzwerkteils abgeschlossen. </p><br><h3 id="nastraivaem-hranilischa">  Speicher konfigurieren </h3><br><p>  Das Konfigurieren des Speichers für ein Replikat unterscheidet sich vom üblichen nur dadurch, dass wir die Zuordnung über das spezielle Menü „Replikationszuordnung“ vornehmen.  Ansonsten ist alles wie bei der üblichen Einstellung.  Jetzt in Ordnung. </p><br><p>  Im zuvor erstellten R02-Pool müssen Sie eine LUN erstellen.  Erstellen, nennen Sie es LUN1. </p><br><p><img src="https://habrastorage.org/webt/tg/l8/vk/tgl8vkdsqf-4oljacfssnh2_zus.jpeg"></p><br><p>  Wir müssen dieselbe LUN auch auf einem Remote-Speichersystem mit identischem Volumen erstellen.  Wir schaffen.  Um Verwirrung zu vermeiden, wird die Remote-LUN LUN1R genannt </p><br><p><img src="https://habrastorage.org/webt/xm/kl/v4/xmklv4deigknjz1vadluit9pdds.jpeg"></p><br><p>  Wenn wir eine bereits vorhandene LUN verwenden müssten, müsste diese produktive LUN zum Zeitpunkt der Replikateinrichtung vom Host abgemeldet werden und auf dem Remote-Speichersystem einfach eine leere LUN mit identischer Größe erstellen. </p><br><p>  Wenn das Speicher-Setup abgeschlossen ist, fahren wir mit der Erstellung der Replikationsregel fort. </p><br><h3 id="nastroyka-pravil-replikacii-ili-replikacionnyh-svyazey">  Konfigurieren Sie Replikationsregeln oder Replikationslinks </h3><br><p>  Nach dem Erstellen von LUNs auf dem Speicher, der momentan die primäre sein wird, konfigurieren wir die Replikationsregel LUN1 auf SHD1 in LUN1R auf SHD2. </p><br><p>  Die Konfiguration erfolgt im Menü Remote Replication. </p><br><p>  Erstellen Sie eine Regel.  Geben Sie dazu den Replikatempfänger an.  Wir geben auch den Namen der Verbindung und den Replikationstyp (synchron oder asynchron) an. </p><br><p><img src="https://habrastorage.org/webt/xk/yu/8f/xkyu8ftgcubcwu4-ul_ux3vc7lq.jpeg"></p><br><p>  Fügen Sie im Feld "Remote-Systeme" unseren SHD2 hinzu.  Zum Hinzufügen müssen Sie den verwaltenden IP-Speicher (MGR) und den Namen der Remote-LUN verwenden, auf die wir replizieren möchten (in unserem Fall LUN1R).  Das Verwalten von IPs wird nur in der Phase des Hinzufügens von Kommunikation benötigt. Der Replikationsverkehr über diese IPs wird nicht übertragen. Hierzu wird der zuvor konfigurierte VIP verwendet. </p><br><p>  Bereits zu diesem Zeitpunkt können wir mehr als ein Remote-System für die Topologie "Eins zu Viele" hinzufügen: Klicken Sie auf die Schaltfläche "Knoten hinzufügen", wie in der folgenden Abbildung dargestellt. </p><br><p><img src="https://habrastorage.org/webt/rv/xb/bh/rvxbbh4umovgds3gduoaxg3tfc8.jpeg"></p><br><p>  In unserem Fall ist das Remote-System eines, daher sind wir darauf beschränkt. </p><br><p>  Die Regel ist fertig.  Beachten Sie, dass es automatisch allen Replikationsteilnehmern hinzugefügt wird (in unserem Fall gibt es zwei davon).  Sie können beliebig viele Regeln für eine beliebige Anzahl von LUNs und in eine beliebige Richtung erstellen.  Um die Last auszugleichen, können wir beispielsweise einen Teil der LUNs von SHD1 nach SHD2 und den anderen Teil im Gegenteil von SHD2 nach SHD1 replizieren. </p><br><p>  SHD1.  Unmittelbar nach der Erstellung begann die Synchronisation. </p><br><p><img src="https://habrastorage.org/webt/y7/v8/gg/y7v8gg7bboqpit0zrow87pgvi5y.jpeg"></p><br><p>  SHD2.  Wir sehen die gleiche Regel, aber die Synchronisation ist bereits beendet. </p><br><p><img src="https://habrastorage.org/webt/tb/dl/0k/tbdl0k_anxtcwmecg31bk0s7fmo.jpeg"></p><br><p>  LUN1 auf SHD1 ist in der Rolle von Primary, dh es ist aktiv.  LUN1R auf SHD2 spielt die Rolle des Sekundärs, dh es wird gehalten, wenn SHD1 ausfällt. <br>  Jetzt können wir unsere LUN mit dem Host verbinden. </p><br><p>  Wir werden die Verbindung über iSCSI herstellen, obwohl dies über FC erfolgen kann.  Das Einrichten der Zuordnung für iSCSI-LUN in einem Replikat unterscheidet sich praktisch nicht vom üblichen Szenario, daher werden wir hier nicht näher darauf eingehen.  Wenn überhaupt, wird dieser Vorgang im Artikel zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schnellen Einrichtung</a> beschrieben. </p><br><p>  Der einzige Unterschied besteht darin, dass wir die Zuordnung im Menü "Replikationszuordnung" erstellen. </p><br><p><img src="https://habrastorage.org/webt/xn/uy/p9/xnuyp9dccwbpg93ahvefmhifmdq.jpeg"></p><br><p>  Richten Sie die Zuordnung ein und geben Sie dem Host die LUN.  Der Gastgeber sah eine LUN. </p><br><p><img src="https://habrastorage.org/webt/qg/y3/vm/qgy3vmfark_2-pvl8liqtozb2iu.jpeg"></p><br><p>  Formatieren Sie es in das lokale Dateisystem. </p><br><p><img src="https://habrastorage.org/webt/zd/8l/qg/zd8lqglmv194u9-zsctatxrsuzk.jpeg"></p><br><p>  Das Setup ist abgeschlossen.  Als nächstes werden Tests gehen. </p><br><h2 id="testirovanie">  Testen </h2><br><p>  Wir werden drei Hauptszenarien testen. </p><br><ol><li>  Personalwechselrollen Sekundär&gt; Primär.  Ein regelmäßiger Rollenwechsel ist erforderlich, wenn wir beispielsweise hauptsächlich ein Rechenzentrum benötigen, einige vorbeugende Vorgänge ausführen müssen und während dieser Zeit, damit die Daten verfügbar sind, die Last an das Backup-Rechenzentrum übertragen. </li><li>  Failover von Rollen Sekundär&gt; Primär (Ausfall des Rechenzentrums).  Dies ist das Hauptszenario für die Replikation, mit dessen Hilfe ein vollständiger Ausfall des Rechenzentrums überstanden werden kann, ohne das Unternehmen für längere Zeit anzuhalten. </li><li>  Unterbrochene Kommunikationskanäle zwischen Rechenzentren.  Überprüfen des korrekten Verhaltens von zwei Speichersystemen unter Bedingungen, unter denen aus irgendeinem Grund der Kommunikationskanal zwischen den Rechenzentren nicht verfügbar ist (z. B. ein Bagger, der an der falschen Stelle gegraben wurde und die dunkle Optik defekt hat). </li></ol><br><p>  Zunächst beginnen wir, Daten in unsere LUN zu schreiben (wir schreiben Dateien mit zufälligen Daten).  Wir sehen sofort, dass der Kommunikationskanal zwischen den Speichersystemen genutzt wird.  Dies ist leicht zu verstehen, wenn Sie die Lastüberwachung der Ports öffnen, die für die Replikation verantwortlich sind. </p><br><p><img src="https://habrastorage.org/webt/s7/99/bt/s799bttjt3v6q24uhvxoywfrwne.jpeg"></p><br><p>  Auf beiden Speichersystemen gibt es jetzt "nützliche" Daten, wir können den Test starten. </p><br><p><img src="https://habrastorage.org/webt/r3/vs/dv/r3vsdvpsp9avchablad41pxrfdu.jpeg"></p><br><p>  Schauen wir uns für alle Fälle die Hash-Summen einer der Dateien an und schreiben Sie sie auf. </p><br><p><img src="https://habrastorage.org/webt/e1/zi/st/e1zistvzwlkimqbupxjtgnltc9o.jpeg"></p><br><h3 id="shtatnoe-pereklyuchenie-roley">  Personalrollenwechsel </h3><br><p>  Das Wechseln der Rollen (Ändern der Replikationsrichtung) kann von jedem Speichersystem aus erfolgen. Sie müssen jedoch weiterhin zu beiden wechseln, da Sie die Zuordnung auf der Primärseite deaktivieren und auf der Sekundärseite aktivieren müssen (die zur Primärseite wird). </p><br><p>  Vielleicht stellt sich jetzt eine vernünftige Frage: Warum nicht automatisieren?  Wir antworten: Alles ist einfach, die Replikation ist ein einfaches Katastrophenschutz-Tool, das ausschließlich auf manuellen Vorgängen basiert.  Um diese Vorgänge zu automatisieren, gibt es einen Metro-Cluster-Modus, der vollständig automatisiert ist, dessen Konfiguration jedoch viel komplizierter ist.  Wir werden im nächsten Artikel über das Einrichten des U-Bahn-Clusters schreiben. </p><br><p>  Deaktivieren Sie die Zuordnung im Hauptspeicher, um sicherzustellen, dass die Aufzeichnung gestoppt wird. </p><br><p><img src="https://habrastorage.org/webt/jk/j4/1l/jkj41ltsncz2hmqoclkrecqvguy.jpeg"></p><br><p>  Wählen Sie dann auf einem der Speichersysteme (egal ob primär oder Backup) im Menü "Remote-Replikation" unsere REPL1-Verbindung aus und klicken Sie auf "Rolle ändern". </p><br><p><img src="https://habrastorage.org/webt/dc/bb/8t/dcbb8tv24xxhofmg_avtodfelas.jpeg"></p><br><p>  Nach einigen Sekunden wird LUN1R (Backup-Speicher) primär. </p><br><p><img src="https://habrastorage.org/webt/-v/hf/l2/-vhfl2g0v20bnfnomxwupf0_9xk.jpeg"></p><br><p>  Wir machen das Mapping von LUN1R mit SHD2. </p><br><p><img src="https://habrastorage.org/webt/lh/uw/cy/lhuwcyscu0quljitysu2pkk35hg.jpeg"></p><br><p>  Danach klammert sich unser E: -Laufwerk automatisch an den Host, nur dass es diesmal mit LUN1R „geflogen“ ist. </p><br><p>  Vergleichen Sie für alle Fälle die Hash-Mengen. </p><br><p><img src="https://habrastorage.org/webt/g6/st/qh/g6stqhn-xr0yqlw84t7y4_y5sqm.png"></p><br><p>  Identisch.  Test bestanden. </p><br><h3 id="avariynoe-pereklyuchenie-otkaz-cod-a">  Failover  Rechenzentrumsfehler </h3><br><p>  Derzeit ist der Hauptspeicher nach dem regulären Umschalten SHD2 bzw. LUN1R.  Um einen Unfall zu simulieren, schalten wir beide Controller SHD2 aus. <br>  Der Zugang dazu ist nicht mehr möglich. </p><br><p>  Wir schauen uns an, was auf dem Speicher 1 passiert (Backup im Moment). </p><br><p><img src="https://habrastorage.org/webt/ai/oy/jt/aioyjtl8xqmmgngtidigkvoesai.jpeg"></p><br><p>  Wir sehen, dass die primäre LUN (LUN1R) nicht verfügbar ist.  Eine Fehlermeldung wurde in den Protokollen, im Informationsbereich sowie in der Replikationsregel selbst angezeigt.  Dementsprechend sind Daten vom Host derzeit nicht verfügbar. </p><br><p>  Ändern Sie die Rolle von LUN1 in Primary. </p><br><p><img src="https://habrastorage.org/webt/ef/vr/wv/efvrwvemqzysnrtebprwvmqnxw8.jpeg"></p><br><p>  Angelegenheiten, die dem Gastgeber zugeordnet sind. </p><br><p><img src="https://habrastorage.org/webt/o9/es/oj/o9esojg6xcl-uv_wbbj6afkrz18.jpeg"></p><br><p>  Stellen Sie sicher, dass Laufwerk E auf dem Host angezeigt wird. </p><br><p><img src="https://habrastorage.org/webt/rg/kj/0s/rgkj0s-0rgoumtmnzk98bd-bgl4.jpeg"></p><br><p>  Überprüfen Sie den Hash. </p><br><p><img src="https://habrastorage.org/webt/hn/yb/yq/hnybyqjm7w_g1il4bowg1-xgq5y.jpeg"></p><br><p>  Alles ist in Ordnung.  Das Speicherzentrum verzeichnete einen Rückgang des aktiven Rechenzentrums.  Die ungefähre Zeit, die wir für das Verbinden der "Umkehrung" der Replikation und das Verbinden der LUN vom Backup-Rechenzentrum aufgewendet haben, betrug ungefähr 3 Minuten.  Es ist klar, dass im realen Produkt alles viel komplizierter ist, und zusätzlich zu Aktionen mit Speichersystemen müssen Sie viel mehr Vorgänge im Netzwerk, auf Hosts und in Anwendungen ausführen.  Und im Leben wird diese Zeitspanne viel länger sein. </p><br><p>  Hier möchte ich schreiben, dass alles, der Test erfolgreich abgeschlossen wurde, aber lasst uns nicht eilen.  Der Hauptspeicher "liegt", wir wissen, dass sie, als sie "fiel", in der Rolle der Grundschule war.  Was passiert, wenn sie sich plötzlich einschaltet?  Es wird zwei Hauptrollen geben, was einer Datenbeschädigung entspricht.  Wir werden es jetzt überprüfen. <br>  Wir werden plötzlich den zugrunde liegenden Speicher einschalten. </p><br><p>  Es wird einige Minuten lang geladen und danach nach einer kurzen Synchronisation wieder in Betrieb genommen, jedoch bereits als sekundär. </p><br><p><img src="https://habrastorage.org/webt/27/hu/q6/27huq6b6guby7o-g7_xkz7quugy.jpeg"></p><br><p>  Alles ok.  Geteiltes Gehirn ist nicht passiert.  Wir haben darüber nachgedacht und immer nach dem Fall des Speichersystems steigt die Rolle des Sekundärsystems an, unabhängig davon, welche Rolle es "im Leben" war.  Jetzt können wir mit Sicherheit sagen, dass der Ausfalltest des Rechenzentrums erfolgreich war. </p><br><h3 id="otkaz-kanalov-svyazi-mezhdu-cod-ami">  Ausfall von Kommunikationskanälen zwischen Rechenzentren </h3><br><p>  Die Hauptaufgabe dieses Tests besteht darin, sicherzustellen, dass das Speichersystem nicht ausflippt, wenn es vorübergehend die Kommunikationskanäle zwischen den beiden Speichersystemen verliert und dann wieder angezeigt wird. <br>  Also.  Wir trennen die Drähte zwischen den Speichersystemen (stellen Sie sich vor, ein Bagger hat sie gegraben). </p><br><p>  Auf der Primärseite sehen wir, dass es keine Verbindung mit der Sekundarstufe gibt. </p><br><p><img src="https://habrastorage.org/webt/yh/nf/ar/yhnfarhppjrnbaxotu4ds4szz5c.jpeg"></p><br><p>  Auf Secondary sehen wir, dass es keine Verbindung zu Primary gibt. </p><br><p><img src="https://habrastorage.org/webt/f4/k9/7h/f4k97hzr11uh3cytxpsjlq2anly.jpeg"></p><br><p>  Alles funktioniert einwandfrei, und wir schreiben weiterhin Daten in das Hauptspeichersystem, dh es wird bereits garantiert, dass sie sich von dem Sicherungssystem unterscheiden, dh sie sind "übrig". </p><br><p>  In wenigen Minuten reparieren wir den Kommunikationskanal.  Sobald sich die Speichersysteme gesehen haben, wird die Datensynchronisation automatisch aktiviert.  Der Administrator benötigt nichts. </p><br><p><img src="https://habrastorage.org/webt/wo/os/yy/woosyydo-vvbauzsd7lgu4qwfos.jpeg"></p><br><p>     . </p><br><p><img src="https://habrastorage.org/webt/up/ne/es/upneeslicidwf8manqfmlvcaohu.jpeg"></p><br><p>  ,        ,      . </p><br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>    –    ,  ,   .       . </p><br><p>        ,  -    .      .   ,        . </p><br><p>                   active-active,       ,       . </p><br><p>   ,       . </p><br><p>   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456348/">https://habr.com/ru/post/de456348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456338/index.html">13 nützliche JavaScript-Einzeiler</a></li>
<li><a href="../de456340/index.html">Eine Geschichte darüber, wie ein Team von Freiberuflern Full-Stack-JavaScript-Anwendungen schreibt</a></li>
<li><a href="../de456342/index.html">Eine Sprache, um alle zu regieren</a></li>
<li><a href="../de456344/index.html">Warum gibt ['1', '7', '11']. Map (parseInt) [1, NaN, 3] in Javascript zurück?</a></li>
<li><a href="../de456346/index.html">Interaktive Roadmap für Webentwicklungslerner</a></li>
<li><a href="../de456350/index.html">Digitale Veranstaltungen in Moskau vom 17. bis 23. Juni</a></li>
<li><a href="../de456352/index.html">Drahtloses Objektkommunikationsmodul WISE-4000</a></li>
<li><a href="../de456354/index.html">Wie sammeln wir TV-Boxen?</a></li>
<li><a href="../de456358/index.html">Die 13 berüchtigtsten Artikel des vergangenen Jahres</a></li>
<li><a href="../de456362/index.html">Level 6 Designer: Wie wir Designer motivieren und entwickeln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>