<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕎 👨🏻‍🚀 📓 Metode Optimasi Kode untuk Redd. Bagian 2: memori non-cacheable dan operasi bus paralel 🤙🏽 🛌🏿 ♾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel terakhir, kami menemukan bahwa cache jelas merupakan hal yang bermanfaat, tetapi berkaitan dengan logika pengontrol, terkadang membuat k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metode Optimasi Kode untuk Redd. Bagian 2: memori non-cacheable dan operasi bus paralel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468027/">  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terakhir,</a> kami menemukan bahwa cache jelas merupakan hal yang bermanfaat, tetapi berkaitan dengan logika pengontrol, terkadang membuat kesulitan.  Secara khusus, ini memperkenalkan durasi denyut nadi yang tidak dapat diprediksi atau penundaan lain dalam pembentukan diagram waktu yang terprogram.  Nah, dan dalam rencana "program terprogram", lokasi fungsi yang buruk dapat mengurangi keuntungan dari cache menjadi kosong, terus-menerus memprovokasi untuk reboot dari memori lambat.  Saya menyebutkan bahwa 15 tahun yang lalu kami harus membuat preprosesor khusus yang memperbaiki masalah yang muncul untuk prosesor SPARC-8, dan berjanji untuk mengatakan betapa mudahnya untuk memperbaiki kesulitan seperti itu ketika mengembangkan prosesor Nios II yang disintesis yang direkomendasikan untuk digunakan dalam paket Redd.  Waktunya telah tiba untuk memenuhi janji. <br><br><img src="https://habrastorage.org/webt/pr/sx/ix/prsxixkamqwdpusqqagnx0xnh1q.png"><br><a name="habracut"></a><br><h4>  Artikel sebelumnya dalam seri: </h4><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd, dan debugging menggunakan tes memori sebagai contoh.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Kode program.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan program untuk prosesor pusat Redd pada contoh akses ke FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eksperimen pertama menggunakan protokol streaming pada contoh koneksi CPU dan prosesor di FPGA kompleks Redd.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Merry Quartusel, atau bagaimana prosesor telah hidup seperti itu.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode Optimasi Kode untuk Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: efek cache.</a> </li></ol><br>  Hari ini, buku referensi kami akan menjadi <b>Buku Pegangan Desain Tertanam</b> , atau lebih tepatnya, bagian <b>7.5.</b>  <b>Menggunakan Memori yang Digabungkan dengan Tutorial Prosesor Nios II</b> .  Bagian itu sendiri berwarna-warni.  Hari ini kami merancang sistem prosesor untuk Intel FPGA dalam program Platform Designer.  Pada zaman Altera, itu disebut QSys (maka ekstensi <b>.qsys</b> dari file proyek).  Tetapi sebelum QSsys muncul, semua orang menggunakan leluhurnya, SOPC Builder (yang ingatannya, ekstensi file <b>.sopcinfo ditinggalkan</b> ).  Jadi, walaupun dokumen tersebut ditandai dengan logo Intel, tetapi gambar di dalamnya adalah screenshot dari SOPC Builder ini.  Itu jelas ditulis lebih dari sepuluh tahun yang lalu, dan sejak itu hanya istilah yang diperbaiki di dalamnya.  Benar, teksnya cukup modern, jadi dokumen ini cukup berguna sebagai panduan pelatihan. <br><br><h2>  Persiapan Peralatan </h2><br>  Jadi  Kami ingin menambahkan memori ke sistem prosesor Spartan kami, yang tidak pernah di-cache dan pada saat yang sama berjalan pada kecepatan setinggi mungkin.  Tentu saja, ini akan menjadi memori FPGA internal.  Kami akan menambahkan memori untuk kode dan data, tetapi ini akan menjadi blok yang berbeda.  Mari kita mulai dengan memori data sebagai yang paling sederhana.  Kami <b>menambahkan Memori OnChip yang</b> sudah dikenal ke sistem. <br><br><img src="https://habrastorage.org/webt/4g/vv/nx/4gvvnxooo_8rfteiku1wm4l6yr8.png"><br><br>  Ya, misalkan volumenya akan 2 kilobyte (masalah utama dengan memori internal FPGA adalah kecil, jadi Anda harus menyimpannya).  Sisanya adalah memori biasa, yang telah kita tambahkan. <br><br><img src="https://habrastorage.org/webt/jd/et/sj/jdetsj-2tvd6ou6xdr_rzggote4.png"><br><br>  Tapi kami tidak akan menghubungkannya ke bus data, tetapi ke bus khusus.  Untuk membuatnya muncul, kita masuk ke properti prosesor, pergi ke tab <b>Cache dan Memory Interfaces</b> dan dalam daftar pilihan <b>Jumlah port master data coulped erat</b> pilih nilai 1. <br><br><img src="https://habrastorage.org/webt/bt/rj/m4/btrjm4ihtix-btomqh6ttgyjifs.png"><br><br>  Berikut port baru untuk prosesor: <br><br><img src="https://habrastorage.org/webt/lm/j7/xu/lmj7xu6jk4lofwv9kdmdi1m4--u.png"><br><br>  Kami baru-baru ini menghubungkan blok memori yang baru ditambahkan ke dalamnya! <br><br><img src="https://habrastorage.org/webt/ea/vf/t_/eavft_i05i9qb9sn5duyrxvgyda.png"><br><br>  Trik lain adalah dalam menetapkan alamat ke memori baru ini.  Dokumen ini memiliki garis panjang alasan tentang optimalisasi decoding alamat.  Ini menyatakan bahwa memori yang tidak di-cache harus dibedakan dari semua jenis memori lainnya dengan bit alamat yang diekspresikan dengan jelas.  Oleh karena itu, dalam dokumen, semua memori yang tidak dapat disimpan dalam cache termasuk dalam kisaran 0x2XXXXXXX.  Jadi, masukkan alamat 0x2000000 secara manual dan kunci agar tidak berubah dengan penetapan otomatis berikut. <br><br><img src="https://habrastorage.org/webt/nf/l3/qn/nfl3qn1zegllimprcc6xtol3yim.png"><br><br>  Yah, dan murni untuk estetika, ganti nama blok ... Sebut saja, katakanlah, <b>NonCachedData</b> . <br><br><img src="https://habrastorage.org/webt/7z/l-/8p/7zl-8pvknmn3thqgvx7cahpzzw8.png"><br><br>  Dengan perangkat keras untuk memori data yang tidak di-cache, itu saja.  Kami beralih ke memori untuk penyimpanan kode.  Semuanya hampir sama di sini, tetapi sedikit lebih rumit.  Faktanya, semuanya dapat dilakukan dengan sepenuhnya identik, hanya port master bus yang dibuka dalam daftar <b>Jumlah port master instruksi yang diikat dengan ketat</b> , namun, tidak mungkin untuk melakukan debug sistem seperti itu.  Ketika program diisi dengan debugger, itu mengalir ke sana melalui bus data.  Ketika berhenti, kode yang dibongkar juga dibaca oleh debugger melalui bus data.  Dan bahkan jika program dimuat dari loader eksternal (kami belum mempertimbangkan metode seperti itu, terutama karena dalam versi gratis dari lingkungan pengembangan kami berkewajiban untuk bekerja hanya dengan debugger JTAG terhubung, tetapi secara umum, tidak ada yang melarang melakukan hal ini), isi juga melalui bus data.  Oleh karena itu, memori harus melakukan dual-port.  Ke satu port, sambungkan wizard instruksi yang tidak di-cache yang berfungsi pada waktu utama, dan ke port lainnya - bus data purnawaktu tambahan.  Ini akan digunakan untuk mengunduh program dari luar, serta untuk mendapatkan konten RAM oleh debugger.  Sisa waktu ban ini tidak digunakan.  Beginilah tampilannya di bagian teoretis dokumen: <br><br><img src="https://habrastorage.org/webt/ks/sv/vt/kssvvtij9hdnujtgehodhaqwjmu.png"><br><blockquote>  Perhatikan bahwa dokumen tidak menjelaskan alasannya, tetapi dicatat bahwa bahkan dengan memori port ganda, hanya satu port yang dapat dihubungkan ke master yang tidak di-cache.  Yang kedua harus terhubung dengan yang biasa. </blockquote>  Mari kita tambahkan 8 kilobyte memori, buatlah dual-port, biarkan sisanya secara default: <br><br><img src="https://habrastorage.org/webt/kl/1q/_k/kl1q_kgyv67kvcjjzyiw-obrrm4.png"><br><br>  Tambahkan port instruksi yang tidak bisa di-cache ke prosesor: <br><br><img src="https://habrastorage.org/webt/tk/ib/2y/tkib2ydvc6f_lfi9nprwkzai0cu.png"><br><br>  Kami memanggil memori <b>NonCachedCode</b> , menghubungkan memori ke bus, menetapkannya 0x20010000 dan menguncinya (untuk kedua port).  Total, kami mendapatkan sesuatu seperti ini: <br><br><img src="https://habrastorage.org/webt/84/1d/o_/841do_ssmf-r_a4ibqdyr2kksly.png"><br><br>  Itu saja.  Kami menyimpan dan menghasilkan sistem, mengumpulkan proyek.  Perangkat keras sudah siap.  Kami lolos ke bagian perangkat lunak. <br><br><h2>  Persiapan BSP di bagian perangkat lunak </h2><br>  Biasanya, setelah mengubah sistem prosesor, cukup pilih item menu <b>Hasilkan BSP</b> , tetapi hari ini kita harus membuka Editor BSP.  Karena kami jarang melakukan ini, izinkan saya mengingatkan Anda di mana item menu yang sesuai berada: <br><br><img src="https://habrastorage.org/webt/x4/nk/ub/x4nkubzhbxq26krtzce8nhuxmcw.png"><br><br>  Di sana kita pergi ke tab <b>Skrip Linker</b> .  Kami melihat bahwa kami telah menambahkan wilayah yang mewarisi nama dari blok RAM: <br><br><img src="https://habrastorage.org/webt/qs/_t/af/qs_taf1wiql9vccnl_7s_frbqci.png"><br><br>  Saya akan menunjukkan cara menambahkan bagian di mana kode akan ditempatkan.  Di bagian bagian, klik Tambah: <br><br><img src="https://habrastorage.org/webt/qa/8o/lu/qa8olur0jjxjhj2oz-dqwzmf3iy.png"><br><br>  Di jendela yang muncul, beri nama bagian (untuk menghindari kebingungan dalam artikel, saya akan menamainya sangat berbeda dengan nama wilayah, yaitu nccode) dan menghubungkannya dengan wilayah (saya memilih <b>NonCachedCode</b> dari daftar): <br><br><img src="https://habrastorage.org/webt/ji/eo/to/jieotoad61gc1i-xarabcynmqyy.png"><br><br>  Itu dia, hasilkan BSP dan tutup editor. <br><br><h2>  Menempatkan kode di bagian memori baru </h2><br>  Biarkan saya mengingatkan Anda bahwa kami memiliki dua fungsi dalam program yang diwarisi dari artikel sebelumnya: <b>MagicFunction1 ()</b> dan <b>MagicFunction2 ()</b> .  Pada pass pertama, keduanya memuat tubuh mereka ke dalam cache, yang terlihat pada osiloskop.  Lebih lanjut - tergantung pada situasi di lingkungan, mereka bekerja dengan kecepatan maksimum atau secara konstan saling menggosok dengan tubuh mereka, memprovokasi unduhan konstan dari SDRAM. <br><br>  Mari kita pindahkan fungsi pertama ke segmen yang tidak di-cache yang baru, dan biarkan yang kedua di tempatnya, lalu jalankan beberapa langkah. <br><blockquote>  Untuk menempatkan fungsi di bagian baru, tambahkan atribut <b>bagian</b> ke dalamnya. </blockquote>  Sebelum mendefinisikan fungsi <b>MagicFunction1 ()</b> , <b>kami</b> juga menempatkan deklarasi dengan atribut ini: <br><br><pre><code class="plaintext hljs">void MagicFunction1()__attribute__ ((section("nccode"))); void MagicFunction1() { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); ...</code> </pre> <br>  Kami melakukan run pertama dari satu iterasi dari loop (saya meletakkan breakpoint pada baris while): <br><pre> <code class="plaintext hljs"> while (1) { MagicFunction1(); MagicFunction2(); }</code> </pre><br>  Kami melihat hasil berikut: <br><br><img src="https://habrastorage.org/webt/vh/1q/jx/vh1qjxzrvwbudd99po6eerz47ja.png"><br><br>  Seperti yang Anda lihat, fungsi pertama benar-benar dijalankan pada kecepatan maksimum, yang kedua diambil dari SDRAM.  Jalankan jalankan kedua: <br><br><img src="https://habrastorage.org/webt/l9/ce/iv/l9ceivh_xyn8ip_xtyqv18u4i2a.png"><br><br>  Kedua fungsi beroperasi pada kecepatan maksimum.  Dan fungsi pertama tidak membongkar yang kedua dari cache, meskipun fakta bahwa di antara mereka adalah sisipan yang saya tinggalkan setelah menulis artikel terakhir: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops256 Nops256 Nops256 Nops64 Nops64 Nops64 Nops16 Nops16 }</code> </pre><br>  Penyisipan ini tidak lagi memengaruhi posisi relatif dari kedua fungsi tersebut, karena yang pertama tertinggal di area memori yang sama sekali berbeda. <br><br><h2>  Beberapa kata tentang data </h2><br>  Demikian pula, Anda dapat membuat bagian data yang tidak di-cache dan menempatkan variabel global di sana, menugaskan mereka atribut yang sama, tetapi untuk menghemat ruang, saya tidak akan memberikan contoh seperti itu. <br><br>  Kami telah membuat wilayah untuk memori seperti itu, pemetaan ke bagian dapat dilakukan dengan cara yang sama seperti untuk bagian kode.  Tetap hanya untuk memahami cara menetapkan atribut yang sesuai ke variabel.  Berikut ini adalah contoh pertama dari mendeklarasikan data tersebut yang ditemukan dalam isi kode yang dibuat secara otomatis: <br><br><pre> <code class="plaintext hljs">volatile alt_u32 alt_log_boot_on_flag \ __attribute__ ((section (".sdata"))) = ALT_LOG_BOOT_ON_FLAG_SETTING;</code> </pre><br><h2>  Apa manfaatnya bagi kita </h2><br>  Sebenarnya, dari hal-hal yang jelas: sekarang kita dapat menempatkan bagian utama dari kode di SDRAM, dan di bagian yang tidak dapat di-cache kita dapat mengeluarkan fungsi-fungsi yang membentuk diagram waktu secara terprogram, atau yang kinerjanya harus maksimal, yang berarti mereka tidak boleh melambat karena bahwa beberapa fungsi lain terus-menerus membuang kode yang sesuai dari cache. <br><br><h2>  Perhatikan baik-baik bannya. </h2><br>  Sekarang perhatikan baik-baik ban di sistem prosesor yang dihasilkan.  Kami punya hampir empat dari mereka.  Saya mengitari bus utama merah (yang merupakan gabungan dari keduanya, itulah sebabnya saya menulis "hampir": secara fisik - ada dua ban, tetapi secara logis - satu).  Saya menyoroti dalam warna hijau bus menuju ke memori instruksi yang tidak di-cache, dengan warna biru - ke memori data yang tidak di-cache.  <b>Ketiga ban ini bekerja secara paralel dan independen satu sama lain!</b> <br><br><img src="https://habrastorage.org/webt/kg/rv/wf/kgrvwfw1kncypo4x6mn4uehagng.png"><br><br>  Ingat, dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang DMA,</a> saya berpendapat bahwa salah satu faktor pembatas kinerja adalah bahwa data ditransmisikan pada bus yang sama?  Blok DMA membaca data dari bus, menulis data ke dalamnya, dan bahkan pada saat yang sama inti prosesor menggunakan bus yang sama.  Seperti yang Anda lihat, kelemahan sistem tertutup ini sepenuhnya dihilangkan dalam FPGA.  Pada pengontrol siap pakai, pabrikan, ketika meletakkan koneksi, dipaksa untuk merobek antara kebutuhan dan kemampuan.  Programmer mungkin perlu opsi ini.  Dan semacamnya.  Dan semacamnya.  Maka ... Banyak hal mungkin diperlukan.  Tetapi sumber daya membutuhkan biaya, dan tidak selalu ada ruang yang cukup untuk mereka pada kristal yang dipilih.  Anda tidak dapat memposting semuanya.  Kita harus memilih apa yang benar-benar dibutuhkan semua orang dan apa yang dibutuhkan dalam kasus-kasus yang terisolasi.  Dan kasus terisolasi mana yang harus diperkenalkan, dan mana yang harus dilupakan.  Dan kemudian muncul solusi kompromi, semua kehalusannya, jika ada keinginan untuk menggunakannya, programmer harus mengingatnya.  Dalam kasus kami, kami dapat bertindak tanpa basa-basi lagi.  Apa yang kita butuhkan hari ini diletakkan hari ini.  Sumber daya kami fleksibel.  Kami membelanjakannya agar peralatannya optimal untuk tugas kita hari ini.  Untuk tugas besok dan kemarin, sumber daya tidak perlu dipesan.  Tetapi di bawah hari ini kita akan meletakkan segala sesuatu sedemikian rupa sehingga program bekerja seefisien mungkin, tanpa memerlukan kesenangan pemrograman khusus. <br><br>  Sekali waktu, di sebuah universitas dalam kursus pengolah sinyal kami diajarkan seni menggunakan dua bus secara paralel dengan satu tim.  Sejauh yang saya tahu, dalam pengontrol ARM modern, pengetahuan rinci tentang matriks bus juga memungkinkan pengoptimalan.  Tapi semua ini bagus ketika pengembang telah bekerja dengan sistem yang sama selama bertahun-tahun.  Jika Anda harus menggunakan perangkat keras yang berbeda dari satu proyek ke proyek lainnya, Anda tidak dapat mengingat semuanya.  Dalam kasus FPGA, kami tidak mempelajari fitur-fitur lingkungan, kami bebas untuk menyesuaikan lingkungan untuk diri kami sendiri. <br><blockquote>  Sehubungan dengan pendekatan "kami tidak menghabiskan banyak waktu untuk pengembangan", kedengarannya seperti ini: <br>  Kita tidak perlu melakukan upaya untuk mengoptimalkan penggunaan ban standar yang sudah jadi, kita dapat dengan cepat meletakkannya di cara yang paling optimal untuk menyelesaikan tugas, dengan cepat menyelesaikan pengembangan bantu ini dan dengan cepat memastikan proses debugging atau pengujian proyek utama. </blockquote>  Mari kita lihat contoh termasuk blok DMA dari <b>Panduan Pengguna IP Perangkat Tertanam</b> untuk mengkonsolidasikan materi. <br><br><img src="https://habrastorage.org/webt/ww/hw/yg/wwhwygxdtfoxpuyftp00h2p_xde.png"><br><br>  Kami melihat tiga koneksi independen.  Input data (pada gambar ini adalah bus yang diproyeksikan ke memori), data keluaran (dalam gambar ini adalah bus yang sama sekali berbeda - antarmuka aliran) dan komunikasi dengan prosesor kontrol.  Tidak ada yang mengganggu untuk menghubungkan semuanya ke bus yang berbeda, maka pekerjaan akan berjalan paralel.  Input data (misalnya, dari SDRAM) akan masuk dalam satu aliran, yang tidak ada yang mengganggu;  output akan masuk dalam aliran yang berbeda, katakanlah, ke saluran FT245-FIFO, yang telah kita pertimbangkan;  dan prosesor pusat tidak akan makan jauh dari bus jam ini, karena bus utama terisolasi.  Meskipun dalam kasus ini, tentu saja, memori dalam SDRAM, berada di bus terpisah, tidak akan tersedia secara terprogram.  Tapi tidak ada yang akan mencegahnya dibaca oleh DMA.  Jika tujuannya adalah untuk mencapai kinerja tinggi dengan buffer, maka itu harus dicapai di semua biaya.  Kecuali jika keseluruhan program harus sesuai dengan memori yang terpasang dalam FPGA, karena tidak ada unit penyimpanan lain di perangkat keras Redd. <br><br>  Untuk memparalelkan ban, Anda juga dapat menggunakan ban yang tidak di-cache, karena kami melihat ada beberapa ban.  Sejumlah pembatasan diberlakukan pada budak yang terhubung dengan bus ini: <br><br><ul><li>  budak itu selalu ada di bus; </li><li>  budak tidak menggunakan mekanisme penundaan bus; </li><li>  tulis latensi selalu nol, baca latensi selalu satu. </li></ul><br>  Jika kondisi ini terpenuhi, perangkat budak seperti itu dapat dihubungkan ke bus yang tidak di-cache.  Tentu saja, kemungkinan besar, itu akan menjadi data bus. <br><br>  Secara umum, mengetahui prinsip-prinsip dasar ini, Anda tentu dapat menggunakannya dalam tugas nyata.  Tetapi, secara umum, Anda bisa.  Anda dapat melakukannya tanpa ini, jika hasilnya dicapai dengan cara konvensional.  Namun perlu diingat.  Terkadang, mengoptimalkan sistem melalui mekanisme ini lebih sederhana daripada memperbaiki program. <br><br><h2>  Kesimpulan </h2><br>  Kami memeriksa teknik untuk mentransfer bagian-bagian kode yang penting untuk kinerja atau ke prediktabilitas pemrosesan eksekusi dalam memori yang tidak dapat di-cache.  Sepanjang jalan, kami memeriksa kemungkinan mengoptimalkan kinerja melalui penggunaan beberapa ban yang beroperasi secara paralel dan independen satu sama lain. <br><br>  Untuk menyelesaikan topik, kita masih harus belajar cara menaikkan frekuensi jam sistem (sekarang ini terbatas pada pulsa clock yang menghasilkan komponen untuk chip SDRAM).  Tetapi karena artikel mengikuti prinsip "satu hal - satu artikel", kami akan melakukannya lain kali. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468027/">https://habr.com/ru/post/id468027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468015/index.html">Apa yang diketahui tentang ITIL 4 saat ini, dan siapa yang sudah menggunakan perpustakaan baru</a></li>
<li><a href="../id468017/index.html">The Maybe Monad via async / tunggu di C # (tanpa Task ov!)</a></li>
<li><a href="../id468019/index.html">Pengembangan situs web di WebAssembly menggunakan NetCore 3 dan Blazor</a></li>
<li><a href="../id468021/index.html">PHP, berapa banyak abstraksi untuk orang-orang?</a></li>
<li><a href="../id468023/index.html">Kecerdasan buatan dalam game pertarungan Shadow Fight 3</a></li>
<li><a href="../id468031/index.html">Kami port game multi-pemain dari C ++ ke web dengan Cheerp, WebRTC, dan Firebase</a></li>
<li><a href="../id468035/index.html">Unduh pers menggunakan pengontrol permainan, atau 8 paten yang tidak biasa untuk perangkat input</a></li>
<li><a href="../id468041/index.html">Pengumuman antarmuka web Kubernetes Web View (dan ikhtisar singkat tentang UI web lain untuk Kubernetes)</a></li>
<li><a href="../id468043/index.html">Cara membuat kit UI yang dijual. Tahapan mengembangkan sistem desain komersial</a></li>
<li><a href="../id468047/index.html">Bekerja dengan hierarki di lsFusion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>