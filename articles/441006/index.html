<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶 🤹🏾 🚴🏼 Una descripción general de los métodos de segmentación de imágenes en la biblioteca de imágenes scikit 🌉 🥦 🧔🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Umbral 
 Esta es la forma más fácil de separar objetos del fondo seleccionando píxeles por encima o por debajo de un cierto umbral. Esto suele ser úti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una descripción general de los métodos de segmentación de imágenes en la biblioteca de imágenes scikit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441006/"><h2>  Umbral </h2><br>  Esta es la forma más fácil de separar objetos del fondo seleccionando píxeles por encima o por debajo de un cierto umbral.  Esto suele ser útil cuando vamos a segmentar objetos por su fondo.  Puedes leer más sobre el umbral <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Las personas familiarizadas con la película Terminator probablemente estarán de acuerdo en que fue la mejor película de ciencia ficción de la época.  En la película, James Cameron introdujo un concepto interesante de efectos visuales, que permitió a los espectadores esconderse detrás de los ojos de un cyborg llamado Terminator.  Este efecto se conoce como "Terminator Vision" (Inglés Terminator Vision).  En cierto sentido, separó las siluetas de personas del fondo.  Esto puede sonar completamente inapropiado entonces, pero la segmentación de imágenes es una parte importante de muchas técnicas de procesamiento de imágenes en la actualidad. <br><br><h2>  Segmentación de imagen </h2><br>  Hay varias bibliotecas escritas para el análisis de imágenes.  En este artículo, analizaremos en detalle scikit-image, una biblioteca de procesamiento de imágenes de Python. <br><br><h2>  Scikit-image </h2><br><img src="https://habrastorage.org/webt/g2/fm/vh/g2fmvhs1nha3wxsoofyblton3hq.png" alt="imagen"><br><br>  Scikit-image es una biblioteca de Python para el procesamiento de imágenes. <br><br><h2>  Instalación </h2><br>  scikit-image se instala de la siguiente manera: <br><br><pre><code class="python hljs">pip install -U scikit-image(Linux <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> OSX) pip install scikit-image(Windows) <span class="hljs-comment"><span class="hljs-comment"># For Conda-based distributions conda install scikit-image</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/hy/at/nt/hyatntvr-9i-awiwo2yxcvx_vym.png"><br><a name="habracut"></a><br><h2>  Descripción general de la imagen de Python </h2><br>  Antes de pasar a los aspectos técnicos de la segmentación de imágenes, es importante familiarizarse un poco con el ecosistema de imágenes Scikit y cómo procesa las imágenes. <br><br><h3>  Importar imagen GrayScale de la biblioteca de skimage </h3><br>  El módulo de datos de skimage contiene varios ejemplos integrados de conjuntos de datos, que generalmente se almacenan en formato jpeg o png. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.binary_blobs() plt.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>)</code> </pre> <br><h3>  Importar imagen en color de la biblioteca de skimage </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.astronaut() plt.imshow(image)</code> </pre> <br><img src="https://habrastorage.org/webt/j2/8b/x5/j28bx5eailfqsuainwhmyskx4ek.png"><br><br><h3>  Importar una imagen desde una fuente externa </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># The I/O module is used for importing the image from skimage import data import numpy as np import matplotlib.pyplot as plt from skimage import io image = io.imread('skimage_logo.png') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/bx/ho/xe/bxhoxercb7yo1soyfgduy9asuwk.png"><br><br><h3>  Descargar múltiples imágenes </h3><br><pre> <code class="python hljs">images = io.ImageCollection(<span class="hljs-string"><span class="hljs-string">'../images/*.png:../images/*.jpg'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Type:'</span></span>, type(images)) images.files Out[]: Type: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skimage</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageCollection</span></span></span><span class="hljs-class">'&gt;</span></span></code> </pre> <br><h3>  Guardar imágenes </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Saving file as 'logo.png' io.imsave('logo.png', logo)</span></span></code> </pre> <br><h2>  Segmentación de imagen </h2><br>  Ahora que tenemos una idea de scikit-image, ofrecemos considerar los detalles de la segmentación de imágenes.  La segmentación de imágenes es el proceso de dividir una imagen digital en varios segmentos para simplificar y / o cambiar la representación de la imagen a algo más significativo y más fácil de analizar. <br><br>  En este artículo, consideraremos algoritmos para modelos enseñados tanto con un maestro (supervisado) como sin un maestro (sin supervisión). <br><br><img src="https://habrastorage.org/webt/zi/93/f7/zi93f7mpnuzuyo_evzeu6jqzxgo.png"><br>  <i>Algunos de los algoritmos de segmentación están disponibles en la biblioteca de imágenes scikit.</i> <br><br>  Segmentación con un profesor: algunos conocimientos preliminares, posiblemente a partir de aportes humanos, se utilizan para guiar el algoritmo. <br><br>  Segmentación sin profesor: no se requieren conocimientos previos.  Estos algoritmos intentan dividir automáticamente las imágenes en áreas significativas.  El usuario aún puede configurar ciertos parámetros para obtener los resultados deseados. <br><br>  Probemos esto en una imagen tutorial que viene con un conjunto de datos de imagen scikit predefinido. <br><br><h3>  Importación regular </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.segmentation <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> seg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.filters <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> filters <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.draw <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> draw <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.color <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> color</code> </pre> <br>  Característica de imagen simple <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image, nrows=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ncols=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cmap=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'gray'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>)) ax.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>) ax.axis(<span class="hljs-string"><span class="hljs-string">'off'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fig, ax</code> </pre> <br><h3>  Imagen </h3><br><pre> <code class="python hljs">text = data.page() image_show(text)</code> </pre> <br><img src="https://habrastorage.org/webt/hr/ci/ac/hrciacrdvu72qvq8yhivtvt1e78.png"><br><br>  Esta imagen es un poco más oscura, pero quizás aún podamos elegir un valor que nos dé una segmentación razonable sin algoritmos complicados.  Ahora, para ayudarnos a elegir este valor, utilizaremos un histograma. <br><br>  En este caso, el histograma muestra el número de píxeles en la imagen con diferentes intensidades encontradas en esta imagen.  En pocas palabras, un histograma es un gráfico en el que el eje X muestra todos los valores que están en la imagen, y el eje Y muestra la frecuencia de estos valores. <br><br><pre> <code class="python hljs">fig, ax = plt.subplots(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ax.hist(text.ravel(), bins=<span class="hljs-number"><span class="hljs-number">32</span></span>, range=[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>]) ax.set_xlim(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/8c/ha/nc/8chanc-jg5519ms6yk0w-h90lfc.png"><br><br>  Nuestro ejemplo resultó ser una imagen de 8 bits, por lo que tenemos 256 valores posibles a lo largo del eje X. El histograma muestra que hay una concentración de píxeles bastante brillantes (0: negro, 255: blanco).  Este es probablemente nuestro fondo de texto bastante claro, pero el resto es un poco borroso.  Un histograma de segmentación ideal sería bimodal para que podamos seleccionar un número justo en el medio.  Ahora intentemos crear algunas imágenes segmentadas basadas en un valor umbral simple. <br><br><h3>  Umbral controlado </h3><br>  Como nosotros mismos elegimos un valor umbral, lo llamamos un valor umbral controlado. <br><br><pre> <code class="python hljs">text_segmented = text &gt; (value concluded <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> histogram ie <span class="hljs-number"><span class="hljs-number">50</span></span>,<span class="hljs-number"><span class="hljs-number">70</span></span>,<span class="hljs-number"><span class="hljs-number">120</span></span> ) image_show(text_segmented);</code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/iv/2l/gr/iv2lgrmmcgef-0geutdoybn85t0.png"></td><td><img src="https://habrastorage.org/webt/rl/k3/on/rlk3oneyt6yvcuq9mqkwel7jg3k.png"></td><td><img src="https://habrastorage.org/webt/e5/o8/fw/e5o8fwm7cs7xzneo-v29k1_vf7e.png"></td></tr></tbody></table><br>  <i>Izquierda: texto&gt; 50 |</i>  <i>Mediados: texto&gt; 70 |</i>  <i>Derecha: texto&gt; 120</i> <br><br>  No obtuvimos resultados perfectos, ya que la sombra de la izquierda crea problemas.  Probemos con el umbral desatendido ahora. <br><br><h3>  Umbral no controlado </h3><br>  Umbral no controlado Scikit-image tiene una serie de métodos automáticos de determinación de umbral que no requieren entrada al elegir el umbral óptimo.  Estos son algunos de los métodos: otsu, li, local. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_ <span class="hljs-comment"><span class="hljs-comment"># Hit tab with the cursor after the underscore to get all the methods. image_show(text &lt; text_threshold);</span></span></code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zo/zb/ne/zozbnecnzak8i_-chy9ghhwa7e0.png"></td><td><img src="https://habrastorage.org/webt/h0/ik/-m/h0ik-mxys3qwdruh-gefraebnto.png"></td></tr></tbody></table><br>  <i>Izquierda otsu ||</i>  <i>Derecha: li</i> <br><br>  En el caso de local, también necesitamos especificar block_size.  La compensación ayuda a ajustar la imagen para obtener mejores resultados. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_local(text,block_size=<span class="hljs-number"><span class="hljs-number">51</span></span>, offset=<span class="hljs-number"><span class="hljs-number">10</span></span>) image_show(text &gt; text_threshold);</code> </pre> <br><img src="https://habrastorage.org/webt/en/ns/zp/ennszp_rpslshqnd0y78mqax76w.png"><br><br>  Este método da un muy buen efecto.  En gran medida, uno puede deshacerse de las regiones ruidosas. <br><br><h2>  Segmentación con un algoritmo para un modelo con un profesor. </h2><br>  El umbral es un proceso de segmentación muy simple, y no funcionará correctamente en una imagen de alto contraste, para lo cual necesitaremos herramientas más avanzadas. <br><br>  En esta sección, utilizaremos una imagen de ejemplo que está disponible gratuitamente y trataremos de segmentar la parte de la cabeza utilizando métodos con el maestro. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># import the image from skimage import io image = io.imread('girl.jpg') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/g6/dw/ga/g6dwgagldj71bqemwgosylqkusw.png"><br><br>  <i>Antes de hacer cualquier segmentación de imagen, se recomienda eliminar el ruido utilizando algunos filtros.</i> <br><br>  Sin embargo, en nuestro caso, la imagen no tiene un ruido significativo, por lo que la aceptaremos tal cual.  El siguiente paso es convertir la imagen a escala de grises usando rgb2gray. <br><br><pre> <code class="python hljs">image_gray = color.rgb2gray(image) image_show(image_gray);</code> </pre> <br><img src="https://habrastorage.org/webt/qx/jl/qs/qxjlqspqdsqiaxu6px23j4q7mvs.png"><br><br>  Utilizaremos dos métodos de segmentación que funcionan con principios completamente diferentes. <br><br><h3>  Segmentación activa del contorno </h3><br>  La segmentación de la ruta activa también se llama serpiente y se inicializa usando una ruta o línea definida por el usuario alrededor de una región de interés, y luego esta ruta se comprime lentamente y es atraída o repelida por la luz y los bordes. <br><br>  Para nuestra imagen de ejemplo, dibujemos un círculo alrededor de la cabeza humana para inicializar la serpiente. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle_points</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolution, center, radius)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Generate points which define a circle on an image.Centre refers to the centre of the circle """</span></span> radians = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi, resolution) c = center[<span class="hljs-number"><span class="hljs-number">1</span></span>] + radius*np.cos(radians)<span class="hljs-comment"><span class="hljs-comment">#polar co-ordinates r = center[0] + radius*np.sin(radians) return np.array([c, r]).T # Exclude last point because a closed path should not have duplicate points points = circle_points(200, [80, 250], 80)[:-1]</span></span></code> </pre> <br>  Los cálculos anteriores calculan las coordenadas xey de los puntos en la periferia del círculo.  Como le dimos una resolución de 200, calculará 200 de esos puntos. <br><br><pre> <code class="python hljs">fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/4o/f1/bu/4of1buz3h2boatz5lpfpnlogh6g.png"><br><br>  Luego, el algoritmo segmenta la cara de la persona del resto de la imagen, ajustando una curva cerrada a los bordes de la cara. <br><br><img src="https://habrastorage.org/webt/z_/o1/ep/z_o1epmu9zcrxuyju7tr85p9n1o.png"><br><br>  Podemos configurar parámetros llamados alfa y beta.  Los valores alfa más altos hacen que la curva se contraiga más rápido, mientras que la beta hace que la curva sea más suave. <br><br><pre> <code class="python hljs">snake = seg.active_contour(image_gray, points,alpha=<span class="hljs-number"><span class="hljs-number">0.06</span></span>,beta=<span class="hljs-number"><span class="hljs-number">0.3</span></span>) fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>) ax.plot(snake[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], snake[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'-b'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/ne/pw/vw/nepwvw8xqanbj61fikjg6qorxq0.png"><br><br><h3>  Segmentación aleatoria del caminante </h3><br>  En este método, la segmentación se lleva a cabo mediante el etiquetado interactivo, que se denomina etiquetas.  Al dibujar cada píxel en la etiqueta para la que se calcula la mayor probabilidad, puede obtener una segmentación de imagen de alta calidad.  Se pueden encontrar más detalles sobre este método en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> trabajo. <br><br>  A continuación, utilizaremos nuevamente los valores anteriores de nuestro ejemplo.  Podríamos haber hecho diferentes inicializaciones, pero por simplicidad, ceñámonos al principio de los círculos. <br><br><pre> <code class="python hljs">image_labels = np.zeros(image_gray.shape, dtype=np.uint8)</code> </pre> <br>  El algoritmo de paso aleatorio acepta etiquetas como entrada.  Por lo tanto, tendremos un círculo grande que cubra toda la cara de la persona, y otro círculo más pequeño cerca del centro de la cara. <br><br><pre> <code class="python hljs">indices = draw.circle_perimeter(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">250</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)<span class="hljs-comment"><span class="hljs-comment">#from here image_labels[indices] = 1 image_labels[points[:, 1].astype(np.int), points[:, 0].astype(np.int)] = 2 image_show(image_labels);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ol/2n/nw/ol2nnwq0un_qzngiv25atfh3d5g.png"><br>  Ahora usemos Random Walker y veamos qué sucede. <br><br><pre> <code class="python hljs">image_segmented = seg.random_walker(image_gray, image_labels) <span class="hljs-comment"><span class="hljs-comment"># Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/au/bs/jn/aubsjn1b1uedkiorghu5izwbbha.png"><br><br>  El resultado no es el mejor, los bordes de la cara permanecieron inalcanzados.  Para corregir esta situación, podemos ajustar el parámetro de pasaje hasta obtener el resultado deseado.  Después de varios intentos, establecemos el valor en 3000, que funciona bastante bien. <br><br><pre> <code class="plaintext hljs">image_segmented = seg.random_walker(image_gray, image_labels, beta = 3000) # Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</code> </pre><br><img src="https://habrastorage.org/webt/ii/4s/h1/ii4sh1n0rxcwgply9xmafyerk5a.png"><br><br>  Todo esto es para la segmentación con el profesor, donde tuvimos que proporcionar ciertos datos de entrada, así como configurar algunos parámetros.  Sin embargo, no siempre es posible que una persona mire la imagen y luego decida qué contribución dar y por dónde comenzar.  Afortunadamente, para tales situaciones, tenemos métodos de segmentación no controlados. <br><br><h2>  Segmentación sin profesor </h2><br>  La segmentación sin un maestro no requiere conocimiento previo.  Considere una imagen que es tan grande que es imposible ver todos los píxeles a la vez.  Por lo tanto, en tales casos, la segmentación sin un maestro puede dividir la imagen en varias subregiones, por lo que en lugar de millones de píxeles, tiene decenas o cientos de áreas.  Veamos dos de estos algoritmos: <br><br><h3>  Agrupación iterativa lineal simple </h3><br>  El método (inglés Simple Linear Iterative Clustering o SLIC) utiliza un algoritmo de aprendizaje automático llamado K-Means.  Toma todos los valores de píxeles de la imagen e intenta dividirlos en un número determinado de subdominios.  Lea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> trabajo para obtener información detallada. <br><br>  SLIC funciona con diferentes colores, por lo que utilizaremos la imagen original. <br><br><pre> <code class="python hljs">image_slic = seg.slic(image,n_segments=<span class="hljs-number"><span class="hljs-number">155</span></span>)</code> </pre> <br>  Todo lo que necesitamos hacer es simplemente establecer un valor promedio para cada segmento que encontremos, lo que hace que se parezca más a una imagen. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># label2rgb replaces each discrete label with the average interior color image_show(color.label2rgb(image_slic, image, kind='avg'));</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/7_/kn/b4/7_knb4b5fgefv0vsg3bed3dtx3o.png"><br><br>  Redujimos esta imagen de 512 * 512 = 262,000 píxeles a 155 segmentos. <br><br><h3>  Felzenszwalb </h3><br>  Este método también utiliza un algoritmo de aprendizaje automático denominado agrupamiento de árbol de mínima extensión.  Felzenszwaib no nos dice el número exacto de grupos en los que se dividirá la imagen.  Generará todos los grupos que considere adecuados para esto. <br><br><pre> <code class="python hljs">image_felzenszwalb = seg.felzenszwalb(image) image_show(image_felzenszwalb);</code> </pre> <br><img src="https://habrastorage.org/webt/ht/bk/ao/htbkaotqhcgg_xlbys0_z_0bwie.png"><br><br>  Hay demasiadas regiones en la imagen.  Vamos a contar la cantidad de segmentos únicos. <br><br><pre> <code class="python hljs">np.unique(image_felzenszwalb).size <span class="hljs-number"><span class="hljs-number">3368</span></span></code> </pre> <br>  Ahora volvamos a colorearlos usando el valor promedio sobre el segmento, como lo hicimos en el algoritmo SLIC. <br><br><pre> <code class="python hljs">image_felzenszwalb_colored = color.label2rgb(image_felzenszwalb, image, kind=<span class="hljs-string"><span class="hljs-string">'avg'</span></span>) image_show(image_felzenszwalb_colored);</code> </pre> <br>  Ahora tenemos menos segmentos.  Si quisiéramos incluso menos segmentos, podríamos cambiar el parámetro de escala.  Este enfoque a veces se llama sobre segmentación. <br><br><img src="https://habrastorage.org/webt/dw/-2/3-/dw-23-xllphmwajmn1sg-sk-nws.png"><br><br>  Esto es más como una imagen posterizada, que es esencialmente solo una reducción en la cantidad de colores.  Para combinarlos de nuevo (RAG). <br><br><h2>  Conclusión </h2><br>  La segmentación de imágenes es un paso muy importante en el procesamiento de imágenes.  Esta es un área activa de investigación con una variedad de aplicaciones, que van desde visión por computadora hasta imágenes médicas, tráfico y video vigilancia.  Python proporciona una biblioteca robusta de imágenes scikit con una gran cantidad de algoritmos de procesamiento de imágenes.  Está disponible de forma gratuita y sin restricciones, respaldado por una comunidad activa.  Le recomiendo que lea su documentación.  El artículo original se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441006/">https://habr.com/ru/post/441006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440994/index.html">Cuide su negocio desde una edad temprana o cómo crear una startup lean</a></li>
<li><a href="../440998/index.html">OpenStack amplía su cartera e involucra CI / CD</a></li>
<li><a href="../441000/index.html">Promoción: traiga un libro de papel y obtenga un descuento en cualquier lector electrónico ONYX BOOX</a></li>
<li><a href="../441002/index.html">Lo que finalizó la tercera prueba de Turing: estadísticas, diálogos interesantes e impresión general</a></li>
<li><a href="../441004/index.html">Splunk deja Rusia (completamente)</a></li>
<li><a href="../441008/index.html">Rabbit MQ en el sistema de procesamiento de residentes</a></li>
<li><a href="../441010/index.html">Baja a la tierra mortal ...</a></li>
<li><a href="../441012/index.html">Datos interesantes sobre la historia del programa lunar chino y la misión espacial Chang'e-4</a></li>
<li><a href="../441014/index.html">Representación estéreo de bajo presupuesto en pocas líneas de código (estereograma, anaglifo, estereoscopio)</a></li>
<li><a href="../441018/index.html">Herramientas de desarrollo y especificación del programa NanoCAD Mechanics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>