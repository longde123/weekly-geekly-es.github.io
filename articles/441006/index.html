<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游놌 游뱣游 游뛊游낖 Una descripci칩n general de los m칠todos de segmentaci칩n de im치genes en la biblioteca de im치genes scikit 游깰 游볹 游븺游낕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Umbral 
 Esta es la forma m치s f치cil de separar objetos del fondo seleccionando p칤xeles por encima o por debajo de un cierto umbral. Esto suele ser 칰ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una descripci칩n general de los m칠todos de segmentaci칩n de im치genes en la biblioteca de im치genes scikit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441006/"><h2>  Umbral </h2><br>  Esta es la forma m치s f치cil de separar objetos del fondo seleccionando p칤xeles por encima o por debajo de un cierto umbral.  Esto suele ser 칰til cuando vamos a segmentar objetos por su fondo.  Puedes leer m치s sobre el umbral <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> . <br><br>  Las personas familiarizadas con la pel칤cula Terminator probablemente estar치n de acuerdo en que fue la mejor pel칤cula de ciencia ficci칩n de la 칠poca.  En la pel칤cula, James Cameron introdujo un concepto interesante de efectos visuales, que permiti칩 a los espectadores esconderse detr치s de los ojos de un cyborg llamado Terminator.  Este efecto se conoce como "Terminator Vision" (Ingl칠s Terminator Vision).  En cierto sentido, separ칩 las siluetas de personas del fondo.  Esto puede sonar completamente inapropiado entonces, pero la segmentaci칩n de im치genes es una parte importante de muchas t칠cnicas de procesamiento de im치genes en la actualidad. <br><br><h2>  Segmentaci칩n de imagen </h2><br>  Hay varias bibliotecas escritas para el an치lisis de im치genes.  En este art칤culo, analizaremos en detalle scikit-image, una biblioteca de procesamiento de im치genes de Python. <br><br><h2>  Scikit-image </h2><br><img src="https://habrastorage.org/webt/g2/fm/vh/g2fmvhs1nha3wxsoofyblton3hq.png" alt="imagen"><br><br>  Scikit-image es una biblioteca de Python para el procesamiento de im치genes. <br><br><h2>  Instalaci칩n </h2><br>  scikit-image se instala de la siguiente manera: <br><br><pre><code class="python hljs">pip install -U scikit-image(Linux <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> OSX) pip install scikit-image(Windows) <span class="hljs-comment"><span class="hljs-comment"># For Conda-based distributions conda install scikit-image</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/hy/at/nt/hyatntvr-9i-awiwo2yxcvx_vym.png"><br><a name="habracut"></a><br><h2>  Descripci칩n general de la imagen de Python </h2><br>  Antes de pasar a los aspectos t칠cnicos de la segmentaci칩n de im치genes, es importante familiarizarse un poco con el ecosistema de im치genes Scikit y c칩mo procesa las im치genes. <br><br><h3>  Importar imagen GrayScale de la biblioteca de skimage </h3><br>  El m칩dulo de datos de skimage contiene varios ejemplos integrados de conjuntos de datos, que generalmente se almacenan en formato jpeg o png. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.binary_blobs() plt.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>)</code> </pre> <br><h3>  Importar imagen en color de la biblioteca de skimage </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.astronaut() plt.imshow(image)</code> </pre> <br><img src="https://habrastorage.org/webt/j2/8b/x5/j28bx5eailfqsuainwhmyskx4ek.png"><br><br><h3>  Importar una imagen desde una fuente externa </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># The I/O module is used for importing the image from skimage import data import numpy as np import matplotlib.pyplot as plt from skimage import io image = io.imread('skimage_logo.png') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/bx/ho/xe/bxhoxercb7yo1soyfgduy9asuwk.png"><br><br><h3>  Descargar m칰ltiples im치genes </h3><br><pre> <code class="python hljs">images = io.ImageCollection(<span class="hljs-string"><span class="hljs-string">'../images/*.png:../images/*.jpg'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Type:'</span></span>, type(images)) images.files Out[]: Type: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skimage</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageCollection</span></span></span><span class="hljs-class">'&gt;</span></span></code> </pre> <br><h3>  Guardar im치genes </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Saving file as 'logo.png' io.imsave('logo.png', logo)</span></span></code> </pre> <br><h2>  Segmentaci칩n de imagen </h2><br>  Ahora que tenemos una idea de scikit-image, ofrecemos considerar los detalles de la segmentaci칩n de im치genes.  La segmentaci칩n de im치genes es el proceso de dividir una imagen digital en varios segmentos para simplificar y / o cambiar la representaci칩n de la imagen a algo m치s significativo y m치s f치cil de analizar. <br><br>  En este art칤culo, consideraremos algoritmos para modelos ense침ados tanto con un maestro (supervisado) como sin un maestro (sin supervisi칩n). <br><br><img src="https://habrastorage.org/webt/zi/93/f7/zi93f7mpnuzuyo_evzeu6jqzxgo.png"><br>  <i>Algunos de los algoritmos de segmentaci칩n est치n disponibles en la biblioteca de im치genes scikit.</i> <br><br>  Segmentaci칩n con un profesor: algunos conocimientos preliminares, posiblemente a partir de aportes humanos, se utilizan para guiar el algoritmo. <br><br>  Segmentaci칩n sin profesor: no se requieren conocimientos previos.  Estos algoritmos intentan dividir autom치ticamente las im치genes en 치reas significativas.  El usuario a칰n puede configurar ciertos par치metros para obtener los resultados deseados. <br><br>  Probemos esto en una imagen tutorial que viene con un conjunto de datos de imagen scikit predefinido. <br><br><h3>  Importaci칩n regular </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.segmentation <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> seg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.filters <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> filters <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.draw <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> draw <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.color <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> color</code> </pre> <br>  Caracter칤stica de imagen simple <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image, nrows=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ncols=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cmap=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'gray'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>)) ax.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>) ax.axis(<span class="hljs-string"><span class="hljs-string">'off'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fig, ax</code> </pre> <br><h3>  Imagen </h3><br><pre> <code class="python hljs">text = data.page() image_show(text)</code> </pre> <br><img src="https://habrastorage.org/webt/hr/ci/ac/hrciacrdvu72qvq8yhivtvt1e78.png"><br><br>  Esta imagen es un poco m치s oscura, pero quiz치s a칰n podamos elegir un valor que nos d칠 una segmentaci칩n razonable sin algoritmos complicados.  Ahora, para ayudarnos a elegir este valor, utilizaremos un histograma. <br><br>  En este caso, el histograma muestra el n칰mero de p칤xeles en la imagen con diferentes intensidades encontradas en esta imagen.  En pocas palabras, un histograma es un gr치fico en el que el eje X muestra todos los valores que est치n en la imagen, y el eje Y muestra la frecuencia de estos valores. <br><br><pre> <code class="python hljs">fig, ax = plt.subplots(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ax.hist(text.ravel(), bins=<span class="hljs-number"><span class="hljs-number">32</span></span>, range=[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>]) ax.set_xlim(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/8c/ha/nc/8chanc-jg5519ms6yk0w-h90lfc.png"><br><br>  Nuestro ejemplo result칩 ser una imagen de 8 bits, por lo que tenemos 256 valores posibles a lo largo del eje X. El histograma muestra que hay una concentraci칩n de p칤xeles bastante brillantes (0: negro, 255: blanco).  Este es probablemente nuestro fondo de texto bastante claro, pero el resto es un poco borroso.  Un histograma de segmentaci칩n ideal ser칤a bimodal para que podamos seleccionar un n칰mero justo en el medio.  Ahora intentemos crear algunas im치genes segmentadas basadas en un valor umbral simple. <br><br><h3>  Umbral controlado </h3><br>  Como nosotros mismos elegimos un valor umbral, lo llamamos un valor umbral controlado. <br><br><pre> <code class="python hljs">text_segmented = text &gt; (value concluded <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> histogram ie <span class="hljs-number"><span class="hljs-number">50</span></span>,<span class="hljs-number"><span class="hljs-number">70</span></span>,<span class="hljs-number"><span class="hljs-number">120</span></span> ) image_show(text_segmented);</code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/iv/2l/gr/iv2lgrmmcgef-0geutdoybn85t0.png"></td><td><img src="https://habrastorage.org/webt/rl/k3/on/rlk3oneyt6yvcuq9mqkwel7jg3k.png"></td><td><img src="https://habrastorage.org/webt/e5/o8/fw/e5o8fwm7cs7xzneo-v29k1_vf7e.png"></td></tr></tbody></table><br>  <i>Izquierda: texto&gt; 50 |</i>  <i>Mediados: texto&gt; 70 |</i>  <i>Derecha: texto&gt; 120</i> <br><br>  No obtuvimos resultados perfectos, ya que la sombra de la izquierda crea problemas.  Probemos con el umbral desatendido ahora. <br><br><h3>  Umbral no controlado </h3><br>  Umbral no controlado Scikit-image tiene una serie de m칠todos autom치ticos de determinaci칩n de umbral que no requieren entrada al elegir el umbral 칩ptimo.  Estos son algunos de los m칠todos: otsu, li, local. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_ <span class="hljs-comment"><span class="hljs-comment"># Hit tab with the cursor after the underscore to get all the methods. image_show(text &lt; text_threshold);</span></span></code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zo/zb/ne/zozbnecnzak8i_-chy9ghhwa7e0.png"></td><td><img src="https://habrastorage.org/webt/h0/ik/-m/h0ik-mxys3qwdruh-gefraebnto.png"></td></tr></tbody></table><br>  <i>Izquierda otsu ||</i>  <i>Derecha: li</i> <br><br>  En el caso de local, tambi칠n necesitamos especificar block_size.  La compensaci칩n ayuda a ajustar la imagen para obtener mejores resultados. <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_local(text,block_size=<span class="hljs-number"><span class="hljs-number">51</span></span>, offset=<span class="hljs-number"><span class="hljs-number">10</span></span>) image_show(text &gt; text_threshold);</code> </pre> <br><img src="https://habrastorage.org/webt/en/ns/zp/ennszp_rpslshqnd0y78mqax76w.png"><br><br>  Este m칠todo da un muy buen efecto.  En gran medida, uno puede deshacerse de las regiones ruidosas. <br><br><h2>  Segmentaci칩n con un algoritmo para un modelo con un profesor. </h2><br>  El umbral es un proceso de segmentaci칩n muy simple, y no funcionar치 correctamente en una imagen de alto contraste, para lo cual necesitaremos herramientas m치s avanzadas. <br><br>  En esta secci칩n, utilizaremos una imagen de ejemplo que est치 disponible gratuitamente y trataremos de segmentar la parte de la cabeza utilizando m칠todos con el maestro. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># import the image from skimage import io image = io.imread('girl.jpg') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/g6/dw/ga/g6dwgagldj71bqemwgosylqkusw.png"><br><br>  <i>Antes de hacer cualquier segmentaci칩n de imagen, se recomienda eliminar el ruido utilizando algunos filtros.</i> <br><br>  Sin embargo, en nuestro caso, la imagen no tiene un ruido significativo, por lo que la aceptaremos tal cual.  El siguiente paso es convertir la imagen a escala de grises usando rgb2gray. <br><br><pre> <code class="python hljs">image_gray = color.rgb2gray(image) image_show(image_gray);</code> </pre> <br><img src="https://habrastorage.org/webt/qx/jl/qs/qxjlqspqdsqiaxu6px23j4q7mvs.png"><br><br>  Utilizaremos dos m칠todos de segmentaci칩n que funcionan con principios completamente diferentes. <br><br><h3>  Segmentaci칩n activa del contorno </h3><br>  La segmentaci칩n de la ruta activa tambi칠n se llama serpiente y se inicializa usando una ruta o l칤nea definida por el usuario alrededor de una regi칩n de inter칠s, y luego esta ruta se comprime lentamente y es atra칤da o repelida por la luz y los bordes. <br><br>  Para nuestra imagen de ejemplo, dibujemos un c칤rculo alrededor de la cabeza humana para inicializar la serpiente. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle_points</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolution, center, radius)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Generate points which define a circle on an image.Centre refers to the centre of the circle """</span></span> radians = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi, resolution) c = center[<span class="hljs-number"><span class="hljs-number">1</span></span>] + radius*np.cos(radians)<span class="hljs-comment"><span class="hljs-comment">#polar co-ordinates r = center[0] + radius*np.sin(radians) return np.array([c, r]).T # Exclude last point because a closed path should not have duplicate points points = circle_points(200, [80, 250], 80)[:-1]</span></span></code> </pre> <br>  Los c치lculos anteriores calculan las coordenadas xey de los puntos en la periferia del c칤rculo.  Como le dimos una resoluci칩n de 200, calcular치 200 de esos puntos. <br><br><pre> <code class="python hljs">fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/4o/f1/bu/4of1buz3h2boatz5lpfpnlogh6g.png"><br><br>  Luego, el algoritmo segmenta la cara de la persona del resto de la imagen, ajustando una curva cerrada a los bordes de la cara. <br><br><img src="https://habrastorage.org/webt/z_/o1/ep/z_o1epmu9zcrxuyju7tr85p9n1o.png"><br><br>  Podemos configurar par치metros llamados alfa y beta.  Los valores alfa m치s altos hacen que la curva se contraiga m치s r치pido, mientras que la beta hace que la curva sea m치s suave. <br><br><pre> <code class="python hljs">snake = seg.active_contour(image_gray, points,alpha=<span class="hljs-number"><span class="hljs-number">0.06</span></span>,beta=<span class="hljs-number"><span class="hljs-number">0.3</span></span>) fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>) ax.plot(snake[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], snake[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'-b'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/ne/pw/vw/nepwvw8xqanbj61fikjg6qorxq0.png"><br><br><h3>  Segmentaci칩n aleatoria del caminante </h3><br>  En este m칠todo, la segmentaci칩n se lleva a cabo mediante el etiquetado interactivo, que se denomina etiquetas.  Al dibujar cada p칤xel en la etiqueta para la que se calcula la mayor probabilidad, puede obtener una segmentaci칩n de imagen de alta calidad.  Se pueden encontrar m치s detalles sobre este m칠todo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> trabajo. <br><br>  A continuaci칩n, utilizaremos nuevamente los valores anteriores de nuestro ejemplo.  Podr칤amos haber hecho diferentes inicializaciones, pero por simplicidad, ce침치monos al principio de los c칤rculos. <br><br><pre> <code class="python hljs">image_labels = np.zeros(image_gray.shape, dtype=np.uint8)</code> </pre> <br>  El algoritmo de paso aleatorio acepta etiquetas como entrada.  Por lo tanto, tendremos un c칤rculo grande que cubra toda la cara de la persona, y otro c칤rculo m치s peque침o cerca del centro de la cara. <br><br><pre> <code class="python hljs">indices = draw.circle_perimeter(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">250</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)<span class="hljs-comment"><span class="hljs-comment">#from here image_labels[indices] = 1 image_labels[points[:, 1].astype(np.int), points[:, 0].astype(np.int)] = 2 image_show(image_labels);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ol/2n/nw/ol2nnwq0un_qzngiv25atfh3d5g.png"><br>  Ahora usemos Random Walker y veamos qu칠 sucede. <br><br><pre> <code class="python hljs">image_segmented = seg.random_walker(image_gray, image_labels) <span class="hljs-comment"><span class="hljs-comment"># Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/au/bs/jn/aubsjn1b1uedkiorghu5izwbbha.png"><br><br>  El resultado no es el mejor, los bordes de la cara permanecieron inalcanzados.  Para corregir esta situaci칩n, podemos ajustar el par치metro de pasaje hasta obtener el resultado deseado.  Despu칠s de varios intentos, establecemos el valor en 3000, que funciona bastante bien. <br><br><pre> <code class="plaintext hljs">image_segmented = seg.random_walker(image_gray, image_labels, beta = 3000) # Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</code> </pre><br><img src="https://habrastorage.org/webt/ii/4s/h1/ii4sh1n0rxcwgply9xmafyerk5a.png"><br><br>  Todo esto es para la segmentaci칩n con el profesor, donde tuvimos que proporcionar ciertos datos de entrada, as칤 como configurar algunos par치metros.  Sin embargo, no siempre es posible que una persona mire la imagen y luego decida qu칠 contribuci칩n dar y por d칩nde comenzar.  Afortunadamente, para tales situaciones, tenemos m칠todos de segmentaci칩n no controlados. <br><br><h2>  Segmentaci칩n sin profesor </h2><br>  La segmentaci칩n sin un maestro no requiere conocimiento previo.  Considere una imagen que es tan grande que es imposible ver todos los p칤xeles a la vez.  Por lo tanto, en tales casos, la segmentaci칩n sin un maestro puede dividir la imagen en varias subregiones, por lo que en lugar de millones de p칤xeles, tiene decenas o cientos de 치reas.  Veamos dos de estos algoritmos: <br><br><h3>  Agrupaci칩n iterativa lineal simple </h3><br>  El m칠todo (ingl칠s Simple Linear Iterative Clustering o SLIC) utiliza un algoritmo de aprendizaje autom치tico llamado K-Means.  Toma todos los valores de p칤xeles de la imagen e intenta dividirlos en un n칰mero determinado de subdominios.  Lea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> trabajo para obtener informaci칩n detallada. <br><br>  SLIC funciona con diferentes colores, por lo que utilizaremos la imagen original. <br><br><pre> <code class="python hljs">image_slic = seg.slic(image,n_segments=<span class="hljs-number"><span class="hljs-number">155</span></span>)</code> </pre> <br>  Todo lo que necesitamos hacer es simplemente establecer un valor promedio para cada segmento que encontremos, lo que hace que se parezca m치s a una imagen. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># label2rgb replaces each discrete label with the average interior color image_show(color.label2rgb(image_slic, image, kind='avg'));</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/7_/kn/b4/7_knb4b5fgefv0vsg3bed3dtx3o.png"><br><br>  Redujimos esta imagen de 512 * 512 = 262,000 p칤xeles a 155 segmentos. <br><br><h3>  Felzenszwalb </h3><br>  Este m칠todo tambi칠n utiliza un algoritmo de aprendizaje autom치tico denominado agrupamiento de 치rbol de m칤nima extensi칩n.  Felzenszwaib no nos dice el n칰mero exacto de grupos en los que se dividir치 la imagen.  Generar치 todos los grupos que considere adecuados para esto. <br><br><pre> <code class="python hljs">image_felzenszwalb = seg.felzenszwalb(image) image_show(image_felzenszwalb);</code> </pre> <br><img src="https://habrastorage.org/webt/ht/bk/ao/htbkaotqhcgg_xlbys0_z_0bwie.png"><br><br>  Hay demasiadas regiones en la imagen.  Vamos a contar la cantidad de segmentos 칰nicos. <br><br><pre> <code class="python hljs">np.unique(image_felzenszwalb).size <span class="hljs-number"><span class="hljs-number">3368</span></span></code> </pre> <br>  Ahora volvamos a colorearlos usando el valor promedio sobre el segmento, como lo hicimos en el algoritmo SLIC. <br><br><pre> <code class="python hljs">image_felzenszwalb_colored = color.label2rgb(image_felzenszwalb, image, kind=<span class="hljs-string"><span class="hljs-string">'avg'</span></span>) image_show(image_felzenszwalb_colored);</code> </pre> <br>  Ahora tenemos menos segmentos.  Si quisi칠ramos incluso menos segmentos, podr칤amos cambiar el par치metro de escala.  Este enfoque a veces se llama sobre segmentaci칩n. <br><br><img src="https://habrastorage.org/webt/dw/-2/3-/dw-23-xllphmwajmn1sg-sk-nws.png"><br><br>  Esto es m치s como una imagen posterizada, que es esencialmente solo una reducci칩n en la cantidad de colores.  Para combinarlos de nuevo (RAG). <br><br><h2>  Conclusi칩n </h2><br>  La segmentaci칩n de im치genes es un paso muy importante en el procesamiento de im치genes.  Esta es un 치rea activa de investigaci칩n con una variedad de aplicaciones, que van desde visi칩n por computadora hasta im치genes m칠dicas, tr치fico y video vigilancia.  Python proporciona una biblioteca robusta de im치genes scikit con una gran cantidad de algoritmos de procesamiento de im치genes.  Est치 disponible de forma gratuita y sin restricciones, respaldado por una comunidad activa.  Le recomiendo que lea su documentaci칩n.  El art칤culo original se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441006/">https://habr.com/ru/post/441006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440994/index.html">Cuide su negocio desde una edad temprana o c칩mo crear una startup lean</a></li>
<li><a href="../440998/index.html">OpenStack ampl칤a su cartera e involucra CI / CD</a></li>
<li><a href="../441000/index.html">Promoci칩n: traiga un libro de papel y obtenga un descuento en cualquier lector electr칩nico ONYX BOOX</a></li>
<li><a href="../441002/index.html">Lo que finaliz칩 la tercera prueba de Turing: estad칤sticas, di치logos interesantes e impresi칩n general</a></li>
<li><a href="../441004/index.html">Splunk deja Rusia (completamente)</a></li>
<li><a href="../441008/index.html">Rabbit MQ en el sistema de procesamiento de residentes</a></li>
<li><a href="../441010/index.html">Baja a la tierra mortal ...</a></li>
<li><a href="../441012/index.html">Datos interesantes sobre la historia del programa lunar chino y la misi칩n espacial Chang'e-4</a></li>
<li><a href="../441014/index.html">Representaci칩n est칠reo de bajo presupuesto en pocas l칤neas de c칩digo (estereograma, anaglifo, estereoscopio)</a></li>
<li><a href="../441018/index.html">Herramientas de desarrollo y especificaci칩n del programa NanoCAD Mechanics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>