<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ”§ ğŸ––ğŸ¿ ğŸ© CSTroN - monitor buatan sendiri pada matriks CSTN vintage dengan input-VGA dan papan kontrol FPGA ğŸ“‰ ğŸ––ğŸ¿ ğŸ§›</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana jika TFT tidak pernah ditemukan? LCD matriks CSTN 

 Entri 
 Ketika monitor CRT menang, argumen berikut diajukan untuk mereka: terlepas dari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CSTroN - monitor buatan sendiri pada matriks CSTN vintage dengan input-VGA dan papan kontrol FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444762/"><img src="https://habrastorage.org/webt/ts/vw/uo/tsvwuobygirooozzafy1gnmiiua.jpeg"><br><br>  Bagaimana jika TFT tidak pernah ditemukan?  LCD matriks CSTN <br><br><h1>  Entri </h1><br>  Ketika monitor CRT menang, argumen berikut diajukan untuk mereka: terlepas dari semua perbaikan, layar LCD tidak akan pernah mengungguli tampilan tabung dalam kualitas gambar.  Mereka, seperti sebelumnya, akan menemukan aplikasi hanya di mana efisiensi energi dan ketebalan kecil diperlukan [1].  Beberapa dekade telah berlalu, dan sekarang kita tahu apakah para pendukung argumen ini benar.  Tetapi hari ini menarik untuk melihat LCD pada waktu itu: apakah mereka benar-benar berkualitas buruk?  Bagaimana rasanya melihat matriks CSTN pada tahun 2019? <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/fm/yv/rf/fmyvrfvnpiqfyih0abovza8tn-m.jpeg"><br><br>  <i>TFT kiri, CSTN kanan, keduanya ditampilkan dari tahun sembilan puluhan</i> <br><br><h1>  LCD di abad terakhir </h1><br>  Sebelum beralih ke TFT, berbagai teknologi tampilan digunakan di komputer laptop.  Pada awalnya, mereka menggunakan monitor CRT yang sama seperti di komputer desktop, hanya yang lebih kecil.  Misalnya, dalam Compaq Portable (1983), IBM 5155 (1984) atau Commodore SX-64 (juga 1984). <br><br><img src="https://habrastorage.org/webt/ge/nb/za/genbzaejmhqeermw61pdxau4nli.jpeg"><br><br>  <i>IBM 5155, penulis: Soupmeister, berlisensi: CC-BY-SA-2.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a></i> <br><br>  Membawa PC seperti itu ke mana-mana adalah hal yang sulit, hal yang sama sekali berbeda - laptop dengan TN-LCD (twist nematic), misalnya, IBM 5140 (1986), Toshiba T1000 (1987).  Layar ini memiliki kontras rendah dan sudut pandang. <br><br><img src="https://habrastorage.org/webt/ee/u8/xr/eeu8xrwciq0nl2cl6z8cha0zu5u.jpeg"><br><br>  <i>Toshiba T1100 dengan monokrom TN-display, penulis: Johann H. Addicks, lisensi: GFDL, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">karenanya</a> tautannya terputus, dalam versi aslinya juga</i> <br><br>  Beberapa produsen bereksperimen dengan matriks pelepasan gas, seperti Toshiba T3200 (1987) dan IBM PS / 2 P70 (1991) melihat cahaya hari.  Mereka memberikan kontras tinggi dan beberapa gradasi kecerahan cahaya merah-oranye, tetapi harganya cukup mahal.  Akhirnya, STN-LCD (supertwist nematic) dikembangkan, seperti, misalnya, di Electronics MC1504 dan prototipe Toshiba T1100.  Kontrasnya jauh lebih baik - dari 1: 5 hingga 1:50, dan beberapa gradasi kecerahan cukup untuk aplikasi bisnis (menggunakan laptop dalam kehidupan sehari-hari masih terlalu mahal).  Tetapi bagaimana jika pengguna menginginkan gambar berwarna?  Dalam hal ini, ia ditawari dua teknologi: TFT dan CSTN (color supertwist nematic).  Laptop pertama dengan TFT - NEC PC9801NC - diperkenalkan pada tahun 1990, kualitas gambar untuk tahun-tahun itu di atas semua pujian, tetapi harganya "mainan seperti itu" jauh lebih mahal daripada laptop mahal lainnya.  Nah, tampilan CSTN hanyalah tampilan STN, di mana filter dilapiskan.  Untuk waktu yang lama, laptop menggunakan matriks dari kedua jenis.  Dan di kereta bawah tanah New York, monitor CSTN masih berfungsi. <br><br><img src="https://habrastorage.org/webt/kk/ch/bd/kkchbdoyuc75xvwabt_3zwmrcp0.jpeg"><br><br>  <i>Salah satunya, sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transit + PLUS</a></i> <br><br><h1>  Cstron </h1><br>  Penulis ingin melihat tampilan CSTN.  Bagaimana?  Sebagai permulaan, beli saja laptop lama dan gunakan.  Ternyata prosesor AMD 5x86-P133.  Artinya, hal paling dinamis yang dapat Anda jalankan di dalamnya adalah game DOS (oh well, MPEG1 akan menarik QV - penerjemah dalam program).  Tentu saja, memainkannya bagus, tetapi saya ingin melihat bagaimana YouTube, misalnya, atau permainan modern terlihat di layar seperti itu - tetapi ini tidak mungkin. <br><br>  Atau? <br><br>  Secara umum, Anda perlu menambahkan input VGA atau HDMI ke dalamnya - dan Anda dapat mengirim sinyal dari sesuatu yang modern.  Layar TFT dari laptop sangat sering dibuat ulang menjadi monitor.  Beli saja papan yang sesuai dengan matriks - dan Anda selesai.  Dan Anda dapat membuat awalan sendiri pada FPGA, yang mengubah sinyal VGA atau HDMI menjadi aliran data piksel. <br><br>  Sekali waktu, ada juga papan yang diproduksi untuk mengubah matriks CSTN menjadi monitor VGA, tetapi ini tidak lagi ditemukan.  Tetapi Anda dapat mengadaptasi papan debug untuk FPGA ML505 untuk ini. <br><br><img src="https://habrastorage.org/webt/ts/vw/uo/tsvwuobygirooozzafy1gnmiiua.jpeg"><br><br>  <i>Hasil jadi.</i>  <i>Sangat tidak biasa untuk mengamati ini di layar CSTN: RAM 16 GB.</i> <br><br><h1>  Manajemen matriks </h1><br>  Mari kita mulai dengan dasar-dasarnya.  Seperti halnya tampilan matriks, tampilan CSTN memiliki baris dan kolom.  Apakah Anda pernah mengendalikan matriks LED dari mikrokontroler?  Itu sama di sini, tetapi tegangannya bervariasi.  Anda perlu menerapkan sinyal tertentu untuk baris dan kolom yang dipilih dan tidak dipilih - dan piksel di persimpangan baris dan kolom yang dipilih akan menunjukkan apa yang Anda butuhkan.  Bentuk sinyal sangat kompleks, nilai kuadrat rata-rata dari tegangan, pergeseran fasa antara tegangan pada baris dan kolom, dan offset ... Jadi, piksel demi piksel, gambar terbentuk. <br><br>  Untungnya, FPGA tidak diperlukan untuk menghasilkan semua sinyal ini, dan bahkan pada sejumlah besar garis.  Semua ini dilakukan oleh modul yang terpasang pada layar.  Di sana, konverter pulsa meningkatkan tegangan konstan, melewati pembagi dan pengulang, sehingga tegangan bias diperoleh.  Driver baris dan kolom mengubah tegangan ini menjadi variabel dengan bentuk yang diperlukan.  Yang diperlukan hanyalah mengirimkan aliran data status piksel ke modul tampilan. <br><br>  Pada TFT-LCD dengan antarmuka DPI (antarmuka paralel digital), semua data sekitar satu piksel tiba sekaligus dalam satu siklus.  Pada garis sinkronisasi horizontal dan bingkai, pulsa diterima masing-masing setelah setiap garis dan bingkai.  Pixel secara terus-menerus ditransmisikan baris demi baris, bingkai demi bingkai.  Jika transmisi full frame membutuhkan 1/60 dtk, maka kecepatan refresh adalah 60 Hz.  Lebar bus data sama dengan kedalaman warna dalam bit, biasanya 16 (5 bit untuk merah dan biru, 6 untuk hijau), 18 (6 bit untuk setiap warna), atau 24 (8 bit untuk setiap warna).  LVDS adalah hal yang sama, hanya bit yang tidak ditransmisikan secara paralel, tetapi secara berurutan dalam pasangan diferensial, tetapi dalam MIPI DSI mereka juga digabungkan menjadi paket.  Bus SPI / i80 memungkinkan Anda untuk mengirim berbagai perintah ke controller, dan jika dijalankan, menghasilkan sinyal untuk DPI atau antarmuka serupa.  Yang, pada gilirannya, agak mengingatkan pada VGA, hanya data pada kecerahan dari masing-masing warna yang diterima bukan dalam analog, tetapi dalam bentuk digital.  Ada konverter VGA ke DPI dan sebaliknya.  Papan sangat mudah digunakan, memungkinkan Anda menerima sinyal VGA dari Raspberry Pi, meskipun pada awalnya komputer ini hanya menghasilkan HDMI dan video komposit. <br><br>  Sinyal yang sangat mirip dengan yang dipasok ke matriks TFT dengan antarmuka DPI harus dipasok ke modul tampilan matriks CSTN.  Lembar data pada SX21V001 [2] menunjukkan cara mengontrol tampilan CSTN dengan resolusi 640x480: <br><br><img src="https://habrastorage.org/webt/ga/au/fu/gaaufudmnscsyjt2mj89ir2hj-g.png"><br><br>  Ini menunjukkan transfer seluruh frame.  Sinyal tiba di jalur CL1 setelah setiap baris, di FLM setelah setiap frame.  Dan ada bus data 16 baris.  Sebenarnya, kesalahan dibuat dalam gambar ini: selama transmisi baris pertama dan kedua, data Y1 dan Y2, dan bukan X1 dan X2, tetapi masing-masing Y140 dan Y242, diterima pada jalur UD0-UD7.  Di sini U dan L adalah, masing-masing, atas dan bawah, yaitu, layar terdiri dari dua matriks dengan resolusi 640x240, terletak satu di atas yang lain.  Ini dia, "pemindaian ganda" misterius dari iklan laptop lama, yang darinya terdapat strip horizontal di seluruh layar.  Untuk tampilan STN dan CSTN, kontrasnya berbanding terbalik dengan jumlah garis, sehingga pemisahan ini memungkinkan untuk ditingkatkan.  Tapi ini bukan satu-satunya cara mereka berbeda dalam cara mereka dikendalikan dari TFT. <br><br><img src="https://habrastorage.org/webt/po/cu/_2/pocu_2wfevtfpev7hbuapasb2va.png"><br><br>  Tidak jelas mengapa sumbu horizontal disebut Y ... Tapi bagaimanapun, CL2 di sini adalah garis untuk memasok pulsa clock yang berganti pixel.  Tetapi bus UD dan LD dalam satu siklus tidak mengirimkan data tentang satu piksel multi-bit, seperti pada TFT, tetapi data tentang beberapa piksel sekaligus, masing-masing tiga bit.  Satu bit per warna, tiga bit per pixel - total delapan warna. <br><br><img src="https://habrastorage.org/webt/ur/dr/6u/urdr6uzrqstflu-gy2r5q-opazy.jpeg"><br><br>  Tapi bagaimana caranya?  Jelas bahwa tampilan CSTN memiliki beberapa warna, misalnya 4096 atau 32768, tetapi tidak 8.  Ternyata PWM diterapkan di sini.  LED dikendalikan dengan cara ini, yang berarti piksel LCD dimungkinkan.  Anda perlu, misalnya, kecerahan 50% - nyalakan piksel dalam bingkai genap dan matikan dalam bingkai aneh.  Metode ini disebut FRC (frame rate control), tetapi PWM dalam konteks ini disebut pixel brightness control dengan cara yang sama, tetapi dalam dua atau lebih frame, tetapi satu.  FRC mengimplementasikan perangkat eksternal, dan PWM mengimplementasikan chip modul display, jika ada dukungan untuk fungsi ini.  Penulis tidak mengetahui tampilan CSTN dengan PWM, tetapi ia menyarankan bahwa ini adalah matriks tipe-HPA.  Bagaimanapun, karena PWM tidak tersedia, kedalaman warna yang diperlukan dapat diperoleh dengan menggunakan FRC. <br><br><img src="https://habrastorage.org/webt/2s/fv/ui/2sfvuishe3qnnb9fytk4mmbthju.jpeg"><br><br>  Berkedip-kedip akan menjadi harga ini, jadi frame rate yang mengerikan (dibandingkan dengan TFT) dapat ditemukan di layar CSTN.  Sebagai contoh, modul ini awalnya memiliki 120 Hz, dan penulis overclock ke 240. <br><br><h1>  Bagaimana penerapannya </h1><br>  Pengembang menghadapi beberapa kesulitan sekaligus: <br><br>  - sinyal input memiliki frame rate 60 Hz, itu harus dua kali lipat atau bahkan empat kali lipat <br><br>  - dalam sinyal input, frame tidak dibagi menjadi dua bagian atas dan bawah masing-masing 640x240 piksel, tetapi di sini perlu untuk membagi <br><br>  - Anda juga perlu menerapkan FRC, jika tidak, kedalaman warna akan menjadi 3 bit per piksel <br><br>  Dua poin pertama berarti bahwa framebuffer diperlukan, dan bukan yang sederhana, tetapi dua port.  Nah, tugas ketiga diselesaikan menggunakan GLDP LUT (tabel pola pencarian tampilan level grayscale) [3].  Tabel pencarian memiliki dua jenis data input: warna yang akan ditampilkan, dan status penghitung bingkai.  Dan satu jenis output: tiga bit yang perlu diserahkan ke subpiksel piksel yang diberikan pada saat tertentu.  Oleh karena itu, simpul berikut akan diperlukan: <br><br><img src="https://habrastorage.org/webt/fi/lx/4-/filx4-nrwyepv-5jjdvjd5jvgh0.png"><br><br>  Hal pertama yang harus dilakukan adalah mengisi seluruh layar dengan beberapa warna.  Pada tahap ini, tidak perlu untuk mengetahui di mana piksel berada, cukup untuk memastikan bahwa modul tampilan memberikan sinyal bentuk yang diperlukan ke matriks.  Kode untuk mengisi FPGA ada di <a href="">sini</a> . <br><br><img src="https://habrastorage.org/webt/_m/ux/-q/_mux-qskx5al8bielsybiavnvba.jpeg"><br><br>  Sekarang cobalah untuk mengeluarkan sesuatu, dan dengan kecerahan yang tidak lengkap juga.  Mencari tabel pencarian FRC untuk meminimalkan flicker.  Penulis menghasilkan dua tabel yang diterapkan pada piksel dalam pola kotak-kotak.  Oleh karena itu, setiap dua piksel yang berdekatan berkedip secara tidak sinkron.  Kodenya ada di <a href="">sini</a> . <br><br><img src="https://habrastorage.org/webt/f2/vl/n9/f2vln9pc18h0txrwkm632snrlns.jpeg"><br><br>  Jadi, kita sudah "mengajarkan" papan untuk menampilkan gambar, hal berikutnya yang akan diperlukan adalah framebuffer.  Pada 640x480 dan 5 bit untuk masing-masing warna, volumenya akan sekitar 600 kilobyte.  Tidak banyak, tetapi begitu banyak di FPGA.  Nah, board memiliki RAM seperti DDR2 dan Xilinx MIG untuk mengendalikannya.  Dua FIFO diterapkan, satu untuk membaca dan satu untuk menulis.  Arbiter memutuskan apakah pertukaran data berikutnya dengan DDR2 dibaca atau ditulis.  Ada dua buffer, catatan masuk ke satu, membaca dari yang lain, dan ketika mengubah bingkai, mereka mengubah tempat.  Kode arbitrator ada di <a href="">sini</a> . <br><br>  Masih menerapkan pengambilan video, di salah satu proyek sebelumnya penulis sudah memiliki waktu operasi yang sama, setelah penyempurnaan, kode untuk konverter dari VGA ke DPI menjadi <a href="">seperti ini</a> . <br><br><h1>  Dan apa yang terjadi? </h1><br>  Lihat itu! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hsehw-7-VTM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ini adalah proyek FPGA ketiga untuk penulis, menarik untuk bekerja dengan Xilinx MIG dan DDR2, serta dengan konveyor sederhana.  FRC yang lebih baik dengan modulasi delta sigma direncanakan, serta eksperimen dengan panel CSTN kemudian menggunakan teknologi HPA (High Performance Addressing) Sharp. <br><br>  Terima kasih atas perhatian anda! <br><br><h1>  Sumber </h1><br>  1. Li, W., &amp; Guo, Q. (2000).  Teknologi Aplikasi Layar Kristal Cair.  Beijing: Pers Industri Listrik. <br><br>  2. HITACHI (1999).  Spesifikasi Penerimaan Pelanggan SX21V001-Z4. <br><br>  3. Hsueh, Y., &amp; Lee, J. (2008).  Metode peningkatan gambar untuk pengontrol kecepatan bingkai LCD.  Simposium Internasional IEEE 2008 tentang Elektronik Konsumen.  doi: 10.1109 / isce.2008.4559534 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444762/">https://habr.com/ru/post/id444762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444748/index.html">3 kualitas utama dari manajer produk yang sukses: Yuri Golikov, VP of Engineering Wrike</a></li>
<li><a href="../id444752/index.html">Sejarah SXSW: Bagaimana Semuanya Dimulai</a></li>
<li><a href="../id444756/index.html">DARPA akan mengembangkan mesin nuklir roket</a></li>
<li><a href="../id444758/index.html">Perbedaan teknis sistem BI (Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../id444760/index.html">Mesin CNC dari apa yang terbaring di garasi</a></li>
<li><a href="../id444764/index.html">Kriptografi di Jawa</a></li>
<li><a href="../id444766/index.html">Karyawan Facebook memiliki akses ke kata sandi pengguna Facebook dan Instagram</a></li>
<li><a href="../id444768/index.html">Mengurangi ketergantungan pada data yang ditandai untuk jaringan pertikaian generatif</a></li>
<li><a href="../id444770/index.html">Bagaimana kami mencari kebocoran data di SimilarWeb</a></li>
<li><a href="../id444774/index.html">Kesalahan dengan migrasi ru-RU lokal di Google Chrome dan cara menghilangkannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>