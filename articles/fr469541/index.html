<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏾 🦔 👩🏻‍🤝‍👨🏿 Assemblage et déploiement des mêmes microservices avec werf et GitLab CI 👨🏾‍💼 🤸🏾 ⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a deux ans, nous avons publié l’article « Générer des projets avec GitLab CI: un .gitlab-ci.yml pour des centaines d’applications », et nous allo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assemblage et déploiement des mêmes microservices avec werf et GitLab CI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/469541/"><img src="https://habrastorage.org/webt/m-/6b/h3/m-6bh3ggyovi2pibiz4iwnfraw0.png"><br><br>  Il y a deux ans, nous avons publié l’article « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Générer des projets avec GitLab CI: un .gitlab-ci.yml pour des centaines d’applications</a> », et nous allons maintenant parler de la résolution d’un problème similaire aujourd’hui.  Le nouveau matériel concerne la façon dont vous pouvez créer des processus CI / CD pour un grand nombre d'applications similaires avec l'avènement d' <code>include</code> dans <code>.gitlab-ci.yml</code> et l'avènement de werf pour remplacer dapp. <a name="habracut"></a><br><br><h2>  Introduction </h2><br>  Dans les instructions supplémentaires données dans l'article, la situation suivante est prise en compte: <br><br><ul><li>  Il existe une grande application cliente, divisée en plusieurs référentiels. </li><li>  Chaque référentiel est une application distincte qui doit être exécutée dans un cluster Kubernetes. </li><li>  En tant que système CI, GitLab CI est utilisé. </li><li>  Le déploiement (l'infrastructure dans laquelle le code est déployé) est décrit par les graphiques Helm. </li><li>  Créez des images et déployez-les dans Kubernetes à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">werf</a> . </li></ul><br>  Pour plus de simplicité et de commodité (et en hommage à la mode), nous continuerons à appeler ces applications des microservices.  <b>Tous ces microservices sont assemblés, déployés et lancés de la même manière</b> , et des paramètres spécifiques sont configurés à l'aide de variables d'environnement. <br><br>  De toute évidence, la copie de <code>.gitlab-ci.yml</code> , <code>werf.yaml</code> et <code>.helm</code> beaucoup de problèmes.  Après tout, toute modification dans CI, le processus d'assemblage ou la description du Helm-chart doit être ajoutée à d'autres référentiels ... <br><br><h2>  Connexion de modèles dans .gitlab-ci.yml </h2><br>  Avec l'avènement de la directive <code>include:file</code> dans GitLab CE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">depuis la version 11.7</a> ), il est devenu possible de créer un CI commun.  <code>include</code> lui-même est apparu un peu plus tôt (en 11.4), mais il a permis de connecter des modèles uniquement à partir <i>d'</i> URL <i>publiques</i> , ce qui a quelque peu limité sa fonctionnalité.  La documentation de GitLab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décrit parfaitement</a> toutes les fonctionnalités et exemples d'utilisation. <br><br>  Ainsi, il a été possible de refuser de copier <code>.gitlab-ci.yml</code> entre les référentiels et de soutenir sa pertinence.  Voici un exemple <code>.gitlab-ci.yml</code> avec <code>include</code> : <br><br><pre> <code class="plaintext hljs">include: - project: 'infra/gitlab-ci' ref: 1.0.0 file: base-gitlab-ci.yaml - project: 'infra/gitlab-ci' ref: 1.0.0 file: cleanup.yaml</code> </pre> <br>  Nous vous recommandons fortement d'utiliser les noms de branche en <code>ref</code> <b>avec prudence</b> .  Les inclusions sont calculées au moment de la création du pipeline, de sorte que les modifications de votre CI peuvent automatiquement tomber dans le pipeline de production au moment le plus inopportun.  Mais l' <b>utilisation de balises dans <code>ref</code></b> facilite la version de la description des processus CI / CD.  Lors de la mise à jour, tout semble aussi transparent que possible et vous pouvez facilement suivre l'historique des modifications dans les versions de pipeline si vous utilisez le contrôle de version sémantique pour les balises. <br><br><h2>  Connectez .helm à partir d'un référentiel distinct </h2><br>  Étant donné que ces microservices sont déployés et exécutés de la même manière, le même ensemble de modèles Helm est requis.  Pour éviter de copier le répertoire <code>.helm</code> entre les référentiels, nous avons utilisé pour cloner le référentiel dans lequel les modèles Helm étaient stockés et vérifiés sur la balise souhaitée.  Cela ressemblait à ceci: <br><br><pre> <code class="bash hljs"> - git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://gitlab-ci-token:<span class="hljs-variable"><span class="hljs-variable">${CI_JOB_TOKEN}</span></span>@gitlab.example.com/infra/helm.git .helm - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> .helm &amp;&amp; git checkout tags/1.0.0 - <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> multiwerf &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> &lt;(multiwerf use 1.0 beta) - <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> werf &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - werf deploy --stages-storage :<span class="hljs-built_in"><span class="hljs-built_in">local</span></span></code> </pre> <br>  Il y avait aussi des variantes utilisant des sous-modules git, mais tout cela ressemble plus à une solution de contournement ... <br><br>  Et maintenant, avec la récente version de werf, il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a la possibilité de</a> connecter des graphiques à partir de référentiels externes.  La prise en charge complète des fonctions du gestionnaire de packages a, à son tour, permis de décrire de manière <i>transparente</i> les dépendances pour le déploiement de l'application. <br><br><h2>  Séquence d'actions </h2><br>  Revenons à la résolution de notre problème avec les microservices.  Augmentons notre référentiel pour stocker les graphiques Helm - par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ChartMuseum</a> .  Il se déploie facilement sur un cluster Kubernetes: <br><br><pre> <code class="bash hljs">helm repo add stable https://kubernetes-charts.storage.googleapis.com helm install stable/chartmuseum --name flant-chartmuseum</code> </pre> <br>  Ajouter une entrée: <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: kubernetes.io/ingress.class: nginx nginx.ingress.kubernetes.io/force-ssl-redirect: "false" nginx.ingress.kubernetes.io/proxy-body-size: 10m nginx.ingress.kubernetes.io/ssl-redirect: "false" name: chart-museum spec: rules: - host: flant-chartmuseum.example.net http: paths: - backend: serviceName: flant-chartmuseum servicePort: 8080 path: / status: loadBalancer: {}</code> </pre> <br>  Le déploiement <code>flant-chartmuseum</code> doit remplacer la variable d'environnement <code>DISABLE_API</code> par <code>false</code> .  Sinon (par défaut), les requêtes de l'API ChartMuseum ne fonctionneront pas et il ne sera pas possible de créer de nouveaux graphiques. <br><br>  Nous décrivons maintenant le référentiel dans lequel les graphiques Helm partagés seront stockés.  La structure de ses répertoires est la suivante: <br><br><pre> <code class="plaintext hljs">. ├── charts │ └── yii2-microservice │ ├── Chart.yaml │ └── templates │ ├── app.yaml └── README.md</code> </pre> <br>  <code>Chart.yaml</code> pourrait ressembler à ceci: <br><br><pre> <code class="plaintext hljs">name: yii2-microservice version: 1.0.4</code> </pre> <br>  Le répertoire des <code>templates</code> doit contenir toutes les primitives Kubernetes nécessaires qui seront nécessaires pour déployer l'application sur le cluster.  Comme vous l'avez peut-être déjà deviné, dans ce cas, le microservice est une application PHP basée sur le framework yii2.  Décrivons son déploiement minimal avec deux conteneurs nginx et php-fpm qui sont construits à l'aide de werf: <br><br><pre> <code class="plaintext hljs">--- apiVersion: apps/v1 kind: Deployment metadata: name: {{ .Values.global.werf.name }} spec: replicas: 1 revisionHistoryLimit: 3 template: metadata: labels: service: {{ .Values.global.werf.name }} spec: imagePullSecrets: - name: registrysecret containers: - name: backend {{ tuple "backend" . | include "werf_container_image" | indent 8 }} command: [ '/usr/sbin/php-fpm7', "-F" ] ports: - containerPort: 9000 protocol: TCP name: http env: {{ tuple "backend" . | include "werf_container_env" | indent 8 }} - name: frontend command: ['/usr/sbin/nginx'] {{ tuple "frontend" . | include "werf_container_image" | indent 8 }} ports: - containerPort: 80 name: http lifecycle: preStop: exec: command: ["/usr/sbin/nginx", "-s", "quit"] env: {{ tuple "frontend" . | include "werf_container_env" | indent 8 }} --- apiVersion: v1 kind: Service metadata: name: {{ .Values.global.werf.name }} spec: selector: service: {{ .Values.global.werf.name }} ports: - name: http port: 80 protocol: TCP</code> </pre> <br>  La variable <code>.Values.global.werf.name</code> contient le nom du projet à partir du fichier <code>werf.yaml</code> , ce qui vous permet d'obtenir les noms de services et de déploiements nécessaires. <br><br>  Faisons l'automatisation la plus simple pour pousser dans le ChartMuseum de nos graphiques lors de la validation dans la branche principale.  Pour ce faire, nous décrivons <code>.gitlab-ci.yml</code> : <br><br><pre> <code class="plaintext hljs">Build and push to chartmuseum: script: - for i in $(ls charts); do helm package "charts/$i"; done; - for i in $(find . -type f -name "*.tgz" -printf "%f\n"); do curl --data-binary "@$i" http://flant-chartmuseum.example.net/api/charts; done; stage: build environment: name: infra only: - master tags: - my-shell-runner-tag</code> </pre> <br>  Les graphiques sont versionnés en changeant la <code>version</code> dans <code>Chart.yaml</code> .  Tous les nouveaux graphiques seront automatiquement ajoutés au ChartMuseum. <br><br>  Nous allons à la ligne d'arrivée!  Dans le référentiel du projet en <code>.helm/requirements.yaml</code> écrivons les dépendances du graphique: <br><br><pre> <code class="plaintext hljs">dependencies: - name: yii2-microservice version: "1.0.4" repository: "@flant"</code> </pre> <br>  ... et exécutez dans le répertoire avec le référentiel: <br><br><pre> <code class="bash hljs">werf helm repo init werf helm repo add flant http://flant-chartmuseum.example.net werf helm dependency update</code> </pre> <br>  Nous <code>.helm/requirements.lock</code> .  Maintenant, pour déployer l'application sur le cluster, il suffit d'exécuter la <code>werf helm dependency build</code> avant d'exécuter <code>werf deploy</code> . <br><br>  Pour mettre à jour la description du déploiement de l'application, vous devez maintenant parcourir les référentiels avec des microservices et appliquer de petits correctifs avec des modifications des hachages et des balises dans <code>requirements.yaml</code> et <code>requirements.lock</code> .  Si vous le souhaitez, cette opération peut également être automatisée via CI: nous avons déjà décrit comment procéder dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article mentionné</a> . <br><br><h2>  Conclusion </h2><br>  J'espère que la séquence d'actions décrite pour l'entretien d'applications similaires sera utile aux ingénieurs confrontés à des problèmes similaires.  Et nous serons heureux de partager d'autres recettes pratiques pour utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">werf</a> .  Par conséquent, si vous rencontrez des difficultés qui semblent insurmontables ou simplement incompréhensibles à mettre en œuvre, n'hésitez pas à contacter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Telegram</a> ou à laisser des demandes de futurs documents ici dans les commentaires. <br><br><h2>  PS </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Créez des projets avec GitLab CI: un .gitlab-ci.yml pour des centaines d'applications</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitLab CI pour une intégration et une livraison continues en production.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: notre pipeline</a> »; </li><li>  Une série de notes sur les innovations dans werf: <br><ul><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de werf pour déployer des graphiques Helm complexes</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge de monorepo et multirepo dans werf et qu'est-ce que le Docker Registry a à voir avec cela</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vous pouvez maintenant créer des images Docker dans werf en utilisant le Dockerfile habituel</a> ." </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469541/">https://habr.com/ru/post/fr469541/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469527/index.html">L'interphone est-il une oreille d'espion?</a></li>
<li><a href="../fr469529/index.html">Le rendu de texte vous déteste</a></li>
<li><a href="../fr469531/index.html">"Comparer les langages de programmation sur une base meilleure-pire est une occupation complètement idiote."</a></li>
<li><a href="../fr469533/index.html">Problèmes et menaces d'identification biométrique</a></li>
<li><a href="../fr469537/index.html">Apprendre à connaître Swift avec Snake</a></li>
<li><a href="../fr469543/index.html">Redis Scaling and Failover pour DirectumRX Services</a></li>
<li><a href="../fr469545/index.html">Nouveautés du noyau Linux 5.3 - Pilotes graphiques, virtualisation et modifications dans le sous-système réseau</a></li>
<li><a href="../fr469549/index.html">Comment avons-nous fait le tarif pour Windows VPS pour 99 roubles</a></li>
<li><a href="../fr469551/index.html">VDS avec une carte vidéo - nous en savons beaucoup sur les perversions</a></li>
<li><a href="../fr469555/index.html">Diffusion: Meetup Moscou Kubernetes # 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>