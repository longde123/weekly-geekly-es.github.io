<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍃 🙎🏾 👨🏿‍🤝‍👨🏾 Die ganze Wahrheit über Linux Epoll 👧 🌑 🈶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na ja, oder fast alle ... 





 Ich glaube, dass das Problem im modernen Internet eine Überfülle an Informationen unterschiedlicher Qualität ist. Das...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über Linux Epoll</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416669/"><p>  Na ja, oder fast alle ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/91f/776/71c/91f77671c2186bc1f2393c47e0696ee9.png"></p><br><p>  Ich glaube, dass das Problem im modernen Internet eine Überfülle an Informationen unterschiedlicher Qualität ist.  Das Finden von Material zu einem interessanten Thema ist kein Problem. Das Problem besteht darin, gutes Material von schlechtem Material zu unterscheiden, wenn Sie wenig Erfahrung auf diesem Gebiet haben.  Ich beobachte ein Bild, wenn es viele Übersichtsinformationen "oben" gibt (fast auf der Ebene einer einfachen Auflistung), sehr wenige ausführliche Artikel und keine Übergangsartikel von einfach zu komplex.  Dennoch ist es die Kenntnis der Merkmale eines bestimmten Mechanismus, die es uns ermöglicht, während der Entwicklung eine fundierte Entscheidung zu treffen. </p><br><p>  In dem Artikel werde ich versuchen aufzuzeigen, was der grundlegende Unterschied zwischen <strong>Epoll</strong> und anderen Mechanismen ist, was es einzigartig macht, und Artikel zitieren, die Sie nur lesen müssen, um die Möglichkeiten und Probleme von <strong>Epoll</strong> besser zu verstehen. </p><br><blockquote> Jeder kann eine Axt führen, aber es braucht einen wahren Krieger, um eine Nahkampfmelodie zu singen. </blockquote><p>  Ich <strong>gehe</strong> davon aus, dass der Leser mit <strong>epoll</strong> vertraut ist, zumindest die Manpage lesen.  Es wurde genug über <strong>epoll</strong> , <strong>poll</strong> , <strong>select geschrieben,</strong> damit jeder, der sich unter Linux entwickelt, mindestens einmal davon gehört hat. </p><a name="habracut"></a><br><h1 id="mnoga--fd">  Viel fd </h1><br><p>  Wenn Leute über <strong>Epoll</strong> sprechen, höre ich im Grunde die These, dass seine "Leistung besser ist, wenn es viele Dateideskriptoren gibt". </p><br><p>  Ich möchte nur eine Frage stellen - wie viel ist wie viel?  Wie viele Verbindungen werden benötigt und vor allem unter welchen Bedingungen wird <strong>epoll</strong> anfangen, spürbare Leistungssteigerungen zu erzielen? </p><br><p>  Für diejenigen, die <strong>Epoll</strong> studiert haben (es gibt viel Material, einschließlich wissenschaftlicher Artikel), liegt die Antwort auf der Hand - es ist genau dann besser, wenn die Anzahl der Verbindungen, die auf ein Ereignis warten, die Anzahl der verarbeitungsfertigen Verbindungen erheblich übersteigt.  Wenn der Gewinn so signifikant wird, dass es einfach keinen Urin gibt, der diese Tatsache ignoriert, werden 10k-Verbindungen berücksichtigt [4]. </p><br><p>  Die Annahme, dass die meisten Verbindungen anstehen, beruht auf einer soliden Logik und Lastüberwachung von Servern, die aktiv verwendet werden. </p><br><p>  Wenn die Anzahl der Wirkstoffe die Gesamtzahl anstrebt, <del>  Es wird keinen Gewinn geben </del>  Es wird keinen signifikanten Gewinn geben, ein signifikanter Gewinn ist auf und nur zurückzuführen, weil <strong>epoll</strong> nur Deskriptoren zurückgibt, die Aufmerksamkeit erfordern, und <strong>poll</strong> alle Deskriptoren zurückgibt, die zur Beobachtung hinzugefügt wurden. </p><br><p>  Im letzteren Fall verbringen wir natürlich Zeit damit, alle Deskriptoren + den Aufwand für das Kopieren eines Arrays von Ereignissen aus dem Kernel zu durchlaufen. </p><br><p>  Tatsächlich wird dieser Punkt bei der anfänglichen Leistungsmessung, die dem Patch beigefügt war [9], nicht unterstrichen, und man kann nur anhand des im Artikel erwähnten Dienstprogramms deadcon raten (leider geht der Dienstprogrammcode pipetest.c verloren).  Andererseits ist es in anderen Quellen [6, 8] sehr schwierig, es nicht zu bemerken, da diese Tatsache praktisch herausragt. </p><br><p>  Die Frage stellt sich sofort, aber was ist nun, wenn nicht geplant ist, <strong>sozusagen</strong> eine solche Anzahl von <strong>Epoll-</strong> Dateideskriptoren zu bedienen, und dies nicht erforderlich ist? </p><br><p>  Trotz der Tatsache, dass <strong>epoll</strong> ursprünglich speziell für solche Situationen erstellt wurde [5, 8, 9], ist dies bei weitem nicht der einzige Unterschied zwischen <strong>epoll</strong> . </p><br><h1 id="epollet">  EPOLLET </h1><br><p>  Zunächst werden wir uns den Unterschied zwischen flankengetriggerten und pegelgetriggerten Triggern ansehen. Eine gute Aussage zu diesem Thema finden Sie im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Edge Triggered Vs Level Triggered Interrupts - Venkatesh Yadav</a> : </p><br><blockquote>  Unterbrechung des Levels, es ist wie bei einem Kind.  Wenn das Baby weint, müssen Sie alles aufgeben, was Sie getan haben, und zum Baby laufen, um es zu füttern.  Dann legst du das Baby wieder in die Krippe.  Wenn er wieder weint, werden Sie ihn nirgendwo lassen, aber Sie werden versuchen, ihn zu beruhigen.  Und während das Kind weint, werden Sie es keinen Moment verlassen und erst dann zur Arbeit zurückkehren, wenn es sich beruhigt.  Aber nehmen wir an, wir gingen in den Garten (Unterbrechung ausgeschaltet), als das Kind anfing zu weinen, und als Sie nach Hause zurückkehrten (Unterbrechung eingeschaltet), war das erste, was Sie tun, das Kind zu überprüfen.  Aber Sie werden nie erfahren, dass er geweint hat, als Sie im Garten waren. <br><br>  Eine Unterbrechung an der Front ist wie ein elektronisches Kindermädchen für gehörlose Eltern.  Sobald das Kind auf dem Gerät zu weinen beginnt, leuchtet ein rotes Licht auf und leuchtet auf, bis Sie die Taste drücken.  Selbst wenn das Kind anfing zu weinen, aber schnell stehen blieb und einschlief, werden Sie immer noch wissen, dass das Kind weinte.  Aber wenn er anfing zu weinen und Sie den Knopf gedrückt haben (Bestätigung der Unterbrechung), leuchtet das Licht nicht auf, selbst wenn er weiter weint.  Der Schallpegel im Raum sollte abfallen und dann wieder ansteigen, damit das Licht aufleuchtet. </blockquote><p>  Wenn der <strong>Epoll</strong> (sowie <strong>Poll</strong> / <strong>Select</strong> ) im Level-Trigger-Verhalten entsperrt ist, wenn sich der Deskriptor im angegebenen Status befindet und bis zum Löschen dieses Status als aktiv betrachtet wird, wird der Flanken-Trigger nur durch Ändern des aktuell angegebenen geordneten Status entsperrt. </p><br><p>  Auf diese Weise können Sie das Ereignis später und nicht sofort nach dem Empfang behandeln (fast eine direkte Analogie zur oberen und unteren Hälfte des Interrupt-Handlers). </p><br><p>  Spezifisches Beispiel mit epoll: </p><br><p>  Level ausgelöst </p><br><ul><li>  Griff zum <strong>Epoll</strong> mit Flag <strong>EPOLLIN hinzugefügt</strong> </li><li>  <strong>epoll_wait ()</strong> blockiert, während auf ein Ereignis gewartet wird </li><li>  Schreiben Sie 19 Bytes in den Dateideskriptor </li><li>  <strong>epoll_wait () wird</strong> mit dem <strong>EPOLLIN-</strong> Ereignis entsperrt </li><li>  Wir machen nichts mit den Daten, die kamen </li><li>  <strong>epoll_wait ()</strong> wird mit dem <strong>EPOLLIN-</strong> Ereignis erneut <strong>entsperrt</strong> </li></ul><br><p>  Dies wird so lange fortgesetzt, bis wir die Daten aus dem Deskriptor vollständig gezählt oder zurückgesetzt haben. </p><br><p>  Flanke ausgelöst </p><br><ul><li>  Handle mit <strong>EPOLLIN-</strong> Flags zu <strong>epoll</strong> <strong>hinzugefügt |</strong>  <strong>EPOLLET</strong> </li><li>  <strong>epoll_wait ()</strong> blockiert, während auf ein Ereignis gewartet wird </li><li>  Schreiben Sie 19 Bytes in den Dateideskriptor </li><li>  <strong>epoll_wait () wird</strong> mit dem <strong>EPOLLIN-</strong> Ereignis entsperrt </li><li>  Wir machen nichts mit den Daten, die kamen </li><li>  <strong>epoll_wait () ist</strong> blockiert und wartet auf ein neues Ereignis </li><li>  Schreiben Sie weitere 19 Bytes in den Dateideskriptor </li><li>  <strong>epoll_wait () wird</strong> mit dem neuen <strong>EPOLLIN-</strong> Ereignis entsperrt </li><li>  <strong>epoll_wait () ist</strong> blockiert und wartet auf ein neues Ereignis </li></ul><br><p>  einfaches Beispiel: <a href="">epollet_socket.c</a> </p><br><p>  Dieser Mechanismus soll die Rückgabe von <strong>epoll_wait ()</strong> aufgrund eines Ereignisses verhindern, das bereits verarbeitet wird. </p><br><p>  Wenn im Fall von level beim Aufrufen von <strong>epoll_wait () der</strong> Kernel prüft, ob sich fd in diesem Zustand befindet, überspringt edge diese Prüfung und versetzt den aufrufenden Prozess sofort in den Ruhezustand. </p><br><p>  <strong>EPOLLET selbst</strong> macht <strong>Epoll</strong> O (1) zu einem Multiplexer für Ereignisse. </p><br><p>  Es ist notwendig, über <strong>EAGAIN</strong> und <strong>EPOLLET</strong> zu erklären - die Empfehlung mit <strong>EAGAIN lautet</strong> , Byte-Stream nicht zu behandeln, die Gefahr im letzteren Fall entsteht nur, wenn Sie den Deskriptor nicht bis zum Ende gelesen haben und keine neuen Daten gekommen sind.  Dann hängt der Schwanz im Deskriptor, aber Sie erhalten keine neue Benachrichtigung.  Mit <strong>accept () ist die</strong> Situation einfach anders. Dort müssen Sie fortfahren, bis <strong>accept ()</strong> <strong>EAGAIN zurückgibt</strong> . Nur in diesem Fall ist die korrekte Operation garantiert. </p><br><pre><code class="hljs lua">// TCP socket (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> stream) //  fd    EPOLLIN      int <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(fd, buffer, BUFFER_LEN); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span> &lt; BUFFER_LEN) { //   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         //  -       epoll_wait, //      }</code> </pre> <br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ accept /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  listenfd    EPOLLIN      event.events = EPOLLIN | EPOLLERR; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &amp;event); sleep(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       &gt;1  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { newfd = accept(listenfd, ...); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  epoll_wait    listenfd    } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { while((newfd = accept(...)) &gt; 0) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -  } if(newfd == -1 &amp;&amp; errno = EAGAIN) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       } }</span></span></code> </pre> <br><p>  Mit dieser Eigenschaft ist nur Hunger genug: </p><br><ul><li>  Pakete kommen zum Deskriptor </li><li>  Pakete in den Puffer lesen </li><li>  Ein weiteres Paket kommt </li><li>  Pakete in den Puffer lesen </li><li>  kommt eine kleine Portion </li><li>  ... </li></ul><br><p>  Daher <strong>werden</strong> wir <strong>EAGAIN nicht</strong> bald erhalten, aber wir werden es möglicherweise überhaupt nicht erhalten. </p><br><p>  Daher erhalten andere Dateideskriptoren keine Zeit für die Verarbeitung, und wir sind damit beschäftigt, ständig ankommende kleine Datenmengen zu lesen. </p><br><h1 id="thundering-nerd-herd">  donnern <del>  Nerd </del>  Herde </h1><br><p>  Um zur letzten Flagge zu gelangen, müssen Sie verstehen, warum sie tatsächlich erstellt wurde und eines der Probleme, die Entwickler bei der Entwicklung von Technologie und Software hatten. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://en.wikipedia.org/wiki/">Donnerndes Herdenproblem</a> </p><br><blockquote>  Problem mit der Donnerherde <br><br>  Stellen Sie sich eine Vielzahl von Prozessen vor, die auf ein Ereignis warten.  Wenn ein Ereignis eintritt, werden sie geweckt und der Kampf um Ressourcen beginnt, obwohl nur ein Prozess erforderlich ist, der sich mit der weiteren Verarbeitung des Ereignisses befasst.  Der Rest der Prozesse wird wieder schlafen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IT-Terminologie - Vasily Alekseenko</a> </blockquote><p>  In diesem Fall interessiert uns das Problem von <strong>accept ()</strong> und <strong>read (),</strong> die in Verbindung mit <strong>epoll</strong> über Streams verteilt sind. </p><br><h1 id="accept">  akzeptieren </h1><br><p>  Tatsächlich gab es bei einem blockierenden Aufruf von <strong>accept ()</strong> lange Zeit keine Probleme.  Der Kernel sorgt dafür, dass nur ein Prozess für dieses Ereignis entsperrt wurde und alle eingehenden Verbindungen serialisiert werden. </p><br><p>  Aber mit <strong>epoll</strong> dieser Trick funktioniert nicht.  Wenn <strong>listen ()</strong> auf einem nicht blockierenden Socket ausgeführt wurde, <strong>warten</strong> alle <strong>epoll_wait ()</strong> beim Herstellen der Verbindung <strong>auf</strong> das Ereignis dieses Deskriptors. </p><br><p>  Natürlich kann <strong>accept ()</strong> nur einen Thread <strong>ausführen</strong> , der Rest erhält <strong>EAGAIN</strong> , aber dies ist eine Verschwendung von Ressourcen. </p><br><p>  Darüber hinaus hilft uns <strong>EPOLLET</strong> auch nicht, da wir nicht genau wissen, wie viele Verbindungen sich in der Verbindungswarteschlange ( <strong>Backlog</strong> ) befinden.  Wie wir uns erinnern, sollte bei Verwendung von <strong>EPOLLET die</strong> Socket-Verarbeitung fortgesetzt werden, bis sie mit dem <strong>EAGAIN-</strong> Fehlercode zurückgegeben wird. <strong>Daher</strong> besteht die Möglichkeit, dass alle <strong>accept ()</strong> von einem Thread verarbeitet werden und der Rest nicht funktioniert. </p><br><p>  Und dies führt uns wieder zu einer Situation, in der der benachbarte Strom vergeblich geweckt wurde. </p><br><p>  Wir können auch eine andere Art von Hunger bekommen - wir werden nur einen Thread laden und der Rest wird keine Verbindungen zur Verarbeitung erhalten. </p><br><h1 id="epolloneshot">  EPOLLONESHOT </h1><br><p>  Vor Version 4.5 bestand die einzig richtige Möglichkeit, den verteilten <strong>Epoll</strong> beim nächsten Aufruf von <strong>accept ()</strong> in einen nicht blockierenden <strong>listen () -</strong> Deskriptor zu verarbeiten, darin, das <strong>EPOLLONESHOT-</strong> Flag zu setzen, was wiederum dazu führte, dass <strong>accept () jeweils</strong> nur in einem Thread verarbeitet wurde. </p><br><p>  Kurz gesagt: Wenn <strong>EPOLLONESHOT</strong> verwendet wird <strong>, wird das</strong> einem bestimmten Deskriptor zugeordnete Ereignis nur einmal <strong>ausgelöst</strong> . <strong>Danach müssen</strong> die Flags mit <strong>epoll_ctl ()</strong> erneut <strong>gespannt werden</strong> . </p><br><h1 id="epollexclusive">  EPOLLEXKLUSIV </h1><br><p>  Hier <strong>hilft</strong> uns <strong>EPOLLEXCLUSIVE</strong> und Level-Triggered. </p><br><p>  <strong>EPOLLEXCLUSIVE</strong> entsperrt jeweils ein ausstehendes <strong>epoll_wait ()</strong> für ein Ereignis. </p><br><p>  Das Schema ist recht einfach (eigentlich nicht): </p><br><ul><li>  Wir haben N Threads, die auf ein Verbindungsereignis warten </li><li>  Der erste Kunde verbindet sich mit uns </li><li>  Thread 0 wird gestreut und die Verarbeitung gestartet, andere Threads bleiben blockiert </li><li>  Ein zweiter Client stellt eine Verbindung zu uns her. Wenn Thread 0 noch mit der Verarbeitung beschäftigt ist, wird Thread 1 entsperrt </li><li>  Wir fahren weiter fort, bis der Thread-Pool erschöpft ist (niemand erwartet ein Ereignis auf <strong>epoll_wait ()</strong> ) </li><li>  Ein anderer Kunde verbindet sich mit uns </li><li>  Und dessen Verarbeitung empfängt einen ersten Strom, der Ursache <strong>epoll_wait ()</strong> </li><li>  Der zweite Thread empfängt den zweiten Client, der <strong>epoll_wait () aufruft.</strong> </li></ul><br><p>  Somit ist die gesamte Wartung gleichmäßig auf die Flüsse verteilt. </p><br><pre> <code class="bash hljs">$ ./epollexclusive --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span> -i, --ip=ADDR specify ip address -p, --port=PORT specify port -n, --threads=NUM specify number of threads to use <span class="hljs-comment"><span class="hljs-comment">#    -  n*8 -t, --thunder not adding EPOLLEXCLUSIVE #     thunder herd -h, --help prints this message $ sudo taskset -c 0-7 ./epollexclusive -i 10.56.75.201 -p 40000 -n 8 2&gt;&amp;1</span></span></code> </pre> <br><p>  Beispielcode: <a href="">epollexclusive.c</a> (funktioniert nur mit der Kernel-Version ab 4.5) </p><br><p>  Wir bekommen ein Pre-Fork-Modell auf Epoll.  Dieses Schema eignet sich gut für <strong>kurzzeitige</strong> TCP-Verbindungen. </p><br><h1 id="read">  lesen </h1><br><p>  Aber mit <strong>read ()</strong> im Fall von Byte-Streaming hilft uns <strong>EPOLLEXCLUSIVE</strong> wie <strong>EPOLLET</strong> nicht weiter. </p><br><p>  Aus offensichtlichen Gründen können wir ohne <strong>EPOLLEXCLUSIVE</strong> überhaupt kein Level- <strong>Trigger</strong> verwenden.  Mit <strong>EPOLLEXCLUSIVE</strong> ist nicht alles besser, da wir ein Paket über Streams verteilen können, außer mit einer unbekannten Reihenfolge der eingetroffenen Bytes. </p><br><p>  Bei <strong>EPOLLET ist die</strong> Situation dieselbe. </p><br><p>  Und hier wird <strong>EPOLLONESHOT</strong> mit Reinitialisierung nach Abschluss der Arbeiten der <strong>Ausweg</strong> sein.  Sobald also ein Thread mit diesem Dateideskriptor und Puffer funktioniert: </p><br><ul><li>  Griff mit <strong>EPOLLONESHOT-</strong> Flags zu <strong>epoll</strong> <strong>hinzugefügt |</strong>  <strong>EPOLLET</strong> </li><li>  Warten auf <strong>epoll_wait ()</strong> </li><li>  Lesen Sie vom Socket zum Puffer, bis <strong>read ()</strong> <strong>EAGAIN zurückgibt</strong> </li><li>  mit <strong>EPOLLONESHOT-</strong> Flags neu <strong>initialisieren |</strong>  <strong>EPOLLET</strong> </li></ul><br><h1 id="struct--epoll_event">  struct epoll_event </h1><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> epoll_data { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> u32; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> u64; } <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">epoll_event</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> events; <span class="hljs-comment"><span class="hljs-comment">/* Epoll events */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span> data; <span class="hljs-comment"><span class="hljs-comment">/* User data variable */</span></span> };</code> </pre> <br><p>  Dieser Artikel ist vielleicht der einzige in meinem Artikel, der meiner persönlichen Meinung nach ist.  Die Möglichkeit, einen Zeiger oder eine Zahl zu verwenden, ist hilfreich.  Wenn Sie beispielsweise einen Zeiger verwenden, wenn Sie epoll verwenden, können Sie einen Trick wie den folgenden ausführen: </p><br><pre> <code class="hljs go">#define container_of(ptr, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, member) ({ \ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeof( ((<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;member ) *__mptr = (ptr); \ (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)( (char *)__mptr - offsetof(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>,member) );}) <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client { <span class="hljs-comment"><span class="hljs-comment">/** some usefull associated data...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event event; }; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* to_epoll_client(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event* event) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container_of(event, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client, event); } <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client ec; ... epoll_ctl(efd, EPOLL_CTL_ADD, fd, &amp;ec.e); ... epoll_wait (efd, events, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* ec_ = to_epoll_client(events[<span class="hljs-number"><span class="hljs-number">0</span></span>].data.ptr);</code> </pre> <br><p>  Ich denke, jeder weiß, woher diese Technik stammt. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Ich hoffe, dass wir das Thema <strong>Epoll</strong> eröffnen konnten.  Wer diesen Mechanismus bewusst nutzen möchte, muss nur die Artikel in der Referenzliste lesen [1, 2, 3, 5]. </p><br><p>  Basierend auf diesem Material (und noch besser durchdachtes Lesen der Materialien aus der Referenzliste) können Sie einen sperrfreien (ohne Blockierung) Pre-Fork-Server (frühe Prozessgenerierung) mit mehreren Threads erstellen oder vorhandene Strategien basierend auf den speziellen Eigenschaften von <strong>epoll ()</strong> überarbeiten. </p><br><p>  <strong>epoll ist</strong> einer der einzigartigen Mechanismen, die Benutzer, die ihre Linux-Programmierpfade ausgewählt haben, kennen müssen, da sie einen ernsthaften Vorteil gegenüber anderen Betriebssystemen bieten. Möglicherweise lehnen sie plattformübergreifendes Lernen für einen bestimmten Fall ab (lassen Sie es funktionieren) nur unter Linux, wird es aber gut machen). </p><br><h2 id="rassuzhdeniya-ob-specifichnosti-zadachi">  Argumentation über die "Spezifität" des Problems </h2><br><p>  Bevor jemand über die Spezifität dieser Flags und Verwendungsmuster spricht, möchte ich eine Frage stellen: </p><br><p>  "Aber ist es nichts, was wir versuchen, die Spezifität des Mechanismus zu diskutieren, der ursprünglich für bestimmte Aufgaben erstellt wurde [9, 11]? Oder warten wir sogar 1k-Verbindungen, ist eine tägliche Aufgabe für einen Programmierer?" </p><br><p>  Ich verstehe das Konzept der "Aufgabenspezifität" nicht, es erinnert mich an alle möglichen Schreie über die Nützlichkeit und Sinnlosigkeit der verschiedenen gelehrten Disziplinen.  Indem wir uns erlauben, auf diese Weise zu argumentieren, geben wir uns das Recht, für andere zu entscheiden, welche Informationen für sie nützlich und welche nutzlos sind, während wir wohlgemerkt nicht am gesamten Bildungsprozess teilnehmen. </p><br><p>  Für Skeptiker ein paar Links: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistungssteigerung mit SO_REUSEPORT in NGINX 1.9.1 - VBart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vom Einhorn lernen: die donnernde Herde akzeptieren () kein Problem - Chris Siebenmann</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serializing accept (), AKA Donnerherde, AKA das Zeeg-Problem - Roberto De Ioris</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie interagiert der EPOLLEXCLUSIVE-Modus von epoll mit dem Level-Triggering?</a> </p><br><h1 id="spisok-literatury">  Referenzliste </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Select ist grundlegend kaputt - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Epoll ist grundsätzlich kaputt 1/2 - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Epoll ist grundlegend gebrochen 2/2 - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das C10K-Problem - Dan Kegel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nochmals Umfrage gegen Epoll - Jacques Mattheij</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">epoll - Benachrichtigungsfunktion für E / A-Ereignisse - The Mann</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Methode zu Epolls Wahnsinn - Cindy Sridharan</a> </li></ol><br><h2 id="benchmarks">  Benchmarks </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.kernel.org/doc/ols/2004/ols2004v1-pages-215-226.pdf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://lse.sourceforge.net/epoll/index.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://mvitolin.wordpress.com/2015/12/05/endurox-testing-epollexclusive-flag/</a> </li></ol><br><h2 id="evolyuciya-epoll">  Die Entwicklung des Epolls </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/13918/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/520012/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/520198/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/542629/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/633422/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/637435/</a> </li></ol><br><h1 id="postskriptum">  Nachtrag </h1><br><p>  Vielen Dank an Sergey ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">dlinyj</a> ) und Peter Ovchenkov für wertvolle Diskussionen, Kommentare und Hilfe! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416669/">https://habr.com/ru/post/de416669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416657/index.html">Zwei Drittel der verwendeten Speicherkarten enthalten personenbezogene Daten von Vorbesitzern</a></li>
<li><a href="../de416659/index.html">Aufgrund dessen wird das Volumen der digitalen Zahlungen für die Gig Economy 1,2 Billionen Dollar erreichen</a></li>
<li><a href="../de416661/index.html">Welche Trends sollten Nutzer und Anbieter von Mobile Banking berücksichtigen?</a></li>
<li><a href="../de416665/index.html">Wiederverwendung privater Android-Bibliotheken mit Sonatype Nexus Repository OSS</a></li>
<li><a href="../de416667/index.html">Budget Staub- und Geräuschdämmung der alten Systemeinheit</a></li>
<li><a href="../de416673/index.html">Analytische Lösung für Manager</a></li>
<li><a href="../de416677/index.html">Cyberpunk- und Spiegelgläser: Reflexionen in Mode und Kultur</a></li>
<li><a href="../de416679/index.html">Peripheral Computing: eine freundschaftliche Übereinstimmung des "Nebels" mit den "Wolken"</a></li>
<li><a href="../de416681/index.html">Wie viel von PostgreSQL und ClickHouse in Python viel, schnell und sofort in numpy</a></li>
<li><a href="../de416683/index.html">Was weiter? Oder wie man Funktionen für die Entwicklung auswählt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>