<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÉ üôéüèæ üë®üèø‚Äçü§ù‚Äçüë®üèæ Die ganze Wahrheit √ºber Linux Epoll üëß üåë üà∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na ja, oder fast alle ... 





 Ich glaube, dass das Problem im modernen Internet eine √úberf√ºlle an Informationen unterschiedlicher Qualit√§t ist. Das...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber Linux Epoll</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416669/"><p>  Na ja, oder fast alle ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/91f/776/71c/91f77671c2186bc1f2393c47e0696ee9.png"></p><br><p>  Ich glaube, dass das Problem im modernen Internet eine √úberf√ºlle an Informationen unterschiedlicher Qualit√§t ist.  Das Finden von Material zu einem interessanten Thema ist kein Problem. Das Problem besteht darin, gutes Material von schlechtem Material zu unterscheiden, wenn Sie wenig Erfahrung auf diesem Gebiet haben.  Ich beobachte ein Bild, wenn es viele √úbersichtsinformationen "oben" gibt (fast auf der Ebene einer einfachen Auflistung), sehr wenige ausf√ºhrliche Artikel und keine √úbergangsartikel von einfach zu komplex.  Dennoch ist es die Kenntnis der Merkmale eines bestimmten Mechanismus, die es uns erm√∂glicht, w√§hrend der Entwicklung eine fundierte Entscheidung zu treffen. </p><br><p>  In dem Artikel werde ich versuchen aufzuzeigen, was der grundlegende Unterschied zwischen <strong>Epoll</strong> und anderen Mechanismen ist, was es einzigartig macht, und Artikel zitieren, die Sie nur lesen m√ºssen, um die M√∂glichkeiten und Probleme von <strong>Epoll</strong> besser zu verstehen. </p><br><blockquote> Jeder kann eine Axt f√ºhren, aber es braucht einen wahren Krieger, um eine Nahkampfmelodie zu singen. </blockquote><p>  Ich <strong>gehe</strong> davon aus, dass der Leser mit <strong>epoll</strong> vertraut ist, zumindest die Manpage lesen.  Es wurde genug √ºber <strong>epoll</strong> , <strong>poll</strong> , <strong>select geschrieben,</strong> damit jeder, der sich unter Linux entwickelt, mindestens einmal davon geh√∂rt hat. </p><a name="habracut"></a><br><h1 id="mnoga--fd">  Viel fd </h1><br><p>  Wenn Leute √ºber <strong>Epoll</strong> sprechen, h√∂re ich im Grunde die These, dass seine "Leistung besser ist, wenn es viele Dateideskriptoren gibt". </p><br><p>  Ich m√∂chte nur eine Frage stellen - wie viel ist wie viel?  Wie viele Verbindungen werden ben√∂tigt und vor allem unter welchen Bedingungen wird <strong>epoll</strong> anfangen, sp√ºrbare Leistungssteigerungen zu erzielen? </p><br><p>  F√ºr diejenigen, die <strong>Epoll</strong> studiert haben (es gibt viel Material, einschlie√ülich wissenschaftlicher Artikel), liegt die Antwort auf der Hand - es ist genau dann besser, wenn die Anzahl der Verbindungen, die auf ein Ereignis warten, die Anzahl der verarbeitungsfertigen Verbindungen erheblich √ºbersteigt.  Wenn der Gewinn so signifikant wird, dass es einfach keinen Urin gibt, der diese Tatsache ignoriert, werden 10k-Verbindungen ber√ºcksichtigt [4]. </p><br><p>  Die Annahme, dass die meisten Verbindungen anstehen, beruht auf einer soliden Logik und Last√ºberwachung von Servern, die aktiv verwendet werden. </p><br><p>  Wenn die Anzahl der Wirkstoffe die Gesamtzahl anstrebt, <del>  Es wird keinen Gewinn geben </del>  Es wird keinen signifikanten Gewinn geben, ein signifikanter Gewinn ist auf und nur zur√ºckzuf√ºhren, weil <strong>epoll</strong> nur Deskriptoren zur√ºckgibt, die Aufmerksamkeit erfordern, und <strong>poll</strong> alle Deskriptoren zur√ºckgibt, die zur Beobachtung hinzugef√ºgt wurden. </p><br><p>  Im letzteren Fall verbringen wir nat√ºrlich Zeit damit, alle Deskriptoren + den Aufwand f√ºr das Kopieren eines Arrays von Ereignissen aus dem Kernel zu durchlaufen. </p><br><p>  Tats√§chlich wird dieser Punkt bei der anf√§nglichen Leistungsmessung, die dem Patch beigef√ºgt war [9], nicht unterstrichen, und man kann nur anhand des im Artikel erw√§hnten Dienstprogramms deadcon raten (leider geht der Dienstprogrammcode pipetest.c verloren).  Andererseits ist es in anderen Quellen [6, 8] sehr schwierig, es nicht zu bemerken, da diese Tatsache praktisch herausragt. </p><br><p>  Die Frage stellt sich sofort, aber was ist nun, wenn nicht geplant ist, <strong>sozusagen</strong> eine solche Anzahl von <strong>Epoll-</strong> Dateideskriptoren zu bedienen, und dies nicht erforderlich ist? </p><br><p>  Trotz der Tatsache, dass <strong>epoll</strong> urspr√ºnglich speziell f√ºr solche Situationen erstellt wurde [5, 8, 9], ist dies bei weitem nicht der einzige Unterschied zwischen <strong>epoll</strong> . </p><br><h1 id="epollet">  EPOLLET </h1><br><p>  Zun√§chst werden wir uns den Unterschied zwischen flankengetriggerten und pegelgetriggerten Triggern ansehen. Eine gute Aussage zu diesem Thema finden Sie im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Edge Triggered Vs Level Triggered Interrupts - Venkatesh Yadav</a> : </p><br><blockquote>  Unterbrechung des Levels, es ist wie bei einem Kind.  Wenn das Baby weint, m√ºssen Sie alles aufgeben, was Sie getan haben, und zum Baby laufen, um es zu f√ºttern.  Dann legst du das Baby wieder in die Krippe.  Wenn er wieder weint, werden Sie ihn nirgendwo lassen, aber Sie werden versuchen, ihn zu beruhigen.  Und w√§hrend das Kind weint, werden Sie es keinen Moment verlassen und erst dann zur Arbeit zur√ºckkehren, wenn es sich beruhigt.  Aber nehmen wir an, wir gingen in den Garten (Unterbrechung ausgeschaltet), als das Kind anfing zu weinen, und als Sie nach Hause zur√ºckkehrten (Unterbrechung eingeschaltet), war das erste, was Sie tun, das Kind zu √ºberpr√ºfen.  Aber Sie werden nie erfahren, dass er geweint hat, als Sie im Garten waren. <br><br>  Eine Unterbrechung an der Front ist wie ein elektronisches Kinderm√§dchen f√ºr geh√∂rlose Eltern.  Sobald das Kind auf dem Ger√§t zu weinen beginnt, leuchtet ein rotes Licht auf und leuchtet auf, bis Sie die Taste dr√ºcken.  Selbst wenn das Kind anfing zu weinen, aber schnell stehen blieb und einschlief, werden Sie immer noch wissen, dass das Kind weinte.  Aber wenn er anfing zu weinen und Sie den Knopf gedr√ºckt haben (Best√§tigung der Unterbrechung), leuchtet das Licht nicht auf, selbst wenn er weiter weint.  Der Schallpegel im Raum sollte abfallen und dann wieder ansteigen, damit das Licht aufleuchtet. </blockquote><p>  Wenn der <strong>Epoll</strong> (sowie <strong>Poll</strong> / <strong>Select</strong> ) im Level-Trigger-Verhalten entsperrt ist, wenn sich der Deskriptor im angegebenen Status befindet und bis zum L√∂schen dieses Status als aktiv betrachtet wird, wird der Flanken-Trigger nur durch √Ñndern des aktuell angegebenen geordneten Status entsperrt. </p><br><p>  Auf diese Weise k√∂nnen Sie das Ereignis sp√§ter und nicht sofort nach dem Empfang behandeln (fast eine direkte Analogie zur oberen und unteren H√§lfte des Interrupt-Handlers). </p><br><p>  Spezifisches Beispiel mit epoll: </p><br><p>  Level ausgel√∂st </p><br><ul><li>  Griff zum <strong>Epoll</strong> mit Flag <strong>EPOLLIN hinzugef√ºgt</strong> </li><li>  <strong>epoll_wait ()</strong> blockiert, w√§hrend auf ein Ereignis gewartet wird </li><li>  Schreiben Sie 19 Bytes in den Dateideskriptor </li><li>  <strong>epoll_wait () wird</strong> mit dem <strong>EPOLLIN-</strong> Ereignis entsperrt </li><li>  Wir machen nichts mit den Daten, die kamen </li><li>  <strong>epoll_wait ()</strong> wird mit dem <strong>EPOLLIN-</strong> Ereignis erneut <strong>entsperrt</strong> </li></ul><br><p>  Dies wird so lange fortgesetzt, bis wir die Daten aus dem Deskriptor vollst√§ndig gez√§hlt oder zur√ºckgesetzt haben. </p><br><p>  Flanke ausgel√∂st </p><br><ul><li>  Handle mit <strong>EPOLLIN-</strong> Flags zu <strong>epoll</strong> <strong>hinzugef√ºgt |</strong>  <strong>EPOLLET</strong> </li><li>  <strong>epoll_wait ()</strong> blockiert, w√§hrend auf ein Ereignis gewartet wird </li><li>  Schreiben Sie 19 Bytes in den Dateideskriptor </li><li>  <strong>epoll_wait () wird</strong> mit dem <strong>EPOLLIN-</strong> Ereignis entsperrt </li><li>  Wir machen nichts mit den Daten, die kamen </li><li>  <strong>epoll_wait () ist</strong> blockiert und wartet auf ein neues Ereignis </li><li>  Schreiben Sie weitere 19 Bytes in den Dateideskriptor </li><li>  <strong>epoll_wait () wird</strong> mit dem neuen <strong>EPOLLIN-</strong> Ereignis entsperrt </li><li>  <strong>epoll_wait () ist</strong> blockiert und wartet auf ein neues Ereignis </li></ul><br><p>  einfaches Beispiel: <a href="">epollet_socket.c</a> </p><br><p>  Dieser Mechanismus soll die R√ºckgabe von <strong>epoll_wait ()</strong> aufgrund eines Ereignisses verhindern, das bereits verarbeitet wird. </p><br><p>  Wenn im Fall von level beim Aufrufen von <strong>epoll_wait () der</strong> Kernel pr√ºft, ob sich fd in diesem Zustand befindet, √ºberspringt edge diese Pr√ºfung und versetzt den aufrufenden Prozess sofort in den Ruhezustand. </p><br><p>  <strong>EPOLLET selbst</strong> macht <strong>Epoll</strong> O (1) zu einem Multiplexer f√ºr Ereignisse. </p><br><p>  Es ist notwendig, √ºber <strong>EAGAIN</strong> und <strong>EPOLLET</strong> zu erkl√§ren - die Empfehlung mit <strong>EAGAIN lautet</strong> , Byte-Stream nicht zu behandeln, die Gefahr im letzteren Fall entsteht nur, wenn Sie den Deskriptor nicht bis zum Ende gelesen haben und keine neuen Daten gekommen sind.  Dann h√§ngt der Schwanz im Deskriptor, aber Sie erhalten keine neue Benachrichtigung.  Mit <strong>accept () ist die</strong> Situation einfach anders. Dort m√ºssen Sie fortfahren, bis <strong>accept ()</strong> <strong>EAGAIN zur√ºckgibt</strong> . Nur in diesem Fall ist die korrekte Operation garantiert. </p><br><pre><code class="hljs lua">// TCP socket (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> stream) //  fd    EPOLLIN      int <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(fd, buffer, BUFFER_LEN); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span> &lt; BUFFER_LEN) { //   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         //  -       epoll_wait, //      }</code> </pre> <br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ accept /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  listenfd    EPOLLIN      event.events = EPOLLIN | EPOLLERR; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &amp;event); sleep(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       &gt;1  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { newfd = accept(listenfd, ...); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  epoll_wait    listenfd    } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { while((newfd = accept(...)) &gt; 0) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -  } if(newfd == -1 &amp;&amp; errno = EAGAIN) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       } }</span></span></code> </pre> <br><p>  Mit dieser Eigenschaft ist nur Hunger genug: </p><br><ul><li>  Pakete kommen zum Deskriptor </li><li>  Pakete in den Puffer lesen </li><li>  Ein weiteres Paket kommt </li><li>  Pakete in den Puffer lesen </li><li>  kommt eine kleine Portion </li><li>  ... </li></ul><br><p>  Daher <strong>werden</strong> wir <strong>EAGAIN nicht</strong> bald erhalten, aber wir werden es m√∂glicherweise √ºberhaupt nicht erhalten. </p><br><p>  Daher erhalten andere Dateideskriptoren keine Zeit f√ºr die Verarbeitung, und wir sind damit besch√§ftigt, st√§ndig ankommende kleine Datenmengen zu lesen. </p><br><h1 id="thundering-nerd-herd">  donnern <del>  Nerd </del>  Herde </h1><br><p>  Um zur letzten Flagge zu gelangen, m√ºssen Sie verstehen, warum sie tats√§chlich erstellt wurde und eines der Probleme, die Entwickler bei der Entwicklung von Technologie und Software hatten. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://en.wikipedia.org/wiki/">Donnerndes Herdenproblem</a> </p><br><blockquote>  Problem mit der Donnerherde <br><br>  Stellen Sie sich eine Vielzahl von Prozessen vor, die auf ein Ereignis warten.  Wenn ein Ereignis eintritt, werden sie geweckt und der Kampf um Ressourcen beginnt, obwohl nur ein Prozess erforderlich ist, der sich mit der weiteren Verarbeitung des Ereignisses befasst.  Der Rest der Prozesse wird wieder schlafen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IT-Terminologie - Vasily Alekseenko</a> </blockquote><p>  In diesem Fall interessiert uns das Problem von <strong>accept ()</strong> und <strong>read (),</strong> die in Verbindung mit <strong>epoll</strong> √ºber Streams verteilt sind. </p><br><h1 id="accept">  akzeptieren </h1><br><p>  Tats√§chlich gab es bei einem blockierenden Aufruf von <strong>accept ()</strong> lange Zeit keine Probleme.  Der Kernel sorgt daf√ºr, dass nur ein Prozess f√ºr dieses Ereignis entsperrt wurde und alle eingehenden Verbindungen serialisiert werden. </p><br><p>  Aber mit <strong>epoll</strong> dieser Trick funktioniert nicht.  Wenn <strong>listen ()</strong> auf einem nicht blockierenden Socket ausgef√ºhrt wurde, <strong>warten</strong> alle <strong>epoll_wait ()</strong> beim Herstellen der Verbindung <strong>auf</strong> das Ereignis dieses Deskriptors. </p><br><p>  Nat√ºrlich kann <strong>accept ()</strong> nur einen Thread <strong>ausf√ºhren</strong> , der Rest erh√§lt <strong>EAGAIN</strong> , aber dies ist eine Verschwendung von Ressourcen. </p><br><p>  Dar√ºber hinaus hilft uns <strong>EPOLLET</strong> auch nicht, da wir nicht genau wissen, wie viele Verbindungen sich in der Verbindungswarteschlange ( <strong>Backlog</strong> ) befinden.  Wie wir uns erinnern, sollte bei Verwendung von <strong>EPOLLET die</strong> Socket-Verarbeitung fortgesetzt werden, bis sie mit dem <strong>EAGAIN-</strong> Fehlercode zur√ºckgegeben wird. <strong>Daher</strong> besteht die M√∂glichkeit, dass alle <strong>accept ()</strong> von einem Thread verarbeitet werden und der Rest nicht funktioniert. </p><br><p>  Und dies f√ºhrt uns wieder zu einer Situation, in der der benachbarte Strom vergeblich geweckt wurde. </p><br><p>  Wir k√∂nnen auch eine andere Art von Hunger bekommen - wir werden nur einen Thread laden und der Rest wird keine Verbindungen zur Verarbeitung erhalten. </p><br><h1 id="epolloneshot">  EPOLLONESHOT </h1><br><p>  Vor Version 4.5 bestand die einzig richtige M√∂glichkeit, den verteilten <strong>Epoll</strong> beim n√§chsten Aufruf von <strong>accept ()</strong> in einen nicht blockierenden <strong>listen () -</strong> Deskriptor zu verarbeiten, darin, das <strong>EPOLLONESHOT-</strong> Flag zu setzen, was wiederum dazu f√ºhrte, dass <strong>accept () jeweils</strong> nur in einem Thread verarbeitet wurde. </p><br><p>  Kurz gesagt: Wenn <strong>EPOLLONESHOT</strong> verwendet wird <strong>, wird das</strong> einem bestimmten Deskriptor zugeordnete Ereignis nur einmal <strong>ausgel√∂st</strong> . <strong>Danach m√ºssen</strong> die Flags mit <strong>epoll_ctl ()</strong> erneut <strong>gespannt werden</strong> . </p><br><h1 id="epollexclusive">  EPOLLEXKLUSIV </h1><br><p>  Hier <strong>hilft</strong> uns <strong>EPOLLEXCLUSIVE</strong> und Level-Triggered. </p><br><p>  <strong>EPOLLEXCLUSIVE</strong> entsperrt jeweils ein ausstehendes <strong>epoll_wait ()</strong> f√ºr ein Ereignis. </p><br><p>  Das Schema ist recht einfach (eigentlich nicht): </p><br><ul><li>  Wir haben N Threads, die auf ein Verbindungsereignis warten </li><li>  Der erste Kunde verbindet sich mit uns </li><li>  Thread 0 wird gestreut und die Verarbeitung gestartet, andere Threads bleiben blockiert </li><li>  Ein zweiter Client stellt eine Verbindung zu uns her. Wenn Thread 0 noch mit der Verarbeitung besch√§ftigt ist, wird Thread 1 entsperrt </li><li>  Wir fahren weiter fort, bis der Thread-Pool ersch√∂pft ist (niemand erwartet ein Ereignis auf <strong>epoll_wait ()</strong> ) </li><li>  Ein anderer Kunde verbindet sich mit uns </li><li>  Und dessen Verarbeitung empf√§ngt einen ersten Strom, der Ursache <strong>epoll_wait ()</strong> </li><li>  Der zweite Thread empf√§ngt den zweiten Client, der <strong>epoll_wait () aufruft.</strong> </li></ul><br><p>  Somit ist die gesamte Wartung gleichm√§√üig auf die Fl√ºsse verteilt. </p><br><pre> <code class="bash hljs">$ ./epollexclusive --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span> -i, --ip=ADDR specify ip address -p, --port=PORT specify port -n, --threads=NUM specify number of threads to use <span class="hljs-comment"><span class="hljs-comment">#    -  n*8 -t, --thunder not adding EPOLLEXCLUSIVE #     thunder herd -h, --help prints this message $ sudo taskset -c 0-7 ./epollexclusive -i 10.56.75.201 -p 40000 -n 8 2&gt;&amp;1</span></span></code> </pre> <br><p>  Beispielcode: <a href="">epollexclusive.c</a> (funktioniert nur mit der Kernel-Version ab 4.5) </p><br><p>  Wir bekommen ein Pre-Fork-Modell auf Epoll.  Dieses Schema eignet sich gut f√ºr <strong>kurzzeitige</strong> TCP-Verbindungen. </p><br><h1 id="read">  lesen </h1><br><p>  Aber mit <strong>read ()</strong> im Fall von Byte-Streaming hilft uns <strong>EPOLLEXCLUSIVE</strong> wie <strong>EPOLLET</strong> nicht weiter. </p><br><p>  Aus offensichtlichen Gr√ºnden k√∂nnen wir ohne <strong>EPOLLEXCLUSIVE</strong> √ºberhaupt kein Level- <strong>Trigger</strong> verwenden.  Mit <strong>EPOLLEXCLUSIVE</strong> ist nicht alles besser, da wir ein Paket √ºber Streams verteilen k√∂nnen, au√üer mit einer unbekannten Reihenfolge der eingetroffenen Bytes. </p><br><p>  Bei <strong>EPOLLET ist die</strong> Situation dieselbe. </p><br><p>  Und hier wird <strong>EPOLLONESHOT</strong> mit Reinitialisierung nach Abschluss der Arbeiten der <strong>Ausweg</strong> sein.  Sobald also ein Thread mit diesem Dateideskriptor und Puffer funktioniert: </p><br><ul><li>  Griff mit <strong>EPOLLONESHOT-</strong> Flags zu <strong>epoll</strong> <strong>hinzugef√ºgt |</strong>  <strong>EPOLLET</strong> </li><li>  Warten auf <strong>epoll_wait ()</strong> </li><li>  Lesen Sie vom Socket zum Puffer, bis <strong>read ()</strong> <strong>EAGAIN zur√ºckgibt</strong> </li><li>  mit <strong>EPOLLONESHOT-</strong> Flags neu <strong>initialisieren |</strong>  <strong>EPOLLET</strong> </li></ul><br><h1 id="struct--epoll_event">  struct epoll_event </h1><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> epoll_data { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> u32; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> u64; } <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">epoll_event</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> events; <span class="hljs-comment"><span class="hljs-comment">/* Epoll events */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span> data; <span class="hljs-comment"><span class="hljs-comment">/* User data variable */</span></span> };</code> </pre> <br><p>  Dieser Artikel ist vielleicht der einzige in meinem Artikel, der meiner pers√∂nlichen Meinung nach ist.  Die M√∂glichkeit, einen Zeiger oder eine Zahl zu verwenden, ist hilfreich.  Wenn Sie beispielsweise einen Zeiger verwenden, wenn Sie epoll verwenden, k√∂nnen Sie einen Trick wie den folgenden ausf√ºhren: </p><br><pre> <code class="hljs go">#define container_of(ptr, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, member) ({ \ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeof( ((<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;member ) *__mptr = (ptr); \ (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)( (char *)__mptr - offsetof(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>,member) );}) <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client { <span class="hljs-comment"><span class="hljs-comment">/** some usefull associated data...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event event; }; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* to_epoll_client(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event* event) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container_of(event, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client, event); } <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client ec; ... epoll_ctl(efd, EPOLL_CTL_ADD, fd, &amp;ec.e); ... epoll_wait (efd, events, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* ec_ = to_epoll_client(events[<span class="hljs-number"><span class="hljs-number">0</span></span>].data.ptr);</code> </pre> <br><p>  Ich denke, jeder wei√ü, woher diese Technik stammt. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Ich hoffe, dass wir das Thema <strong>Epoll</strong> er√∂ffnen konnten.  Wer diesen Mechanismus bewusst nutzen m√∂chte, muss nur die Artikel in der Referenzliste lesen [1, 2, 3, 5]. </p><br><p>  Basierend auf diesem Material (und noch besser durchdachtes Lesen der Materialien aus der Referenzliste) k√∂nnen Sie einen sperrfreien (ohne Blockierung) Pre-Fork-Server (fr√ºhe Prozessgenerierung) mit mehreren Threads erstellen oder vorhandene Strategien basierend auf den speziellen Eigenschaften von <strong>epoll ()</strong> √ºberarbeiten. </p><br><p>  <strong>epoll ist</strong> einer der einzigartigen Mechanismen, die Benutzer, die ihre Linux-Programmierpfade ausgew√§hlt haben, kennen m√ºssen, da sie einen ernsthaften Vorteil gegen√ºber anderen Betriebssystemen bieten. M√∂glicherweise lehnen sie plattform√ºbergreifendes Lernen f√ºr einen bestimmten Fall ab (lassen Sie es funktionieren) nur unter Linux, wird es aber gut machen). </p><br><h2 id="rassuzhdeniya-ob-specifichnosti-zadachi">  Argumentation √ºber die "Spezifit√§t" des Problems </h2><br><p>  Bevor jemand √ºber die Spezifit√§t dieser Flags und Verwendungsmuster spricht, m√∂chte ich eine Frage stellen: </p><br><p>  "Aber ist es nichts, was wir versuchen, die Spezifit√§t des Mechanismus zu diskutieren, der urspr√ºnglich f√ºr bestimmte Aufgaben erstellt wurde [9, 11]? Oder warten wir sogar 1k-Verbindungen, ist eine t√§gliche Aufgabe f√ºr einen Programmierer?" </p><br><p>  Ich verstehe das Konzept der "Aufgabenspezifit√§t" nicht, es erinnert mich an alle m√∂glichen Schreie √ºber die N√ºtzlichkeit und Sinnlosigkeit der verschiedenen gelehrten Disziplinen.  Indem wir uns erlauben, auf diese Weise zu argumentieren, geben wir uns das Recht, f√ºr andere zu entscheiden, welche Informationen f√ºr sie n√ºtzlich und welche nutzlos sind, w√§hrend wir wohlgemerkt nicht am gesamten Bildungsprozess teilnehmen. </p><br><p>  F√ºr Skeptiker ein paar Links: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistungssteigerung mit SO_REUSEPORT in NGINX 1.9.1 - VBart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vom Einhorn lernen: die donnernde Herde akzeptieren () kein Problem - Chris Siebenmann</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serializing accept (), AKA Donnerherde, AKA das Zeeg-Problem - Roberto De Ioris</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie interagiert der EPOLLEXCLUSIVE-Modus von epoll mit dem Level-Triggering?</a> </p><br><h1 id="spisok-literatury">  Referenzliste </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Select ist grundlegend kaputt - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Epoll ist grunds√§tzlich kaputt 1/2 - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Epoll ist grundlegend gebrochen 2/2 - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das C10K-Problem - Dan Kegel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nochmals Umfrage gegen Epoll - Jacques Mattheij</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">epoll - Benachrichtigungsfunktion f√ºr E / A-Ereignisse - The Mann</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Methode zu Epolls Wahnsinn - Cindy Sridharan</a> </li></ol><br><h2 id="benchmarks">  Benchmarks </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.kernel.org/doc/ols/2004/ols2004v1-pages-215-226.pdf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://lse.sourceforge.net/epoll/index.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://mvitolin.wordpress.com/2015/12/05/endurox-testing-epollexclusive-flag/</a> </li></ol><br><h2 id="evolyuciya-epoll">  Die Entwicklung des Epolls </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/13918/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/520012/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/520198/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/542629/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/633422/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://lwn.net/Articles/637435/</a> </li></ol><br><h1 id="postskriptum">  Nachtrag </h1><br><p>  Vielen Dank an Sergey ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">dlinyj</a> ) und Peter Ovchenkov f√ºr wertvolle Diskussionen, Kommentare und Hilfe! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416669/">https://habr.com/ru/post/de416669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416657/index.html">Zwei Drittel der verwendeten Speicherkarten enthalten personenbezogene Daten von Vorbesitzern</a></li>
<li><a href="../de416659/index.html">Aufgrund dessen wird das Volumen der digitalen Zahlungen f√ºr die Gig Economy 1,2 Billionen Dollar erreichen</a></li>
<li><a href="../de416661/index.html">Welche Trends sollten Nutzer und Anbieter von Mobile Banking ber√ºcksichtigen?</a></li>
<li><a href="../de416665/index.html">Wiederverwendung privater Android-Bibliotheken mit Sonatype Nexus Repository OSS</a></li>
<li><a href="../de416667/index.html">Budget Staub- und Ger√§uschd√§mmung der alten Systemeinheit</a></li>
<li><a href="../de416673/index.html">Analytische L√∂sung f√ºr Manager</a></li>
<li><a href="../de416677/index.html">Cyberpunk- und Spiegelgl√§ser: Reflexionen in Mode und Kultur</a></li>
<li><a href="../de416679/index.html">Peripheral Computing: eine freundschaftliche √úbereinstimmung des "Nebels" mit den "Wolken"</a></li>
<li><a href="../de416681/index.html">Wie viel von PostgreSQL und ClickHouse in Python viel, schnell und sofort in numpy</a></li>
<li><a href="../de416683/index.html">Was weiter? Oder wie man Funktionen f√ºr die Entwicklung ausw√§hlt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>