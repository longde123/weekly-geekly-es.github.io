<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌘 🤹🏾 👇🏼 Introduction à Screen Capture API - Scannez les codes QR dans un navigateur 🛒 👩🏻‍💻 🍢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Présentation 


 Dans cet article, nous avons supposé que nous parlerons de l'API de capture d'écran. Cette API est née en 2014, et il est difficile d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction à Screen Capture API - Scannez les codes QR dans un navigateur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460825/"><h2 id="vvedenie">  Présentation </h2><br><p>  Dans cet article, nous avons supposé que nous parlerons de l'API de capture d'écran.  Cette API est née en 2014, et il est difficile de l'appeler nouvelle, mais la prise en charge du navigateur est encore assez faible.  Néanmoins, il peut être utilisé pour des projets personnels ou lorsque ce soutien n'est pas si important. </p><br><p>  Quelques liens pour vous aider à démarrer: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spécifications de capture d'écran</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide d'utilisation de MDN</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Démo</a> </li></ul><br><p>  Au cas où le lien avec la démo tomberait (ou si vous êtes trop paresseux pour y aller) - voici à quoi ressemble la démo terminée: </p><br><p><img src="https://habrastorage.org/webt/7i/3e/ue/7i3eueyergc9kkrarhti7oat5au.gif"></p><br><p>  Commençons. </p><a name="habracut"></a><br>
<h2 id="motivaciya">  La motivation </h2><br><p>  Récemment, j'ai eu l'idée d'une application Web qui utilise des codes QR dans son travail.  Et bien qu'ils soient généralement pratiques pour envoyer, par exemple, de longs liens dans le monde réel, où vous pouvez pointer le téléphone vers eux, sur le bureau, c'est un peu plus compliqué.  Si le code QR est sur l'écran du même appareil sur lequel vous devez le lire, vous devez jouer avec les services pour la reconnaissance ou le reconnaître depuis le téléphone et retransférer les données sur le PC.  Inopportunément. </p><br><p>  Certains produits, tels que <strong>1Password</strong> , incluent une solution intéressante pour cette situation.  Si vous devez configurer un compte à partir d'un code QR, ils ouvrent une fenêtre translucide que vous pouvez faire glisser sur l'image avec le code, et il est automatiquement reconnu.  Voici à quoi ça ressemble: </p><br><p><img src="https://habrastorage.org/webt/we/m9/ty/wem9tytbuf_zm5kt4d8tlnyowga.png"></p><br><p>  Ce serait idéal si nous pouvions implémenter quelque chose de similaire pour notre application.  Mais cela ne fonctionnera probablement pas dans le navigateur ... </p><br><h2 id="vstrechayte----getdisplaymedia">  Rencontrez - getDisplayMedia </h2><br><p> Enfin presque.  Ici, l'API de capture d'écran avec sa seule méthode <code>getDisplayMedia</code> nous <code>getDisplayMedia</code> .  <code>getDisplayMedia</code> est comme <code>getUserMedia</code> , uniquement pour l'écran de l'appareil, au lieu de sa caméra.  Malheureusement, la prise en charge du navigateur, comme mentionné ci-dessus, est loin d'être aussi répandue que l'accès à la caméra.  Selon MDN, vous pouvez l'utiliser dans Firefox, Chrome, Edge (bien qu'il soit au mauvais endroit - immédiatement dans le <code>navigator</code> , et non dans <code>navigator.mediaDevices</code> ) + Edge Mobile et ... Opera pour Android. </p><br><p>  Une sélection assez curieuse de navigateurs mobiles à côté des Big Two attendus. </p><br><p>  L'API elle-même est extrêmement simple.  Il fonctionne de la même manière que <code>getUserMedia</code> , mais vous permet de capturer un flux vidéo à partir de l'une des <strong>surfaces d'affichage</strong> définies: </p><br><ul><li>  depuis le <strong>moniteur</strong> (écran entier), </li><li>  à partir d'une <strong>fenêtre</strong> ou de toutes les fenêtres d'une certaine application, </li><li>  depuis un <strong>navigateur</strong> , ou plutôt depuis un document spécifique.  Dans Chrome, ce document est un onglet séparé, mais dans FF il n'y a pas une telle option. </li></ul><br><p>  API du navigateur, qui vous permet de regarder au-delà du navigateur ... Cela semble familier et augure généralement de quelques problèmes, mais dans ce cas, cela peut être très pratique.  Vous pouvez capturer une image à partir d'autres fenêtres et, par exemple, reconnaître et traduire du texte en temps réel, comme Google Translate Camera.  Eh bien, et il y a probablement beaucoup d'autres utilisations intéressantes. </p><br><h2 id="sobiraem">  Nous collectons </h2><br><p>  Nous avons donc compris les capacités que l'API nous offre.  Et ensuite? </p><br><p>  Et puis nous devons dépasser ce flux vidéo en images sur lesquelles nous pouvons travailler.  Pour ce faire, nous utilisons les éléments <code>&lt;video&gt;</code> , <code>&lt;canvas&gt;</code> et quelques autres JS. </p><br><p>  Un gros plan du processus ressemble à ceci: </p><br><ul><li>  Flux direct vers <code>&lt;video&gt;</code> ; </li><li>  Avec une certaine fréquence, dessinez le contenu de la <code>&lt;video&gt;</code> dans <code>&lt;canvas&gt;</code> ; </li><li>  Collectez un objet ImageData à partir de <code>&lt;canvas&gt;</code> à l'aide de la méthode de contexte <code>getImageData</code> 2D. </li></ul><br><p>  Toute cette procédure peut sembler un peu étrange en raison d'un si long pipeline, mais cette méthode est assez populaire et a été utilisée pour capturer des données de webcams dans <code>getUserMedia</code> . </p><br><p>  En omettant tout ce qui n'est pas pertinent, afin de démarrer le flux et d'en retirer le cadre, nous avons besoin du code suivant: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> video = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'video'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> context = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> displayMediaOptions = { <span class="hljs-attr"><span class="hljs-attr">video</span></span>: { <span class="hljs-attr"><span class="hljs-attr">cursor</span></span>: <span class="hljs-string"><span class="hljs-string">"never"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">audio</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } video.srcObject = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> navigator.mediaDevices.getDisplayMedia(displayMediaOptions); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> videoTrack = video.srcObject.getVideoTracks()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { height, width } = videoTrack.getSettings(); context.drawImage(video, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.getImageData(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height); } <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> run();</code> </pre> <br><p>  Comme mentionné ci-dessus: nous créons d'abord les éléments <code>&lt;video&gt;</code> et <code>&lt;canvas&gt;</code> et demandons au canevas un contexte 2D ( <code>CanvasRenderingContext2D</code> ). </p><br><p>  Ensuite, nous définissons les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">restrictions / conditions de</a> flux.  Contrairement aux flux de la caméra, il y en a peu.  Nous disons que nous ne voulons pas voir le curseur et que nous n'avons pas besoin d'audio.  Bien qu'au moment d'écrire ces lignes, la capture audio n'est toujours prise en charge par personne. </p><br><p>  Après cela, nous accrochons le flux reçu de type <code>MediaStream</code> à l'élément <code>&lt;video&gt;</code> .  Notez que <code>getDisplayMedia</code> renvoie une promesse. </p><br><p>  Enfin, à partir des données reçues sur le flux, nous nous souvenons de la résolution de la vidéo afin de la dessiner correctement sur le canevas, dessiner le cadre et extraire l'objet ImageData du <code>ImageData</code> . </p><br><p>  Pour une utilisation complète, vous souhaiterez probablement traiter les images en boucle plutôt qu'une fois.  Par exemple, pendant que vous attendez lorsque l'image souhaitée apparaît dans le cadre.  Et ici, il faut dire quelques mots. </p><br><p>  Quand il s'agit de «gérer quelque chose dans le DOM dans une boucle constante», la première chose qui vient à l'esprit est très probablement <code>requestAnimationFrame</code> .  Cependant, dans notre cas, son utilisation ne fonctionnera pas.  Le fait est que lorsque l'onglet cesse d'être actif - les navigateurs suspendent le traitement de la boucle rAF.  Dans notre cas, c'est à ce moment que nous voudrons traiter les images. </p><br><p>  À cet égard, au lieu de rAF, nous utiliserons le bon vieux <code>setInterval</code> .  Mais les choses ne vont pas si bien avec lui.  Dans un onglet inactif, l'intervalle entre les opérations de rappel est d' <em>au moins 1 seconde</em> .  Néanmoins, cela nous suffit. </p><br><p>  Enfin, lorsque nous arrivons aux cadres, nous pouvons les traiter à notre guise.  Pour les besoins de cette démo, nous utiliserons la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jsQR</a> .  C'est extrêmement simple: l'entrée accepte <code>ImageData</code> , la largeur et la hauteur de l'image.  Si l'image reçue a un code QR, vous obtiendrez un objet JS avec des données reconnues. <br>  Complétons notre exemple précédent avec juste quelques lignes de code supplémentaires: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageData = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> run(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> code = jsQR(imageData.data, streamWidth, streamHeight);</code> </pre> <br><p>  C'est fait! </p><br><h2 id="npm">  NPM </h2><br><p>  Je pensais que le code principal derrière cet exemple pourrait être empaqueté dans une bibliothèque npm et gagner du temps lors de l'utilisation initiale pour une utilisation ultérieure.  La bibliothèque est très simple, à ce stade, elle accepte simplement le rappel auquel <code>ImageData</code> sera envoyé, et un paramètre supplémentaire est la fréquence d'envoi des données.  Tout le traitement dont vous avez besoin pour apporter le vôtre.  Je vais réfléchir à l'opportunité d'étendre ses fonctionnalités. </p><br><p>  La bibliothèque s'appelle <code>stream-display</code> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NPM</a> |  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Github</a> . </p><br><p>  Son utilisation est réduite à trois lignes de code et à un rappel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callback = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">imageData</span></span></span><span class="hljs-function"> =&gt;</span></span> {...} <span class="hljs-comment"><span class="hljs-comment">// do whatever with those images const capture = new StreamDisplay(callback); // specify where the ImageData will go await capture.startCapture(); // when ready capture.stopCapture(); // when done</span></span></code> </pre> <br><p>  La démo peut être vue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Il existe également une version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CodePen</a> pour des expériences rapides.  Les deux exemples utilisent le package NPM ci-dessus. </p><br><h2 id="nemnogo-o-testirovanii">  Un peu sur les tests </h2><br><p>  En emballant ce code dans la bibliothèque, j'ai dû réfléchir à la façon de le tester.  Je ne voulais absolument pas faire glisser 50 Mo de Chrome sans tête pour y exécuter quelques petits tests.  Et même si l'idée d'écrire des talons pour tous les composants semblait trop douloureuse, je l'ai finalement fait. <br>  En tant que testeur, la <code>tape</code> été sélectionnée.  Voici ce que j'ai finalement dû simuler: </p><br><ul><li>  <code>document</code> les éléments objet et DOM.  Pour cela, j'ai pris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jsdom</a> ; </li><li>  certaines méthodes jsdom qui manquent d'implémentation: <code>HTMLMediaElement#play</code> , <code>HTMLCanvasElement#getContext</code> et <code>navigator.mediaDevices#getDisplayMedia</code> ; </li><li>  le temps.  Pour ce faire, j'ai utilisé les <code>useFakeTimers</code> bibliothèque <code>useFakeTimers</code> , qui sous le capot appelle <code>lolex</code> .  Il définit ses remplacements sur <code>setInterval</code> , <code>requestAnimationFrame</code> et de nombreuses autres fonctions qui fonctionnent avec le temps, et vous permet également de contrôler le flux de ce faux temps.  Mais attention: jsdom utilise le passage du temps à un endroit de son processus d'initialisation, et si vous allumez sinon d'abord, tout se fige. </li></ul><br><p>  J'ai également utilisé sinon pour tous les stubs de fonction qui devaient être surveillés.  Le reste a été implémenté par des fonctions JS vides. </p><br><p>  Bien entendu, vous êtes libre de choisir les outils que vous connaissez déjà.  Mais j'espère que cette liste vous permettra de la préparer à l'avance, puisque maintenant vous savez à quoi vous devez faire face. </p><br><p>  Le résultat final peut être vu dans le référentiel de la bibliothèque.  Ça n'a pas l'air trop joli, mais ça marche. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  La solution ne s'est pas avérée aussi élégante que la fenêtre transparente mentionnée au début de l'article, mais peut-être que le Web y arrivera un jour.  On ne peut qu'espérer que lorsque les navigateurs apprendront à voir à travers leurs fenêtres - ces capacités seront strictement contrôlées par nous.  En attendant, rappelez-vous que lorsque vous fouillez l'écran dans Chrome - il peut être analysé, enregistré, etc.  Alors ne fouillez pas plus que nécessaire! </p><br><p>  J'espère que quelqu'un après cet article a appris une nouvelle astuce pour lui-même.  Si vous avez des idées sur quoi d'autre cela peut être utilisé, écrivez dans les commentaires.  Et à bientôt. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460825/">https://habr.com/ru/post/fr460825/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460813/index.html">Comment utiliser les diagrammes de Voronoi pour contrôler l'IA</a></li>
<li><a href="../fr460815/index.html">Inventer la bibliothèque vusb</a></li>
<li><a href="../fr460819/index.html">WorldSkills: avis du participant de l'Olympiade</a></li>
<li><a href="../fr460821/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 307 (du 15 au 21 juillet)</a></li>
<li><a href="../fr460823/index.html">Événements numériques à Moscou du 22 juillet au 28 juillet</a></li>
<li><a href="../fr460827/index.html">Problème PGP</a></li>
<li><a href="../fr460831/index.html">Les dangers des designers</a></li>
<li><a href="../fr460833/index.html">Physique et économie. Différence gnoséologique et sa manifestation en informatique</a></li>
<li><a href="../fr460837/index.html">Manuel du podcast pour débutants</a></li>
<li><a href="../fr460839/index.html">Lancer Predator - Référentiels de données précompilés</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>