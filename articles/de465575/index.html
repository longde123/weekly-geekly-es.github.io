<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏽 🧟 🌰 Vergleichsoperationen in C ++ 20 ☹️ 🤳🏾 ♏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Treffen in Köln ist vorbei, der C ++ 20-Standard wurde auf ein mehr oder weniger fertiges Aussehen reduziert (zumindest bis zum Erscheinen speziel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vergleichsoperationen in C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/465575/">  Das Treffen in Köln ist vorbei, der C ++ 20-Standard wurde auf ein mehr oder weniger fertiges Aussehen reduziert (zumindest bis zum Erscheinen spezieller Hinweise), und ich möchte über eine der kommenden Innovationen sprechen.  Dies ist ein Mechanismus, der normalerweise als <i>Operator &lt;=&gt; bezeichnet wird</i> (der Standard definiert ihn als "Drei-Wege-Vergleichsoperator", hat aber den informellen Spitznamen "Raumschiff"), aber ich glaube, dass sein Anwendungsbereich viel breiter ist. <br><br>  Wir werden nicht nur einen neuen Operator haben - die Semantik der Vergleiche wird sich auf der Ebene der Sprache selbst erheblich ändern. <br><a name="habracut"></a><br>  Denken Sie an diese Tabelle, auch wenn Sie aus diesem Artikel nichts anderes herausholen können: <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Gleichheit</b> <br></td><td>  <b>Straffung</b> <br></td></tr><tr><td>  <b>Grundlegend</b> <br></td><td>  <i>==</i> <br></td><td>  <i>&lt;=&gt;</i> <br></td></tr><tr><td>  <b>Derivate</b> <br></td><td>  <i>! =</i> <br></td><td>  <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> , <i>&gt; =</i> <br></td></tr></tbody></table></div><br>  Jetzt haben wir einen neuen Operator, <i>&lt;=&gt;</i> , aber was noch wichtiger ist, die Operatoren sind jetzt systematisiert.  Es gibt grundlegende Operatoren und abgeleitete Operatoren - jede Gruppe hat ihre eigenen Fähigkeiten. <br><br>  Wir werden in der Einleitung kurz auf diese Funktionen eingehen und in den folgenden Abschnitten näher darauf eingehen. <br><br>  Grundlegende Operatoren können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>invertiert werden</b></a> (d. H. Mit der umgekehrten Reihenfolge der Parameter umgeschrieben werden).  Abgeleitete Anweisungen können über die entsprechende Basisanweisung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>umgeschrieben werden</b></a> .  Weder konvertierte noch umgeschriebene Kandidaten generieren neue Funktionen. Sie werden lediglich auf Quellcodeebene ersetzt und aus einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>erweiterten Gruppe von Kandidaten ausgewählt</b></a> .  Beispielsweise kann der Ausdruck <i>a &lt;9</i> jetzt als <i>a.operator &lt;=&gt; (9) &lt;0</i> und der Ausdruck <i>10! = B</i> als <i>! Operator == (b, 10)</i> ausgewertet werden.  Dies bedeutet, dass auf einen oder zwei Operatoren verzichtet werden kann, bei denen zur Erzielung des gleichen Verhaltens jetzt 2, 4, 6 oder sogar 12 Operatoren manuell geschrieben werden müssen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im</a> Folgenden wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein kurzer</a> Überblick über die Regeln zusammen mit einer Tabelle aller möglichen Transformationen gegeben. <br><br>  Sowohl Basisoperatoren als auch abgeleitete Operatoren können als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Standard</b></a> definiert werden.  Bei Basisoperatoren bedeutet dies, dass der Operator auf jedes Mitglied in der Deklarationsreihenfolge angewendet wird.  Bei abgeleiteten Operatoren werden diese umgeschriebenen Kandidaten verwendet. <br><br>  Es sollte beachtet werden, dass es keine solche Transformation gibt, bei der ein Operator einer Art (d. H. Gleichheit oder Ordnung) in Form eines Operators einer anderen Art ausgedrückt werden könnte.  Mit anderen Worten, die Spalten in unserer Tabelle sind in keiner Weise voneinander abhängig.  Der Ausdruck <i>a == b</i> wird niemals implizit als <i>Operator &lt;=&gt;</i> <i>(a, b) == 0</i> ausgewertet (aber natürlich hindert Sie nichts daran, Ihren <i>Operator ==</i> mit dem <i>Operator &lt;=&gt; zu definieren,</i> wenn Sie möchten). <br><br>  Betrachten Sie ein kleines Beispiel, in dem wir zeigen, wie der Code vor und nach dem Anwenden der neuen Funktionalität aussieht.  Wir werden einen String-Typ schreiben, bei dem nicht zwischen Groß- und Kleinschreibung unterschieden wird, <i>CIString</i> , dessen Objekte sowohl miteinander als auch mit <i>char const *</i> verglichen werden können. <br><br>  In C ++ 17 müssen wir für unsere Aufgabe 18 Vergleichsfunktionen schreiben: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CIString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assize() == bssize() &amp;&amp; ci_compare(asc_str(), bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), bsc_str()) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), b) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), b) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(a, bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(a, bsc_str()) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } };</code> </pre> <br>  In C ++ 20 können Sie nur 4 Funktionen ausführen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CIString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.size() == bssize() &amp;&amp; ci_compare(s.c_str(), bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), bsc_str()) &lt;=&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), b) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), b) &lt;=&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } };</code> </pre> <br>  Ich werde Ihnen genauer sagen, was das alles bedeutet, aber lassen Sie uns zunächst ein wenig zurückgehen und uns daran erinnern, wie Vergleiche mit dem C ++ 20-Standard funktioniert haben. <br><br><h2>  Vergleiche in Standards von C ++ 98 bis C ++ 17 </h2><br>  Die Vergleichsoperationen haben sich seit der Erstellung der Sprache nicht wesentlich geändert.  Wir hatten sechs Operatoren: <i>==,!</i> <i>=</i> , <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> Und <i>&gt; =</i> .  Der Standard definiert jeden von ihnen für eingebaute Typen, aber im Allgemeinen befolgen sie dieselben Regeln.  Bei der Auswertung eines <i>a @ b-</i> Ausdrucks (wobei <i>@</i> einer von sechs Vergleichsoperatoren ist) sucht der Compiler nach Elementfunktionen, freien Funktionen und integrierten Kandidaten mit dem Namen <i>operator @</i> , die in der angegebenen Reihenfolge mit Typ <i>A</i> oder <i>B</i> aufgerufen werden können.  Aus ihnen wird der am besten geeignete Kandidat ausgewählt.  Das ist alles.  Tatsächlich arbeiteten <i>alle</i> Operatoren auf die gleiche Weise: Die Operation <i>&lt;unterschied</i> sich nicht von <i>&lt;&lt;</i> . <br><br>  Solch ein einfaches Regelwerk ist leicht zu erlernen.  Alle Betreiber sind absolut unabhängig und gleichwertig.  Es spielt keine Rolle, was wir Menschen über die grundlegende Beziehung zwischen <i>==</i> und <i>! =</i> Operationen wissen.  In Bezug auf die Sprache ist dies ein und dasselbe.  Wir verwenden Redewendungen.  Zum Beispiel definieren wir den Operator <i>! =</i> Through <i>==</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; lhs, A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(lhs == rhs); }</code> </pre> <br>  In ähnlicher Weise definieren wir durch den Operator <i>&lt;</i> alle anderen Beziehungsoperatoren.  Wir verwenden diese Redewendungen, weil wir trotz der Regeln der Sprache nicht alle sechs Operatoren als gleichwertig betrachten.  Wir akzeptieren, dass zwei von ihnen grundlegend sind ( <i>==</i> und <i>&lt;</i> ), und durch sie werden alle anderen bereits ausgedrückt. <br><br>  Tatsächlich basiert die Standardvorlagenbibliothek vollständig auf diesen beiden Operatoren, und die große Anzahl von Typen im ausgenutzten Code enthält Definitionen von nur einem oder beiden. <br><br>  Der Operator <i>&lt;</i> ist jedoch aus zwei Gründen für die Basiserolle nicht sehr geeignet. <br><br>  Erstens kann nicht garantiert werden, dass andere Beziehungsoperatoren sich dadurch ausdrücken.  Ja, <i>a&gt; b</i> bedeutet genau dasselbe wie <i>b &lt;a</i> , aber es ist nicht wahr, dass <i>a &lt;= b</i> genau dasselbe bedeutet wie <i>! (B &lt;a)</i> .  Die letzten beiden Ausdrücke sind äquivalent, wenn es eine Eigenschaft der Trichotomie gibt, bei der für zwei beliebige Werte nur eine der drei Aussagen wahr ist: <i>a &lt;b</i> , <i>a == b</i> oder <i>a&gt; b</i> .  Bei Vorliegen einer Trichotomie bedeutet der Ausdruck <i>a &lt;= b</i> , dass es sich entweder um den ersten oder den zweiten Fall handelt ... und dies entspricht der Aussage, dass es sich nicht um den dritten Fall handelt.  Daher <i>(a &lt;= b) ==! (A&gt; b) ==! (B &lt;a)</i> . <br><br>  Aber was ist, wenn die Haltung nicht die Eigenschaft der Trichotomie besitzt?  Dies ist charakteristisch für partielle Ordnungsbeziehungen.  Ein klassisches Beispiel sind Gleitkommazahlen, für die eine der Operationen <i>1.f &lt;NaN</i> , <i>1.f == NaN</i> und <i>1.f&gt; NaN</i> <i>false</i> ergibt.  Daher <i>lügt</i> auch <i>1.f &lt;= NaN</i> , aber gleichzeitig <i>! (NaN &lt;1.f)</i> ist <i>wahr</i> . <br><br>  Die einzige Möglichkeit, den Operator <i>&lt;=</i> allgemein über die Basisoperatoren zu implementieren, besteht darin, beide Operationen als <i>(a == b) ||</i> zu zeichnen  <i>(a &lt;b)</i> , was ein großer Rückschritt ist, wenn wir uns <i>noch</i> mit linearer Ordnung befassen müssen, da dann nicht eine Funktion aufgerufen wird, sondern zwei (zum Beispiel der Ausdruck <i>„abc..xyz9“ &lt;= „abc ..xyz1 "</i> muss umgeschrieben werden als <i>(" abc..xyz9 "==" abc..xyz1 ") || (" abc..xyz9 "&lt;" abc..xyz1 ")</i> und zweimal, um die gesamte Zeile zu vergleichen). <br><br>  Zweitens ist der Operator <i>&lt;</i> aufgrund der Besonderheiten seiner Verwendung in lexikografischen Vergleichen für die Grundrolle nicht sehr geeignet.  Programmierer machen oft diesen Fehler: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t &lt; rhs.t &amp;&amp; u &lt; rhs.u; } };</code> </pre> <br>  Um den Operator == für eine Sammlung von Elementen zu definieren, reicht es aus, <i>== einmal</i> auf jedes Mitglied anzuwenden. Dies funktioniert jedoch nicht mit dem Operator <i>&lt;</i> .  Unter dem Gesichtspunkt dieser Implementierung werden die Mengen <i>A {1, 2}</i> und <i>A {2, 1}</i> als äquivalent angesehen (da keine von ihnen kleiner als die andere ist).  Um dies zu beheben, wenden Sie den Operator <i>&lt;</i> zweimal auf jedes Mitglied an, mit Ausnahme des letzten: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &lt; rhs.t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rhs.t &lt; t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u &lt; rhs.u; }</code> </pre> <br>  Schließlich, um den korrekten Betrieb von Vergleichen heterogener Objekte zu gewährleisten - d.h.  Um sicherzustellen, dass die Ausdrücke <i>a == 10</i> und <i>10 == a</i> dasselbe bedeuten, empfehlen sie normalerweise, Vergleiche als freie Funktionen zu schreiben.  Tatsächlich ist dies im Allgemeinen die einzige Möglichkeit, solche Vergleiche durchzuführen.  Dies ist unpraktisch, da Sie erstens die Einhaltung dieser Empfehlung überwachen müssen und zweitens normalerweise solche Funktionen als versteckte Freunde deklarieren müssen, um eine bequemere Implementierung zu ermöglichen (d. H. Innerhalb des Klassenkörpers). <br><br>  Beachten Sie, dass beim Vergleichen von Objekten unterschiedlichen Typs nicht immer der <i>Operator == (X, int) geschrieben werden muss</i> .  Sie können auch Fälle bedeuten, in denen <i>int</i> implizit in <i>X umgewandelt werden kann</i> . <br><br>  Fassen wir die Regeln zum C ++ 20-Standard zusammen: <br><br><ul><li>  Alle Anweisungen werden gleich behandelt. </li><li>  Wir verwenden Redewendungen, um die Implementierung zu erleichtern.  Die Operatoren <i>==</i> und <i>&lt;</i> nehmen wir für die Grundsprachen und drücken die verbleibenden Beziehungsoperatoren durch sie aus. </li><li>  Das ist nur der Operator <i>&lt;ist</i> für die Rolle der Basis nicht sehr geeignet. </li><li>  Es ist wichtig (und empfohlen), Vergleiche heterogener Objekte als freie Funktionen zu schreiben. </li></ul><br><h2>  Neuer grundlegender Bestelloperator: &lt;=&gt; </h2><br>  Die bedeutendste und auffälligste Änderung in der Arbeit von Vergleichen in C ++ 20 ist die Hinzufügung eines neuen Operators - <i>Operator &lt;=&gt;</i> , eines Drei-Wege-Vergleichsoperators. <br><br>  Drei-Wege-Vergleiche sind bereits mit den Funktionen <i>memcmp</i> / <i>strcmp</i> in C und <i>basic_string :: compare ()</i> in C ++ bekannt.  Sie alle geben einen Wert vom Typ <i>int zurück</i> , der durch eine beliebige positive Zahl dargestellt wird, wenn das erste Argument größer als das zweite ist, <i>0,</i> wenn sie gleich sind, und ansonsten durch eine beliebige negative Zahl. <br><br>  Der Operator "Raumschiff" gibt keinen <i>int-</i> Wert zurück, sondern ein Objekt, das zu einer der Vergleichskategorien gehört, deren Wert die Art der Beziehung zwischen den verglichenen Objekten widerspiegelt.  Es gibt drei Hauptkategorien: <br><br><ul><li>  <i>strong_ordering</i> : Eine lineare Ordnungsbeziehung, in der Gleichheit die Austauschbarkeit von Elementen impliziert (d. <i>h. (a &lt;=&gt; b) == strong_ordering :: gleich</i> impliziert, dass <i>f (a) == f (b)</i> für alle geeigneten Funktionen <i>f gilt</i> Der Begriff „geeignete Funktion“ wird absichtlich nicht klar definiert, enthält jedoch keine Funktionen, die die Adressen ihrer Argumente oder die <i>Kapazität () des</i> Vektors usw. zurückgeben. Wir interessieren uns nur für die „wesentlichen“ Eigenschaften, die ebenfalls sehr vage, aber bedingt möglich sind Nehmen wir an, wir sprechen über den <i>Wert</i> des Typs. Der Wert des Vektors ist darin enthalten  m Elemente, aber nicht seine Adresse usw.).  Diese Kategorie enthält die folgenden Werte: <i>strong_ordering :: größer</i> , <i>strong_ordering :: gleich</i> und <i>strong_ordering :: kleiner</i> . </li><li>  <i>schwache_ordnung</i> : eine lineare Ordnungsbeziehung, in der Gleichheit nur eine bestimmte Äquivalenzklasse definiert.  Ein klassisches Beispiel ist der Vergleich von Zeichenfolgen ohne <i>Berücksichtigung der</i> Groß- und Kleinschreibung, wenn zwei Objekte <i>schwach_bestellend :: äquivalent sein können</i> , aber nicht genau gleich sind (dies erklärt das Ersetzen des Wortes <i>gleich</i> durch <i>äquivalent</i> im <i>Wertnamen</i> ). </li><li>  Teilbestellung: Teilordnungsbeziehung.  In dieser Kategorie wird ein weiterer Wert zu den Werten <i>größer</i> , <i>äquivalent</i> und <i>kleiner</i> hinzugefügt (wie bei <i>schwach_bestellung</i> ) - <i>ungeordnet</i> ("ungeordnet").  Es kann verwendet werden, um Teilordnungsbeziehungen in einem Typsystem <i>auszudrücken</i> : <i>1.f &lt;=&gt; NaN</i> gibt den Wert <i>partielle_bestellung :: ungeordnet an</i> . </li></ul><br>  Sie arbeiten hauptsächlich mit der Kategorie <i>strong_ordering</i> .  Dies ist auch die optimale Kategorie für die standardmäßige Verwendung.  Beispiel: <i>2 &lt;=&gt; 4</i> gibt <i>strong_ordering :: less</i> und <i>3 &lt;=&gt; -1</i> <i>gibt strong_ordering :: größer zurück</i> . <br><br>  Kategorien höherer Ordnung können implizit auf Kategorien schwächerer Ordnung reduziert werden (d. H. <i>Starke</i> Ordnung ist auf schwache Ordnung reduzierbar).  In diesem Fall bleibt der aktuelle Beziehungstyp erhalten (d. H. <i>Starke Ordnung :: gleich</i> wird zu <i>schwacher Ordnung :: äquivalent</i> ). <br><br>  Die Werte der Vergleichskategorien können mit einem von sechs Vergleichsoperatoren mit Literal <i>0</i> (nicht mit <i>int</i> und nicht mit <i>int</i> gleich <i>0</i> , sondern einfach mit Literal <i>0</i> ) verglichen werden: <br><br><pre> <code class="cpp hljs">strong_ordering::less &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">// true strong_ordering::less == 0 // false strong_ordering::less != 0 // true strong_ordering::greater &gt;= 0 // true partial_ordering::less &lt; 0 // true partial_ordering::greater &gt; 0 // true // unordered -  ,   //       partial_ordering::unordered &lt; 0 // false partial_ordering::unordered == 0 // false partial_ordering::unordered &gt; 0 // false</span></span></code> </pre> <br>  Dank eines Vergleichs mit dem Literal <i>0</i> können wir die Beziehungsoperatoren implementieren: <i>a @ b</i> entspricht <i>(a &lt;=&gt; b) @ 0</i> für jeden dieser Operatoren. <br><br>  Zum Beispiel kann <i>2 &lt;4</i> als <i>(2 &lt;=&gt; 4) &lt;0</i> berechnet werden, was zu <i>strong_ordering :: less &lt;0 führt</i> und den Wert <i>true</i> ergibt. <br><br>  Der Operator <i>&lt;=&gt;</i> passt viel besser zur Rolle des Basiselements als der Operator <i>&lt;</i> , da beide Probleme des letzteren beseitigt werden. <br><br>  Erstens <i>ist</i> garantiert, dass der Ausdruck <i>a &lt;= b</i> auch bei teilweiser Ordnung äquivalent zu <i>(a &lt;=&gt; b) &lt;= 0 ist</i> .  Für zwei ungeordnete Werte gibt <i>a &lt;=&gt; b</i> den Wert <i>partielle_bestellte :: ungeordnete</i> und <i>partielle_bestellte :: ungeordnete &lt;= 0</i> gibt <i>false an</i> , was wir brauchen.  Dies ist möglich, weil <i>&lt;=&gt;</i> mehr Arten von Werten zurückgeben kann: Beispielsweise enthält die Kategorie <i>partielle</i> Ordnung vier mögliche Werte.  Ein Wert vom Typ <i>bool</i> kann nur <i>wahr</i> oder <i>falsch sein</i> , bevor wir nicht zwischen Vergleichen geordneter und ungeordneter Werte unterscheiden konnten. <br><br>  Betrachten Sie zur Verdeutlichung ein Beispiel für eine Teilordnungsbeziehung, die sich nicht auf Gleitkommazahlen bezieht.  Angenommen, wir möchten einem <i>int-</i> Typ einen NaN-Status hinzufügen, wobei NaN nur ein Wert ist, der kein geordnetes Paar mit einem beteiligten Wert bildet.  Sie können dies mit <i>std :: optional</i> tun, um es zu speichern: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntNan</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; val = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(IntNan <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!val || !rhs.val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *val == *rhs.val; } partial_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(IntNan <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!val || !rhs.val) { <span class="hljs-comment"><span class="hljs-comment">//  unordered   //     return partial_ordering::unordered; } // &lt;=&gt;   strong_ordering  int, //        partial_ordering return *val &lt;=&gt; *rhs.val; } }; IntNan{2} &lt;=&gt; IntNan{4}; // partial_ordering::less IntNan{2} &lt;=&gt; IntNan{}; // partial_ordering::unordered //     .    IntNan{2} &lt; IntNan{4}; // true IntNan{2} &lt; IntNan{}; // false IntNan{2} == IntNan{}; // false IntNan{2} &lt;= IntNan{}; // false</span></span></code> </pre> <br>  Der Operator <i>&lt;=</i> gibt den korrekten Wert zurück, da wir jetzt mehr Informationen auf der Ebene der Sprache selbst ausdrücken können. <br><br>  Zweitens reicht es aus, <i>&lt;=&gt;</i> einmal anzuwenden, um alle erforderlichen Informationen zu erhalten, was die Implementierung eines lexikografischen Vergleichs erleichtert: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    //  t.   != 0 (..  t // ),    //   if (auto c = t &lt;=&gt; rhs.t; c != 0) return c; //     //    return u &lt;=&gt; rhs.u; };</span></span></code> </pre> <br>  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen finden</a> Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0515</a> , dem ursprünglichen Satz zum Hinzufügen des <i>Operators &lt;=&gt;.</i> <br><br><h2>  Neue Bedienerfunktionen </h2><br>  Wir verfügen nicht nur über einen neuen Betreiber.  Wenn das oben gezeigte Beispiel mit der Deklaration der Struktur <i>A</i> nur besagt, dass <i>wir</i> jetzt jedes Mal anstelle von <i>x &lt;y</i> <i>(x &lt;=&gt; y) &lt;0</i> schreiben müssen, würde es niemandem gefallen. <br><br>  Der Mechanismus zum Auflösen von Vergleichen in C ++ 20 unterscheidet sich deutlich vom alten Ansatz, aber diese Änderung steht in direktem Zusammenhang mit dem neuen Konzept zweier grundlegender Vergleichsoperatoren: <i>==</i> und <i>&lt;=&gt;</i> .  Wenn es früher eine Redewendung (Aufnahme über <i>==</i> und <i>&lt;</i> ) war, die wir verwendet haben, von der der Compiler aber nichts wusste, wird er diesen Unterschied jetzt verstehen. <br><br>  Ich werde noch einmal die Tabelle geben, die Sie bereits am Anfang des Artikels gesehen haben: <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Gleichheit</b> <br></td><td>  <b>Straffung</b> <br></td></tr><tr><td>  <b>Grundlegend</b> <br></td><td>  <i>==</i> <br></td><td>  <i>&lt;=&gt;</i> <br></td></tr><tr><td>  <b>Derivate</b> <br></td><td>  <i>! =</i> <br></td><td>  <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> , <i>&gt; =</i> <br></td></tr></tbody></table></div><br>  Jeder der Basis- und Ableitungsoperatoren hat eine neue Fähigkeit erhalten, die ich noch ein paar Worte weiter sagen werde. <br><br><h3>  Inversion von Basisoperatoren </h3><br>  Nehmen Sie als Beispiel einen Typ, der nur mit <i>int</i> verglichen werden kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } };</code> </pre> <br>  Unter dem Gesichtspunkt der alten Regeln ist es nicht überraschend, dass der Ausdruck <i>a == 10</i> funktioniert und zu <i>a.operator == (10)</i> ausgewertet wird. <br><br>  Aber was ist mit <i>10 == a</i> ?  In C ++ 17 wird dieser Ausdruck als eindeutiger Syntaxfehler betrachtet.  Es gibt keinen solchen Operator.  Damit ein solcher Code funktioniert, müssten Sie einen symmetrischen <i>Operator ==</i> schreiben, der zuerst den Wert von <i>int</i> und dann <i>A</i> ... annimmt, und um dies zu implementieren, müsste er in Form einer freien Funktion vorliegen. <br><br>  In C ++ 20 können grundlegende Operatoren invertiert werden.  Für <i>10 == a findet der</i> Compiler den Kandidatenoperator <i>== (A, int)</i> (tatsächlich ist dies eine Mitgliedsfunktion, aber der Klarheit halber schreibe ich ihn hier als freie Funktion) und dann zusätzlich - eine Variante mit der umgekehrten Reihenfolge der Parameter, d.h. .  <i>operator == (int, A)</i> .  Dieser zweite Kandidat stimmt mit unserem Ausdruck überein (und im Idealfall), also werden wir ihn wählen.  Der Ausdruck <i>10 == a</i> in C ++ 20 wird als <i>a.operator == (10)</i> ausgewertet.  Der Compiler versteht, dass Gleichheit symmetrisch ist. <br><br>  Jetzt werden wir unseren Typ erweitern, damit er nicht nur über den Gleichheitsoperator, sondern auch über den Ordnungsoperator mit <i>int</i> verglichen werden kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i &lt;=&gt; j; } };</code> </pre> <br>  Auch hier funktioniert der Ausdruck <i>a &lt;=&gt; 42</i> <i>einwandfrei</i> und wird nach den alten Regeln als <i>a.operator &lt;=&gt; (42)</i> berechnet, aber <i>42 &lt;=&gt;</i> a wäre aus Sicht von C ++ 17 falsch, selbst wenn der Operator <i>&lt; =&gt;</i> existierte bereits in der Sprache.  In C ++ 20 ist der <i>Operator &lt;=&gt;</i> wie der <i>Operator ==</i> symmetrisch: Er erkennt invertierte Kandidaten.  Für <i>42 &lt;=&gt;</i> a wird ein <i>Elementfunktionsoperator &lt;=&gt;</i> <i>(A, int)</i> gefunden (wieder schreibe ich es hier nur zur besseren Übersichtlichkeit als freie Funktion) sowie ein synthetischer Kandidatenoperator <i>&lt;=&gt;</i> <i>(int, A).</i> .  Diese umgekehrte Version passt genau zu unserem Ausdruck - wir wählen ihn aus. <br><br>  <i>42 &lt;=&gt;</i> <i>a wird jedoch</i> NICHT als <i>a.operator</i> <i>&lt;=&gt;</i> berechnet <i>(42)</i> .  Das wäre falsch  Dieser Ausdruck <i>ergibt 0 &lt;=&gt; a.operator &lt;=&gt; (42)</i> .  Versuchen Sie herauszufinden, warum dieser Eintrag korrekt ist. <br><br>  Es ist wichtig zu beachten, dass der Compiler keine neuen Funktionen erstellt.  Bei der Berechnung von <i>10 == a</i> wurde der neue Operatoroperator <i>== (int, A)</i> nicht angezeigt, und bei der Berechnung von <i>42 &lt;=&gt; a</i> wurde der <i>Operator</i> <i>&lt;=&gt;</i> <i>(int, A)</i> nicht angezeigt.  Nur zwei Ausdrücke werden durch invertierte Kandidaten umgeschrieben.  Ich wiederhole: Es werden keine neuen Funktionen erstellt. <br><br>  Beachten Sie auch, dass ein Datensatz mit der umgekehrten Reihenfolge der Parameter nur für Basisoperatoren verfügbar ist, für Ableitungen jedoch nicht.  Also: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; }; b != <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ok   C++17,   C++20 42 != b; //    C++17,   C++20</span></span></code> </pre> <br><h3>  Abgeleitete Operatoren umschreiben </h3><br>  Kehren wir zu unserem Beispiel mit Struktur <i>A zurück</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i &lt;=&gt; j; } };</code> </pre> <br>  Nehmen Sie den Ausdruck <i>a! = 17</i> .  In C ++ 17 ist dies ein Syntaxfehler, da der <i>Operator! =</i> Operator nicht vorhanden ist.  In C ++ 20 sucht der Compiler jedoch für Ausdrücke, die abgeleitete Vergleichsoperatoren enthalten, auch nach den entsprechenden Basisoperatoren und drückt abgeleitete Vergleiche durch diese aus. <br><br>  Wir wissen, dass in der Mathematik die Operation <i>! =</i> Im Wesentlichen NICHT <i>==</i> bedeutet.  Dies ist dem Compiler nun bekannt.  Für den Ausdruck <i>a! = 17</i> sucht er nicht nur nach dem <i>Operator! = Operatoren</i> , sondern auch nach dem <i>Operator ==</i> (und wie in den vorherigen Beispielen nach dem invertierten <i>Operator ==</i> ).  In diesem Beispiel haben wir einen Gleichheitsoperator gefunden, der fast zu uns passt - wir müssen ihn nur entsprechend der gewünschten Semantik umschreiben: <i>a! = 17</i> wird berechnet als <i>! (A == 17)</i> . <br><br>  In ähnlicher Weise wird <i>17! =</i> A berechnet als <i>! A.operator == (17)</i> , was sowohl eine umgeschriebene als auch eine invertierte Version ist. <br><br>  Ähnliche Transformationen werden auch für bestellende Operatoren durchgeführt.  Wenn wir <i>eine &lt;9</i> schreiben würden, würden wir (erfolglos) versuchen, den <i>Operator &lt;</i> zu finden, und auch die grundlegenden Kandidaten berücksichtigen: den <i>Operator &lt;=&gt;</i> .  Der entsprechende Ersatz für die Beziehungsoperatoren sieht folgendermaßen aus: <i>a @ b</i> (wobei <i>@</i> einer der Beziehungsoperatoren ist) wird als <i>(a &lt;=&gt; b) @ 0</i> berechnet.  In unserem Fall ist <i>a.operator &lt;=&gt; (9) &lt;0</i> .  In ähnlicher Weise wird <i>9 &lt;= a</i> als <i>0 &lt;= a.operator &lt;=&gt; (9)</i> berechnet. <br><br>  Beachten Sie, dass der Compiler wie im Fall des Aufrufs keine neuen Funktionen für die neu geschriebenen Kandidaten erstellt.  Sie werden einfach unterschiedlich berechnet und alle Transformationen werden nur auf Quellcodeebene ausgeführt. <br><br>  Das Obige führt mich zu folgendem Rat: <br><br>  <b><i>NUR GRUNDLEGENDE OPERATOREN</i></b> <i>: Definieren Sie nur grundlegende Operatoren (== und &lt;=&gt;) in Ihrem Typ.</i> <br><br>  Da die Basisoperatoren den gesamten Satz von Vergleichen angeben, reicht es aus, nur diese zu definieren.  Dies bedeutet, dass Sie nur 2 Operatoren benötigen, um Objekte desselben Typs zu vergleichen (anstelle von 6, ab sofort), und nur 2 Operatoren, um verschiedene Objekttypen zu vergleichen (anstelle von 12).  Wenn Sie nur die Gleichheitsoperation benötigen, schreiben Sie einfach 1 Funktion zum Vergleichen von Objekten desselben Typs (anstelle von 2) und 1 Funktion zum Vergleichen verschiedener Objekttypen (anstelle von 4).  Die <i>Klasse std :: sub_match</i> ist ein Extremfall: In C ++ 17 werden 42 Vergleichsoperatoren verwendet, und in C ++ 20 werden nur 8 verwendet, während die Funktionalität in keiner Weise darunter leidet. <br><br>  Da der Compiler auch invertierte Kandidaten berücksichtigt, können alle diese Operatoren als Elementfunktionen implementiert werden.  Sie müssen keine freien Funktionen mehr schreiben, um Objekte verschiedener Typen zu vergleichen. <br><br><h3>  Sonderregeln für die Suche nach Kandidaten </h3><br>  Wie bereits erwähnt, wurde die Suche nach Kandidaten für <i>a @ b</i> in C ++ 17 nach folgendem Prinzip durchgeführt: Wir finden alle <i>Operator @ -Operatoren</i> und wählen aus ihnen den am besten geeigneten aus. <br><br>  C ++ 20 verwendet eine erweiterte Gruppe von Kandidaten.  Jetzt werden wir alle <i>Operatoren @</i> suchen.  Sei <i>@@</i> der <i>Basisoperator</i> für <i>@</i> (es kann der gleiche Operator sein).  Wir finden auch alle <i>Operatoren @@</i> und <i>fügen</i> für jeden von ihnen die invertierte Version hinzu.  Aus all diesen gefundenen Kandidaten wählen wir die am besten geeigneten aus. <br><br>  Beachten Sie, dass eine Überladung des Bedieners in <b>einem einzigen</b> Durchgang zulässig ist.  Wir versuchen nicht, verschiedene Kandidaten zu ersetzen.  Zuerst sammeln wir sie alle und wählen dann die beste aus ihnen aus.  Wenn dies nicht vorhanden ist, schlägt die Suche wie zuvor fehl. <br><br>  Jetzt haben wir viel mehr potenzielle Kandidaten und damit mehr Unsicherheit.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(C <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(C <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C x, C y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x != y; }</code> </pre> <br>  In C ++ 17 hatten wir nur einen Kandidaten für <i>x! = Y</i> , und jetzt gibt es drei: <i>x.operator! = (Y)</i> <i>,! X.operator == (y)</i> und <i>! Y.operator == (x)</i> .  Was soll ich wählen?  Sie sind alle gleich!  (Hinweis: Der Kandidat <i>y.operator! = (X)</i> existiert nicht, da nur <i>Basisoperatoren invertiert werden können</i> .) <br><br>  Zwei zusätzliche Regeln wurden eingeführt, um diese Unsicherheit zu beseitigen.  Nicht konvertierte Kandidaten sind Konvertiten vorzuziehen.    .  ,  <i>x.operator!=(y)</i> «» <i>!x.operator==(y)</i> ,   «» <i>!y.operator==(x)</i> .      ,   «»   . <br><br>   :           <i>operator@@</i> .    .   ,       . <br><br>        -.    —    (,   <i>x &lt; y</i> ,    —  <i>(x &lt;=&gt; y) &lt; 0</i> ),        (, <i>x &lt;=&gt; y</i>  <i>void</i>  -  ,       DSL),    .          .       ,       <i>bool</i>      (  :  <i>operator==</i>   <i>bool</i> ,        ?) <br><br>  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Base&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Base&amp;); <span class="hljs-comment"><span class="hljs-comment">// #1 friend bool operator==(const Base&amp;, const Base&amp;); }; struct Derived : Base { friend void operator&lt;=&gt;(const Derived&amp;, const Derived&amp;); // #2 }; bool f(Derived d1, Derived d2) { return d1 &lt; d2; }</span></span></code> </pre> <br>   <i>d1 &lt; d2</i>    : <i>#1</i>  <i>#2</i> .   — <i>#2</i> ,      , ,   .    ,  <i>d1 &lt; d2</i>   <i>(d1 &lt;=&gt; d2) &lt; 0</i> .    ,    <i>void</i>  <i>0</i> — ,    . ,          - ,    <i>#1</i> . <br><br><h3>    </h3><br> ,     ,    C++17,         .    ,  -    .     : <br><br><ul><li>       </li><li>      (  ) </li><li>            ,         </li><li>               ,   . </li></ul><br>         <b>  </b> ,        .     . <br><br>             .          ,    ,  ,   ,   ,      (   ).  ,         : <br><div class="scrollable-table"><table><tbody><tr><td> <b> </b> <br></td><td>  <b>Variante 1</b> <br></td><td>  <b>Option 2</b> <br></td></tr><tr><td> <i>a == b</i> <br></td><td> <i>b == a</i> <br></td><td><br></td></tr><tr><td> <i>a != b</i> <br></td><td> <i>!(a == b)</i> <br></td><td> <i>!(b == a)</i> <br></td></tr><tr><td> <i>a &lt;=&gt; b</i> <br></td><td> <i>0 &lt;=&gt; (b &lt;=&gt; a)</i> <br></td><td><br></td></tr><tr><td> <i>a &lt; b</i> <br></td><td> <i>(a &lt;=&gt; b) &lt; 0</i> <br></td><td> <i>(b &lt;=&gt; a) &gt; 0</i> <br></td></tr><tr><td> <i>a &lt;= b</i> <br></td><td> <i>(a &lt;=&gt; b) &lt;= 0</i> <br></td><td> <i>(b &lt;=&gt; a) &gt;= 0</i> <br></td></tr><tr><td> <i>a &gt; b</i> <br></td><td> <i>(a &lt;=&gt; b) &gt; 0</i> <br></td><td> <i>(b &lt;=&gt; a) &lt; 0</i> <br></td></tr><tr><td> <i>a &gt;= b</i> <br></td><td> <i>(a &lt;=&gt; b) &gt;= 0</i> <br></td><td> <i>(b &lt;=&gt; a) &lt;= 0</i> <br></td></tr></tbody></table></div><br>   « »         ,     , .. <i>a &lt; b</i>   <i>0 &lt; (b &lt;=&gt; a)</i> ,       ,   ,      . <br><br><h3>       </h3><br>    C++17       .      .           : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u &amp;&amp; v == rhs.v; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,     , //     ?:  &amp;&amp;/|| if (t &lt; rhs.t) return true; if (rhs.t &lt; t) return false; if (u &lt; rhs.u) return true; if (rhs.u &lt; u) return false; return v &lt; rhs.v; } bool operator&gt; (A const&amp; rhs) const { return rhs &lt; *this; } bool operator&lt;=(A const&amp; rhs) const { return !(rhs &lt; *this); } bool operator&gt;=(A const&amp; rhs) const { return !(*this &lt; rhs); } };</span></span></code> </pre> <br>      - <i>std::tie()</i> ,     . <br><br>       ,   :    : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u &amp;&amp; v == rhs.v; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   T if (auto c = t &lt;=&gt; rhs.t; c != 0) return c; // ...  U if (auto c = u &lt;=&gt; rhs.u; c != 0) return c; // ...  V return v &lt;=&gt; rhs.v; } };</span></span></code> </pre> <br>     .   <i>&lt;=&gt;</i>         <i>&lt;</i> .  ,        .  <i>c != 0</i>    ,      ,          ( <i></i>  <i></i> ),     . <br><br>        <i> </i> .   C++20    ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>   ,        .     ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>    .   ,         ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>   ,     ,     .     :        <i>operator==</i> ,     <i>operator&lt;=&gt;</i> . <br><br><h2>    </h2><br>         C++20:        .          .         ,    ,        ,     . <br><br><h2>   </h2><br>  PVS-Studio      ,            &lt;=&gt;  .         ,       -.   ,     ,            (.  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> ").  ++          . <br><br>      PVS-Studio        &lt;,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t &lt; rhs.t &amp;&amp; u &lt; rhs.u; }</code> </pre> <br>        . ,   -  .  . <br><br> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Comparisons in C++20</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465575/">https://habr.com/ru/post/de465575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465561/index.html">Was ich von einem führenden Programmierer gelernt habe</a></li>
<li><a href="../de465567/index.html">Testen von SQL Server-Code mit tSQLt</a></li>
<li><a href="../de465569/index.html">Entwicklungskarte für mobile Entwickler</a></li>
<li><a href="../de465571/index.html">Wie man Männerzigaretten für Frauen verkauft und Wilde dazu bringt, sich selbst zu schützen: Texter, die es könnten</a></li>
<li><a href="../de465573/index.html">Die ganze Kraft von IntelliJ IDEA am Beispiel einer Sprache (in Bildern)</a></li>
<li><a href="../de465577/index.html">Neue Arten der Mikromarkierung für erweiterte interaktive Snippets</a></li>
<li><a href="../de465579/index.html">Erstellen von Unternehmens-Chats und Videokonferenzen mit dem Zextras-Team</a></li>
<li><a href="../de465583/index.html">Details der böswilligen Kampagne für iPhone-Nutzer enthüllt</a></li>
<li><a href="../de465585/index.html">So verwalten Sie React Data Grid über Redux</a></li>
<li><a href="../de465587/index.html">Analyse: Was ist der OTC-Markt und welche Transaktionen werden dort durchgeführt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>