<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüöí üà∏ üëçüèæ Schweigen von Ruby-Ausf√ºhrungen: Transactional Rails / PostgreSQL-Thriller üôÜüèø üöß üë®‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist eine Geschichte dar√ºber, warum Sie Fehler niemals ignorieren sollten , wenn Sie sich in einer Transaktion in einer Datenbank befinden. Es ist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schweigen von Ruby-Ausf√ºhrungen: Transactional Rails / PostgreSQL-Thriller</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418147/"><p>  <em>Dies ist eine Geschichte dar√ºber, warum Sie Fehler <strong>niemals</strong> ignorieren <strong>sollten</strong> , wenn Sie sich in einer Transaktion in einer Datenbank befinden.</em>  <em>Es ist keine Option, herauszufinden, wie Transaktionen richtig verwendet werden und was zu tun ist, wenn sie verwendet werden.</em>  <em>Spoiler: Es geht um Beratungssperren in PostgreSQL!</em> </p><br><p> Ich habe an einem Projekt gearbeitet, in dem Benutzer eine gro√üe Anzahl schwerer Entit√§ten (nennen wir sie Produkte) von einem externen Dienst in unsere Anwendung importieren k√∂nnen.  F√ºr jedes Produkt werden noch vielf√§ltigere Daten von externen APIs geladen.  Es ist nicht ungew√∂hnlich, dass ein Benutzer Hunderte von Produkten zusammen mit allen Abh√§ngigkeiten l√§dt. Daher dauert der Import eines Produkts sp√ºrbar (30 bis 60 Sekunden), und der gesamte Vorgang kann lange dauern.  Der Benutzer kann es leid sein, auf das Ergebnis zu warten, und er hat das Recht, jederzeit auf die Schaltfl√§che "Abbrechen" zu klicken. Die Anwendung sollte f√ºr die Anzahl der Produkte n√ºtzlich sein, die zu diesem Zeitpunkt heruntergeladen werden konnten. </p><a name="habracut"></a><br><p>  Der ‚Äûunterbrochene Import‚Äú wird wie folgt implementiert: Zu Beginn wird f√ºr jedes Produkt ein tempor√§rer Aufgabendatensatz auf dem Typenschild in der Datenbank erstellt.  F√ºr jedes Produkt wird eine Hintergrundimportaufgabe gestartet, die das Produkt herunterl√§dt, zusammen mit allen Abh√§ngigkeiten in der Datenbank speichert (alles im Allgemeinen erledigt) und ganz am Ende seinen Aufgabendatensatz l√∂scht.  Wenn zum Zeitpunkt des Starts der Hintergrundaufgabe kein Datensatz in der Datenbank vorhanden ist, wird die Aufgabe einfach stillschweigend beendet.  Um den Import abzubrechen, reicht es also aus, einfach alle Aufgaben zu l√∂schen und fertig. </p><br><p>  Es spielt keine Rolle, ob der Import vom Benutzer abgebrochen oder vollst√§ndig von ihm selbst abgeschlossen wurde. In jedem Fall bedeutet das Fehlen von Aufgaben, dass alles vorbei ist und der Benutzer die Anwendung verwenden kann. </p><br><p>  Das Design ist einfach und zuverl√§ssig, aber es gab einen kleinen Fehler.  Ein typischer Fehlerbericht √ºber ihn lautete: ‚ÄûNachdem der Import abgebrochen wurde, wird dem Benutzer eine Liste seiner Waren angezeigt.  Wenn Sie die Seite jedoch aktualisieren, wird die Liste der Produkte durch mehrere Eintr√§ge erg√§nzt. "  Der Grund f√ºr dieses Verhalten ist einfach: Wenn der Benutzer auf die Schaltfl√§che "Abbrechen" klickte, wurde er sofort in die Liste aller Produkte √ºbernommen.  Zu diesem Zeitpunkt laufen jedoch bereits begonnene Importe bestimmter Waren noch. </p><br><p>  Dies ist nat√ºrlich eine Kleinigkeit, aber die Benutzer waren von der Bestellung verwirrt, daher w√§re es sch√∂n, sie zu beheben.  Ich hatte zwei M√∂glichkeiten: bereits laufende Aufgaben irgendwie zu identifizieren und zu "t√∂ten" oder, wenn ich auf die Schaltfl√§che "Abbrechen" klicke, zu warten, bis sie abgeschlossen sind, und "ihren eigenen Tod zu sterben", bevor ich den Benutzer weiter √ºbertrage.  Ich entschied mich f√ºr den zweiten Weg - zu warten. </p><br><h2 id="tranzakcionnye-blokirovki-speshat-na-pomosch">  Transaktionssperren eilen zur Rettung </h2><br><p>  F√ºr alle, die mit (relationalen) Datenbanken arbeiten, liegt die Antwort auf der Hand: Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transaktionen</a> ! </p><br><p> Es ist wichtig zu beachten, dass in den meisten RDBMS Datens√§tze, die innerhalb einer Transaktion aktualisiert wurden, <em>blockiert werden</em> und f√ºr √Ñnderungen durch andere Prozesse nicht zug√§nglich sind, bis diese Transaktion abgeschlossen ist.  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>SELECT FOR UPDATE</code></a> ausgew√§hlte Datens√§tze werden ebenfalls gesperrt. </p><br><p>  Genau unser Fall!  Ich habe die Aufgabe des Imports einzelner Waren in eine Transaktion verpackt und den Aufgabendatensatz ganz am Anfang blockiert: </p><br><pre> <code class="ruby hljs">ActiveRecord::Base.transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> task = Import::Task.lock.find_by(<span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> id) <span class="hljs-comment"><span class="hljs-comment"># SELECT ‚Ä¶ FOR UPDATE  ¬´    ¬ª return unless task #  - ? ,    ! #     task.destroy end</span></span></code> </pre> <br><p>  Wenn der Benutzer den Import abbrechen m√∂chte, l√∂scht der Importstopp die Aufgaben f√ºr die noch nicht gestarteten Importe und muss auf den Abschluss der bereits vorhandenen warten: </p><br><pre> <code class="ruby hljs">user.import_tasks.delete_all <span class="hljs-comment"><span class="hljs-comment">#       </span></span></code> </pre> <br><p>  Einfach und elegant!  Ich habe die Tests durchgef√ºhrt, den Import lokal und bei der Bereitstellung √ºberpr√ºft und "in den Kampf" eingesetzt. </p><br><h2 id="ne-tak-bystro">  Nicht so schnell‚Ä¶ </h2><br><p>  Zufrieden mit meiner Arbeit war ich sehr √ºberrascht, bald Fehlerberichte und Unmengen von Fehlern in den Protokollen zu finden.  Viele Produkte wurden √ºberhaupt nicht importiert.  In einigen F√§llen konnte nach Abschluss aller Importe nur noch ein einziges Produkt √ºbrig bleiben. </p><br><p>  Fehler in den Protokollen waren ebenfalls nicht ermutigend: <code>PG::InFailedSqlTransaction</code> mit einem Backtrack, der zu dem Code f√ºhrte, der die unschuldigen <code>PG::InFailedSqlTransaction</code> ausf√ºhrte.  Was ist √ºberhaupt los? </p><br><p>  Nach einem Tag anstrengenden Debuggens habe ich drei Hauptursachen f√ºr die Probleme identifiziert: </p><br><ol><li>  Wettbewerbsf√§higes Einf√ºgen widerspr√ºchlicher Datens√§tze in die Datenbank. </li><li>  Automatische Transaktionsstornierung in PostgreSQL nach Fehlern. </li><li>  Schweigen von Problemen (Ruby-Ausnahmen) im Anwendungscode. </li></ol><br><p>  <strong>Problem Eins: Wettbewerbsorientiertes Einf√ºgen von widerspr√ºchlichen Eintr√§gen</strong> </p><br><p>  Da jeder Importvorgang bis zu einer Minute dauert und es viele dieser Aufgaben gibt, f√ºhren wir sie parallel aus, um Zeit zu sparen.  Abh√§ngige Warendatens√§tze k√∂nnen sich √ºberschneiden, sofern sich alle Produkte des Benutzers auf einen einzigen Datensatz beziehen k√∂nnen, der einmal erstellt und dann wiederverwendet wird. </p><br><p>  Es gibt √úberpr√ºfungen, um dieselben Abh√§ngigkeiten im Anwendungscode zu finden und wiederzuverwenden. <em>Wenn wir jedoch Transaktionen verwenden, sind diese √úberpr√ºfungen unbrauchbar geworden</em> : Wenn Transaktion A einen abh√§ngigen Datensatz erstellt hat <em>, dieser</em> jedoch noch nicht abgeschlossen wurde, kann Transaktion B seine Existenz nicht herausfinden und versucht, ein Duplikat zu erstellen aufnehmen. </p><br><p>  <strong>Problem 2: Automatische Transaktionsstornierung von PostgreSQL nach Fehlern</strong> </p><br><p>  Nat√ºrlich haben wir die Erstellung doppelter Aufgaben auf Datenbankebene mithilfe der folgenden DDL verhindert: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> product_deps <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> (user_id, characteristics);</code> </pre> <br><p>  Wenn eine laufende Transaktion A einen neuen Datensatz einf√ºgt und Transaktion B versucht, einen Datensatz mit denselben Werten wie die Felder <code>user_id</code> und <code>characteristics</code> <code>user_id</code> , erh√§lt Transaktion B einen Fehler: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> product_deps (user_id, characteristics) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'{"same": "value"}'</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- Now it will block until first transaction will be finished ERROR: duplicate key value violates unique constraint "product_deps_user_id_characteristics_key" DETAIL: Key (user_id, characteristics)=(1, {"same": "value"}) already exists. -- And will throw an error when first transaction have commited and it is become clear that we have a conflict</span></span></code> </pre> <br><p>  Es gibt jedoch eine Funktion, die nicht vergessen werden sollte: Transaktion B wird nach dem Erkennen eines Fehlers automatisch abgebrochen und alle darin ausgef√ºhrten Arbeiten werden den Bach runtergehen.  Diese Transaktion <strong>ist jedoch immer noch</strong> in einem "fehlerhaften" Zustand <strong>ge√∂ffnet.</strong> Bei jedem Versuch, eine selbst harmloseste Anforderung auszuf√ºhren, werden jedoch nur Fehler als Antwort zur√ºckgegeben: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> products; ERROR: current transaction is aborted, commands ignored until <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">block</span></span></code> </pre> <br><p>  Es ist v√∂llig unn√∂tig zu sagen, dass alles, was bei dieser Transaktion in die Datenbank eingegeben wurde, nicht gespeichert wird: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--      ,   ROLLBACK --          </span></span></code> </pre> <br><p>  <strong>Problem drei: Stille</strong> </p><br><p>  Zu diesem Zeitpunkt war bereits klar, dass das einfache Hinzuf√ºgen von Transaktionen zur Anwendung sie brach.  Es gab keine Wahl: Ich musste in den Importcode eintauchen.  Im Code fielen mir oft folgende Muster auf: </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_stuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment"># ,   rescue StandardError nil #  ,  end</span></span></code> </pre> <br><p>  Der Code-Autor hier sagt uns: "Wir haben es versucht, es ist uns nicht gelungen, aber es ist okay, wir machen ohne weiter."  Und obwohl die Gr√ºnde f√ºr diese Auswahl durchaus erkl√§rbar sein k√∂nnen (nicht alles kann auf Anwendungsebene verarbeitet werden), macht dies eine auf Transaktionen basierende Logik unm√∂glich: Eine verworfene Ausf√ºhrung kann nicht zum <code>transaction</code> schweben und f√ºhrt nicht zu einem korrekten Rollback Transaktionen (ActiveRecord f√§ngt alle Fehler in diesem Block ab, setzt die Transaktion zur√ºck und wirft sie erneut aus). </p><br><h2 id="idealnyy-shtorm">  Perfekter Sturm </h2><br><p>  Und so kamen alle drei Faktoren zusammen, um das Perfekte zu schaffen <del>  der Sturm </del>  Fehler: </p><br><ul><li>  Eine Anwendung in einer Transaktion versucht, einen widerspr√ºchlichen Datensatz in die Datenbank einzuf√ºgen, und verursacht einen "doppelten Schl√ºssel" -Fehler von PostgreSQL.  Dieser Fehler f√ºhrt jedoch nicht dazu, dass die Transaktion in der Anwendung zur√ºckgesetzt wird, da sie in einem der Teile der Anwendung "vertuscht" wird. </li><li>  Die Transaktion wird ung√ºltig, aber die Anwendung wei√ü nichts davon und arbeitet weiter.  Bei jedem Versuch, auf die Datenbank zuzugreifen, erh√§lt die Anwendung erneut einen Fehler. Diesmal wird "aktuelle Transaktion abgebrochen". Dieser Fehler kann jedoch auch verworfen werden ... </li><li>  Sie haben wahrscheinlich bereits verstanden, dass etwas in der Anwendung weiterhin kaputt geht, aber niemand wird davon erfahren, bis die Ausf√ºhrung den ersten Punkt erreicht hat, an dem es keine √ºberm√§√üig gierige <code>rescue</code> und an dem der Fehler m√∂glicherweise auftaucht, protokolliert wird. im Fehler-Tracker registriert - alles.  Aber dieser Ort wird bereits sehr weit von dem Ort entfernt sein, der zur Hauptursache des Fehlers wurde, und dies allein wird das Debuggen zu einem Albtraum machen. </li></ul><br><h2 id="alternativa-tranzakcionnym-blokirovkam-v-postgresql">  Alternative zu Transaktionssperren in PostgreSQL </h2><br><p>  Die Suche nach <code>rescue</code> im Anwendungscode und das Umschreiben der gesamten Importlogik ist keine Option.  Eine lange Zeit.  Ich brauchte eine schnelle L√∂sung und fand sie bei den Postgres!  Es verf√ºgt √ºber eine integrierte L√∂sung f√ºr Sperren, eine Alternative zum Sperren von Datens√§tzen in Transaktionen und Sperren f√ºr Besprechungsempfehlungen.  Ich habe sie wie folgt benutzt: </p><br><p>  Zuerst habe ich zuerst die Wrapping-Transaktion entfernt.  In jedem Fall ist die Interaktion mit externen APIs (oder anderen ‚ÄûNebenwirkungen‚Äú) aus dem Anwendungscode mit einer offenen Transaktion eine schlechte Idee, denn selbst wenn Sie die Transaktion zusammen mit allen √Ñnderungen in unserer Datenbank zur√ºcksetzen, bleiben die √Ñnderungen in externen Systemen erhalten und die Anwendung als Ganzes kann sich in einem seltsamen und unerw√ºnschten Zustand befinden.  Mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolator-Juwel</a> k√∂nnen Sie sicherstellen, dass Nebenwirkungen ordnungsgem√§√ü von Transaktionen <em>isoliert</em> sind. </p><br><p>  Dann sperre ich bei jedem Importvorgang einen eindeutigen Schl√ºssel f√ºr den gesamten Import (z. B. erstellt aus der Benutzer-ID und dem Hash aus dem Namen der Operationsklasse): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock_shared(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id);</code> </pre> <br><p>  Gemeinsame Sperren f√ºr denselben Schl√ºssel k√∂nnen von einer beliebigen Anzahl von Sitzungen gleichzeitig ausgef√ºhrt werden. </p><br><p>  Durch das gleichzeitige Abbrechen des Importvorgangs werden alle Aufgabeneintr√§ge aus der Datenbank gel√∂scht und versucht, denselben Schl√ºssel <em>exklusiv zu</em> sperren.  In diesem Fall muss sie warten, bis alle freigegebenen Sperren freigegeben sind: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id)</code> </pre> <br><p>  Und das ist alles!  Jetzt wartet die "Stornierung", bis alle "laufenden" Importe einzelner Waren abgeschlossen sind. </p><br><p>  Da wir jetzt nicht durch eine Transaktion verbunden sind, k√∂nnen wir einen kleinen Hack verwenden, um die Wartezeit auf den Abbruch des Imports zu begrenzen (falls einige Importsticks "h√§ngen bleiben"), da es nicht gut ist, den Webserverfluss f√ºr eine lange Zeit zu blockieren (und zu erzwingen) auf Benutzer warten): </p><br><pre> <code class="ruby hljs">transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute(<span class="hljs-string"><span class="hljs-string">"SET LOCAL lock_timeout = '30s'"</span></span>) execute(<span class="hljs-string"><span class="hljs-string">"SELECT pg_advisory_lock(42, user.id)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rescue</span></span> ActiveRecord::LockWaitTimeout <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">#    (     ) end</span></span></code> </pre> <br><p>  Es ist sicher, einen Fehler <em>au√üerhalb</em> des <code>transaction</code> abzufangen, da <a href="">ActiveRecord die Transaktion bereits zur√ºcksetzt</a> . </p><br><h2 id="no-chto-delat-s-konkurentnoy-vstavkoy-odinakovyh-zapisey">  Aber was tun mit dem wettbewerbsf√§higen Einf√ºgen identischer Datens√§tze? </h2><br><p>  Leider kenne ich keine L√∂sung, die mit <em>wettbewerbsf√§higen</em> Beilagen gut funktionieren w√ºrde.  Es gibt die folgenden Ans√§tze, aber alle blockieren gleichzeitige Einf√ºgungen, bis die erste Transaktion abgeschlossen ist: </p><br><ul><li>  <code>INSERT ‚Ä¶ ON CONFLICT UPDATE</code> (verf√ºgbar seit PostgreSQL 9.5) in der zweiten Transaktion wird blockiert, bis die erste Transaktion abgeschlossen ist, und gibt dann den Datensatz zur√ºck, der von der ersten Transaktion eingef√ºgt wurde. </li><li>  Sperren Sie einen allgemeinen Datensatz in einer Transaktion, bevor Sie √úberpr√ºfungen ausf√ºhren, um einen neuen Datensatz einzuf√ºgen.  Hier warten wir, bis der in eine andere Transaktion eingef√ºgte Datensatz sichtbar ist und die Validierungen nicht vollst√§ndig funktionieren k√∂nnen. </li><li>  Nehmen Sie eine Art allgemeine Empfehlungssperre - der Effekt ist der gleiche wie beim Blockieren eines allgemeinen Datensatzes. </li></ul><br><p>  Wenn Sie keine Angst haben, mit Fehlern auf Basisebene zu arbeiten, k√∂nnen Sie einfach den Eindeutigkeitsfehler abfangen: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import_all_the_things</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#   ,   Dep.create(user_id, chars) rescue ActiveRecord::RecordNotUnique retry end</span></span></span></span></code> </pre> <br><p>  Stellen Sie einfach sicher, dass dieser Code nicht mehr in eine Transaktion eingeschlossen ist. </p><br><blockquote>  Warum sind sie blockiert? <br><br>  Die Einschr√§nkungen UNIQUE und EXCLUDE blockieren <em>potenzielle Konflikte, indem sie</em> verhindern, dass sie gleichzeitig aufgezeichnet werden.  Wenn Sie beispielsweise eine eindeutige Einschr√§nkung f√ºr eine Ganzzahlspalte haben und eine Transaktion eine Zeile mit dem Wert 5 einf√ºgt, werden andere Transaktionen, die ebenfalls versuchen, 5 einzuf√ºgen, blockiert, aber Transaktionen, die versuchen, 6 oder 4 einzuf√ºgen, werden sofort erfolgreich, ohne zu blockieren.  Da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die tats√§chliche tats√§chliche Transaktionsisolationsstufe von PostgreSQL</a> <code>READ COMMITED</code> , ist eine Transaktion nicht berechtigt, nicht <code>READ COMMITED</code> √Ñnderungen von anderen Transaktionen <code>READ COMMITED</code> .  Daher kann ein <code>INSERT</code> mit einem widerspr√ºchlichen Wert erst akzeptiert oder abgelehnt werden, wenn die erste Transaktion ihre √Ñnderungen festschreibt (dann erh√§lt die zweite einen Eindeutigkeitsfehler) oder zur√ºckgesetzt wird (dann ist das Einf√ºgen in die zweite Transaktion erfolgreich).  Lesen Sie mehr dar√ºber in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel des Autors von EXCLUDE-Einschr√§nkungen</a> . </blockquote><br><h2 id="predotvraschaem-katastrofu-v-buduschem">  Verhindern Sie zuk√ºnftige Katastrophen </h2><br><p>  <em>Jetzt</em> wissen Sie, dass nicht der gesamte Code in eine Transaktion eingeschlossen werden kann.  Es w√§re sch√∂n sicherzustellen, dass in Zukunft niemand mehr solchen Code in eine Transaktion einbindet und meinen Fehler wiederholt. </p><br><p>  Zu diesem Zweck k√∂nnen Sie alle Ihre Vorg√§nge in ein kleines Hilfsmodul einschlie√üen, das pr√ºft, ob die Transaktion ge√∂ffnet ist, bevor der umschlossene Vorgangscode ausgef√ºhrt wird (hier wird davon ausgegangen, dass alle Ihre Vorg√§nge dieselbe Schnittstelle haben - die <code>call</code> ). </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#     module NoTransactionAllowed class InTransactionError &lt; RuntimeError; end def call(*) return super unless in_transaction? raise InTransactionError, "#{self.class.name} doesn't work reliably within a DB transaction" end def in_transaction? connection = ApplicationRecord.connection # service transactions (tests and database_cleaner) are not joinable connection.transaction_open? &amp;&amp; connection.current_transaction.joinable? end end #    class Deps::Import &lt; BaseService prepend NoTransactionAllowed def call do_import rescue ActiveRecord::RecordNotUnique retry end end</span></span></code> </pre> <br><p>  Wenn jemand versucht, einen <em>gef√§hrlichen</em> Dienst in eine Transaktion einzubinden, erh√§lt er sofort einen Fehler (es sei denn, er schweigt nat√ºrlich). </p><br><h2 id="itogi">  Zusammenfassung </h2><br><p>  Die wichtigste Lektion, die gelernt werden muss: Seien Sie mit Ausnahmen vorsichtig.  Behandeln Sie nicht alles hintereinander, sondern fangen Sie nur die Ausnahmen ab, mit denen Sie umgehen k√∂nnen, und lassen Sie den Rest in die Protokolle gelangen.  Ignorieren Sie niemals Ausnahmen (nur wenn Sie nicht 100% sicher sind, warum Sie dies tun).  Je fr√ºher ein Fehler bemerkt wird, desto einfacher ist das Debuggen. </p><br><p>  Und √ºbertreiben Sie es nicht mit Transaktionen in der Datenbank.  Dies ist kein Allheilmittel.  Verwenden Sie unseren Edelsteinisolator und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">after_commit_everywhere</a> - damit Ihre Transaktionen absolut kinderleicht werden. </p><br><h2 id="chto-pochitat">  Was zu lesen </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Au√üergew√∂hnlicher Rubin</em></a> <em>von Avdi Grimm</em> .  In diesem kurzen Buch erfahren Sie, wie Sie mit vorhandenen Ausnahmen in Ruby umgehen und ein Ausnahmesystem f√ºr Ihre Anwendung richtig entwerfen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://brandur.org/"><em>Verwenden</em></a> von Atomtransaktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://brandur.org/"><em>zur Stromversorgung einer Idempotenten API</em></a> von @Brandur.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sein Blog enth√§lt</a> viele n√ºtzliche Artikel √ºber Anwendungszuverl√§ssigkeit, Ruby und PostgreSQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418147/">https://habr.com/ru/post/de418147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418137/index.html">Bloodlust: Interview mit dem Gr√ºnder von DonorSearch</a></li>
<li><a href="../de418139/index.html">Numerische L√∂sung mathematischer Modelle von Objekten, die durch Differentialgleichungssysteme gegeben sind</a></li>
<li><a href="../de418141/index.html">RE: Ghat / AFR Anf√§nger Skipper Race</a></li>
<li><a href="../de418143/index.html">PVS-Studio als SAST-L√∂sung</a></li>
<li><a href="../de418145/index.html">Die erste Klage gegen Roskomnadzor von einem Unternehmen, das unter der Sperrung von Telegram litt</a></li>
<li><a href="../de418149/index.html">Phishing mit Titel-Tag</a></li>
<li><a href="../de418153/index.html">Kolesa Android Meetup Video: Informationen zu MVVM, Antipatterns und modularer Entwicklung</a></li>
<li><a href="../de418155/index.html">Diode LED Zenerdiode</a></li>
<li><a href="../de418159/index.html">Wohin zum Designer: renommierte Auszeichnungen f√ºr Russland, Osteuropa und die GUS-Staaten</a></li>
<li><a href="../de418161/index.html">In Stanford entwickelten sich Streaming-Batterien f√ºr Raumtemperatur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>