<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🚒 🈸 👍🏾 Schweigen von Ruby-Ausführungen: Transactional Rails / PostgreSQL-Thriller 🙆🏿 🚧 👨‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist eine Geschichte darüber, warum Sie Fehler niemals ignorieren sollten , wenn Sie sich in einer Transaktion in einer Datenbank befinden. Es ist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schweigen von Ruby-Ausführungen: Transactional Rails / PostgreSQL-Thriller</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418147/"><p>  <em>Dies ist eine Geschichte darüber, warum Sie Fehler <strong>niemals</strong> ignorieren <strong>sollten</strong> , wenn Sie sich in einer Transaktion in einer Datenbank befinden.</em>  <em>Es ist keine Option, herauszufinden, wie Transaktionen richtig verwendet werden und was zu tun ist, wenn sie verwendet werden.</em>  <em>Spoiler: Es geht um Beratungssperren in PostgreSQL!</em> </p><br><p> Ich habe an einem Projekt gearbeitet, in dem Benutzer eine große Anzahl schwerer Entitäten (nennen wir sie Produkte) von einem externen Dienst in unsere Anwendung importieren können.  Für jedes Produkt werden noch vielfältigere Daten von externen APIs geladen.  Es ist nicht ungewöhnlich, dass ein Benutzer Hunderte von Produkten zusammen mit allen Abhängigkeiten lädt. Daher dauert der Import eines Produkts spürbar (30 bis 60 Sekunden), und der gesamte Vorgang kann lange dauern.  Der Benutzer kann es leid sein, auf das Ergebnis zu warten, und er hat das Recht, jederzeit auf die Schaltfläche "Abbrechen" zu klicken. Die Anwendung sollte für die Anzahl der Produkte nützlich sein, die zu diesem Zeitpunkt heruntergeladen werden konnten. </p><a name="habracut"></a><br><p>  Der „unterbrochene Import“ wird wie folgt implementiert: Zu Beginn wird für jedes Produkt ein temporärer Aufgabendatensatz auf dem Typenschild in der Datenbank erstellt.  Für jedes Produkt wird eine Hintergrundimportaufgabe gestartet, die das Produkt herunterlädt, zusammen mit allen Abhängigkeiten in der Datenbank speichert (alles im Allgemeinen erledigt) und ganz am Ende seinen Aufgabendatensatz löscht.  Wenn zum Zeitpunkt des Starts der Hintergrundaufgabe kein Datensatz in der Datenbank vorhanden ist, wird die Aufgabe einfach stillschweigend beendet.  Um den Import abzubrechen, reicht es also aus, einfach alle Aufgaben zu löschen und fertig. </p><br><p>  Es spielt keine Rolle, ob der Import vom Benutzer abgebrochen oder vollständig von ihm selbst abgeschlossen wurde. In jedem Fall bedeutet das Fehlen von Aufgaben, dass alles vorbei ist und der Benutzer die Anwendung verwenden kann. </p><br><p>  Das Design ist einfach und zuverlässig, aber es gab einen kleinen Fehler.  Ein typischer Fehlerbericht über ihn lautete: „Nachdem der Import abgebrochen wurde, wird dem Benutzer eine Liste seiner Waren angezeigt.  Wenn Sie die Seite jedoch aktualisieren, wird die Liste der Produkte durch mehrere Einträge ergänzt. "  Der Grund für dieses Verhalten ist einfach: Wenn der Benutzer auf die Schaltfläche "Abbrechen" klickte, wurde er sofort in die Liste aller Produkte übernommen.  Zu diesem Zeitpunkt laufen jedoch bereits begonnene Importe bestimmter Waren noch. </p><br><p>  Dies ist natürlich eine Kleinigkeit, aber die Benutzer waren von der Bestellung verwirrt, daher wäre es schön, sie zu beheben.  Ich hatte zwei Möglichkeiten: bereits laufende Aufgaben irgendwie zu identifizieren und zu "töten" oder, wenn ich auf die Schaltfläche "Abbrechen" klicke, zu warten, bis sie abgeschlossen sind, und "ihren eigenen Tod zu sterben", bevor ich den Benutzer weiter übertrage.  Ich entschied mich für den zweiten Weg - zu warten. </p><br><h2 id="tranzakcionnye-blokirovki-speshat-na-pomosch">  Transaktionssperren eilen zur Rettung </h2><br><p>  Für alle, die mit (relationalen) Datenbanken arbeiten, liegt die Antwort auf der Hand: Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transaktionen</a> ! </p><br><p> Es ist wichtig zu beachten, dass in den meisten RDBMS Datensätze, die innerhalb einer Transaktion aktualisiert wurden, <em>blockiert werden</em> und für Änderungen durch andere Prozesse nicht zugänglich sind, bis diese Transaktion abgeschlossen ist.  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>SELECT FOR UPDATE</code></a> ausgewählte Datensätze werden ebenfalls gesperrt. </p><br><p>  Genau unser Fall!  Ich habe die Aufgabe des Imports einzelner Waren in eine Transaktion verpackt und den Aufgabendatensatz ganz am Anfang blockiert: </p><br><pre> <code class="ruby hljs">ActiveRecord::Base.transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> task = Import::Task.lock.find_by(<span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> id) <span class="hljs-comment"><span class="hljs-comment"># SELECT … FOR UPDATE  «    » return unless task #  - ? ,    ! #     task.destroy end</span></span></code> </pre> <br><p>  Wenn der Benutzer den Import abbrechen möchte, löscht der Importstopp die Aufgaben für die noch nicht gestarteten Importe und muss auf den Abschluss der bereits vorhandenen warten: </p><br><pre> <code class="ruby hljs">user.import_tasks.delete_all <span class="hljs-comment"><span class="hljs-comment">#       </span></span></code> </pre> <br><p>  Einfach und elegant!  Ich habe die Tests durchgeführt, den Import lokal und bei der Bereitstellung überprüft und "in den Kampf" eingesetzt. </p><br><h2 id="ne-tak-bystro">  Nicht so schnell… </h2><br><p>  Zufrieden mit meiner Arbeit war ich sehr überrascht, bald Fehlerberichte und Unmengen von Fehlern in den Protokollen zu finden.  Viele Produkte wurden überhaupt nicht importiert.  In einigen Fällen konnte nach Abschluss aller Importe nur noch ein einziges Produkt übrig bleiben. </p><br><p>  Fehler in den Protokollen waren ebenfalls nicht ermutigend: <code>PG::InFailedSqlTransaction</code> mit einem Backtrack, der zu dem Code führte, der die unschuldigen <code>PG::InFailedSqlTransaction</code> ausführte.  Was ist überhaupt los? </p><br><p>  Nach einem Tag anstrengenden Debuggens habe ich drei Hauptursachen für die Probleme identifiziert: </p><br><ol><li>  Wettbewerbsfähiges Einfügen widersprüchlicher Datensätze in die Datenbank. </li><li>  Automatische Transaktionsstornierung in PostgreSQL nach Fehlern. </li><li>  Schweigen von Problemen (Ruby-Ausnahmen) im Anwendungscode. </li></ol><br><p>  <strong>Problem Eins: Wettbewerbsorientiertes Einfügen von widersprüchlichen Einträgen</strong> </p><br><p>  Da jeder Importvorgang bis zu einer Minute dauert und es viele dieser Aufgaben gibt, führen wir sie parallel aus, um Zeit zu sparen.  Abhängige Warendatensätze können sich überschneiden, sofern sich alle Produkte des Benutzers auf einen einzigen Datensatz beziehen können, der einmal erstellt und dann wiederverwendet wird. </p><br><p>  Es gibt Überprüfungen, um dieselben Abhängigkeiten im Anwendungscode zu finden und wiederzuverwenden. <em>Wenn wir jedoch Transaktionen verwenden, sind diese Überprüfungen unbrauchbar geworden</em> : Wenn Transaktion A einen abhängigen Datensatz erstellt hat <em>, dieser</em> jedoch noch nicht abgeschlossen wurde, kann Transaktion B seine Existenz nicht herausfinden und versucht, ein Duplikat zu erstellen aufnehmen. </p><br><p>  <strong>Problem 2: Automatische Transaktionsstornierung von PostgreSQL nach Fehlern</strong> </p><br><p>  Natürlich haben wir die Erstellung doppelter Aufgaben auf Datenbankebene mithilfe der folgenden DDL verhindert: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> product_deps <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> (user_id, characteristics);</code> </pre> <br><p>  Wenn eine laufende Transaktion A einen neuen Datensatz einfügt und Transaktion B versucht, einen Datensatz mit denselben Werten wie die Felder <code>user_id</code> und <code>characteristics</code> <code>user_id</code> , erhält Transaktion B einen Fehler: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> product_deps (user_id, characteristics) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'{"same": "value"}'</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- Now it will block until first transaction will be finished ERROR: duplicate key value violates unique constraint "product_deps_user_id_characteristics_key" DETAIL: Key (user_id, characteristics)=(1, {"same": "value"}) already exists. -- And will throw an error when first transaction have commited and it is become clear that we have a conflict</span></span></code> </pre> <br><p>  Es gibt jedoch eine Funktion, die nicht vergessen werden sollte: Transaktion B wird nach dem Erkennen eines Fehlers automatisch abgebrochen und alle darin ausgeführten Arbeiten werden den Bach runtergehen.  Diese Transaktion <strong>ist jedoch immer noch</strong> in einem "fehlerhaften" Zustand <strong>geöffnet.</strong> Bei jedem Versuch, eine selbst harmloseste Anforderung auszuführen, werden jedoch nur Fehler als Antwort zurückgegeben: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> products; ERROR: current transaction is aborted, commands ignored until <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">block</span></span></code> </pre> <br><p>  Es ist völlig unnötig zu sagen, dass alles, was bei dieser Transaktion in die Datenbank eingegeben wurde, nicht gespeichert wird: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--      ,   ROLLBACK --          </span></span></code> </pre> <br><p>  <strong>Problem drei: Stille</strong> </p><br><p>  Zu diesem Zeitpunkt war bereits klar, dass das einfache Hinzufügen von Transaktionen zur Anwendung sie brach.  Es gab keine Wahl: Ich musste in den Importcode eintauchen.  Im Code fielen mir oft folgende Muster auf: </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_stuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment"># ,   rescue StandardError nil #  ,  end</span></span></code> </pre> <br><p>  Der Code-Autor hier sagt uns: "Wir haben es versucht, es ist uns nicht gelungen, aber es ist okay, wir machen ohne weiter."  Und obwohl die Gründe für diese Auswahl durchaus erklärbar sein können (nicht alles kann auf Anwendungsebene verarbeitet werden), macht dies eine auf Transaktionen basierende Logik unmöglich: Eine verworfene Ausführung kann nicht zum <code>transaction</code> schweben und führt nicht zu einem korrekten Rollback Transaktionen (ActiveRecord fängt alle Fehler in diesem Block ab, setzt die Transaktion zurück und wirft sie erneut aus). </p><br><h2 id="idealnyy-shtorm">  Perfekter Sturm </h2><br><p>  Und so kamen alle drei Faktoren zusammen, um das Perfekte zu schaffen <del>  der Sturm </del>  Fehler: </p><br><ul><li>  Eine Anwendung in einer Transaktion versucht, einen widersprüchlichen Datensatz in die Datenbank einzufügen, und verursacht einen "doppelten Schlüssel" -Fehler von PostgreSQL.  Dieser Fehler führt jedoch nicht dazu, dass die Transaktion in der Anwendung zurückgesetzt wird, da sie in einem der Teile der Anwendung "vertuscht" wird. </li><li>  Die Transaktion wird ungültig, aber die Anwendung weiß nichts davon und arbeitet weiter.  Bei jedem Versuch, auf die Datenbank zuzugreifen, erhält die Anwendung erneut einen Fehler. Diesmal wird "aktuelle Transaktion abgebrochen". Dieser Fehler kann jedoch auch verworfen werden ... </li><li>  Sie haben wahrscheinlich bereits verstanden, dass etwas in der Anwendung weiterhin kaputt geht, aber niemand wird davon erfahren, bis die Ausführung den ersten Punkt erreicht hat, an dem es keine übermäßig gierige <code>rescue</code> und an dem der Fehler möglicherweise auftaucht, protokolliert wird. im Fehler-Tracker registriert - alles.  Aber dieser Ort wird bereits sehr weit von dem Ort entfernt sein, der zur Hauptursache des Fehlers wurde, und dies allein wird das Debuggen zu einem Albtraum machen. </li></ul><br><h2 id="alternativa-tranzakcionnym-blokirovkam-v-postgresql">  Alternative zu Transaktionssperren in PostgreSQL </h2><br><p>  Die Suche nach <code>rescue</code> im Anwendungscode und das Umschreiben der gesamten Importlogik ist keine Option.  Eine lange Zeit.  Ich brauchte eine schnelle Lösung und fand sie bei den Postgres!  Es verfügt über eine integrierte Lösung für Sperren, eine Alternative zum Sperren von Datensätzen in Transaktionen und Sperren für Besprechungsempfehlungen.  Ich habe sie wie folgt benutzt: </p><br><p>  Zuerst habe ich zuerst die Wrapping-Transaktion entfernt.  In jedem Fall ist die Interaktion mit externen APIs (oder anderen „Nebenwirkungen“) aus dem Anwendungscode mit einer offenen Transaktion eine schlechte Idee, denn selbst wenn Sie die Transaktion zusammen mit allen Änderungen in unserer Datenbank zurücksetzen, bleiben die Änderungen in externen Systemen erhalten und die Anwendung als Ganzes kann sich in einem seltsamen und unerwünschten Zustand befinden.  Mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolator-Juwel</a> können Sie sicherstellen, dass Nebenwirkungen ordnungsgemäß von Transaktionen <em>isoliert</em> sind. </p><br><p>  Dann sperre ich bei jedem Importvorgang einen eindeutigen Schlüssel für den gesamten Import (z. B. erstellt aus der Benutzer-ID und dem Hash aus dem Namen der Operationsklasse): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock_shared(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id);</code> </pre> <br><p>  Gemeinsame Sperren für denselben Schlüssel können von einer beliebigen Anzahl von Sitzungen gleichzeitig ausgeführt werden. </p><br><p>  Durch das gleichzeitige Abbrechen des Importvorgangs werden alle Aufgabeneinträge aus der Datenbank gelöscht und versucht, denselben Schlüssel <em>exklusiv zu</em> sperren.  In diesem Fall muss sie warten, bis alle freigegebenen Sperren freigegeben sind: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id)</code> </pre> <br><p>  Und das ist alles!  Jetzt wartet die "Stornierung", bis alle "laufenden" Importe einzelner Waren abgeschlossen sind. </p><br><p>  Da wir jetzt nicht durch eine Transaktion verbunden sind, können wir einen kleinen Hack verwenden, um die Wartezeit auf den Abbruch des Imports zu begrenzen (falls einige Importsticks "hängen bleiben"), da es nicht gut ist, den Webserverfluss für eine lange Zeit zu blockieren (und zu erzwingen) auf Benutzer warten): </p><br><pre> <code class="ruby hljs">transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute(<span class="hljs-string"><span class="hljs-string">"SET LOCAL lock_timeout = '30s'"</span></span>) execute(<span class="hljs-string"><span class="hljs-string">"SELECT pg_advisory_lock(42, user.id)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rescue</span></span> ActiveRecord::LockWaitTimeout <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">#    (     ) end</span></span></code> </pre> <br><p>  Es ist sicher, einen Fehler <em>außerhalb</em> des <code>transaction</code> abzufangen, da <a href="">ActiveRecord die Transaktion bereits zurücksetzt</a> . </p><br><h2 id="no-chto-delat-s-konkurentnoy-vstavkoy-odinakovyh-zapisey">  Aber was tun mit dem wettbewerbsfähigen Einfügen identischer Datensätze? </h2><br><p>  Leider kenne ich keine Lösung, die mit <em>wettbewerbsfähigen</em> Beilagen gut funktionieren würde.  Es gibt die folgenden Ansätze, aber alle blockieren gleichzeitige Einfügungen, bis die erste Transaktion abgeschlossen ist: </p><br><ul><li>  <code>INSERT … ON CONFLICT UPDATE</code> (verfügbar seit PostgreSQL 9.5) in der zweiten Transaktion wird blockiert, bis die erste Transaktion abgeschlossen ist, und gibt dann den Datensatz zurück, der von der ersten Transaktion eingefügt wurde. </li><li>  Sperren Sie einen allgemeinen Datensatz in einer Transaktion, bevor Sie Überprüfungen ausführen, um einen neuen Datensatz einzufügen.  Hier warten wir, bis der in eine andere Transaktion eingefügte Datensatz sichtbar ist und die Validierungen nicht vollständig funktionieren können. </li><li>  Nehmen Sie eine Art allgemeine Empfehlungssperre - der Effekt ist der gleiche wie beim Blockieren eines allgemeinen Datensatzes. </li></ul><br><p>  Wenn Sie keine Angst haben, mit Fehlern auf Basisebene zu arbeiten, können Sie einfach den Eindeutigkeitsfehler abfangen: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import_all_the_things</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#   ,   Dep.create(user_id, chars) rescue ActiveRecord::RecordNotUnique retry end</span></span></span></span></code> </pre> <br><p>  Stellen Sie einfach sicher, dass dieser Code nicht mehr in eine Transaktion eingeschlossen ist. </p><br><blockquote>  Warum sind sie blockiert? <br><br>  Die Einschränkungen UNIQUE und EXCLUDE blockieren <em>potenzielle Konflikte, indem sie</em> verhindern, dass sie gleichzeitig aufgezeichnet werden.  Wenn Sie beispielsweise eine eindeutige Einschränkung für eine Ganzzahlspalte haben und eine Transaktion eine Zeile mit dem Wert 5 einfügt, werden andere Transaktionen, die ebenfalls versuchen, 5 einzufügen, blockiert, aber Transaktionen, die versuchen, 6 oder 4 einzufügen, werden sofort erfolgreich, ohne zu blockieren.  Da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die tatsächliche tatsächliche Transaktionsisolationsstufe von PostgreSQL</a> <code>READ COMMITED</code> , ist eine Transaktion nicht berechtigt, nicht <code>READ COMMITED</code> Änderungen von anderen Transaktionen <code>READ COMMITED</code> .  Daher kann ein <code>INSERT</code> mit einem widersprüchlichen Wert erst akzeptiert oder abgelehnt werden, wenn die erste Transaktion ihre Änderungen festschreibt (dann erhält die zweite einen Eindeutigkeitsfehler) oder zurückgesetzt wird (dann ist das Einfügen in die zweite Transaktion erfolgreich).  Lesen Sie mehr darüber in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel des Autors von EXCLUDE-Einschränkungen</a> . </blockquote><br><h2 id="predotvraschaem-katastrofu-v-buduschem">  Verhindern Sie zukünftige Katastrophen </h2><br><p>  <em>Jetzt</em> wissen Sie, dass nicht der gesamte Code in eine Transaktion eingeschlossen werden kann.  Es wäre schön sicherzustellen, dass in Zukunft niemand mehr solchen Code in eine Transaktion einbindet und meinen Fehler wiederholt. </p><br><p>  Zu diesem Zweck können Sie alle Ihre Vorgänge in ein kleines Hilfsmodul einschließen, das prüft, ob die Transaktion geöffnet ist, bevor der umschlossene Vorgangscode ausgeführt wird (hier wird davon ausgegangen, dass alle Ihre Vorgänge dieselbe Schnittstelle haben - die <code>call</code> ). </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#     module NoTransactionAllowed class InTransactionError &lt; RuntimeError; end def call(*) return super unless in_transaction? raise InTransactionError, "#{self.class.name} doesn't work reliably within a DB transaction" end def in_transaction? connection = ApplicationRecord.connection # service transactions (tests and database_cleaner) are not joinable connection.transaction_open? &amp;&amp; connection.current_transaction.joinable? end end #    class Deps::Import &lt; BaseService prepend NoTransactionAllowed def call do_import rescue ActiveRecord::RecordNotUnique retry end end</span></span></code> </pre> <br><p>  Wenn jemand versucht, einen <em>gefährlichen</em> Dienst in eine Transaktion einzubinden, erhält er sofort einen Fehler (es sei denn, er schweigt natürlich). </p><br><h2 id="itogi">  Zusammenfassung </h2><br><p>  Die wichtigste Lektion, die gelernt werden muss: Seien Sie mit Ausnahmen vorsichtig.  Behandeln Sie nicht alles hintereinander, sondern fangen Sie nur die Ausnahmen ab, mit denen Sie umgehen können, und lassen Sie den Rest in die Protokolle gelangen.  Ignorieren Sie niemals Ausnahmen (nur wenn Sie nicht 100% sicher sind, warum Sie dies tun).  Je früher ein Fehler bemerkt wird, desto einfacher ist das Debuggen. </p><br><p>  Und übertreiben Sie es nicht mit Transaktionen in der Datenbank.  Dies ist kein Allheilmittel.  Verwenden Sie unseren Edelsteinisolator und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">after_commit_everywhere</a> - damit Ihre Transaktionen absolut kinderleicht werden. </p><br><h2 id="chto-pochitat">  Was zu lesen </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Außergewöhnlicher Rubin</em></a> <em>von Avdi Grimm</em> .  In diesem kurzen Buch erfahren Sie, wie Sie mit vorhandenen Ausnahmen in Ruby umgehen und ein Ausnahmesystem für Ihre Anwendung richtig entwerfen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://brandur.org/"><em>Verwenden</em></a> von Atomtransaktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://brandur.org/"><em>zur Stromversorgung einer Idempotenten API</em></a> von @Brandur.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sein Blog enthält</a> viele nützliche Artikel über Anwendungszuverlässigkeit, Ruby und PostgreSQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418147/">https://habr.com/ru/post/de418147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418137/index.html">Bloodlust: Interview mit dem Gründer von DonorSearch</a></li>
<li><a href="../de418139/index.html">Numerische Lösung mathematischer Modelle von Objekten, die durch Differentialgleichungssysteme gegeben sind</a></li>
<li><a href="../de418141/index.html">RE: Ghat / AFR Anfänger Skipper Race</a></li>
<li><a href="../de418143/index.html">PVS-Studio als SAST-Lösung</a></li>
<li><a href="../de418145/index.html">Die erste Klage gegen Roskomnadzor von einem Unternehmen, das unter der Sperrung von Telegram litt</a></li>
<li><a href="../de418149/index.html">Phishing mit Titel-Tag</a></li>
<li><a href="../de418153/index.html">Kolesa Android Meetup Video: Informationen zu MVVM, Antipatterns und modularer Entwicklung</a></li>
<li><a href="../de418155/index.html">Diode LED Zenerdiode</a></li>
<li><a href="../de418159/index.html">Wohin zum Designer: renommierte Auszeichnungen für Russland, Osteuropa und die GUS-Staaten</a></li>
<li><a href="../de418161/index.html">In Stanford entwickelten sich Streaming-Batterien für Raumtemperatur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>