<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏿 👨🏿‍🤝‍👨🏽 🧘🏾 Wir schreiben unsere Programmiersprache, Teil 1: Wir schreiben eine Sprach-VM 🙉 🐝 🧖🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 Guten Tag an alle Habrachitateli! 

 Vielleicht ist es erwähnenswert, dass das Ziel meiner Arbeit, auf deren Grundlage eine Reihe von Sta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben unsere Programmiersprache, Teil 1: Wir schreiben eine Sprach-VM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435202/"><h3>  Einführung </h3><br>  Guten Tag an alle Habrachitateli! <br><br>  Vielleicht ist es erwähnenswert, dass das Ziel meiner Arbeit, auf deren Grundlage eine Reihe von Statuen geschrieben werden, darin bestand, selbst ein voll funktionsfähiges YP von 0 zu schaffen und dann mein Wissen, meine Best Practices und meine Erfahrungen mit den Interessierten zu teilen. <br><br>  Ich werde die Entstehung der Sprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschreiben</a> , die ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor hier beschrieben habe</a> . <br><br>  Er interessierte viele und provozierte eine hitzige Diskussion in den Kommentaren.  Daher ist das Thema für viele interessant. <br><br>  Ich denke, es lohnt sich, sofort Informationen über das Projekt zu veröffentlichen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Site</a> (wird etwas später mit Dokumentation gefüllt). <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> <br><br>  Um das Projekt selbst zu berühren und alles in Aktion zu sehen, ist es besser, das Repository herunterzuladen und alles aus dem Ordner bin auszuführen.  In der Veröffentlichung habe ich es nicht eilig, die neuesten Versionen der Sprache und Laufzeit hochzuladen, weil  Manchmal ist es einfach zu faul für mich, es zu tun. <br><br>  Ich kann in C / C ++ und Object Pascal codieren.  Ich habe das Projekt seitdem auf FPC geschrieben  Meiner Meinung nach ist diese Sprache viel einfacher und besser geeignet, um so zu schreiben.  Der zweite entscheidende Faktor war, dass FPC eine große Anzahl von Zielplattformen unterstützt und es möglich ist, ein Projekt für die gewünschte Plattform mit einem Minimum an Änderungen neu zu erstellen.  Wenn ich Object Pascal aus irgendeinem Grund nicht mag, beeile dich nicht, den Pfosten zu schließen und zu rennen, um Steine ​​auf den Kommentar zu werfen.  Diese Sprache ist sehr schön und intuitiv, aber ich werde nicht so viel Code bereitstellen.  Genau das, was Sie brauchen. <br><br>  Vielleicht beginne ich meine Geschichte. <br><a name="habracut"></a><br><h3>  Wir setzen uns Ziele </h3><br>  Zuallererst braucht jedes Projekt seine Ziele und TK, die in Zukunft umgesetzt werden müssen.  Es muss im Voraus entschieden werden, welche Art von Sprache erstellt wird, um die primäre VM dafür zu schreiben. <br><br>  Die wichtigsten Punkte, die die Weiterentwicklung meiner VM bestimmt haben, sind folgende: <br><br><ul><li>  Dynamisches Tippen und Typgießen.  Ich beschloss, ihre Unterstützung in der Entwicklungsphase der VM zu organisieren. </li><li>  Multithreading-Unterstützung.  Ich habe dieses Element im Voraus in diese Liste aufgenommen, um die Architektur der VM ordnungsgemäß zu entwerfen und die Unterstützung für Multithreading auf der Kernebene der VM und nicht später mit Krücken zu organisieren. </li><li>  Export externer Methoden.  Ohne dies wird die Sprache nutzlos sein.  Es sei denn, es in ein Projekt einzubetten. </li><li>  Zusammenstellung der Sprache (in eine einzige abstrakte ausführbare Datei).  Teilweise kompiliert oder interpretiert?  Viel hängt davon ab. </li><li>  Allgemeine VM-Architektur.  Wird der Stack oder das Register unsere VM sein?  Ich habe versucht, dies und das umzusetzen.  Ich habe eine gestapelte VM zur Unterstützung ausgewählt. </li><li>  Wie sehen Sie die Arbeit mit Variablen, Arrays, Strukturen?  Persönlich wollte ich in diesem Moment eine Sprache implementieren, in der fast alles an implizite Zeiger gebunden ist, da ein solcher Ansatz viel Speicherplatz sparen und das Leben des Entwicklers vereinfachen würde.  Wenn wir zulassen, dass etwas Großes an Methoden übergeben wird, wird automatisch nur ein Zeiger auf dieses große übertragen. </li></ul><br>  Daher habe ich die oben genannten Prioritäten ausgewählt und mit der Implementierung der virtuellen Sprachmaschine begonnen.  Das ist natürlich seltsam, normalerweise werden zuerst Parser / Übersetzer und dann VMs geschrieben.  Nun, ich habe begonnen, das Projekt in dieser Reihenfolge zu entwickeln, und ich werde es in der Reihenfolge, in der ich es entwickelt habe, weiter beschreiben. <br><br>  Ich muss sofort sagen, dass ich VM so eloquent wie möglich genannt habe - SVM (Stack-based Virtual Machine). <br><br><h3>  Beginnen wir mit der Implementierung der Variablenklasse </h3><br>  Anfangs habe ich einfach einen Variantentyp verwendet, weil er einfacher und schneller ist.  Es war eine Krücke, aber es stützte das Projekt und ermöglichte mir, die erste Version von VM und Sprache schnell zu implementieren.  Später setzte ich mich an den Code und schrieb eine Implementierung meiner „Variante“.  Im Wesentlichen müssen Sie eine Klasse schreiben, die einen Zeiger auf einen Wert im Speicher speichert. In meiner Implementierung ist dies <code>null/cardinal/int64/double/string/array</code> .  Man könnte die Eingabe von Groß- und Kleinschreibung verwenden, aber ich dachte, es wäre besser, die Art und Weise zu implementieren, wie ich sie implementiert habe. <br><br>  Bevor ich anfing, Klassencode zu schreiben, entschied ich mich, die Direktive {$ H +} sofort in den Modulheader einzufügen, um die Unterstützung von Zeichenfolgen in der zukünftigen Sprache flexibler zu gestalten. <br><blockquote>  P.S.  für diejenigen, die den Unterschied zwischen den Modi H- und H + FPC möglicherweise nicht kennen. <br><br>  Beim Zusammenstellen von Code im H-Modus werden Zeichenfolgen als Zeichenarray dargestellt.  Wenn H + - als Zeiger auf ein Stück Gedächtnis.  Im ersten Fall werden die Zeilen zunächst in der Länge festgelegt und standardmäßig auf 256 Zeichen begrenzt.  Im zweiten Fall sind die Zeilen dynamisch erweiterbar und es können viel mehr Zeichen eingepfercht werden.  Sie arbeiten etwas langsamer, aber funktionaler.  Mit H + können Sie Zeichenfolgen auch als Zeichenarray deklarieren, beispielsweise auf folgende Weise: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[<span class="hljs-number"><span class="hljs-number">256</span></span>];</code> </pre></blockquote>  Für den Anfang deklarieren wir Enum als Typ, den wir als bestimmtes Flag verwenden, um den Datentyp durch einen Zeiger zu bestimmen: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVMType = (svmtNull, svmtWord, svmtInt, svmtReal, svmtStr, svmtArr);</code> </pre><br>  Als nächstes beschreiben wir die Grundstruktur unseres Variablentyps und einige Methoden: <br><br><pre> <code class="delphi hljs"> TSVMMem = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> m_val: pointer; m_type: TSVMType; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> m_val := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; m_type := svmtNull; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Clear; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtNull: <span class="hljs-comment"><span class="hljs-comment">{ nop }</span></span>; svmtWord: Dispose(PCardinal(m_val)); svmtInt: Dispose(PInt64(m_val)); svmtReal: Dispose(PDouble(m_val)); svmtStr: Dispose(PString(m_val)); svmtArr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(PMemArray(m_val)^, <span class="hljs-number"><span class="hljs-number">0</span></span>); Dispose(PMemArray(m_val)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Die Klasse erbt nichts, daher können geerbte Aufrufe im Konstruktor und Destruktor weggelassen werden.  Ich werde auf die Inline-Richtlinie achten.  Es ist sicher besser, {$ inline on} zum Dateikopf hinzuzufügen.  Die aktive Verwendung in VMs erhöhte die Produktivität erheblich (Mb irgendwo um bis zu 15-20%!).  Sie teilt dem Compiler mit, dass der Hauptteil der Methode am besten an der Stelle ihres Aufrufs eingebettet ist.  Der Ausgabecode wird am Ende etwas größer sein, aber schneller arbeiten.  In diesem Fall ist die Verwendung von Inline ratsam. <br><br>  Ok, zu diesem Zeitpunkt haben wir das Fundament unserer Klasse heruntergespült.  Jetzt müssen wir eine Reihe von Setzern und Gettern (Setter &amp; Getter) in unserer Klasse beschreiben. <br><br>  Die Aufgabe besteht darin, einige Methoden zu schreiben, mit denen Sie die Werte aus unserer Klasse überfüllen und später zurückerhalten können. <br><br>  Lassen Sie uns zunächst die Zuweisung eines Werts für unsere Klasse herausfinden.  Zuerst können Sie einen verallgemeinerten Setter schreiben und dann für einzelne Datentypen: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value; t:TSVMType)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = t) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: PCardinal(m_val)^ := Cardinal(value); svmtInt: PInt64(m_val)^ := Int64(value); svmtReal: PDouble(m_val)^ := Double(value); svmtStr: PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := t; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PCardinal(m_val)); PCardinal(m_val)^ := Cardinal(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PInt64(m_val)); PInt64(m_val)^ := Int64(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PDouble(m_val)); PDouble(m_val)^ := Double(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PString(m_val)); PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value:cardinal)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = svmtWord) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PCardinal(m_val)^ := value <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := svmtWord; New(PCardinal(m_val)); PCardinal(m_val)^ := value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Jetzt können Sie Code für ein paar Getter schreiben: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetW</span></span></span><span class="hljs-function">:</span></span>cardinal; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: Result := PCardinal(m_val)^; svmtInt: Result := PInt64(m_val)^; svmtReal: Result := Trunc(PDouble(m_val)^); svmtStr: Result := StrToQWord(PString(m_val)^); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Ok, großartig, jetzt, da Sie eine Weile auf die IDE gestarrt und den Code für Setter und Getter begeistert eingegeben haben, stehen wir vor der Aufgabe, Unterstützung für unsere Art von mathematischen und logischen Operationen zu implementieren.  Als Beispiel werde ich die Implementierung der Additionsoperation geben: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m:TSVMMem)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetW(GetW + m.GetW); svmtInt: SetI(GetW + m.GetI); svmtReal: SetD(GetW + m.GetD); svmtStr: SetD(GetW + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetI(GetI + m.GetW); svmtInt: SetI(GetI + m.GetI); svmtReal: SetD(GetI + m.GetD); svmtStr: SetD(GetI + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetD(GetD + m.GetW); svmtInt: SetD(GetD + m.GetI); svmtReal: SetD(GetD + m.GetD); svmtStr: SetD(GetD + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetS(GetS + IntToStr(m.GetW)); svmtInt: SetS(GetS + IntToStr(m.GetI)); svmtReal: SetS(GetS + FloatToStr(m.GetD)); svmtStr: SetS(GetS + m.GetS); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Alles ist einfach.  Weitere Operationen können auf ähnliche Weise beschrieben werden, und jetzt ist unsere Klasse bereit. <br>  Für Arrays benötigen Sie natürlich noch einige Methoden, ein Beispiel für das Abrufen eines Elements per Index: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: cardinal; grabber:PGrabber)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtArr: Result := PMemArray(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TSVMMem.CreateFW(Ord(PString(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>])); grabber^.AddTask(Result); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Großartig.  Jetzt können wir weitermachen. <br><br><h3>  Wir realisieren einen Stapel </h3><br>  Nach einer Weile kam ich zu solchen Gedanken.  Der Stapel muss gleichzeitig statisch (aus Gründen der Geschwindigkeit) und dynamisch (aus Gründen der Flexibilität) sein. <br><br>  Daher ist der Stapel in Blöcken implementiert.  Das heißt,  wie es funktionieren sollte - anfangs hat das Array des Stapels eine bestimmte Größe (ich habe beschlossen, die Blockgröße auf 256 Elemente festzulegen, damit es schön und nicht klein ist).  Dementsprechend ist ein Array in dem Array enthalten, das die aktuelle Oberseite des Stapels anzeigt.  Die Neuzuweisung von Speicher ist eine besonders lange Operation, die weniger häufig ausgeführt werden kann.  Wenn mehr Werte auf den Stapel verschoben werden, kann seine Größe immer auf die Größe eines anderen Blocks erweitert werden. <br><br>  Ich bringe die gesamte Stack-Implementierung mit: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TStack = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> items: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pointer; size, i_pos: cardinal; parent_vm: pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PStack = ^TStack; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; size := StackBlockSize; parent_vm := vm; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> items[i_pos] := p; inc(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i_pos &gt;= size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size + StackBlockSize; SetLength(items, size) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); Result := items[i_pos]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p := items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>] := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>] := p; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); size := StackBlockSize; i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Bei externen Methoden übergibt die VM einen Zeiger auf den Stapel, damit sie die erforderlichen Argumente von dort übernehmen kann.  Ein Zeiger auf den VM-Stream wurde später hinzugefügt, damit Rückrufaufrufe von externen Methoden implementiert werden können und im Allgemeinen mehr Leistung über VM-Methoden übertragen werden kann. <br><br>  Also, wie Sie sich mit der Anordnung des Stapels vertraut gemacht haben.  Der Rückrufstapel ist auf die gleiche Weise angeordnet, um die Call &amp; Return-Operationen und den Garbage Collector-Stapel zu vereinfachen und zu vereinfachen.  Das einzige, was ist die anderen Größen der Blöcke. <br><br><h3>  Sprechen Sie über Müll </h3><br>  Es ist normalerweise viel, viel.  Und du musst etwas damit anfangen. <br><br>  Zunächst möchte ich darüber sprechen, wie Garbage Collectors in anderen Sprachen angeordnet sind, z. B. in Lua, Ruby, Java, Perl, PHP usw.  Sie arbeiten nach dem Prinzip, Zeiger auf Objekte im Speicher zu zählen. <br><br>  Das heißt,  Es ist also logisch, dass wir Speicher für etwas zugewiesen haben. Der Zeiger wurde sofort in einer Variablen / einem Array / an einer anderen Stelle platziert.  Der Laufzeit-Garbage-Collector fügt diesen Zeiger sofort mit einer Liste möglicher Garbage-Objekte zu sich selbst hinzu.  Im Hintergrund überwacht der Garbage Collector ständig alle Variablen, Arrays usw.  Wenn es keinen Zeiger auf etwas aus der Liste des möglichen Mülls gibt, bedeutet dies, dass Müll und Speicher darunter entfernt werden müssen. <br><br>  Ich habe beschlossen, mein Fahrrad zu verkaufen.  Ich bin eher daran gewöhnt, mit dem Gedächtnis nach dem Prinzip von Taras Bulba zu arbeiten.  Ich habe dich geboren - ich werde dich töten, ich meine, wenn ich den nächsten Freien in der nächsten Klasse rufe.  Daher ist der Garbage Collector meiner VM halbautomatisch.  Das heißt,  Es muss im manuellen Modus aufgerufen werden und entsprechend damit arbeiten.  In seinem Zug werden Zeiger auf deklarierte temporäre Objekte hinzugefügt (diese Rolle liegt hauptsächlich beim Übersetzer und ein wenig beim Entwickler).  Um Speicher unter anderen Objekten freizugeben, können Sie einen separaten Opcode verwenden. <br><br>  Das heißt,  Der Garbage Collector verfügt zum Zeitpunkt des Aufrufs über eine vorgefertigte Liste von Zeigern, die Sie benötigen, um Speicherplatz freizugeben. <br><br><h3>  Nun beschäftigen wir uns mit der Kompilierung in eine abstrakte ausführbare Datei </h3><br>  Die Idee war ursprünglich, dass Anwendungen, die in meiner Sprache geschrieben wurden, ohne Quelle ausgeführt werden können, wie dies bei vielen ähnlichen Sprachen der Fall ist.  Das heißt,  es kann für kommerzielle Zwecke verwendet werden. <br><br>  Bestimmen Sie dazu das Format der ausführbaren Dateien.  Ich habe folgendes bekommen: <br><br><ol><li>  Header, zum Beispiel "SVMEXE_CNS". </li><li>  Ein Abschnitt mit einer Liste von Bibliotheken, aus denen Methoden importiert werden. </li><li>  Der Importabschnitt der erforderlichen Methoden, die Bibliotheken, aus denen die Methoden importiert werden, werden durch ihre Nummer im obigen Abschnitt angegeben. </li><li>  Abschnitt der Konstanten. </li><li>  Codeabschnitt </li></ol><br>  Ich denke nicht, dass es sich lohnt, die detaillierten Schritte zum Implementieren von Parsern für diese Abschnitte darzulegen, da Sie alles in meinem Repository selbst sehen können. <br><br><h3>  Codeausführung </h3><br>  Nachdem wir die obigen Abschnitte analysiert und die VM initialisiert haben, haben wir einen Abschnitt mit dem Code.  In meiner VM wird ein nicht ausgerichteter Bytecode ausgeführt, d. H.  Anweisungen können beliebig lang sein. <br><br>  Eine Reihe von Opcodes - Anweisungen für eine virtuelle Maschine mit kleinen Kommentaren, die ich im Voraus unten zeige: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TComand = ( <span class="hljs-comment"><span class="hljs-comment">{** for stack **}</span></span> bcPH, <span class="hljs-comment"><span class="hljs-comment">// [top] = [var] bcPK, // [var] = [top] bcPP, // pop bcSDP, // stkdrop bcSWP, // [top] &lt;-&gt; [top-1] {** jump's **} bcJP, // jump [top] bcJZ, // [top] == 0 ? jp [top-1] bcJN, // [top] &lt;&gt; 0 ? jp [top-1] bcJC, // jp [top] &amp; push callback point as ip+1 bcJR, // jp to last callback point &amp; rem last callback point {** for untyped's **} bcEQ, // [top] == [top-1] ? [top] = 1 : [top] = 0 bcBG, // [top] &gt; [top-1] ? [top] = 1 : [top] = 0 bcBE, // [top] &gt;= [top-1] ? [top] = 1 : [top] = 0 bcNOT, // [top] = ![top] bcAND, // [top] = [top] and [top-1] bcOR, // [top] = [top] or [top-1] bcXOR, // [top] = [top] xor [top-1] bcSHR, // [top] = [top] shr [top-1] bcSHL, // [top] = [top] shl [top-1] bcNEG, // [top] = -[top] bcINC, // [top]++ bcDEC, // [top]-- bcADD, // [top] = [top] + [top-1] bcSUB, // [top] = [top] - [top-1] bcMUL, // [top] = [top] * [top-1] bcDIV, // [top] = [top] / [top-1] bcMOD, // [top] = [top] % [top-1] bcIDIV, // [top] = [top] \ [top-1] bcMV, // [top]^ = [top-1]^ bcMVBP, // [top]^^ = [top-1]^ bcGVBP, // [top]^ = [top-1]^^ bcMVP, // [top]^ = [top-1] {** memory operation's **} bcMS, // memory map size = [top] bcNW, // [top] = @new bcMC, // copy [top] bcMD, // double [top] bcRM, // rem @[top] bcNA, // [top] = @new array[ [top] ] of pointer bcTF, // [top] = typeof( [top] ) bcSF, // [top] = sizeof( [top] ) {** array's **} bcAL, // length( [top] as array ) bcSL, // setlength( [top] as array, {stack} ) bcPA, // push ([top] as array)[top-1] bcSA, // peek [top-2] -&gt; ([top] as array)[top-1] {** memory grabber **} bcGPM, // add pointer to TMem to grabber task-list bcGC, // run grabber {** constant's **} bcPHC, // push copy of const bcPHCP, // push pointer to original const {** external call's **} bcPHEXMP, // push pointer to external method bcINV, // call external method bcINVBP, // call external method by pointer [top] {** for thread's **} bcPHN, // push null bcCTHR, // [top] = thread(method = [top], arg = [top+1]):id bcSTHR, // suspendthread(id = [top]) bcRTHR, // resumethread(id = [top]) bcTTHR, // terminatethread(id = [top]) {** for try..catch..finally block's **} bcTR, // try @block_catch = [top], @block_end = [top+1] bcTRS, // success exit from try/catch block bcTRR, // raise exception, message = [top] {** for string's **} bcSTRD, // strdel bcCHORD, bcORDCH, {** [!] directly memory operations **} bcALLC, //alloc memory bcRALLC, //realloc memory bcDISP, //dispose memory bcGTB, //get byte bcSTB, //set byte bcCBP, //mem copy bcRWBP, //read word bcWWBP, //write word bcRIBP, //read int bcWIBP, //write int bcRFBP, //read float bcWFBP, //write float bcRSBP, //read string bcWSBP, //write string bcTHREXT,//stop code execution bcDBP //debug method call );</span></span></code> </pre><br>  Sie haben sich also fließend mit den von mir geschriebenen Vorgängen vertraut gemacht.  Jetzt möchte ich darüber sprechen, wie alles funktioniert. <br><br>  Eine VM wird als Objekt implementiert, sodass Sie problemlos Multithreading-Unterstützung implementieren können. <br><br>  Es hat einen Zeiger auf ein Array mit Opcodes, IP (Instruction Pointer) - Offset des ausgeführten Befehls und Zeiger auf andere VM-Strukturen. <br><br>  Die Codeausführung ist ein großer Switch-Fall. <br><br>  Geben Sie einfach eine Beschreibung der VM: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVM = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ip, end_ip: TInstructionPointer; mainclasspath: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; mem: PMemory; stack: TStack; cbstack: TCallBackStack; bytes: PByteArr; grabber: TGrabber; consts: PConstSection; extern_methods: PImportSection; try_blocks: TTRBlocks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunThread</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b: TByteArr)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><h3>  Ein bisschen über die Ausnahmebehandlung </h3><br>  Zu diesem Zweck verfügt die VM über einen Stapel von Ausnahmebehandlungsroutinen und einen großen Try / Catch-Block, in den die Codeausführung eingeschlossen ist.  Aus dem Stapel können Sie eine Struktur mit einem Eintrittspunktversatz auf den Block für die Behandlung von Catch- und End- / End-Ausnahmen setzen.  Ich habe auch den trs-Opcode bereitgestellt, der vor catch platziert wird und den Code auf finally / end setzt, wenn dies erfolgreich ist, und gleichzeitig den Block mit Informationen zu Ausnahmebehandlungsroutinen vom oberen Rand des entsprechenden Stapels gelöscht.  Ist es einfach  Einfach.  Ist es bequem?  Praktisch. <br><br><h3>  Lassen Sie uns über externe Methoden und Bibliotheken sprechen </h3><br>  Ich habe sie bereits erwähnt.  Importe, Bibliotheken ... Ohne sie hat die Sprache nicht die gewünschte Flexibilität und Funktionalität. <br><br>  Zunächst deklarieren wir bei der Implementierung der VM den Typ der externen Methode und das Protokoll für den Aufruf. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TExternalFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PStack: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; PExternalFunction = ^TExternalFunction;</code> </pre><br>  Beim Importieren einer VM füllt der Parser des Importabschnitts ein Array von Zeigern auf externe Methoden.  Daher hat jede Methode eine statische Adresse, die in der Phase der Montage der Anwendung unter der VM berechnet wird und über die die gewünschte Methode aufgerufen werden kann. <br><br>  Der Aufruf erfolgt später auf folgende Weise während der Codeausführung: <br><br><pre> <code class="delphi hljs">TExternalFunction(self.extern_methods^.GetFunc(TSVMMem(self.stack.popv).GetW))(@self.stack);</code> </pre><br><h3>  Schreiben wir eine einfache Bibliothek für unsere VM </h3><br>  Und lassen Sie sie zuerst die Schlafmethode implementieren: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> bf; <span class="hljs-meta"><span class="hljs-meta">{$mode objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, svm_api <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'..\svm_api.pas'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DSleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stack:PStack)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sleep(TSVMMem(Stack^.popv).GetW); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> DSleep <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'SLEEP'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br><h3>  Zusammenfassung </h3><br>  Dazu werde ich wahrscheinlich meinen ersten Artikel aus einem geplanten Zyklus beenden. <br><br>  Heute habe ich die Erstellung der Sprachlaufzeit ausführlich beschrieben.  Ich glaube, dass dieser Artikel sehr nützlich für Leute sein wird, die sich entscheiden, ihre eigene Sprache zu schreiben oder zu verstehen, wie ähnliche Programmiersprachen funktionieren. <br><br>  Der vollständige VM-Code ist im Repository im Zweig / runtime / svm verfügbar. <br><br>  Wenn Ihnen dieser Artikel gefallen hat, dann seien Sie nicht faul, ein Plus an Karma zu werfen und es nach oben zu heben. Ich habe es versucht und werde es für Sie versuchen. <br><br>  Wenn Ihnen etwas nicht klar ist, dann begrüßen Sie die Kommentare oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Forum</a> . <br><br>  Vielleicht sind Ihre Fragen und Antworten nicht nur für Sie interessant. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435202/">https://habr.com/ru/post/de435202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435186/index.html">Rolls-Royce entwickelt das schnellste Elektroflugzeug der Welt</a></li>
<li><a href="../de435190/index.html">Google hat es geschafft, über Irland und Bermuda Steuern von 22,7 Milliarden US-Dollar abzuziehen</a></li>
<li><a href="../de435194/index.html">Vereinfachen Sie das Schreiben eines Lebenslaufs eines Entwicklers</a></li>
<li><a href="../de435196/index.html">Forscher geben ReCAPTCHA über Google-Dienste weiter</a></li>
<li><a href="../de435198/index.html">Arduin und LED, oder wie man den Kinderdesigner aufwertet</a></li>
<li><a href="../de435204/index.html">Empfang für Entwickler zur Überwindung des Aufschubs</a></li>
<li><a href="../de435206/index.html">Europa genehmigt Urheberrechtsrichtlinie - warum Streaming-Plattformen dagegen sind</a></li>
<li><a href="../de435208/index.html">Internet der Dinge ... die nach einer guten UI / UX schreien</a></li>
<li><a href="../de435210/index.html">Xamarins Arbeit mit dem C SDK</a></li>
<li><a href="../de435212/index.html">Wie man Papier-Visitenkarten im neuen Jahr vergisst</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>