<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÜüèø üë®üèø‚Äçü§ù‚Äçüë®üèΩ üßòüèæ Wir schreiben unsere Programmiersprache, Teil 1: Wir schreiben eine Sprach-VM üôâ üêù üßñüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Guten Tag an alle Habrachitateli! 

 Vielleicht ist es erw√§hnenswert, dass das Ziel meiner Arbeit, auf deren Grundlage eine Reihe von Sta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben unsere Programmiersprache, Teil 1: Wir schreiben eine Sprach-VM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435202/"><h3>  Einf√ºhrung </h3><br>  Guten Tag an alle Habrachitateli! <br><br>  Vielleicht ist es erw√§hnenswert, dass das Ziel meiner Arbeit, auf deren Grundlage eine Reihe von Statuen geschrieben werden, darin bestand, selbst ein voll funktionsf√§higes YP von 0 zu schaffen und dann mein Wissen, meine Best Practices und meine Erfahrungen mit den Interessierten zu teilen. <br><br>  Ich werde die Entstehung der Sprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschreiben</a> , die ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor hier beschrieben habe</a> . <br><br>  Er interessierte viele und provozierte eine hitzige Diskussion in den Kommentaren.  Daher ist das Thema f√ºr viele interessant. <br><br>  Ich denke, es lohnt sich, sofort Informationen √ºber das Projekt zu ver√∂ffentlichen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Site</a> (wird etwas sp√§ter mit Dokumentation gef√ºllt). <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> <br><br>  Um das Projekt selbst zu ber√ºhren und alles in Aktion zu sehen, ist es besser, das Repository herunterzuladen und alles aus dem Ordner bin auszuf√ºhren.  In der Ver√∂ffentlichung habe ich es nicht eilig, die neuesten Versionen der Sprache und Laufzeit hochzuladen, weil  Manchmal ist es einfach zu faul f√ºr mich, es zu tun. <br><br>  Ich kann in C / C ++ und Object Pascal codieren.  Ich habe das Projekt seitdem auf FPC geschrieben  Meiner Meinung nach ist diese Sprache viel einfacher und besser geeignet, um so zu schreiben.  Der zweite entscheidende Faktor war, dass FPC eine gro√üe Anzahl von Zielplattformen unterst√ºtzt und es m√∂glich ist, ein Projekt f√ºr die gew√ºnschte Plattform mit einem Minimum an √Ñnderungen neu zu erstellen.  Wenn ich Object Pascal aus irgendeinem Grund nicht mag, beeile dich nicht, den Pfosten zu schlie√üen und zu rennen, um Steine ‚Äã‚Äãauf den Kommentar zu werfen.  Diese Sprache ist sehr sch√∂n und intuitiv, aber ich werde nicht so viel Code bereitstellen.  Genau das, was Sie brauchen. <br><br>  Vielleicht beginne ich meine Geschichte. <br><a name="habracut"></a><br><h3>  Wir setzen uns Ziele </h3><br>  Zuallererst braucht jedes Projekt seine Ziele und TK, die in Zukunft umgesetzt werden m√ºssen.  Es muss im Voraus entschieden werden, welche Art von Sprache erstellt wird, um die prim√§re VM daf√ºr zu schreiben. <br><br>  Die wichtigsten Punkte, die die Weiterentwicklung meiner VM bestimmt haben, sind folgende: <br><br><ul><li>  Dynamisches Tippen und Typgie√üen.  Ich beschloss, ihre Unterst√ºtzung in der Entwicklungsphase der VM zu organisieren. </li><li>  Multithreading-Unterst√ºtzung.  Ich habe dieses Element im Voraus in diese Liste aufgenommen, um die Architektur der VM ordnungsgem√§√ü zu entwerfen und die Unterst√ºtzung f√ºr Multithreading auf der Kernebene der VM und nicht sp√§ter mit Kr√ºcken zu organisieren. </li><li>  Export externer Methoden.  Ohne dies wird die Sprache nutzlos sein.  Es sei denn, es in ein Projekt einzubetten. </li><li>  Zusammenstellung der Sprache (in eine einzige abstrakte ausf√ºhrbare Datei).  Teilweise kompiliert oder interpretiert?  Viel h√§ngt davon ab. </li><li>  Allgemeine VM-Architektur.  Wird der Stack oder das Register unsere VM sein?  Ich habe versucht, dies und das umzusetzen.  Ich habe eine gestapelte VM zur Unterst√ºtzung ausgew√§hlt. </li><li>  Wie sehen Sie die Arbeit mit Variablen, Arrays, Strukturen?  Pers√∂nlich wollte ich in diesem Moment eine Sprache implementieren, in der fast alles an implizite Zeiger gebunden ist, da ein solcher Ansatz viel Speicherplatz sparen und das Leben des Entwicklers vereinfachen w√ºrde.  Wenn wir zulassen, dass etwas Gro√ües an Methoden √ºbergeben wird, wird automatisch nur ein Zeiger auf dieses gro√üe √ºbertragen. </li></ul><br>  Daher habe ich die oben genannten Priorit√§ten ausgew√§hlt und mit der Implementierung der virtuellen Sprachmaschine begonnen.  Das ist nat√ºrlich seltsam, normalerweise werden zuerst Parser / √úbersetzer und dann VMs geschrieben.  Nun, ich habe begonnen, das Projekt in dieser Reihenfolge zu entwickeln, und ich werde es in der Reihenfolge, in der ich es entwickelt habe, weiter beschreiben. <br><br>  Ich muss sofort sagen, dass ich VM so eloquent wie m√∂glich genannt habe - SVM (Stack-based Virtual Machine). <br><br><h3>  Beginnen wir mit der Implementierung der Variablenklasse </h3><br>  Anfangs habe ich einfach einen Variantentyp verwendet, weil er einfacher und schneller ist.  Es war eine Kr√ºcke, aber es st√ºtzte das Projekt und erm√∂glichte mir, die erste Version von VM und Sprache schnell zu implementieren.  Sp√§ter setzte ich mich an den Code und schrieb eine Implementierung meiner ‚ÄûVariante‚Äú.  Im Wesentlichen m√ºssen Sie eine Klasse schreiben, die einen Zeiger auf einen Wert im Speicher speichert. In meiner Implementierung ist dies <code>null/cardinal/int64/double/string/array</code> .  Man k√∂nnte die Eingabe von Gro√ü- und Kleinschreibung verwenden, aber ich dachte, es w√§re besser, die Art und Weise zu implementieren, wie ich sie implementiert habe. <br><br>  Bevor ich anfing, Klassencode zu schreiben, entschied ich mich, die Direktive {$ H +} sofort in den Modulheader einzuf√ºgen, um die Unterst√ºtzung von Zeichenfolgen in der zuk√ºnftigen Sprache flexibler zu gestalten. <br><blockquote>  P.S.  f√ºr diejenigen, die den Unterschied zwischen den Modi H- und H + FPC m√∂glicherweise nicht kennen. <br><br>  Beim Zusammenstellen von Code im H-Modus werden Zeichenfolgen als Zeichenarray dargestellt.  Wenn H + - als Zeiger auf ein St√ºck Ged√§chtnis.  Im ersten Fall werden die Zeilen zun√§chst in der L√§nge festgelegt und standardm√§√üig auf 256 Zeichen begrenzt.  Im zweiten Fall sind die Zeilen dynamisch erweiterbar und es k√∂nnen viel mehr Zeichen eingepfercht werden.  Sie arbeiten etwas langsamer, aber funktionaler.  Mit H + k√∂nnen Sie Zeichenfolgen auch als Zeichenarray deklarieren, beispielsweise auf folgende Weise: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[<span class="hljs-number"><span class="hljs-number">256</span></span>];</code> </pre></blockquote>  F√ºr den Anfang deklarieren wir Enum als Typ, den wir als bestimmtes Flag verwenden, um den Datentyp durch einen Zeiger zu bestimmen: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVMType = (svmtNull, svmtWord, svmtInt, svmtReal, svmtStr, svmtArr);</code> </pre><br>  Als n√§chstes beschreiben wir die Grundstruktur unseres Variablentyps und einige Methoden: <br><br><pre> <code class="delphi hljs"> TSVMMem = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> m_val: pointer; m_type: TSVMType; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> m_val := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; m_type := svmtNull; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Clear; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtNull: <span class="hljs-comment"><span class="hljs-comment">{ nop }</span></span>; svmtWord: Dispose(PCardinal(m_val)); svmtInt: Dispose(PInt64(m_val)); svmtReal: Dispose(PDouble(m_val)); svmtStr: Dispose(PString(m_val)); svmtArr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(PMemArray(m_val)^, <span class="hljs-number"><span class="hljs-number">0</span></span>); Dispose(PMemArray(m_val)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Die Klasse erbt nichts, daher k√∂nnen geerbte Aufrufe im Konstruktor und Destruktor weggelassen werden.  Ich werde auf die Inline-Richtlinie achten.  Es ist sicher besser, {$ inline on} zum Dateikopf hinzuzuf√ºgen.  Die aktive Verwendung in VMs erh√∂hte die Produktivit√§t erheblich (Mb irgendwo um bis zu 15-20%!).  Sie teilt dem Compiler mit, dass der Hauptteil der Methode am besten an der Stelle ihres Aufrufs eingebettet ist.  Der Ausgabecode wird am Ende etwas gr√∂√üer sein, aber schneller arbeiten.  In diesem Fall ist die Verwendung von Inline ratsam. <br><br>  Ok, zu diesem Zeitpunkt haben wir das Fundament unserer Klasse heruntergesp√ºlt.  Jetzt m√ºssen wir eine Reihe von Setzern und Gettern (Setter &amp; Getter) in unserer Klasse beschreiben. <br><br>  Die Aufgabe besteht darin, einige Methoden zu schreiben, mit denen Sie die Werte aus unserer Klasse √ºberf√ºllen und sp√§ter zur√ºckerhalten k√∂nnen. <br><br>  Lassen Sie uns zun√§chst die Zuweisung eines Werts f√ºr unsere Klasse herausfinden.  Zuerst k√∂nnen Sie einen verallgemeinerten Setter schreiben und dann f√ºr einzelne Datentypen: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value; t:TSVMType)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = t) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: PCardinal(m_val)^ := Cardinal(value); svmtInt: PInt64(m_val)^ := Int64(value); svmtReal: PDouble(m_val)^ := Double(value); svmtStr: PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := t; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PCardinal(m_val)); PCardinal(m_val)^ := Cardinal(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PInt64(m_val)); PInt64(m_val)^ := Int64(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PDouble(m_val)); PDouble(m_val)^ := Double(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PString(m_val)); PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value:cardinal)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = svmtWord) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PCardinal(m_val)^ := value <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := svmtWord; New(PCardinal(m_val)); PCardinal(m_val)^ := value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Jetzt k√∂nnen Sie Code f√ºr ein paar Getter schreiben: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetW</span></span></span><span class="hljs-function">:</span></span>cardinal; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: Result := PCardinal(m_val)^; svmtInt: Result := PInt64(m_val)^; svmtReal: Result := Trunc(PDouble(m_val)^); svmtStr: Result := StrToQWord(PString(m_val)^); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Ok, gro√üartig, jetzt, da Sie eine Weile auf die IDE gestarrt und den Code f√ºr Setter und Getter begeistert eingegeben haben, stehen wir vor der Aufgabe, Unterst√ºtzung f√ºr unsere Art von mathematischen und logischen Operationen zu implementieren.  Als Beispiel werde ich die Implementierung der Additionsoperation geben: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m:TSVMMem)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetW(GetW + m.GetW); svmtInt: SetI(GetW + m.GetI); svmtReal: SetD(GetW + m.GetD); svmtStr: SetD(GetW + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetI(GetI + m.GetW); svmtInt: SetI(GetI + m.GetI); svmtReal: SetD(GetI + m.GetD); svmtStr: SetD(GetI + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetD(GetD + m.GetW); svmtInt: SetD(GetD + m.GetI); svmtReal: SetD(GetD + m.GetD); svmtStr: SetD(GetD + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetS(GetS + IntToStr(m.GetW)); svmtInt: SetS(GetS + IntToStr(m.GetI)); svmtReal: SetS(GetS + FloatToStr(m.GetD)); svmtStr: SetS(GetS + m.GetS); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Alles ist einfach.  Weitere Operationen k√∂nnen auf √§hnliche Weise beschrieben werden, und jetzt ist unsere Klasse bereit. <br>  F√ºr Arrays ben√∂tigen Sie nat√ºrlich noch einige Methoden, ein Beispiel f√ºr das Abrufen eines Elements per Index: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: cardinal; grabber:PGrabber)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtArr: Result := PMemArray(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TSVMMem.CreateFW(Ord(PString(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>])); grabber^.AddTask(Result); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Gro√üartig.  Jetzt k√∂nnen wir weitermachen. <br><br><h3>  Wir realisieren einen Stapel </h3><br>  Nach einer Weile kam ich zu solchen Gedanken.  Der Stapel muss gleichzeitig statisch (aus Gr√ºnden der Geschwindigkeit) und dynamisch (aus Gr√ºnden der Flexibilit√§t) sein. <br><br>  Daher ist der Stapel in Bl√∂cken implementiert.  Das hei√üt,  wie es funktionieren sollte - anfangs hat das Array des Stapels eine bestimmte Gr√∂√üe (ich habe beschlossen, die Blockgr√∂√üe auf 256 Elemente festzulegen, damit es sch√∂n und nicht klein ist).  Dementsprechend ist ein Array in dem Array enthalten, das die aktuelle Oberseite des Stapels anzeigt.  Die Neuzuweisung von Speicher ist eine besonders lange Operation, die weniger h√§ufig ausgef√ºhrt werden kann.  Wenn mehr Werte auf den Stapel verschoben werden, kann seine Gr√∂√üe immer auf die Gr√∂√üe eines anderen Blocks erweitert werden. <br><br>  Ich bringe die gesamte Stack-Implementierung mit: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TStack = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> items: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pointer; size, i_pos: cardinal; parent_vm: pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PStack = ^TStack; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; size := StackBlockSize; parent_vm := vm; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> items[i_pos] := p; inc(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i_pos &gt;= size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size + StackBlockSize; SetLength(items, size) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); Result := items[i_pos]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p := items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>] := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>] := p; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); size := StackBlockSize; i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Bei externen Methoden √ºbergibt die VM einen Zeiger auf den Stapel, damit sie die erforderlichen Argumente von dort √ºbernehmen kann.  Ein Zeiger auf den VM-Stream wurde sp√§ter hinzugef√ºgt, damit R√ºckrufaufrufe von externen Methoden implementiert werden k√∂nnen und im Allgemeinen mehr Leistung √ºber VM-Methoden √ºbertragen werden kann. <br><br>  Also, wie Sie sich mit der Anordnung des Stapels vertraut gemacht haben.  Der R√ºckrufstapel ist auf die gleiche Weise angeordnet, um die Call &amp; Return-Operationen und den Garbage Collector-Stapel zu vereinfachen und zu vereinfachen.  Das einzige, was ist die anderen Gr√∂√üen der Bl√∂cke. <br><br><h3>  Sprechen Sie √ºber M√ºll </h3><br>  Es ist normalerweise viel, viel.  Und du musst etwas damit anfangen. <br><br>  Zun√§chst m√∂chte ich dar√ºber sprechen, wie Garbage Collectors in anderen Sprachen angeordnet sind, z. B. in Lua, Ruby, Java, Perl, PHP usw.  Sie arbeiten nach dem Prinzip, Zeiger auf Objekte im Speicher zu z√§hlen. <br><br>  Das hei√üt,  Es ist also logisch, dass wir Speicher f√ºr etwas zugewiesen haben. Der Zeiger wurde sofort in einer Variablen / einem Array / an einer anderen Stelle platziert.  Der Laufzeit-Garbage-Collector f√ºgt diesen Zeiger sofort mit einer Liste m√∂glicher Garbage-Objekte zu sich selbst hinzu.  Im Hintergrund √ºberwacht der Garbage Collector st√§ndig alle Variablen, Arrays usw.  Wenn es keinen Zeiger auf etwas aus der Liste des m√∂glichen M√ºlls gibt, bedeutet dies, dass M√ºll und Speicher darunter entfernt werden m√ºssen. <br><br>  Ich habe beschlossen, mein Fahrrad zu verkaufen.  Ich bin eher daran gew√∂hnt, mit dem Ged√§chtnis nach dem Prinzip von Taras Bulba zu arbeiten.  Ich habe dich geboren - ich werde dich t√∂ten, ich meine, wenn ich den n√§chsten Freien in der n√§chsten Klasse rufe.  Daher ist der Garbage Collector meiner VM halbautomatisch.  Das hei√üt,  Es muss im manuellen Modus aufgerufen werden und entsprechend damit arbeiten.  In seinem Zug werden Zeiger auf deklarierte tempor√§re Objekte hinzugef√ºgt (diese Rolle liegt haupts√§chlich beim √úbersetzer und ein wenig beim Entwickler).  Um Speicher unter anderen Objekten freizugeben, k√∂nnen Sie einen separaten Opcode verwenden. <br><br>  Das hei√üt,  Der Garbage Collector verf√ºgt zum Zeitpunkt des Aufrufs √ºber eine vorgefertigte Liste von Zeigern, die Sie ben√∂tigen, um Speicherplatz freizugeben. <br><br><h3>  Nun besch√§ftigen wir uns mit der Kompilierung in eine abstrakte ausf√ºhrbare Datei </h3><br>  Die Idee war urspr√ºnglich, dass Anwendungen, die in meiner Sprache geschrieben wurden, ohne Quelle ausgef√ºhrt werden k√∂nnen, wie dies bei vielen √§hnlichen Sprachen der Fall ist.  Das hei√üt,  es kann f√ºr kommerzielle Zwecke verwendet werden. <br><br>  Bestimmen Sie dazu das Format der ausf√ºhrbaren Dateien.  Ich habe folgendes bekommen: <br><br><ol><li>  Header, zum Beispiel "SVMEXE_CNS". </li><li>  Ein Abschnitt mit einer Liste von Bibliotheken, aus denen Methoden importiert werden. </li><li>  Der Importabschnitt der erforderlichen Methoden, die Bibliotheken, aus denen die Methoden importiert werden, werden durch ihre Nummer im obigen Abschnitt angegeben. </li><li>  Abschnitt der Konstanten. </li><li>  Codeabschnitt </li></ol><br>  Ich denke nicht, dass es sich lohnt, die detaillierten Schritte zum Implementieren von Parsern f√ºr diese Abschnitte darzulegen, da Sie alles in meinem Repository selbst sehen k√∂nnen. <br><br><h3>  Codeausf√ºhrung </h3><br>  Nachdem wir die obigen Abschnitte analysiert und die VM initialisiert haben, haben wir einen Abschnitt mit dem Code.  In meiner VM wird ein nicht ausgerichteter Bytecode ausgef√ºhrt, d. H.  Anweisungen k√∂nnen beliebig lang sein. <br><br>  Eine Reihe von Opcodes - Anweisungen f√ºr eine virtuelle Maschine mit kleinen Kommentaren, die ich im Voraus unten zeige: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TComand = ( <span class="hljs-comment"><span class="hljs-comment">{** for stack **}</span></span> bcPH, <span class="hljs-comment"><span class="hljs-comment">// [top] = [var] bcPK, // [var] = [top] bcPP, // pop bcSDP, // stkdrop bcSWP, // [top] &lt;-&gt; [top-1] {** jump's **} bcJP, // jump [top] bcJZ, // [top] == 0 ? jp [top-1] bcJN, // [top] &lt;&gt; 0 ? jp [top-1] bcJC, // jp [top] &amp; push callback point as ip+1 bcJR, // jp to last callback point &amp; rem last callback point {** for untyped's **} bcEQ, // [top] == [top-1] ? [top] = 1 : [top] = 0 bcBG, // [top] &gt; [top-1] ? [top] = 1 : [top] = 0 bcBE, // [top] &gt;= [top-1] ? [top] = 1 : [top] = 0 bcNOT, // [top] = ![top] bcAND, // [top] = [top] and [top-1] bcOR, // [top] = [top] or [top-1] bcXOR, // [top] = [top] xor [top-1] bcSHR, // [top] = [top] shr [top-1] bcSHL, // [top] = [top] shl [top-1] bcNEG, // [top] = -[top] bcINC, // [top]++ bcDEC, // [top]-- bcADD, // [top] = [top] + [top-1] bcSUB, // [top] = [top] - [top-1] bcMUL, // [top] = [top] * [top-1] bcDIV, // [top] = [top] / [top-1] bcMOD, // [top] = [top] % [top-1] bcIDIV, // [top] = [top] \ [top-1] bcMV, // [top]^ = [top-1]^ bcMVBP, // [top]^^ = [top-1]^ bcGVBP, // [top]^ = [top-1]^^ bcMVP, // [top]^ = [top-1] {** memory operation's **} bcMS, // memory map size = [top] bcNW, // [top] = @new bcMC, // copy [top] bcMD, // double [top] bcRM, // rem @[top] bcNA, // [top] = @new array[ [top] ] of pointer bcTF, // [top] = typeof( [top] ) bcSF, // [top] = sizeof( [top] ) {** array's **} bcAL, // length( [top] as array ) bcSL, // setlength( [top] as array, {stack} ) bcPA, // push ([top] as array)[top-1] bcSA, // peek [top-2] -&gt; ([top] as array)[top-1] {** memory grabber **} bcGPM, // add pointer to TMem to grabber task-list bcGC, // run grabber {** constant's **} bcPHC, // push copy of const bcPHCP, // push pointer to original const {** external call's **} bcPHEXMP, // push pointer to external method bcINV, // call external method bcINVBP, // call external method by pointer [top] {** for thread's **} bcPHN, // push null bcCTHR, // [top] = thread(method = [top], arg = [top+1]):id bcSTHR, // suspendthread(id = [top]) bcRTHR, // resumethread(id = [top]) bcTTHR, // terminatethread(id = [top]) {** for try..catch..finally block's **} bcTR, // try @block_catch = [top], @block_end = [top+1] bcTRS, // success exit from try/catch block bcTRR, // raise exception, message = [top] {** for string's **} bcSTRD, // strdel bcCHORD, bcORDCH, {** [!] directly memory operations **} bcALLC, //alloc memory bcRALLC, //realloc memory bcDISP, //dispose memory bcGTB, //get byte bcSTB, //set byte bcCBP, //mem copy bcRWBP, //read word bcWWBP, //write word bcRIBP, //read int bcWIBP, //write int bcRFBP, //read float bcWFBP, //write float bcRSBP, //read string bcWSBP, //write string bcTHREXT,//stop code execution bcDBP //debug method call );</span></span></code> </pre><br>  Sie haben sich also flie√üend mit den von mir geschriebenen Vorg√§ngen vertraut gemacht.  Jetzt m√∂chte ich dar√ºber sprechen, wie alles funktioniert. <br><br>  Eine VM wird als Objekt implementiert, sodass Sie problemlos Multithreading-Unterst√ºtzung implementieren k√∂nnen. <br><br>  Es hat einen Zeiger auf ein Array mit Opcodes, IP (Instruction Pointer) - Offset des ausgef√ºhrten Befehls und Zeiger auf andere VM-Strukturen. <br><br>  Die Codeausf√ºhrung ist ein gro√üer Switch-Fall. <br><br>  Geben Sie einfach eine Beschreibung der VM: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVM = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ip, end_ip: TInstructionPointer; mainclasspath: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; mem: PMemory; stack: TStack; cbstack: TCallBackStack; bytes: PByteArr; grabber: TGrabber; consts: PConstSection; extern_methods: PImportSection; try_blocks: TTRBlocks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunThread</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b: TByteArr)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><h3>  Ein bisschen √ºber die Ausnahmebehandlung </h3><br>  Zu diesem Zweck verf√ºgt die VM √ºber einen Stapel von Ausnahmebehandlungsroutinen und einen gro√üen Try / Catch-Block, in den die Codeausf√ºhrung eingeschlossen ist.  Aus dem Stapel k√∂nnen Sie eine Struktur mit einem Eintrittspunktversatz auf den Block f√ºr die Behandlung von Catch- und End- / End-Ausnahmen setzen.  Ich habe auch den trs-Opcode bereitgestellt, der vor catch platziert wird und den Code auf finally / end setzt, wenn dies erfolgreich ist, und gleichzeitig den Block mit Informationen zu Ausnahmebehandlungsroutinen vom oberen Rand des entsprechenden Stapels gel√∂scht.  Ist es einfach  Einfach.  Ist es bequem?  Praktisch. <br><br><h3>  Lassen Sie uns √ºber externe Methoden und Bibliotheken sprechen </h3><br>  Ich habe sie bereits erw√§hnt.  Importe, Bibliotheken ... Ohne sie hat die Sprache nicht die gew√ºnschte Flexibilit√§t und Funktionalit√§t. <br><br>  Zun√§chst deklarieren wir bei der Implementierung der VM den Typ der externen Methode und das Protokoll f√ºr den Aufruf. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TExternalFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PStack: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; PExternalFunction = ^TExternalFunction;</code> </pre><br>  Beim Importieren einer VM f√ºllt der Parser des Importabschnitts ein Array von Zeigern auf externe Methoden.  Daher hat jede Methode eine statische Adresse, die in der Phase der Montage der Anwendung unter der VM berechnet wird und √ºber die die gew√ºnschte Methode aufgerufen werden kann. <br><br>  Der Aufruf erfolgt sp√§ter auf folgende Weise w√§hrend der Codeausf√ºhrung: <br><br><pre> <code class="delphi hljs">TExternalFunction(self.extern_methods^.GetFunc(TSVMMem(self.stack.popv).GetW))(@self.stack);</code> </pre><br><h3>  Schreiben wir eine einfache Bibliothek f√ºr unsere VM </h3><br>  Und lassen Sie sie zuerst die Schlafmethode implementieren: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> bf; <span class="hljs-meta"><span class="hljs-meta">{$mode objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, svm_api <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'..\svm_api.pas'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DSleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stack:PStack)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sleep(TSVMMem(Stack^.popv).GetW); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> DSleep <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'SLEEP'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br><h3>  Zusammenfassung </h3><br>  Dazu werde ich wahrscheinlich meinen ersten Artikel aus einem geplanten Zyklus beenden. <br><br>  Heute habe ich die Erstellung der Sprachlaufzeit ausf√ºhrlich beschrieben.  Ich glaube, dass dieser Artikel sehr n√ºtzlich f√ºr Leute sein wird, die sich entscheiden, ihre eigene Sprache zu schreiben oder zu verstehen, wie √§hnliche Programmiersprachen funktionieren. <br><br>  Der vollst√§ndige VM-Code ist im Repository im Zweig / runtime / svm verf√ºgbar. <br><br>  Wenn Ihnen dieser Artikel gefallen hat, dann seien Sie nicht faul, ein Plus an Karma zu werfen und es nach oben zu heben. Ich habe es versucht und werde es f√ºr Sie versuchen. <br><br>  Wenn Ihnen etwas nicht klar ist, dann begr√º√üen Sie die Kommentare oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Forum</a> . <br><br>  Vielleicht sind Ihre Fragen und Antworten nicht nur f√ºr Sie interessant. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435202/">https://habr.com/ru/post/de435202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435186/index.html">Rolls-Royce entwickelt das schnellste Elektroflugzeug der Welt</a></li>
<li><a href="../de435190/index.html">Google hat es geschafft, √ºber Irland und Bermuda Steuern von 22,7 Milliarden US-Dollar abzuziehen</a></li>
<li><a href="../de435194/index.html">Vereinfachen Sie das Schreiben eines Lebenslaufs eines Entwicklers</a></li>
<li><a href="../de435196/index.html">Forscher geben ReCAPTCHA √ºber Google-Dienste weiter</a></li>
<li><a href="../de435198/index.html">Arduin und LED, oder wie man den Kinderdesigner aufwertet</a></li>
<li><a href="../de435204/index.html">Empfang f√ºr Entwickler zur √úberwindung des Aufschubs</a></li>
<li><a href="../de435206/index.html">Europa genehmigt Urheberrechtsrichtlinie - warum Streaming-Plattformen dagegen sind</a></li>
<li><a href="../de435208/index.html">Internet der Dinge ... die nach einer guten UI / UX schreien</a></li>
<li><a href="../de435210/index.html">Xamarins Arbeit mit dem C SDK</a></li>
<li><a href="../de435212/index.html">Wie man Papier-Visitenkarten im neuen Jahr vergisst</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>