<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚Äçüßëüèª üåù „äôÔ∏è Initialisierung und Betrieb des Bytecode-Interpreters in JVM HotSpot unter x86 ü•î üåî üéÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fast jeder Java-Entwickler wei√ü, dass in Java geschriebene Programme zun√§chst in einen JVM-Bytecode kompiliert und als Klassendateien in einem standar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Initialisierung und Betrieb des Bytecode-Interpreters in JVM HotSpot unter x86</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469291/"><p> Fast jeder Java-Entwickler wei√ü, dass in Java geschriebene Programme zun√§chst in einen JVM-Bytecode kompiliert und als Klassendateien in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">standardisierten Format gespeichert werden</a> .  Nachdem solche Klassendateien in der virtuellen Maschine abgerufen wurden und der Compiler sie noch nicht erreicht hat, interpretiert die JVM den in diesen Klassendateien enthaltenen Bytecode.  Dieser Artikel bietet einen √úberblick √ºber die Funktionsweise des Interpreters in Bezug auf den OpenJDK JVM HotSpot. </p><a name="habracut"></a><br><p>  Der Inhalt des Artikels: </p><br><ul><li>  Die Umwelt </li><li>  Java-Anwendung ausf√ºhren </li><li>  Interpreter-Initialisierung und Steuerung der √úbertragung in Java-Code </li><li>  Beispiel </li></ul><br><h4 id="okruzhenie">  Die Umwelt </h4><br><p>  F√ºr Experimente verwenden wir die Assembly der neuesten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verf√ºgbaren</a> OpenJDK JDK12- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Revision</a> mit Autoconf- <a href="">Konfiguration</a> </p><br><pre><code class="plaintext hljs">--enable-debug --with-native-debug-symbols=internal</code> </pre> <br><p>  unter Ubuntu 18.04 / gcc 7.4.0. </p><br><p>  <code>--with-native-debug-symbols=internal</code> bedeutet, dass beim Erstellen des JDK Debazh-Symbole in den Bin√§rdateien selbst enthalten sind. </p><br><p>  <code>--enable-debug</code> - dass die Bin√§rdatei zus√§tzlichen Debugging-Code enth√§lt. </p><br><p>  Das Erstellen von JDK 12 in einer solchen Umgebung ist kein komplizierter Prozess.  Alles, was ich tun musste, war, JDK11 zu installieren ( <a href="">JDK n-1 ist erforderlich, um JDK n zu erstellen</a> ) und die erforderlichen Bibliotheken per Hand zu liefern, f√ºr die eine automatische Konfiguration signalisiert wurde.  F√ºhren Sie als N√§chstes den Befehl aus </p><br><pre> <code class="plaintext hljs">bash configure --enable-debug --with-native-debug-symbols=internal &amp;&amp; make CONF=fastdebug images</code> </pre> <br><p>  und nachdem wir ein bisschen gewartet haben (auf meinem Laptop ungef√§hr 10 Minuten), bekommen wir fastdebug Build JDK 12. </p><br><p>  Im Prinzip w√ºrde es v√∂llig ausreichen, jdk einfach aus √∂ffentlichen Repositorys zu installieren und zus√§tzlich das Paket openjdk-xx-dbg mit Debug-Symbolen bereitzustellen, wobei xx die jdk-Version ist. Die Fastdebug-Assembly bietet jedoch Debugging-Funktionen von gdb, die in einigen F√§llen das Leben erleichtern k√∂nnen.  Im Moment verwende ich aktiv <a href="">ps ()</a> , eine Funktion zum Anzeigen von Java-Stack-Traces von gdb, und <a href="">pfl ()</a> , eine Funktion zum Analysieren des <a href="">Frame-</a> Stacks (sehr praktisch beim Debuggen des Interpreters in gdb). </p><br><div class="spoiler">  <b class="spoiler_title">Beispiel ps () und pfl ()</b> <div class="spoiler_text"><p>  Betrachten Sie beispielsweise das folgende GDB-Skript </p><br><pre> <code class="plaintext hljs">#   java file /home/dmitrii/jdk12/build/linux-x86_64-server-fastdebug/images/jdk/bin/java #   SEGV-, HotSpot #  SEGV  . #, https://hg.openjdk.java.net/jdk/jdk12/file/06222165c35f/src/hotspot/cpu/x86/vm_version_x86.cpp#l361 handle SIGSEGV nostop noprint set breakpoint pending on set pagination off #  ,   #    # java- public static void main(String args[]) b PostJVMInit thread 2 commands #   , #    set $buf = (char *) malloc(1000) #        #(   ) b *AbstractInterpreter::_entry_table[0] thread 2 commands #      rbx. #   Method* set $mthd = ((Method *) $rbx) #    $buf call $mthd-&gt;name_and_sig_as_C_string($buf, 1000) # ,  public static void main(String args) if strcmp()("Main.main([Ljava/lang/String;)V", $buf) == 0 #   ,      # ps/pfl        #(    ps/pfl) b InterpreterRuntime::build_method_counters(JavaThread*, Method*) commands #  ,    #   delete breakpoints call ps() call pfl() c end end c end c end r -cp /home/dmitrii/jdk12/ Main</code> </pre> <br><p>  Das Ergebnis der Ausf√ºhrung eines solchen Skripts ist: </p><br><pre> <code class="plaintext hljs">"Executing ps" for thread: "main" #1 prio=5 os_prio=0 cpu=468,61ms elapsed=58,65s tid=0x00007ffff001b800 nid=0x5bfa runnable [0x00007ffff7fd9000] java.lang.Thread.State: RUNNABLE Thread: 0x00007ffff001b800 [0x5bfa] State: _running _has_called_back 0 _at_poll_safepoint 0 JavaThread state: _thread_in_Java 1 - frame( sp=0x00007ffff7fd9920, unextended_sp=0x00007ffff7fd9920, fp=0x00007ffff7fd9968, pc=0x00007fffd828748b) Main.main(Main.java:10) "Executing pfl" for thread: "main" #1 prio=5 os_prio=0 cpu=468,83ms elapsed=58,71s tid=0x00007ffff001b800 nid=0x5bfa runnable [0x00007ffff7fd9000] java.lang.Thread.State: RUNNABLE Thread: 0x00007ffff001b800 [0x5bfa] State: _running _has_called_back 0 _at_poll_safepoint 0 JavaThread state: _thread_in_Java [Describe stack layout] 0x00007ffff7fd99e0: 0x00007ffff7fd9b00 #2 entry frame call_stub word fp - 0 0x00007ffff7fd99d8: 0x00007ffff7fd9c10 call_stub word fp - 1 0x00007ffff7fd99d0: 0x00007fffd8287160 call_stub word fp - 2 0x00007ffff7fd99c8: 0x00007fffbf1fb3e0 call_stub word fp - 3 0x00007ffff7fd99c0: 0x000000000000000a call_stub word fp - 4 0x00007ffff7fd99b8: 0x00007ffff7fd9ce8 call_stub word fp - 5 0x00007ffff7fd99b0: 0x00007ffff7fd9a80 call_stub word fp - 6 0x00007ffff7fd99a8: 0x00007ffff001b800 call_stub word fp - 7 0x00007ffff7fd99a0: 0x00007ffff7fd9b40 call_stub word fp - 8 0x00007ffff7fd9998: 0x00007ffff7fd9c00 call_stub word fp - 9 0x00007ffff7fd9990: 0x00007ffff7fd9a80 call_stub word fp - 10 0x00007ffff7fd9988: 0x00007ffff7fd9ce0 call_stub word fp - 11 0x00007ffff7fd9980: 0x00007fff00001fa0 call_stub word fp - 12 0x00007ffff7fd9978: 0x0000000716a122b8 sp for #2 locals for #1 unextended_sp for #2 local 0 0x00007ffff7fd9970: 0x00007fffd82719f3 0x00007ffff7fd9968: 0x00007ffff7fd99e0 #1 method Main.main([Ljava/lang/String;)V @ 0 - 1 locals 1 max stack 0x00007ffff7fd9960: 0x00007ffff7fd9978 interpreter_frame_sender_sp 0x00007ffff7fd9958: 0x0000000000000000 interpreter_frame_last_sp 0x00007ffff7fd9950: 0x00007fffbf1fb3e0 interpreter_frame_method 0x00007ffff7fd9948: 0x0000000716a11c40 interpreter_frame_mirror 0x00007ffff7fd9940: 0x0000000000000000 interpreter_frame_mdp 0x00007ffff7fd9938: 0x00007fffbf1fb5e8 interpreter_frame_cache 0x00007ffff7fd9930: 0x00007ffff7fd9978 interpreter_frame_locals 0x00007ffff7fd9928: 0x00007fffbf1fb3d0 interpreter_frame_bcp 0x00007ffff7fd9920: 0x00007ffff7fd9920 sp for #1 interpreter_frame_initial_sp unextended_sp for #1</code> </pre> <br><p>  Wie Sie sehen k√∂nnen, erhalten wir im Fall von <code>ps()</code> nur den Aufrufstapel, im Fall von <code>pfl()</code> die vollst√§ndige <code>pfl()</code> . </p></div></div><br><h4 id="zapusk-java-prilozheniya">  Java-Anwendung ausf√ºhren </h4><br><p>  Bevor wir direkt mit der Diskussion des Interpreters fortfahren, werden wir kurz die Aktionen √ºberpr√ºfen, die ausgef√ºhrt werden, bevor die Steuerung auf den Java-Code √ºbertragen wird.  Nehmen Sie zum Beispiel ein Java-Programm, das "√ºberhaupt nichts tut": </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span></span>{ } }</code> </pre> <br><p>  und versuchen Sie herauszufinden, was passiert, wenn Sie eine solche Anwendung ausf√ºhren: </p><br><p> <code>javac Main.java &amp;&amp; java Main</code> </p> <br><p>  Um diese Frage zu beantworten, m√ºssen Sie zun√§chst die Java-Bin√§rdatei suchen und anzeigen, mit der wir alle unsere JVM-Anwendungen ausf√ºhren.  In meinem Fall befindet es sich entlang des Pfades </p><br><p>  <code>/home/dmitrii/jdk12/build/linux-x86_64-server-fastdebug/images/jdk/bin/java</code> . </p><br><p>  Aber am Ende gibt es nichts Besonderes zu sehen.  Dies ist eine Bin√§rdatei, die zusammen mit Debazhnymi-Symbolen nur 20 KB ben√∂tigt und aus nur einer Quelldatei <a href="">launcher / main.c. kompiliert wird.</a> </p><br><p>  Er empf√§ngt <a href="">lediglich</a> Befehlszeilenargumente (char * argv []), <a href="">liest die Argumente aus der Umgebungsvariablen JDK_JAVA_OPTIONS</a> , f√ºhrt eine grundlegende Vorverarbeitung und Validierung durch (z. B. k√∂nnen Sie dieser Umgebungsvariablen keine <a href="">Terminaloption</a> oder keinen <a href="">Hauptklassennamen</a> hinzuf√ºgen) und <a href="">die Funktion aufrufen JLI_Launch</a> mit der resultierenden Argumentliste. </p><br><p>  Die Definition der JLI_Launch-Funktion <a href="">ist</a> nicht in der Java-Bin√§rdatei enthalten, und wenn Sie sich die direkten Abh√§ngigkeiten ansehen: </p><br><pre> <code class="plaintext hljs">$ ldd java linux-vdso.so.1 (0x00007ffcc97ec000) libjli.so =&gt; /home/dmitrii/jdk12/build/linux-x86_64-server-fastdebug/images/jdk/bin/./../lib/libjli.so (0x00007ff27518d000) // &lt;---------    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff274d9c000) libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007ff274b7f000) libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ff27497b000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ff27475c000) /lib64/ld-linux-x86-64.so.2 (0x00007ff27559f000)</code> </pre> <br><p>  Sie k√∂nnen <strong>libjli.so sehen,</strong> das damit verkn√ºpft ist.  Diese Bibliothek enth√§lt die Launcher-Oberfl√§che - eine Reihe von Funktionen, mit denen Java eine virtuelle Maschine initialisiert und startet, darunter JLI_Launch. </p><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndige Liste der Schnittstellenfunktionen</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ objdump -T -j .text libjli.so libjli.so: file format elf64-x86-64 DYNAMIC SYMBOL TABLE: 0000000000009280 g DF .text 0000000000000038 Base JLI_List_add 0000000000003330 g DF .text 00000000000001c3 Base JLI_PreprocessArg 0000000000008180 g DF .text 0000000000000008 Base JLI_GetStdArgs 0000000000008190 g DF .text 0000000000000008 Base JLI_GetStdArgc 0000000000007e50 g DF .text 00000000000000b8 Base JLI_ReportErrorMessage 000000000000a400 g DF .text 00000000000000df Base JLI_ManifestIterate 0000000000002e70 g DF .text 0000000000000049 Base JLI_InitArgProcessing 0000000000008000 g DF .text 0000000000000011 Base JLI_ReportExceptionDescription 0000000000003500 g DF .text 0000000000000074 Base JLI_AddArgsFromEnvVar 0000000000007f10 g DF .text 00000000000000e9 Base JLI_ReportErrorMessageSys 0000000000005840 g DF .text 00000000000000b8 Base JLI_ReportMessage 0000000000009140 g DF .text 000000000000003a Base JLI_SetTraceLauncher 0000000000009020 g DF .text 000000000000000a Base JLI_MemFree 0000000000008f90 g DF .text 0000000000000026 Base JLI_MemAlloc 00000000000059c0 g DF .text 0000000000002013 Base JLI_Launch 00000000000091c0 g DF .text 000000000000003b Base JLI_List_new 0000000000008ff0 g DF .text 0000000000000026 Base JLI_StringDup 0000000000002ec0 g DF .text 000000000000000c Base JLI_GetAppArgIndex</code> </pre> </div></div><br><p>  Nach der √úbertragung der Steuerung an JLI_Launch sind eine Reihe von Aktionen erforderlich, um die JVM zu starten, z. </p><br><p>  <strong>I.</strong>  Laden von JVM-HotSpot-Zeichen in den Speicher und Abrufen eines Zeigers auf eine Funktion zum Erstellen einer VM. </p><br><p>  Der gesamte JVM-HotSpot-Code befindet sich in der Bibliothek libjvm.so.  Nachdem der absolute Pfad zu libjvm.so ermittelt wurde, wird die <a href="">Bibliothek in den Speicher geladen</a> und der <a href="">Zeiger auf die Funktion JNI_CreateJavaVM wird herausgerissen</a> .  Dieser Funktionszeiger wird gespeichert und anschlie√üend zum Erstellen und Initialisieren der virtuellen Maschine verwendet. </p><br><p>  Offensichtlich ist libjvm.so nicht mit libjli.so verkn√ºpft </p><br><p>  <strong>II</strong> .  Parsing-Argumente, die nach der Vorverarbeitung √ºbergeben wurden. </p><br><p>  Eine Funktion mit dem sprechenden Namen <a href="">ParseArguments</a> analysiert die √ºber die Befehlszeile √ºbergebenen Argumente.  Dieser Argumentparser definiert <a href="">den Anwendungsstartmodus</a> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> LaunchMode { <span class="hljs-comment"><span class="hljs-comment">// cf. sun.launcher.LauncherHelper LM_UNKNOWN = 0, LM_CLASS, LM_JAR, LM_MODULE, LM_SOURCE };</span></span></code> </pre> <br><p>  Au√üerdem wird ein Teil der Argumente in das Format <code>-DpropertyName=propertyValue</code> konvertiert. Beispielsweise wird <code>-cp=/path</code> in <code>-Djava.class.path=/path</code> konvertiert.  Dar√ºber hinaus werden solche <code>SystemProperty</code> im <a href="">globalen Array</a> im JVM-HotSpot gespeichert und in der <a href="">ersten Phase der Initialisierung</a> an <code>java.lang.System::props</code> weitergeleitet (In JDK12 wurde der Initialisierungsmechanismus von java.lang.System.props ge√§ndert, mehr in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Commit</a> ). </p><br><p>  Beim Parsen von Argumenten werden auch einige Optionen <code>--list-modules</code> , die nicht von der JVM verarbeitet werden (z. B. <code>--list-modules</code> , die Verarbeitung dieser Option erfolgt zu <a href="">diesem Zeitpunkt</a> direkt im Launcher). </p><br><p>  <strong>III</strong> .  Gabeln Sie einen urspr√ºnglichen Thread und erstellen Sie eine VM darin </p><br><p>  Aber wenn etwas schief gelaufen ist, wird versucht, <a href="">die JVM im Hauptthread</a> zu <a href="">starten.</a> "Probieren Sie es einfach aus." </p><br><p>  Nachdem ich die Frage untersucht hatte, fand ich einen der m√∂glichen Gr√ºnde, warum die JVM nicht im Hauptthread startet.  Tatsache ist, dass (zumindest unter Linux) Pthreads und der Hauptthread mit dem Stack unterschiedlich funktionieren.  Die Gr√∂√üe des Hauptfadens ist durch <code>ulimit -s</code> -s begrenzt, d.h.  Wenn Sie einen beliebig gro√üen Wert festlegen, erhalten Sie einen beliebig gro√üen Stapel.  Der Hauptthread verwendet etwas √Ñhnliches wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MAP_GROWSDOWN</a> , jedoch nicht <code>MAP_GROWSDOWN</code> .  Die Verwendung von <code>MAP_GROWSDOWN</code> in seiner reinen Form ist nicht sicher und, wenn der Speicher mir recht <code>MAP_GROWSDOWN</code> , gesperrt.  Auf meinem Computer <code>MAP_GROWSDOWN</code> keinen Effekt hinzu.  Der Unterschied zwischen der Haupt-Thread-Zuordnung und MAP_GROWSDOWN besteht darin, dass keine andere <code>mmap</code> mit Ausnahme von <code>MAP_FIXED</code> einen Konflikt mit dem Bereich einer m√∂glichen <code>MAP_FIXED</code> kann.  Alles, was von der Software ben√∂tigt wird, ist, den entsprechenden <code>rsp</code> Wert einzustellen, und dann wird das Betriebssystem es herausfinden: Und der Seitenfehler wird verarbeitet und der <a href="">Schutz wird eingestellt</a> .  Dieser Unterschied betrifft eine Reihe von Rechen: <a href="">Beim Bestimmen der Stapelgr√∂√üe des aktuellen Streams</a> , <a href="">beim Erstellen von Schutzseiten</a> </p><br><p>  Wir gehen also davon aus, dass wir im Moment die Optionen erfolgreich analysiert und einen Thread f√ºr die VM erstellt haben.  Danach beginnt der gerade gegabelte Thread mit der Erstellung einer virtuellen Maschine und <a href="">ruft die Funktion Threads :: create_vm auf</a> </p><br><p>  In dieser Funktion wird eine ziemlich gro√üe Anzahl gemacht <del>  schwarze Magie </del>  Initialisierungen werden uns nur an wenigen interessieren. </p><br><h4 id="inicializaciya-intepretatora-i-peredacha-upravleniya-java-kodu">  Initialisierung des Interpreters und √úbertragung der Kontrolle auf den Java-Code </h4><br><p>  F√ºr jede Anweisung im JVM-HotSpot gibt es eine bestimmte Maschinencodevorlage f√ºr eine bestimmte Architektur.  Wenn der Interpreter mit der Ausf√ºhrung einer Anweisung beginnt, sucht er zun√§chst nach der Adresse seiner Vorlage in der speziellen <a href="">DispatchTable-</a> Tabelle.  <a href="">Springen Sie als</a> N√§chstes zur Adresse dieser Vorlage. Nachdem die Ausf√ºhrung der Anweisung abgeschlossen ist, nimmt jvm die Adresse der <a href="">n√§chsten Anweisung in der angegebenen Reihenfolge heraus</a> und beginnt, sie auf die gleiche Weise auszuf√ºhren, und so weiter.  Dieses Verhalten wird mit dem Interpreter nur f√ºr Anweisungen beobachtet, die nicht "versenden", z. B. arithmetische Anweisungen ( <code>xsub</code> , <code>xdiv</code> usw., wobei <code>x</code> - <code>i</code> , <code>l</code> , <code>f</code> , <code>d</code> ).  Sie f√ºhren lediglich arithmetische Operationen aus. </p><br><p>  Im Fall von Prozeduraufrufanweisungen ( <code>invokestatic</code> , <code>invokevirtual</code> usw.) ist die n√§chste <code>invokevirtual</code> Anweisung die erste Anweisung in der aufgerufenen Prozedur.  Solche Anweisungen selbst geben die Adresse der n√§chsten Bytecode-Anweisung an, die in ihrer Vorlage ausgef√ºhrt werden soll. </p><br><p>  Um den Betrieb dieses Computers in <a href=""><code>Threads::create_vm</code></a> , werden eine Reihe von Initialisierungen durchgef√ºhrt, von denen der Interpreter abh√§ngt: </p><br><p>  <strong>I.</strong>  Initialisieren einer Tabelle verf√ºgbarer Bytecodes </p><br><p>  Bevor Sie mit der Initialisierung des Interpreters fortfahren, m√ºssen Sie die Tabelle der verwendeten Bytecodes initialisieren.  Es wird in der Funktion <a href="">Bytecodes :: initialize ausgef√ºhrt</a> und als gut lesbare Bezeichnung dargestellt.  Sein Fragment ist wie folgt: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Java bytecodes // bytecode bytecode name format wide f. result tp stk traps def(_nop , "nop" , "b" , NULL , T_VOID , 0, false); def(_aconst_null , "aconst_null" , "b" , NULL , T_OBJECT , 1, false); def(_iconst_m1 , "iconst_m1" , "b" , NULL , T_INT , 1, false); def(_iconst_0 , "iconst_0" , "b" , NULL , T_INT , 1, false); def(_iconst_1 , "iconst_1" , "b" , NULL , T_INT , 1, false); def(_iconst_2 , "iconst_2" , "b" , NULL , T_INT , 1, false); def(_iconst_3 , "iconst_3" , "b" , NULL , T_INT , 1, false); def(_iconst_4 , "iconst_4" , "b" , NULL , T_INT , 1, false); def(_iconst_5 , "iconst_5" , "b" , NULL , T_INT , 1, false); def(_lconst_0 , "lconst_0" , "b" , NULL , T_LONG , 2, false); def(_lconst_1 , "lconst_1" , "b" , NULL , T_LONG , 2, false); def(_fconst_0 , "fconst_0" , "b" , NULL , T_FLOAT , 1, false); def(_fconst_1 , "fconst_1" , "b" , NULL , T_FLOAT , 1, false); def(_fconst_2 , "fconst_2" , "b" , NULL , T_FLOAT , 1, false); def(_dconst_0 , "dconst_0" , "b" , NULL , T_DOUBLE , 2, false); def(_dconst_1 , "dconst_1" , "b" , NULL , T_DOUBLE , 2, false); def(_bipush , "bipush" , "bc" , NULL , T_INT , 1, false); def(_sipush , "sipush" , "bcc" , NULL , T_INT , 1, false); def(_ldc , "ldc" , "bk" , NULL , T_ILLEGAL, 1, true ); def(_ldc_w , "ldc_w" , "bkk" , NULL , T_ILLEGAL, 1, true ); def(_ldc2_w , "ldc2_w" , "bkk" , NULL , T_ILLEGAL, 2, true );</span></span></code> </pre> <br><p>  In √úbereinstimmung mit dieser Tabelle wird f√ºr jeden Bytecode seine L√§nge festgelegt (die Gr√∂√üe betr√§gt immer 1 Byte, es kann jedoch auch einen Index in <code>ConstantPool</code> , sowie breite Bytecodes), Name, Bytecode und Flags: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Bytecodes::_is_initialized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* Bytecodes::_name [Bytecodes::number_of_codes]; BasicType Bytecodes::_result_type [Bytecodes::number_of_codes]; s_char Bytecodes::_depth [Bytecodes::number_of_codes]; u_char Bytecodes::_lengths [Bytecodes::number_of_codes]; Bytecodes::Code Bytecodes::_java_code [Bytecodes::number_of_codes]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> Bytecodes::_flags [(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;BitsPerByte)*<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre> <br><p>  Diese Parameter werden ferner ben√∂tigt, um Interpreter-Vorlagencode zu generieren. </p><br><p>  <strong>II</strong> .  Cache-Code initialisieren </p><br><p>  Um Code f√ºr Interpreter-Vorlagen zu generieren, m√ºssen Sie zuerst Speicher f√ºr dieses Unternehmen zuweisen.  Die Speicherreservierung f√ºr Cache-Code ist in einer gleichnamigen Funktion <a href="">CodeCache :: initialize ()</a> implementiert.  Wie aus dem folgenden Codeabschnitt dieser Funktion ersichtlich ist </p><br><pre> <code class="cpp hljs"> CodeCacheExpansionSize = align_up(CodeCacheExpansionSize, os::vm_page_size()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SegmentedCodeCache) { <span class="hljs-comment"><span class="hljs-comment">// Use multiple code heaps initialize_heaps(); } else { // Use a single code heap FLAG_SET_ERGO(uintx, NonNMethodCodeHeapSize, 0); FLAG_SET_ERGO(uintx, ProfiledCodeHeapSize, 0); FLAG_SET_ERGO(uintx, NonProfiledCodeHeapSize, 0); ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize); add_heap(rs, "CodeCache", CodeBlobType::All); }</span></span></code> </pre> <br><p>  Der Cache-Code wird durch die Optionen gesteuert - <a href=""><code>-XX:ReservedCodeCacheSize</code></a> , <a href=""><code>-XX:SegmentedCodeCache</code></a> , <a href=""><code>-XX:CodeCacheExpansionSize</code></a> , <a href=""><code>-XX:NonNMethodCodeHeapSize</code></a> , <a href=""><code>-XX:ProfiledCodeHeapSize</code></a> <a href=""><code>-XX:NonProfiledCodeHeapSize</code></a> , <a href=""><code>-XX:NonProfiledCodeHeapSize</code></a> .  Eine kurze Beschreibung dieser Optionen finden Sie unter den Links, zu denen sie f√ºhren.  Zus√§tzlich zur Befehlszeile werden die Werte einiger dieser Optionen ergonomisch angepasst. Wenn beispielsweise der <code>SegmentedCodeCache</code> Wert standardm√§√üig <code>SegmentedCodeCache</code> wird (aus), wird <code>SegmentedCodeCache</code> mit einer Codegr√∂√üe <code>&gt;= 240Mb</code> in <a href="">CompilerConfig :: set_tiered_flags enthalten sein</a> . </p><br><p>  Nach dem Durchf√ºhren von √úberpr√ºfungen wird ein Bereich mit der Gr√∂√üe <code>ReservedCodeCacheSize</code> Bytes <code>ReservedCodeCacheSize</code> .  Wenn sich herausstellt, dass <code>SegmentedCodeCache</code> , ist dieser Bereich in Teile unterteilt: JIT-kompilierte Methoden, Stichroutinen usw. </p><br><p>  <strong>III</strong> .  Initialisierung von Interpreter-Mustern </p><br><p>  Nachdem die Bytecode-Tabelle und der Cache-Code initialisiert wurden, k√∂nnen Sie mit der Codegenerierung der Interpreter-Vorlagen fortfahren.  Zu diesem Zweck reserviert der Interpreter einen Puffer aus dem zuvor initialisierten Cache-Code.  In jeder Phase der Codegenerierung werden <a href="">Codelets</a> - kleine Codeabschnitte - aus dem <a href="">Puffer herausgeschnitten</a> .  Nach Abschluss der aktuellen Generation wird der Teil des Codelets, der nicht vom Code verwendet wird, freigegeben und steht f√ºr nachfolgende Codegenerierungen zur Verf√ºgung. </p><br><p>  Betrachten Sie jeden dieser Schritte einzeln: </p><br><ul><li>  <a href="">slow_signature_handler</a> </li></ul><br><pre> <code class="cpp hljs"> { <span class="hljs-function"><span class="hljs-function">CodeletMark </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_masm, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"slow signature handler"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; AbstractInterpreter::_slow_signature_handler = generate_slow_signature_handler(); }</code> </pre><br><p>  Der Signaturhandler wird verwendet, um Argumente f√ºr Aufrufe nativer Methoden vorzubereiten.  In diesem Fall wird ein generischer Handler generiert, wenn die native Methode beispielsweise mehr als 13 Argumente enth√§lt (ich habe sie im Debugger nicht √ºberpr√ºft, aber nach dem <a href="">Code</a> sollte sie so aussehen). </p><br><ul><li>  <a href="">ung√ºltige Bytecode-Verarbeitung</a> </li></ul><br><pre> <code class="cpp hljs"> { <span class="hljs-function"><span class="hljs-function">CodeletMark </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_masm, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"error exits"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; _unimplemented_bytecode = generate_error_exit(<span class="hljs-string"><span class="hljs-string">"unimplemented bytecode"</span></span>); _illegal_bytecode_sequence = generate_error_exit(<span class="hljs-string"><span class="hljs-string">"illegal bytecode sequence - method not verified"</span></span>); }</code> </pre> <br><p>  Die VM √ºberpr√ºft Klassendateien w√§hrend der Initialisierung. Dies ist jedoch der Fall, wenn die Argumente auf dem Stapel nicht das erforderliche Format oder den Bytecode haben, den die VM nicht kennt.  Diese Stubs werden beim Generieren von Vorlagencode f√ºr jeden der Bytecodes verwendet. </p><br><ul><li>  <a href="">R√ºckkehr von der Funktion</a> </li></ul><br><p>  Nach dem Aufruf der Prozeduren m√ºssen die Daten aus dem Frame-Stack wiederhergestellt werden, der vor dem Aufruf der Prozedur vorhanden war, von der die R√ºckgabe erfolgt. </p><br><ul><li>  <a href="">Earlyret</a> </li></ul><br><p>  Wird verwendet, wenn die Laufzeit von einem Interpreter aufgerufen wird. </p><br><ul><li><p>  <a href="">Ausnahmen werfen</a> </p><br></li><li><p>  <a href="">Methodeneintrittspunkte</a> </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> method_entry(kind) \ { CodeletMark cm(_masm, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"method entry point (kind = "</span></span></span><span class="hljs-meta"> #kind </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">")"</span></span></span><span class="hljs-meta">); \ Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind); \ Interpreter::update_cds_entry_table(Interpreter::kind); \ }</span></span></code> </pre> <br><p>  Wird je nach Art der Methode als Makro dargestellt.  Im allgemeinen Fall wird die Vorbereitung des <a href="">interpretierten Stapelrahmens</a> durchgef√ºhrt, StackOverflow-Pr√ºfung, Stack-Banging.  F√ºr native Methoden wird ein Signaturhandler definiert. </p><br></li><li><p>  <a href="">Generierung von Bytecode-Vorlagen</a> </p><br></li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Bytecodes set_entry_points_for_all_bytes(); // installation of code in other places in the runtime // (ExcutableCodeManager calls not needed to copy the entries) set_safepoints_for_all_bytes();</span></span></code> </pre> <br><p>  Um die Anweisung auszuf√ºhren, m√ºssen sich Operanden in der VM-Spezifikation im Operandenstapel befinden. Dies hindert HotSpot jedoch nicht daran, sie im Register zwischenzuspeichern.  Eine <a href="">Aufz√§hlung wird</a> verwendet, um den aktuellen Status der Oberseite des Stapels zu bestimmen. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TosState { <span class="hljs-comment"><span class="hljs-comment">// describes the tos cache contents btos = 0, // byte, bool tos cached ztos = 1, // byte, bool tos cached ctos = 2, // char tos cached stos = 3, // short tos cached itos = 4, // int tos cached ltos = 5, // long tos cached ftos = 6, // float tos cached dtos = 7, // double tos cached atos = 8, // object cached vtos = 9, // tos not cached number_of_states, ilgl // illegal state: should not occur };</span></span></code> </pre> <br><p>  Jeder Befehl definiert die Eingabe- und Ausgabezust√§nde der <code>TosState</code> Oberseite des Stapels, und die Erzeugung von Mustern erfolgt abh√§ngig von diesem Zustand.  Diese Vorlagen werden in einer lesbaren <a href="">Vorlagentabelle</a> initialisiert.  Ein Fragment dieser Tabelle lautet wie folgt: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// interpr. templates // Java spec bytecodes ubcp|disp|clvm|iswd in out generator argument def(Bytecodes::_nop , ____|____|____|____, vtos, vtos, nop , _ ); def(Bytecodes::_aconst_null , ____|____|____|____, vtos, atos, aconst_null , _ ); def(Bytecodes::_iconst_m1 , ____|____|____|____, vtos, itos, iconst , -1 ); def(Bytecodes::_iconst_0 , ____|____|____|____, vtos, itos, iconst , 0 ); def(Bytecodes::_iconst_1 , ____|____|____|____, vtos, itos, iconst , 1 ); def(Bytecodes::_iconst_2 , ____|____|____|____, vtos, itos, iconst , 2 ); def(Bytecodes::_iconst_3 , ____|____|____|____, vtos, itos, iconst , 3 ); def(Bytecodes::_iconst_4 , ____|____|____|____, vtos, itos, iconst , 4 ); def(Bytecodes::_iconst_5 , ____|____|____|____, vtos, itos, iconst , 5 ); def(Bytecodes::_lconst_0 , ____|____|____|____, vtos, ltos, lconst , 0 ); def(Bytecodes::_lconst_1 , ____|____|____|____, vtos, ltos, lconst , 1 ); def(Bytecodes::_fconst_0 , ____|____|____|____, vtos, ftos, fconst , 0 ); def(Bytecodes::_fconst_1 , ____|____|____|____, vtos, ftos, fconst , 1 ); def(Bytecodes::_fconst_2 , ____|____|____|____, vtos, ftos, fconst , 2 ); def(Bytecodes::_dconst_0 , ____|____|____|____, vtos, dtos, dconst , 0 ); def(Bytecodes::_dconst_1 , ____|____|____|____, vtos, dtos, dconst , 1 ); def(Bytecodes::_bipush , ubcp|____|____|____, vtos, itos, bipush , _ ); def(Bytecodes::_sipush , ubcp|____|____|____, vtos, itos, sipush , _ );</span></span></code> </pre> <br><p>  Wir werden uns besonders f√ºr <code>in</code> , <code>out</code> und <code>generator</code> Spalten interessieren. </p><br><p>  <code>in</code> - der Status der Oberseite des Stapels zum Zeitpunkt des Beginns der Anweisung <br>  <code>out</code> - Zustand der Oberseite des Stapels zum Zeitpunkt des Abschlusses der Anweisung <br>  <code>generator</code> - Generator der Maschinenanweisungscode-Vorlage </p><br><p>  Die allgemeine Ansicht der Vorlage f√ºr alle Bytecodes kann wie folgt beschrieben werden: </p><br><ol><li><p>  Wenn f√ºr den Befehl kein Versandbit gesetzt ist, wird der Befehlsprolog ausgef√ºhrt (No-Op auf x86). </p><br></li><li><p>  Mit dem <code>generator</code> wird Maschinencode generiert </p><br></li><li><p>  Wenn das Versandbit f√ºr den Befehl nicht gesetzt ist, wird der √úbergang zum n√§chsten Befehl in der Reihenfolge ausgef√ºhrt, abh√§ngig vom <code>out</code> der Oberseite des Stapels, der f√ºr den n√§chsten Befehl eingeht </p><br></li></ol><br><p>  Die Einstiegspunktadresse f√ºr die resultierende Vorlage wird in der globalen Tabelle gespeichert und kann zum Debuggen verwendet werden. </p><br><p>  In HotSpot ist der folgende relativ dumme Code daf√ºr verantwortlich: </p><br><div class="spoiler">  <b class="spoiler_title">Anweisungscode-Generator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TemplateInterpreterGenerator::set_entry_points(Bytecodes::Code code) { <span class="hljs-function"><span class="hljs-function">CodeletMark </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_masm, Bytecodes::name(code), code)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// initialize entry points assert(_unimplemented_bytecode != NULL, "should have been generated before"); assert(_illegal_bytecode_sequence != NULL, "should have been generated before"); address bep = _illegal_bytecode_sequence; address zep = _illegal_bytecode_sequence; address cep = _illegal_bytecode_sequence; address sep = _illegal_bytecode_sequence; address aep = _illegal_bytecode_sequence; address iep = _illegal_bytecode_sequence; address lep = _illegal_bytecode_sequence; address fep = _illegal_bytecode_sequence; address dep = _illegal_bytecode_sequence; address vep = _unimplemented_bytecode; address wep = _unimplemented_bytecode; // code for short &amp; wide version of bytecode if (Bytecodes::is_defined(code)) { Template* t = TemplateTable::template_for(code); assert(t-&gt;is_valid(), "just checking"); set_short_entry_points(t, bep, cep, sep, aep, iep, lep, fep, dep, vep); } if (Bytecodes::wide_is_defined(code)) { Template* t = TemplateTable::template_for_wide(code); assert(t-&gt;is_valid(), "just checking"); set_wide_entry_point(t, wep); } // set entry points EntryPoint entry(bep, zep, cep, sep, aep, iep, lep, fep, dep, vep); Interpreter::_normal_table.set_entry(code, entry); Interpreter::_wentry_point[code] = wep; } //... void TemplateInterpreterGenerator::set_short_entry_points(Template* t, address&amp; bep, address&amp; cep, address&amp; sep, address&amp; aep, address&amp; iep, address&amp; lep, address&amp; fep, address&amp; dep, address&amp; vep) { assert(t-&gt;is_valid(), "template must exist"); switch (t-&gt;tos_in()) { case btos: case ztos: case ctos: case stos: ShouldNotReachHere(); // btos/ctos/stos should use itos. break; case atos: vep = __ pc(); __ pop(atos); aep = __ pc(); generate_and_dispatch(t); break; case itos: vep = __ pc(); __ pop(itos); iep = __ pc(); generate_and_dispatch(t); break; case ltos: vep = __ pc(); __ pop(ltos); lep = __ pc(); generate_and_dispatch(t); break; case ftos: vep = __ pc(); __ pop(ftos); fep = __ pc(); generate_and_dispatch(t); break; case dtos: vep = __ pc(); __ pop(dtos); dep = __ pc(); generate_and_dispatch(t); break; case vtos: set_vtos_entry_points(t, bep, cep, sep, aep, iep, lep, fep, dep, vep); break; default : ShouldNotReachHere(); break; } } //... void TemplateInterpreterGenerator::generate_and_dispatch(Template* t, TosState tos_out) { if (PrintBytecodeHistogram) histogram_bytecode(t); #ifndef PRODUCT // debugging code if (CountBytecodes || TraceBytecodes || StopInterpreterAt &gt; 0) count_bytecode(); if (PrintBytecodePairHistogram) histogram_bytecode_pair(t); if (TraceBytecodes) trace_bytecode(t); if (StopInterpreterAt &gt; 0) stop_interpreter_at(); __ verify_FPU(1, t-&gt;tos_in()); #endif // !PRODUCT int step = 0; if (!t-&gt;does_dispatch()) { step = t-&gt;is_wide() ? Bytecodes::wide_length_for(t-&gt;bytecode()) : Bytecodes::length_for(t-&gt;bytecode()); if (tos_out == ilgl) tos_out = t-&gt;tos_out(); // compute bytecode size assert(step &gt; 0, "just checkin'"); // setup stuff for dispatching next bytecode if (ProfileInterpreter &amp;&amp; VerifyDataPointer &amp;&amp; MethodData::bytecode_has_profile(t-&gt;bytecode())) { __ verify_method_data_pointer(); } __ dispatch_prolog(tos_out, step); } // generate template t-&gt;generate(_masm); // advance if (t-&gt;does_dispatch()) { #ifdef ASSERT // make sure execution doesn't go beyond this point if code is broken __ should_not_reach_here(); #endif // ASSERT } else { // dispatch to next bytecode __ dispatch_epilog(tos_out, step); } }</span></span></code> </pre> </div></div><br><p>     ,     .         JVM.       Java-    .       <a href="">JavaCalls</a> .     JVM  ,     <a href="">  main</a> . </p><br><h4 id="primer">  Beispiel </h4><br><p>  ,        ,     : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span></span>{ Sum.sum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); } }</code> </pre> <br><p>         <code>Sum.sum(II)</code> . </p><br><p>   2  <code>javac -c *.java</code>    ,      . <br>  <code>Sum.sum</code> : </p><br><pre> <code class="plaintext hljs"> descriptor: (II)I flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=2 0: iload_0 1: iload_1 2: iadd 3: ireturn LineNumberTable: line 3: 0</code> </pre> <br><p>  Main.main </p><br><pre> <code class="plaintext hljs"> descriptor: ([Ljava/lang/String;)V flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: iconst_2 1: iconst_3 2: invokestatic #2 // Method Sum.sum:(II)I 5: pop 6: return LineNumberTable: line 13: 0 line 14: 6</code> </pre> <br><p>   ,          ‚Äî      . </p><br><p>   <code>invokestatic</code> '  x86   -   HotSpot    <a href=""></a> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TemplateTable::invokestatic(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> byte_no) { transition(vtos, vtos); assert(byte_no == f1_byte, <span class="hljs-string"><span class="hljs-string">"use this argument"</span></span>); prepare_invoke(byte_no, rbx); <span class="hljs-comment"><span class="hljs-comment">// get f1 Method* // do the call __ profile_call(rax); __ profile_arguments_type(rax, rbx, rbcp, false); __ jump_from_interpreted(rbx, rax); }</span></span></code> </pre> <br><p> <code>byte_no == f1_byte</code> ‚Äî   <code>ConstantPoolCache</code> ,    , <code>rbx</code> ‚Äî ,      <code>Method *</code> .      :  , ,      ( <code>method_entry</code>    ). </p><br><p>   <code>prepare_invoke</code> .  ,     <code>invokestatic</code>    <code>ConstantPool</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Constant_Methodref_Info</code></a> .   HotSpot    .  2      .. <a href=""><code>ConstantPoolCache</code></a> . <code>ConstantPoolCache</code>       ,    (,    <code>ConstantPoolCacheEntry</code>   ,      ).     <code>ConstantPoolCacheEntry</code> ,      (   0)        / .   ,         <code>ConstantPool</code> ,        <code>ConstantPoolCache</code>      ( x86 Little Endian). </p><br><p> , ,  HotSpot    <code>prepare_invoke</code> ‚Äî     <code>ConstantPoolCache</code> .  ,   ,     <code>ConstantPoolCacheEntry</code>    </p><br><pre> <code class="cpp hljs"> __ get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, <span class="hljs-number"><span class="hljs-number">1</span></span>, index_size); __ cmpl(temp, code); <span class="hljs-comment"><span class="hljs-comment">// have we resolved this bytecode? __ jcc(Assembler::equal, resolved); // resolve first time through address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache); __ movl(temp, code); __ call_VM(noreg, entry, temp); // Update registers with resolved info __ get_cache_and_index_at_bcp(Rcache, index, 1, index_size); __ bind(resolved);</span></span></code> </pre> <br><p>  ,    <code>InterpreterRuntime::resolve_from_cache</code> . </p><br><p>       receiver'a   ,         .     (, ,  ,  <code>ConstantPoolCache</code>   <code>&lt;clinit&gt;</code> ,      ). <a href="">  </a>      define class,    <code>EagerInitialization</code> ( ,      ,           :)).     HotSpot   ( CDS  )     . </p><br><p>  ,         ,   <code>ConstantPoolCacheEntry</code>    .      <code>Method *</code>  <code>rbx</code> ,   ,         . </p><br><p>       <code>Sum.sum(2, 3)</code> .      gdb-script <code>sum.gdb</code> : </p><br><pre> <code class="plaintext hljs">#    java file /home/dmitrii/jdk12/build/linux-x86_64-server-fastdebug/images/jdk/bin/java # gdb    SEGV' #,   https://hg.openjdk.java.net/jdk/jdk12/file/06222165c35f/src/hotspot/cpu/x86/vm_version_x86.cpp#l361 handle SIGSEGV nostop noprint #       set breakpoint pending on #    , #    set pagination off #      main b PostJVMInit commands #   , #    set $buffer = malloc(1000) #   . #jmp       # invokestatic b *AbstractInterpreter::_entry_table[0] thread 2 commands #     invokestatic, # Method*   rbx set $mthd = (Method *) $rbx #    $buffer call $mthd-&gt;name_and_sig_as_C_string($buffer, 1000) if strcmp()($buffer, "Sum.sum(II)I") == 0 #  iload_0,     b *TemplateInterpreter::_normal_table._table[vtos][26] thread 2 #  iload_1,   - int,  #  iload_0 b *TemplateInterpreter::_normal_table._table[itos][27] thread 2 #   iadd b *TemplateInterpreter::_normal_table._table[itos][96] thread 2 end c end c end r -cp . Main</code> </pre><br><p>    <code>gdb -x sum.gdb</code> ,       <code>Sum.sum</code> </p><br><pre> <code class="plaintext hljs">$453 = 0x7ffff7fdcdd0 "Sum.sum(II)I"</code> </pre> <br><p>   <code>layout asm</code> ,    ,   <a href="">generate_normal_entry</a> .      -,  StackOverflow, stack-banging    dispatch    <code>iload_0</code>    .       : </p><br><pre> <code class="plaintext hljs">0x7fffd828fa1f mov eax,DWORD PTR [r14] ;, iload_0 0x7fffd828fa22 movzx ebx,BYTE PTR [r13+0x1] ;   0x7fffd828fa27 inc r13 ; bcp (byte code pointer) 0x7fffd828fa2a movabs r10,0x7ffff717e8a0 ; DispatchTable 0x7fffd828fa34 jmp QWORD PTR [r10+rbx*8] ;jump     </code> </pre> <br><p>        <code>rax</code> ,        </p><br><pre> <code class="plaintext hljs">0x7fffd828fabe push rax ;     ;   ,      0x7fffd828fabf mov eax,DWORD PTR [r14-0x8] 0x7fffd828fac3 movzx ebx,BYTE PTR [r13+0x1] 0x7fffd828fac8 inc r13 0x7fffd828facb movabs r10,0x7ffff717e8a0 0x7fffd828fad5 jmp QWORD PTR [r10+rbx*8]</code> </pre> <br><p>       <code>iadd</code> : </p><br><pre> <code class="plaintext hljs">0x7fffd8292ba7 mov edx,DWORD PTR [rsp] ; ,     iload_1 0x7fffd8292baa add rsp,0x8 ; rsp    0x7fffd8292bae add eax,edx ;   0x7fffd8292bb0 movzx ebx,BYTE PTR [r13+0x1] 0x7fffd8292bb5 inc r13 0x7fffd8292bb8 movabs r10,0x7ffff717e8a0 0x7fffd8292bc2 jmp QWORD PTR [r10+rbx*8]</code> </pre> <br><p>    <code>gdb</code>  <code>eax</code>  <code>edx</code>    ,    </p><br><pre> <code class="plaintext hljs">(gdb) p $eax $457 = 3 (gdb) p $edx $458 = 2</code> </pre> <br><p>       ,     <code>Sum.sum</code> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469291/">https://habr.com/ru/post/de469291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469271/index.html">Serialisieren und Deserialisieren von .NET Core vs Go-Daten</a></li>
<li><a href="../de469275/index.html">Wie ich es an 18 US-Universit√§ten getan habe</a></li>
<li><a href="../de469277/index.html">Wer sind DevOps?</a></li>
<li><a href="../de469287/index.html">Kampfgolems von den Karten. Wie wir das Spiel in die Parobot Card League verwandelt haben</a></li>
<li><a href="../de469289/index.html">Was ist Margin Trading an der B√∂rse und wie funktioniert es?</a></li>
<li><a href="../de469295/index.html">‚ÄûFunde eines Audio-Mannes‚Äú: Ein Baum von Musikgenres, ein Xylophon von GitHub-Events und Satellitensendungen</a></li>
<li><a href="../de469297/index.html">Eisenkonferenzen. SOM i.MX6, Aliceduino, Keras + STM32Cube.AI</a></li>
<li><a href="../de469299/index.html">Sofortige Ansicht, Sofort und Unzug√§nglich</a></li>
<li><a href="../de469301/index.html">Agilean: Lean + Agile</a></li>
<li><a href="../de469303/index.html">Andrei Belyaev √ºber Reflexion in Java beim Treffen jug.msk.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>