<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏻 📕 👧🏾 任务计划程序演变 👵🏿 ↔️ 💗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们正在使用的iFunny应用程序已经在商店中使用了五年以上。 在这段时间里，移动团队不得不经历许多不同的方法以及工具之间的迁移，而一年前，有一段时间需要从自写解决方案切换到更“时尚”和更广泛的方向。 本文只是对研究的内容，研究的解决方案以及最终的解决方案进行了小幅挤压。 

 为什么我们需要所有这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>任务计划程序演变</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/434680/"><img src="https://habrastorage.org/webt/bv/mr/ps/bvmrpspwu-kyhojb5tiu4lqbdi8.jpeg"><br><br> 我们正在使用的iFunny应用程序已经在商店中使用了五年以上。 在这段时间里，移动团队不得不经历许多不同的方法以及工具之间的迁移，而一年前，有一段时间需要从自写解决方案切换到更“时尚”和更广泛的方向。 本文只是对研究的内容，研究的解决方案以及最终的解决方案进行了小幅挤压。 <a name="habracut"></a><br><br>  <b>为什么我们需要所有这些？</b> <br><br> 为了纪念本文的内容以及为什么这个主题对Android开发团队非常重要，让我们立即做出决定： <br><br><ol><li> 在许多情况下，您需要在活动用户界面框架之外运行任务。 </li><li> 系统对此类任务的启动施加了很多限制； </li><li> 事实证明，在每种现有解决方案之间进行选择非常困难，因为每种工具都有其优缺点。 </li></ol><br><h3>  <b>事件发展的年代</b> </h3><br>  <b>Android 0</b> <b><br></b> <h3>  AlarmManager，处理程序，服务 </h3><br> 最初，实施他们的解决方案是为了基于服务启动基于后台的任务。 还有一种机制可以将任务链接到生命周期，并可以取消和恢复它们。 这很适合团队使用很长时间，因为该平台没有对此类任务施加任何限制。 <br>  Google建议根据以下图表进行操作： <br><br><img src="https://habrastorage.org/webt/e-/46/zn/e-46znleyxvynpm35pbebgrkdhk.png"><br><br> 到2018年底，了解这一点是没有意义的，足以评估灾难的规模。 <br> 实际上，没有人关心后台发生了多少工作。 应用程序完成了他们想要的工作，并在需要时完成了工作。 <br><br>  <i><b>优点</b> ：</i> <i><br></i>  <i>随处可见；</i> <i><br></i>  <i>所有人都可以使用。</i> <i><br><br></i>  <i><b>缺点</b> ：</i> <i><br></i>  <i>系统以各种方式限制工作；</i> <i><br></i>  <i>没有条件发射；</i> <i><br></i>  <i>该API最少，您需要编写大量代码。</i> <i><br></i> <br>  <b>Android 5.棒棒糖</b> <b><br></b> <h3>  Jobcheduler </h3><br> 在接近2015年的5（！）年之后，Google注意到任务执行效率低下。 用户开始经常抱怨说，他们的手机只是躺在桌子上或放在口袋里就没电了。 <br><br> 随着Android 5的发布，出现了类似JobScheduler的工具。 这是一种可以在后台进行各种工作的机制，由于启动这些任务的集中系统以及为启动该任务设定条件的能力，该机制的开始得到了优化和简化。 <br><br> 在代码中，所有这些看起来都非常简单：宣布了其中包含开始和结束事件的服务。 <br> 从细微差别：如果要异步执行工作，则需要从onStartJob启动流； 最主要的是不要忘记在工作结束时调用jobFinished方法，否则系统不会放开WakeLock，您的任务将不会被视为已完成并且会丢失。 <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br> 您可以从应用程序中的任何位置启动此工作。 任务在我们的流程中执行，但在IPC级别启动。 有一个集中的机制来控制它们的执行，并仅在必要时才唤醒应用程序。 您还可以设置各种触发条件，并通过捆绑包传输数据。 <br><br><pre> <code class="java hljs">JobInfo task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobInfo.Builder(JOB_ID, serviceName) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); JobScheduler scheduler = (JobScheduler) context.getSystemService(JOB_SCHEDULER_SERVICE); scheduler.schedule(task);</code> </pre> <br> 总的来说，相比什么都没有，这已经是什么了。 但是，该机制仅在API 21中可用，并且在Android 5.0发行时，停止支持所有旧设备（已经过去了3年，并且我们仍然支持Fours）会很奇怪。 <br><br>  <i><b>优点</b> ：</i> <i><br></i>  <i>API很简单；</i> <i><br></i>  <i>发射条件。</i> <i><br></i> <br>  <b><i>缺点</i></b> ： <br>  <s>从API 21开始可用</s> <br> 实际上，仅使用API​​ 23； <br> 容易犯错误。 <br><br>  <b>Android 5.棒棒糖</b> <b><br></b> <h3>  <b>GCM网络经理</b> </h3><br> 还介绍了JobScheduler的类似物-GCM网络管理器。 这是一个提供相似功能的库，但已经与API 9一起使用。确实，它需要Google Play服务作为回报。 显然，JobScheduler工作所需的功能不仅开始通过Android版本提供，而且还开始在GPS级别提供。 应当指出，该框架的开发人员很快改变了主意，并决定不将他们的未来与GPS连接起来。 多亏了他们。 <br><br> 一切看起来都完全相同。 相同的服务： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmNetworkManagerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmTaskService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TaskParams taskParams)</span></span></span><span class="hljs-function"> </span></span>{ doWork(taskParams); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br> 相同的任务启动： <br><br><pre> <code class="java hljs">OneoffTask task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OneoffTask.Builder() .setService(GcmNetworkManagerService.class) .setTag(TAG) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); GcmNetworkManager mGcmNetworkManager = GcmNetworkManager.getInstance(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); mGcmNetworkManager.schedule(task);</code> </pre> <br> 架构的相似性是由继承的功能和在工具之间进行简单迁移的愿望所决定的。 <br><br>  <i><b>优点</b> ：</i> <i><br></i>  <i>与JobScheduler类似的API；</i> <i><br></i>  <i>从API 9开始可用。</i> <i><br><br></i>  <i><b>缺点</b> ：</i> <i><br></i>  <i>您必须拥有Google Play服务</i> <i><br></i>  <i>容易犯错误。</i> <br><br>  <b>Android 5.棒棒糖</b> <b><br></b> <h3>  <b>唤醒广播接收器</b> </h3><br> 接下来，我将简要介绍JobScheduler中使用的一种基本机制，开发人员可以直接使用。 这是WakeLock及其基础的WakefulBroadcastReceiver。 <br><br> 使用WakeLock，可以防止系统进入挂起状态，即保持设备处于活动状态。 如果我们想做一些重要的工作，这是必要的。 <br> 创建WakeLock时，可以指定其设置：按住CPU，屏幕或键盘。 <br><br><pre> <code class="java hljs">PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE) PowerManager.WakeLock wl = pm.newWakeLock(PARTIAL_WAKE_LOCK, <span class="hljs-string"><span class="hljs-string">"name"</span></span>) wl.acquire(timeout);</code> </pre> <br> 基于此机制，WakefulBroadcastReceiver可以工作。 我们启动服务并按住WakeLock。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleWakefulReceiver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WakefulBroadcastReceiver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ Intent service = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, SimpleWakefulService.class); startWakefulService(context, service); } }</code> </pre> <br> 服务完成必要的工作后，我们通过类似的方法将其释放。 <br><br> 通过4个版本，此BroadcastReceiver将被弃用，并在developer.android.com上介绍以下替代方案： <br><br><ul><li>  JobScheduler; </li><li> 协同剑 </li><li> 下载管理器 </li><li> 用于窗口的FLAG_KEEP_SCREEN_ON。 </li></ul><br>  <b>Android 6.棉花糖</b> <b><br></b> <h3>  <b>DozeMode：随时随地睡眠</b> </h3><br> 然后Google开始对设备上运行的应用程序进行各种优化。 但是，对用户而言最优化的是对开发人员的限制。 <br><br> 第一步是DozeMode，如果设备闲置了一段时间，它将进入睡眠模式。 在第一个版本中，它持续一个小时，在后续版本中，睡眠时间减少到30分钟。 手机会定期唤醒，执行所有待处理的任务，然后再次入睡。  DozeMode窗口以指数形式展开。 可以通过adb跟踪模式之间的所有转换。 <br><br> 当发生DozeMode时，会对应用程序施加以下限制： <br><br><ul><li> 系统将忽略所有WakeLock； </li><li>  AlarmManager延迟； </li><li>  JobScheduler无法正常工作； </li><li>  SyncAdapter无法正常工作； </li><li> 网络访问受到限制。 </li></ul><br> 您也可以将应用程序添加到白名单中，这样它就不会受到DozeMode的限制，但是至少三星完全忽略了此列表。 <br><br>  <b>Android 6.棉花糖</b> <b><br></b> <h3>  <b>AppStandby：不活动的应用程序</b> </h3><br> 系统识别不活动的应用程序，并对它们施加与DozeMode中相同的限制。 <br> 在以下情况下，会将应用程序发送到隔离： <br><br><ul><li> 在前台没有进程； </li><li> 没有有效的通知； </li><li> 未添加到排除列表。 </li></ul><br>  <b>Android 7.牛轧糖</b> <b><br></b> <h3>  <b>背景优化。</b>  <b>斯维尔特</b> </h3><br>  Svelte是一个项目，其中Google试图优化应用程序和系统本身的RAM消耗。 <br> 在Android 7中，在该项目的框架内，已确定隐式广播不是很有效，因为它们被大量应用程序监听，并且当这些事件发生时，系统会花费大量资源。 因此，清单中禁止声明以下类型的事件： <br><br><ul><li>  CONNECTIVITY_ACTION; </li><li>  ACTION_NEW_PICTURE; </li><li>  ACTION_NEW_VIDEO。 </li></ul><br>  <b>Android 7.牛轧糖</b> <b><br></b> <h3>  <b>FirebaseJobDispatcher</b> </h3><br> 同时，发布了任务启动框架的新版本-FirebaseJobDispatcher。 实际上，这是完整的GCM NetworkManager，它经过整理和灵活一些。 <br><br> 在视觉上，一切看起来都完全一样。 相同的服务： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br> 他之间的唯一区别是安装驱动程序的能力。 驱动程序是负责任务启动策略的类。 <br><br> 任务的启动本身并没有随着时间而改变。 <br><br><pre> <code class="java hljs">FirebaseJobDispatcher dispatcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirebaseJobDispatcher(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GooglePlayDriver(context)); Job task = dispatcher.newJobBuilder() .setService(FirebaseJobDispatcherService.class) .setTag(TAG) .setConstraints(Constraint.ON_UNMETERED_NETWORK, Constraint.DEVICE_IDLE) .build(); dispatcher.mustSchedule(task);</code> </pre><br>  <i><b>优点</b> ：</i> <i><br></i>  <i>与JobScheduler类似的API；</i> <i><br></i>  <i>从API 9开始可用。</i> <i><br><br></i>  <i><b>缺点</b> ：</i> <i><br></i>  <i>您必须拥有Google Play服务</i> <i><br></i>  <i>容易犯错误。</i> <i><br></i> <br> 安装我的驱动程序摆脱GPS的做法令人鼓舞。 我们甚至进行了搜索，但最终找到了以下内容： <br><br><img src="https://habrastorage.org/webt/3n/39/ua/3n39uanajermu--vb5qrzgfl8jq.png"><br><br><img src="https://habrastorage.org/webt/zm/rq/i3/zmrqi3pnt_0hx8lcspdy8k6xio8.png"><br><br>  Google知道这一点，但是这些任务仍然存在数年。 <br><br>  <b>Android 7.牛轧糖</b> <b><br></b> <h3>  <b>Evernote的Android Job</b> </h3><br> 结果，社区无法忍受，一个自制的解决方案以Evernote的图书馆形式出现。 它不仅是唯一的解决方案，而且还是Evernote的解决方案，它能够建立自己的地位并“融入人民”。 <br><br> 从体系结构的角度来看，该库比其前身更方便。 <br> 出现了负责创建任务的实体。 对于JobScheduler，它们是通过反射创建的。 <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJobCreator</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobCreator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tag: String)</span></span></span><span class="hljs-function">: Job? </span></span>{ when (tag) { SendLogsJob.TAG -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SendLogsJob() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } }</code> </pre> <br> 有一个单独的类，即任务本身。 在JobScheduler中，所有这些都被转储到onStartJob内部的开关中。 <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Params)</span></span></span><span class="hljs-function">: Result </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doWork(params) } }</code> </pre> <br> 任务的启动是相同的，但Evernote除了继承的事件外，还添加了自己的任务，例如启动日常任务，唯一任务以及在窗口内启动。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobRequest.Builder(JOB_ID) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED) .build() .scheduleAsync();</code> </pre> <br>  <i><b>优点</b> ：</i> <i><br></i>  <i>方便的API;</i> <i><br></i>  <i>所有版本均受支持；</i> <i><br></i>  <i>不需要Google Play服务。</i> <i><br><br></i>  <i><b>缺点</b> ：</i> <i><br></i>  <i>第三方解决方案。</i> <i><br></i> <br> 伙计们积极支持他们的图书馆。 尽管存在很多关键问题，但它适用于所有版本和所有设备。 结果，去年我们的Android团队选择了Evernote的解决方案，因为Google的库削减了他们无法支持的大量设备。 <br> 在内部，她在极端情况下使用AlarmManager研究Google的解决方案。 <br><br>  <b>Android 8. Oreo</b> <b><br></b> <h3>  <b>后台执行限制</b> </h3><br> 让我们回到我们的局限性。 随着新的Android的到来，新的优化方法已经出现。 谷歌的家伙发现了另一个问题。 这次，事实证明整个过程都在服务和广播中（是的，没有新内容）。 <br><br><ul><li>  <s>如果后台有应用程序，则为startService</s> </li><li>  <s>清单中的隐式广播</s> </li></ul><br> 首先，禁止从后台启动服务。 在“法律框架”中，仅保留前台服务。 现在可以说服务已过时。 <br> 第二个限制是相同的广播。 这次禁止在清单中注册所有隐式广播。 隐式广播是一种广播，不仅仅用于我们的应用。 例如，有动作ACTION_PACKAGE_REPLACED，有ACTION_MY_PACKAGE_REPLACED。 因此，第一个是隐式的。 <br><br> 但是，仍然可以通过Context.registerBroadcast注册任何广播。 <br><br>  <b>Android 9. Pie</b> <b><br></b> <h3>  <b>工作经理</b> </h3><br> 关于此优化尚未停止。 就能耗而言，这些设备也许开始迅速而谨慎地工作； 也许用户对此抱怨较少。 <br> 在Android 9中，该框架的开发人员彻底使用了该工具来启动任务。 为了解决所有紧迫的问题，在Google I / O上引入了一个库，用于启动WorkManager的后台任务。 <br><br>  Google最近一直在尝试塑造其对Android应用程序体系结构的愿景，并为开发人员提供为此所需的工具。 因此，存在带有LiveData，ViewModel和Room的建筑组件。  WorkManager看起来是对其方法和范例的合理补充。 <br><br> 如果我们谈论WorkManager的内部布置方式，则其中没有技术突破。 实际上，这是现有解决方案的包装：JobScheduler，FirebaseJobDispatcher和AlarmManager。 <br><br><div class="spoiler">  <b class="spoiler_title">createBestAvailableBackgroundScheduler</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Scheduler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBestAvailableBackgroundScheduler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context, WorkManager)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &gt;= MIN_JOB_SCHEDULER_API_LEVEL) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemJobScheduler(context, workManager); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tryCreateFirebaseJobScheduler(context); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemAlarmScheduler(context); } }</code> </pre> <br></div></div><br> 选择代码非常简单。 但应注意的是，JobScheduler从API 21开始可用，但由于第一个版本相当不稳定，因此它们仅与API 23一起使用。 <br><br> 如果版本低于23，则通过反射尝试找到FirebaseJobDispatcher，否则使用AlarmManager。 <br><br> 值得注意的是，包装器的包装非常灵活。 这次，开发人员将所有内容分解为单独的实体，在结构上看起来很方便： <br><br><ul><li> 工人-工作逻辑； </li><li>  WorkRequest-任务启动的逻辑； </li><li>  WorkRequest.Builder-参数； </li><li> 约束-条件； </li><li>  WorkManager-管理任务的经理； </li><li>  WorkStatus-任务状态。 </li></ul><br><br><img src="https://habrastorage.org/webt/n_/ts/xi/n_tsxiw0wsxv6a5abotzdzokcba.png"><br><br> 启动条件是从JobScheduler继承的。 <br> 可以注意到，用于更改URI的触发器仅在API 23中出现。此外，使用方法中的标志，您不仅可以订阅特定URI的更改，还可以订阅所有嵌套在其中的更改。 <br><br> 如果我们谈论我们，那么在Alpha阶段，决定切换到WorkManager。 <br> 这有几个原因。  Evernote有几个关键错误，该库的开发人员承诺在过渡到集成WorkManager的版本时会修复这些错误。 他们自己也同意Google的决定否定了Evernote的优势。 另外，由于我们使用架构组件，因此该解决方案非常适合我们的架构。 <br><br> 此外，我想以一个简单的示例说明我们如何尝试使用这种方法。 同时，是否拥有WorkManager或JobScheduler并不是很关键。 <br><br><img src="https://habrastorage.org/webt/ox/yd/0p/oxyd0pizr6h8tx4egaz_kub5wqy.png" width="300" height="430"><img src="https://habrastorage.org/webt/6m/ec/hd/6mechdqawzamahgaij7df-isocg.png" width="300" height="430"><br><br> 让我们来看一个非常简单的例子：单击重新发布或点赞。 <br><br> 现在，所有应用程序都试图摆脱阻塞对网络的请求，因为这使用户感到紧张并使其等待，尽管此时他可以在应用程序内进行购买或观看广告。 <br><br> 在这种情况下，本地数据首先会发生变化-用户立即看到其操作的结果。 然后在后台向服务器发送请求，如果请求失败，则数据将重置为其初始状态。 <br><br> 接下来，我将展示一个示例，说明我们的情况。 <br><br>  JobRunner包含启动任务的逻辑。 他的方法描述了任务的配置和传递参数。 <br><br><div class="spoiler">  <b class="spoiler_title">JobRunner.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">likePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(content: IFunnyContent)</span></span></span><span class="hljs-function"> </span></span>{ val constraints = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .build() val input = Data.Builder() .putString(LikeContentJob.ID, content.id) .build() val request = OneTimeWorkRequest.Builder(LikeContentJob::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setInputData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setConstraints</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constraints</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkManager</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getInstance</span></span></span><span class="hljs-class">().</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enqueue</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">) }</span></span></code> </pre><br></div></div><br>  WorkManager中的任务本身如下：我们从参数中获取ID，并在服务器上调用方法以喜欢此内容。 <br><br> 我们有一个包含以下逻辑的基类： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>{ val workerInjector = WorkerInjectorProvider.injector() workerInjector.inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performJob(inputData) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Data)</span></span></span><span class="hljs-function">: Result }</span></span></code> </pre><br> 首先，它可以使您远离对Worker的明确了解。 它还通过WorkerInjector包含依赖项注入逻辑。 <br><br><div class="spoiler">  <b class="spoiler_title">WorkerInjectorImpl.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Ovierride</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Worker job)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> AppCrashedEventSendJob) { Injector.getAppComponent().inject((AppCrashedEventSendJob) job); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> CheckNativeCrashesJob) { Injector.getAppComponent().inject((CheckNativeCrashesJob) job); } } }</code> </pre><br></div></div><br> 它只是代理对Dagger的调用，但可以帮助我们进行测试：我们替换注射器的实现，并在任务中实现必要的环境。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testRegisterPushProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WorkManagerTestInitHelper.initializeTestWorkManager(context) val testDriver = WorkManagerTestInitHelper.getTestDriver() WorkerInjectorProvider.setInjector(TestInjector()) <span class="hljs-comment"><span class="hljs-comment">// mock dependencies val id = jobRunner.runPushRegisterJob() testDriver.setAllConstraintsMet(id) Assert.assertTrue(…) }</span></span></code> </pre><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jobRunner</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobRunner</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interactor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ iFunnyContentDao.like(getContent().id) jobRunner.likePost(getContent()) } }</code> </pre> <br> 交互器是ViewController拉动以启动脚本通过的实体（在这种情况下，就像它一样）。 我们在本地将内容标记为“已上传”，然后提交任务以执行。 如果任务失败，将删除类似内容。 <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class">() </span></span>{ val likeState = MediatorLiveData&lt;Boolean&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentId = MutableLiveData&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentState: LiveData&lt;IFunnyContent&gt; = attachLiveDataToContentId(); init { likeState.addSource(iFunnyContentState) { likeState.postValue(it!!.hasLike) } } }</code> </pre> <br> 我们使用Google的架构组件：ViewModel和LiveData。 这就是我们的ViewModel的样子。 在这里，我们将状态为like的DAO中的对象更新连接起来。 <br><br><div class="spoiler">  <b class="spoiler_title">IFunnyContentViewController.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewController</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">likePostInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">viewModel</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: View)</span></span></span><span class="hljs-function"> </span></span>{ viewModel.likeState.observe(lifecycleOwner, { updateLikeView(it!!) }) } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLikePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ likePostInteractor.setContent(getContent()) likePostInteractor.execute() } }</code> </pre> <br></div></div><br> 一方面，ViewController订阅更改状态的请求，另一方面，它启动我们需要的脚本的传递。 <br><br> 这几乎是我们需要的所有代码。 剩下的就是添加View本身的行为以及DAO的实现； 如果使用“房间”，则只需在对象中注册字段。 它看起来非常简单有效。 <br><br><h3>  <b>总结一下</b> </h3><br>  <b>JobScheduler，GCM网络经理，FirebaseJobDispatcher：</b> <br><br><ul><li> 不要使用它们 </li><li> 不再阅读有关它们的文章 </li><li> 不看报告 </li><li> 不要以为选择哪一个。 </li></ul><br>  <b>Evernote的Android Job：</b> <br><br><ul><li> 在内部，他们将使用WorkManager； </li><li> 关键错误在解决方案之间是模糊的。 </li></ul><br>  <b>工作管理器：</b> <br><br><ul><li>  API等级9以上； </li><li> 独立于Google Play服务； </li><li> 链接/输入合并器； </li><li> 反应方法 </li><li>  Google的支持（我想相信）。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN434680/">https://habr.com/ru/post/zh-CN434680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN434670/index.html">年度报告Habrapost-2018</a></li>
<li><a href="../zh-CN434672/index.html">《金融科技文摘》：2018年最受欢迎的产品，卡与卡之间的转账量翻了一番，加密货币税</a></li>
<li><a href="../zh-CN434674/index.html">我们迅速应对电缆破坏，无处不在，无物理陷阱</a></li>
<li><a href="../zh-CN434676/index.html">TOP-10-2019年度学习</a></li>
<li><a href="../zh-CN434678/index.html">管理员上午：在数十台服务器上添加空间以喝咖啡</a></li>
<li><a href="../zh-CN434682/index.html">个人城市传送器</a></li>
<li><a href="../zh-CN434684/index.html">Rust 2019及以后：增长限制</a></li>
<li><a href="../zh-CN434686/index.html">KPI中的JavaScript和Node.js讲座</a></li>
<li><a href="../zh-CN434688/index.html">FreeBSD计划切换到ZFSonLinux</a></li>
<li><a href="../zh-CN434690/index.html">Haiku操作系统：移植应用程序和创建软件包</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>