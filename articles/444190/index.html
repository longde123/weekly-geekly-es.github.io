<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🏫 ☝🏾 👩🏻‍🌾 Crea los bordes de un mapa generado por procedimientos 🥢 👩🏿‍🚀 🔔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Scott Turner continúa trabajando en su juego generado por procedimientos y ahora ha decidido abordar el problema del diseño de los bordes de los mapas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crea los bordes de un mapa generado por procedimientos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png" alt="imagen"></div><br>  <i>Scott Turner continúa trabajando en su juego generado por procedimientos y ahora ha decidido abordar el problema del diseño de los bordes de los mapas.</i>  <i>Para hacer esto, tiene que resolver varios problemas difíciles e incluso crear su propio lenguaje para describir los límites.</i> <br><br>  Las fronteras seguían siendo un elemento importante de las tarjetas de fantasía, que habían estado en mi lista durante bastante tiempo.  Los mapas funcionales generalmente tienen una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">línea de borde</a> simple, pero los mapas de fantasía y los mapas medievales, de los cuales los primeros suelen tomar ideas, tienen límites bastante reflexivos y artísticos.  Estos límites dejan en claro que el mapa se ha hecho intencionalmente fantástico y le dan al espectador una sensación de asombro. <br><br>  Actualmente hay un par de formas simples de dibujar bordes en mi juego <b>Dragons Abound</b> .  Puede dibujar una línea simple o doble alrededor del perímetro del mapa y agregar elementos simples en las esquinas, como en estas figuras: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/9f8/477/aed9f8477ef53b5550b742ea1fde36b2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br>  El juego también puede agregar un campo en la parte inferior del borde para el nombre del mapa.  Hay varias variaciones de este campo en <b>Dragons Abound</b> , incluidos elementos tan complejos como cabezas de tornillo falsas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/f6f/c3a/42ff6fc3adae5b40293bb82d5a1be325.png"></div><br>  Hay variabilidad en estos campos de nombre, pero todos se crean manualmente. <br><br>  Un aspecto interesante de los límites de las tarjetas de fantasía es que son creativas y de plantilla.  A menudo consisten en una pequeña cantidad de elementos simples que se combinan de diferentes maneras para crear un resultado único.  Como siempre, el primer paso al trabajar con un nuevo tema para mí es estudiar una colección de ejemplos de mapas, crear un catálogo de tipos de elementos de borde y estudiar su apariencia. <br><a name="habracut"></a><br>  El borde más simple es una línea que corre a lo largo de los bordes del mapa e indica sus límites.  Como dije anteriormente, también se llama la "línea de trama": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99f/c81/c98/99fc81c98e1092077272081464d28752.png"></div><br>  También hay una variación con la ubicación de los bordes dentro del mapa.  En esta versión, el mapa alcanza los bordes de la imagen, pero el borde crea un borde virtual dentro de la imagen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/aef/1db/43faef1db7bf3af195c857d7ed673710.png"></div><br>  Esto se puede hacer con cualquier tipo de borde, pero generalmente se usa solo con bordes simples como el borde de un marco. <br><br>  Un concepto popular de diseño de tarjetas de fantasía es simular como si estuvieran dibujadas en un viejo pergamino roto.  A veces esto se realiza dibujando el borde como el borde áspero del papel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/cb2/ff1/907cb2ff125bbd178f9a16717e5e724f.png"></div><br>  Aquí hay un ejemplo más sofisticado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/751/860/d6e/751860d6e43ed2e857cf6f3ba7f766e0.png"></div><br>  En mi experiencia, este método se ha vuelto menos popular porque las herramientas digitales se han puesto en uso.  Si desea que la tarjeta se vea como un viejo pergamino roto, entonces es más fácil aplicarle la textura del pergamino que dibujarla a mano. <br><br>  La herramienta más poderosa para crear bordes de mapa es la repetibilidad.  En el caso más simple, es suficiente repetir una sola línea para crear dos líneas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/139/e12/31d139e129fe513e07937c5a2bd88979.png"></div><br>  Puede agregar interés al mapa variando el estilo del elemento repetido, en este caso combinando una sola línea gruesa con una sola línea delgada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/ccd/118/530ccd11872f4aa6a32d4b3271cf94f3.png"></div><br>  Dependiendo del elemento, son posibles diversas variaciones de estilo.  En este ejemplo, la línea se repite, pero el color cambia: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc7/89e/96c/fc789e96ccfba58ac4cb595e5ec33fb7.png"></div><br>  Para crear patrones más complejos, puede usar "repetibilidad repetible".  Este borde consta de aproximadamente cinco líneas simples con diferentes anchos y distancias: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Este borde repite las líneas, pero las separa para que se vean como dos bordes finos separados.  En esta parte de la publicación no hablaré sobre el procesamiento de ángulos, pero diferentes ángulos para las dos líneas también ayudan a crear esta diferencia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  ¿Son estas dos líneas, cuatro o seis?  ¡Creo que todo depende de cómo los dibujes! <br><br>  Otro elemento de estilización es llenar el espacio entre elementos con color, patrón o textura.  En este ejemplo, el borde se volvió más interesante debido al relleno de color de acento entre las dos líneas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/ccf/158/1d8ccf158b9ae0378ddaef1031ba15c9.png"></div><br>  Aquí hay un ejemplo de cómo se llena el borde con un patrón: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f87/37d/bb2/f8737dbb215166947e42f0da1b45cfc7.png"></div><br>  Además, los elementos se pueden diseñar para que se vean tridimensionales.  Aquí hay un mapa en el que el borde está sombreado para que parezca voluminoso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a80/25b/695/a8025b69549773f8935d2b37680401a3.png"></div><br>  En este mapa, el borde está sombreado para parecer tridimensional, y esto se combina con la ubicación de los bordes dentro de los bordes del mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36c/899/9e7/36c8999e74172c962aef40a4a9e3addc.png"></div><br>  Otro elemento de borde común es la escala en forma de rayas multicolores: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  Estas franjas forman una cuadrícula ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuadrícula cartográfica</a> ).  En los mapas reales, la escala ayuda a determinar las distancias, pero en los mapas de fantasía es principalmente un elemento decorativo. <br><br>  Estas rayas generalmente se dibujan en blanco y negro, pero a veces se agrega rojo u otro color: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/f0f/f67/450f0ff67ac1fdf5c5e2ffaf8fbe80c0.png"></div><br>  Este elemento también se puede combinar con otros, como en este ejemplo con líneas y escala: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/d56/29d/313d5629d6ec8b8d7c7c4c1ead322a09.png"></div><br>  Este ejemplo es un poco inusual.  Por lo general, la escala (si la hay) es el elemento más interno del borde. <br><br>  En este mapa, hay diferentes escalas con diferentes resoluciones (¡así como notas rúnicas extrañas!): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/cd6/217/74bcd62173160e440a4ee6cfad2128c1.png"></div><br>  (En Reddit, el usuario <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AbouBenAdhem</a> me informó que las marcas rúnicas son números 48 y 47 escritos en cuneiforme babilónico. Además, las “escalas con diferentes resoluciones” tienen seis divisiones divididas en diez divisiones más pequeñas, que corresponde al sistema de números hexadecimales babilonios. Por lo general Indico las fuentes de los mapas, pero hay demasiadas piezas pequeñas en esta publicación, así que no me molesté. Sin embargo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este mapa fue</a> creado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Thomas Ray</a> para el autor S.E. Boleyn, por lo que tal vez la acción en sus libros tiene lugar en el séquito de Babilonia. <br><br>  Además de las líneas y la escala, el elemento más común es un patrón geométrico repetitivo.  A menudo consta de partes como círculos, rombos y rectángulos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/6ba/f61/31c6baf612bf2fa11a13905e4482d82e.png"></div><br>  Los elementos geométricos, como las líneas, se pueden sombrear para que se vean tridimensionales: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/cc8/c33/43ecc8c33bbf3143ba32c18b878d16e2.png"></div><br>  Se pueden crear límites complejos combinando estos elementos de diferentes maneras.  Aquí está el borde que combina líneas, patrones geométricos y escala: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Los ejemplos que se muestran arriba eran tarjetas digitales, pero, por supuesto, lo mismo se puede hacer con tarjetas escritas a mano.  Aquí hay un ejemplo de un patrón geométrico simple creado a mano: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f7/c2d/e3d/6f7c2de3d5db82a9c7e9884d726be98e.png"></div><br>  Estos elementos también se pueden combinar de manera flexible de muchas maneras.  Aquí hay un patrón geométrico combinado con un "borde irregular": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/f1a/150/0faf1a15052e90a479428c4c495ad44c.png"></div><br>  En los ejemplos mostrados anteriormente, el patrón geométrico es bastante simple.  Pero puede crear patrones muy complejos combinando de manera diferente los elementos geométricos básicos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/13f/fc2/38e13ffc2a2aac266aabb291a7d7f0e6.png"></div><br>  Otro elemento popular del patrón es el tejido o el nudo celta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07e/00e/8d8/07e00e8d868b6ca48be746fbe07e61ca.png"></div><br>  Aquí hay un borde de mimbre más complejo que contiene color, escala y otros elementos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  En este mapa, el tejido se combina con un elemento de borde irregular: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/4df/588/e954df58825bc42d408b61804a1287a9.png"></div><br>  Además de los patrones geométricos y el tejido, cualquier patrón repetitivo puede ser parte del borde de la tarjeta.  Aquí hay un ejemplo usando formas que se asemejan a puntas de flecha: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Y aquí hay un ejemplo con un patrón de onda repetitiva: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/c13/3c2/841c133c2f1c0f724b5d076e5ea415fb.png"></div><br>  Y finalmente, las runas u otros elementos del alfabeto de fantasía a veces se agregan a los bordes de las tarjetas de fantasía: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Los ejemplos anteriores están tomados de mapas modernos de fantasía, pero aquí hay un ejemplo de un mapa histórico (siglo XVIII) con líneas y un patrón dibujado a mano: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/b9f/3b8/1d7b9f3b8f0c7eb296079c5f6f6b23aa.png"></div><br>  Por supuesto, puede encontrar ejemplos de mapas con muchos otros elementos en los bordes.  Algunas de las más bellas están completamente dibujadas a mano y tienen decoraciones tan cuidadosamente elaboradas que pueden superar la propia tarjeta ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mundo de Alma</a> , Francesca Baerald): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c7/004/e18/1c7004e186e0d2be63b98539375316ff.png"></div><br>  También vale la pena hablar un poco sobre <i>simetría</i> .  Al igual que la repetibilidad, la simetría es una herramienta poderosa, y los bordes del mapa son generalmente simétricos o tienen elementos simétricos. <br><br>  Muchos bordes del mapa son simétricos de adentro hacia afuera, como en este ejemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Aquí, el borde se compone de varias líneas con y sin relleno, pero desde afuera hacia adentro idealmente se repite en relación con el centro del borde. <br><br>  En este ejemplo más complejo, el borde es simétrico, con la excepción de franjas de escala alternadas en blanco y negro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  Dado que duplicar la escala no tiene sentido, a menudo se considera un elemento separado, incluso si el resto del borde es simétrico. <br><br>  Además de la simetría interna-externa, los bordes a menudo son simétricos a lo largo de su longitud.  Algunos bordes ilustrados pueden tener un diseño simple que abarca toda la longitud del borde del mapa, pero en la mayoría de los casos el patrón es bastante corto y se repite, llenando el borde de una esquina a otra: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Observe que en este ejemplo el patrón contiene un elemento que no es simétrico (de izquierda a derecha), pero el patrón general es simétrico y se repite: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Una excepción notable a esta regla son los bordes llenos de runas o caracteres alfabéticos.  A menudo resultan ser únicos, como si se escribiera un mensaje largo a lo largo de la frontera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Por supuesto, hay muchos otros ejemplos de elementos de borde de mapa que no he considerado aquí, pero ya tenemos un buen punto de referencia.  En las siguientes partes, desarrollaré varias funciones en <b>Dragons Abound</b> para describir, mostrar y generar de manera procesal bordes de mapas similares a estos ejemplos.  En la segunda parte, comenzaremos configurando el idioma para describir los bordes de los mapas. <br><br><h2>  Parte 2 </h2><br>  En esta parte, crearé la versión inicial del lenguaje de descripción de borde de mapa (MBDL). <br><br>  ¿Por qué dedicar tiempo a crear un lenguaje de descripción de límites de mapa?  En primer lugar, este será el objetivo de mi generación procesal.  Más adelante escribiré un algoritmo para crear nuevos bordes de mapa, y la salida de este algoritmo será una descripción del nuevo borde en MBDL.  En segundo lugar, MBDL servirá como una representación textual de los límites del mapa.  En particular, necesito poder guardar y reutilizar mis límites.  Para hacer esto, necesito una notación de texto que se pueda escribir y usar para recrear el borde del mapa. <br><br>  Comenzaré a crear MBDL definiendo el elemento más simple: la línea.  La línea tiene color y ancho.  Por lo tanto, en MBDL presentaré la línea de esta forma: <br><br><blockquote><code>L(width, color)</code> </blockquote> <br>  Aquí hay algunos ejemplos (perdón por mis habilidades de Photoshop): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db2/db8/68e/db2db868ede7282a34c695f8062a691b.png"></div><br>  La secuencia de elementos se representa desde el exterior hacia el interior (*), por lo que suponemos que este es el borde en la parte superior del mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/75e/b3a/b7c75eb3aefb8f77d1915166c0bdd979.png"></div><br>  Mire el segundo ejemplo: una línea con bordes se representa como tres elementos de línea separados. <br><br>  <i>(* Dibujar desde afuera hacia adentro fue una elección arbitraria, me pareció que era más natural que hacer desde adentro hacia afuera. Desafortunadamente, como resultó mucho más tarde, había una buena razón para trabajar en la dirección opuesta. Pronto te contaré sobre eso, pero todo se deja en la publicación - viejo, porque tomaría mucho tiempo rehacer todas las ilustraciones)</i> <br><br>  Convenientemente, los espacios se pueden representar como líneas sin color: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/1a4/171/0ba1a41719610641d7b5a5e26da0692e.png"></div><br>  Pero sería más visual tener un elemento de espacio vertical específico: <br><br><blockquote>  VS (ancho) </blockquote><br>  Los siguientes elementos simples son formas geométricas: rayas, rombos y elipses.  Se supone que las líneas se extienden a lo largo de todo el borde, por lo que no tienen una longitud explícitamente especificada.  Pero las figuras geométricas no pueden llenar toda la línea, por lo tanto, además del ancho (*), cada una debe tener una longitud, color de contorno, ancho de contorno y color de relleno: <br><br><blockquote> <code>B(width, length, outline, outline width, fill) <br> D(width, length, outline, outline width, fill) <br> E(width, length, outline, outline width, fill)</code> </blockquote> <br>  (* Acepté que consideraré el ancho en la dirección desde afuera hacia adentro, y la longitud se mide a lo largo del borde). <br><br>  Aquí hay ejemplos de formas geométricas simples: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/fad/cf6/a3dfadcf6a5a98a9785b0b487a6e17fc.png"></div><br>  Para que estos elementos llenen toda la longitud del borde, deben repetirse.  Para indicar el grupo de elementos que se repetirán para llenar la longitud del borde, uso corchetes: <br><br><blockquote> <code>[ element element element ... ]</code> </blockquote> <br>  Aquí hay un ejemplo de un patrón repetitivo de rectángulos y rombos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  A veces necesitaré un espacio (horizontal) entre elementos de un patrón repetitivo.  Aunque puede usar un elemento sin colores para crear un espacio, será más inteligente y más conveniente tener un elemento de espacio horizontal: <br><br><blockquote> <code>HS(length)</code> </blockquote> <br>  La última función necesaria para esta primera iteración de MBDL es la capacidad de apilar elementos uno encima del otro.  Aquí hay un ejemplo de borde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/7e9/3f3/8ea7e93f3040563ef7ec2715ca39a14d.png"></div><br>  La forma más fácil de describirlo es una línea amarilla ancha debajo del patrón superior.  Puede implementar esto de diferentes maneras (por ejemplo, un espacio vertical negativo), pero decidí usar llaves para indicar el orden de los elementos hacia adentro: <br><br><blockquote> <code>{element element element ...}</code> </blockquote> <br>  De hecho, esta entrada le dice que recuerde dónde estaba el patrón desde afuera hacia adentro al ingresar los corchetes, y luego regrese a este punto cuando salga de los corchetes.  Los corchetes también se pueden considerar como una descripción de elementos que ocupan un espacio vertical.  Por lo tanto, el borde que se muestra arriba se puede describir de la siguiente manera: <br><br><blockquote> <code><b>L(1, black) <br> {L(20, yellow)} <br> VS(3) <br> [B(5, 10, black, 3, none) <br> D(5, 10, black,3,red)] <br> VS(3) <br> L(1, black)</b></code> </blockquote> <br>  Dibujamos una línea negra, nos fijamos donde estamos, dibujamos una línea amarilla y luego volvemos a la posición previamente fijada, caemos un poco, dibujamos un patrón de rectángulos y rombos, caemos un poco y luego dibujamos otra línea negra. <br><br>  Hay mucho más por hacer en MBDL, pero esto es suficiente para describir los muchos límites de los mapas.  El siguiente paso es convertir la descripción del límite en el MBDL al borde mismo.  Esto es similar a convertir una representación escrita de un programa de computadora (como Javascript) en la ejecución de este programa.  La primera etapa es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">análisis léxico (análisis) del</a> lenguaje: la transformación del texto fuente en un borde real del mapa o en algún tipo de forma intermedia, que es más fácil de convertir en un borde. <br><br>  El análisis es un área bastante bien estudiada de la informática.  Analizar un idioma no es muy simple, pero en nuestro caso es bueno (*) que MBDL sea una gramática <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libre de</a> contexto.  Las gramáticas sin contexto se analizan con bastante facilidad, y hay muchas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramientas de análisis de Javascript</a> para ellas.  Me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">decidí</a> por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nearley.js</a> , que parece ser bastante maduro y (más importante) una herramienta bien documentada. <br><br>  <i>(* Esto no es solo suerte, me aseguré de que el lenguaje no tuviera contexto).</i> <br><br>  No te presentaré las gramáticas libres de contexto, pero la sintaxis de Nearley es bastante simple y debes entender el significado sin ningún problema.  La gramática Nearley consiste en un conjunto de reglas.  Cada regla tiene un carácter a la izquierda, una flecha y la parte derecha de la regla, que puede ser una secuencia de caracteres y no caracteres, así como varias opciones separadas por "|"  (o): <br><br><blockquote> <code><b>border -&gt; element | element border <br> element -&gt;</b> “ <b>L"</b></code> </blockquote> <br>  Cada una de las reglas dice que el lado izquierdo se puede reemplazar por cualquiera de las opciones en el lado derecho.  Es decir, la primera regla dice que un borde es un elemento, o un elemento, seguido de otro borde.  Que en sí mismo puede ser un elemento, o un elemento seguido de un borde, etc.  La segunda regla dice que un elemento solo puede ser una cadena "L".  Es decir, juntas estas reglas corresponden a tales límites: <br><br><blockquote> <code><b>L <br> LLL</b></code> </blockquote> <br>  y no corresponden a tales límites: <br><br><blockquote> <code><b>X <br> L3L</b></code> </blockquote> <br>  Por cierto, si quieres experimentar con esta (o cualquier otra) gramática en Nearley, entonces hay un sandbox en línea para esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  Puede ingresar gramática y casos de prueba para ver qué coincide y qué no. <br><br>  Aquí hay una definición más completa de una línea primitiva: <br><br><blockquote> <code><b>@builtin “number.ne" <br> @builtin “string.ne" <br> border -&gt; element | element border <br> element -&gt; “L(" decimal “," dqstring “)"</b></code> </blockquote> <br>  Nearley tiene varios elementos integrados comunes, y el número es uno de ellos.  Por lo tanto, puedo usarlo para reconocer el ancho numérico de una línea primitiva.  Para el reconocimiento de color, uso otro elemento incorporado y permito el uso de cualquier cadena entre comillas dobles. <br><br>  Sería bueno agregar espacios entre diferentes personajes, así que hagámoslo.  Nearley admite clases de caracteres y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RBNF</a> para "cero o más" algo con ": *", por lo que puedo usar esto para especificar "cero o más espacios" y pegarlo en cualquier lugar para permitir espacios en las descripciones: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element border <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")"</b></code> </blockquote> <br>  Sin embargo, el uso de WS en todas partes hace que sea difícil leer la gramática, por lo que los abandonaré, pero imagino que lo son. <br><br>  Un elemento también puede ser un espacio vertical: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")"</b></code> </blockquote> <br>  Esto corresponde a tales límites <br><br><blockquote> <code><b>L(3.5,"black") VS(3.5)</b></code> </blockquote> <br>  Luego vienen las primitivas de tira, rombo y elipse. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")"</b></code> </blockquote> <br>  Coincidirá con tales elementos <br><br><blockquote> <code><b>B(34, 17, "white", 3, "black")</b></code> </blockquote> <br>  (Tenga en cuenta que las primitivas geométricas no son "elementos" porque no pueden estar solos en el nivel superior. Deben estar encerrados en un patrón). <br><br>  También necesito un espacio horizontal primitivo: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  Ahora agregaré una operación de patrón (repetición).  Esta es una secuencia de uno o más elementos dentro de corchetes.  Usaré el operador RBNF ": +", que aquí significa "uno o más". <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric):+ "]"</b></code> </blockquote> <br>  Tenga en cuenta que el patrón solo puede rellenarse con primitivas geométricas.  No podemos, por ejemplo, colocar una línea dentro de un patrón.  El elemento del patrón ahora coincidirá con algo como esto. <br><br><blockquote> <code><b>[B(34,17,"white",3,"black")E(13,21,"white",3,"rgb(27,0,0)")]</b></code> </blockquote> <br>  La última parte del lenguaje es el operador de superposición.  Este es cualquier número de elementos dentro de llaves. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric ):+ "]" <br> element -&gt; "{" (element ):+ "}"</b></code> </blockquote> <br>  lo que nos permite hacer lo siguiente: <br><br><blockquote> <code><b>{L(3.5,"rgb(98,76,15)")VS(3.5)}</b></code> </blockquote> <br>  (Tenga en cuenta que, a diferencia del operador de repetición, el operador de superposición se puede usar internamente). <br><br>  Después de limpiar la descripción y agregar espacios a los lugares necesarios, obtenemos la siguiente gramática MBDL: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> element -&gt; "(" WS (element WS):+ ")" <br> element -&gt; "[" WS (geometric WS):+ "]" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  Entonces, MBDL ahora está definido y hemos creado una gramática del lenguaje.  Se puede usar con Nearley para reconocer cadenas de idioma.  Antes de profundizar en MBDL / Nearley, me gustaría implementar las primitivas utilizadas en MBDL para que se pueda mostrar el límite descrito en MBDL.  Esto lo haremos en la siguiente parte. <br><br><h2>  Parte 3 </h2><br>  Ahora comenzaremos a implementar las primitivas de representación.  (En este punto, todavía no tengo que vincular el analizador a las primitivas de representación. Para realizar pruebas, los llamaré manualmente). <br><br>  Comencemos con la línea primitiva.  Recordemos cómo se ve: <br><br><blockquote> <code><b>L(width, color)</b></code> </blockquote> <br>  Además del ancho y el color, aquí hay un parámetro implícito: la distancia desde el borde exterior del mapa.  (Dibujo los bordes desde el borde del mapa hacia afuera. ¡Tenga en cuenta que comenzamos desde uno diferente!) No debe apuntar al MBDL, porque el intérprete que ejecuta el MBDL puede rastrearlo para dibujar el borde.  Sin embargo, esto debería ser una entrada para todas las primitivas de representación para que sepan dónde dibujarlas.  Llamaré a este parámetro offset. <br><br>  Si solo necesitara dibujar un borde a lo largo de la parte superior del mapa, entonces la primitiva de línea sería muy simple de implementar.  Sin embargo, de hecho, tendré que dibujar desde arriba.  abajo, izquierda y derecha.  (Quizás algún día me dé cuenta de los bordes oblicuos o curvos, pero por ahora nos adheriremos a los bordes rectangulares estándar.) Además, la longitud y la ubicación del elemento de línea dependen del tamaño del mapa (así como del desplazamiento).  Por lo tanto, como parámetros, necesito todos estos datos. <br><br>  Una vez establecidos todos estos parámetros, basta con crear una línea primitiva y usarla para dibujar una línea alrededor del mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a56/74f/785/a5674f78512bef22e569656701203401.png"></div><br>  (Tenga en cuenta que uso varias funciones de <b>Dragons Abound</b> para dibujar la línea "escrita a mano"). Intentemos crear un borde más complejo: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black)</b></code> </blockquote> <br>  Se ve así: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86a/ad8/849/86aad88494c1c17f993524ef09ef9b2f.png"></div><br>  Bastante bien  Tenga en cuenta que hay lugares en los que las líneas negras y la línea dorada no están completamente alineadas debido a las fluctuaciones.  Si quiero deshacerme de estos puntos, entonces simplemente puede reducir la cantidad de oscilación. <br><br>  Implementar una primitiva de espacio vertical es bastante simple;  solo realiza un incremento de desplazamiento.  Agreguemos un poco de espacio: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black) <br> VS(5) <br> L(3, black) L(10, red) L(3, black)</b></code> </blockquote> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eab/471/b90/eab471b902eb44e703f460d700936937.png"></div><br>  Al dibujar líneas, los ángulos se pueden realizar dibujando entre el desplazamiento y el dibujo a lo largo del mapa en el sentido de las agujas del reloj.  Pero, en general, necesito implementar el truncamiento en cada lado del borde del mapa para crear una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conexión angular con un bisel</a> .  Esto será necesario para crear bordes con patrones que se unan correctamente en las esquinas, y en el caso general eliminará la necesidad de dibujar elementos con bordes en un ángulo que de otro modo sería necesario.  (*) <br><br>  <i>(Nota: como se dirá en las siguientes partes, con el tiempo me negué a usar regiones de truncamiento al implementar ángulos. La razón principal es que para crear ángulos complejos, por ejemplo, compensaciones cuadradas:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  <i>Se requieren áreas de truncamiento cada vez más complejas.</i>  <i>Además, con el tiempo, encontré una mejor manera de trabajar con patrones en las esquinas.</i>  <i>En lugar de regresar y reescribir esta parte del artículo, decidí dejarlo para ilustrar el proceso de "creatividad".)</i> <br><br>  La idea principal es truncar cada borde en diagonal y crear cuatro áreas truncadas en las que se dibujará cada lado del borde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fb/31a/cf9/9fb31acf993cde46b6a7fdc408be6afd.png"></div><br>  Al truncar, todo lo dibujado en el área correspondiente se cortará en el ángulo deseado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/52b/f00/f02/52bf00f026f6979f6425345389fa646a.png"></div><br>  Desafortunadamente, esto crea pequeños espacios a lo largo de las líneas diagonales, probablemente porque el navegador realiza imperfectamente el suavizado a lo largo del borde truncado.  La prueba mostró que un fondo brilla a través del espacio entre los dos bordes.  Fue posible solucionar esto expandiendo un poco una de las máscaras (la mitad del píxel parece ser suficiente), pero esto a veces no resuelve el problema. <br><br>  A continuación, debe implementar formas geométricas.  A diferencia de las líneas, se repiten en el patrón, llenando el lado del borde del mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  Una persona dibujaría este patrón de izquierda a derecha, dibujando un rectángulo, un rombo y luego repitiendo el mismo hasta que se llene todo el borde.  Por lo tanto, esto también se puede implementar en el programa dibujando un patrón a lo largo del borde.  Sin embargo, será más fácil dibujar primero todos los rectángulos y luego todos los rombos.  Bastará con dibujar a lo largo del borde la misma figura geométrica a intervalos.  Y es muy conveniente que cada elemento tenga el mismo intervalo.  Por supuesto, una persona no haría eso, porque es demasiado difícil organizar los elementos en los lugares correctos, pero esto no es un problema para el programa. <br><br>  Es decir, el procedimiento para dibujar formas geométricas simples necesita parámetros en los que se transfieren todas las dimensiones y colores de la figura (es decir, ancho, largo, grosor de línea, color de línea y relleno), así como la posición de inicio (que por razones que se aclararán pronto, Consideraré el centro de la figura), el intervalo de espacio horizontal para la transición entre repeticiones y el número de repeticiones.  También será conveniente indicar la dirección de repetición en forma de un vector [dx, dy], para que podamos realizar repeticiones de izquierda a derecha, de derecha a izquierda, arriba o abajo, simplemente cambiando el vector y el punto de partida.  Póngalo todo junto y obtenga una tira de formas repetitivas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/409/bcd/c33/409bcdc33756610ac6ace2d0fde0a3a4.png"></div><br>  Usando este código varias veces y renderizando con el mismo desplazamiento, puedo combinar las rayas en blanco y negro para crear la escala del mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/8f5/0d9/b888f50d9f164b9319cc8b3cf8d38588.png"></div><br>  Antes de comenzar a descubrir cómo aplicar todo esto al borde real del mapa, primero implementemos la misma funcionalidad para elipses y rombos. <br><br>  Los rombos son solo rectángulos con vértices rotados, por lo que solo necesita hacer un pequeño cambio en el código.  Resultó que todavía no tengo un código listo para renderizar la elipse, pero es muy fácil tomar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vista paramétrica de la elipse</a> y crear una función que me dé los puntos de la elipse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fa/74e/079/3fa74e079dd2c29afa5acb0135d4092f.png"></div><br>  Aquí hay un ejemplo (creado manualmente) que usa las características implementadas anteriormente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/bf2/d39/bf8bf2d3992b34bc173622dc86c0d8b5.png"></div><br>  Para una cantidad de código tan pequeña, ¡se ve bastante bien! <br><br>  Resolvamos ahora el complejo caso de los bordes con elementos repetitivos: esquinas. <br><br>  Si hay un borde con elementos repetidos, hay varias formas de resolver el problema con las esquinas.  El primero es ajustar las repeticiones para que se ejecuten en las esquinas sin un matrimonio notable: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Otra opción es detener la repetición en algún lugar cerca de la esquina en ambos lados.  Esto a menudo se hace si el patrón no se puede "rotar" fácilmente en la esquina: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  La última opción es cerrar el patrón con alguna decoración de esquina: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Algún día llegaré a las decoraciones de las esquinas, pero por ahora usaremos la primera opción.  ¿Cómo hacer que un patrón de rayas o círculos "gire" en las esquinas del mapa sin espacios? <br><br>  La idea principal es colocar el elemento del patrón exactamente en la esquina de modo que la mitad esté en un borde del mapa y la otra en el adyacente.  En este ejemplo, el círculo está exactamente en la esquina y se puede dibujar desde cualquier dirección: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  En otros casos, el elemento está medio dibujado en una dirección y la otra mitad en la otra, pero los bordes coinciden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  En este caso, se dibuja una franja blanca en ambos lados, pero se conecta en la esquina sin espacios. <br><br>  Hay dos aspectos a considerar al colocar un elemento en una esquina. <br><br>  Primero, el elemento de esquina se dividirá y reflejará en relación con la diagonal que pasa por el centro del elemento.  Los elementos con simetría radial, por ejemplo, cuadrados, círculos y estrellas, no cambiarán su forma.  Los elementos sin simetría radial, por ejemplo, rectángulos y rombos, cambiarán de forma al reflejar en relación con la diagonal. <br><br>  En segundo lugar, para que los elementos de las esquinas de los dos lados se conecten correctamente, debe haber un número entero de elementos (*) a lo largo de ambos lados del mapa.  No tienen que ser el mismo número, pero debe haber un número entero de elementos en ambos lados.  Si un número fraccionario de patrones está contenido en un lado, entonces desde un borde el patrón no coincidirá con el lado adyacente. <br><br>  <i>(* En algunos casos, por ejemplo, con rayas largas, puede ocurrir una repetición parcial con repetición completa y los elementos se alinearán de todos modos. Sin embargo, el elemento de esquina resultante será asimétrico y diferirá en longitud del mismo elemento en los lados del mapa. Un ejemplo de esto se puede ver aquí:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/418/110/263418110aafe94ef8c62d57e8540371.png"></div><br>  <i>Se produce una barra de escala blanca con diferentes repeticiones parciales y, como resultado, se obtiene un elemento desplazado con respecto al centro.</i>  <i>Para la escala del mapa, este no es siempre el caso, ya que muestra la distancia absoluta y no tiene que ser simétrica.</i>  <i>Pero para un patrón decorativo, esto generalmente se ve mal).</i> <br><br>  Aquí hay un ejemplo que muestra cómo se recorta un número entero de repeticiones exactamente en la esquina: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ab/8de/0a3/8ab8de0a3452332e2813b3771091b165.png"></div><br>  Si hace lo mismo desde los cuatro lados, las esquinas coincidirán y el patrón se ubicará perfectamente a lo largo de todo el borde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfc/c9a/e46/dfcc9ae46a68807e983705e553aa2ba3.png"></div><br>  Tras un examen cuidadoso, notará que el patrón no ocurre exactamente en las esquinas.  La mitad del círculo en cada esquina se toma de cada lado, y estas dos mitades se dibujan independientemente a mano, por lo tanto, no son perfectas.  Pero ahora están lo suficientemente cerca de esto. <br><br>  Entonces, podemos realizar una conexión perfecta del patrón en las esquinas, eligiendo un número entero de repeticiones para cada borde.  Sin embargo, la solución a este problema no es trivial. <br><br>  Primero, supongamos que sabemos que el lado tiene 866 píxeles de largo y queremos repetir el elemento 43 veces.  Luego, el elemento debe repetirse cada 20.14 píxeles.  ¿Cómo establecemos la longitud específica de un elemento (y en el caso general, un patrón de elementos)?  En el ejemplo anterior, agregué espacio adicional entre los círculos.  Pero si los círculos inicialmente se tocan, entonces esto cambiará el patrón.  ¿Quizás vale la pena estirar los círculos para que continúen tocándose? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e36/2b0/ebd/e362b0ebd3fd04e5d8b00de5d3aba151.png"></div><br>  Ahora los elementos se tocan, pero los círculos se han convertido en elipses y las esquinas tienen una forma extraña.  (¿Recuerda que dije que los elementos sin simetría radial cambian de forma cuando se reflejan en relación con un ángulo? Para las rayas, esto no será un gran problema). O quizás valga la pena comprimir todos los elementos para que se toquen entre sí y se ajusten en una longitud adecuada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/ba8/0af/d7cba80afb431dc6c9afc52d7ad94b5c.png"></div><br>  Pero para darnos cuenta de esto, necesitamos hacer que los elementos sean mucho más pequeños de lo que eran originalmente.  Ninguna de estas opciones parece perfecta. <br><br>  El segundo problema ocurre cuando los lados de la tarjeta son de diferentes tamaños.  Ahora tenemos que resolver el problema de encontrar un número entero de repeticiones adecuado para ambos lados.  Sería ideal encontrar una solución que se ajuste a ambos lados.  Pero no quiero hacer esto a costa de demasiado cambio de patrón.  Puede ser mejor crear patrones ligeramente diferentes en ambos lados si ambos están lo suficientemente cerca del patrón original. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y finalmente, el tercer problema surge cuando uso la función de superponer varios elementos entre sí: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d9/4ed/6ac/4d94ed6acf107193f2109bd2b2f07a67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No quiero hacer ningún cambio en el patrón que destruirá la relación entre los elementos. </font><font style="vertical-align: inherit;">Creo que con una escala adecuada, las relaciones en su conjunto se mantendrán, pero necesito probar esto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarea interesante, ¿verdad? </font><font style="vertical-align: inherit;">Hasta ahora no tengo soluciones particularmente de alta calidad para ella. </font><font style="vertical-align: inherit;">¡Quizás aparecerán más tarde!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 4 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, hemos implementado primitivas para dibujar líneas y formas geométricas. Comencé a trabajar en el uso de formas repetitivas para llenar los bordes y hablé sobre las dificultades de colocar patrones arbitrarios en el borde del mapa para que encajen perfectamente en las esquinas. El problema principal es que, en el caso general, debe hacer que el patrón sea más largo (o más corto) para que se ajuste lateralmente. Las opciones para cambiar la longitud del patrón (agregar o eliminar espacios, cambiar la longitud de los elementos de los patrones) conducen a varios cambios en el patrón en sí. ¡Parece que la tarea de seleccionar un patrón entre varios elementos es muy difícil!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando me encuentro con tareas aparentemente intransigentes, me gusta comenzar implementando una versión simple. Las tareas fallidas a menudo se pueden resolver resolviendo repetidamente problemas "simples" hasta que el resultado sea lo suficientemente bueno. Y, a veces, la implementación de una versión simple proporciona cierta comprensión que simplifica la solución de un problema más complejo. Si no mejora y el problema sigue siendo incómodo, al menos tendremos una versión simplificada que aún puede ser útil, aunque no del todo como debería.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma más fácil es cambiar la longitud del patrón agregando longitudes sin cambiar nada en el patrón. </font><font style="vertical-align: inherit;">Básicamente, esto agrega espacio en blanco al final del patrón. </font><font style="vertical-align: inherit;">(Nota: es mejor distribuir el espacio vacío entre todos los elementos en el patrón). Vale la pena considerar que tal solución solo puede alargar el patrón. </font><font style="vertical-align: inherit;">Siempre podemos agregar espacio vacío al patrón, pero no podemos tomarlo si es necesario, ¡tal vez no haya más espacio vacío en el patrón! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con este enfoque, el algoritmo de ubicación del patrón en el lado de la tarjeta será muy simple:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Divida la longitud del lado de la tarjeta por la longitud del patrón y redondee hacia abajo para determinar la cantidad de repeticiones del patrón que se ajusta a ese lado. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distancia entre los elementos en este caso será igual a la longitud del lado dividido por el número de repeticiones. </font><font style="vertical-align: inherit;">(Esta es la más cercana a la ubicación original, dado que solo podemos agregar espacio).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dibuja un patrón a lo largo del costado, teniendo en cuenta la distancia calculada. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fue difícil implementar este sistema. </font><font style="vertical-align: inherit;">Las esquinas tercamente no querían coincidir. </font><font style="vertical-align: inherit;">Me tomó demasiado tiempo darme cuenta de que cuando el mapa no es cuadrado, no puedo dibujar áreas de truncamiento para cuatro lados desde el centro del mapa, porque esto crea ángulos de truncamiento que no son iguales a 45 grados. </font><font style="vertical-align: inherit;">De hecho, las áreas de truncamiento deben parecerse al reverso de un sobre:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/29a/beb/b2029abeb54302b5f7d3335a15c95f86.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando descubrí esto, el algoritmo comenzó a funcionar sin problemas. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(¡Pero no olvide la nota anterior de que con el tiempo abandoné las áreas de truncamiento!)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aquí hay un ejemplo con una relación de aproximadamente 2: 1:</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bff/739/d19/bff739d19d76fdb4db63033b970eb241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta escala, es bastante difícil de notar, pero las esquinas se conectan correctamente y solo hay una ligera diferencia visual entre los lados. </font><font style="vertical-align: inherit;">En este caso, el algoritmo para alinear los patrones solo necesita insertar píxeles fraccionarios, por lo que es invisible para el ojo, especialmente porque los contornos de los círculos están superpuestos por un píxel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay otro ejemplo con rayas:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/852/625/aa8852625e15121ce822cc6ca5fe8742.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es la parte superior del borde cuadrado. </font><font style="vertical-align: inherit;">Aquí está el mismo borde en un mapa más rectangular:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/207/9b1/90d2079b1e869c59ee204f1a75f5dbc7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí puede ver que en el lado de la tarjeta hay un espacio visualmente más grande entre las bandas. </font><font style="vertical-align: inherit;">El algoritmo no debe insertar más espacio que la longitud de un elemento completo; </font><font style="vertical-align: inherit;">por lo tanto, el peor de los casos ocurre cuando tenemos elementos largos y un lado corto que es ligeramente diferente de un tamaño adecuado. </font><font style="vertical-align: inherit;">Pero en la mayoría de los casos prácticos, la alineación no es muy perjudicial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay un ejemplo con un patrón de varios elementos:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/602/4f8/d186024f8ee1e4fbcd5918c63537a024.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aquí las rayas se superponen a las rayas: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/af7/ad6/c60af7ad6c71ee4ef1850f0bf194af62.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede ver que, dado que se realiza la misma alineación para cada elemento, las franjas permanecen centradas entre sí. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sugerí que una buena solución para colocar el patrón en el costado del mapa sería difícil, pero un enfoque muy simple con la distribución uniforme del elemento del patrón para llenar el espacio deseado funciona bastante bien para muchos patrones. Este es un recordatorio para todos nosotros: no hay necesidad de asumir que la decisión debe ser complicada; ¡puede ser más fácil de lo que piensas! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, esta solución no funciona para patrones con elementos conmovedores, por ejemplo, para escala de mapa. En este caso, agregar espacio desplaza los elementos:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cd/d7e/27f/3cdd7e27f8c2d92be26d36e7b4807f5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra opción para alargar un patrón, que mencioné anteriormente, es estirar los elementos individuales del patrón. </font><font style="vertical-align: inherit;">Es adecuado para algo así como un patrón de escala, pero se verá mal en un patrón con elementos simétricos, porque el estiramiento los hará asimétricos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La implementación de la opción de estiramiento resultó ser más complicada de lo que esperaba, principalmente porque tuve que estirar los elementos en diferentes bordes del mapa por diferentes tamaños (porque el mapa puede no ser cuadrado sino rectangular), y también cambiar dinámicamente la ubicación de los elementos en función de los nuevos estirados Tamaños. </font><font style="vertical-align: inherit;">Pero después de unas horas logré lograr esto:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/552/3c4/d1c5523c43a9828cd9c1c1bee6f4bbde.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora tengo todas las características necesarias para dibujar el borde del mapa (aunque los elementos de borde se crean manualmente): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2b/ccc/326/d2bccc326a0500f92267378e137e2f6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Convertí la imagen a escala de grises, porque no quería molestarme con la selección de colores, y la tarjeta en sí es bastante aburrida, pero como prueba de concepto, los bordes se ven bastante bonitos. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 5 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la parte 2, desarrollé la gramática del lenguaje de descripción de borde de mapa (MBDL), y en las partes 3 y 4, implementé procedimientos para ejecutar todas las primitivas del lenguaje. </font><font style="vertical-align: inherit;">Ahora trabajaré en conectar estas partes para poder describir el borde en MBDL y dibujarlo en el mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la Parte 3, escribí la gramática MBDL para que funcione con la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herramienta de análisis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Javascript </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Nearley</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La gramática terminada se ve así:</font></font><br><br><blockquote> <code><b>@builtin</b> <b>"</b> <b>number.ne"</b> <br> <b>@builtin</b> <b>"</b> <b>string.ne"</b> <br> <b>border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>VS(" number</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>(" WS (element WS):+</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>[" WS (geometric WS):+</b> <b>"</b> <b>]"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>B(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>E(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>D(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>HS(" number</b> <b>"</b> <b>)"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De manera predeterminada, cuando analiza una regla con éxito usando Nearley, la regla devuelve una matriz que contiene todos los elementos que corresponden al lado derecho de la regla. </font><font style="vertical-align: inherit;">Por ejemplo, si la regla</font></font><br><br><blockquote> <code><b>test -&gt;</b> <b>"</b> <b>A" |</b> <b>"</b> <b>B" |</b> <b>"</b> <b>C"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> combinado con una cuerda </font></font><br><br><blockquote> <code><b>A</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entonces Nearley regresará </font></font><br><br><blockquote> <code><b>[</b> <b>"</b> <b>A" ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una matriz con un solo valor es la cadena "A" correspondiente al lado derecho de la regla. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué devuelve Nearley cuando un elemento se analiza usando esta regla?</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay tres partes en el lado derecho de la regla, por lo que devolverá una matriz con tres valores. </font><font style="vertical-align: inherit;">El primer valor será el que devuelve la regla para WS, el segundo valor será el que devolverá la regla para decimal y el tercer valor será el que devolverá la regla para WS. </font><font style="vertical-align: inherit;">Si, usando la regla anterior, analizaré "57", entonces el resultado será el siguiente:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> [ "5", "7" ], <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El resultado final del análisis de Nearley será una matriz anidada de matrices, que es un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">árbol de sintaxis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En algunos casos, el árbol de sintaxis es una representación muy útil; en otros casos, no del todo. En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dragons Abound</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por ejemplo, dicho árbol no es particularmente útil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afortunadamente, las reglas de Nearley pueden anular el comportamiento estándar y devolver lo que quieran. De hecho, la regla (integrada) para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decimal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no devuelve una lista de números, devuelve el número Javascript equivalente, que en la mayoría de los casos es mucho más útil, es decir, el valor de retorno de la regla </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numérica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene la forma:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> 57, <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las reglas de Nearley redefinen el comportamiento estándar agregando un postprocesador a la regla, tomando una matriz estándar y reemplazándola por lo que necesita. Un postprocesador es solo código Javascript dentro de paréntesis especiales al final de una regla. Por ejemplo, en la regla del </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">número</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">nunca me interesan los espacios posibles a cada lado del número. Por lo tanto, sería conveniente que la regla simplemente devolviera un número y no una matriz de tres elementos. Aquí hay un postprocesador que realiza esta tarea:</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS {% default =&gt; default[1] %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este postprocesador toma el resultado estándar (la matriz de tres elementos que se muestra arriba) y lo reemplaza con el segundo elemento de la matriz, que es el número Javascript de la regla </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decimal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Entonces ahora la regla </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numérica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devuelve el número real. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta funcionalidad se puede utilizar para procesar un idioma entrante en un idioma intermedio, con el que es más fácil trabajar. </font><font style="vertical-align: inherit;">Por ejemplo, puedo usar la gramática Nearley para convertir una cadena MBDL en una matriz de estructuras Javascript, cada una de las cuales representa una primitiva identificada por un campo "op". </font><font style="vertical-align: inherit;">La regla para la línea primitiva se verá así:</font></font><br><br><blockquote> <code><b>element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)" {% data=&gt; {op:</b> <b>"</b> <b>L", width: data[1], color: data[3]} %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es decir, el resultado del análisis "L (13, negro)" será la estructura de Javascript: </font></font><br><br><blockquote> <code><b>{op:</b> <b>"</b> <b>L", width: 13, color:</b> <b>"</b> <b>black"}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Después de agregar el procesamiento posterior apropiado, el resultado devuelto por la gramática puede ser una secuencia (matriz) de estructuras de operación para la línea entrante. </font><font style="vertical-align: inherit;">Es decir, el resultado de analizar la cadena</font></font><br><br><blockquote> <code><b>L( 415, “black") <br> VS(5) <br> [B(1, 2, “black", 3, “white") HS(5) E(1, 2, “black", 3, “white")]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> será </font></font><br><br><blockquote> <code><b>[ <br> {op: "L", width: 415, color: "black"}, <br> {op: "VS", width: 5}, <br> {op: "P", <br> elements: [{op: "B", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}, <br> {op: "HS", width: 5}, <br> {op: "E", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}]} <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que es mucho más fácil de procesar para crear un borde de mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este punto, puede tener una pregunta: si la fase de posprocesamiento de la regla Nearley puede contener algún Javascript, ¿por qué no omitir la vista intermedia y simplemente dibujar el borde del mapa durante el postprocesamiento? </font><font style="vertical-align: inherit;">Para muchas tareas, este enfoque sería ideal. </font><font style="vertical-align: inherit;">Decidí no usarlo por varias razones.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, en MBDL hay un par (*) de componentes que no se pueden ejecutar durante el proceso de análisis. Por ejemplo, no podemos dibujar elementos geométricos repetitivos (tira o rombo) durante el proceso de análisis, porque necesitamos conocer información de otros elementos en el mismo patrón. En particular, necesitamos saber la longitud total del patrón para comprender hasta qué punto debemos organizar las repeticiones de cada elemento individual. Es decir, el elemento del patrón aún debe crear una representación intermedia de todos los elementos geométricos. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(* Hay otros componentes con limitaciones similares de los que aún no he hablado).</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, Javascript en Nearley está integrado en las reglas, por lo que no podremos pasar información adicional a Javascript, a excepción de las variables globales. Por ejemplo, para dibujar el borde, necesito saber el tamaño del mapa, las cuatro áreas de truncamiento utilizadas, etc. Aunque puedo agregar código que haga que esta información esté disponible para los posprocesadores de Nearley, será un poco complicado y puede ser difícil mantener dicho código. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por estas razones, estoy analizando una representación intermedia, que luego se ejecuta para crear el borde del mapa en sí.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente paso es desarrollar un intérprete que reciba una representación intermedia de MBDL y la ejecute para generar límites de mapa. Esto no es muy difícil de hacer. Básicamente, el trabajo es establecer las condiciones iniciales (por ejemplo, generar regiones de truncamiento para los cuatro lados del mapa) e iterar sobre la secuencia de estructuras de la representación intermedia con cada ejecución. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay un par de momentos resbaladizos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, necesito pasar de renderizar desde adentro a dibujar desde adentro hacia afuera. La razón es porque quiero que la mayoría de los bordes no se superpongan con el mapa, así que necesito dibujar los bordes para que las líneas del borde interior coincidan con los bordes del mapa. Si dibujo desde afuera hacia adentro, entonces necesito saber el ancho del borde antes de comenzar a dibujar para que el borde no se superponga con el mapa. Si dibujo de adentro hacia afuera, empiezo desde el borde del mapa y dibujo. También le permite imponer opcionalmente un borde en el mapa; simplemente comience el borde con un espacio vertical negativo (VS).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro punto difícil son los patrones repetitivos. </font><font style="vertical-align: inherit;">Para dibujar patrones repetitivos, necesito mirar todos los elementos del patrón y determinar el más ancho, porque establecerá el ancho de todo el patrón. </font><font style="vertical-align: inherit;">También necesito mirar y seguir la longitud del patrón para saber cuánta distancia dejar antes de cada repetición. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay un ejemplo de un borde bastante complejo que usé para probar el intérprete:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c8/88a/2a9/3c888a2a96352845f6165f5eca7f6ab3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creo que fue posible (¿necesario?) Adjuntarlo para probar al analizador, pero para este borde acabo de crear una vista intermedia manualmente: </font></font><br><br><blockquote> <code><b>[ <br> {op:'P', elements: [ <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'white'}, <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'black'}, <br> ]}, <br> {op:'VS', width: 2}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'PUSH'}, <br> {op:'L', width:10, color: 'rgb(222,183,64)'}, <br> {op:'POP'}, <br> {op:'PUSH'}, <br> {op:'P', elements: [ <br> {op:'E', width: 5, length: 5, lineWidth: 1, color: 'black', fill: 'red'}, <br> {op:'HS', length: 10}, <br> ]}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'POP'}, <br> {op:'VS', width: 2}, <br> {op:'P', elements: [ <br> {op:'E', width: 2, length: 2, lineWidth: 0, color: 'black', fill: 'white'}, <br> {op:'HS', length: 13}, <br> ]}, <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creé esta vista a través de prueba y error. Sea como fuere, ¡el intérprete funciona! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como último paso, permítanme usar el analizador para crear una vista intermedia de la versión MBDL. No hay mucho que mostrarme aquí: tuve que arreglar algunos nombres de campo, pero de lo contrario el código funcionó bien. Para el borde, utilicé una versión ligeramente diferente de MBDL:</font></font><br><br><blockquote> <code><b>[B(5,37,"black",2,"white") B(5,37,"black",2,"black")] <br> VS(3) <br> L(3,"black") <br> {L(10,"rgb(222,183,64)")} <br> [E(5,5,"black",1,"red") HS(-5) E(2,2,"none",0,"white") HS(10)] <br> L(3,"black")</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ella dibuja el mismo borde, pero de una manera ligeramente diferente. </font><font style="vertical-align: inherit;">También cambié la sintaxis de la superposición, reemplazando los paréntesis con llaves para que sea más diferente de la otra sintaxis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar por qué quería dibujar de adentro hacia afuera, y no solo colocar automáticamente el borde en el exterior del mapa, puedo agregar un espacio vertical negativo al comienzo de este borde para mover la escala del mapa dentro del borde del mapa:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tengo la mayor parte de la infraestructura necesaria para la generación procesal de los bordes del mapa: un lenguaje de descripción de límites, un analizador de idiomas y procedimientos para realizar una representación intermedia. </font><font style="vertical-align: inherit;">Solo queda lidiar con la parte difícil: ¡la generación procesal!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 6 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que se ha implementado todo el MBDL, tenía la intención de proceder a la generación procesal de los bordes del mapa, pero aún no estoy seguro de cómo quiero hacer esto, porque me demoraré un poco e implementaré un par de características más de MBDL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la primera discusión sobre el procesamiento de esquinas con patrones, hablé sobre un par de enfoques diferentes. Al final, me di cuenta de las esquinas biseladas, pero había una segunda opción: detener el patrón cerca de la esquina, como en estos ejemplos:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/94d/01b/3b794d01b552c42ed9b8362f5405ff9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/3a8/159/ee23a8159d81afd1f7c95c16a90bcdf7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tal solución se usa a menudo cuando el patrón de borde es algún tipo de figura asimétrica, runas u otra cosa que no se puede girar 90 grados, mientras se mantiene la alineación. Pero es obvio que esto funcionará con formas geométricas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta puede ser la opción que elija antes de generar el borde, pero puede agregar un poco de flexibilidad si lo habilita desde una parte del borde y usa la esquina biselada en la otra. Para hacer esto, tengo que agregar un nuevo comando a MBDL. Sospecho que pueden surgir otras opciones para diferentes partes del borde, por lo que agregaré un comando de opciones generales:</font></font><br><br><blockquote> <code><b>element -&gt; "O(MITER)"</b> <br> <b>element -&gt; "O(STOPPED)"</b> <br> <b>element -&gt; "O(STOPPED," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Aquí nuevamente, para mayor claridad, omitimos espacios y algunos otros detalles). Hasta ahora, las únicas opciones son "MITRE" para esquinas biseladas y "DETENIDO" para detenerse cerca de esquinas. </font><font style="vertical-align: inherit;">Si no se transmite ningún valor DETENIDO, el programa detiene el patrón a una distancia razonable de la esquina. </font><font style="vertical-align: inherit;">Si se transmite el valor, el patrón se detiene a esa distancia de la esquina. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si se usan esquinas DETENIDAS, entonces dejo de dibujar el patrón de esquina lejos de las esquinas.</font></font> Así es como se ve: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/5df/49e/a8e5df49eecf2ebc5e94e571cb7d0ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí, utilicé la opción MITRE para el patrón de escala en blanco y negro, por lo que se refleja con respecto al ángulo. </font><font style="vertical-align: inherit;">Para un patrón de círculos rojos y cuadrados negros dentro de una línea dorada (y para un patrón de círculos fuera del borde), utilicé DETENIDO. </font><font style="vertical-align: inherit;">Puedes ver que estos dos patrones terminan cerca de la esquina.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, hay un par de problemas. En primer lugar, vemos que a la izquierda el elemento más cercano a la esquina es un cuadrado negro, y en la parte superior hay un círculo rojo. Sucedió porque la esquina está cerca del comienzo de la repetición en un lado y cerca del final de la repetición en el otro. Pero se ve raro. Sería mejor si las esquinas fueran simétricas, incluso si para esto tuviéramos que agregar otro elemento al final del patrón. En segundo lugar, puede ver que el patrón fuera del borde (semicírculos y puntos negros) también termina en una repetición en la esquina. Pero como la longitud de esta repetición es mucho menor que la longitud de los círculos rojos / cuadrados negros, terminan en diferentes lugares. Probablemente sería mejor si todos los patrones se detuvieran a la misma distancia de la esquina.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para solucionar el primer problema, debe agregar otra repetición del primer elemento del patrón al final de cada lado del borde. </font><font style="vertical-align: inherit;">Pero en realidad es un poco más complicado, porque podría usar un desplazamiento horizontal negativo dentro del patrón para superponer varios elementos (como se hace aquí). </font><font style="vertical-align: inherit;">También debe agregar otra repetición a cualquier elemento del patrón que tenga el mismo punto de inicio que el primer elemento.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/331/6fc/9c43316fcd44d79a0b2374401a46240a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora el patrón es simétrico con respecto al ángulo y se ve mucho mejor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuación, necesito rastrear el patrón STOPPED más largo y detener cada patrón STOPPED a esta distancia:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a33/920/c6c/a33920c6cda9072bbda915544f1f4926.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora el patrón de círculos blancos se deja de lado más, pero aún no está alineado con el patrón de círculos rojos. </font></font> Por qué<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto sucedió porque el patrón de círculo blanco está más lejos del borde del mapa y el borde es más largo que donde se dibuja el patrón de círculo rojo. </font><font style="vertical-align: inherit;">Para solucionar este problema, también debe mover los patrones y considerar su desplazamiento en relación con el borde del mapa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70b/574/2c1/70b5742c1d4f404335b97128f09d6baf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora todo está bellamente alineado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La segunda opción para los ángulos son los desplazamientos cuadrados en las esquinas, por ejemplo, estos:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Será mucho más difícil implementar esto! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, la gramática de esta opción es simple y utiliza el código de operación Opción:</font></font><br><br><blockquote> <code><b>element -&gt; "O(SQOFFSET)"</b> <br> <b>element -&gt; "O(SQOFFSET," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El número indica el tamaño del desplazamiento cuadrado para el elemento en el borde del mapa; </font><font style="vertical-align: inherit;">Los elementos con diferentes desplazamientos deben alinearse en consecuencia. </font><font style="vertical-align: inherit;">Si no hay un número, el programa selecciona el tamaño de desplazamiento apropiado. </font><font style="vertical-align: inherit;">Poner a cero el número desactiva el desplazamiento cuadrado. </font><font style="vertical-align: inherit;">Esto le permite crear bordes en los que algunos elementos usan desplazamientos cuadrados, mientras que otros no, como en este borde:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo primero que me di cuenta fue que necesitaría áreas de truncamiento adicionales porque utilizo el truncamiento para procesar lugares donde la frontera cambia de dirección. </font><font style="vertical-align: inherit;">SQOFFSET requerirá áreas de truncamiento más complejas; </font><font style="vertical-align: inherit;">También necesitará áreas separadas para diferentes elementos cuando active y desactive SQOFFSET. </font><font style="vertical-align: inherit;">Dado que las áreas de truncamiento agregan artefactos no deseados de todos modos, esto parece demasiado trabajo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando trabajé en patrones escalables anteriores, implementé el llenado de un patrón asimétrico para agregar otra repetición desde un extremo del patrón. También me di cuenta de que esto eliminaría la necesidad de esquinas biseladas. Simplemente dibujaré todos los patrones a lo largo del borde en el sentido de las agujas del reloj, comenzando el patrón en una esquina y terminando cerca de la siguiente esquina. Esto me permitirá deshacerme de las áreas de truncamiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo más importante en esta nueva forma de trabajar con esquinas fue que el primer elemento del patrón ya no está "dividido" en dos lados. Si observa los patrones de escala en blanco y negro en los mapas de arriba, puede ver que hay un rectángulo blanco que pasa por la esquina. Ahora el rectángulo blanco colindará con la esquina:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/909/c83/ead909c83fa91ff80af290ab92ca9fae.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los mapas se dibujan en ambos sentidos, pero este no es un gran problema. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para empezar, implementé compensaciones para líneas. </font><font style="vertical-align: inherit;">Para hacer esto, fue suficiente girar la línea en relación con los ángulos correspondientes:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/bf6/2fd/9c2bf62fdfec732f56361f4aa17fc19e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como puedes entender, puedo combinar ángulos con desplazamientos y ángulos regulares, como en el mapa de arriba: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/f5b/e02/e0bf5be02606044dd5fba4f82d3dad67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, dar vuelta los patrones a la vuelta de la esquina es más difícil. </font><font style="vertical-align: inherit;">La idea general es dibujar de una esquina a casi la otra, y así sucesivamente a lo largo del borde, hasta volver al principio. </font><font style="vertical-align: inherit;">Teóricamente es suficiente dibujar solo patrones horizontales y verticales, y todo debe estar bellamente alineado; </font><font style="vertical-align: inherit;">En realidad, rastrear todo esto es bastante triste. </font><font style="vertical-align: inherit;">De hecho, tuve que reescribir completamente el código dos veces y escribir un montón de papel, pero no hablaré sobre esto en detalle. </font><font style="vertical-align: inherit;">Solo muestra el resultado:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/35b/889/91235b889603c973fcfe094a1614a993.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una ilusión óptica molesta surge en las esquinas: el elemento de la esquina parece no centrado más cerca del exterior de la esquina. </font><font style="vertical-align: inherit;">De hecho, esto no es cierto, pero parece que sí, porque más cerca del interior de la esquina hay más espacio visualmente vacío. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como los segmentos de los ángulos de desplazamiento son bastante cortos, es muy fácil crear un patrón de no equilibrio en la esquina:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/601/dff/b1b601dffc11782fb8cbe738a906b0e5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A veces se ve bastante feo. </font><font style="vertical-align: inherit;">Me recordó a un viejo chiste:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paciente: "Doctor, cuando hago esto, me duele". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doctor: "¡Entonces no hagas eso!"</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, intentaré no hacerlo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo general, no dibujaré la escala del mapa a lo largo del ángulo de desplazamiento, pero si lo necesito, necesitaré usar la opción que estira el patrón para que la escala del mapa encaje en la esquina sin espacios entre los rectángulos:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26f/a88/0da/26fa880da6d00d380afdae60c489dd9c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, puede ver que el tamaño de los rectángulos de escala varía notablemente. </font><font style="vertical-align: inherit;">Es decir, esta no es una muy buena opción. </font><font style="vertical-align: inherit;">(Por cierto, los ángulos de desplazamiento también tienen un error en el patrón de círculos. Más tarde lo arreglé, pero como dije, es muy difícil hacerlo.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el patrón es demasiado grande para caber en el segmento del ángulo de desplazamiento, entonces el algoritmo simplemente se rinde:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/044/b2d/b4d044b2dc2bf23cd670113476b9803d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo cual está lejos de ser ideal, pero, como dije anteriormente, "Entonces no lo hagas". </font><font style="vertical-align: inherit;">(En realidad, no es muy difícil agregar una función de compresión o estiramiento si la necesito). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué sucede si uso ambas esquinas de desplazamiento y la opción que detiene los patrones en frente de las esquinas? </font><font style="vertical-align: inherit;">En este caso, me detengo no lejos de las esquinas desplazadas:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/170/d60/9c1/170d609c1b789359490e35741215ba04.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Me parece que esta es una decisión lógica. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444190/">https://habr.com/ru/post/444190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444178/index.html">9 consejos para crear juegos independientes de un solo desarrollador</a></li>
<li><a href="../444182/index.html">Ir condiciones y sus rarezas</a></li>
<li><a href="../444184/index.html">Sobre las perspectivas de los centros de datos premontados</a></li>
<li><a href="../444186/index.html">Aleteo 1.2. Que hay de nuevo</a></li>
<li><a href="../444188/index.html">CG Pods: auriculares TWS que podrían</a></li>
<li><a href="../444192/index.html">API Management Mitap - Experiencia IBM, Google, Yandex y Leroy Merlin - Registro disponible</a></li>
<li><a href="../444198/index.html">Dropbox limita la sincronización: ahora solo 3 dispositivos</a></li>
<li><a href="../444200/index.html">Sesión de resolución de problemas</a></li>
<li><a href="../444204/index.html">Introducción de pruebas en Python. Parte 3</a></li>
<li><a href="../444206/index.html">27 de marzo, Moscú - JavaScript MeetUP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>