<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏽 🚅 😐 Fallen in einen Kaninchenbau: Eine Geschichte über einen Fehler beim Neustart eines Lackes - Teil 1 🙌🏼 🧓 🧑🏾‍🤝‍🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ghostinushanka , der die letzten 20 minuten auf die knöpfe gedrückt hatte, als hänge sein leben davon ab, dreht sich mit einem halbwilden ausdruck in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fallen in einen Kaninchenbau: Eine Geschichte über einen Fehler beim Neustart eines Lackes - Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477968/"><p>  <a href="https://habr.com/en/users/ghostinushanka/" class="user_link">ghostinushanka</a> , der die letzten 20 minuten auf die <a href="https://habr.com/en/users/ghostinushanka/" class="user_link">knöpfe</a> gedrückt hatte, als hänge sein leben davon ab, dreht sich mit einem halbwilden ausdruck in den augen und einem schlauen grinsen zu mir um - "alter, ich glaube ich verstehe." </p><br><p>  "Schau mal her", sagt er und zeigt auf eines der Symbole auf dem Bildschirm. "Ich wette auf meinen roten Hut, dass, wenn wir hier hinzufügen, was ich dir gerade geschickt habe", der Fehler nicht mehr besteht wird angezeigt. " </p><br><p> Ein wenig verwirrt und müde ändere ich den sed-Ausdruck, an dem wir seit einiger Zeit gearbeitet haben, speichere die Datei und <code>systemctl varnish reload</code> .  Die Fehlermeldung ist verschwunden ... </p><br><p>  "Die Mails, die ich mit dem Kandidaten ausgetauscht habe", fuhr mein Kollege fort, während sich sein Grinsen in ein echtes Lächeln voller Freude verwandelte. "Mir wurde plötzlich klar, dass dies genau dasselbe Problem ist!" </p><a name="habracut"></a><br><h3 id="s-chego-ono-vsyo-nachinalos">  Wie hat alles angefangen? </h3><br><p>  <em>In diesem Artikel wird davon ausgegangen, dass Sie verstehen, wie bash, awk, sed und systemd funktionieren.</em>  <em>Lackkenntnisse sind erwünscht, aber nicht erforderlich.</em> <em><br></em>  <em>Snippet-Zeitstempel geändert.</em> <em><br></em>  <em>Mit <a href="https://habr.com/en/users/ghostinushanka/" class="user_link">ghostinushanka geschrieben</a> .</em> <em><br></em>  <em>Dieser Text ist eine Übersetzung des vor zwei Wochen in englischer Sprache veröffentlichten Originals.</em>  <em><a href="https://habr.com/en/users/boikoden/" class="user_link">Boikoden</a> Übersetzung.</em> </p><br><p>  An einem anderen warmen Herbstmorgen scheint die Sonne durch die Panoramafenster, die Tasse des frisch zubereiteten koffeinhaltigen Getränks bleibt von der Tastatur entfernt, die Lieblingssymphonie der Klänge im Kopfhörer überlagert das Rascheln der mechanischen Tastaturen und der schicksalhafte Titel „Investigate lackre“ strahlt spielerisch den ersten Eintrag in der Backlog-Ticketliste auf der Kanbantafel. sh: echo: E / A-Fehler beim Staging “(Untersuchen Sie den„ varnishreload sh: echo: E / A-Fehler “in der Phase).  Wenn es um Lack geht, gibt es keine Fehler und es kann keinen Platz geben, auch wenn sie nicht zu Problemen führen, wie in diesem Fall. </p><br><p>  Für diejenigen, die mit <a href="https://github.com/varnishcache/pkg-varnish-cache/blob/weekly/systemd/varnishreload">varnishreload</a> nicht <a href="https://github.com/varnishcache/pkg-varnish-cache/blob/weekly/systemd/varnishreload">vertraut sind</a> , ist dies ein einfaches Shell-Skript, mit dem eine <a href="https://github.com/varnishcache/pkg-varnish-cache/blob/weekly/systemd/varnishreload">Lackkonfiguration neu geladen</a> wird - auch VCL genannt. </p><br><p>  Wie der Name des Tickets andeutet, ist auf einem der Server auf der Bühne ein Fehler aufgetreten, und da ich sicher war, dass das Lackrouting auf der Bühne ordnungsgemäß funktioniert, habe ich angenommen, dass dies ein geringfügiger Fehler ist.  Also nur eine Nachricht, die in einen bereits geschlossenen Ausgabestream gelangt ist.  Ich nehme das Ticket für mich und vertraue darauf, dass ich es in weniger als 30 Minuten als fertig markieren werde. Ich klopfe mir auf die Schulter, um das Board vom nächsten Müll zu säubern und zu wichtigeren Angelegenheiten zurückzukehren. </p><br><h3 id="vrezayas-v-stenu-na-skorosti-200-kmch">  Mit 200 km / h gegen eine Wand prallen </h3><br><p>  Nachdem <code>varnishreload</code> Datei <code>varnishreload</code> auf einem der Server mit Debian Stretch geöffnet hatte, sah ich ein Shell-Skript mit einer Länge von weniger als 200 Zeilen. </p><br><p>  Nachdem ich das Skript durchgearbeitet hatte, bemerkte ich nichts, was zu Problemen führen könnte, wenn es mehrmals direkt vom Terminal aus ausgeführt wurde. </p><br><p>  Am Ende ist dies eine Bühne, auch wenn sie kaputt geht, wird sich niemand beschweren, na ja ... nicht zu viel.  Ich führe das Skript aus und sehe, was auf das Terminal geschrieben wird. Es werden jedoch keine Fehler angezeigt. </p><br><p>  Ein paar weitere Schritte stellen sicher, dass ich den Fehler nicht ohne zusätzlichen Aufwand reproduzieren kann, und ich beginne herauszufinden, wie dieses Skript geändert werden kann und ob es trotzdem einen Fehler gibt. </p><br><p>  Kann ein Skript STDOUT überschreiben (mit <code>&gt; &amp;-</code> )?  Oder STDERR?  Keiner von beiden arbeitete infolgedessen. </p><br><p>  Offensichtlich verändert systemd irgendwie die Startumgebung, aber wie und warum? <br>  Ich <code>varnishreload</code> vim und bearbeite <code>varnishreload</code> , <code>varnishreload</code> <code>set -x</code> direkt unter dem <code>varnishreload</code> hinzu und <code>varnishreload</code> , dass die Debug-Skript-Ausgabe ein wenig Licht ins Dunkel bringt. </p><br><p>  Die Datei ist repariert, also starte ich den Lack neu und stelle fest, dass die Änderung alles kaputt gemacht hat ... Der Auspuff ist ein komplettes Durcheinander, in dem es Tonnen von C-ähnlichem Code gibt.  Selbst das Scrollen im Terminal reicht nicht aus, um herauszufinden, wo es beginnt.  Ich bin völlig verwirrt.  Kann sich der Debug-Modus auf die Arbeit von Programmen auswirken, die in einem Skript gestartet wurden?  Nein, Quatsch.  Ein Fehler in der Shell?  Mehrere mögliche Szenarien rasen durch meinen Kopf wie Kakerlaken in verschiedene Richtungen.  Eine Tasse koffeinreiches Getränk war sofort leer, ein kurzer Weg in die Küche, um die Vorräte aufzufüllen, und ... los geht's.  Ich öffne das Skript und schaue mir den Shebang an: <code>#!/bin/sh</code> . </p><br><p>  <code>/bin/sh</code> ist einfach bash symlink, das Skript wird also im POSIX-kompatiblen Modus interpretiert, oder?  Da war es!  Die Standard-Shell in Debian ist dash, und genau darauf <a href="https://wiki.debian.org/Shell">bezieht sich</a> <code>/bin/sh</code> . </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ls -l /bin/sh lrwxrwxrwx 1 root root 4 Jan 24 2017 /bin/sh -&gt; dash</span></span></code> </pre> <br><p>  Aus Versuchsgründen habe ich den shebang in <code>#!/bin/bash</code> geändert, <code>set -x</code> gelöscht und es erneut versucht.  Schließlich trat beim anschließenden Neustart von lack ein tolerierbarer Fehler in der Ausgabe auf: </p><br><pre> <code class="bash hljs">Jan 01 12:00:00 hostname varnishreload[32604]: /usr/sbin/varnishreload: line 124: <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span>: write error: Broken pipe Jan 01 12:00:00 hostname varnishreload[32604]: VCL <span class="hljs-string"><span class="hljs-string">'reload_20190101_120000_32604'</span></span> compiled</code> </pre> <br><p>  Linie 124, da ist es! </p><br><pre> <code class="bash hljs">114 <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_vcl_file</span></span></span></span>() { 115 VCL_SHOW=$(varnishadm vcl.show -v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_NAME</span></span></span><span class="hljs-string">"</span></span> 2&gt;&amp;1) || : 116 VCL_FILE=$( 117 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_SHOW</span></span></span><span class="hljs-string">"</span></span> | 118 awk <span class="hljs-string"><span class="hljs-string">'$1 == "//" &amp;&amp; $2 == "VCL.SHOW" {print; exit}'</span></span> | { 119 <span class="hljs-comment"><span class="hljs-comment"># all this ceremony to handle blanks in FILE 120 read -r DELIM VCL_SHOW INDEX SIZE FILE 121 echo "$FILE" 122 } 123 ) || : 124 125 if [ -z "$VCL_FILE" ] 126 then 127 echo "$VCL_SHOW" &gt;&amp;2 128 fail "failed to get the VCL file name" 129 fi 130 131 echo "$VCL_FILE" 132 }</span></span></code> </pre> <br><p>  Aber wie sich herausstellte, ist die Zeile 124 ziemlich leer und nicht von Interesse.  Ich konnte nur annehmen, dass der Fehler als Teil einer mehrzeiligen Ausgabe in Zeile 116 auftrat. <br>  Was wird schließlich in die Variable <code>VCL_FILE</code> als Ergebnis der Ausführung der oben genannten Unterschale geschrieben? </p><br><p>  Zu Beginn sendet es den Inhalt der <code>VLC_SHOW</code> Variablen, die in Zeile 115 erstellt wurde, über die Pipe an den nächsten Befehl.  Und was passiert dann? </p><br><p>  Zunächst wird <code>varnishadm</code> , das Teil des <code>varnishadm</code> ist, um den Lack ohne Neustart zu konfigurieren. </p><br><p>  Mit dem <code>vcl.show -v</code> die gesamte in <code>${VCL_NAME}</code> angegebene VCL-Konfiguration an <code>${VCL_NAME}</code> ausgegeben. </p><br><p>  <code>varnishadm vcl.list</code> können Sie die derzeit aktive VCL-Konfiguration sowie mehrere frühere Versionen von Lack-Routing-Konfigurationen <code>varnishadm vcl.list</code> , die sich noch im Speicher <code>varnishadm vcl.list</code> . Die Ausgabe ähnelt der folgenden: </p><br><pre> <code class="plaintext hljs">discarded cold/busy 1 reload_20190101_120000_11903 discarded cold/busy 2 reload_20190101_120000_12068 discarded cold/busy 16 reload_20190101_120000_12259 discarded cold/busy 16 reload_20190101_120000_12299 discarded cold/busy 28 reload_20190101_120000_12357 active auto/warm 32 reload_20190101_120000_12397 available auto/warm 0 reload_20190101_120000_12587</code> </pre> <br><p>  Der Wert der Variablen <code>${VCL_NAME}</code> in einem anderen Teil des <code>varnishreload</code> Skripts auf den Namen der derzeit aktiven VCL gesetzt, sofern vorhanden.  In diesem Fall ist dies "reload_20190101_120000_12397". </p><br><p>  Großartig, die Variable <code>${VCL_SHOW}</code> enthält die vollständige Konfiguration für den Lack, soweit dies klar ist.  Jetzt habe ich endlich verstanden, warum die Dash-Ausgabe mit <code>set -x</code> so kaputt war - sie enthielt den Inhalt der resultierenden Konfiguration. </p><br><p>  Es ist wichtig zu verstehen, dass eine vollständige VCL-Konfiguration häufig aus mehreren Dateien zusammengesetzt werden kann.  Kommentare im C-Stil werden verwendet, um zu bestimmen, wo einige Konfigurationsdateien in anderen enthalten waren. Genau darum geht es in dem folgenden Code-Snippet in der gesamten Zeile. <br>  Die Syntax der Kommentare, die die enthaltenen Dateien beschreiben, hat das folgende Format: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// VCL.SHOW &lt;NUM&gt; &lt;NUM&gt; &lt;FILENAME&gt;</span></span></code> </pre> <br><p>  Die Zahlen sind in diesem Zusammenhang nicht wichtig, wir interessieren uns für den Dateinamen. </p><br><p>  Also, was ist los im Sumpf der Mannschaften, die auf der Linie 116 starten? <br>  Lass es uns herausfinden. <br>  Das Team besteht aus vier Teilen: </p><br><ol><li>  Ein einfaches <code>echo</code> , das den Wert der Variablen <code>${VCL_SHOW}</code> <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_SHOW</span></span></span><span class="hljs-string">"</span></span></code> </pre> </li><li>  <code>awk</code> sucht nach einer Zeile (Datensatz), in der das erste Feld nach dem Aufbrechen des Texts "//" und das zweite "VCL.SHOW" lautet. <br>  Awk schreibt die erste Zeile, die mit diesen Mustern übereinstimmt, und stoppt dann sofort die Verarbeitung. <br><pre> <code class="bash hljs">awk <span class="hljs-string"><span class="hljs-string">'$1 == "//" &amp;&amp; $2 == "VCL.SHOW" {print; exit}'</span></span></code> </pre> </li><li>  Ein Codeblock, der in fünf durch Leerzeichen getrennten variablen Feldwerten gespeichert wird.  Die fünfte Variable FILE ruft den Rest der Zeichenfolge ab.  Schließlich schreibt das letzte Echo den Inhalt der Variablen <code>${FILE}</code> . <br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -r DELIM VCL_SHOW INDEX SIZE FILE; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$FILE</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> </li><li>  Da alle Schritte 1 bis 3 in einer Unterschale liegen, wird die Ausgabe des Wertes <code>$FILE</code> in die Variable <code>VCL_FILE</code> . </li></ol><br><p>  Wie aus dem Kommentar in Zeile 119 hervorgeht, dient dies einem einzigen Zweck: Fälle zuverlässig zu behandeln, in denen die VCL auf Dateien mit Leerzeichen im Namen verweist. </p><br><p>  Ich habe die ursprüngliche Verarbeitungslogik für <code>${VCL_FILE}</code> und versucht, die <code>${VCL_FILE}</code> zu ändern, aber dies hat zu nichts geführt.  Bei mir hat alles reibungslos geklappt, und beim Starten des Dienstes ist ein Fehler aufgetreten. </p><br><p>  Es scheint, dass der Fehler einfach nicht reproduzierbar ist, wenn Sie das Skript manuell ausführen, während die erwarteten 30 Minuten bereits sechsmal abgelaufen sind und im Anhang eine Aufgabe mit höherer Priorität aufgetreten ist, die den Rest der Fälle beiseite schiebt.  Der Rest der Woche war mit einer Vielzahl von Aufgaben gefüllt und wurde nur geringfügig mit einem Bericht über sed und einem Interview mit dem Kandidaten verwässert.  Das Problem mit dem <code>varnishreload</code> ging im Sand der Zeit unwiederbringlich verloren. </p><br><h3 id="vashe-tak-nazyvaemoe-sed-fu-na-samom-dele-dryan">  Ihr sogenannter Sed-Fu ... wirklich ... Müll </h3><br><p>  Die nächste Woche war ein ziemlich freier Tag, also entschied ich mich erneut für dieses Ticket.  Ich hatte gehofft, dass in meinem Gehirn ein Hintergrundprozess die ganze Zeit nach einer Lösung für dieses Problem suchte, und dieses Mal verstehe ich mit Sicherheit, was es ist. </p><br><p>  Da das letzte Mal eine einfache Codeänderung nicht geholfen hat, habe ich mich entschlossen, sie ab der 116. Zeile neu zu schreiben.  In jedem Fall war der vorhandene Code mies.  Und es ist absolut nicht nötig, <code>read</code> . </p><br><p>  Schauen Sie sich den Fehler noch einmal an: <br>  <code>sh: echo: broken pipe</code> - in diesem Befehl ist echo an zwei Stellen, aber ich vermute, dass der erste der wahrscheinlichere Schuldige ist (na ja, oder zumindest ein Komplize).  Awk ist auch nicht glaubwürdig.  Und falls es wirklich <code>awk | {read; echo}</code> <code>awk | {read; echo}</code>  <code>awk | {read; echo}</code> konstruktion führt zu all diesen problemen, warum nicht ersetzen?  Dieser einzeilige Befehl verwendet nicht alle Funktionen von awk, und selbst dieses Extra wird im Anhang <code>read</code> . </p><br><p>  Da es letzte Woche einen Bericht über <code>sed</code> , wollte ich meine neu erworbenen Fähigkeiten ausprobieren und <code>echo | awk | { read; echo}</code> vereinfachen <code>echo | awk | { read; echo}</code>  in ein verständlicheres <code>echo | sed</code>  <code>echo | sed</code> .  Obwohl dies definitiv nicht der beste Ansatz ist, um einen Fehler zu erkennen, dachte ich, ich würde zumindest mein sed-fu ausprobieren und vielleicht etwas Neues über das Problem erfahren.  Dabei bat ich meinen Kollegen, den Autor des sed-Berichts, mir zu helfen, ein effektiveres sed-Skript zu entwickeln. </p><br><p>  Ich habe den Inhalt von <code>varnishadm vcl.show -v "$VCL_NAME"</code> in der Datei abgelegt, damit ich mich darauf konzentrieren kann, ein sed-Skript zu schreiben, ohne den Dienst neu zu <code>varnishadm vcl.show -v "$VCL_NAME"</code> . </p><br><p>  Eine kurze Beschreibung, wie sed mit Eingaben umgeht, finden Sie im <a href="https://www.gnu.org/software/sed/manual/sed.html">GNU-Handbuch</a> .  In sed-Quellen wird das Zeichen <code>\n</code> explizit als Zeilentrennzeichen angegeben. </p><br><p>  In mehreren Durchgängen und mit den Empfehlungen meines Kollegen haben wir ein sed-Skript geschrieben, das das gleiche Ergebnis wie die gesamte Quelltextzeile 116 lieferte. </p><br><p>  Das Folgende ist eine Beispiel-Eingabedatei: </p><br><pre> <code class="bash hljs">&gt; cat vcl-example.vcl Text // VCL.SHOW 0 1578 file with 3 spaces.vcl More text // VCL.SHOW 0 1578 file.vcl Even more text // VCL.SHOW 0 1578 file with TWOspaces.vcl Final text</code> </pre> <br><p>  Dies ist aus der obigen Beschreibung möglicherweise nicht ersichtlich, aber wir interessieren uns nur für den ersten Kommentar <code>// VCL.SHOW</code> , und möglicherweise sind mehrere davon in der Eingabe enthalten.  Deshalb beendet die Original-Awk ihre Arbeit nach dem ersten Match. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  ,      #   sed,  -    '\#'    '/',           #    “// VCL.SHOW”,       #  -n   ,  sed     ,       (.  ) # -E      &gt; cat vcl-processor-1.sed \#// VCL.SHOW#p &gt; sed -En -f vcl-processor-1.sed vcl-example.vcl // VCL.SHOW 0 1578 file with 3 spaces.vcl // VCL.SHOW 0 1578 file.vcl // VCL.SHOW 0 1578 file with TWOspaces.vcl #  ,     #   “substitute”,     ,    a #      ,    &gt; cat vcl-processor-2.sed \#// VCL.SHOW# { s#.* [0-9]+ [0-9]+ (.*)$#\1# p } &gt; sed -En -f vcl-processor-2.sed vcl-example.vcl file with 3 spaces.vcl file.vcl file with TWOspaces.vcl #  ,      #      awk,         &gt; cat vcl-processor-3.sed \#// VCL.SHOW# { s#.* [0-9]+ [0-9]+ (.*)$#\1# p q } &gt; sed -En -f vcl-processor-3.sed vcl-example.vcl file with 3 spaces.vcl #  ,    ,      &gt; sed -En -e '\#// VCL.SHOW#{s#.* [0-9]+ [0-9]+ (.*)$#\1#p;q;}' vcl-example.vcl file with 3 spaces.vcl</span></span></code> </pre> <br><p>  Der Inhalt des varnishreload-Skripts sieht also ungefähr so ​​aus: </p><br><pre> <code class="bash hljs">VCL_FILE=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(echo "$VCL_SHOW" | sed -En '\#// VCL.SHOW#{s#.*[0-9]+ [0-9]+ (.*)</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$#</span></span></span><span class="hljs-string">\1#p;q;};')"</span></span></code> </pre> <br><p>  Die obige Logik kann wie folgt zusammengefasst werden: <br>  Wenn die Zeile mit dem regulären Ausdruck <code>// VCL.SHOW</code> , fressen Sie gierig den Text auf, der beide Zahlen in dieser Zeile enthält, und speichern Sie alles, was nach dieser Operation übrig bleibt.  Geben Sie den gespeicherten Wert ein und beenden Sie das Programm. </p><br><p>  Einfach, richtig? </p><br><p>  Wir waren zufrieden mit dem sed-Skript und der Tatsache, dass es den gesamten Originalcode ersetzt.  Alle meine Tests ergaben die gewünschten Ergebnisse, so dass ich den "varnishreload" auf dem Server änderte und <code>systemctl reload varnish</code> erneut <code>systemctl reload varnish</code> .  Das dreckige <code>echo: write error: Broken pipe</code> lachte wieder in unseren Gesichtern.  Ein blinkender Cursor wartete darauf, dass in der dunklen Leere des Terminals ein neuer Befehl eingegeben wurde ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477968/">https://habr.com/ru/post/de477968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477954/index.html">Wie Antworten auf Posts das Internet intelligenter machen</a></li>
<li><a href="../de477956/index.html">JavaScript in 3D: eine Einführung in Three.js</a></li>
<li><a href="../de477958/index.html">Top 10 Trends aus dem neuen High-Tech-Tech Crime Trends Report 2019/2020 Group-IB</a></li>
<li><a href="../de477964/index.html">Zwei Monate von der Idee bis zum ersten Verkauf: Erfahrung im Genesis-Team</a></li>
<li><a href="../de477966/index.html">HolyJS 2019 Moskau aus der Sicht des Teilnehmers</a></li>
<li><a href="../de477974/index.html">Vivado: Picasso-Modus</a></li>
<li><a href="../de477976/index.html">Visualisierung und Analyse der Community-Struktur anhand von Grafiken</a></li>
<li><a href="../de477978/index.html">Hier finden Sie die besten Preise des Jahres für Gadgets</a></li>
<li><a href="../de478474/index.html">Bruder Pablo Escobar hat auch ein flexibles Smartphone herausgebracht</a></li>
<li><a href="../de478480/index.html">Künstliche Intelligenz, ITSM und allgemein, woher kommt LEAN?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>