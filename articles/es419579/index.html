<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍👩 😹 👨‍❤️‍💋‍👨 Implementación del operador in en C ++ 👃🏼 👩🏿‍🤝‍👨🏻 🐬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Hoy espero mostrarte algo de magia. Mi pasatiempo es inventar todo tipo de piezas aparentemente imposibles en C ++, lo que me ayuda a aprender to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementación del operador in en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419579/">  Hola  Hoy espero mostrarte algo de magia.  Mi pasatiempo es inventar todo tipo de piezas aparentemente imposibles en C ++, lo que me ayuda a aprender todo tipo de sutilezas del lenguaje, o simplemente divertirme.  El operador in está en varios idiomas, por ejemplo Python, JS.  Pero no lo trajeron en C ++, pero a veces quiero que lo sea, así que ¿por qué no implementarlo? <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; some_map = { { <span class="hljs-string"><span class="hljs-string">"black"</span></span>, <span class="hljs-string"><span class="hljs-string">"white"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"cat"</span></span>, <span class="hljs-string"><span class="hljs-string">"dog"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"day"</span></span>, <span class="hljs-string"><span class="hljs-string">"night"</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = <span class="hljs-string"><span class="hljs-string">"cat"</span></span> in some_map) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"fish"</span></span>; }</code> </pre> <br><a name="habracut"></a><br>  Cómo debería funcionar el operador, creo que es obvio.  Toma el objeto izquierdo y comprueba si se produce este objeto en el objeto indicado a la derecha, que no tiene que ser una colección.  No existe una solución universal en sí misma, al igual que no existe una solución universal para otros operadores, por lo tanto, se inventó la posibilidad de sobrecargarlos.  Por lo tanto, para el operador in, debe implementar un mecanismo similar. <br><br>  La sobrecarga se verá así. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator_in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unordered_map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.find(key) != data.end(); }</code> </pre><br>  Creo que la idea es clara, la expresión de la especie. <br><br><pre> <code class="cpp hljs"> <span class="hljs-string"><span class="hljs-string">"some string"</span></span> in some_map</code> </pre><br>  Debería convertirse en una llamada de función. <br><br><pre> <code class="cpp hljs"> operator_in(<span class="hljs-string"><span class="hljs-string">"some string"</span></span>, some_map)</code> </pre><br>  La implementación de este mecanismo es bastante simple, utilizando las capacidades existentes para la sobrecarga del operador.  El operador in es esencialmente una macro que multiplica. <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> in *OP_IN_HELP{}*</span></span></code> </pre><br>  En este caso, <b>OP_IN_HELP</b> es una clase vacía y solo nos sirve para seleccionar la sobrecarga correcta. <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_HELP</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class">&lt;TIn&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">*(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_HELP</span></span></span><span class="hljs-class">&amp;) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OP_IN_LVAL&lt;TIn&gt;(data); }</code> </pre><br>  El operador es repetitivo, lo que le permite aceptar cualquier tipo como primer argumento.  Ahora necesitamos obtener de alguna manera el objeto correcto, sin perder el izquierdo.  Para hacer esto, implementamos la clase <b>OP_IN_LVAL</b> que almacenará nuestro objeto izquierdo. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; m_in; OP_IN_LVAL(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; val) : m_in(val) {}; };</code> </pre><br>  Dado que el objeto en sí estará vivo mientras se ejecuta la expresión, no hay nada de qué preocuparse si mantenemos una referencia constante a este objeto.  Ahora todo lo que nos queda es implementar el operador interno de multiplicación, que nos devolverá el resultado del operador sobrecargado, será una plantilla en sí misma. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; m_in; OP_IN_LVAL(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; val) : m_in(val) {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TWhat</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">*(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TWhat</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">what</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> operator_in(m_in, what); } };</code> </pre><br>  En realidad, esta solución ya funcionará, pero es limitada y no nos permitirá escribir de esta manera. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = <span class="hljs-string"><span class="hljs-string">"true"</span></span> in some_map) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; }</code> </pre><br>  Para que tengamos esa oportunidad, necesitamos arrojar el valor de retorno del operador sobrecargado.  Hay dos versiones de cómo hacer esto, una usa las capacidades de C ++ 14, la otra funciona dentro de C ++ 11. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; m_in; OP_IN_LVAL(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; val) :m_in(val) {}; <span class="hljs-comment"><span class="hljs-comment">//   C++14 template&lt;class TWhat&gt; auto operator*(const TWhat&amp; what) const { return operator_in(m_in, what); } //   C++11 template&lt;class TWhat&gt; auto operator*(const TWhat&amp; what) const -&gt; decltype(operator_in(m_in, what)) { return operator_in(m_in, what); } //       //       template&lt;class TWhat&gt; auto operator*(TWhat&amp; what) const -&gt; decltype(operator_in(m_in, what)) { return operator_in(m_in, what); } };</span></span></code> </pre><br>  Como trabajo principalmente en Visual Studio 2013, estoy limitado al marco de trabajo de C ++ 11 y la solución dentro de C ++ 11 funcionará con éxito en C ++ 14, por lo que le aconsejo que lo elija. <br><br>  Un ejemplo de implementación del operador genérico in para unordered_map. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIterator</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpInResult</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_result; TIterator m_iter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: OpInResult(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result, TIterator&amp; iter) : m_result(result), m_iter(iter) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } TIterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_iter; } <span class="hljs-function"><span class="hljs-function">TIterator&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_iter; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TKey</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TVal</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_in</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TKey</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;&amp; data) -&gt; OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt; { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> iter = data.find(key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt;(iter != data.end(), iter); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TKey</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TVal</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_in</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;&amp; data) -&gt; OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt; { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> iter = data.find(key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt;(iter != data.end(), iter); }</code> </pre><br>  La clase <b>OpInResult le</b> permite anular el operador de <b>conversión</b> , lo que nos permite usarlo en if.  También anula el operador de flecha, que le permite enmascararse como un iterador que devuelve unordered_map.find (). <br><br>  Un ejemplo se puede encontrar aquí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cpp.sh/7rfdw</a> <br><br>  También me gustaría decir acerca de algunas características de esta solución. <br>  Visual Studio crea una instancia de la plantilla en el lugar de uso, lo que significa que la función de sobrecarga debe declararse antes de usar el operador, pero puede declararse después de la <b>declaración de</b> clase <b>OP_IN_LVAL</b> .  A su vez, GCC crea una instancia de la plantilla en la ubicación de la declaración (cuando encuentra uso por sí misma), lo que significa que una declaración sobrecargada debe declararse antes de declarar la clase <b>OP_IN_LVAL</b> .  Si no está del todo claro de qué se trata, entonces aquí hay un ejemplo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cpp.sh/5jxcq</a> En este código, acabo de sobrecargar el operador in debajo de la <b>declaración de</b> clase <b>OP_IN_LVAL</b> y dejó de compilar en GCC (a menos que compilara con el indicador -fpermissive), pero se compila correctamente en Visual Studio. <br><br>  En C ++ 17, se hizo posible escribir así. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = some_map.find(<span class="hljs-string"><span class="hljs-string">"true"</span></span>); res != some_map.end()) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; }</code> </pre><br>  Pero me parece el diseño de la vista. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = <span class="hljs-string"><span class="hljs-string">"true"</span></span> in some_map) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; }</code> </pre><br>  Se ve mejor. <br><br>  Se pueden ver más ejemplos de sobrecargas aquí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/ChaosOptima/operator_in</a> <br><br>  Basado en el principio de implementación de este operador, tampoco habrá ningún problema para implementar <br>  y otros operadores y expresiones, por ejemplo. <br><br><pre> <code class="cpp hljs"> negative = FROM some_vector WHERE [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>;};</code> </pre><br><div class="spoiler">  <b class="spoiler_title">PS</b> <div class="spoiler_text">  Me gustaría saber si está interesado en estos temas, ¿hay algún punto al escribir sobre esto aquí?  ¿Y le gustaría saber cómo implementar otras cosas interesantes? <br><br>  operador condicional nulo <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = $<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_ptr $-&gt;func1()$-&gt;func2()$-&gt;func3(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)$endif;</code> </pre><br>  emparejamiento patern <br><br><pre> <code class="cpp hljs"> succes = patern_match val with_type(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"some int "</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } with_cast(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; items) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; val : items) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } with(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>()) [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"empty string\n"</span></span>; } with(oneof&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>)) [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; value) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; value &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } with_cast(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; str) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"some str "</span></span> &lt;&lt; str &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } at_default { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"no match"</span></span>; };</code> </pre><br>  cadena de enumeración <br><br><pre> <code class="cpp hljs"> StringEnum Power $def ( POW0, POW1, POW2 = POW1 * <span class="hljs-number"><span class="hljs-number">2</span></span>, POW3, POW4 = POW3 + <span class="hljs-number"><span class="hljs-number">1</span></span>, POW8 = POW4 * <span class="hljs-number"><span class="hljs-number">2</span></span>, POW9, POW10 ); to_string(Power::POW0) from_string&lt;Power&gt;(<span class="hljs-string"><span class="hljs-string">"POW0"</span></span>)</code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419579/">https://habr.com/ru/post/es419579/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419569/index.html">Slurm: video de clases y facaps organizacionales</a></li>
<li><a href="../es419571/index.html">La posición es excelente, pero continúan plantando para reposts</a></li>
<li><a href="../es419573/index.html">Experiencia de turismo espacial</a></li>
<li><a href="../es419575/index.html">Siguiendo el requisito de indicar la velocidad exacta de conexión, los proveedores del Reino Unido redujeron los números de publicidad en un promedio del 41%</a></li>
<li><a href="../es419577/index.html">Diseño de cosas familiares: cómo mejorar la interfaz en el ejemplo de YouTube</a></li>
<li><a href="../es419581/index.html">¿Qué proyectos sin fines de lucro son interesantes para Y Combinator?</a></li>
<li><a href="../es419583/index.html">Cómo Rusia se perdió el apogeo del DVD, pero alcanzó a Occidente con la llegada de Internet de banda ancha</a></li>
<li><a href="../es419585/index.html">PWA es fácil. Hola habr</a></li>
<li><a href="../es419587/index.html">Competiciones que cambian el mundo. 1567-2035</a></li>
<li><a href="../es419589/index.html">Usamos AMP como una biblioteca de uso general para crear sitios dinámicos rápidos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>