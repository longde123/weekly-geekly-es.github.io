<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüé§ üîà üõ¨ OpenSceneGraph: Techniques de programmation de base üß§ ‚úäüèΩ üë¶üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Cet article ne se concentrera pas tant sur les graphiques que sur la mani√®re dont l'application qui les utilise doit √™tre organis√©e, en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Techniques de programmation de base</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437688/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><h1>  Pr√©sentation </h1><br>  Cet article ne se concentrera pas tant sur les graphiques que sur la mani√®re dont l'application qui les utilise doit √™tre organis√©e, en tenant compte des sp√©cificit√©s du moteur OpenSceneGraph et des logiciels qu'il fournit. <br><br>  Ce n'est un secret pour personne que la cl√© du succ√®s de tout produit logiciel est une architecture bien con√ßue qui permet de maintenir et d'√©tendre le code √©crit.  En ce sens, le moteur que nous envisageons est √† un niveau assez √©lev√©, fournissant au d√©veloppeur une bo√Æte √† outils tr√®s large, permettant la construction d'une architecture modulaire flexible. <br><br>  Cet article est assez long et comprend un aper√ßu des diff√©rents outils et techniques (mod√®les de conception, si vous le souhaitez) fournis par le moteur de d√©veloppement.  Toutes les sections de l'article sont fournies avec des exemples, dont le code peut √™tre pris dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon r√©f√©rentiel</a> . <br><a name="habracut"></a><br><h1>  1. Analyse des options de ligne de commande </h1><br>  En C / C ++, les param√®tres de ligne de commande sont transmis via les arguments √† la fonction main ().  Dans les exemples pr√©c√©dents, nous avons soigneusement marqu√© ces param√®tres comme inutilis√©s, nous allons maintenant les utiliser pour indiquer √† notre programme certaines donn√©es au d√©marrage. <br><br>  OSG poss√®de des outils d'analyse de ligne de commande int√©gr√©s. <br><br>  Cr√©ez l'exemple suivant <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de ligne de commande</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre> <br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ArgumentParser args(&amp;argc, argv); std::string filename; args.read(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"--model"</span></span></span><span class="hljs-meta">, filename); osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; root = osgDB::readNodeFile(filename); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  D√©finissez les param√®tres de d√©marrage du programme dans QtCreator <br><br><img src="https://habrastorage.org/webt/41/le/8p/41le8pjjdv2q-in3idhgnpe6-ao.png"><br><br>  En ex√©cutant le programme pour l'ex√©cution, nous obtenons le r√©sultat (mod√®le de camion <a href="">tir√© des m√™mes donn√©es OpenSceneGraph</a> ) <br><br><img src="https://habrastorage.org/webt/t-/_o/bb/t-_obbiwlzwuax1e336kqd6tosy.png"><br><br>  Voyons maintenant un exemple ligne par ligne <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>;</code> </pre><br>  cr√©e une instance de la classe d'analyseur de ligne de commande osg :: ArgumentParser.  Une fois cr√©√©, le constructeur de classe re√ßoit les arguments accept√©s par la fonction main () du syst√®me d'exploitation. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filename; args.read(<span class="hljs-string"><span class="hljs-string">"--model"</span></span>, filename);</code> </pre><br>  nous analysons les arguments, √† savoir, nous recherchons la cl√© ¬´‚Äìmodel¬ª parmi eux, en mettant sa valeur dans le nom de fichier de la cha√Æne.  Ainsi, en utilisant cette cl√©, nous transf√©rons le nom du fichier avec un mod√®le tridimensionnel au programme.  Ensuite, nous chargeons ce mod√®le et l'afficher <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFile(filename); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  La m√©thode read () de la classe osg :: ArgumentParser a beaucoup de surcharges, vous permettant de lire non seulement les valeurs de cha√Æne de la ligne de commande, mais aussi les entiers, les nombres √† virgule flottante, les vecteurs, etc.  Par exemple, vous pouvez lire un certain param√®tre de type float <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> size = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; args.read(<span class="hljs-string"><span class="hljs-string">"--size"</span></span>, size);</code> </pre><br>  Si ce param√®tre n'est pas affich√© sur la ligne de commande, sa valeur restera telle qu'elle √©tait apr√®s l'initialisation de la variable de taille. <br><br><h1>  2. M√©canisme de notification et d'enregistrement </h1><br>  OpenSceneGraph dispose d'un m√©canisme de notification qui vous permet d'afficher des messages de d√©bogage pendant le processus de rendu, ainsi qu'initi√©s par le d√©veloppeur.  Ceci est d'une grande aide lors du tra√ßage et du d√©bogage d'un programme.  Le syst√®me de notification OSG prend en charge la sortie des informations de diagnostic (erreurs, avertissements, notifications) au niveau du c≈ìur du moteur et de ses plug-ins.  Le d√©veloppeur peut afficher un message de diagnostic pendant le fonctionnement du programme en utilisant la fonction osg :: notify (). <br><br>  Cette fonction fonctionne comme un flux de sortie standard de la biblioth√®que C ++ standard via une surcharge d'op√©rateur &lt;&lt;.  Il prend le niveau du message comme argument: TOUJOURS, FATAL, WARN, NOTICE, INFO, DEBUG_INFO et DEBUG_FP.  Par exemple <br><br><pre> <code class="cpp hljs">osg::notify(osg::WARN) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some warning message"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  affiche un avertissement avec du texte d√©fini par l'utilisateur. <br><br>  Les notifications OSG peuvent contenir des informations importantes sur l'√©tat du programme, les extensions du sous-syst√®me graphique de l'ordinateur, les probl√®mes possibles avec le moteur. <br><br>  Dans certains cas, il est n√©cessaire de sortir ces donn√©es non pas sur la console, mais pour pouvoir rediriger cette sortie vers un fichier (sous la forme d'un journal) ou vers toute autre interface, y compris un widget graphique.  Le moteur contient une classe sp√©ciale osg :: NotifyHandler qui fournit la redirection des notifications vers le flux de sortie dont le d√©veloppeur a besoin. <br><br>  √Ä l'aide d'un exemple simple, r√©fl√©chissez √† la mani√®re de rediriger la sortie des notifications, par exemple, vers un fichier journal de texte.  √âcrivez le code suivant <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de notification</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;fstream&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> class LogFileHandler : public osg::NotifyHandler { public: LogFileHandler(const std::string &amp;file) { _log.open(file.c_str()); } virtual ~LogFileHandler() { _log.close(); } virtual void notify(osg::NotifySeverity severity, const char *msg) { _log </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; msg; } protected: std::ofstream _log; }; int main(int argc, char *argv[]) { osg::setNotifyLevel(osg::INFO); osg::setNotifyHandler(new LogFileHandler("../logs/log.txt")); osg::ArgumentParser args(&amp;argc, argv); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); if (!root) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; ": No data loaded." &lt;&lt; std::endl; return -1; } osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Pour rediriger la sortie, nous √©crivons la classe LogFileHandler, qui est le successeur de osg :: NotifyHandler.  Le constructeur et le destructeur de cette classe contr√¥lent l'ouverture et la fermeture du flux de sortie _log auquel le fichier texte est associ√©.  La m√©thode notify () est une m√©thode de classe de base similaire que nous avons red√©finie pour afficher dans le fichier les notifications envoy√©es par OSG pendant le fonctionnement via le param√®tre msg. <br><br>  <strong>Classe LogFileHandler</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogFileHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NotifyHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: LogFileHandler(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;file) { _log.open(file.c_str()); } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~LogFileHandler() { _log.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NotifySeverity severity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *msg)</span></span></span><span class="hljs-function"> </span></span>{ _log &lt;&lt; msg; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ofstream _log; };</code> </pre><br>  Ensuite, dans le programme principal, effectuez les r√©glages n√©cessaires <br><br><pre> <code class="cpp hljs">osg::setNotifyLevel(osg::INFO);</code> </pre><br>  d√©finissez le niveau des notifications INFO, c'est-√†-dire la sortie dans le journal de toutes les informations sur le fonctionnement du moteur, y compris les notifications actuelles de fonctionnement normal. <br><br><pre> <code class="cpp hljs">osg::setNotifyHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LogFileHandler(<span class="hljs-string"><span class="hljs-string">"../logs/log.txt"</span></span>));</code> </pre><br>  installez le gestionnaire de notification.  Ensuite, nous traitons les arguments de ligne de commande dans lesquels les chemins d'acc√®s aux mod√®les charg√©s sont pass√©s <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>; osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">": No data loaded."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  Dans le m√™me temps, nous g√©rons la situation de manque de donn√©es sur la ligne de commande, affichant un message dans le journal en mode manuel √† l'aide de la macro OSG_FATAL.  Ex√©cutez le programme avec les arguments suivants <br><br><img src="https://habrastorage.org/webt/mc/h4/so/mch4sot5pfjjpq9vb2dlolnjllm.png"><br><br>  obtenir la sortie dans un fichier journal comme celui-ci <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de journal OSG</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Opened DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_osgd.dll CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() Opened DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_deprecated_osgd.dll OSGReaderWriter wrappers loaded OK CullSettings::readEnvironmentalVariables() void StateSet::setGlobalDefaults() void StateSet::setGlobalDefaults() ShaderPipeline disabled. StateSet::setGlobalDefaults() Setting up GL2 compatible shaders CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() ShaderComposer::ShaderComposer() 0xa5ce8f0 CullSettings::readEnvironmentalVariables() ShaderComposer::ShaderComposer() 0xa5ce330 View::setSceneData() Reusing existing scene0xa514220 CameraManipulator::computeHomePosition(0, 0) boundingSphere.center() = (-6.40034 1.96225 0.000795364) boundingSphere.radius() = 16.6002 CameraManipulator::computeHomePosition(0xa52f138, 0) boundingSphere.center() = (-6.40034 1.96225 0.000795364) boundingSphere.radius() = 16.6002 Viewer::realize() - No valid contexts found, setting up view across all screens. Applying osgViewer::ViewConfig : AcrossAllScreens . . . . ShaderComposer::~ShaderComposer() 0xa5ce330 ShaderComposer::~ShaderComposer() 0xa5ce8f0 ShaderComposer::~ShaderComposer() 0xa5d6228 close(0x1)0xa5d3e50 close(0)0xa5d3e50 ContextData::unregisterGraphicsContext 0xa5d3e50 DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. ShaderComposer::~ShaderComposer() 0xa5de4e0 close(0x1)0xa5ddba0 close(0)0xa5ddba0 ContextData::unregisterGraphicsContext 0xa5ddba0 Done destructing osg::View DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. Closing DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_osgd.dll Closing DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_deprecated_osgd.dll</code> </pre><br></div></div><br>  Peu importe que ces informations vous semblent inutiles pour le moment - √† l'avenir, une telle conclusion peut aider √† d√©boguer des erreurs dans votre programme. <br><br>  Par d√©faut, OSG envoie des messages √† la sortie standard std :: cout et des messages d'erreur au flux std :: cerr.  Cependant, en rempla√ßant le gestionnaire de notification, comme indiqu√© dans l'exemple, cette sortie peut √™tre redirig√©e vers n'importe quel flux de sortie, y compris les √©l√©ments GUI. <br><br>  Gardez √† l'esprit que lors de la d√©finition d'un niveau √©lev√© de notifications (par exemple, FATAL), le syst√®me ignore toutes les notifications d'un niveau inf√©rieur.  Par exemple, dans un cas similaire <br><br><pre> <code class="cpp hljs">osg::setNotifyLevel(osg::FATAL); . . . osg::notify(osg::WARN) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some message."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  un message personnalis√© ne sera tout simplement pas affich√©. <br><br><h1>  3. Interception d'attributs g√©om√©triques </h1><br>  La classe osg :: Geometry g√®re un ensemble de donn√©es d√©crivant les sommets et affiche un maillage polygonal √† l'aide d'un ensemble ordonn√© de primitives.  Cependant, cette classe n'a aucune id√©e des √©l√©ments de la topologie du mod√®le tels que les faces, les ar√™tes et la relation entre eux.  Cette nuance emp√™che la mise en ≈ìuvre de choses telles que le d√©placement de certains visages, par exemple, lors de l'animation de mod√®les.  OSG ne prend actuellement pas en charge cette fonctionnalit√©. <br><br>  Cependant, le moteur impl√©mente un certain nombre de foncteurs qui vous permettent de relire les attributs de g√©om√©trie de n'importe quel objet et de les utiliser pour mod√©liser la topologie du maillage polygonal.  En C ++, un foncteur est une construction qui vous permet d'utiliser un objet comme fonction. <br><br>  La classe osg :: Drawable fournit au d√©veloppeur quatre types de foncteurs: <br><br><ol><li>  osg :: Drawable :: AttributeFunctor - lit les attributs des sommets comme un tableau de pointeurs.  Il dispose d'un certain nombre de m√©thodes virtuelles pour appliquer des attributs de sommet de diff√©rents types de donn√©es.  Pour utiliser ce foncteur, vous devez d√©crire la classe et remplacer une ou plusieurs de ses m√©thodes, dans lesquelles les actions requises par le d√©veloppeur sont effectu√©es <br></li></ol><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Drawable::AttributeType type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, osg::Vec3* ptr )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  3-     ptr. //      }</span></span></code> </pre><br><ol><li>  osg :: Drawable :: ConstAttributeFunctor - version en lecture seule du foncteur pr√©c√©dent: un pointeur vers un tableau de vecteurs est pass√© en param√®tre constant <br></li><li>  osg :: PrimitiveFunctor - imite le processus de rendu des objets OpenGL.  Sous pr√©texte de restituer un objet, les m√©thodes de foncteur remplac√©es par le d√©veloppeur sont appel√©es.  Ce foncteur poss√®de deux sous-classes de mod√®les importantes: osg :: TemplatePrimitiveFunctor &lt;&gt; et osg :: TriangleFunctor &lt;&gt;.  Ces classes re√ßoivent des sommets primitifs en tant que param√®tres et les transmettent aux m√©thodes utilisateur √† l'aide de l'op√©rateur operator (). <br></li><li>  osg :: PrimitiveIndexFunctor - effectue les m√™mes actions que le foncteur pr√©c√©dent, mais accepte les indices de vertex de la primitive comme param√®tre. <br></li></ol><br>  Les classes d√©riv√©es d'osg :: Drawable, telles que osg :: ShapeDrawable et osg :: Geometry, ont une m√©thode accept () pour appliquer divers foncteurs. <br><br><h1>  4. Exemple d'utilisation du foncteur primitif </h1><br>  Nous illustrons la fonctionnalit√© d√©crite en utilisant l'exemple de collecte d'informations sur les faces triangulaires et les points de certaines g√©om√©tries que nous avons pr√©c√©demment d√©termin√©es. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de foncteur</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geode&gt; #include &lt;osg/Geometry&gt; #include &lt;osg/TriangleFunctor&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> std::string vec2str(const osg::Vec3 &amp;v) { std::string tmp = std::to_string(vx()); tmp += </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" "</span></span></span><span class="hljs-meta">; tmp += std::to_string(vy()); tmp += </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" "</span></span></span><span class="hljs-meta">; tmp += std::to_string(vz()); return tmp; } struct FaceCollector { void operator()(const osg::Vec3 &amp;v1, const osg::Vec3 &amp;v2, const osg::Vec3 &amp;v3) { std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Face vertices: " &lt;&lt; vec2str(v1) &lt;&lt; "; " &lt;&lt; vec2str(v2) &lt;&lt; "; " &lt;&lt; vec2str(v3) &lt;&lt; std::endl; } }; int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.5f) ); vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(3.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(3.0f, 0.0f, 1.5f) ); vertices-&gt;push_back( osg::Vec3(4.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(4.0f, 0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUAD_STRIP, 0, 10)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); osg::TriangleFunctor&lt;FaceCollector&gt; functor; geom-&gt;accept(functor); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  En omettant le processus de cr√©ation de g√©om√©trie que nous consid√©rons plusieurs fois, pr√™tons attention aux points suivants.  Nous d√©finissons une structure FaceCollector pour laquelle nous red√©finissons operator () comme suit <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FaceCollector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Face vertices: "</span></span> &lt;&lt; vec2str(v1) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; "</span></span> &lt;&lt; vec2str(v2) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; "</span></span> &lt;&lt; vec2str(v3) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br>  Cet op√©rateur, une fois appel√©, affichera les coordonn√©es des trois sommets qui lui sont transmis par le moteur.  La fonction vec2str est requise pour traduire les composants du vecteur osg :: Vec3 en std :: string.  Pour appeler le foncteur, cr√©ez-en une instance et passez-la √† l'objet g√©om√©trie via la m√©thode accept () <br><br><pre> <code class="cpp hljs">osg::TriangleFunctor&lt;FaceCollector&gt; functor; geom-&gt;accept(functor);</code> </pre><br>  Cet appel, comme mentionn√© ci-dessus, imite le rendu de la g√©om√©trie, rempla√ßant le dessin lui-m√™me en appelant une m√©thode fonctor red√©finie.  Dans ce cas, il sera appel√© lors du "dessin" de chacun des triangles qui composent la g√©om√©trie de l'exemple. <br><br>  Sur l'√©cran, nous obtenons une telle g√©om√©trie <br><br><img src="https://habrastorage.org/webt/ai/-a/6v/ai-a6vj4eeubetgk0bpicmjbgfm.png"><br><br>  et un tel √©chappement √† la console <br><br><pre> <code class="plaintext hljs">Face vertices: 0.000000 0.000000 0.000000; 0.000000 0.000000 1.000000; 1.000000 0.000000 0.000000 Face vertices: 0.000000 0.000000 1.000000; 1.000000 0.000000 1.500000; 1.000000 0.000000 0.000000 Face vertices: 1.000000 0.000000 0.000000; 1.000000 0.000000 1.500000; 2.000000 0.000000 0.000000 Face vertices: 1.000000 0.000000 1.500000; 2.000000 0.000000 1.000000; 2.000000 0.000000 0.000000 Face vertices: 2.000000 0.000000 0.000000; 2.000000 0.000000 1.000000; 3.000000 0.000000 0.000000 Face vertices: 2.000000 0.000000 1.000000; 3.000000 0.000000 1.500000; 3.000000 0.000000 0.000000 Face vertices: 3.000000 0.000000 0.000000; 3.000000 0.000000 1.500000; 4.000000 0.000000 0.000000 Face vertices: 3.000000 0.000000 1.500000; 4.000000 0.000000 1.000000; 4.000000 0.000000 0.000000</code> </pre><br>  En fait, lors de l'appel √† geom-&gt; accept (...), les triangles ne sont pas rendus, les appels OpenGL sont simul√©s, et au lieu d'eux des donn√©es sur les sommets du triangle, dont le rendu est simul√© <br><br><img src="https://habrastorage.org/webt/gx/gp/il/gxgpilewn7pw26w9tdy-e28ypds.png"><br><br>  La classe osg :: TemplatePrimitiveFunctor collecte des donn√©es non seulement sur les triangles, mais √©galement sur toutes les autres primitives OpenGL.  Pour impl√©menter le traitement de ces donn√©es, vous devez remplacer les op√©rateurs suivants dans l'argument mod√®le <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   void operator()( const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, bool );</span></span></code> </pre><br><br><h1>  5. Le mod√®le de visiteur </h1><br>  Le mod√®le de visiteur est utilis√© pour acc√©der aux op√©rations de modification des √©l√©ments du graphique de sc√®ne sans modifier les classes de ces √©l√©ments.  La classe visiteur impl√©mente toutes les fonctions virtuelles pertinentes pour les appliquer √† diff√©rents types d'√©l√©ments via un m√©canisme de double r√©partition.  √Ä l'aide de ce m√©canisme, le d√©veloppeur peut cr√©er sa propre instance de visiteur en impl√©mentant la fonctionnalit√© dont il a besoin √† l'aide d'op√©rateurs sp√©ciaux et lier le visiteur √† divers types d'√©l√©ments de graphique de sc√®ne √† la vol√©e, sans modifier la fonctionnalit√© des √©l√©ments eux-m√™mes.  Il s'agit d'un excellent moyen d'√©tendre les fonctionnalit√©s d'un √©l√©ment sans d√©finir de sous-classes de ces √©l√©ments. <br><br>  Pour impl√©menter ce m√©canisme dans OSG, la classe osg :: NodeVisitor est d√©finie.  La classe h√©rit√©e d'osg :: NodeVisitor se d√©place dans le graphique de la sc√®ne, visite chaque n≈ìud et lui applique les op√©rations d√©finies par le d√©veloppeur.  Il s'agit de la classe principale utilis√©e pour intervenir dans le processus de mise √† jour des n≈ìuds et de d√©coupage des n≈ìuds invisibles, ainsi que pour appliquer d'autres op√©rations li√©es √† la modification de la g√©om√©trie des n≈ìuds de sc√®ne, telles que osgUtil :: SmoothingVisitor, osgUtil :: Simplifier et osgUtil :: TriStripVisitor. <br><br>  Pour sous-classer le visiteur, nous devons remplacer une ou plusieurs m√©thodes apply () surcharg√©es virtuelles fournies par la classe de base osg :: NodeVisitor.  La plupart des principaux types de n≈ìuds OSG ont ces m√©thodes.  Le visiteur appellera automatiquement la m√©thode apply () pour chacun des n≈ìuds visit√©s lors de la travers√©e du graphe de la sc√®ne.  Le d√©veloppeur remplace la m√©thode apply () pour chacun des types de n≈ìuds dont il a besoin. <br><br>  Dans l'impl√©mentation de la m√©thode apply (), le d√©veloppeur, au moment appropri√©, doit appeler la m√©thode traverse () de la classe de base osg :: NodeVisitor.  Cela lance la transition du visiteur vers le n≈ìud suivant, soit un enfant ou un voisin au niveau de la hi√©rarchie, si le n≈ìud actuel ne poss√®de aucun n≈ìud enfant vers lequel la transition peut √™tre effectu√©e.  L'absence d'un appel √† traverse () signifie arr√™ter la travers√©e du graphe de sc√®ne et le reste du graphe de sc√®ne est ignor√©. <br><br>  Les surcharges de la m√©thode apply () ont des formats unifi√©s <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Node&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Geode&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Group&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Transform&amp; )</span></span></span></span>;</code> </pre><br>  Pour contourner le sous-graphique du n≈ìud actuel de l'objet visiteur, vous devez d√©finir le mode d'analyse, par exemple, <br><br><pre> <code class="cpp hljs">ExampleVisitor visitor; visitor-&gt;setTraversalMode( osg::NodeVisitor::TRAVERSE_ALL_CHILDREN ); node-&gt;accept( visitor );</code> </pre><br>  Le mode de contournement est d√©fini par plusieurs √©num√©rateurs <br><br><ol><li>  TRAVERSE_ALL_CHILDREN - se d√©pla√ßant √† travers tous les n≈ìuds enfants. <br></li><li>  TRAVERSE_PARENTS - repasse du n≈ìud actuel, n'atteignant pas le n≈ìud racine <br></li><li>  TRAVERSE_ACTIVE_CHILDREN - contourne exclusivement les n≈ìuds actifs, c'est-√†-dire ceux dont la visibilit√© est activ√©e via le n≈ìud osg :: Switch. <br></li></ol><br><br><h1>  6. Analyse de la structure du cessna br√ªlant </h1><br>  Le d√©veloppeur peut toujours analyser la partie du graphique de sc√®ne g√©n√©r√©e par le mod√®le charg√© √† partir du fichier. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de foncteur</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class InfoVisitor : public osg::NodeVisitor { public: InfoVisitor() : _level(0) { setTraversalMode(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN); } std::string spaces() { return std::string(_level * 2, ' '); } virtual void apply(osg::Node &amp;node); virtual void apply(osg::Geode &amp;geode); protected: unsigned int _level; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void InfoVisitor::apply(osg::Node &amp;node) { std::cout &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; "::" &lt;&lt; node.className() &lt;&lt; std::endl; _level++; traverse(node); _level--; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void InfoVisitor::apply(osg::Geode &amp;geode) { std::cout &lt;&lt; spaces() &lt;&lt; geode.libraryName() &lt;&lt; "::" &lt;&lt; geode.className() &lt;&lt; std::endl; _level++; for (unsigned int i = 0; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); std::cout &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; "::" &lt;&lt; drawable-&gt;className() &lt;&lt; std::endl; } traverse(geode); _level--; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { osg::ArgumentParser args(&amp;argc, argv); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); if (!root.valid()) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; ": No data leaded. " &lt;&lt; std::endl; return -1; } InfoVisitor infoVisitor; root-&gt;accept(infoVisitor); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Nous cr√©ons la classe InfoVisitor, en l'h√©ritant d'osg :: NodeVisitor <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InfoVisitor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NodeVisitor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: InfoVisitor() : _level(<span class="hljs-number"><span class="hljs-number">0</span></span>) { setTraversalMode(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(_level * <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Node &amp;node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Geode &amp;geode)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _level; };</code> </pre><br>  La propri√©t√© _level prot√©g√©e pointera vers le niveau du graphique de sc√®ne o√π se trouve actuellement notre classe de visiteurs.  Dans le constructeur, initialisez le compteur de niveau et d√©finissez le mode de travers√©e des n≈ìuds - pour contourner tous les n≈ìuds enfants. <br><br>  Red√©finissez maintenant les m√©thodes apply () pour les n≈ìuds <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> InfoVisitor::apply(osg::Node &amp;node) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; node.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _level++; traverse(node); _level--; }</code> </pre><br>  Ici, nous afficherons le type du n≈ìud actuel.  La m√©thode libraryName () pour le n≈ìud affiche le nom de la biblioth√®que OSG o√π ce n≈ìud est impl√©ment√©, et la m√©thode className affiche le nom de la classe de n≈ìud.  Ces m√©thodes sont impl√©ment√©es gr√¢ce √† l'utilisation de macros dans le code des biblioth√®ques OSG. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; node.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Apr√®s cela, nous augmentons le compteur de niveau du graphique et appelons la m√©thode traverse (), initiant une transition vers un niveau sup√©rieur, vers le n≈ìud enfant.  Apr√®s √™tre revenu de traverse (), nous diminuons √† nouveau la valeur du compteur.  Il est facile de deviner que traverse () lance un appel r√©p√©t√© √† la m√©thode apply (), d√©j√† travers√©e () pour un sous-graphe √† partir du n≈ìud courant.  Nous obtenons une ex√©cution r√©cursive des visiteurs jusqu'√† ce que nous atteignions les n≈ìuds d'extr√©mit√© du graphique de sc√®ne. <br><br>  Pour un n≈ìud d'extr√©mit√© de type osg :: Geode, sa surcharge de la m√©thode apply () est surcharg√©e <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> InfoVisitor::apply(osg::Geode &amp;geode) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; geode.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; geode.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _level++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; drawable-&gt;className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } traverse(geode); _level--; }</code> </pre><br>  avec un code fonctionnant de la m√™me mani√®re, sauf que nous affichons des donn√©es sur tous les objets g√©om√©triques attach√©s au n≈ìud g√©om√©trique actuel <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; drawable-&gt;className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  Dans la fonction main (), nous traitons les arguments de ligne de commande √† travers lesquels nous passons une liste de mod√®les charg√©s dans la sc√®ne et formons la sc√®ne <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>; osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root.valid()) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">": No data leaded. "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  Dans le m√™me temps, nous traitons les erreurs li√©es √† l'absence de noms de fichiers de mod√®le sur la ligne de commande.  Maintenant, nous cr√©ons une classe de visiteurs et la passons au graphe de sc√®ne pour l'ex√©cuter <br><br><pre> <code class="cpp hljs">InfoVisitor infoVisitor; root-&gt;accept(infoVisitor);</code> </pre><br>  Voici les √©tapes pour lancer la visionneuse, ce que nous avons d√©j√† fait plusieurs fois.  Apr√®s avoir d√©marr√© le programme avec des param√®tres <br><br><pre> <code class="bash hljs">$ visitor ../data/cessnafire.osg</code> </pre><br>  nous verrons la sortie suivante sur la console <br><br><pre> <code class="plaintext hljs">osg::Group osg::MatrixTransform osg::Geode osg::Geometry osg::Geometry osg::MatrixTransform osgParticle::ModularEmitter osgParticle::ModularEmitter osgParticle::ParticleSystemUpdater osg::Geode osgParticle::ParticleSystem osgParticle::ParticleSystem osgParticle::ParticleSystem osgParticle::ParticleSystem</code> </pre><br>  En fait, nous avons obtenu un arbre complet de la sc√®ne charg√©e.  Excusez-moi, o√π sont autant de n≈ìuds?  Tout est tr√®s simple - les mod√®les au format * .osg sont eux-m√™mes des conteneurs qui stockent non seulement des donn√©es sur la g√©om√©trie du mod√®le, mais √©galement d'autres informations sur sa structure sous la forme d'un sous-graphique de la sc√®ne OSG.  La g√©om√©trie du mod√®le, les transformations, les effets de particules qui r√©alisent la fum√©e et la flamme sont tous des n≈ìuds du graphique de sc√®ne OSG.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toute sc√®ne peut √™tre t√©l√©charg√©e √† partir de * .osg ou d√©charg√©e de la visionneuse au format * .osg. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est un exemple simple d'application de la m√©canique des visiteurs. </font><font style="vertical-align: inherit;">En fait, √† l'int√©rieur des visiteurs, vous pouvez effectuer de nombreuses op√©rations pour modifier les n≈ìuds lorsque le programme est en cours d'ex√©cution.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Contr√¥le du comportement des n≈ìuds dans le graphe de sc√®ne en rempla√ßant la m√©thode traverse () </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fa√ßon importante de travailler avec OSG est de remplacer la m√©thode traverse (). Cette m√©thode est appel√©e chaque fois qu'une image est dessin√©e. Ils acceptent un param√®tre de type osg :: NodeVisitor &amp; qui signale quel passage du graphe de sc√®ne est actuellement en cours (mise √† jour, traitement d'√©v√©nement ou √©cr√™tage). La plupart des h√¥tes OSG remplacent cette m√©thode pour impl√©menter leurs fonctionnalit√©s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne faut pas oublier que remplacer la m√©thode traverse () peut √™tre dangereux, car il affecte le processus de travers√©e du graphe de la sc√®ne et peut conduire √† un affichage incorrect de la sc√®ne. Il est √©galement g√™nant si vous souhaitez ajouter de nouvelles fonctionnalit√©s √† plusieurs types de n≈ìuds. Dans ce cas, des rappels de n≈ìuds sont utilis√©s, dont la conversation ira un peu plus bas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous savons d√©j√† que le n≈ìud osg :: Switch peut contr√¥ler l'affichage de ses n≈ìuds enfants, y compris l'affichage de certains n≈ìuds et d√©sactiver l'affichage des autres. </font><font style="vertical-align: inherit;">Mais il ne sait pas comment le faire automatiquement, nous allons donc cr√©er un nouveau n≈ìud bas√© sur l'ancien, qui basculera entre les n≈ìuds enfants √† diff√©rents moments, conform√©ment √† la valeur du compteur interne.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple Animswitch</font></font></b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class AnimatingSwitch : public osg::Switch { public: AnimatingSwitch() : osg::Switch(), _count(0) {} AnimatingSwitch(const AnimatingSwitch &amp;copy, const osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {} META_Node(osg, AnimatingSwitch); virtual void traverse(osg::NodeVisitor &amp;nv); protected: unsigned int _count; }; void AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { if (!((++_count) % 60) ) { setValue(0, !getValue(0)); setValue(1, !getValue(1)); } osg::Switch::traverse(nv); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;AnimatingSwitch&gt; root = new AnimatingSwitch; root-&gt;addChild(model1.get(), true); root-&gt;addChild(model2.get(), false); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetons un ≈ìil √† cet exemple. </font><font style="vertical-align: inherit;">Nous cr√©ons une nouvelle classe AnimatingSwitch qui h√©rite d'osg :: Switch.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimatingSwitch</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Switch { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AnimatingSwitch() : osg::Switch(), _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} AnimatingSwitch(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatingSwitch &amp;copy, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {} META_Node(osg, AnimatingSwitch); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NodeVisitor &amp;nv)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) ) { setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } osg::Switch::traverse(nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cette classe contient le constructeur par d√©faut. </font></font><br><br><pre> <code class="cpp hljs">AnimatingSwitch() : osg::Switch(), _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et constructeur pour la copie, cr√©√© conform√©ment aux exigences de l'OSG </font></font><br><br><pre> <code class="cpp hljs">AnimatingSwitch(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatingSwitch &amp;copy, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le constructeur pour la copie doit contenir comme param√®tres: une r√©f√©rence constante √† l'instance de classe √† copier et le param√®tre osg :: CopyOp sp√©cifiant les param√®tres de copie de la classe. </font><font style="vertical-align: inherit;">Des lettres assez √©tranges suivent</font></font><br><br><pre> <code class="cpp hljs">META_Node(osg, AnimatingSwitch);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'une macro qui forme la structure n√©cessaire pour le descendant d'une classe d√©riv√©e de osg :: Node. </font><font style="vertical-align: inherit;">Jusqu'√† ce que nous attachions de l'importance √† cette macro, il est important qu'elle soit pr√©sente lors de l'h√©ritage d'osg :: Switch lors de la d√©finition de toutes les classes descendantes. </font><font style="vertical-align: inherit;">La classe contient le champ prot√©g√© _count - le compteur m√™me sur lequel nous basculons. </font><font style="vertical-align: inherit;">Nous impl√©mentons la commutation lors de la substitution de la m√©thode traverse ()</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) ) { setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } osg::Switch::traverse(nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La commutation de l'√©tat d'affichage des n≈ìuds se produira chaque fois que la valeur du compteur (incr√©mentation de chaque appel de m√©thode) est un multiple de 60. Nous compilons l'exemple et l'ex√©cutons </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z5/fl/2u/z5fl2uhbnzxafceoro_wbga-pk4.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que la m√©thode traverse () est constamment red√©finie pour divers types de n≈ìuds, elle devrait fournir un m√©canisme pour obtenir des matrices de transformation et rendre les √©tats pour une utilisation ult√©rieure par leur algorithme surcharg√©. </font><font style="vertical-align: inherit;">Le param√®tre d'entr√©e osg :: NodeVisitor est la cl√© de diverses op√©rations avec des n≈ìuds. </font><font style="vertical-align: inherit;">En particulier, il indique le type de travers√©e actuelle du graphique de sc√®ne, comme la mise √† jour, le traitement des √©v√©nements et l'√©cr√™tage des faces invisibles. </font><font style="vertical-align: inherit;">Les deux premiers sont li√©s aux rappels de n≈ìuds et seront pris en compte lors de l'√©tude de l'animation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La passe de d√©tourage peut √™tre identifi√©e en convertissant l'objet osg :: NodeVisitor en objet osg :: CullVisitor</font></font><br><br><pre> <code class="cpp hljs">osgUtil::CullVisitor *cv = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgUtil::CullVisitor *&gt;(&amp;nv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cv) { <span class="hljs-comment"><span class="hljs-comment">///  - ,     }</span></span></code> </pre><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. M√©canisme de rappel </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article pr√©c√©dent,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous avons impl√©ment√© l'animation d'un objet de sc√®ne en modifiant les param√®tres de sa transformation √† l'int√©rieur du cycle de rendu de sc√®ne. Comme cela a √©t√© mentionn√© √† plusieurs reprises, cette approche contient un comportement d'application potentiellement dangereux dans le rendu multi-thread. Pour r√©soudre ce probl√®me, un m√©canisme de rappel est utilis√© lors de la travers√©e du graphe de sc√®ne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe plusieurs types de rappels dans le moteur. Les rappels sont impl√©ment√©s par des classes sp√©ciales, parmi lesquelles osg :: NodeCallback est con√ßu pour g√©rer le processus de mise √† jour des n≈ìuds de sc√®ne, et osg :: Drawable :: UpdateCallback, osg :: Drawable :: EventCallback et osg :: Drawable: CullCallback - ex√©cute les m√™mes fonctions, mais pour les objets de g√©om√©trie.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La classe osg :: NodeCallback poss√®de un op√©rateur virtual () rempla√ßable fourni par le d√©veloppeur pour impl√©menter ses propres fonctionnalit√©s. </font><font style="vertical-align: inherit;">Pour que le rappel fonctionne, vous devez attacher une instance de la classe d'appel au n≈ìud pour lequel il sera trait√© en appelant la m√©thode setUpdateCallback () ou addUpdateCallback (). </font><font style="vertical-align: inherit;">L'op√©rateur operator () est automatiquement appel√© lors de la mise √† jour des n≈ìuds du graphe de sc√®ne lors du rendu de chaque image. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le tableau suivant r√©pertorie les rappels disponibles pour le d√©veloppeur dans OSG.</font></font><br><br><table><thead><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pr√©nom </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fonction de rappel </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©thode virtuelle </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©thode pour attacher √† un objet </font></font></th></tr></thead><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mise √† jour du n≈ìud </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> op√©rateur () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setUpdateCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âv√©nement de n≈ìud </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> op√©rateur () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setEventCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âcr√™tage des n≈ìuds </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> op√©rateur () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setCullCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mise √† jour de la g√©om√©trie </font></font></td><td> osg::Drawable::UpdateCallback </td><td> update() </td><td> osg::Drawable::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::Drawable::EventCallback </td><td> event() </td><td> osg::Drawable::setEventCallback() </td></tr><tr><td>   </td><td> osg::Drawable::CullCallback </td><td> cull() </td><td> osg::Drawable::setCullCallback() </td></tr><tr><td>   </td><td> osg::StateAttributeCallback </td><td> operator() </td><td> osg::StateAttribute::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::StateAttributeCallback </td><td> operator() </td><td> osg::StateAttribute::setEventCallback() </td></tr><tr><td>   </td><td> osg::Uniform::Callback </td><td> operator() </td><td> osg::Uniform::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::Uniform::Callback </td><td> operator() </td><td> osg::Uniform::setEvevtCallback() </td></tr><tr><td>       </td><td> osg::Camera::DrawCallback </td><td> operator() </td><td> osg::Camera::PreDrawCallback() </td></tr><tr><td>       </td><td> osg::Camera::DrawCallback </td><td> operator() </td><td> osg::Camera::PostDrawCallback() </td></tr></tbody></table><br><br><h1> 9.  osg::Switch     </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu plus haut, nous avons √©crit un exemple avec la commutation de deux mod√®les d'avion. </font><font style="vertical-align: inherit;">Nous allons maintenant r√©p√©ter cet exemple, mais nous ferons tout correctement en utilisant le m√©canisme de rappel OSG.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappel avec exemple</font></font></b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class SwitchingCallback : public osg::NodeCallback { public: SwitchingCallback() : _count(0) {} virtual void operator()(osg::Node *node, osg::NodeVisitor *nv); protected: unsigned int _count; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void SwitchingCallback::operator()(osg::Node *node, osg::NodeVisitor *nv) { osg::Switch *switchNode = static_cast&lt;osg::Switch *&gt;(node); if ( !((++_count) % 60) &amp;&amp; switchNode ) { switchNode-&gt;setValue(0, !switchNode-&gt;getValue(0)); switchNode-&gt;setValue(1, !switchNode-&gt;getValue(0)); } traverse(node, nv); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1, true); root-&gt;addChild(model2, false); root-&gt;setUpdateCallback( new SwitchingCallback ); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous devez cr√©er une classe h√©ritant d'osg :: NodeCallback, qui contr√¥le le n≈ìud osg :: Switch </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwitchingCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NodeCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SwitchingCallback() : _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Node *node, osg::NodeVisitor *nv)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le compteur _count contr√¥lera la commutation du n≈ìud osg :: Switch du mappage d'un n≈ìud enfant √† un autre, en fonction de sa valeur. </font><font style="vertical-align: inherit;">Dans le constructeur, nous initialisons le compteur et red√©finissons la m√©thode virtual operator ()</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SwitchingCallback::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(osg::Node *node, osg::NodeVisitor *nv) { osg::Switch *switchNode = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Switch *&gt;(node); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) &amp;&amp; switchNode ) { switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } traverse(node, nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le n≈ìud sur lequel l'appel a fonctionn√© lui est transmis via le param√®tre de n≈ìud. </font><font style="vertical-align: inherit;">Puisque nous savons avec certitude qu'il s'agira d'un n≈ìud de type osg :: Switch, nous effectuons une conversion statique du pointeur vers le n≈ìud vers le pointeur vers le n≈ìud du commutateur</font></font><br><br><pre> <code class="cpp hljs">osg::Switch *switchNode = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Switch *&gt;(node);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous basculerons les n≈ìuds enfants affich√©s avec la valeur valide de ce pointeur, et lorsque la valeur du compteur est un multiple de 60 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) &amp;&amp; switchNode ) { switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N'oubliez pas d'appeler la m√©thode traverse () pour continuer la travers√©e r√©cursive du graphe de sc√®ne </font></font><br><br><pre> <code class="cpp hljs">traverse(node, nv);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le reste du code du programme est trivial, √† l'exception de la ligne </font></font><br><br><pre> <code class="cpp hljs">root-&gt;setUpdateCallback( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SwitchingCallback );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o√π nous affectons le rappel que nous avons cr√©√© au n≈ìud racine de type osg :: Switch. </font><font style="vertical-align: inherit;">Le programme fonctionne de mani√®re similaire √† l'exemple pr√©c√©dent</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z5/fl/2u/z5fl2uhbnzxafceoro_wbga-pk4.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous avons utilis√© la myst√©rieuse m√©thode traverse () √† deux fins: remplacer cette m√©thode dans les classes successives et appeler cette m√©thode sur la classe osg :: NodeVisitor pour continuer √† parcourir le graphe de la sc√®ne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'exemple que nous venons d'examiner, nous utilisons la troisi√®me option d'appeler traverse (), en passant un pointeur vers le n≈ìud et un pointeur vers l'instance de visiteur comme param√®tres. Comme dans les deux premiers cas, s'il n'y a pas d'appel √† traverse () sur ce noeud, l'analyse du graphe de sc√®ne sera arr√™t√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les m√©thodes addUpdateCallback () servent √©galement √† ajouter un rappel au n≈ìud. Contrairement √† setUpdateCallback (), il est utilis√© pour ajouter un autre rappel aux appels existants. Ainsi, il peut y avoir plusieurs rappels pour le m√™me n≈ìud.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons examin√© les techniques de base utilis√©es dans le d√©veloppement d'applications √† l'aide du moteur graphique OpenSceneGraph. </font><font style="vertical-align: inherit;">Cependant, c'est loin de tous les points que j'aimerais aborder (malgr√© le fait que l'article s'est av√©r√© assez long), donc</font></font><br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437688/">https://habr.com/ru/post/fr437688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437676/index.html">Les universit√©s et les acc√©l√©rateurs d'entreprise comme levier pour lancer une start-up B2B aux √âtats-Unis</a></li>
<li><a href="../fr437680/index.html">Ma collection de bricolage sur Youtube</a></li>
<li><a href="../fr437682/index.html">√âcriture d'un autre outil de cr√©ation de mod√®les Kubernetes</a></li>
<li><a href="../fr437684/index.html">Algorithme supr√™me - Compendium biais√©</a></li>
<li><a href="../fr437686/index.html">Learning Go: √©crire un messager p2p avec un cryptage de bout en bout</a></li>
<li><a href="../fr437694/index.html">Analyse de l'utilitaire Files.walkFileTree ();</a></li>
<li><a href="../fr437696/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 283 (du 21 au 27 janvier)</a></li>
<li><a href="../fr437698/index.html">Service de traduction de brevets de l'OMPI Translate - Mes exp√©riences</a></li>
<li><a href="../fr437702/index.html">Analyse des entrevues d'emploi Google: requ√™tes synonymes</a></li>
<li><a href="../fr437704/index.html">Excellente connaissance du programme scolaire en tant qu'indicateur d'une intelligence pas la plus √©lev√©e</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>