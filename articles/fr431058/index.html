<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüíª üéÖüèΩ üë®üèΩ‚Äç‚öñÔ∏è Premiers pas avec Unicorn Engine ‚õπüèø ‚úã üïµüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de la recherche de "Unicorn Engine" sur Habr, j'ai √©t√© surpris de constater que cet outil n'a jamais √©t√© pr√©sent√© dans les articles. Je vais essa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Premiers pas avec Unicorn Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431058/"><p>  Lors de la recherche de "Unicorn Engine" sur Habr, j'ai √©t√© surpris de constater que cet outil n'a jamais √©t√© pr√©sent√© dans les articles.  Je vais essayer de combler ce vide.  Commen√ßons par les bases et regardons un exemple d'utilisation de l'√©mulateur dans la vie r√©elle.  Afin de ne pas r√©inventer la roue, j'ai d√©cid√© de traduire simplement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> manuel.  <em>Avant de commencer, je dirai que tous mes commentaires ou commentaires ressembleront √† ceci</em> . </p><a name="habracut"></a><br><h1 id="chto-takoe-unicorn-engine">  Qu'est-ce qu'un moteur Unicorn? </h1><br><p>  <em>Les d√©veloppeurs eux-m√™mes √©crivent sur</em> <del>  <em>Moteur Licorne</em> </del>  <em>Unicorn Engine comme ceci:</em> </p><br><blockquote>  Unicorn est un √©mulateur de processeur l√©ger, multi-plateforme et multi-architecture. </blockquote><p>  Ce n'est pas un √©mulateur standard.  Il n'√©mule pas le fonctionnement de l'ensemble du programme ou de l'ensemble du syst√®me d'exploitation.  Il ne prend pas en charge les commandes syst√®me (telles que l'ouverture d'un fichier, la sortie d'un caract√®re sur la console, etc.).  Vous devrez faire le balisage de la m√©moire et y charger vous-m√™me les donn√©es, puis vous d√©marrez simplement l'ex√©cution √† partir d'une adresse sp√©cifique. </p><br><p>  Alors, comment est-ce utile? </p><br><ul><li>  Lors de l'analyse de virus, vous pouvez appeler des fonctions uniques sans cr√©er de processus malveillant. </li><li>  Pour r√©soudre CTF. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pour le fuzzing</a> . </li><li>  <a href="">Un plugin pour gdb</a> pour pr√©dire l'√©tat futur, par exemple, les sauts futurs ou les valeurs de registre. </li><li>  √âmulation d'un code riche en fonctionnalit√©s. </li></ul><br><p>  De quoi avez-vous besoin? </p><br><ul><li>  Moteur Unicorn install√© avec liaison Python. </li><li>  D√©monteur </li></ul><br><h1 id="primer">  Exemple </h1><br><p>  Par exemple, prenez une t√¢che avec hxp CTF 2017 sous le nom <strong><em>Fibonacci</em></strong> .  Le binaire peut √™tre t√©l√©charg√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Lorsque vous d√©marrez le programme, il commence √† afficher notre drapeau dans la console, mais tr√®s lentement.  Chaque octet de drapeau suivant est consid√©r√© de plus en plus lent. </p><br><pre><code class="bash hljs">The flag is: hxp{F</code> </pre> <br><p>  Cela signifie que pour obtenir le drapeau dans un d√©lai raisonnable, nous devons optimiser le fonctionnement de cette application. </p><br><p>  En utilisant IDA Pro ( <em>j'ai personnellement utilis√© radare2 + Cutter</em> ), nous avons d√©compil√© le code en un pseudocode de type C.  Bien que le code n'ait pas √©t√© d√©compil√© correctement, nous pouvons toujours en obtenir des informations sur ce qui se passe √† l'int√©rieur. </p><br><div class="spoiler">  <b class="spoiler_title">Code d√©compil√©</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__int64 __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__int64 a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *v3; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 int v4; // ebx@1 signed __int64 v5; // r8@2 char v6; // r9@3 __int64 v7; // r8@3 char v8; // cl@3 __int64 v9; // r9@5 int a2a; // [sp+Ch] [bp-1Ch]@3 v3 = &amp;encrypted_flag; v4 = 0; setbuf(stdout, 0LL); printf("The flag is: ", 0LL); while ( 1 ) { LODWORD(v5) = 0; do { a2a = 0; fibonacci(v4 + v5, &amp;a2a); v8 = v7; v5 = v7 + 1; } while ( v5 != 8 ); v4 += 8; if ( (unsigned __int8)(a2a &lt;&lt; v8) == v6 ) break; v3 = (char *)v3 + 1; _IO_putc((char)(v6 ^ ((_BYTE)a2a &lt;&lt; v8)), stdout); v9 = *((char *)v3 - 1); } _IO_putc(10, stdout); return 0LL; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, _DWORD *a2)</span></span></span><span class="hljs-function"> </span></span>{ _DWORD *v2; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 unsigned int v3; // er12@3 unsigned int result; // eax@3 unsigned int v5; // edx@3 unsigned int v6; // esi@3 unsigned int v7; // edx@4 v2 = a2; if ( i ) { if ( i == 1 ) { result = fibonacci(0, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } else { v3 = fibonacci(i - 2, a2); result = v3 + fibonacci(i - 1, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } v7 = v6 + (v5 &amp; 0x33333333) + ((v6 + (v5 &amp; 0x33333333)) &gt;&gt; 4); *v2 ^= ((BYTE1(v7) &amp; 0xF) + (v7 &amp; 0xF) + (unsigned __int8)((((v7 &gt;&gt; 8) &amp; 0xF0F0F) + (v7 &amp; 0xF0F0F0F)) &gt;&gt; 16)) &amp; 1; } else { *a2 ^= 1u; result = 1; } return result; }</span></span></code> </pre> </div></div><br><p>  Voici le code assembleur des fonctions <em>main</em> et <em>fibonacci</em> : </p><br><div class="spoiler">  <b class="spoiler_title">principal</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x4004E0 main proc near ; DATA XREF: start+1Do .text:0x4004E0 .text:0x4004E0 var_1C = dword ptr -1Ch .text:0x4004E0 .text:0x4004E0 push rbp .text:0x4004E1 push rbx .text:0x4004E2 xor esi, esi ; buf .text:0x4004E4 mov ebp, offset unk_4007E1 .text:0x4004E9 xor ebx, ebx .text:0x4004EB sub rsp, 18h .text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x4004FB mov edi, offset format ; "The flag is: " .text:0x400500 xor eax, eax .text:0x400502 call _printf .text:0x400507 mov r9d, 49h .text:0x40050D nop dword ptr [rax] .text:0x400510 .text:0x400510 loc_400510: ; CODE XREF: main+8Aj .text:0x400510 xor r8d, r8d .text:0x400513 jmp short loc_40051B .text:0x400513 ; --------------------------------------------------------------------------- .text:0x400515 align 8 .text:0x400518 .text:0x400518 loc_400518: ; CODE XREF: main+67j .text:0x400518 mov r9d, edi .text:0x40051B .text:0x40051B loc_40051B: ; CODE XREF: main+33j .text:0x40051B lea edi, [rbx+r8] .text:0x40051F lea rsi, [rsp+28h+var_1C] .text:0x400524 mov [rsp+28h+var_1C], 0 .text:0x40052C call fibonacci .text:0x400531 mov edi, [rsp+28h+var_1C] .text:0x400535 mov ecx, r8d .text:0x400538 add r8, 1 .text:0x40053C shl edi, cl .text:0x40053E mov eax, edi .text:0x400540 xor edi, r9d .text:0x400543 cmp r8, 8 .text:0x400547 jnz short loc_400518 .text:0x400549 add ebx, 8 .text:0x40054C cmp al, r9b .text:0x40054F mov rsi, cs:stdout ; fp .text:0x400556 jz short loc_400570 .text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc .text:0x400565 movzx r9d, byte ptr [rbp-1] .text:0x40056A jmp short loc_400510 .text:0x40056A ; --------------------------------------------------------------------------- .text:0x40056C align 10h .text:0x400570 .text:0x400570 loc_400570: ; CODE XREF: main+76j .text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc .text:0x40057A add rsp, 18h .text:0x40057E xor eax, eax .text:0x400580 pop rbx .text:0x400581 pop rbp .text:0x400582 retn .text:0x400582 main endp</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">fibonacci</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x400670 fibonacci proc near ; CODE XREF: main+4Cp .text:0x400670 ; fibonacci+19p ... .text:0x400670 test edi, edi .text:0x400672 push r12 .text:0x400674 push rbp .text:0x400675 mov rbp, rsi .text:0x400678 push rbx .text:0x400679 jz short loc_4006F8 .text:0x40067B cmp edi, 1 .text:0x40067E mov ebx, edi .text:0x400680 jz loc_400710 .text:0x400686 lea edi, [rdi-2] .text:0x400689 call fibonacci .text:0x40068E lea edi, [rbx-1] .text:0x400691 mov r12d, eax .text:0x400694 mov rsi, rbp .text:0x400697 call fibonacci .text:0x40069C add eax, r12d .text:0x40069F mov edx, eax .text:0x4006A1 mov ebx, eax .text:0x4006A3 shr edx, 1 .text:0x4006A5 and edx, 55555555h .text:0x4006AB sub ebx, edx .text:0x4006AD mov ecx, ebx .text:0x4006AF mov edx, ebx .text:0x4006B1 shr ecx, 2 .text:0x4006B4 and ecx, 33333333h .text:0x4006BA mov esi, ecx .text:0x4006BC .text:0x4006BC loc_4006BC: ; CODE XREF: fibonacci+C2j .text:0x4006BC and edx, 33333333h .text:0x4006C2 lea ecx, [rsi+rdx] .text:0x4006C5 mov edx, ecx .text:0x4006C7 shr edx, 4 .text:0x4006CA add edx, ecx .text:0x4006CC mov esi, edx .text:0x4006CE and edx, 0F0F0F0Fh .text:0x4006D4 shr esi, 8 .text:0x4006D7 and esi, 0F0F0Fh .text:0x4006DD lea ecx, [rsi+rdx] .text:0x4006E0 mov edx, ecx .text:0x4006E2 shr edx, 10h .text:0x4006E5 add edx, ecx .text:0x4006E7 and edx, 1 .text:0x4006EA xor [rbp+0], edx .text:0x4006ED pop rbx .text:0x4006EE pop rbp .text:0x4006EF pop r12 .text:0x4006F1 retn .text:0x4006F1 ; --------------------------------------------------------------------------- .text:0x4006F2 align 8 .text:0x4006F8 .text:0x4006F8 loc_4006F8: ; CODE XREF: fibonacci+9j .text:0x4006F8 mov edx, 1 .text:0x4006FD xor [rbp+0], edx .text:0x400700 mov eax, 1 .text:0x400705 pop rbx .text:0x400706 pop rbp .text:0x400707 pop r12 .text:0x400709 retn .text:0x400709 ; --------------------------------------------------------------------------- .text:0x40070A align 10h .text:0x400710 .text:0x400710 loc_400710: ; CODE XREF: fibonacci+10j .text:0x400710 xor edi, edi .text:0x400712 call fibonacci .text:0x400717 mov edx, eax .text:0x400719 mov edi, eax .text:0x40071B shr edx, 1 .text:0x40071D and edx, 55555555h .text:0x400723 sub edi, edx .text:0x400725 mov esi, edi .text:0x400727 mov edx, edi .text:0x400729 shr esi, 2 .text:0x40072C and esi, 33333333h .text:0x400732 jmp short loc_4006BC .text:0x400732 fibonacci endp</code> </pre> </div></div><br><p>  √Ä ce stade, nous avons de nombreuses occasions de r√©soudre ce probl√®me.  Par exemple, nous pouvons restaurer le code en utilisant l'un des langages de programmation et y appliquer l'optimisation, mais le processus de r√©cup√©ration du code est une t√¢che tr√®s difficile, au cours de laquelle nous pouvons faire des erreurs.  Eh bien, comparer le code pour trouver l'erreur est g√©n√©ralement sans valeur.  Mais, si nous utilisons le moteur Unicorn, nous pouvons ignorer l'√©tape de reconstruction du code et √©viter le probl√®me d√©crit ci-dessus.  Bien s√ªr, nous pouvons √©viter ces probl√®mes en utilisant frida ou en √©crivant des scripts pour gdb, mais ce n'est pas tout. </p><br><p>  Avant de commencer l'optimisation, nous ex√©cuterons l'√©mulation dans le moteur Unicorn sans changer le programme.  Et seulement apr√®s un lancement r√©ussi, passons √† l'optimisation. </p><br><h2 id="shag-1-da-priydet-virtualizaciya">  √âtape 1: laissez venir la virtualisation </h2><br><p>  Cr√©ons le fichier fibonacci.py et enregistrons-le √† c√¥t√© du binaire. </p><br><p>  Commen√ßons par importer les biblioth√®ques requises: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn.x86_const <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct</code> </pre> <br><p>  La premi√®re ligne charge les constantes binaires et de base Unicorn principales.  La deuxi√®me ligne charge les constantes des deux architectures x86 et x86_64. </p><br><p>  Ensuite, ajoutez quelques fonctions n√©cessaires: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(name) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.read() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.unpack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, data)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.pack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, num)</code> </pre> <br><p>  Ici, nous avons annonc√© les fonctions dont nous aurons besoin plus tard: </p><br><ul><li>  <strong>read</strong> renvoie simplement le contenu du fichier, </li><li>  <strong>u32</strong> prend une cha√Æne de 4 octets dans le codage LE et convertit en int, </li><li>  <strong>p32</strong> fait le contraire - il prend un nombre et le transforme en une cha√Æne de 4 octets dans l'encodage LE. </li></ul><br><p>  Remarque: Si vous avez install√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pwntools</a> , vous n'avez pas besoin de cr√©er ces fonctions, il vous suffit de les importer: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pwn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *</code> </pre> <br><p>  Et enfin, commen√ßons par initialiser notre classe Unicorn Engine pour l'architecture x86_64: </p><br><pre> <code class="python hljs">mu = Uc (UC_ARCH_X86, UC_MODE_64)</code> </pre> <br><p>  Ici, nous appelons les fonctions <strong>Uc</strong> avec les param√®tres suivants: </p><br><ul><li>  Le premier param√®tre est l'architecture principale.  Les constantes commencent par <strong>UC_ARCH_</strong> ; </li><li>  le deuxi√®me param√®tre est la sp√©cification de l'architecture.  Les constantes commencent par <strong>UC_MODE_</strong> . </li></ul><br><p>  Vous pouvez trouver toutes les constantes dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">feuille de triche</a> . </p><br><p>  Comme je l'ai √©crit ci-dessus, pour utiliser le moteur Unicorn, nous devons initialiser la m√©moire virtuelle manuellement.  Pour cet exemple, nous devons placer le code et la pile quelque part en m√©moire. </p><br><p>  L'adresse de base (Base addr) du binaire commence √† 0x400000.  Mettons notre pile √† 0x0 et allouons 1024 * 1024 de m√©moire pour cela.  Tr√®s probablement, nous n'avons pas besoin d'autant d'espace, mais cela ne fait toujours pas de mal. </p><br><p>  Nous pouvons baliser la m√©moire en appelant la m√©thode <strong>mem_map</strong> . </p><br><p>  Ajoutez ces lignes: </p><br><pre> <code class="python hljs">BASE = <span class="hljs-number"><span class="hljs-number">0x400000</span></span> STACK_ADDR = <span class="hljs-number"><span class="hljs-number">0x0</span></span> STACK_SIZE = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span> mu.mem_map(BASE, <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>) mu.mem_map(STACK_ADDR, STACK_SIZE)</code> </pre> <br><p>  Maintenant, nous devons charger le binaire dans son adresse principale de la m√™me mani√®re que le chargeur de d√©marrage.  Apr√®s cela, nous devons d√©finir <strong>RSP</strong> √† la fin de la pile. </p><br><pre> <code class="python hljs">mu.mem_write(BASE, read(<span class="hljs-string"><span class="hljs-string">"./fibonacci"</span></span>)) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Nous pouvons maintenant d√©marrer l'√©mulation et ex√©cuter le code, mais nous devons d√©terminer avec quelle adresse commencer √† travailler et quand l'√©mulateur doit s'arr√™ter. </p><br><p>  Prenez l'adresse de la premi√®re commande de <strong>main ()</strong> , nous pouvons d√©marrer l'√©mulation √† partir de 0x004004e0.  La fin sera consid√©r√©e comme un appel √† <strong>putc ("\ n")</strong> , qui se trouve √† 0x00400575, apr√®s avoir affich√© le drapeau entier. </p><br><pre> <code class="plaintext hljs">.text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc</code> </pre> <br><p>  Nous pouvons commencer √† √©muler: </p><br><pre> <code class="python hljs">mu.emu_start(<span class="hljs-number"><span class="hljs-number">0x004004e0</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400575</span></span>)</code> </pre> <br><p>  Ex√©cutez maintenant le script: </p><br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 32, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  Oups, quelque chose s'est mal pass√©, mais nous ne savons m√™me pas quoi.  Juste avant d'appeler <strong>mu.emu_start,</strong> nous pouvons ajouter: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) mu.hook_add(UC_HOOK_CODE, hook_code)</code> </pre> <br><p>  Ce code ajoute un crochet.  Nous d√©clarons notre propre fonction <strong>hook_code</strong> , qui est appel√©e par l'√©mulateur avant chaque commande.  Il prend les param√®tres suivants: </p><br><ul><li>  notre copie de <strong>Uc</strong> , </li><li>  adresse d'instruction </li><li>  instructions de taille </li><li>  donn√©es utilisateur (nous pouvons passer cette valeur avec un argument facultatif √† <strong>hook_add ()</strong> ). <br>  Maintenant, si nous ex√©cutons le script, nous devrions voir la sortie suivante: <br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py &gt;&gt;&gt; Tracing instruction at 0x4004e0, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e1, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e2, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004e4, instruction size = 0x5 &gt;&gt;&gt; Tracing instruction at 0x4004e9, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004eb, instruction size = 0x4 &gt;&gt;&gt; Tracing instruction at 0x4004ef, instruction size = 0x7 Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 41, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  √Ä l'adresse o√π l'erreur s'est produite, nous pouvons comprendre que notre script ne peut pas traiter cette commande: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream</code> </pre> <br><p>  Cette instruction lit les donn√©es de l'adresse 0x601038 (vous pouvez les voir dans IDA Pro).  Il s'agit de la section <strong>.bss</strong> que nous n'avons pas <strong>balis√©e</strong> .  Ma solution serait de simplement sauter toutes les instructions probl√©matiques si cela n'affecte pas la logique du programme. <br>  Voici une autre instruction probl√©matique: <br></p><pre> <code class="plaintext hljs">.text:0x4004F6 call _setbuf</code> </pre> <br><p>  Nous ne pouvons appeler aucune fonction avec glibc, car nous n'avons pas de glibc charg√©e en m√©moire.  Dans tous les cas, nous n'avons pas besoin de cette commande, nous pouvons donc √©galement la sauter. <br>  Voici la liste compl√®te des commandes √† ignorer: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x400502 call _printf .text:0x40054F mov rsi, cs:stdout ; fp</code> </pre> <br><p>  Pour ignorer les commandes, nous devons r√©√©crire <strong>RIP</strong> avec l'instruction suivante: <br></p><pre> <code class="python hljs">mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  Maintenant, <strong>hook_code</strong> devrait ressembler √† ceci: </p><br><p></p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  Nous devons √©galement faire quelque chose avec des instructions qui affichent l'indicateur dans la console octet par octet. </p><br><pre> <code class="plaintext hljs">.text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">__IO_putc</a> prend des octets pour la sortie comme <strong>premier argument</strong> (il s'agit du registre <strong>RDI</strong> ). </p><br><p>  Nous pouvons lire les donn√©es directement √† partir du registre, sortir les donn√©es vers la console et ignorer cet ensemble d'instructions.  Le <strong>hook_code</strong> mis √† jour est pr√©sent√© ci-dessous: </p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#print('&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size)) if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) elif address == 0x400560: # c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size)</span></span></code> </pre> <br><p>  Nous pouvons courir et tout fonctionnera, mais toujours lentement. </p><br><h1 id="shag-2-uvelichim-skorost">  √âtape 2: augmentez la vitesse! </h1><br><p>  Pensons √† augmenter la vitesse de travail.  Pourquoi ce programme est-il si lent? </p><br><p>  Si nous regardons le code d√©compil√©, nous verrons que <strong>main ()</strong> appelle <strong>fibonacci ()</strong> plusieurs fois et <strong>fibonacci ()</strong> est une fonction r√©cursive.  Examinons de plus pr√®s cette fonction; elle prend et renvoie deux arguments.  La premi√®re valeur de retour est transmise via le registre <strong>RAX</strong> , la seconde est renvoy√©e via le lien qui a √©t√© transmis via le deuxi√®me argument √† la fonction.  Si nous regardons plus en profondeur la relation entre <strong>main ()</strong> et <strong>fibonacci ()</strong> , alors nous verrons que le deuxi√®me argument ne prend que deux valeurs possibles: 0 ou 1. Si vous ne voyez toujours pas cela, ex√©cutez <strong>gdb</strong> et mettez un point d'arr√™t au d√©but de la fonction <strong>fibonacci ()</strong> . </p><br><p>  Pour optimiser le fonctionnement de l'algorithme, nous pouvons utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la programmation dynamique</a> afin de m√©moriser la valeur de retour des param√®tres entrants.  Pensez par vous-m√™me, le deuxi√®me argument ne peut prendre que deux valeurs possibles, donc tout ce que nous avons √† faire est de nous souvenir <math> </math> $ inline $ 2 * MAX \ _OF \ _FIRST \ _ARGUMENT $ inline $   vapeur </p><br><div class="spoiler">  <b class="spoiler_title">Pour ceux qui ne comprennent pas</b> <div class="spoiler_text"><p>  <strong>fibonacci</strong> est une fonction r√©cursive qui calcule la valeur suivante comme la somme des deux pr√©c√©dentes.  √Ä chaque √©tape, elle va plus loin.  Chaque fois qu'elle recommence, elle suit le m√™me chemin qu'auparavant, plus un nouveau sens. </p><br><p>  Un exemple: <br>  Supposons que la profondeur = 6, puis: <strong>1 1 2 3 5 8</strong> . <br>  Et maintenant profondeur = 8, puis: <strong>1 1 2 3 5 8</strong> 13 21. </p><br><p>  Nous pourrions simplement nous rappeler que les 6 premiers membres sont <strong>1 1 2 3 5 8</strong> , et quand ils nous demandent de compter plus que nous nous en souvenions, nous prenons ce dont nous nous souvenons et ne comptons que ce qui manque. </p></div></div><br><p>  Une fois que <strong>RIP</strong> est au d√©but de <strong>fibonacci ()</strong> , nous pouvons obtenir les arguments de la fonction.  Nous savons qu'une fonction renvoie un r√©sultat lorsqu'elle quitte une fonction.  Comme nous ne pouvons pas fonctionner avec deux param√®tres √† la fois, nous avons besoin d'une pile pour renvoyer les param√®tres.  Lorsque nous entrons dans <strong>fibonacci (),</strong> nous devons mettre les arguments sur la pile et les r√©cup√©rer √† notre sortie.  Pour stocker les paires compt√©es, nous pouvons utiliser un dictionnaire. </p><br><p>  Comment traiter une paire de valeurs? </p><br><ul><li>  Au tout d√©but de la fonction, nous pouvons v√©rifier si cette paire figure dans les r√©sultats que nous connaissons d√©j√†: <br><ul><li>  s'il y en a, alors nous pouvons retourner cette paire.  Nous avons juste besoin d'√©crire les valeurs de retour en <strong>RAX</strong> et √† l'adresse du lien, qui est dans le deuxi√®me argument.  Nous attribuons √©galement une adresse <strong>RIP</strong> pour quitter la fonction.  Nous ne pouvons pas utiliser <strong>RET</strong> dans <strong>fibonacci ()</strong> , car ces appels sont accroch√©s, nous allons donc prendre un certain <strong>RET</strong> de <strong>main ()</strong> ; </li><li>  si ces valeurs ne le sont pas, nous les ajoutons simplement √† la pile. </li></ul></li><li>  Avant de quitter la fonction, nous pouvons enregistrer la paire retourn√©e.  Nous connaissons les arguments d'entr√©e, car nous pouvons les lire √† partir de notre pile. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Ce code est pr√©sent√© ici.</b> <div class="spoiler_text"><pre> <code class="python hljs">FIBONACCI_ENTRY = <span class="hljs-number"><span class="hljs-number">0x00400670</span></span> FIBONACCI_END = [ <span class="hljs-number"><span class="hljs-number">0x004006f1</span></span>, <span class="hljs-number"><span class="hljs-number">0x00400709</span></span>] instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-comment"><span class="hljs-comment">#     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET ,       fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref)</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Voici le script entier</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function from unicorn import * from unicorn.x86_const import * import struct def read(name): with open(name) as f: return f.read() def u32(data): return struct.unpack("I", data)[0] def p32(num): return struct.pack("I", num) FIBONACCI_ENTRY = 0x00400670 FIBONACCI_END = [ 0x004006f1, 0x00400709] instructions_skip_list = [0x004004ef,0x004004f6,0x00400502,0x0040054f] #     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET .     fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref) mu = Uc (UC_ARCH_X86, UC_MODE_64) BASE = 0x400000 STACK_ADDR = 0x0 STACK_SIZE = 1024*1024 mu.mem_map(BASE, 1024*1024) mu.mem_map(STACK_ADDR, STACK_SIZE) mu.mem_write(BASE, read("./fibonacci")) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - 1) mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(0x004004e0, 0x00400575) print()</span></span></code> </pre></div></div><br><p>  Hourra, nous avons enfin pu optimiser l'application √† l'aide du moteur Unicorn.  Bon travail! </p><br><h1 id="zametka">  Une note </h1><br><p>  Maintenant, j'ai d√©cid√© de vous donner un peu de devoirs. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici, vous pouvez trouver</a> trois autres t√¢ches, chacune ayant un indice et une solution compl√®te.  Vous pouvez jeter un ≈ìil √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">feuille de triche</a> tout en r√©solvant les probl√®mes. </p><br><p>  L'un des probl√®mes les plus ennuyeux est de se souvenir du nom de la constante souhait√©e.  C'est facile √† g√©rer si vous utilisez des modules compl√©mentaires Tab dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IPython</a> .  Lorsque vous avez install√© IPython, vous pouvez √©crire √† <strong>partir de l'importation de licorne UC_ARCH_,</strong> appuyez sur Tab et vous verrez toutes les constantes qui commencent de la m√™me mani√®re. </p><p></p><p></p><p></p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431058/">https://habr.com/ru/post/fr431058/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431046/index.html">Fonctionnement r√©el de z-index</a></li>
<li><a href="../fr431048/index.html">La machine d'√©v√©nement garde le cycle de vie</a></li>
<li><a href="../fr431050/index.html">L'illusion de la puret√©: la min√©ralisation de l'eau affecte-t-elle sa qualit√© et comment le compteur TDS nous aidera-t-il?</a></li>
<li><a href="../fr431052/index.html">Devend Day: cartes, √©quipes, deux requ√™tes</a></li>
<li><a href="../fr431056/index.html">USPACE: Drones Time</a></li>
<li><a href="../fr431060/index.html">Usurpation d'identit√© allemande avec authentification en ligne et financement des r√©fugi√©s en Allemagne</a></li>
<li><a href="../fr431064/index.html">Manifeste du programmeur rigide</a></li>
<li><a href="../fr431066/index.html">DEFCON 16. Comment puis-je vous joindre? Permettez-moi d'√©num√©rer les moyens. 2e partie</a></li>
<li><a href="../fr431068/index.html">L'art de l'√©ducation: l'id√©ologie des machines √† sous</a></li>
<li><a href="../fr431070/index.html">Hara mange? Nous parlons des habitudes alimentaires d'un sp√©cialiste informatique moderne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>