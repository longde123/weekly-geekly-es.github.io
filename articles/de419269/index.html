<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏨 👩🏿‍⚖️ 🤞🏿 Rebuses im Code und wie man sie entschlüsselt. Die geheime Kraft der Identifikatoren 👨🏿‍🎨 👨‍👦 🥔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Reiner Code liest sich wie gut geschriebene Prosa. 
 Grady Butch in sauberem Code 
 Rebus als Code 


 Was ist ein Rebus? Dies ist eine verschlüsselte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rebuses im Code und wie man sie entschlüsselt. Die geheime Kraft der Identifikatoren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419269/"><blockquote>  Reiner Code liest sich wie gut geschriebene Prosa. <br>  <i>Grady Butch in sauberem Code</i> <br></blockquote><h2>  Rebus als Code </h2><br><img src="https://habrastorage.org/webt/7x/kw/pl/7xkwplb_gdofblahdmwqiqvz4f0.jpeg"><br><br>  Was ist ein Rebus?  Dies ist eine verschlüsselte Nachricht.  Der Autor des Rebus nimmt gewöhnlichen menschlichen Text und verschlüsselt ihn mit Zeichnungen, Zahlen und Buchstaben.  Und wir schauen uns eine solche Verschlüsselung an und versuchen, den Quelltext zu lesen. <br><br>  Der Rebus hat zwei Formen.  Der Rebus ist einerseits der unverschlüsselte Originaltext und andererseits die Chiffrierzeichnungen.  Der Text ist das „Was“ des Rebus, seine Bedeutung, Botschaft.  Bilder sind „wie“: <i>wie</i> genau die Nachricht verschlüsselt wird, mit <i>welchen</i> Mitteln.  Wenn wir den Rebus erraten, übersetzen wir „wie“ in „was“. <br><a name="habracut"></a><br>  Zeichnungen sind die Sprache des Rebus, sein Arsenal an Ausdrucksmitteln.  Der Rebusnik spricht sozusagen mit Hilfe dieser Zeichnungen zu uns, kommuniziert etwas.  Er darf keine normalen menschlichen Wörter verwenden. <br><br>  So lesen sich die Rätsel: <br><br><img src="https://habrastorage.org/webt/ot/yj/pe/otyjpegfyy8v5-7gk8vji8s9ddc.jpeg"><br><br><h2>  Der Code ist wie ein Rebus </h2><br>  Der Programmcode hat etwas mit dem Rebus gemeinsam: Er hat auch ein eigenes „Was“ und „Wie“.  Und manchmal muss es auch entschlüsselt werden. <br><br>  Das „Was“ eines Codes ist sein Zweck, dh dieser Effekt und das Endergebnis, das wir von ihm erwarten.  <i>Was</i> genau macht er <i>?</i> <br><br>  "Wie" des Codes - auf welche konkrete Weise wird er sein "Was" erfüllen, mit welchen spezifischen Zuordnungen, Multiplikationen, Vergleichen;  Implementierung des Algorithmus, Anweisungen an den Prozessor.  Es ist eine erlaubte Codesprache, ein Arsenal an Ausdrucksmitteln. <br><br>  Martin Fowler spricht so darüber ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Funktionslänge“</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Original</a> ): <br><blockquote>  Smalltalk arbeitete in jenen Jahren an Schwarz-Weiß-Maschinen.  Wenn Sie Text oder Grafiken hervorheben mussten, mussten Sie das Video umkehren.  Die Klasse in Smalltalk, die für den Zeitplan verantwortlich war, enthielt die 'Highlight'-Methode, und in ihrer Implementierung gab es nur eine Zeile - einen Aufruf der' Reverse'-Methode.  Der Name der Methode war länger als die Implementierung, aber es spielte keine Rolle, da zwischen der Absicht und der Implementierung dieses Codes ein großer Abstand besteht. <br></blockquote>  Hier ist das Highlight das „Was“.  In Martins Terminologie - <i>Absicht</i> : "Markieren Sie ein Fragment des Bildes."  Der Name drückt aus, was diese Funktion tut.  Umgekehrt ist wie, <i>Implementierung</i> .  <i>Wie</i> genau die Hervorhebung durchgeführt wird (mithilfe der Bildinversion).  Das ist der Unterschied zwischen "was" und "wie". <br><br>  Trotz der Tatsache, dass der Name der Methode länger ist als ihre Implementierung, ist die Existenz einer solchen Methode aus einem sehr einfachen Grund sinnvoll.  Wenn wir einen umgekehrten Aufruf im Code sehen, müssen wir verstehen oder uns daran erinnern, dass die Bildinversion verwendet wird, um dieses Bild besser sichtbar zu machen.  Wenn wir ein Highlight sehen, lesen wir einfach: "Machen Sie dieses Fragment sichtbarer."  Im ersten Fall geben wir uns ein wenig Mühe, um die dem Code zugewiesene Mission zu verstehen, im zweiten - nein.  Im ersten Fall sehen wir einen Rebus vor uns, der entschlüsselt werden muss, im zweiten Fall eine Geschichte in einer verständlichen Sprache. <br><br>  Ein Programmierer ist, wenn er ein Programm schreibt, wie ein Rebus.  Der Programmierer verschlüsselt die menschliche Beschreibung des Algorithmus mit verfügbaren Programmiersprachenwerkzeugen (primitiver als die menschliche Sprache).  Verschlüsselt "was" mit "wie".  Und später liest er oder sein Kollege den Code und entschlüsselt <s>diese Rebusse, die</s> anfängliche Beschreibung des Algorithmus.  <b>Wenn wir beim Lesen des Codes nicht sofort verstehen können, zu welchem ​​Ergebnis die Ausführung jedes Fragments führen wird, dh zu welchem ​​Zweck und welcher Bedeutung der Code, dann ist dieser Code ein Rebus und muss in einer klaren Sprache neu geschrieben werden.</b> <br><br>  Das Problem mit den Rätseln im Code ist, dass sie <i>immer</i> mentale Anstrengung erfordern.  Selbst wenn wir nicht alle Entschlüsselungsvorgänge in unserem Kopf ausführen, sondern uns nur dumm an die Bedeutung eines Rebus erinnern, wird dies dennoch eine Last erzeugen: Erstens, um sich an seine Bedeutung zu erinnern, und zweitens zum Zeitpunkt der Aufzeichnung der Transformation Rebus in diesem Wert. <br><br>  Das Entschlüsseln des Rebus beim Lesen des Codes ist die mentale Transformation, über die Tim Ottinger in dem Buch Clean Code spricht.  Zwar diskutiert er sie dort im Zusammenhang mit der Zuweisung verständlicher Namen zu Variablen, aber das Problem ist von genau demselben betroffen.  Wort an Tim: <br><blockquote>  Programmierer sind in der Regel sehr schlau.  Und kluge Leute zeigen manchmal gerne die Kraft der Intelligenz und demonstrieren ihre Fähigkeit, mental zu jonglieren.  Wenn Sie sich am Ende daran erinnern, dass die Variable r eine URL mit einem Remote-Host und ein in Kleinbuchstaben konvertiertes Schema enthält, ist dies ein klarer Hinweis auf Ihre Meinung. <br>  Einer der Unterschiede zwischen einem intelligenten und einem professionellen Programmierer besteht darin, dass ein Fachmann versteht: Klarheit ist von größter Bedeutung.  Profis nutzen ihre Macht für immer und schreiben Code, der für andere Menschen verständlich ist. </blockquote>  Selbst eine kleine Ladung von jedem Rebus kann zu einem Problem werden, wenn es viele solcher Rebusse gibt.  Sie sind wahrscheinlich auf Code gestoßen, dessen Lesen einfach anstrengend ist.  <b>Wissen Sie: Rebusse im Code sind für Ihre Müdigkeit verantwortlich.</b>  Rebuses verschärfen die Müdigkeit selbst des eigenen Autors beim Schreiben von Code.  Schließlich liest der Programmierer beim Schreiben von Code auch immer wieder neu, was geschrieben wurde.  Trotz der Tatsache, dass der Autor seine eigenen Rätsel nicht entschlüsselt, sondern sich nur daran erinnert, erzeugen sie immer noch eine Last.  Die Falle ist, dass der <b>Autor einfach keine Rätsel in seinem eigenen Code sieht</b> !  Versuchen Sie sich vorzustellen, wie viel geistige Anstrengung Sie am Abend sparen können, wenn Sie morgens anfangen, Rätsel in Ihrem Code loszuwerden! <br><br>  Um die Müdigkeit beim Schreiben und Lesen von Code zu verringern, müssen Sie Rätsel vermeiden.  Aber wie geht das? <br><br><h2>  Die Sprache des Codes.  Identifikatorstärke </h2><br>  Ich stimme der Aussage von Grady Butch zu, dass sauberer Code wie gute Prosa liest.  Dies ist eine notwendige, wenn auch nicht ausreichende Bedingung.  Die meisten von uns werden intuitiv verstehen, worum es geht, aber ich möchte zumindest eine Definition erhalten: Was ist das - gute Prosa. <br><br>  Ich fragte meine Kollegen: Wie unterscheidet sich gute Prosa von schlechter Prosa?  Jeder antwortete anders, betonte aber irgendwie die Bedeutung der Sprache: Sie muss reich sein, sie muss klare Bilder in Geist und Seele des Lesers erzeugen.  Wenn der Leser leicht ein klares Bild hat, das der Autor für ihn zeichnen wollte, haben wir es mit guter Prosa zu tun. <br><br>  Der Code teilt dem Prozessor mit, was er tun soll.  Ein guter Code sagt es gleichzeitig dem Programmierer - und darüber hinaus sehr wahrheitsgemäß!  - Was macht er hier?  Das heißt, es legt seinen Algorithmus so nahe wie möglich daran, wie der Autor es in einer natürlichen Sprache getan hätte.  Unser Code muss dies sehr gut tun, sonst kann ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ungezügelter Verrückter mit einer Kettensäge oder einer Schrotflinte</a> zu uns nach Hause kommen.  Der Code sollte kein Rebus sein. <br><br>  Welche Tools hat der Code, um kein Rebus zu sein? <br><br>  Eine Geschichte im Namen des Codes wird von einer Person leicht verstanden, wenn der Code selbst in menschlicher Sprache spricht.  Dies kann nur mit Hilfe von Bezeichnern erreicht werden: Namen von Funktionen, Klassen, Variablen und Konstanten - denn <b>nur in Bezeichnern können wir Wörter der menschlichen Sprache verwenden, die wir benötigen</b> . <br><br>  Natürlich sind die Schlüsselwörter einer Programmiersprache auch menschliche Wörter, aber ihr Wortschatz ist zu elend.  So etwas wie die Sprache von Ellochka dem Oger - man kann keine gute Prosa darüber schreiben. <br><br>  Daher ist es wichtig, dass der Programmcode so viele korrekt ausgewählte Bezeichner wie möglich enthält.  Damit ihre Gesamtheit die sehr gut geschriebene Prosa bildet. <br><br>  Sehen Sie, wie einfach es ist, Codezeilen zu lesen, wenn die Namen der Variablen und Methoden gut ausgewählt sind: <br><br><pre><code class="ruby hljs">pageData.hasAttribute(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>) dom_tree.to_html() emails_str.split(<span class="hljs-string"><span class="hljs-string">','</span></span>)</code> </pre> <br>  Wenn man sich diese kurzen Sätze ansieht, ist es leicht zu verstehen, wovon sie sprechen.  Wir wissen, welches Ergebnis wir erhalten, weil uns Identifikatoren davon erzählen.  Stellen Sie sich nun vor, dass an der Stelle jedes solchen Aufrufs seine Implementierung erfolgt - um wie viel verringert sich die Lesegeschwindigkeit eines solchen „verschlüsselten“ Codes? <br><br>  Bei vielen der einfachsten Refactoring-Techniken: benannte Konstanten, Auswahl einer Methode, Ersetzen einer Variablen durch einen Methodenaufruf, eine erklärende Variable, Aufteilen einer temporären Variablen usw. geht es darum, <b>wie der Code die menschliche Sprache spricht, mit anderen Worten, wie Rätsel vermieden werden</b> . <br><br><h2>  Rebus-Methode </h2><br>  Als ich Pure Code las, wurde ich regelmäßig von dem Gedanken besucht: „Was zur Hölle!“. <br><br>  Robert Martin gibt uns aufgrund seiner 40-jährigen Erfahrung Tipps, wie man Code verbessern kann.  Zum Beispiel: <br><blockquote>  Erste Regel: Funktionen sollten kompakt sein.  Die zweite Regel: Funktionen sollten noch kompakter sein. </blockquote>  Und dann gibt er zu, dass er seine Behauptung nicht wissenschaftlich begründen kann.  Ehrlich gesagt, unwissenschaftlich, macht er es auch schlecht.  Das Erfordernis der Funktionskompaktheit sieht bereits wie ein Dogma aus - deshalb ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debatte</a> über die Frage nach der Länge einer Funktion seit so vielen Jahrzehnten nicht mehr abgeklungen. <br><br>  Und Bob bietet auch an, jede Funktion so zu schreiben, dass sie nur eine Operation ausführt.  Darüber hinaus ist auch nicht klar, was diese eine Operation ist.  Wir müssen das Prinzip einer einzigen Abstraktionsebene um Hilfe bitten, was die Situation weiter verwirrt.  Das alles ist zu neblig. <br><br>  Martin Fowler ist pragmatischer. <br><br><blockquote>  Es scheint mir, dass das Argument über die Trennung von Absicht und Verwirklichung mehr Bedeutung hat.  Wenn Sie sich beim Betrachten eines Codes bemühen müssen, zu verstehen, <i>was</i> er tut, müssen Sie ihn in eine Funktion einfügen und ihm einen Namen geben, der diesem „Was“ entspricht.  Beim nächsten Mal ist der Zweck der Funktion sofort ersichtlich, und in den meisten Fällen ist es Ihnen egal, wie die Funktion ihre Aufgabe erfüllt. <br><br><div class="spoiler">  <b class="spoiler_title">Das Original</b> <div class="spoiler_text">  Das für mich sinnvollste Argument ist jedoch die Trennung zwischen Absicht und Umsetzung.  Wenn Sie sich die Mühe machen müssen, ein Codefragment zu betrachten, um herauszufinden, <i>was</i> es tut, sollten Sie es in eine Funktion extrahieren und die Funktion nach diesem „Was“ benennen.  Auf diese Weise springt der Zweck der Funktion beim erneuten Lesen direkt auf Sie zu, und die meiste Zeit müssen Sie sich nicht darum kümmern, wie die Funktion ihren Zweck erfüllt - das ist der Hauptteil der Funktion. <br></div></div></blockquote>  Schon besser.  Sehen Sie jetzt, was Martin in dieser Passage sagen wollte?  Er meinte: Lass uns die Rätsel beseitigen.  Lassen Sie den Code selbst uns sagen, was das Ergebnis sein wird und wie - lassen Sie es irgendwo weiter entfernt in der Definition der Funktion versteckt sein.  Lassen Sie alle Rätsel entschlüsselt werden.  Keine Rätsel - keine Anstrengung. <br><br>  In keinem Fall sollten Sie Refactoring-Methoden blind anwenden.  Das ist so offensichtlich, aber wie kann man verstehen, wann Refactoring wirklich benötigt wird und wann nicht?  <b>Die Rebus-Methode besagt: Wenn der Rebus nach dem Refactoring nicht verschwindet, ist kein Refactoring erforderlich</b> . <br><br>  <b>Wenn Sie keinen Namen für eine neue Funktion finden, der klar erklärt, was darin passiert, ist es eine Glocke, dass Sie hier etwas falsch machen.</b>  <b>Versuchen Sie, ein etwas anderes Codefragment in der Funktion auszuwählen, für das Sie schnell einen verständlichen und kurzen Namen finden.</b> <br><br><h2>  Ein Beispiel für das Entschlüsseln von Rätseln im Code (nicht sehr erfolgreich) </h2><br>  Als solches werde ich ein Fragment aus dem Buch „Clean Code“ zitieren, das mir gefallen hat.  Vor dem Refactoring sehen wir Code voller Rätsel.  Das Refactoring wurde vom Autor des Buches gemäß den von ihm beworbenen Regeln für guten Code durchgeführt, und - nur ein Zufall - der refactored Code sieht genauso aus wie der Code, in dem die Rebusse entschlüsselt werden. <br><br>  Der Refactoring-Autor hat vollständig lesbare Bezeichner (Klassennamen, Methoden und Variablen) angewendet, um anzugeben, was der Code tatsächlich tut.  Es ist schade, dass es nicht überall erfolgreich war und an einigen Stellen anstelle der vorherigen Rätsel neue Rätsel auftauchten. <br><br>  Zum Beispiel die in dieser Passage am häufigsten verwendete Include-Methode <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">include</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String pageName, String arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ WikiPage inheritedPage = findInheritedPage(pageName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inheritedPage != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { String pagePathName = getPathNameForPage(inheritedPage); buildIncludeDirective(pagePathName, arg); } }</code> </pre> <br>  Der Name spiegelt überhaupt nicht wider, was in der Implementierung passiert.  Was beinhaltet und wo? <br><br>  Betrachten Sie den Aufruf dieser Methode: <br><br><pre> <code class="java hljs">include(<span class="hljs-string"><span class="hljs-string">"TearDown"</span></span>, <span class="hljs-string"><span class="hljs-string">"-teardown"</span></span>);</code> </pre> <br>  Es ist unmöglich zu sagen, welches Ergebnis der Autor des Codes hier erzielen würde. <br><br>  Weiter: Was macht buildIncludeDirective?  Nach dem Namen zu urteilen, sollte er eine Art Einschlussrichtlinie ausarbeiten, und was nun?  Bring sie zurück?  Aber nein.  Er fügt es sofort zum Gesamtergebnis hinzu. <br><br>  Und hier ist noch ein updatePageContent.  Was sagt uns updatePageContent über das Ergebnis, das wir nach dem Aufruf der Methode erhalten?  Nichts.  Einige Seiteninhalte werden dort ersetzt, wenn niemand weiß was.  Warum wurde hier Refactoring als Methodenextraktion bezeichnet?  Hat er geholfen, den Rebus loszuwerden?  Es hat nicht geholfen, aber den Code nur noch mehr verwirrt.  Hier haben wir genau den Fall, in dem der Körper der Methode vorzuziehen ist.  Bau <br><br><pre> <code class="java hljs">pageData.setContent(newPageContent.toString());</code> </pre> <br>  viel klarer als das kryptische updatePageContent (). <br><br>  Zur Unterhaltung schlage ich den Lesern vor, nach anderen schlechten Stellen im <a href="">überarbeiteten Code</a> zu suchen. <br><br>  Um Bob zu rechtfertigen, kann ich sagen, dass dieser Code nicht mehr in der aktuellen Version von FitNesse enthalten ist.  Anscheinend wurde auch er einmal umgestaltet. <br><br><h2>  Fazit </h2><br>  Die Länge der Funktion ist ein zu vages Kriterium, um die Qualität der Funktion zu bestimmen.  "Kurze Funktionen" ist nicht gleich "gute Funktionen".  Die Länge der Funktion ist kein Kriterium, vergessen Sie alles. <br><br>  Guter Code sollte Antworten auf die Fragen des Programmierers geben - warum ist er (der Code) hier, was zum <s>Teufel macht er</s> hier, <s>er</s> erzielt das Ergebnis.  Diese Antworten können nur mit Bezeichnern gegeben werden. <br><br>  Als Beispiel dafür, welche Art von Antworten der Code nicht geben sollte, möchte ich einen Auszug aus einem lustigen Buch geben. <br><blockquote>  "Ich bin Ronan, Victor of Evil", sagte er langsam.  - Und das ist Tarl.  Wir wollen dich <br>  Fragen stellen.  Wenn du lügst, stirbst du.  Verstanden <br>  "Ich, Onkel, für immer", hauchte er.  - Bitte.  Ich werde alles sagen. <br>  "Das ist schön", fuhr Ronan fort.  - Name? <br>  - Ronan, Gewinner des Bösen. <br>  - Ja, nicht meins, Idiot! <br>  "Ah, ja, dann Tarle", antwortete der Ork entschuldigend. <br>  - Und nicht meins!  Gemurmelte Tarle.  - Dein Name, Verein!  Vorname! <br>  „Der Name ist der Name, mit dem ich mich von anderen unterscheide“, murmelte der Ork. <br>  - Nun, gib diesen Namen hier!  Schrie Tarle. <br>  Orka dämmerte plötzlich. <br>  - Ah!  Pickel! <br>  "Also Pickel, was machst du hier?" <br>  "Ich habe es in meine Hose gesteckt", kam die wahrheitsgemäße Antwort. <br>  Ronan runzelte angewidert die Nase. <br>  "Nein, ich frage, was deine Orkbande hier macht!" <br>  Pimples Augen drehten sich schnell um und sahen sich in der Szene um. <br>  "Die meisten Leute sind hier kopflos", murmelte er. <br>  Tarle berührte Ronan an der Schulter. <br>  „Lass es mich versuchen“, sagte er zuversichtlich und wandte sich an den verängstigten Ork.  - Sag mir, <br>  Pickel ", fuhr er fort," warum bist du hier? " <br>  - Oh Onkel, und frag nicht.  Existenzphilosophie ist für mich nur ein dunkler Wald. <br>  „Hör zu, du Drachenrülpsen“, knurrte er gedämpft.  - Deine Orkbande hatte etwas Besonderes <br>  Grund hierher zu kommen.  Was ist es im Wald? <br>  - Es gibt viele Bäume. <br>  Ronans Augen weiteten sich und Tarle wandte sich ab.  Der Pickel, der das Gefühl hatte, nicht die erwartete Antwort gegeben zu haben, begann weiter zu murmeln. <br>  - Und wenn Sie den Grund und nicht den Wald kennen wollen, dann nur, weil diese Person in der Kneipe ist <br>  hat uns bezahlt, hierher zu kommen und dich zu töten. <br>  <i>James Bibby, Ronan der Barbar</i> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419269/">https://habr.com/ru/post/de419269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419257/index.html">Indien führt neues PD-Schutzgesetz ein - ein weiteres Analogon zur DSGVO?</a></li>
<li><a href="../de419259/index.html">Rust 1.28 Release</a></li>
<li><a href="../de419261/index.html">Aktionen bei Google: Schreiben einer einfachen Anwendung für Google Assistant zu Dialogflow- und Cloud-Funktionen für Firebase</a></li>
<li><a href="../de419265/index.html">Verwenden eines mehrschichtigen neuronalen Netzwerks, um Hindernisse in Spielen zu vermeiden</a></li>
<li><a href="../de419267/index.html">SOK Coworking Tour</a></li>
<li><a href="../de419271/index.html">Analoge in Python und JavaScript. Teil vier</a></li>
<li><a href="../de419273/index.html">Schreiben eines Linux-Kernelmoduls: GPIO mit IRQ-Unterstützung</a></li>
<li><a href="../de419277/index.html">Wärmebänder mit Schutzart IP68. Geeignet für Licht in einem Badehaus</a></li>
<li><a href="../de419279/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 264 (30. Juli - 5. August)</a></li>
<li><a href="../de419281/index.html">rcm - rc-file manager: optimieren und verwenden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>