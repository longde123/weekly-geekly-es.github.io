<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👁‍🗨 📽️ 🕵️ 如何建立和建立 🏂 🤲 🚳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="背景知识 


 在Java语言开发的许多地方遇到了必须验证值的情况之后，很明显，有必要以某种方式解决此问题。 为此，设置了以下任务： 
 开发一个可启用以下功能的库： 


- 验证数据类型 ; 
- 设置默认值，而不是无效的字段或元素； 
- 删除对象或数组的无效部分 ； 
- 收到错误讯息 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何建立和建立</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429916/"><h2 id="predystoriya"> 背景知识 </h2><br><p> 在Java语言开发的许多地方遇到了必须验证值的情况之后，很明显，有必要以某种方式解决此问题。 为此，设置了以下任务： <br> 开发一个可启用以下功能的库： </p><br><ul><li> 验证<strong>数据类型</strong> ; </li><li> 设置<strong>默认值，</strong>而不是无效的字段或元素； </li><li>  <strong>删除</strong>对象或数组的<strong>无效部分</strong> ； </li><li> 收到<strong>错误讯息</strong> </li></ul><br><p> 其基础将是： </p><br><ul><li> 易学 </li><li> 所接收代码的可读性。 </li><li> 易于修改代码 </li></ul><br><p> 为了实现这些目标，已经开发了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="四重奏">四方</a>验证库。 </p><a name="habracut"></a><br><h2 id="osnovnye-kirpichi-validacii"> 基本验证模块 </h2><br><p> 被设计为适用于各种任务的大多数系统的核心是最简单的<strong>元素</strong> ：动作，数据和算法。 以及它们的<strong>构成</strong>方法-为了从更简单的最简单的元素中组装一些东西，以解决更复杂的问题。 </p><br><h3 id="validator"> 验证者 </h3><br><p>四方库基于<strong>验证器</strong>的概念。 该库中的验证器具有以下形式的功能 </p><br><pre><code class="plaintext hljs">function validator( value: any, { key: string|int, parent: any }, { key: string|int, parent: any }, ... ): boolean</code> </pre> <br><p> 此定义中有几件事应该更详细地描述： </p><br><p>  <strong><code>function(...): boolean</code></strong> -表示验证器-计算验证结果，验证结果为布尔值<strong>-true</strong>或<strong>false</strong> ，分别<strong>有效</strong>或<strong>无效</strong> </p><br><p>  <strong><code>value: any</code></strong> any-表示验证器-计算验证<strong>值</strong>的结果，该<strong>值</strong>可以是任何javascript值。 验证器将<strong>验证后的值</strong>分配给有效或无效。 </p><br><p>  <strong><code>{ key: string|int, parent: any }, ...</code></strong>表示验证值可以在不同的上下文中，具体取决于值嵌套的级别。 让我们用例子展示一下 </p><br><p>  <strong>没有上下文的</strong>示例值 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//         . //         : const isValueValid = validator(4)</span></span></code> </pre> <br><p>  <b>数组上下文中的</b>示例值 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  0 1 2 3 4 const arr = [1, 2, 3, value, 5] //       (k): 3 //      : [1, 2, 3, value, 5] //    value -      const isValueValid = validator(4, { key: 3, parent: [1,2,3,4,5] })</span></span></code> </pre> <br><p>  <b>对象上下文中的</b>示例值 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> } <span class="hljs-comment"><span class="hljs-comment">//        'c' //       : { a: 1, b: 2, c: 4, d: 8 } //    value -   //   : const isValueValid = validator(4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } })</span></span></code> </pre> <br><p> 由于对象中的结构可以具有更大的嵌套，因此谈论<b>各种上下文</b>是有意义<b>的</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrOfObj = [{ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> }, <span class="hljs-comment"><span class="hljs-comment">// ... ] //   c     'c' //    : { a: 1, b: 2, c: 4, d: 8 } //        arrOfObj, //       0. //    value -      const isValueValid = validator( 4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } } { key: 0, parent: [{ a: 1, b: 2, c: 4, d: 8 }] } )</span></span></code> </pre> <br><p> 依此类推。 </p><br><div class="spoiler">  <b class="spoiler_title">关于数组方法的相似性</b> <div class="spoiler_text"><p> 验证器的此定义应使您想起作为参数传递给数组方法的函数的定义，例如： <strong>map，filter，some，every</strong>等。 </p><br><ul><li> 这些函数的第一个参数是<strong>数组元素。</strong> </li><li> 第二个参数是<strong>元素</strong>的<strong>索引。</strong> </li><li> 第三个参数是<strong>数组本身。</strong> </li></ul><br><p> 在这种情况下，验证器是一个更通用的函数-它不仅获取数组和数组中元素的索引，而且还获取其父级和父级中数组的索引，依此类推。 </p></div></div><br><h3 id="chto-nam-stoit-dom-postroit"> 我们应该建什么房子？ </h3><br><p> 上述砖头在javascript拐杖<em>“海滩”</em>上的其他<em>“石头解决方案”</em>中并不突出。 因此，让我们从它们中构建一些更连贯和有趣的东西。 为此，我们有一个<strong>构图</strong> 。 </p><br><h3 id="kak-postroit-neboskryob-validacii-obektov"> 如何建立一个对象验证的摩天大楼？ </h3><br><p> 同意，以使验证描述与对象描述匹配的方式来验证对象将很方便。 为此，我们将使用<strong>验证器</strong>的<strong>对象组成</strong> 。 看起来像这样： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //      , //     const objectSchema = { a: a =&gt; typeof a ==='string', //   'string' b: b =&gt; typeof b === 'number', //   'number' // ... } const compositeObjValidator = v(objectSchema) const obj = { a: 'some text', b: 2 } const isObjValid = compositeObjValidator(obj) console.log(isObjValid) // =&gt; true</span></span></code> </pre> <br><p> 如您所见，从为特定字段定义的不同验证器块中，我们可以组装一个对象验证器-一些仍然很小的“小建筑物”，但是比没有它更好。 为此，我们使用验证器<code>v</code>的作曲者。  <strong>每次在验证程序的位置遇到对象文字<code>v</code>时，他都会将其视为对象组成，并根据其字段将其转换为对象验证程序。</strong> </p><br><p> 有时我们<strong>无法描述所有领域</strong> 。 例如，当一个对象是数据字典时： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quartet = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'quartet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = quartet() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isStringValidator = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> name === <span class="hljs-string"><span class="hljs-string">'string'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyValueValidator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, { key }</span></span></span><span class="hljs-function">) =&gt;</span></span> value.length === <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; key.length === <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dictionarySchema= { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: isStringValidator, ...v.rest(keyValueValidator) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compositeObjValidator = v(dictionarySchema) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: <span class="hljs-string"><span class="hljs-string">'next letter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-string"><span class="hljs-string">'d'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = compositeObjValidator(obj) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isObjValid) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true const obj2 = { dictionaryName: 'next letter', b: 'a', a: 'invalid value', notValidKey: 'a' } const isObj2Valid = compositeObjValidator(obj2) console.log(isObj2Valid) // =&gt; false</span></span></code> </pre> <br><h3 id="kak-pereispolzovat-stroitelnye-resheniya"> 如何重用施工解决方案？ </h3><br><p> 如上所述，有必要重用简单的验证器。 在这些示例中，我们已经不得不使用“字符串类型验证器”两次。 </p><br><p> 为了缩短记录并提高其可读性，四方库使用验证程序的字符串同义词。  <strong>每当验证者的作曲者在验证者应有的位置遇到字符串时，它都会在字典中搜索其验证者并使用它</strong> 。 </p><br><p> 默认情况下，最常见的验证器已在库中定义。 </p><br><p> 请考虑以下示例： </p><br><pre> <code class="javascript hljs">v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>)(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true v('number')('1') // =&gt; false v('string')('1') // =&gt; true v('string')(null) // =&gt; false v('null')(null) // =&gt; true v('object')(null) // =&gt; true v('object!')(null) // =&gt; false // ...</span></span></code> </pre> <br><p> 以及<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="文件资料">文档中</a></strong>描述的许多其他问题。 </p><br><h3 id="kazhdoy-arke---svoy-vid-kirpichey"> 每个拱门都有自己的砖头类型？ </h3><br><p> 验证程序的编写者（函数<code>v</code> ）也是验证程序的工厂。 从某种意义上说，它包含许多返回的有用方法 </p><br><ul><li> 功能验证器 </li><li> 作曲家将其视为创建验证程序的方案的值 </li></ul><br><p> 例如，让我们看一下数组验证：通常，它包括检查数组的类型和检查其所有元素。 我们将<code>v.arrayOf(elementValidator)</code>使用<code>v.arrayOf(elementValidator)</code>方法。 例如，采用带有名称的点数组。 </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [ {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'D'</span></span>}, ]</code> </pre> <br><p> 由于点数组是对象数组，因此使用对象组合来验证数组元素是有意义的。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> namedPointSchema = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// number -       y: 'number', name: 'string' // string -       }</span></span></code> </pre> <br><p> 现在，使用工厂方法<code>v.arrayOf</code> ，为整个数组创建一个验证器。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isArrayValid = v.arrayOf({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span> })</code> </pre> <br><p> 让我们看看这个验证器是如何工作的： </p><br><pre> <code class="javascript hljs">isArrayValid(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false isArrayValid(null) // =&gt; false isArrayValid([]) // =&gt; true isArrayValid([1, 2, 3]) // =&gt; false isArrayValid([ {x: 1, y: 1, name: 'A'}, {x: 2, y: 1, name: 'B'}, {x: -1, y: 2, name: 'C'}, {x: 1, y: 3, name: 'D'}, ]) // =&gt; true</span></span></code> </pre> <br><p> 这只是工厂方法之一，每种方法在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="文件资料">文档中</a>都有描述<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="文件资料">。</a> </p><br><p> 如上所述， <code>v.rest</code>也是一种工厂方法，该方法返回一个对象组合，该对象组合检查未在对象组合中指定的所有字段。 这意味着可以使用<code>spread-operator</code>将其嵌入到另一个对象合成中。 </p><br><p> 让我们以其中的几个示例为例： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //   ,    const max = { name: 'Maxim', sex: 'male', age: 34, status: 'grandpa', friends: [ { name: 'Dima', friendDuration: '1 year'}, { name: 'Semen', friendDuration: '3 months'} ], workExperience: 2 } //  ,   "" , // ""  , ""   -  const nameSchema = v.and( 'not-empty', 'string', //   name =&gt; name[0].toUpperCase() === name[0] // - ) const maxSchema = { name: nameSchema, //       sex: v.enum('male', 'female'), //  -   . //       "" age: v.and('non-negative', 'safe-integer'), status: v.enum('grandpa', 'non-grandpa'), friends: v.arrayOf({ name: nameSchema, //      friendDuration: v.regex(/^[1-9]\d? (years?|months?)$/) }), workExperience: v.and('non-negative', 'safe-integer') } console.log(v(maxSchema)(max)) // =&gt; true</span></span></code> </pre> <br><h3 id="byt-ili-ne-byt"> 是还是不是？ </h3><br><p> 有效数据经常采用各种形式，例如： </p><br><ul><li>  <code>id</code>可以是数字，也可以是字符串。 </li><li> 根据尺寸， <code>point</code>对象可能包含也可能不包含某些坐标。 </li><li> 还有许多其他情况。 </li></ul><br><p> 为了组织变体的验证，提供了一种单独的组成类型-变体组成。 它由可能选项的验证器数组表示。 当至少一个验证者报告对象的有效性时，该对象被视为有效。 </p><br><p> 考虑一个带有标识符验证的例子： </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isValidId = v([ v.and(<span class="hljs-string"><span class="hljs-string">'not-empty'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>), <span class="hljs-comment"><span class="hljs-comment">//       v.and('positive', 'safe-integer') //    ]) isValidId('') // =&gt; false isValidId('asdba32bas321ab321adb321abds546ba98s7') // =&gt; true isValidId(0) // =&gt; false isValidId(1) // =&gt; true isValidId(1123124) // =&gt; true</span></span></code> </pre> <br><p> 点验证示例： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPointValid = v([ { <span class="hljs-comment"><span class="hljs-comment">//    -    x  dimension: v.enum(1), x: 'number', // v.rest    false // ,    -  ...v.rest(() =&gt; false) }, //   -    { dimension: v.enum(2), x: 'number', y: 'number', ...v.rest(() =&gt; false) }, //   - x, y  z { dimension: v.enum(3), x: 'number', y: 'number', z: 'number', ...v.rest(() =&gt; false) }, ]) // ,    ,      ,     -  -    isPointValid(1) // =&gt; false isPointValid(null) // =&gt; false isPointValid({ dimension: 1, x: 2 }) // =&gt; true isPointValid({ dimension: 1, x: 2, y: 3 //   }) // =&gt; false isPointValid({ dimension: 2, x: 2, y: 3 }) // =&gt; true isPointValid({ dimension: 3, x: 2, y: 3, z: 4 }) // =&gt; true // ...</span></span></code> </pre> <br><p> 因此， <strong>每当作曲家看到一个数组时，他都会认为它是此数组的验证器元素的组成，这样当其中一个认为该值有效时，验证的计算将停止并且该值将被视为有效。</strong> </p><br><p> 如我们所见，作曲家不仅将验证器功能视为验证器，而且还将所有可能导致验证器功能的事物视为。 </p><br><table><thead><tr><th> 验证者类型 </th><th> 例子 </th><th> 作曲家认为 </th></tr></thead><tbody><tr><td> 验证功能 </td><td> <code>x =&gt; typeof x === 'bigint'</code> </td> <td> 只是要求了必要的值 </td></tr><tr><td> 对象组成 </td><td> <code>{ a: 'number' }</code> </td> <td> 根据指定的字段验证器为对象创建验证器函数 </td></tr><tr><td> 变体成分 </td><td> <code>['number', 'string']</code> </td> <td> 创建一个验证器函数以使用至少一个选项来验证值 </td></tr><tr><td> 工厂方法调用结果 </td><td> <code>v.enum('male', 'female')</code> </td> <td> 大多数工厂方法都返回验证函数（ <code>v.rest</code> ，该函数返回对象组成），因此它们被视为常规验证函数 </td></tr></tbody></table><br><p> 所有这些验证器选项都是有效的，并且可以在验证器应在模式中的任何位置使用。 </p><br><p> 结果，工作方案始终是这样的： <code>v(schema)</code>返回验证函数。 接下来，在特定值上调用此验证函数： <br> <code>v(schema)(value[, ...parents])</code> </p> <br><h2 id="u-vas-avarii-na-stroyke-byli"> 您在施工现场有任何事故吗？ </h2><br><p>  <em>-还没有</em> <br>  <em>-他们会的！</em> </p><br><p> 碰巧数据无效，我们需要能够确定无效原因。 </p><br><p> 为此，四方库提供了一种<em>解释</em>机制。 它包含以下事实：在验证器（无论是内部验证器还是外部验证器）检测到验证数据的有效性时，必须发送<em>说明性注释</em> 。 </p><br><p> 为此， <code>v</code>了验证者<code>v</code>的作曲者的第二个参数。 它增加了在数据无效的情况下向<code>v.explanation</code>数组发送<em>解释性注释</em>的<code>v.explanation</code> 。 </p><br><p> 例如，让我们验证一个数组，并想找出所有无效元素的数量及其值： </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   -     //   const getExplanation = (value, { key: index }) =&gt; ({ invalidValue: value, index }) // ,       . //         v.explanation //    const arrValidator = v.arrayOf( v( 'number', //   getExplanation //   "",   "" ) ) // ,     ""  //     ,     //         //   ,       const explainableArrValidator = v(arrValidator, 'this array is not valid') const arr = [1, 2, 3, 4, '5', '6', 7, '8'] explainableArrValidator(arr) // =&gt; false v.explanation // [ // { invalidValue: '5', index: 4 }, // { invalidValue: '6', index: 5 }, // { invalidValue: '8', index: 7 }, // 'this array is not valid' // ]</span></span></code> </pre> <br><p> 如您所见，解释的选择取决于任务。 有时甚至没有必要。 </p><br><p> 有时我们需要对无效字段进行处理。 在这种情况下，可以使用无效字段的名称作为<em>解释</em> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = v(objSchema) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invalidObj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } isObjValid(invalidObj) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false v.explanation // ['b', 'c'] //     console.error(`${v.explanation.join(', ')} is not valid`) // =&gt; b, c is not valid //       (. ) invalidObj = v.omitInvalidProps(objSchema)(invalidObj) console.log(invalidObj) // =&gt; { a: 1 }</span></span></code> </pre> <br><p> 有了这种解释机制，您可以实现与验证结果相关的任何行为。 </p><br><p> 解释可以是任何东西： </p><br><ul><li> 包含必要信息的对象； </li><li> 纠正错误的功能。  （ <code>getExplanation =&gt; function(invalid): valid</code> ）; </li><li> 无效字段的名称或无效元素的索引； </li><li> 错误代码 </li><li> 所有这些足以让您发挥想象力。 </li></ul><br><h2 id="chto-delat-kogda-delo-ne-stroitsya"> 没有构建东西时该怎么办？ </h2><br><p> 纠正验证错误并非难事。 为此，该库使用带有副作用的验证器，该副作用会记住错误的位置以及如何修复错误。 </p><br><ul><li>  <code>v.default(validator, value)</code> -返回一个记住无效值的验证程序，并在调用<code>v.fix</code>设置默认值 </li><li>  <code>v.filter(validator)</code> -返回一个记住无效值的验证器，并在调用<code>v.fix</code> -从父级中删除该值 </li><li>  <code>v.addFix(validator, fixFunc)</code> -返回一个记住无效值的验证程序，并且在调用<code>v.fix</code> -调用带有参数（值，{key，parent}，...）的fixFunc。  <code>fixFunc</code>必须变异合作伙伴之一-更改值 </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toPositive = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">negativeValue, { key, parent }</span></span></span><span class="hljs-function">) =&gt;</span></span> { parent[key] = -negativeValue } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v.filter(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'array'</span></span>, []), <span class="hljs-attr"><span class="hljs-attr">d</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, invalidValue =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(invalidValue)), <span class="hljs-comment"><span class="hljs-comment">//    pos: v.and( v.default('number', 0), //     -  0 v.addFix('non-negative', toPositive) //     -   ) } const invalidObj = { a: 1, b: 2, c: 3, d: '4', pos: -3 } v.resetExplanation() //   v() v(objSchema)(invalidObj) // =&gt; false // v.hasFixes() =&gt; true const validObj = v.fix(invalidObj) console.log(validObj) // =&gt; { a: 1, b: '', c: [], d: 4 }</span></span></code> </pre> <br><h3 id="po-hozyaystvu-eschyo-prigoditsya"> 杂务仍然派上用场 </h3><br><p> 该库中还有一些验证方法的实用程序方法： </p><br><table><thead><tr><th> 方法 </th><th> 结果 </th></tr></thead><tbody><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="v.throwError"><code>v.throwError</code></a> </td> <td> 如果无效，则使用给定的消息引发TypeError。 </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="`v.omitInvalidItems`"><code>v.omitInvalidItems</code></a> </td> <td> 返回没有无效元素（字段）的新数组（或字典对象）。 </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="`v.omitInvalidProps`"><code>v.omitInvalidProps</code></a> </td> <td> 根据指定的对象验证器，返回没有无效字段的新对象。 </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="`v.validOr`"><code>v.validOr</code></a> </td> <td> 如果有效，则返回该值，否则将其替换为指定的默认值。 </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>v.example</code></a> </td> <td> 检查给定的值是否适合该模式。 如果它们不合适，则会引发错误。 用作文档和电路测试 </td></tr></tbody></table><br><h2 id="rezultaty"> 结果 </h2><br><p> 通过以下方式解决了任务： </p><br><table><thead><tr><th> 挑战赛 </th><th> 解决方案 </th></tr></thead><tbody><tr><td> 数据类型验证 </td><td> 默认命名验证器。 </td></tr><tr><td> 预设值 </td><td> <code>v.default</code> </td> </tr><tr><td> 移除无效零件 </td><td>  <code>v.filter</code> ， <code>v.omitInvalidItems</code>和<code>v.omitInvalidProps</code> 。 </td></tr><tr><td> 易学 </td><td> 简单的验证器，将它们组合为复杂的验证器的简单方法。 </td></tr><tr><td> 代码可读性 </td><td> 该库的目标之一是将验证方案本身比作 </td></tr><tr><td> 验证对象。 </td></tr><tr><td> 易于修改 </td><td> 掌握了合成的元素并使用了自己的验证功能-更改代码非常简单。 </td></tr><tr><td> 错误讯息 </td><td> 以错误消息的形式进行说明。 或根据说明计算错误代码。 </td></tr></tbody></table><br><h2 id="posleslovie"> 后记 </h2><br><p> 该解决方案旨在快速方便地创建验证器功能，并具有嵌入自定义验证功能的能力。 因此，欢迎阅读本文的人进行任何更正，批评和改进。 谢谢您的关注。 <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN429916/">https://habr.com/ru/post/zh-CN429916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN429904/index.html">关于计算机游戏开发的有趣和悲伤的故事</a></li>
<li><a href="../zh-CN429908/index.html">如何在食物中使用协程和夜间安眠</a></li>
<li><a href="../zh-CN429910/index.html">AppsConf上升</a></li>
<li><a href="../zh-CN429912/index.html">库开发：从API到公开发布</a></li>
<li><a href="../zh-CN429914/index.html">OpenSceneGraph：场景图和智能指针</a></li>
<li><a href="../zh-CN429918/index.html">虚拟世界英特尔。 第2部分：SMP</a></li>
<li><a href="../zh-CN429920/index.html">NaN中的Tragicomedy行为：我们如何在JS上制作游戏并在Steam上发布它</a></li>
<li><a href="../zh-CN429922/index.html">如何将一个简单的项目转变为长期建设项目，或切断所有不必要的项目</a></li>
<li><a href="../zh-CN429928/index.html">您需要了解的有关压力和强烈情绪的所有信息</a></li>
<li><a href="../zh-CN429930/index.html">Splunk 简单的应用程序故障排除</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>