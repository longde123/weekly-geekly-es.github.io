<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚈 🚫 🍢 6 hombres inesperados de Julia 💪🏼 🙏🏾 👩🏽‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Finalmente, apareció una guía en ruso para el idioma Julia . Proporciona una introducción completa al lenguaje para aquellos que tienen poca experienc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>6 hombres inesperados de Julia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443484/"><p><img src="https://habrastorage.org/webt/kk/lq/li/kklqliklumioy9-vmupwuq9afpc.png"></p><br><p>  Finalmente, apareció una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">guía en ruso para el idioma Julia</a> .  Proporciona una introducción completa al lenguaje para aquellos que tienen poca experiencia en programación (el resto será útil para el desarrollo general), también hay una introducción al aprendizaje automático y un montón de tareas para consolidar el material. </p><br><p> Durante la búsqueda, me encontré con un curso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programación para economistas</a> (además de Julia, también hay Python).  Los experimentados pueden ir a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">curso rápido</a> o leer el libro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo pensar como un informático</a> </p><br><p>  La siguiente es una traducción del material del blog de Christopher Rackauckas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7 Julia Gotchas y Cómo manejarlos</a> </p><a name="habracut"></a><br><p> Permítanme comenzar diciendo que Julia es un lenguaje maravilloso.  La amo, esto es lo que considero el lenguaje más poderoso e intuitivo que he usado.  Este es sin duda mi idioma favorito.  Sin embargo, hay algunas "trampas", pequeñas cosas difíciles que debes saber.  Cada idioma los tiene, y una de las primeras cosas que debe hacer para dominar el idioma es descubrir cuáles son y cómo evitarlos.  El objetivo de esta publicación es ayudarlo a acelerar este proceso al exponer algunos de los <code></code> más comunes que sugieren métodos de programación alternativos. </p><br><p>  Julia es un buen lenguaje para entender lo que está sucediendo, porque no tiene magia.  Los desarrolladores de Julia querían tener reglas de conducta claramente definidas.  Esto significa que todo comportamiento puede explicarse.  Sin embargo, esto puede significar que tiene que esforzarse para comprender por qué esto y no lo otro está sucediendo.  Es por eso que no solo voy a describir algunos problemas comunes, sino que también voy a explicar por qué surgen.  Verás que hay algunos patrones muy similares, y una vez que te des cuenta de ellos, ya no te burlarás de ninguno de ellos.  Debido a esto, Julia tiene una curva de aprendizaje un poco más pronunciada en comparación con lenguajes más simples como <em>MATLAB / R / Python</em> .  Sin embargo, una vez que haya dominado esto, podrá utilizar completamente el laconismo de Julia para obtener el rendimiento de <em>C / Fortran</em> .  Ahora cava más profundo. </p><br><h2 id="nezhdanchik-raz-repl-terminal-imeet-globalnuyu-oblast-vidimosti">  Inesperadamente: REPL (terminal) tiene un alcance global </h2><br><p>  Este es, con mucho, el problema más común reportado por los nuevos usuarios de Julia.  Alguien dirá: "Escuché, ¡Julia es rápida!", Abra REPL, escriba rápidamente un algoritmo conocido y ejecute este script.  Después de su ejecución, miran el tiempo y dicen: "Espera un segundo, ¿por qué es lento, como en Python?"  Dado que este es un problema tan importante y común, dediquemos un tiempo a explorar las razones por las que esto sucede para descubrir cómo evitarlo. </p><br><h3 id="nebolshoe-otstuplenie-pochemu-dzhuliya-bystra">  Una pequeña digresión: por qué Julia es rápida </h3><br><p>  Debe comprender que Julia no es solo una compilación de código, sino también una especialización de tipos (es decir, una compilación de código específica para estos tipos).  Permítanme reiterar: Julia no es rápida, porque el código se compila utilizando el compilador JIT, más bien el secreto de la velocidad es que se compila el código específico del tipo. </p><br><p>  Si necesita una historia completa, consulte algunas de las notas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que escribí para el próximo seminario</a> .  La especificidad de tipo está determinada por el principio básico del diseño de Julia: <strong>despacho múltiple</strong> .  Cuando escribes el código: </p><br><pre> <code class="plaintext hljs">function f(a,b) return 2a+b end</code> </pre> <br><p>  Parece que esta es solo una <code></code> , pero de hecho aquí se crean una gran cantidad de <code></code> .  En el lenguaje de Julia, una función es una abstracción, y lo que en realidad se llama es un método.  Si llama a <code>f(2.0,3.0)</code> , Julia ejecutará el código compilado, que toma dos números de coma flotante y devuelve <code>2a + b</code> .  Si llama a <code>f(2,3)</code> , Julia ejecutará otro código compilado que toma dos enteros y devuelve <code>2a + b</code> .  La función <code>f</code> es una abstracción o abreviatura para muchos métodos diferentes que tienen la misma forma, y ​​dicho esquema de usar el símbolo <em>f</em> para llamar a todos estos métodos diferentes se denomina despacho múltiple.  Y esto se aplica en todas partes: el operador <code>+</code> es en realidad una función que llamará a los métodos dependiendo de los tipos que vea.  En realidad, Julia obtiene su velocidad porque el código compilado por ella conoce sus tipos y, por lo tanto, el código compilado que llama a f (2.0,3.0) es exactamente el código compilado que se obtiene al definir la misma función en <em>C / Fortran</em> .  Puede verificar esto con la macro <code>code_native</code> para ver el ensamblado compilado: </p><br><pre> <code class="plaintext hljs">@code_native f(2.0,3.0)</code> </pre> <br><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp Source line: 2 vaddsd %xmm0, %xmm0, %xmm0 vaddsd %xmm1, %xmm0, %xmm0 popq %rbp retq nop</code> </pre> <br><p>  Este es el mismo ensamblado compilado que espera de una función en <em>C / Fortran</em> , y difiere del código de ensamblado para enteros: </p><br><pre> <code class="plaintext hljs">@code_native f(2,3) pushq %rbp movq %rsp, %rbp Source line: 2 leaq (%rdx,%rcx,2), %rax popq %rbp retq nopw (%rax,%rax)</code> </pre> <br><h4 id="sut-repl--global-scope-ne-dopuskaet-specifiku-tipov">  Esencia: REPL / Global Scope no permite especificidad de tipo </h4><br><p>  Esto nos lleva al punto principal: REPL / Global Scope es lento porque no permite la especificación de tipo.  En primer lugar, tenga en cuenta que REPL es un ámbito global porque Julia permite un ámbito anidado para funciones.  Por ejemplo, si definimos </p><br><pre> <code class="plaintext hljs">function outer() a = 5 function inner() return 2a end b = inner() return 3a+b end</code> </pre> <br><p>  veremos que este código funciona.  Esto se debe a que Julia le permite capturar <code></code> función externa a una función interna.  Si aplica esta idea de manera recursiva, se dará cuenta de que el área más alta es el área que es <strong>REPL</strong> directamente (que es el alcance global del módulo <strong>Principal</strong> ).  Pero ahora pensemos cómo se compilará la función en esta situación.  Implementamos lo mismo, pero usando variables globales: </p><br><pre> <code class="plaintext hljs">a=2.0; b=3.0 function linearcombo() return 2a+b end ans = linearcombo()</code> </pre> <br><p>  y </p><br><pre> <code class="plaintext hljs">a = 2; b = 3 ans2= linearcombo()</code> </pre> <br><p>  Pregunta: ¿Qué tipos debe aceptar el compilador para <code>b</code> ?  Tenga en cuenta que en este ejemplo, cambiamos los tipos y aún llamamos a la misma función.  Puede tratar cualquier tipo que le agreguemos: flotante, enteros, matrices, tipos de usuarios extraños, etc. En Julia, esto significa que las variables deben estar encuadradas y los tipos se verifican cada vez que se usan.  ¿Cómo crees que se ve el código compilado? </p><br><div class="spoiler">  <b class="spoiler_title">Voluminoso</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp pushq %r15 pushq %r14 pushq %r12 pushq %rsi pushq %rdi pushq %rbx subq $96, %rsp movl $2147565792, %edi # imm = 0x800140E0 movabsq $jl_get_ptls_states, %rax callq *%rax movq %rax, %rsi leaq -72(%rbp), %r14 movq $0, -88(%rbp) vxorps %xmm0, %xmm0, %xmm0 vmovups %xmm0, -72(%rbp) movq $0, -56(%rbp) movq $10, -104(%rbp) movq (%rsi), %rax movq %rax, -96(%rbp) leaq -104(%rbp), %rax movq %rax, (%rsi) Source line: 3 movq pcre2_default_compile_context_8(%rdi), %rax movq %rax, -56(%rbp) movl $2154391480, %eax # imm = 0x806967B8 vmovq %rax, %xmm0 vpslldq $8, %xmm0, %xmm0 # xmm0 = zero,zero,zero,zero,zero,zero,zero,zero,xmm0[0,1,2,3,4,5,6,7] vmovdqu %xmm0, -80(%rbp) movq %rdi, -64(%rbp) movabsq $jl_apply_generic, %r15 movl $3, %edx movq %r14, %rcx callq *%r15 movq %rax, %rbx movq %rbx, -88(%rbp) movabsq $586874896, %r12 # imm = 0x22FB0010 movq (%r12), %rax testq %rax, %rax jne L198 leaq 98096(%rdi), %rcx movabsq $jl_get_binding_or_error, %rax movl $122868360, %edx # imm = 0x752D288 callq *%rax movq %rax, (%r12) L198: movq 8(%rax), %rax testq %rax, %rax je L263 movq %rax, -80(%rbp) addq $5498232, %rdi # imm = 0x53E578 movq %rdi, -72(%rbp) movq %rbx, -64(%rbp) movq %rax, -56(%rbp) movl $3, %edx movq %r14, %rcx callq *%r15 movq -96(%rbp), %rcx movq %rcx, (%rsi) addq $96, %rsp popq %rbx popq %rdi popq %rsi popq %r12 popq %r14 popq %r15 popq %rbp retq L263: movabsq $jl_undefined_var_error, %rax movl $122868360, %ecx # imm = 0x752D288 callq *%rax ud2 nopw (%rax,%rax)</code> </pre> </div></div><br><p>  Para lenguajes dinámicos sin especialización de tipo, este código inflado con todas las instrucciones adicionales es tan bueno como sea posible, por lo que Julia disminuye su velocidad.  Para comprender por qué esto es tan importante, tenga en cuenta que cada fragmento de código que escribe en Julia se compila.  Digamos que escribes un bucle en tu script: </p><br><pre> <code class="plaintext hljs">a = 1 for i = 1:100 a += a + f(a) end</code> </pre> <br><p>  El compilador tendrá que compilar este bucle, pero como no puede garantizar que los tipos no cambien, conserva de forma conservadora un paño en todos los tipos, lo que conduce a una ejecución lenta. </p><br><h4 id="kak-izbezhat-problemy">  Como evitar un problema </h4><br><p>  Hay varias formas de evitar este problema.  La forma más fácil es envolver siempre sus scripts en funciones.  Por ejemplo, el código anterior tomará la forma: </p><br><pre> <code class="plaintext hljs">function geta(a) # can also just define a=1 here for i = 1:100 a += a + f(a) end return a end a = geta(1)</code> </pre> <br><p>  Esto le dará el mismo resultado, pero dado que el compilador puede especializarse en el tipo <code>a</code> , le proporcionará el código compilado que desee.  Otra cosa que puede hacer es definir sus variables como constantes. </p><br><pre> <code class="plaintext hljs">const b = 5</code> </pre> <br><p>  Al hacer esto, le dice al compilador que la variable no cambiará y, por lo tanto, podrá especializar todo el código que lo usa en el tipo que es actualmente.  Hay una ligera peculiaridad de que Julia realmente le permite cambiar el valor de una constante, pero no un tipo.  Por lo tanto, puede usar <code>const</code> para decirle al compilador que no cambiará el tipo.  Sin embargo, tenga en cuenta que hay algunas pequeñas peculiaridades: </p><br><pre> <code class="plaintext hljs">const a = 5 f() = a println(f()) # Prints 5 a = 6 println(f()) # Prints 5 # WARNING: redefining constant a</code> </pre> <br><p>  esto no funciona como se esperaba, porque el compilador, al darse cuenta de que conoce la respuesta a <code>f () = a</code> (ya que <code>a</code> es una constante), simplemente reemplazó la llamada a la función con la respuesta, dando un comportamiento diferente al de a si no fuera constante. </p><br><p>  <strong>Moraleja: no escriba sus scripts directamente en REPL, siempre envuélvalos en una función.</strong> </p><br><h2 id="nezhdanchik-dva-nestabilnost-tipov">  Nezhdanchik dos: inestabilidad tipo </h2><br><p>  Entonces, acabo de expresar una opinión sobre la importancia de la especialización del código para los tipos de datos.  Déjame hacerte una pregunta, ¿qué sucede cuando tus tipos pueden cambiar?  Si adivinó: "Bueno, en este caso, no puede especializar el código compilado", tiene razón.  Tal problema se conoce como inestabilidad de tipo.  Pueden aparecer de manera diferente, pero un ejemplo común es que inicializa el valor con el simple, pero no necesariamente el tipo que debería ser.  Por ejemplo, veamos: </p><br><pre> <code class="plaintext hljs">function g() x=1 for i = 1:10 x = x/2 end return x end</code> </pre> <br><p>  Tenga en cuenta que <code>1/2</code> es un número de coma flotante en Julia.  Por lo tanto, si comenzamos con <code>x = 1</code> , el número entero cambiará a un número de coma flotante y, por lo tanto, la función debería compilar el bucle interno, como si pudiera ser de cualquier tipo.  Si en cambio tuviéramos: </p><br><pre> <code class="plaintext hljs">function h() x=1.0 for i = 1:10 x = x/2 end return x end</code> </pre> <br><p>  entonces toda la función podrá compilarse de manera óptima, sabiendo que <code>x</code> seguirá siendo un número de coma flotante (esta capacidad para que el compilador determine los tipos se llama inferencia de tipos).  Podemos verificar el código compilado para ver la diferencia: </p><br><div class="spoiler">  <b class="spoiler_title">Tela nativa</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp pushq %r15 pushq %r14 pushq %r13 pushq %r12 pushq %rsi pushq %rdi pushq %rbx subq $136, %rsp movl $2147565728, %ebx # imm = 0x800140A0 movabsq $jl_get_ptls_states, %rax callq *%rax movq %rax, -152(%rbp) vxorps %xmm0, %xmm0, %xmm0 vmovups %xmm0, -80(%rbp) movq $0, -64(%rbp) vxorps %ymm0, %ymm0, %ymm0 vmovups %ymm0, -128(%rbp) movq $0, -96(%rbp) movq $18, -144(%rbp) movq (%rax), %rcx movq %rcx, -136(%rbp) leaq -144(%rbp), %rcx movq %rcx, (%rax) movq $0, -88(%rbp) Source line: 4 movq %rbx, -104(%rbp) movl $10, %edi leaq 477872(%rbx), %r13 leaq 10039728(%rbx), %r15 leaq 8958904(%rbx), %r14 leaq 64(%rbx), %r12 leaq 10126032(%rbx), %rax movq %rax, -160(%rbp) nopw (%rax,%rax) L176: movq %rbx, -128(%rbp) movq -8(%rbx), %rax andq $-16, %rax movq %r15, %rcx cmpq %r13, %rax je L272 movq %rbx, -96(%rbp) movq -160(%rbp), %rcx cmpq $2147419568, %rax # imm = 0x7FFF05B0 je L272 movq %rbx, -72(%rbp) movq %r14, -80(%rbp) movq %r12, -64(%rbp) movl $3, %edx leaq -80(%rbp), %rcx movabsq $jl_apply_generic, %rax vzeroupper callq *%rax movq %rax, -88(%rbp) jmp L317 nopw %cs:(%rax,%rax) L272: movq %rcx, -120(%rbp) movq %rbx, -72(%rbp) movq %r14, -80(%rbp) movq %r12, -64(%rbp) movl $3, %r8d leaq -80(%rbp), %rdx movabsq $jl_invoke, %rax vzeroupper callq *%rax movq %rax, -112(%rbp) L317: movq (%rax), %rsi movl $1488, %edx # imm = 0x5D0 movl $16, %r8d movq -152(%rbp), %rcx movabsq $jl_gc_pool_alloc, %rax callq *%rax movq %rax, %rbx movq %r13, -8(%rbx) movq %rsi, (%rbx) movq %rbx, -104(%rbp) Source line: 3 addq $-1, %rdi jne L176 Source line: 6 movq -136(%rbp), %rax movq -152(%rbp), %rcx movq %rax, (%rcx) movq %rbx, %rax addq $136, %rsp popq %rbx popq %rdi popq %rsi popq %r12 popq %r13 popq %r14 popq %r15 popq %rbp retq nop</code> </pre> </div></div><br><p>  en contra </p><br><div class="spoiler">  <b class="spoiler_title">Hechizo de ensamblador ordenado</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp movabsq $567811336, %rax # imm = 0x21D81D08 Source line: 6 vmovsd (%rax), %xmm0 # xmm0 = mem[0],zero popq %rbp retq nopw %cs:(%rax,%rax)</code> </pre> </div></div><br><p>  ¡Qué diferencia en el número de cálculos para obtener el mismo valor! </p><br><h4 id="kak-nayti-i-spravitsya-s-nestabilnostyu-tipov">  Cómo encontrar y lidiar con la inestabilidad de tipos </h4><br><p><img src="https://habrastorage.org/webt/92/l8/sn/92l8sno_8hd-dho0limmkwerezs.jpeg"></p><br><p>  En este punto, puede preguntar: "Bueno, ¿por qué no usar <strong>C</strong> para no tener que buscar estas inestabilidades?"  La respuesta es: </p><br><ol><li>  Fácil de encontrar </li><li>  Pueden ser de ayuda. </li><li><p>  Puede manejar la inestabilidad con barreras funcionales. </p><br><p>  Julia le da la macro <code>code_warntype</code> para mostrar dónde están las inestabilidades de tipo.  Por ejemplo, si usamos esto en la función <code>g</code> que creamos: </p><br><pre> <code class="plaintext hljs">@code_warntype g()</code> </pre> <br></li></ol><br><div class="spoiler">  <b class="spoiler_title">obtener el análisis</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Variables: #self#::#g x::ANY #temp#@_3::Int64 i::Int64 #temp#@_5::Core.MethodInstance #temp#@_6::Float64 Body: begin x::ANY = 1 # line 3: SSAValue(2) = (Base.select_value)((Base.sle_int)(1,10)::Bool,10,(Base.box)(Int64,(Base.sub_int)(1,1)))::Int64 #temp#@_3::Int64 = 1 5: unless (Base.box)(Base.Bool,(Base.not_int)((#temp#@_3::Int64 === (Base.box)(Int64,(Base.add_int)(SSAValue(2),1)))::Bool)) goto 30 SSAValue(3) = #temp#@_3::Int64 SSAValue(4) = (Base.box)(Int64,(Base.add_int)(#temp#@_3::Int64,1)) i::Int64 = SSAValue(3) #temp#@_3::Int64 = SSAValue(4) # line 4: unless (Core.isa)(x::UNION{FLOAT64,INT64},Float64)::ANY goto 15 #temp#@_5::Core.MethodInstance = MethodInstance for /(::Float64, ::Int64) goto 24 15: unless (Core.isa)(x::UNION{FLOAT64,INT64},Int64)::ANY goto 19 #temp#@_5::Core.MethodInstance = MethodInstance for /(::Int64, ::Int64) goto 24 19: goto 21 21: #temp#@_6::Float64 = (x::UNION{FLOAT64,INT64} / 2)::Float64 goto 26 24: #temp#@_6::Float64 = $(Expr(:invoke, :(#temp#@_5), :(Main./), :(x::Union{Float64,Int64}), 2)) 26: x::ANY = #temp#@_6::Float64 28: goto 5 30: # line 6: return x::UNION{FLOAT64,INT64} end::UNION{FLOAT64,INT64}</code> </pre> </div></div><br><p>  Tenga en cuenta que al principio decimos que el tipo x es <code>Any</code> .  Utilizará cualquier tipo que no esté designado como <code>strict type</code> , es decir, es un tipo abstracto que necesita ser encuadrado / verificado en cada paso.  Vemos que al final devolvemos <code>x</code> como <code>UNION {FLOAT64, INT64}</code> , que es otro tipo no estricto.  Esto nos dice que el tipo <code></code> ha cambiado, causando dificultades.  Si en cambio miramos <code>code_warntype</code> para <code>h</code> , obtenemos todos los tipos estrictos: </p><br><pre> <code class="plaintext hljs">@code_warntype h() Variables: #self#::#h x::Float64 #temp#::Int64 i::Int64 Body: begin x::Float64 = 1.0 # line 3: SSAValue(2) = (Base.select_value)((Base.sle_int)(1,10)::Bool,10,(Base.box)(Int64,(Base.sub_int)(1,1)))::Int64 #temp#::Int64 = 1 5: unless (Base.box)(Base.Bool,(Base.not_int)((#temp#::Int64 === (Base.box)(Int64,(Base.add_int)(SSAValue(2),1)))::Bool)) goto 15 SSAValue(3) = #temp#::Int64 SSAValue(4) = (Base.box)(Int64,(Base.add_int)(#temp#::Int64,1)) i::Int64 = SSAValue(3) #temp#::Int64 = SSAValue(4) # line 4: x::Float64 = (Base.box)(Base.Float64,(Base.div_float)(x::Float64,(Base.box)(Float64,(Base.sitofp)(Float64,2)))) 13: goto 5 15: # line 6: return x::Float64 end::Float64</code> </pre> <br><p>  Esto indica que la función es de tipo estable y se compilará esencialmente en un <em>código C</em> óptimo.  Por lo tanto, la inestabilidad de tipo no es difícil de encontrar.  Lo que es más difícil es encontrar el diseño correcto.  ¿Por qué resolver la inestabilidad de tipo?  Este es un problema de larga data que ha llevado al hecho de que los idiomas escritos dinámicamente dominan el campo de juego de los scripts.  La idea es que, en muchos casos, desee encontrar un compromiso entre rendimiento y confiabilidad. </p><br><p>  Por ejemplo, puede leer una tabla desde una página web en la que los enteros se mezclan con números de coma flotante.  En Julia, puede escribir su función de modo que si todos fueran números enteros, se compile bien, y si todos fueran números de coma flotante, también se compilaría bien.  ¿Y si se mezclan?  Esto seguirá funcionando.  Esta es la flexibilidad / conveniencia que conocemos y amamos de un lenguaje como <em>Python / R.</em>  Pero Julia le dirá directamente (a <em>través de code_warntype</em> ) cuando sacrifique el rendimiento. </p><br><h3 id="kak-spravitsya-s-nestabilnostyami-tipov">  Cómo lidiar con las inestabilidades de tipo </h3><br><p><img src="https://habrastorage.org/webt/2s/9h/xg/2s9hxgty3fsdvuqf3a6ey05dxzs.png"></p><br><p>  Hay varias formas de lidiar con las inestabilidades de tipo.  En primer lugar, si le gusta algo como <em>C / Fortran</em> donde sus tipos se declaran y no pueden cambiar (lo que garantiza la estabilidad de los tipos), puede hacerlo en Julia: </p><br><pre> <code class="plaintext hljs">local a::Int64 = 5</code> </pre> <br><p>  Esto hace <code>a</code> número entero de 64 bits, y si el código futuro intenta cambiarlo, se generará un mensaje de error (o se realizará la conversión correcta. Pero como la conversión no se redondeará automáticamente, lo más probable es que cause errores).  Espolvéalos alrededor de tu código y obtendrás estabilidad de tipo, ala, <em>C / Fortran</em> .  Una forma menos complicada de manejar esto es con declaraciones de tipo.  Aquí pones la misma sintaxis en el otro lado del signo igual.  Por ejemplo: </p><br><pre> <code class="plaintext hljs">a = (b/c)::Float64</code> </pre> <br><p>  Parece decir: "calcule b / c y asegúrese de que la salida sea Float64. Si no lo está, intente realizar una conversión automática. Si la conversión no puede realizarse fácilmente, envíe un error".  Colocar tales diseños lo ayudará a asegurarse de saber qué tipos están involucrados.  Sin embargo, en algunos casos, la inestabilidad de tipo es necesaria.  Por ejemplo, supongamos que desea tener un código confiable, pero el usuario le ofrece algo loco, como: </p><br><pre> <code class="plaintext hljs">arr = Vector{Union{Int64,Float64}}(undef, 4) arr[1]=4 arr[2]=2.0 arr[3]=3.2 arr[4]=1</code> </pre> <br><p>  que es una matriz de enteros 4x1 y números de punto flotante.  El tipo de elemento real para la matriz es <code>Union {Int64, Float64}</code> , que, como vimos anteriormente, no era estricto, lo que podría generar problemas.  El compilador solo sabe que cada valor puede ser un número entero o un número de coma flotante, pero no qué elemento de qué tipo.  Esto significa que es ingenuo hacer aritmética con esta matriz, por ejemplo: </p><br><pre> <code class="plaintext hljs">function foo{T,N}(array::Array{T,N}) for i in eachindex(array) val = array[i] # do algorithm X on val end end</code> </pre> <br><p>  será lento ya que las operaciones serán encuadradas.  Sin embargo, podemos utilizar el envío múltiple para ejecutar códigos de manera especializada.  Esto se conoce como el uso de barreras funcionales.  Por ejemplo: </p><br><pre> <code class="plaintext hljs">function inner_foo{T&lt;:Number}(val::T) # Do algorithm X on val end function foo2{T,N}(array::Array{T,N}) for i in eachindex(array) inner_foo(array[i]) end end</code> </pre> <br><p>  Tenga en cuenta que debido al envío múltiple, la llamada a <code>inner_foo</code> llama a un método específicamente compilado para números de coma flotante o un método especialmente compilado para enteros.  Por lo tanto, puede poner un cálculo largo en <code>inner_foo</code> y aún así hacerlo funcionar bien, no inferior al tipo estricto que le proporciona la barrera funcional. </p><br><p>  Por lo tanto, espero que vea que Julia ofrece una buena combinación de rendimiento de escritura fuerte y la comodidad de la escritura dinámica.  Una buena programadora, Julia, tiene ambas opciones para maximizar la productividad y / o la productividad si es necesario. </p><br><h3 id="nezhdanchik-3-eval-rabotaet-na-globalnom-urovne">  Sorpresa 3: Eval funciona a nivel mundial </h3><br><p><img src="https://habrastorage.org/webt/vs/5d/p2/vs5dp2t9wel5mbje-ewldc3fxne.jpeg"></p><br><p>  Una de las mayores fortalezas de Julia es su capacidad de metaprogramación.  Esto le permite escribir fácilmente programas generadores de código, reduciendo efectivamente la cantidad de código que necesita escribir y mantener.  Una macro es una función que se ejecuta en tiempo de compilación y (generalmente) escupe código.  Por ejemplo: </p><br><pre> <code class="plaintext hljs">macro defa() :(a=5) end</code> </pre> <br><p>  reemplazará cualquier instancia <code>defa</code> con el código <code>a = 5</code> ( <code>:(a = 5)</code> es una <em>expresión entre comillas</em> . El código de Julia es expresiones y, por lo tanto, la metaprogramación es una colección de expresiones). </p><br><p>  Puede usar esto para construir cualquier programa complejo de Julia que desee y ponerlo en una función como un tipo de atajo realmente inteligente.  Sin embargo, a veces puede que necesite evaluar directamente el código generado.  Julia le da una función de <code>eval</code> o macro <code>@eval</code> para hacer esto.  En general, debe intentar evitar la <code>eval</code> , pero hay algunos códigos donde es necesario, por ejemplo, <a href="">mi nueva biblioteca para transferir datos entre diferentes procesos para la programación paralela</a> .   ,  ,     : </p><br><pre> <code class="plaintext hljs">@eval :(a=5)</code> </pre> <br><p>        (REPL).    ,      / .  Por ejemplo: </p><br><pre> <code class="plaintext hljs">function testeval() @eval :(a=5) return 2a+5 end</code> </pre> <br><p>     ,   <code>a</code>      REPL.   , ,       : </p><br><pre> <code class="plaintext hljs">function testeval() @eval :(a=5) b = a::Int64 return 2b+5 end</code> </pre> <br><p>  <code>b</code> —   ,     ,     , ,  ,          .     <code>eval</code>  ,    ,     <code>REPL</code> . </p><br><h3 id="nezhdanchik-4-kak-razbivat-vyrazheniya">  4:    </h3><br><p>  Julia   ,     .        :    ,    . </p><br><p>  , ?  ,   ,   .  Por ejemplo: </p><br><pre> <code class="plaintext hljs">a = 2 + 3 + 4 + 5 + 6 + 7 +8 + 9 + 10+ 11+ 12+ 13 a</code> </pre> <br><p> ,      90,     27. ?  <code>a = 2 + 3 + 4 + 5 + 6 + 7</code>   ,      <code>a = 27</code> ,     <code>+8 + 9 + 10+ 11+ 12+ 13</code> ,   ,    ,    : </p><br><pre> <code class="plaintext hljs">a = 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10+ 11+ 12+ 13</code> </pre> <br><p>   90,   .         ,   . </p><br><blockquote>              .   —     ,       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">rssdev10</a> </blockquote><p>       .  Por ejemplo: </p><br><pre> <code class="plaintext hljs">x = rand(2,2) a = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2.*x[:,1]).*sin(2.*x[:,2])./(4)] b = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) - sin(2.*x[:,1]).*sin(2.*x[:,2])./(4)]</code> </pre> <br><p>     ,  a  b —     ,    !    (2,2) ,   — (1-)   2.  ,   ,    : </p><br><pre> <code class="plaintext hljs">a = [1 -2] b = [1 - 2]</code> </pre> <br><p>      : <code>1</code>  <code>-2</code> .    : <code>1-2</code> .  -     .    : </p><br><pre> <code class="plaintext hljs">a = [1 2 3 -4 2 -3 1 4]</code> </pre> <br><p>    2x4.   ,    .      :        <code>hcat</code> : </p><br><pre> <code class="plaintext hljs">a = hcat(cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi),-sin(2.*x[:,1]).*sin(2.*x[:,2])./(4))</code> </pre> <br><p>  ! </p><br><h3 id="podvodnyy-kamen-5-predstavleniya-kopirovanie-i-glubokaya-kopiya">   №5: ,     </h3><br><p><img src="https://habrastorage.org/webt/wh/xj/8f/whxj8fg_es5hmuoky6ixtzneat0.jpeg"></p><br><blockquote> <strong> (View)</strong> —  () ,     (  ),        . <br><br>       ,       ,   .       ,    .            ,     . </blockquote><p>         —   "". ""     <code></code>    ,     . ""  —      (    ).    (  <em>()</em> ) . ,     : </p><br><pre> <code class="plaintext hljs">a = [3;4;5] b = a b[1] = 1</code> </pre> <br><p>     ,  <code>a</code> —   <code>[1; 4; 5]</code> , . .  <code>b</code>  <code>a</code> .   ,  <code>b = a</code>   <code>b</code>   <code>a</code> .         , ,    <code>b</code> ,    ,          (   <code>b</code>  <code>a</code> ).   ,            . ,        , : </p><br><pre> <code class="plaintext hljs">a = rand(2,2) # Makes a random 2x2 matrix b = vec(a) # Makes a view to the 2x2 matrix which is a 1-dimensional array</code> </pre> <br><p>  <code>b</code>  ,   <code>b</code>    <code>a</code> ,  <code>b</code>    .  ,       ,        ( ,         ).   .  ,          .  Por ejemplo: </p><br><pre> <code class="plaintext hljs">c = a[1:2,1]</code> </pre> <br><p>        <code></code> ( ,  <code>c</code>   <code>a</code> ).     ,   ,      ,   ,   .  ,        , : </p><br><pre> <code class="plaintext hljs">d = @view a[1:2,1] e = view(a,1:2,1)</code> </pre> <br><p>  <code>d</code> ,  <code>e</code> —     ,   <code>d</code>  <code>e</code>  <code>a</code> ,       ,     ,       <code></code> . ( ,   , —  <code>reshape</code> ,     .)     ,   .  Por ejemplo: </p><br><pre> <code class="plaintext hljs">a[1:2,1] = [1;2]</code> </pre> <br><p>  <code>a</code> ,      <code>a[1:2,1]</code>   <code>view (a, 1:2,1)</code> ,      ,   <code>a</code> .   -? ,     : </p><br><pre> <code class="plaintext hljs">b = copy(a)</code> </pre> <br><p> ,  <code>b</code>   <code>a</code> ,   ,  <code>b</code>   <code>a</code> .     <code>a</code> ,    <code>copy! (B, a)</code>  ,           <code>a</code>   <code>a</code> (   ,  <code>b</code>       ).        . , <code>Vector {Vector}</code> : </p><br><pre> <code class="plaintext hljs">a = [ [1, 2, 3], [4, 5], [6, 7, 8, 9] ]</code> </pre> <br><p>   <code></code>  .  ,   ? </p><br><pre> <code class="plaintext hljs">b = copy(a) b[1][1] = 10 a</code> </pre> <br><pre> <code class="plaintext hljs">3-element Array{Array{Int64,1},1}: [10, 2, 3] [4, 5] [6, 7, 8, 9]</code> </pre> <br><p>  ,     <code>a[1][1]</code>  10!   ?   <code>copy</code>    <code>a</code> .   <code>a</code>  ,         <code>b</code> ,  <code>b</code>      .   ,  <code>deepcopy</code> : </p><br><pre> <code class="plaintext hljs">b = deepcopy(a)</code> </pre> <br><p>      ,     .  ,         ,      . </p><br><h3 id="golovnaya-bol-6-vremennye-raspredeleniya-vektorizaciya-i-funkcii-in-place">   №6:  ,    In-Place </h3><br><p>  <em>MATLAB / Python / R</em>    .  Julia , , ,  "  ".    <code> </code> (. .    ,   , ,   ,        ).               (in-place),   .       ?  in-place ( <em>mutable function</em> ) —  ,   ,    .       ,                 . ,   : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] for i = 1:10 x = x + inner(x) end return x end function inner(x) return 2x end</code> </pre> <br><p>   ,   <code>inner</code> ,     ,    <code>2x</code> . ,       .  ,       - <code>y</code> ,      : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] y = Vector{Int64}(3) for i = 1:10 inner(y,x) for i in 1:3 x[i] = x[i] + y[i] end copy!(y,x) end return x end function inner!(y,x) for i=1:3 y[i] = 2*x[i] end nothing end</code> </pre> <br><p>  . <code>inner!(y, x)</code>   ,   <code>y</code> .  <code>y</code>  ,  <code>y</code>     , ,       , <code>inner! (y, x)</code>  <code></code>   <code></code> . ,   ,  mutable (,  "").     <code>!</code>      (   ). </p><br><p>  ,   <code>inner!(y, x)</code>   .    <code>copy!(y, x)</code> —   ,    <code>x</code>  <code>y</code> ,  .  ,  ,       .    :    <code>x</code>     <code>y</code> .       ,   <code>x + inner(x)</code> , ,  ,      11 .     ,     . </p><br><p> ,     ,    ,     .  -     ( <em>loop-fusion</em> ).   Julia v0.5    <code>.</code>      (    ( <em>broadcast</em> ),         <code></code> ).  ,  <code>f.(x)</code> —    ,   <code>f</code>    <code>x</code> ,   ,   .     <code>f</code>  <code>x</code>    ,  <code>x = x + f. (x)</code>   .          : </p><br><pre> <code class="plaintext hljs">x .= x .+ f.(x)</code> </pre> <br><p> <code>.=</code>    ,   ,  ,   </p><br><pre> <code class="plaintext hljs">for i = 1:length(x) x[i] = x[i] + f(x[i]) end</code> </pre> <br><p>  ,       : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] for i = 1:10 x .= x .+ inner.(x) end return x end function inner(x) return 2x end</code> </pre> <br><p>         <em>MATLAB / R / Python</em> ,        , ,  .      <code>  </code> ,     ,  <em>C / Fortran</em> . </p><br><h3 id="vyvod-vyuchite-pravila-poymite-ih-i-kataytes-kak-syr-v-masle"> :  ,         </h3><br><p>   :     ,   .   ,      .  ,        .   ,     ,     .     ,    . </p><br><p>    -   ,      <em>C / Fortran</em> ,           .    -  ,        ,   ! </p><br><p>   :     ?  ,       .  ,  ,       ? [    ,   Javascript   <code>var x = 3</code>  <code>x</code> ,  <code>x = 3</code>  <code>x</code> .    ?     , -       Javascript!] </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443484/">https://habr.com/ru/post/443484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443472/index.html">¿Tienes un problema para ir a la nube? 7 consejos sobre cómo no equivocarte</a></li>
<li><a href="../443476/index.html">Cómo SimCity inspiró a toda una generación de urbanistas</a></li>
<li><a href="../443478/index.html">Datos de prueba sintéticos vs reales: pros, contras, trampas</a></li>
<li><a href="../443480/index.html">Fichas criptográficas PKCS # 11: ver y exportar certificados, verificar su validez</a></li>
<li><a href="../443482/index.html">AIOps en la práctica: ¿qué puede hacer Huawei FabricInsight?</a></li>
<li><a href="../443486/index.html">ReLEx SMILE: cómo no cometer errores en las previsiones</a></li>
<li><a href="../443488/index.html">Componentes funcionales con ganchos de reacción. ¿Por qué son mejores?</a></li>
<li><a href="../443490/index.html">¿Por qué estoy reduciendo mi trabajo en Debian?</a></li>
<li><a href="../443492/index.html">Un juego para amantes y expertos en Linux</a></li>
<li><a href="../443494/index.html">Guía: Cómo lanzar un producto SaaS en AppSumo: éxitos y algunos errores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>