<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖøÔ∏è üöâ üóº 5 Common-Sense-Prinzipien zum Erstellen von Cloud-nativen Apps üöÇ ‚úåüèª üë®‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cloud-basierte (Cloud-native) oder einfach nur Cloud-Anwendungen werden speziell f√ºr die Verwendung in Cloud-Infrastrukturen erstellt. Normalerweise w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 Common-Sense-Prinzipien zum Erstellen von Cloud-nativen Apps</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/455024/">  Cloud-basierte (Cloud-native) oder einfach nur Cloud-Anwendungen werden speziell f√ºr die Verwendung in Cloud-Infrastrukturen erstellt.  Normalerweise werden sie als eine Reihe von lose gekoppelten Mikrodiensten erstellt, die in Containern verpackt sind, die wiederum von einer Cloud-Plattform verwaltet werden.  Solche Anwendungen sind standardm√§√üig f√ºr Ausf√§lle bereit, was bedeutet, dass sie zuverl√§ssig funktionieren und auch bei schwerwiegenden Ausf√§llen auf Infrastrukturebene skaliert werden k√∂nnen.  Die Kehrseite der Medaille sind die Einschr√§nkungen (Vertr√§ge), die die Cloud-Plattform Containeranwendungen auferlegt, um sie automatisch verwalten zu k√∂nnen. <br><br><img src="https://habrastorage.org/webt/i4/jg/_8/i4jg_8cdsmt7yazeyaz_e2lclmo.png" width="100%"><br><br>  Viele Unternehmen sind sich der Notwendigkeit und Wichtigkeit der Umstellung auf Cloud-Anwendungen bewusst und wissen immer noch nicht, wo sie anfangen sollen.  In diesem Beitrag werden wir eine Reihe von Prinzipien betrachten, deren Einhaltung bei der Entwicklung von Containeranwendungen das Potenzial von Cloud-Plattformen erkennt und einen zuverl√§ssigen Betrieb und eine zuverl√§ssige Skalierung von Anwendungen erm√∂glicht, selbst bei schwerwiegenden Ausf√§llen auf der Ebene der IT-Infrastruktur.  Das ultimative Ziel der hier beschriebenen Prinzipien ist es, zu lernen, wie Anwendungen erstellt werden, die automatisch von Cloud-Plattformen wie Kubernetes verwaltet werden k√∂nnen. <br><a name="habracut"></a><br><h3>  Prinzipien des Software-Designs </h3><br>  In der Welt der Programmierung werden Prinzipien als ziemlich allgemeine Regeln verstanden, die bei der Entwicklung von Software beachtet werden m√ºssen.  Sie k√∂nnen bei der Arbeit mit jeder Programmiersprache verwendet werden.  Jedes Prinzip hat seine eigenen Ziele, die Vorlagen und Praktiken dienen normalerweise als Instrument f√ºr ihre Erreichung.  Es gibt auch eine Reihe grundlegender Prinzipien f√ºr die Erstellung hochwertiger Software, aus denen alle anderen hervorgehen.  Hier einige Beispiele f√ºr Grundprinzipien: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KISS</a> (halte es einfach, dumm) - mach es nicht kompliziert; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DRY</a> (Wiederhole dich nicht) - wiederhole nicht; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YAGNI</a> (Du wirst es nicht brauchen) - erschaffe nichts, in dem es keine unmittelbare Notwendigkeit gibt; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SoC</a> (Trennung von Bedenken) - um Verantwortlichkeiten zu teilen. </li></ul><br>  Wie Sie sehen k√∂nnen, legen diese Prinzipien keine spezifischen Regeln fest, sondern geh√∂ren zur Kategorie der sogenannten √úberlegungen zum gesunden Menschenverstand, die auf praktischen Erfahrungen vieler Entwickler beruhen und auf die sie sich regelm√§√üig beziehen. <br>  Dar√ºber hinaus gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SOLID</a> - eine Reihe der ersten f√ºnf Prinzipien der objektorientierten Programmierung und Gestaltung, die von Robert Martin formuliert wurden.  SOLID enth√§lt erg√§nzende Prinzipien, die verallgemeinert und offen f√ºr Interpretationen sind und - wenn sie in Kombination angewendet werden - dazu beitragen, bessere Softwaresysteme zu erstellen und diese langfristig besser zu unterst√ºtzen. <br><br>  SOLID-Prinzipien gelten f√ºr OOP und werden in Form von Konzepten und Konzepten wie Klassen, Schnittstellen und Vererbung formuliert.  Analog dazu k√∂nnen Sie f√ºr Cloud-Anwendungen auch die Entwicklungsprinzipien formulieren. Nur das Grundelement ist hier keine Klasse, sondern ein Container.  Nach diesen Grunds√§tzen k√∂nnen Sie containerisierte Anwendungen erstellen, die die Ziele von Cloud-Plattformen wie Kubernetes besser erf√ºllen. <br><br><h3>  Cloud-basierte Container: Red Hat-Ansatz </h3><br>  Heutzutage ist fast jede Anwendung relativ einfach in Beh√§lter zu verpacken.  Damit Anwendungen innerhalb einer Cloud-Plattform wie Kubernetes effizient automatisiert und orchestriert werden k√∂nnen, ist jedoch zus√§tzlicher Aufwand erforderlich. <br>  Die unten vorgestellten Ideen basierten auf der Methodik der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zw√∂lf-Faktoren-App</a> und vielen anderen Arbeiten zu verschiedenen Aspekten der Erstellung von Webanwendungen, von der Quellcodeverwaltung bis hin zu Skalenmodellen.  Die beschriebenen Prinzipien gelten nur f√ºr die Entwicklung von Containeranwendungen, die auf Microservices basieren und f√ºr Cloud-Plattformen wie Kubernetes konzipiert sind.  Das Grundelement unserer Diskussion ist das Image des Containers, und die Laufzeit des Zielcontainers ist die Container-Orchestrierungsplattform.  Der Zweck der vorgeschlagenen Prinzipien besteht darin, Container zu erstellen, f√ºr die Sie auf den meisten Orchestrierungsplattformen Planungsaufgaben (Planung - Auswahl eines Hosts zum Ausf√ºhren der Containerinstanz), Skalierung und √úberwachung automatisieren k√∂nnen.  Die Prinzipien sind in zuf√§lliger Reihenfolge aufgef√ºhrt. <br><br><h3>  Single Concern Principle (SCP) </h3><br>  Dieses Prinzip √§hnelt in vielerlei Hinsicht dem Single Responsibility Principle ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SRP</a> ), das Teil der SOLID-Suite ist und besagt, dass jedes Objekt eine Verantwortung haben muss und diese Verantwortung vollst√§ndig in der Klasse enthalten sein muss.  Das Wesentliche an SRP ist, dass jede Pflicht ein Grund f√ºr √Ñnderungen ist und eine Klasse nur einen Grund f√ºr √Ñnderungen haben muss. <br><br>  In SCP verwenden wir anstelle des Wortes "Verantwortung" das Wort "Anliegen", um eine h√∂here Abstraktionsebene und einen breiteren Zweck des Containers im Vergleich zur OOP-Klasse anzuzeigen.  Und wenn das Ziel von SRP darin besteht, nur einen Grund f√ºr √Ñnderungen zu haben, m√∂chte SCP die M√∂glichkeiten zur Wiederverwendung und zum Austausch von Containern erweitern.  Indem Sie SRP folgen und einen Container erstellen, der eine einzelne Aufgabe l√∂st und funktionsf√§hig macht, erh√∂hen Sie die Wahrscheinlichkeit, dass das Image dieses Containers in verschiedenen Anwendungskontexten wiederverwendet wird. <br><br>  Das Prinzip von SCP besagt, dass jeder Container eine einzelne Aufgabe l√∂sen und gut erledigen sollte.  Dar√ºber hinaus ist SCP in der Welt der Container einfacher zu erreichen als SRP in der Welt der OOP, da Container normalerweise einen einzigen Prozess ausf√ºhren und dieser Prozess meistens eine einzige Aufgabe l√∂st. <br><br>  Wenn ein Container-Mikroservice mehrere Probleme gleichzeitig l√∂sen muss, kann er in Einzelaufgabencontainer unterteilt und mithilfe von Seitenwagenvorlagen und Init-Containern zu einem Pod (Einheit zum Bereitstellen einer Containerplattform) zusammengef√ºhrt werden.  Dar√ºber hinaus macht es SCP einfach, einen alten Container (z. B. einen Webserver oder einen Nachrichtenbroker) durch einen neuen zu ersetzen, der das gleiche Problem l√∂st, jedoch √ºber verbesserte Funktionen verf√ºgt oder besser skaliert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/4j/3o/ud4j3okts2jt7hdfr68-tdjlkw4.png"></div><br><br><h3>  Prinzip der Bequemlichkeit der √úberwachung (High Observability Principle, HOP) </h3><br>  Wenn Container als einheitliche Methode zum Verpacken und Starten von Anwendungen verwendet werden, werden die Anwendungen selbst als ‚ÄûBlack Box‚Äú betrachtet.  Wenn es sich jedoch um Cloud-Container handelt, m√ºssen sie der Laufzeit spezielle APIs zur Verf√ºgung stellen, um den Zustand der Container zu √ºberwachen und gegebenenfalls geeignete Ma√ünahmen zu ergreifen.  Ohne dies ist es nicht m√∂glich, die Automatisierung der Aktualisierung von Containern und die Verwaltung ihres Lebenszyklus zu vereinheitlichen, was wiederum die Stabilit√§t und Benutzerfreundlichkeit des Softwaresystems verschlechtert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/_y/lh/nm_ylhsfix0alpq7uwqmjy8smf0.png"></div><br>  In der Praxis sollte eine Containeranwendung mindestens eine API f√ºr verschiedene Arten von Gesundheitspr√ºfungen haben: Lebendigkeitstests und Bereitschaftstests.  Wenn der Antrag behauptet, mehr zu sein, sollte er andere Mittel zur √úberwachung seines Zustands bereitstellen.  Protokollieren Sie beispielsweise wichtige Ereignisse √ºber STDERR und STDOUT, um Protokolle mit Fluentd, Logstash und anderen √§hnlichen Tools zu aggregieren.  Sowie die Integration in Trace- und Sammlungsbibliotheken von Metriken wie OpenTracing, Prometheus usw. <br><br>  Im Allgemeinen kann die Anwendung immer noch als ‚ÄûBlack Box‚Äú betrachtet werden, muss jedoch gleichzeitig mit allen APIs ausgestattet sein, die die Plattform ben√∂tigt, um sie optimal √ºberwachen und verwalten zu k√∂nnen. <br><br><h3>  Lebenszyklus-Konformit√§tsprinzip (LCP) </h3><br>  LCP ist das Gegenteil von HOP.  Wenn die HOP angibt, dass der Container der Plattform APIs zum Lesen bereitstellen muss, muss die Anwendung f√ºr LCP Informationen von der Plattform empfangen k√∂nnen.  Dar√ºber hinaus sollte der Container Ereignisse nicht nur empfangen, sondern auch anpassen, dh darauf reagieren.  Daher der Name des Prinzips, der als Voraussetzung f√ºr die Bereitstellung von APIs zum Schreiben f√ºr die Plattform angesehen werden kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bd/3s/p8/bd3sp8v4heoylqg4rzjmk5oiyue.png"></div><br>  Plattformen verf√ºgen √ºber verschiedene Arten von Ereignissen, mit denen der Lebenszyklus des Containers verwaltet werden kann.  Es liegt jedoch an der Anwendung, zu entscheiden, welche von ihnen wahrgenommen werden sollen und wie sie reagieren sollen. <br><br>  Es ist klar, dass einige Ereignisse wichtiger sind als andere.  Wenn eine Anwendung beispielsweise kein Herunterfahren im Notfall toleriert, muss sie Signal: Terminate (SIGTERM) -Nachrichten akzeptieren und den Beendigungsvorgang so bald wie m√∂glich einleiten, um das nach SIGTERM kommende Signal: Kill (SIGKILL) abzufangen. <br><br>  Dar√ºber hinaus k√∂nnen Ereignisse wie PostStart und PreStop f√ºr den Anwendungslebenszyklus wichtig sein.  Nach dem Starten der Anwendung kann es beispielsweise einige Zeit dauern, bis sie ‚Äûaufgew√§rmt‚Äú ist, bevor sie auf Anforderungen reagieren kann.  Oder die Anwendung muss beim Herunterfahren Ressourcen freigeben. <br><br><h3>  Das Prinzip der Unver√§nderlichkeit des Beh√§lterbildes (Image Immutability Principle, IIP) </h3><br>  Es ist allgemein anerkannt, dass containerisierte Anwendungen nach dem Zusammenbau unver√§ndert bleiben m√ºssen, auch wenn sie in verschiedenen Umgebungen ausgef√ºhrt werden.  Dies impliziert die Notwendigkeit, den Datenspeicher zur Laufzeit zu externalisieren (dh externe Tools zu verwenden) und sich auf externe Konfigurationen zu verlassen, die f√ºr eine bestimmte Laufzeitumgebung konfiguriert sind, anstatt eindeutige Container f√ºr jede Umgebung zu √§ndern oder zu erstellen.  Nach √Ñnderungen an der Anwendung muss das Container-Image in allen verwendeten Umgebungen neu zusammengesetzt und bereitgestellt werden.  √úbrigens wird bei der Verwaltung von IT-Systemen ein √§hnliches Prinzip verwendet, das als Prinzip der Unver√§nderlichkeit von Servern und Infrastruktur bekannt ist. <br><br>  Das Ziel von IIP ist es, die Erstellung separater Container-Images f√ºr verschiedene Laufzeitumgebungen zu verhindern und √ºberall dasselbe Image zusammen mit der entsprechenden Konfiguration f√ºr eine bestimmte Umgebung zu verwenden.  Das Befolgen dieses Prinzips erm√∂glicht es Ihnen, so wichtige Vorgehensweisen im Hinblick auf die Automatisierung von Cloud-Systemen wie das Zur√ºcksetzen und Zur√ºcksetzen von Anwendungsaktualisierungen zu implementieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hl/rr/t9/hlrrt9r4lw4f7wcik19j3o5zmou.png"></div><br><h3>  Process Disposability Principle (PDP) </h3><br>  Eines der wichtigsten Merkmale eines Containers ist seine Verg√§nglichkeit: Eine Containerinstanz kann leicht erstellt und leicht zerst√∂rt werden, sodass sie jederzeit leicht durch eine andere Instanz ersetzt werden kann.  Es kann viele Gr√ºnde f√ºr einen solchen Austausch geben: Fehler beim Zustandstest, Anwendungsskalierung, Portierung auf einen anderen Host, Ersch√∂pfung der Plattformressourcen oder andere Situationen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tk/qw/lq/tkqwlqu9-qyusgg6n-wpgl0hxks.png"></div><br>  Infolgedessen m√ºssen Containeranwendungen ihren Status mit externen Mitteln beibehalten oder daf√ºr interne verteilte Schaltkreise mit Redundanz verwenden.  Dar√ºber hinaus sollte die Anwendung schnell gestartet und schnell heruntergefahren werden und auf einen pl√∂tzlichen schwerwiegenden Hardwarefehler vorbereitet sein. <br><br>  Eine Praxis, die zur Umsetzung dieses Prinzips beitr√§gt, besteht darin, kleine Container zu erstellen.  Cloud-Umgebungen k√∂nnen automatisch einen Host zum Starten einer Containerinstanz ausw√§hlen. Je kleiner der Container, desto schneller wird er gestartet. Er wird einfach schneller √ºber das Netzwerk auf den Zielhost kopiert. <br><br><h3>  Selbstbeherrschungsprinzip (S-CP) </h3><br>  Nach diesem Prinzip sind bei der Montage alle notwendigen Komponenten im Beh√§lter enthalten.  Der Container sollte in der Erwartung erstellt werden, dass das System nur einen sauberen Linux-Kernel hat, sodass alle erforderlichen zus√§tzlichen Bibliotheken im Container selbst abgelegt werden m√ºssen.  Dort sollten sich auch Dinge befinden, wie die Laufzeit f√ºr die entsprechende Programmiersprache, die Anwendungsplattform (falls erforderlich) und andere Abh√§ngigkeiten, die w√§hrend des Betriebs der Containeranwendung erforderlich sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p7/ia/qb/p7iaqbxksacennpuyk5vvhzdnw4.png"></div><br><br>  Ausnahmen werden nur f√ºr Konfigurationen gemacht, die von Umgebung zu Umgebung variieren und zur Laufzeit bereitgestellt werden sollten, beispielsweise √ºber Kubernetes ConfigMap. <br><br>  Eine Anwendung kann mehrere containerisierte Komponenten enthalten, z. B. einen separaten DBMS-Container als Teil einer Webcontaineranwendung.  Nach dem S-CP-Prinzip sollten diese Container nicht zu einem zusammengefasst werden, sondern so erstellt werden, dass der DBMS-Container alles enth√§lt, was f√ºr das Funktionieren der Datenbank erforderlich ist, und der Webanwendungscontainer alles enth√§lt, was f√ºr das Funktionieren der Webanwendung erforderlich ist, denselben Webserver .  Daher h√§ngt der Webanwendungscontainer zur Laufzeit vom DBMS-Container ab und greift bei Bedarf darauf zu. <br><br><h3>  Runtime Confinement Principle (RCP) </h3><br>  Das S-CP-Prinzip definiert, wie ein Container zusammengesetzt werden soll und was eine Bin√§rbilddatei enthalten soll.  Ein Container ist jedoch nicht nur eine ‚ÄûBlack Box‚Äú, die nur ein Merkmal aufweist - die Dateigr√∂√üe.  Zur Laufzeit erh√§lt der Container andere Dimensionen: den verwendeten Speicher, die Prozessorzeit und andere Systemressourcen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e5/v5/vb/e5v5vbk3witcr7oe1bgs23forks.png"></div><br>  Und hier ist das RCP-Prinzip n√ºtzlich, wonach der Container seine Anforderungen an Systemressourcen enthaupten und auf die Plattform √ºbertragen muss.  Mit den Ressourcenprofilen jedes Containers (wie viel CPU-, Speicher-, Netzwerk- und Festplattensystemressourcen ben√∂tigt werden) kann die Plattform die Planung und automatische Skalierung optimal durchf√ºhren, IT-Kapazit√§ten verwalten und SLA-Ebenen f√ºr Container unterst√ºtzen. <br><br>  Neben der Erf√ºllung der Ressourcenanforderungen des Containers ist es auch wichtig, dass die Anwendung nicht √ºber das von ihr festgelegte Framework hinausgeht.  Andernfalls wird die Plattform bei Ressourcenknappheit eher in die Liste der Anwendungen aufgenommen, die unterbrochen oder migriert werden m√ºssen. <br><br>  Wenn wir √ºber den Fokus auf die Cloud sprechen, meinen wir in erster Linie die Art und Weise, wie wir arbeiten. <br>  Oben haben wir eine Reihe allgemeiner Prinzipien formuliert, die die methodische Grundlage f√ºr die Erstellung hochwertiger Containeranwendungen f√ºr Cloud-Umgebungen bilden. <br><br>  Beachten Sie, dass Sie zus√§tzlich zu diesen allgemeinen Prinzipien zus√§tzliche fortgeschrittene Methoden und Techniken f√ºr die Arbeit mit Containern ben√∂tigen.  Dar√ºber hinaus haben wir einige kurze Empfehlungen, die spezifischer sind und je nach Situation angewendet (oder nicht angewendet) werden sollten: <br><br><ul><li>  Versuchen Sie, die Gr√∂√üe der Bilder zu verringern: L√∂schen Sie tempor√§re Dateien und legen Sie keine unn√∂tigen Pakete ab. Je kleiner der Container, desto schneller wird er gesammelt und √ºber das Netzwerk auf den Zielhost kopiert. </li><li>  Konzentrieren Sie sich auf beliebige Benutzer-IDs: Verwenden Sie nicht den Befehl sudo oder eine spezielle Benutzer-ID, um Ihre Container auszuf√ºhren. </li><li>  Beschriften Sie wichtige Ports: Portnummern k√∂nnen auch zur Laufzeit festgelegt werden. Es ist jedoch besser, sie mit dem Befehl EXPOSE anzugeben. F√ºr andere Personen und Programme ist es einfacher, Ihre Bilder zu verwenden. </li><li>  Behalten Sie persistente Daten auf Volumes bei: Daten, die nach der Zerst√∂rung des Containers verbleiben m√ºssen, sollten auf Volumes geschrieben werden. </li><li>  Schreiben Sie Bildmetadaten: Tags, Beschriftungen und Anmerkungen erleichtern die Verwendung von Bildern - andere Entwickler sind dankbar. </li><li>  Synchronisieren des Hosts und der Images: Bei einigen Containeranwendungen muss der Container anhand bestimmter Attribute wie Zeit oder Maschinen-ID mit dem Host synchronisiert werden. </li><li>  Abschlie√üend teilen wir Vorlagen und Best Practices, die dazu beitragen, die oben genannten Prinzipien effektiver umzusetzen: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.slideshare.net/luebken/container-patterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.projectatomic.io/container-best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.openshift.com/enterprise/3.0/creating_images/guidelines.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">leanpub.com/k8spatterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">12factor.net</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Webinar zur neuen Version von OpenShift Container Platform - 4</b></a> <br>  11. Juni um 11.00 Uhr <br><br>  Was Sie lernen werden: <br><br><ul><li>  Unver√§nderliches Red Hat Enterprise Linux CoreOS </li><li>  Open-Shift-Service-Mesh </li><li>  Operator Framework </li><li>  Knativer Rahmen </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455024/">https://habr.com/ru/post/de455024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455010/index.html">Asynchrone Benutzerskripte in reinem Rust ohne Frameworks und SMS</a></li>
<li><a href="../de455012/index.html">H√§ufig gestellte Fragen zum zellul√§ren Abfangen: Was sind IMSI-Abfangj√§ger / SCATs und kann ich mich vor ihnen sch√ºtzen?</a></li>
<li><a href="../de455016/index.html">Wir erstellen die unzug√§nglichste Website mit einer idealen Bewertung Leuchtturm</a></li>
<li><a href="../de455018/index.html">Der Posten der gro√üen Liebe f√ºr kleine Unternehmen</a></li>
<li><a href="../de455020/index.html">Vor- und Nachteile der Verwendung von Flutter f√ºr die mobile Entwicklung</a></li>
<li><a href="../de455026/index.html">Telefonie mit Snom: f√ºr diejenigen, die zu Hause arbeiten</a></li>
<li><a href="../de455030/index.html">PHP-Spezifikationen</a></li>
<li><a href="../de455032/index.html">Kein Fehler, sondern ein Merkmal: eine Untersuchung der Motilit√§t und Gehirnaktivit√§t einer Person mit Polydaktylie</a></li>
<li><a href="../de455038/index.html">Wie Plesk die KubeCon besucht hat</a></li>
<li><a href="../de455040/index.html">Verbesserung der Arbeit von Wi-Fi. Teil 2. Ausstattungsmerkmale</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>