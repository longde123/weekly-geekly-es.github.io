<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ò üéà üñïüèº System.IO.Pipelines: una herramienta poco conocida para los amantes del alto rendimiento üíá üçΩÔ∏è üîë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola lector Ha pasado mucho tiempo desde el lanzamiento de .NET Core 2.1. Y las innovaciones tan geniales como Span y Memory ya se han considerado amp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines: una herramienta poco conocida para los amantes del alto rendimiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464921/">  Hola lector  Ha pasado mucho tiempo desde el lanzamiento de .NET Core 2.1.  Y las innovaciones tan geniales como Span y Memory ya se han considerado ampliamente, puede leer, ver y escuchar mucho sobre ellas.  Sin embargo, desafortunadamente, una biblioteca llamada System.IO.Pipelines no recibi√≥ la misma atenci√≥n.  Casi todo lo que se trata sobre este tema es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫nica publicaci√≥n</a> que muchos han traducido y publicado en casa.  Definitivamente deber√≠a haber m√°s informaci√≥n para que los interesados ‚Äã‚Äãpuedan ver la tecnolog√≠a desde diferentes √°ngulos. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  Por lo tanto, esta biblioteca tiene como objetivo acelerar el trabajo con el procesamiento de datos de transmisi√≥n.  Originalmente fue creado y utilizado por el equipo de desarrollo de Kestrel (un servidor web multiplataforma para ASP.NET Core), pero actualmente se entrega a trav√©s de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete nuget</a> separado. <br>  Antes de profundizar en el tema, podemos imaginar el mecanismo de la biblioteca como un an√°logo mejorado de MemoryStream.  El problema con el MemoryStream original es un n√∫mero excesivo de copias, lo cual es obvio si recuerda que una matriz de bytes privada se usa dentro como un b√∫fer.  Por ejemplo, en los m√©todos de <a href="">lectura</a> y <a href="">escritura</a> , la copia es claramente visible.  Por lo tanto, para el objeto que queremos escribir en la secuencia, se crear√° una copia en el b√∫fer interno y, durante la lectura, se entregar√° una copia de la copia interna al consumidor.  Parece que no es el uso m√°s racional del espacio. <br>  System.IO.Pipelines no tiene como objetivo reemplazar todas las transmisiones, es una herramienta adicional en el arsenal de un desarrollador que escribe c√≥digo de alto rendimiento.  Le sugiero que se familiarice con los m√©todos y clases b√°sicos, vea c√≥mo est√°n organizados en su interior y analice ejemplos b√°sicos. <br><br>  Comencemos con el dispositivo interno, al mismo tiempo examinando fragmentos de c√≥digo simples.  Despu√©s de eso, quedar√° claro qu√© y c√≥mo funciona, y c√≥mo debe usarse.  Cuando trabaje con System.IO.Pipelines, vale la pena recordar que el concepto b√°sico es que todas las operaciones de lectura-escritura deben realizarse sin asignaciones adicionales.  Pero algunos m√©todos que son atractivos a primera vista contradicen esta regla.  En consecuencia, el c√≥digo que est√° tratando de acelerar comienza a asignar memoria para datos nuevos y nuevos, cargando el recolector de basura. <br><br>  La biblioteca interna de la biblioteca utiliza las posibilidades m√°s amplias de las √∫ltimas versiones del idioma y el intervalo de tiempo, Span, Memoria, agrupaciones de objetos, ValueTask, etc.  Vale la pena ver, al menos, un gran ejemplo del uso de estas funciones en producci√≥n. <br>  Hubo un tiempo en que algunos no estaban contentos con la implementaci√≥n de secuencias en C #, porque una clase se usaba tanto para leer como para escribir.  Pero, como dicen, no puedes tirar m√©todos fuera de una clase.  Incluso si la transmisi√≥n no admit√≠a leer / escribir / mover el puntero, las propiedades CanRead, CanWrite y CanSeek entraron en vigencia, lo que parec√≠a una peque√±a muleta.  Aqu√≠ las cosas son diferentes. <br>  Para trabajar con tuber√≠as, se utilizan 2 clases: <a href="">PipeWriter</a> y <a href="">PipeReader</a> .  Estas clases contienen aproximadamente 50 l√≠neas cada una y son pseudo-fachadas (no sus encarnaciones m√°s cl√°sicas, ya que hay una sola clase oculta detr√°s de ellas, y no muchas) para la clase <a href="">Pipe</a> , que contiene toda la l√≥gica b√°sica para trabajar con datos.  De los miembros p√∫blicos, 2 constructores, 2 propiedades de solo obtenci√≥n: Reader y Writer, el m√©todo Reset (), que restablece los campos internos a su estado inicial para que la clase pueda reutilizarse.  Otros m√©todos de trabajo se llaman utilizando pseudo-fachadas. <br><br><h2>  Para comenzar en la clase Pipe </h2><br>  La instancia de clase ocupa 320 bytes, que es bastante (casi un tercio de kilobyte, 2 de esos objetos no cab√≠an en la memoria de Manchester Mark I).  Por lo tanto, asignarlo en grandes cantidades es una mala idea.  Adem√°s, el significado del objeto est√° destinado a un uso a largo plazo.  El uso de grupos tambi√©n hace un argumento para esta declaraci√≥n.  Despu√©s de todo, los objetos utilizados en el grupo vivir√°n para siempre (en cualquier caso, en el est√°ndar). <br>  Tenga en cuenta que la clase est√° marcada como sellada y que es segura para subprocesos: muchas secciones del c√≥digo son una secci√≥n cr√≠tica y est√°n envueltas en bloqueos. <br>  Para comenzar, debe crear una instancia de la clase Pipe y obtener los objetos PipeReader y PipeWriter utilizando las propiedades mencionadas. <br><br><div class="spoiler">  <b class="spoiler_title">F√°cil inicializaci√≥n</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Considere los m√©todos para trabajar con tuber√≠as: <br>  Para grabar a trav√©s de PipeWriter: WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Complete, CancelPendingFlush, OnReaderCompleted. <br>  Para leer a trav√©s de PipeReader: AdvanceTo, ReadAsync, TryRead, Complete, CancelPendingRead, OnWriterCompleted. <br><br>  Como se indica en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la publicaci√≥n</a> , la clase utiliza una lista de b√∫feres vinculada individualmente.  Pero, obviamente, no se pasan entre PipeReader y PipeWriter: toda la l√≥gica est√° en una clase.  Esta lista se usa tanto para leer como para escribir.  Adem√°s, los datos devueltos se almacenan en esta lista. <br>  Tambi√©n hay objetos que indican el comienzo de los datos para leer (ReadHead e index), el final de los datos para leer (ReadTail e index) y el comienzo del lugar para escribir (WriteHead y la cantidad de bytes almacenados en buffer).  Aqu√≠ ReadHead, ReadTail y WriteHead son un segmento espec√≠fico de la lista, y el √≠ndice indica una posici√≥n espec√≠fica dentro del segmento.  Por lo tanto, la grabaci√≥n puede comenzar desde el medio de un segmento, capturar todo el siguiente segmento y terminar en el medio del tercero.  Estos punteros se mueven en varios m√©todos. <br><br><h2>  Comenzando con los m√©todos PipeWriter </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (fuente ReadOnlyMemory &lt;byte&gt;, CancellationToken cancellationToken)</a> </h3><br>  Solo ese m√©todo tentador.  Tiene una firma muy adecuada y moderna: acepta ReadOnlyMemory, as√≠ncrono.  Y muchos pueden sentirse tentados, especialmente recordando que Span y Memory son tan r√°pidos y geniales.  Pero no te hagas ilusiones.  Todo lo que este m√©todo hace es copiar el ReadOnlyMemory pasado a la lista interna.  Y "copiar" significa una llamada al m√©todo CopyTo, y no copiar el objeto en s√≠.  Es decir, todos los datos que queremos grabar se copiar√°n, cargando as√≠ la memoria.  Este m√©todo debe estudiarse solo para asegurarse de que es mejor no usarlo.  Bueno, y tal vez para algunas situaciones raras, este comportamiento es apropiado. <br>  El cuerpo del m√©todo es una secci√≥n cr√≠tica, el acceso al mismo se sincroniza a trav√©s de un monitor. <br><br>  Entonces puede surgir la pregunta, c√≥mo escribir algo, si no a trav√©s del m√©todo m√°s obvio y √∫nico adecuado. <br><br><h3>  # 2 <a href="">Memoria &lt;byte&gt; GetMemory (int sizeHint)</a> </h3><br>  El m√©todo toma un par√°metro de un tipo entero.  En √©l debemos indicar cu√°ntos bytes queremos escribir (o m√°s, pero en ning√∫n caso menos).  Este m√©todo verifica si hay suficiente espacio para escribir en el fragmento de memoria actual almacenado en _writingHeadMemory.  Si es suficiente, _writingHeadMemory se devuelve como Memoria.  De lo contrario, para los datos escritos en el b√∫fer, pero para los cuales no se llam√≥ al m√©todo FlushAsync, se llama y se selecciona otro BufferSegment, que est√° conectado al anterior (aqu√≠ est√° la lista).  En ausencia de _writingHeadMemory, se inicializa con un nuevo BufferSegment.  Y la asignaci√≥n del pr√≥ximo b√∫fer es una secci√≥n cr√≠tica y se realiza bajo el candado. <br>  Sugiero un vistazo a tal ejemplo.  A primera vista, puede parecer que el compilador (o tiempo de ejecuci√≥n) ha enga√±ado al demonio. <br><br><div class="spoiler">  <b class="spoiler_title">Diablo</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048  4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Pero todo en este ejemplo es comprensible y simple. <br>  Al crear una instancia de Pipe, podemos pasar un objeto <a href="">PipeOptions</a> con opciones para crearlo al constructor. <br><br>  PipeOptions tiene un campo de tama√±o m√≠nimo de segmento predeterminado.  No hace mucho tiempo era 2048, pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta confirmaci√≥n</a> cambi√≥ todo, ahora 4096. Al momento de escribir, la versi√≥n con 4096 era un paquete de prelanzamiento, en la √∫ltima versi√≥n de lanzamiento era 2048. Esto explica el comportamiento del primer ejemplo.  Si es cr√≠tico de usar un tama√±o m√°s peque√±o para el b√∫fer est√°ndar, puede especificarlo en una instancia del tipo PipeOptions. <br><br>  Pero en el segundo ejemplo, donde se indica el tama√±o m√≠nimo, la longitud no coincide de todos modos.  Y esto ya est√° sucediendo porque la creaci√≥n de un nuevo BufferSegment se produce mediante grupos.  Una de las opciones en PipeOptions es el grupo de memoria.  Despu√©s de eso, el grupo especificado se usar√° para crear un nuevo segmento.  Si no especific√≥ su grupo de memoria, se utilizar√° el ArrayPool est√°ndar, que, como sabe, tiene varios cubos para diferentes tama√±os de matrices (cada uno es 2 veces m√°s grande que el anterior) y, cuando se le solicita un tama√±o espec√≠fico, busca un cubo con matrices de tama√±o adecuado (luego existe el mayor o igual m√°s cercano).  En consecuencia, el nuevo b√∫fer seguramente ser√° m√°s grande de lo que solicit√≥.  El tama√±o m√≠nimo de matriz en el ArrayPool est√°ndar (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) es 16. Pero no se preocupe, porque se trata de un conjunto de matrices.  En consecuencia, en la gran mayor√≠a de los casos, la matriz no ejerce presi√≥n sobre el recolector de basura y se reutilizar√°. <br><br><h3>  # 2.5 <a href="">Span &lt;byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Funciona de manera similar, dando Span from Memory. <br><br>  Por lo tanto, GetMemory () o GetSpan () son los principales m√©todos para escribir.  Nos dan un objeto en el que podemos escribir.  Para hacer esto, no necesitamos asignar memoria para nuevas matrices de valores, podemos escribir directamente en la estructura interna.  Cu√°l usar depender√° principalmente de la API que est√© utilizando y del m√©todo asincr√≥nico.  Sin embargo, en vista de lo anterior, surge una pregunta.  ¬øC√≥mo sabr√° el lector cu√°nto escribimos?  Si siempre usamos una implementaci√≥n espec√≠fica del grupo, que proporciona una matriz del mismo tama√±o que el solicitado, el lector podr√≠a leer todo el b√∫fer de una vez.  Sin embargo, como ya hemos dicho, se nos asigna un b√∫fer con una alta probabilidad de un tama√±o mayor.  Esto lleva al siguiente m√©todo requerido para la operaci√≥n. <br><br><h3>  # 3 <a href="">void Advance (int bytes)</a> </h3><br>  Un m√©todo simple y terrible.  Toma el n√∫mero de bytes escritos como argumento.  Incrementan los contadores internos: _unflushedBytes y _writingHeadBytesBuffered, cuyos nombres hablan por s√≠ mismos.  Tambi√©n trunca _writingHeadMemory exactamente al n√∫mero de bytes escritos (usando el m√©todo Slice).  Por lo tanto, despu√©s de llamar a este m√©todo, debe solicitar un nuevo bloque de memoria en forma de Memoria o Span, no puede escribir en el anterior.  Y todo el cuerpo del m√©todo es una secci√≥n cr√≠tica y se ejecuta bajo un candado. <br><br>  Parece que despu√©s de esto el lector puede recibir datos.  Pero se necesita un paso m√°s. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (CancellationToken cancellationToken)</a> </h3><br>  Se llama al m√©todo despu√©s de que escribimos los datos necesarios en la Memoria recibida e indicamos cu√°nto escribimos all√≠.  El m√©todo devuelve una ValueTask, sin embargo, no es as√≠ncrona (a diferencia de su descendiente StreamPipeWriter).  ValueTask es un tipo especial (estructura de solo lectura) que se usa en el caso de que la mayor√≠a de las llamadas no usen la asincron√≠a, es decir, todos los datos necesarios estar√°n disponibles en el momento de su llamada y el m√©todo finalizar√° de forma sincr√≥nica.  En el interior, contiene datos o Tarea (en caso de que no funcion√≥ sincr√≥nicamente).  Depende del estado de la propiedad _writerAwaitable.IsCompleted.  Si buscamos qu√© cambia el estado de este objeto en espera, veremos que esto sucede bajo la condici√≥n de que la cantidad de datos no procesados ‚Äã‚Äã(no consumidos) (esto no es exactamente lo mismo que no le√≠dos (no examinados), se explicar√° m√°s adelante) excede un cierto umbral (_pauseWriterThreshold).  El valor predeterminado es 16 tama√±os de segmento.  Si lo desea, el valor se puede cambiar en PipeOptions.  Adem√°s, este m√©todo inicia la continuaci√≥n del m√©todo ReadAsync, si uno fue bloqueado. <br><br>  Devuelve un FlushResult que contiene 2 propiedades: IsCanceled e IsCompleted.  IsCanceled indica si Flush ha sido cancelado (llamada CancelPendingFlush).  IsCompleted indica si PipeReader se complet√≥ (llamando a los m√©todos Complete () o CompleteAsync ()). <br>  La parte principal del m√©todo se realiza bajo Locke Skywalker. <br><br>  Otros m√©todos de PipeWriter no son interesantes desde el punto de vista de la implementaci√≥n y se usan con mucha menos frecuencia, por lo tanto, solo se proporcionar√° una breve descripci√≥n. <br><br><h3>  # 5 void Complete (excepci√≥n de excepci√≥n = nulo) o ValueTask CompleteAsync (excepci√≥n de excepci√≥n = nulo) </h3><br>  Tubo de marcas cerrado para escritura.  Al finalizar, se lanzar√° una excepci√≥n al intentar utilizar los m√©todos para escribir.  Si PipeReader ya se ha completado, tambi√©n se completar√° toda la instancia de Pipe.  La mayor parte del trabajo se realiza bajo la cerradura. <br><br><h3>  # 6 nulo CancelPendingFlush () </h3><br>  Como su nombre lo indica, completa la operaci√≥n actual de FlushAsync ().  Hay un lok. <br><br><h3>  # 7 void OnReaderCompleted (acci√≥n &lt;excepci√≥n, objeto&gt; devoluci√≥n de llamada, estado del objeto) </h3><br>  Ejecuta el delegado delegado cuando el lector completa.  Tambi√©n hay una cerradura. <br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> actualmente dice que este m√©todo no se puede invocar en algunos descendientes de PipeWriter y se eliminar√° en el futuro.  Por lo tanto, no debe vincular la l√≥gica a estos m√©todos. <br><br><h2>  Ir a PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (token CancellationToken)</a> </h3><br>  Aqu√≠, como FlushAsync, se devuelve una ValueTask, que sugiere que el m√©todo es principalmente sincr√≥nico, pero no siempre.  Depende del estado de _readerAwaitable.  Al igual que con FlushAsync, debe encontrar cu√°ndo _readerAwaitable est√° configurado como incompleto.  Esto sucede cuando PipeReader lee todo de la lista (o contiene datos que se marcaron como examinados y necesita m√°s datos para continuar).  Lo cual, de hecho, es l√≥gico.  En consecuencia, podemos concluir que es deseable ajustar Pipe a su trabajo, establecer todas sus opciones cuidadosamente, en base a estad√≠sticas identificadas emp√≠ricamente.  La configuraci√≥n adecuada reducir√° la probabilidad de una bifurcaci√≥n de ejecuci√≥n asincr√≥nica y permitir√° un procesamiento de datos m√°s eficiente.  Casi todo el m√©todo est√° rodeado por una cerradura. <br><br>  Devuelve un misterioso <a href="">ReadResult</a> .  De hecho, es solo un b√∫fer + indicadores que muestran el estado de la operaci√≥n (IsCanceled: si ReadAsync se cancel√≥ e IsCompleted indicando si PipeWriter estaba cerrado).  En este caso, IsCompleted es un valor que indica si se llam√≥ a los m√©todos PipeWriter Complete () o CompleteAsync ().  Si se llamaron a estos m√©todos con una excepci√≥n, se lanzar√°n al intentar leer. <br><br>  El b√∫fer nuevamente tiene un tipo misterioso: <a href="">ReadOnlySequence</a> .  Esto, a su vez, es un objeto para contener <a href="">segmentos (ReadOnlySequenceSegment) de los</a> √≠ndices <a href="">de</a> inicio y fin + inicio y fin dentro de los segmentos correspondientes.  Que en realidad se asemeja a la estructura de la propia clase Pipe.  Por cierto, BufferSegment es el sucesor de ReadOnlySequenceSegment, lo que sugiere que se usa all√≠.  Gracias a esto, puede deshacerse de las asignaciones de memoria innecesarias para la transferencia de datos del escritor al lector. <br>  ReadOnlySpan se puede obtener del b√∫fer para su posterior procesamiento.  Para completar la imagen, puede verificar si el b√∫fer contiene un solo ReadOnlySpan.  Si contiene, no necesitamos iterar sobre la colecci√≥n de un elemento y podemos obtenerla usando la propiedad First.  De lo contrario, debe revisar todos los segmentos en el b√∫fer y procesar cada ReadOnlySpan. <br><br>  Tema de discusi√≥n: en la clase ReadOnlySequence, los tipos de referencia anulables se usan activamente y hay goto (no para salir de la anidaci√≥n y no en el c√≥digo generado), en particular, <a href="">aqu√≠</a> <br><br>  Despu√©s del procesamiento, debe dejar en claro a la instancia de Pipe que hemos le√≠do los datos. <br><br><h3>  # 2 <a href="">bool TryRead (resultado de ReadResult)</a> </h3><br>  Versi√≥n sincr√≥nica.  Le permite obtener el resultado si es as√≠.  Si a√∫n no est√° all√≠, a diferencia de ReadAsync, no bloquea, pero devuelve falso.  Tambi√©n en la cerradura. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition consumido, SequencePosition examinado)</a> </h3><br>  En este m√©todo, puede especificar cu√°ntos bytes leemos y cu√°ntos procesamos.  Los datos que hayan sido le√≠dos pero no procesados ‚Äã‚Äãse devolver√°n la pr√≥xima vez que se lean.  Esta caracter√≠stica puede parecer extra√±a a primera vista, pero cuando se procesa una secuencia de bytes, rara vez es necesario procesar cada byte individualmente.  Por lo general, los datos se intercambian mediante mensajes.  Puede surgir una situaci√≥n en la que el lector, al leer, recibi√≥ un mensaje completo y parte del segundo.  El todo debe ser procesado, y parte del segundo debe dejarse la pr√≥xima vez para que venga junto con la parte restante.  El m√©todo AdvanceTo acepta una SequencePosition, que en realidad es un segmento + √≠ndice.  Al procesar todo lo que ReadAsync ha le√≠do, puede especificar el b√∫fer. Fin.  De lo contrario, tendr√° que crear expl√≠citamente una posici√≥n, indicando el segmento y el √≠ndice en el que se detuvo el procesamiento.  Debajo del cap√≥ lok. <br>  Adem√°s, si la cantidad de informaci√≥n en bruto es menor que la falla instalada (_resumeWriterThreshold), se inicia la continuaci√≥n de PipeWriter si se bloque√≥.  Por defecto, este umbral es de 8 vol√∫menes de segmento (la mitad del umbral de bloqueo). <br><br><h3>  # 4 vac√≠o completo (excepci√≥n de excepci√≥n = nulo) </h3><br>  Completa PipeReader.  Si PipeWriter est√° completo en este punto, la instancia completa de Pipe finaliza.  Bloquear adentro. <br><br><h3>  # 5 nulo CancelPendingRead () </h3><br>  Le permite cancelar la lectura que se espera actualmente.  Locke <br><br><h3>  # 6 void OnWriterCompleted (Acci√≥n &lt;Excepci√≥n, objeto&gt; devoluci√≥n de llamada, estado del objeto) </h3><br>  Le permite especificar el delegado que se ejecutar√° cuando PipeWriter se complete. <br>  Al igual que el m√©todo similar para PipeWriter, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n tiene</a> la misma nota que se eliminar√°.  Bloqueo debajo del cap√≥. <br><br><h2>  Ejemplo </h2><br><br>  El listado a continuaci√≥n muestra un ejemplo de trabajo con tuber√≠as. <br>  Desde la introducci√≥n de .NET Core Span y Memory, muchas clases para trabajar con datos se han complementado con sobrecargas que utilizan estos tipos.  Entonces, el esquema general de interacci√≥n ser√° aproximadamente el mismo.  En mi ejemplo, us√© tuber√≠as para trabajar con tuber√≠as (me gustan las palabras ra√≠z), es decir.  canales: objetos del sistema operativo para la comunicaci√≥n entre procesos.  El canal API se ha ampliado en consecuencia para leer datos en Span y Memory.  La versi√≥n asincr√≥nica usa memoria, ya que el m√©todo asincr√≥nico se convertir√° en un m√©todo de plantilla usando una m√°quina de estados finitos autogenerada, en la que se almacenan todas las variables locales y los par√°metros del m√©todo, y dado que Span es una estructura de solo lectura, no puede estar en el mont√≥n, respectivamente, usando Span en un m√©todo asincr√≥nico no es posible.  Pero tambi√©n hay una versi√≥n sincr√≥nica del m√©todo que le permite utilizar Span.  En mi ejemplo, prob√© ambos y result√≥ que la versi√≥n s√≠ncrona en esta situaci√≥n se muestra mejor.  Al usarlo, se produce menos recolecci√≥n de basura y el procesamiento de datos es m√°s r√°pido.  Pero esto fue solo porque hab√≠a muchos datos.  En el caso de que sea probable una situaci√≥n en la que no habr√° datos al momento de solicitar el siguiente lote, debe usar la versi√≥n asincr√≥nica para no forzar el procesador inactivo. <br>  El ejemplo tiene comentarios que explican algunos puntos.  Le llamo la atenci√≥n sobre el hecho de que, a pesar de que los fragmentos del programa responsable de la lectura desde la tuber√≠a y el procesamiento est√°n separados, al escribir en un archivo, los datos se leen exactamente desde el lugar donde se escriben al leer desde la tuber√≠a. <br><br><div class="spoiler">  <b class="spoiler_title">A√±os de evoluci√≥n por el bien de una caracter√≠stica poderosa: Maine as√≠ncrono</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pipepatawriter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/         -       . //int readBytes = await _namedPipe.ReadAsync(buffer, token); //         PipeWriter Span //         -       . int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); //      ,        //         if (readBytes == 0) { await Task.Delay(500, token); continue; } // ,       _pipeWriter.Advance(readBytes); //  ,      PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); //  PipeReader  ,       //        ,      if (result.IsCompleted) { break; } } //  _pipeWriter     Pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Procesador de datos</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">//     Pipe ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; //      await _bytesProcessor.ProcessBytesAsync(buffer, token); // ,      .       ,   //  ,               //    IBytesProcessor.ProcessBytesAsync   ,    _pipeReader.AdvanceTo(buffer.End); //  PipeWriter  ,      //      ,      if (result.IsCompleted) { break; } } //  _pipeReader     Pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Procesador de bytes</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//,         IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464921/">https://habr.com/ru/post/464921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464909/index.html">"Nos est√°n mirando": lo que puede suceder en una minivan discreta justo debajo de su ventana</a></li>
<li><a href="../464913/index.html">"Know kaizen": ¬øcu√°l es esta filosof√≠a para mejorar los procesos de producci√≥n?</a></li>
<li><a href="../464915/index.html">Optimizaci√≥n de recursi√≥n de cola de JavaScript</a></li>
<li><a href="../464917/index.html">After cyberpunk: lo que necesitas saber sobre los g√©neros actuales de la ciencia ficci√≥n moderna</a></li>
<li><a href="../464919/index.html">Control de recursos incorporado de RAM utilizada en la aplicaci√≥n.</a></li>
<li><a href="../464925/index.html">Gu√≠a de voz UX: situaciones, patrones, herramientas (y un poco de apoyo moral)</a></li>
<li><a href="../464927/index.html">Minero ASIC de segunda mano: riesgos, verificaci√≥n y hashrate recableado</a></li>
<li><a href="../464929/index.html">Carga diferida de la imagen del navegador (atributo de carga)</a></li>
<li><a href="../464931/index.html">Ensamblador inserta ... en C #?</a></li>
<li><a href="../464933/index.html">Aplicaciones para libros electr√≥nicos en el sistema operativo Android. Parte 4. Juegos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>