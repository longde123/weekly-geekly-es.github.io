<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💫 👉 👼🏼 Kami menulis sistem operasi di Rust. Menerapkan memori halaman (baru) 🔵 🕘 🧐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, kami akan mencari tahu bagaimana menerapkan dukungan memori halaman di inti kami. Pertama, kami akan mempelajari berbagai metode seh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis sistem operasi di Rust. Menerapkan memori halaman (baru)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445618/">  Pada artikel ini, kami akan mencari tahu bagaimana menerapkan dukungan memori halaman di inti kami.  Pertama, kami akan mempelajari berbagai metode sehingga kerangka tabel halaman fisik menjadi tersedia untuk kernel, dan mendiskusikan kelebihan dan kekurangannya.  Kemudian kami mengimplementasikan fungsi terjemahan alamat dan fungsi membuat pemetaan baru. <br><br>  Seri artikel ini diterbitkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Jika Anda memiliki pertanyaan atau masalah, buka tiket terkait di sana.  Semua sumber untuk artikel ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di utas ini</a> . <br><br>  <i><b>Artikel lain tentang paging?</b></i> <i><br></i>  <i>Jika Anda mengikuti siklus ini, Anda melihat artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Memori Halaman: Tingkat Lanjut"</a> pada akhir Januari.</i>  <i>Tapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya dikritik</a> karena tabel halaman rekursif.</i>  <i>Oleh karena itu, saya memutuskan untuk menulis ulang artikel, menggunakan pendekatan berbeda untuk mengakses frame.</i> <br><a name="habracut"></a><br>  <i>Ini opsi baru.</i>  <i>Artikel ini masih menjelaskan bagaimana tabel halaman rekursif bekerja, tetapi kami menggunakan implementasi yang lebih sederhana dan lebih kuat.</i>  <i>Kami tidak akan menghapus artikel sebelumnya, tetapi menandainya sebagai usang dan tidak akan memperbaruinya.</i> <i><br><br></i>  <i>Saya harap Anda menikmati opsi baru!</i> <br><br><h1>  Isi </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembaruan Ketergantungan</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akses ke tabel halaman</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan identitas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperbaiki peta offset</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan memori fisik penuh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tampilan sementara</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tabel Halaman Rekursif</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dukungan bootloader</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi boot</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Titik masuk makro</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akses ke tabel halaman</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terjemahan Alamat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan MappedPageTable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buat pemetaan baru</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemilihan Bingkai</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ringkasan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa selanjutnya</a> </li></ul><br><a name="1"></a><h1>  Pendahuluan </h1><br>  Dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terakhir,</a> kami belajar tentang prinsip-prinsip memori paging dan bagaimana tabel halaman empat tingkat pada <code>x86_64</code> .  Kami juga menemukan bahwa loader sudah mengatur hierarki tabel halaman untuk kernel kami, jadi kernel tersebut berjalan pada alamat virtual.  Ini meningkatkan keamanan karena akses yang tidak sah ke memori menyebabkan kesalahan halaman alih-alih mengubah memori fisik secara acak. <br><br>  Artikel tersebut akhirnya tidak dapat mengakses tabel halaman dari kernel kami, karena mereka disimpan dalam memori fisik, dan kernel sudah berjalan di alamat virtual.  Di sini kami melanjutkan topik dan mengeksplorasi berbagai opsi untuk mengakses bingkai tabel halaman dari kernel.  Kami akan membahas kelebihan dan kekurangan masing-masing, dan kemudian memilih opsi yang sesuai untuk inti kami. <br><br>  Diperlukan dukungan boot loader, jadi kami akan mengonfigurasinya terlebih dahulu.  Kemudian kami menerapkan fungsi yang berjalan melalui seluruh hierarki tabel halaman untuk menerjemahkan alamat virtual ke alamat fisik.  Terakhir, kita akan belajar cara membuat pemetaan baru dalam tabel halaman dan bagaimana menemukan bingkai memori yang tidak digunakan untuk membuat tabel baru. <br><br><a name="1_1"></a><h3>  Pembaruan Ketergantungan </h3><br>  Artikel ini mengharuskan Anda untuk mendaftar <code>bootloader</code> versi 0.4.0 atau lebih tinggi dan <code>x86_64</code> versi 0.5.2 atau lebih tinggi dalam dependensi.  Anda dapat memperbarui dependensi di <code>Cargo.toml</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = "0.4.0" x86_64 = "0.5.2"</code> </pre> <br>  Untuk perubahan dalam versi ini, lihat <a href="">log bootloader</a> dan <a href="">x86_64 log</a> . <br><br><a name="2"></a><h1>  Akses ke tabel halaman </h1><br>  Mengakses tabel halaman dari kernel tidak semudah kelihatannya.  Untuk memahami masalah ini, lihat hierarki tabel empat tingkat dari artikel sebelumnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  Yang penting adalah bahwa setiap entri halaman menyimpan alamat <i>fisik</i> dari tabel berikut.  Ini menghindari terjemahan dari alamat-alamat ini, yang mengurangi kinerja dan dengan mudah mengarah ke loop tanpa akhir. <br><br>  Masalahnya adalah kita tidak dapat secara langsung mengakses alamat fisik dari kernel, karena ia juga bekerja pada alamat virtual.  Sebagai contoh, ketika kita pergi ke alamat <code>4 KiB</code> , kita mendapatkan akses ke alamat <i>virtual</i> <code>4 KiB</code> , dan bukan ke alamat <i>fisik di</i> mana tabel halaman level 4 disimpan.  Jika kita ingin mengakses alamat fisik <code>4 KiB</code> , maka kita perlu menggunakan beberapa alamat virtual, yang diterjemahkan ke dalamnya. <br><br>  Oleh karena itu, untuk mengakses frame dari tabel halaman, Anda perlu memetakan beberapa halaman virtual ke frame ini.  Ada berbagai cara untuk membuat pemetaan seperti itu. <br><br><a name="2_1"></a><h3>  Pemetaan identitas </h3><br>  Solusi sederhana adalah <b>tampilan identik dari semua tabel halaman</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  Dalam contoh ini, kita melihat tampilan bingkai yang identik.  Alamat fisik tabel halaman pada saat yang sama adalah alamat virtual yang valid, sehingga kita dapat dengan mudah mengakses tabel halaman dari semua level, dimulai dengan register CR3. <br><br>  Namun, pendekatan ini mengacaukan ruang alamat virtual dan membuatnya sulit untuk menemukan area memori bebas yang bersebelahan.  Katakanlah kita ingin membuat area memori virtual 1000 KiB pada gambar di atas, misalnya, untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menampilkan file dalam memori</a> .  Kami tidak dapat memulai dengan wilayah <code>28 KiB</code> , karena terletak pada halaman yang sudah diduduki pada <code>1004  KiB</code> .  Oleh karena itu, Anda harus melihat lebih jauh hingga kami menemukan fragmen besar yang cocok, misalnya, dengan <code>1008  KiB</code> .  Ada masalah fragmentasi yang sama seperti pada memori tersegmentasi. <br><br>  Selain itu, pembuatan tabel halaman baru jauh lebih rumit, karena kita perlu menemukan bingkai fisik yang halaman yang sesuai belum digunakan.  Misalnya, untuk file kami, kami memesan area seluas 1000 KiB memori <i>virtual</i> , mulai dari alamat <code>1008  KiB</code> .  Sekarang kita tidak dapat lagi menggunakan bingkai apa pun dengan alamat fisik antara <code>1000  KiB</code> dan <code>2008  KiB</code> , karena tidak dapat ditampilkan secara identik. <br><br><a name="2_2"></a><h3>  Memperbaiki peta offset </h3><br>  Untuk menghindari kekacauan ruang alamat virtual, Anda dapat menampilkan tabel halaman di <b>area memori yang terpisah</b> .  Oleh karena itu, alih-alih mengidentifikasi pemetaan, kami memetakan frame dengan offset tetap di ruang alamat virtual.  Misalnya, offset bisa 10 TiB: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/c8a/5ea/f4ac8a5ea64fd215de176248b5f74e20.svg"><br><br>  Dengan mengalokasikan rentang memori virtual ini murni untuk menampilkan tabel halaman, kami menghindari masalah tampilan yang identik.  Pemesanan ruang alamat virtual yang begitu besar hanya dimungkinkan jika ruang alamat virtual jauh lebih besar dari ukuran memori fisik.  Pada <code>x86_64</code> ini bukan masalah karena ruang alamat 48-bit adalah 256 TiB. <br><br>  Tetapi pendekatan ini memiliki kelemahan bahwa ketika membuat setiap tabel halaman, Anda perlu membuat pemetaan baru.  Selain itu, itu tidak memungkinkan akses ke tabel di ruang alamat lain, yang akan berguna saat membuat proses baru. <br><br><a name="2_3"></a><h3>  Pemetaan memori fisik penuh </h3><br>  Kami dapat memecahkan masalah ini dengan <b>menampilkan semua memori fisik</b> , dan bukan hanya bingkai tabel halaman: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/3cf/7df/c393cf7df76515739e1d9274160c4b5d.svg"><br><br>  Pendekatan ini memungkinkan kernel untuk mengakses memori fisik sewenang-wenang, termasuk bingkai tabel halaman dari ruang alamat lainnya.  Berbagai memori virtual disediakan dengan ukuran yang sama seperti sebelumnya, tetapi hanya tidak ada halaman yang tidak cocok yang tersisa di dalamnya. <br><br>  Kerugian dari pendekatan ini adalah bahwa tabel halaman tambahan diperlukan untuk menampilkan memori fisik.  Tabel halaman ini harus disimpan di suatu tempat, sehingga mereka menggunakan sebagian dari memori fisik, yang dapat menjadi masalah pada perangkat dengan sejumlah kecil RAM. <br><br>  Namun, pada x86_64 kita bisa menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman</a> 2 MiB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">besar</a> untuk menampilkan alih-alih ukuran default 4 KiB.  Dengan demikian, untuk menampilkan 32 GiB memori fisik, hanya diperlukan 132 KiB per tabel halaman: hanya satu tabel level ketiga dan 32 tabel level kedua.  Halaman besar juga di-cache lebih efisien karena mereka menggunakan lebih sedikit entri dalam buffer terjemahan dinamis (TLB). <br><br><a name="2_4"></a><h3>  Tampilan sementara </h3><br>  Untuk perangkat dengan memori fisik sangat sedikit, Anda hanya dapat <b>menampilkan tabel halaman sementara</b> ketika Anda perlu mengaksesnya.  Untuk perbandingan sementara, tampilan identik hanya dari tabel level pertama diperlukan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00a/3ab/5ce/00a3ab5ce85057d3679a48379d3d2297.svg"></div><br><br>  Dalam gambar ini, tabel level 1 mengelola 2 MiB pertama dari ruang alamat virtual.  Hal ini dimungkinkan karena akses dilakukan dari register CR3 melalui entri nol pada tabel level 4, 3 dan 2. Catatan dengan indeks <code>8</code> menerjemahkan halaman virtual pada <code>32 KiB</code> menjadi kerangka fisik pada <code>32 KiB</code> , dengan demikian mengidentifikasi tabel level 1 itu sendiri. Pada gambar ini ditunjukkan oleh panah horizontal. <br><br>  Dengan menulis ke tabel level 1 yang dipetakan secara identik, kernel kami dapat membuat hingga 511 perbandingan waktu (512 dikurangi catatan yang diperlukan untuk pemetaan identitas).  Pada contoh di atas, kernel membuat dua perbandingan waktu: <br><br><ul><li>  Memetakan entri nol di tabel level 1 ke bingkai di <code>24 KiB</code> .  Ini membuat pemetaan sementara halaman virtual pada <code>0 KiB</code> ke bingkai fisik tabel level 2 halaman yang ditunjukkan oleh panah bertitik. </li><li>  Cocokkan catatan ke-9 dari tabel level 1 dengan bingkai pada <code>4 KiB</code> .  Ini membuat pemetaan sementara halaman virtual pada <code>36 KiB</code> ke bingkai fisik tabel level 4 halaman yang ditunjukkan oleh panah bertitik. </li></ul><br>  Sekarang kernel dapat mengakses tabel level 2 dengan menulis ke halaman yang dimulai pada <code>0 KiB</code> dan tabel level 4 dengan menulis ke halaman yang dimulai pada <code>33 KiB</code> . <br><br>  Dengan demikian, akses ke bingkai tabel halaman yang sewenang-wenang dengan pemetaan sementara terdiri dari tindakan berikut: <br><br><ul><li>  Temukan entri gratis di tabel level 1 yang ditampilkan secara identik. <br></li><li>  Petakan entri ini ke bingkai fisik tabel halaman yang ingin kita akses. <br></li><li>  Akses bingkai ini melalui halaman virtual yang terkait dengan entri. <br></li><li>  Atur rekaman kembali ke yang tidak digunakan, sehingga menghapus pemetaan sementara. </li></ul><br>  Dengan pendekatan ini, ruang alamat virtual tetap bersih, karena 512 halaman virtual yang sama terus digunakan.  Kerugiannya adalah beberapa ketidaknyamanan, terutama karena perbandingan baru mungkin memerlukan perubahan beberapa tingkat tabel, yaitu, kita perlu mengulangi proses yang dijelaskan beberapa kali. <br><br><a name="2_5"></a><h3>  Tabel Halaman Rekursif </h3><br>  Pendekatan lain yang menarik yang tidak memerlukan tabel halaman tambahan sama sekali adalah <b>pencocokan rekursif</b> . <br><br>  Idenya adalah untuk menerjemahkan beberapa catatan dari tabel tingkat keempat ke dalamnya.  Dengan demikian, kami benar-benar memesan bagian dari ruang alamat virtual dan memetakan semua frame tabel saat ini dan masa depan ke ruang ini. <br><br>  Mari kita lihat contoh untuk memahami bagaimana semua ini bekerja: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  Satu-satunya perbedaan dari contoh di awal artikel adalah catatan tambahan dengan indeks <code>511</code> di tabel level 4, yang dipetakan ke bingkai fisik <code>4 KiB</code> , yang terletak di tabel ini sendiri. <br><br>  Saat CPU mencatat, ini tidak merujuk ke tabel level 3, tetapi lagi-lagi merujuk ke tabel level 4. Ini mirip dengan fungsi rekursif yang memanggil dirinya sendiri.  Adalah penting bahwa prosesor mengasumsikan bahwa setiap record di tabel level 4 menunjuk ke tabel level 3, jadi sekarang ia memperlakukan tabel level 4 sebagai tabel level 3. Ini berfungsi karena tabel semua level di x86_64 memiliki struktur yang sama. <br><br>  Dengan mengikuti rekaman rekursif satu atau lebih kali sebelum memulai konversi yang sebenarnya, kita dapat secara efektif mengurangi jumlah level yang dilalui prosesor.  Sebagai contoh, jika kita mengikuti catatan rekursif sekali, dan kemudian pergi ke tabel level 3, prosesor berpikir bahwa tabel level 3 adalah tabel level 2. Selanjutnya, dia menganggap tabel level 2 sebagai tabel level 1, dan tabel level 1 dipetakan bingkai dalam memori fisik.  Ini berarti bahwa kita sekarang dapat membaca dan menulis ke tabel level 1 halaman karena prosesor berpikir ini adalah bingkai yang dipetakan.  Gambar di bawah ini menunjukkan lima langkah terjemahan seperti itu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Demikian pula, kita dapat mengikuti entri rekursif dua kali sebelum memulai konversi untuk mengurangi jumlah level yang diteruskan menjadi dua: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Mari kita menjalani prosedur ini langkah demi langkah.  Pertama, CPU mengikuti entri rekursif di tabel level 4 dan berpikir telah mencapai tabel level 3. Kemudian ia mengikuti entri rekursif lagi dan berpikir bahwa ia telah mencapai level 2. Tetapi pada kenyataannya itu masih di level 4. Kemudian CPU pergi ke alamat baru. dan masuk ke tabel level 3, tetapi berpikir itu sudah ada di tabel level 1. Akhirnya, pada titik entri berikutnya di tabel level 2, prosesor berpikir telah mengakses frame memori fisik.  Ini memungkinkan kita untuk membaca dan menulis ke tabel level 2. <br><br>  Tabel level 3 dan 4 juga dapat diakses. Untuk mengakses tabel level 3 kita mengikuti catatan rekursif tiga kali: prosesor berpikir bahwa itu sudah ada di tabel level 1, dan pada langkah berikutnya kita mencapai level 3, yang CPU anggap sebagai bingkai yang dipetakan.  Untuk mengakses tabel level 4 itu sendiri, kita cukup mengikuti catatan rekursif empat kali sampai prosesor memproses tabel level 4 itu sendiri sebagai bingkai yang dipetakan (berwarna biru pada gambar di bawah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  Konsep ini sulit dipahami pada awalnya, tetapi dalam praktiknya ia bekerja dengan cukup baik. <br><br><h4>  Perhitungan Alamat </h4><br>  Jadi, kita dapat mengakses tabel dari semua level dengan mengikuti rekaman rekursif satu atau lebih kali.  Karena indeks dalam tabel empat level diturunkan langsung dari alamat virtual, alamat virtual khusus harus dibuat untuk metode ini.  Seperti yang kita ingat, indeks tabel halaman diekstraksi dari alamat sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Misalkan kita ingin mengakses tabel level 1 yang menampilkan halaman tertentu.  Seperti yang kita pelajari di atas, Anda harus melalui catatan rekursif sekali, dan kemudian melalui indeks level 4, 3 dan 2.  Untuk melakukan ini, kami memindahkan semua blok alamat satu blok ke kanan dan mengatur indeks catatan rekursif ke tempat indeks awal level 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Untuk mengakses tabel level 2 halaman ini, kami memindahkan semua blok indeks dua blok ke kanan dan mengatur indeks rekursif ke tempat kedua blok sumber: level 4 dan level 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Untuk mengakses tabel level 3, kami melakukan hal yang sama, kami hanya menggeser ke kanan sudah tiga blok alamat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Akhirnya, untuk mengakses tabel level 4, pindahkan semuanya empat blok ke kanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Sekarang Anda dapat menghitung alamat virtual untuk tabel halaman dari keempat level.  Kita bahkan dapat menghitung alamat yang secara tepat menunjuk ke entri tabel halaman tertentu dengan mengalikan indeksnya dengan 8, ukuran entri tabel halaman. <br><br>  Tabel di bawah ini menunjukkan struktur alamat untuk mengakses berbagai jenis bingkai: <br><br><table><thead><tr><th>  Alamat virtual untuk </th><th>  Struktur alamat ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oktal</a> ) </th></tr></thead><tbody><tr><td>  Halaman </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Entri di tabel level 1 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Entri dalam tabel level 2 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Entri dalam tabel level 3 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Entri di tabel level 4 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Di sini <code></code> adalah indeks level 4, <code></code> adalah level 3, <code></code> adalah level 2, dan <code>DDD</code> adalah indeks level 1 untuk frame yang ditampilkan, <code>EEEE</code> adalah penyeimbangnya.  <code>RRR</code> adalah indeks dari catatan rekursif.  Indeks (tiga digit) dikonversi menjadi offset (empat digit) dengan mengalikannya dengan 8 (ukuran entri tabel halaman).  Dengan offset ini, alamat yang dihasilkan langsung menunjuk ke entri tabel halaman yang sesuai. <br><br>  <code>SSSS</code> adalah bit ekspansi dari digit yang ditandatangani, yaitu, mereka semua adalah salinan bit 47. Ini adalah persyaratan khusus untuk alamat yang valid dalam arsitektur x86_64, yang kami bahas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alamatnya oktal</a> , karena setiap karakter oktal mewakili tiga bit, yang memungkinkan Anda untuk memisahkan indeks tabel 9-bit pada level yang berbeda.  Ini tidak mungkin dalam sistem heksadesimal, di mana setiap karakter mewakili empat bit. <br><br><h4>  Kode karat </h4><br>  Anda dapat membuat alamat tersebut dalam kode Rust menggunakan operasi bitwise: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// the virtual address whose corresponding page tables you want to access let addr: usize = […]; let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12);</span></span></code> </pre> <br>  Kode ini mengasumsikan pemetaan rekursif dari catatan level 4 terakhir dengan indeks <code>0o777</code> (511) dicocokkan secara rekursif.  Ini bukan masalahnya, jadi kodenya belum berfungsi.  Lihat di bawah tentang cara memberi tahu loader untuk mengatur pemetaan rekursif. <br><br>  Sebagai alternatif untuk melakukan operasi bitwise secara manual, Anda dapat menggunakan jenis <code>RecursivePageTable</code> dari <code>x86_64</code> crate, yang menyediakan abstraksi yang aman untuk berbagai operasi tabel.  Misalnya, kode di bawah ini menunjukkan cara mengubah alamat virtual ke alamat fisiknya yang sesuai: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. let level_4_table_addr = […]; let level_4_table_ptr = level_4_table_addr as *mut PageTable; let recursive_page_table = unsafe { let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap(); } /// Retrieve the physical address for the given virtual address let addr: u64 = […] let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset()))</span></span></code> </pre> <br>  Sekali lagi, kode ini membutuhkan pemetaan rekursif yang benar.  Dengan pemetaan ini, <code>level_4_table_addr</code> hilang dihitung seperti pada contoh kode pertama. <br><br><hr><br>  Pemetaan rekursif adalah metode yang menarik yang menunjukkan seberapa kuat pencocokan dapat melalui satu tabel.  Ini relatif mudah diimplementasikan dan hanya membutuhkan pengaturan minimal (hanya satu entri rekursif), jadi ini adalah pilihan yang baik untuk percobaan pertama. <br><br>  Tetapi memiliki beberapa kelemahan: <br><br><ul><li>  Memori virtual dalam jumlah besar (512 GiB).  Ini bukan masalah dalam ruang alamat 48-bit yang besar, tetapi dapat menyebabkan perilaku cache yang kurang optimal. <br></li><li>  Ini dengan mudah memberikan akses hanya ke ruang alamat yang sedang aktif.  Akses ke ruang alamat lain masih dimungkinkan dengan mengubah entri rekursif, tetapi pencocokan sementara diperlukan untuk beralih.  Kami menjelaskan cara melakukan ini di artikel sebelumnya (usang). <br></li><li>  Ini sangat tergantung pada format tabel halaman x86 dan mungkin tidak berfungsi pada arsitektur lain. </li></ul><br><a name="3"></a><h1>  Dukungan bootloader </h1><br>  Semua pendekatan yang dijelaskan di atas memerlukan perubahan pada tabel halaman dan pengaturan yang sesuai.  Sebagai contoh, untuk memetakan memori fisik secara identik atau rekursif memetakan catatan dari tabel tingkat keempat.  Masalahnya adalah kita tidak dapat melakukan pengaturan ini tanpa akses ke tabel halaman. <br><br>  Jadi, saya butuh bantuan dari bootloader.  Dia memiliki akses ke tabel halaman, sehingga dia dapat membuat tampilan yang kita butuhkan.  Dalam implementasinya saat ini, kotak <code>bootloader</code> mendukung dua pendekatan di atas menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi kargo</a> : <br><br><ul><li>  Fungsi <code>map_physical_memory</code> memetakan memori fisik penuh di suatu tempat di ruang alamat virtual.  Dengan demikian, kernel mendapatkan akses ke semua memori fisik dan dapat menerapkan pendekatan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tampilan memori fisik penuh</a> . <br></li><li>  Menggunakan fungsi <code>recursive_page_table</code> , loader secara rekursif menampilkan entri tabel halaman tingkat keempat.  Ini memungkinkan kernel untuk bekerja sesuai dengan metode yang dijelaskan dalam bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Tabel Halaman Rekursif"</a> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk kernel kami, kami memilih opsi pertama, karena ini adalah pendekatan yang sederhana, platform-independen dan lebih kuat (juga memberikan akses ke frame lain, bukan hanya tabel halaman). </font><font style="vertical-align: inherit;">Untuk dukungan dari bootloader, tambahkan fungsi ke dependensinya </font></font><code>map_physical_memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = { version = "0.4.0", features = ["map_physical_memory"]}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika fitur ini diaktifkan, bootloader memetakan memori fisik lengkap ke beberapa alamat virtual yang tidak digunakan. </font><font style="vertical-align: inherit;">Untuk meneruskan serangkaian alamat virtual ke kernel, bootloader meneruskan struktur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informasi boot</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="3_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informasi boot </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peti </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mendefinisikan struktur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bootinfo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan semua informasi yang dikirimkan oleh inti. </font><font style="vertical-align: inherit;">Struktur masih diselesaikan, sehingga mungkin ada beberapa kegagalan saat memutakhirkan ke versi masa depan yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak kompatibel dengan semver</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saat ini, struktur memiliki dua bidang: </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidang ini </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyediakan ikhtisar memori fisik yang tersedia. </font><font style="vertical-align: inherit;">Ini memberitahu kernel berapa banyak memori fisik yang tersedia pada sistem dan area memori mana yang dicadangkan untuk perangkat seperti VGA. </font><font style="vertical-align: inherit;">Kartu memori dapat diminta dari firmware BIOS atau UEFI, tetapi hanya pada awal proses booting. </font><font style="vertical-align: inherit;">Karena alasan ini, loader harus menyediakannya, karena kernel tidak akan lagi dapat menerima informasi ini. </font><font style="vertical-align: inherit;">Kartu memori akan berguna nanti di artikel ini.</font></font><br></li><li> <code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melaporkan alamat awal virtual pemetaan memori fisik. </font><font style="vertical-align: inherit;">Menambahkan offset ini ke alamat fisik, kami mendapatkan alamat virtual yang sesuai. </font><font style="vertical-align: inherit;">Ini memberikan akses dari kernel ke memori fisik sewenang-wenang.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loader meneruskan struktur </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke </font><font style="vertical-align: inherit;">kernel </font><font style="vertical-align: inherit;">sebagai argumen </font></font><code>&amp;'static BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke fungsi </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tambahkan:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penting untuk menentukan jenis argumen yang benar, karena kompiler tidak mengetahui jenis tanda tangan yang benar dari fungsi titik masuk kami. </font></font><br><br><a name="3_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Titik masuk makro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena fungsi </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dipanggil secara eksternal dari loader, tanda tangan fungsi tidak dicentang. Ini berarti bahwa kita dapat membiarkannya menerima argumen arbitrer tanpa kesalahan kompilasi, tetapi ini akan crash atau menyebabkan perilaku runtime yang tidak ditentukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memastikan bahwa fungsi titik masuk selalu memiliki tanda tangan yang benar, peti </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyediakan makro </font></font><code>entry_point</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kami menulis ulang fungsi kami menggunakan makro ini:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda tidak perlu lagi menggunakan untuk titik masuk </font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>no_mangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena makro menentukan bagi kami titik masuk nyata dari tingkat yang lebih rendah </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Fungsi </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang </font><font style="vertical-align: inherit;">telah </font><font style="vertical-align: inherit;">menjadi fungsi Rust yang benar-benar normal, sehingga kita dapat memilih nama arbitrer untuk itu. Yang penting dicentang berdasarkan jenisnya, jadi jika Anda menggunakan tanda tangan yang salah, misalnya dengan menambahkan argumen atau mengubah jenisnya, kesalahan kompilasi akan terjadi</font></font><br><br><a name="4"></a><h1>  Implementasi </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki akses ke memori fisik, dan akhirnya kita dapat memulai implementasi sistem. </font><font style="vertical-align: inherit;">Pertama, pertimbangkan tabel halaman aktif saat ini di mana kernel berjalan. </font><font style="vertical-align: inherit;">Pada langkah kedua, buat fungsi terjemahan yang mengembalikan alamat fisik yang dipetakan alamat virtual ini. </font><font style="vertical-align: inherit;">Pada langkah terakhir, kami akan mencoba mengubah tabel halaman untuk membuat pemetaan baru. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, buat modul baru dalam kode </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk modul, buat file kosong </font></font><code>src/memory.rs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="4_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akses ke tabel halaman </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada akhir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel sebelumnya,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami mencoba melihat tabel halaman tempat kernel bekerja, tetapi tidak dapat mengakses kerangka fisik yang ditunjukkan oleh register </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sekarang kita dapat terus bekerja dari tempat ini: fungsi </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan mengembalikan tautan ke tabel halaman aktif dari tingkat keempat:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::PageTable; /// Returns a mutable reference to the active level 4 table. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable { use x86_64::{registers::control::Cr3, VirtAddr}; let (level_4_table_frame, _) = Cr3::read(); let phys = level_4_table_frame.start_address(); let virt = VirtAddr::new(phys.as_u64() + physical_memory_offset); let page_table_ptr: *mut PageTable = virt.as_mut_ptr(); &amp;mut *page_table_ptr // unsafe }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, kita membaca kerangka fisik tabel aktif tingkat 4 dari register </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kemudian kami mengambil alamat awal fisiknya dan mengubahnya menjadi alamat virtual dengan menambahkan </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Akhirnya, ubah alamat menjadi pointer mentah </font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan metode ini </font></font><code>as_mut_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian buat tautan dengan tidak aman </font></font><code>&amp;mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kami membuat tautan </font></font><code>&amp;mut</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai gantinya </font></font><code>&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena nanti dalam artikel kami akan memodifikasi tabel halaman ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak perlu memasukkan blok yang tidak aman di sini, karena Rust menganggap seluruh tubuh </font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai satu blok besar yang tidak aman. Ini meningkatkan risiko, karena dimungkinkan untuk secara tidak sengaja memperkenalkan operasi yang tidak aman di baris sebelumnya. Ini juga membuat sulit untuk mendeteksi operasi yang tidak aman. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC telah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dibuat </font><font style="vertical-align: inherit;">untuk memodifikasi perilaku Rust ini.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita bisa menggunakan fungsi ini untuk menampilkan catatan dari tabel tingkat keempat:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::active_level_4_table; let l4_table = unsafe { active_level_4_table(boot_info.physical_memory_offset) }; for (i, entry) in l4_table.iter().enumerate() { if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); } } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melewati bidang struktur yang sesuai </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kemudian kami menggunakan fungsi </font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk beralih melalui entri tabel halaman dan kombinator </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">enumerate</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menambahkan indeks </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke setiap elemen. Hanya entri yang tidak kosong yang ditampilkan, karena semua 512 entri tidak akan muat di layar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kami menjalankan kode, kami melihat hasil ini: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a33/def/50d/a33def50db528880395b665882aabe75.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melihat beberapa catatan tidak kosong yang dipetakan ke berbagai tabel tingkat ketiga. Begitu banyak area memori yang digunakan karena area terpisah diperlukan untuk kode kernel, tumpukan kernel, terjemahan memori fisik, dan informasi booting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melihat tabel halaman dan melihat tabel level ketiga, kita dapat kembali mengkonversi frame yang ditampilkan ke alamat virtual:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in the for loop in src/main.rs use x86_64::{structures::paging::PageTable, VirtAddr}; if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); // get the physical address from the entry and convert it let phys = entry.frame().unwrap().start_address(); let virt = phys.as_u64() + boot_info.physical_memory_offset; let ptr = VirtAddr::new(virt).as_mut_ptr(); let l3_table: &amp;PageTable = unsafe { &amp;*ptr }; // print non-empty entries of the level 3 table for (i, entry) in l3_table.iter().enumerate() { if !entry.is_unused() { println!(" L3 Entry {}: {:?}", i, entry); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melihat tabel level kedua dan pertama, ulangi proses ini, masing-masing, untuk catatan level ketiga dan kedua. </font><font style="vertical-align: inherit;">Seperti yang dapat Anda bayangkan, jumlah kode berkembang sangat cepat, jadi kami tidak akan mempublikasikan listing lengkap. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel traverse manual menarik karena membantu memahami bagaimana prosesor menerjemahkan alamat. </font><font style="vertical-align: inherit;">Tetapi biasanya kami hanya tertarik untuk menampilkan satu alamat fisik untuk alamat virtual tertentu, jadi mari kita buat fungsi untuk ini.</font></font><br><br><a name="4_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terjemahan Alamat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menerjemahkan alamat virtual ke alamat fisik, kita harus melalui tabel halaman empat tingkat sampai kita mencapai bingkai yang dipetakan. </font><font style="vertical-align: inherit;">Mari kita buat fungsi yang melakukan terjemahan alamat ini:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::{PhysAddr, VirtAddr}; /// Translates the given virtual address to the mapped physical address, or /// `None` if the address is not mapped. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. pub unsafe fn translate_addr(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { translate_addr_inner(addr, physical_memory_offset) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami merujuk ke fungsi aman </font></font><code>translate_addr_inner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk membatasi jumlah kode tidak aman. Seperti disebutkan di atas, Rust menganggap seluruh tubuh </font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai blok besar yang tidak aman. Dengan menjalankan satu fungsi aman, kami kembali membuat setiap operasi eksplisit </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi internal khusus memiliki fungsi nyata:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// Private function that is called by `translate_addr`. /// /// This function is safe to limit the scope of `unsafe` because Rust treats /// the whole body of unsafe functions as an unsafe block. This function must /// only be reachable through `unsafe fn` from outside of this module. fn translate_addr_inner(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { use x86_64::structures::paging::page_table::FrameError; use x86_64::registers::control::Cr3; // read the active level 4 frame from the CR3 register let (level_4_table_frame, _) = Cr3::read(); let table_indexes = [ addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index() ]; let mut frame = level_4_table_frame; // traverse the multi-level page table for &amp;index in &amp;table_indexes { // convert the frame into a page table reference let virt = frame.start_address().as_u64() + physical_memory_offset; let table_ptr: *const PageTable = VirtAddr::new(virt).as_ptr(); let table = unsafe {&amp;*table_ptr}; // read the page table entry and update `frame` let entry = &amp;table[index]; frame = match entry.frame() { Ok(frame) =&gt; frame, Err(FrameError::FrameNotPresent) =&gt; return None, Err(FrameError::HugeFrame) =&gt; panic!("huge pages not supported"), }; } // calculate the physical address by adding the page offset Some(frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih menggunakan kembali fungsi, </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami membaca kembali frame tingkat keempat dari register </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena ini menyederhanakan implementasi prototipe. Jangan khawatir, kami akan segera memperbaiki solusinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur </font></font><code>VirtAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudah menyediakan metode untuk menghitung indeks dalam tabel halaman dari empat level. Kami menyimpan indeks ini dalam array kecil, karena memungkinkan Anda untuk mengulang semua tabel </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Di luar loop, kita ingat frame terakhir yang dikunjungi untuk menghitung alamat fisik nanti. </font></font><code>frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunjuk ke bingkai tabel halaman selama iterasi dan ke frame terkait setelah iterasi terakhir, yaitu, setelah melewati catatan level 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di dalam loop, kami sekali lagi menerapkan</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengubah bingkai ke tautan tabel halaman. Kemudian kita membaca catatan dari tabel halaman saat ini dan menggunakan fungsi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>PageTableEntry::frame</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengambil frame yang cocok. Jika catatan tidak dipetakan ke bingkai, kembali </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika catatan menampilkan halaman besar 2 MiB atau 1 GiB, sejauh ini kita akan panik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, mari kita periksa fungsi terjemahan di beberapa alamat:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; use x86_64::VirtAddr; let addresses = [ // the identity-mapped vga buffer page 0xb8000, // some code page 0x20010a, // some stack page 0x57ac_001f_fe48, // virtual address mapped to physical address 0 boot_info.physical_memory_offset, ]; for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); let phys = unsafe { translate_addr(virt, boot_info.physical_memory_offset) }; println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kami menjalankan kode, kami mendapatkan hasil berikut: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0b/e32/db8/a0be32db8b6353452f9d40d7b1d350ad.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang diharapkan, dengan pemetaan yang identik, alamat tersebut </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dikonversi ke alamat fisik yang sama. </font><font style="vertical-align: inherit;">Halaman kode dan halaman stack dikonversi ke alamat fisik yang berubah-ubah, yang tergantung pada bagaimana loader membuat pemetaan awal untuk kernel kami. </font><font style="vertical-align: inherit;">Pemetaan </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus menunjuk ke alamat fisik </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi gagal, karena terjemahan menggunakan halaman besar untuk efisiensi. </font><font style="vertical-align: inherit;">Versi bootloader yang akan datang mungkin menerapkan optimasi yang sama untuk halaman kernel dan stack.</font></font><br><br><a name="4_3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggunakan MappedPageTable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penerjemahan alamat virtual ke alamat fisik adalah tugas khas dari kernel OS, oleh karena itu peti </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyediakan abstraksi untuk itu. </font><font style="vertical-align: inherit;">Itu sudah mendukung halaman besar dan beberapa fungsi lainnya, kecuali </font></font><code>translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, oleh karena itu, kami menggunakannya alih-alih menambahkan dukungan untuk halaman besar ke implementasi kami sendiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dasar abstraksi adalah dua sifat yang mendefinisikan berbagai fungsi terjemahan dari tabel halaman:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ciri tersebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyediakan fungsi yang berfungsi pada halaman. </font><font style="vertical-align: inherit;">Misalnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>translate_page</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerjemahkan halaman ini ke dalam bingkai dengan ukuran yang sama, serta </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat pemetaan baru di tabel.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sifat tersebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MapperAllSizes</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyiratkan aplikasi </font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk semua ukuran halaman. </font><font style="vertical-align: inherit;">Selain itu, ia menyediakan fungsi yang berfungsi dengan halaman dengan ukuran yang berbeda, termasuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>translate_addr</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau umum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>translate</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ciri-ciri hanya mendefinisikan antarmuka, tetapi tidak menyediakan implementasi apa pun. </font><font style="vertical-align: inherit;">Sekarang peti </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyediakan dua jenis yang menerapkan sifat: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MappedPageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>RecursivePageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Yang pertama mengharuskan setiap frame dari tabel halaman ditampilkan di suatu tempat (misalnya, dengan offset). </font><font style="vertical-align: inherit;">Tipe kedua dapat digunakan jika tabel tingkat keempat ditampilkan secara rekursif. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memiliki semua memori fisik yang dipetakan </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sehingga Anda dapat menggunakan tipe MappedPageTable. </font><font style="vertical-align: inherit;">Untuk menginisialisasi, buat fungsi baru </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam modul </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::structures::paging::{PhysFrame, MapperAllSizes, MappedPageTable}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::PhysAddr; <span class="hljs-comment"><span class="hljs-comment">/// Initialize a new MappedPageTable. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn init(physical_memory_offset: u64) -&gt; impl MapperAllSizes { let level_4_table = active_level_4_table(physical_memory_offset); let phys_to_virt = move |frame: PhysFrame| -&gt; *mut PageTable { let phys = frame.start_address().as_u64(); let virt = VirtAddr::new(phys + physical_memory_offset); virt.as_mut_ptr() }; MappedPageTable::new(level_4_table, phys_to_virt) } // make private unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable {…}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak dapat langsung kembali </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari suatu fungsi karena itu umum untuk tipe penutupan. Kami akan menyelesaikan masalah ini dengan konstruk sintaksis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>impl Trait</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Keuntungan tambahan adalah Anda kemudian dapat beralih ke kernel </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanpa mengubah tanda tangan fungsi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MappedPageTable::new</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengharapkan dua parameter: tautan yang dapat diubah ke tabel halaman level 4 dan penutupan </font></font><code>phys_to_virt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengubah bingkai fisik menjadi penunjuk tabel halaman </font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Untuk parameter pertama, kita dapat menggunakan kembali fungsinya </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Untuk yang kedua, kami membuat penutupan yang digunakan </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk melakukan konversi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga menjadikannya sebagai </font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fungsi pribadi, karena mulai sekarang hanya akan dipanggil dari </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menggunakan metode ini</font></font><code>MapperAllSizes::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alih-alih fungsi kita sendiri </font></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita perlu mengubah hanya beberapa baris di </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS // new: different imports use blog_os::memory; use x86_64::{structures::paging::MapperAllSizes, VirtAddr}; // new: initialize a mapper let mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let addresses = […]; // same as before for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); // new: use the `mapper.translate_addr` method let phys = mapper.translate_addr(virt); println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah memulai, kami melihat hasil terjemahan yang sama seperti sebelumnya, tetapi hanya halaman besar sekarang juga yang berfungsi: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/5ed/d9c/51d5edd9c004e1238b321dee51fdf8b3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang diharapkan, alamat virtual </font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dikonversi ke alamat fisik </font></font><code>0x0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Menggunakan fungsi terjemahan untuk jenis ini </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami menghilangkan kebutuhan untuk mengimplementasikan dukungan untuk halaman besar. </font><font style="vertical-align: inherit;">Kami juga memiliki akses ke fungsi halaman lain, seperti </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang akan kami gunakan di bagian selanjutnya. </font><font style="vertical-align: inherit;">Pada tahap ini, kita tidak lagi membutuhkan fungsinya </font></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda dapat menghapusnya jika mau.</font></font><br><br><a name="4_4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buat pemetaan baru </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, kami hanya melihat tabel halaman, tetapi belum mengubah apa pun. </font><font style="vertical-align: inherit;">Mari kita buat pemetaan baru untuk halaman yang sebelumnya tidak ditampilkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan menggunakan fungsi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari sifat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi pertama-tama kami akan mempertimbangkan fungsi ini. </font><font style="vertical-align: inherit;">Dokumentasi mengatakan bahwa itu memerlukan empat argumen: halaman yang ingin kami tampilkan; </font><font style="vertical-align: inherit;">Bingkai di mana halaman harus dipetakan. </font><font style="vertical-align: inherit;">set bendera untuk menulis tabel halaman dan distributor bingkai </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pengalokasi bingkai diperlukan karena memetakan halaman ini mungkin memerlukan pembuatan tabel tambahan yang membutuhkan bingkai yang tidak digunakan sebagai penyimpanan cadangan.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fungsi </font></font><code>create_example_mapping</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah pertama dalam implementasi kami adalah membuat fungsi baru </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memetakan halaman ini ke </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bingkai fisik buffer teks VGA. Kami memilih bingkai ini karena memudahkan untuk memeriksa apakah tampilan dibuat dengan benar: kita hanya perlu menulis ke halaman yang baru saja ditampilkan dan melihat apakah itu muncul di layar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terlihat seperti ini:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Page, Size4KiB, Mapper, FrameAllocator}; /// Creates an example mapping for the given page to frame `0xb8000`. pub fn create_example_mapping( page: Page, mapper: &amp;mut impl Mapper&lt;Size4KiB&gt;, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { mapper.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain halaman </font></font><code>page</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang ingin Anda petakan, fungsi tersebut mengharapkan instance dari </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tipe </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengimplementasikan sifat </font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang disediakan metode </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Parameter umum </font></font><code>Size4KiB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diperlukan, karena sifat </font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tersebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">umum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk sifat tersebut </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PageSize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bekerja dengan halaman standar 4 KiB dan halaman besar 2 MiB dan 1 GiB. Kami hanya ingin membuat 4 halaman KiB, jadi kami dapat menggunakannya </font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alih-alih persyaratannya </font></font><code>MapperAllSizes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai perbandingan, atur flag </font></font><code>PRESENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena itu diperlukan untuk semua entri yang valid, dan flag </font></font><code>WRITABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk membuat halaman yang ditampilkan dapat ditulis. Tantangan</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak aman: Anda dapat melanggar keamanan memori dengan argumen yang tidak valid, jadi Anda harus menggunakan blok </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk daftar semua kemungkinan bendera, lihat bagian "Format Tabel Halaman" dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel sebelumnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi ini </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mungkin gagal, jadi itu kembali </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Result</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena ini hanyalah contoh kode yang seharusnya tidak dapat diandalkan, kami cukup menggunakannya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>expect</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk panik jika terjadi kesalahan. </font><font style="vertical-align: inherit;">Jika berhasil, fungsi mengembalikan jenis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MapperFlush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menyediakan cara mudah untuk menghapus halaman yang baru-baru ini ditampilkan dari buffer terjemahan dinamis (TLB) menggunakan metode ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>flush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seperti </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tipe ini menerapkan atribut [ </font></font><code>#[must_use]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">] ke</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengeluarkan peringatan jika kita tidak sengaja lupa menggunakannya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fiktif </font></font><code>FrameAllocator</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menelepon </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda harus membuatnya terlebih dahulu </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seperti disebutkan di atas, kerumitan membuat tampilan baru tergantung pada halaman virtual yang ingin kita tampilkan. </font><font style="vertical-align: inherit;">Dalam kasus paling sederhana, tabel level 1 untuk halaman sudah ada, dan kita hanya perlu membuat satu catatan. </font><font style="vertical-align: inherit;">Dalam kasus yang paling sulit, halaman berada di area memori yang level 3 belum dibuat, jadi pertama-tama Anda harus membuat tabel halaman level 3, 2 dan 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan kasing sederhana dan berasumsi bahwa Anda tidak perlu membuat tabel halaman baru. </font><font style="vertical-align: inherit;">Distributor kerangka yang selalu kembali sudah cukup untuk ini </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami membuat </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fungsi tampilan untuk pengujian:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang Anda perlu menemukan halaman yang dapat ditampilkan tanpa membuat tabel halaman baru. Pemuat dimuat ke megabyte pertama ruang alamat virtual, jadi kami tahu bahwa untuk wilayah ini ada tabel level 1. yang valid. Sebagai contoh kami, kami dapat memilih halaman yang tidak digunakan di area memori ini, misalnya, halaman di alamat </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menguji fungsinya, pertama-tama kita menampilkan halaman </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian menampilkan isi dari memori:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory; use x86_64::{structures::paging::Page, VirtAddr}; let mut mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let mut frame_allocator = memory::EmptyFrameAllocator; // map a previously unmapped page let page = Page::containing_address(VirtAddr::new(0x1000)); memory::create_example_mapping(page, &amp;mut mapper, &amp;mut frame_allocator); // write the string `New!` to the screen through the new mapping let page_ptr: *mut u64 = page.start_address().as_mut_ptr(); unsafe { page_ptr.offset(400).write_volatile(0x_f021_f077_f065_f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, kami membuat pemetaan untuk halaman </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, memanggil fungsi </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan tautan yang dapat berubah ke instance </font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini memetakan halaman </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke frame buffer teks VGA, jadi kita harus melihat apa yang tertulis di layar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian konversikan halaman menjadi pointer mentah dan tulis nilainya ke offset </font></font><code>400</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kami tidak menulis ke bagian atas halaman karena garis atas buffer VGA secara langsung digeser dari layar sebagai berikut </font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tulis nilai </font></font><code>0x_f021_f077_f065_f04e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang sesuai dengan string </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Baru!"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada latar belakang putih. Seperti yang kita pelajari di artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Mode Teks VGA"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , menulis ke buffer VGA harus volatile, jadi kami menggunakan metode ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>write_volatile</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kami menjalankan kode di QEMU, kami melihat hasil berikut: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/248/1a0/4cf2481a07f40c681954ff4954dce866.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menulis ke halaman </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tulisan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Baru!"</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kami telah berhasil membuat pemetaan baru di tabel halaman. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Susunan ini berfungsi karena sudah ada tabel level 1 untuk susunan </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ketika kami mencoba memetakan halaman di mana tabel level 1 belum ada, fungsinya </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gagal karena mencoba mengalokasikan bingkai dari </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk membuat tabel baru. </font><font style="vertical-align: inherit;">Kami melihat bahwa ini terjadi ketika kami mencoba menampilkan halaman </font></font><code>0xdeadbeaf000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alih-alih </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika ini dimulai, panik terjadi dengan pesan kesalahan berikut: </font></font><br><br><pre> <code class="plaintext hljs">panicked at 'map_to failed: FrameAllocationFailed', /…/result.rs:999:5</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menampilkan halaman yang belum memiliki tabel level 1 halaman, Anda harus membuat yang benar </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tapi bagaimana Anda tahu frame mana yang gratis dan berapa banyak memori fisik yang tersedia?</font></font><br><br><a name="4_5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemilihan Bingkai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk tabel halaman baru, Anda harus membuat distributor bingkai yang benar. </font><font style="vertical-align: inherit;">Mari kita mulai dengan kerangka umum:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidang </font></font><code>frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat diinisialisasi dengan iterator bingkai sewenang-wenang. Ini memungkinkan Anda untuk hanya mendelegasikan panggilan ke </font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Iterator::next</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk inisialisasi, kami </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan kartu memori </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang ditransfer oleh bootloader sebagai bagian dari struktur </font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sebagaimana dijelaskan di bagian </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informasi Booting</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kartu memori disediakan oleh firmware BIOS / UEFI. Ini dapat diminta hanya pada awal proses boot, sehingga bootloader telah memanggil fungsi yang diperlukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kartu memori terdiri dari daftar struktur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang berisi alamat awal, panjang, dan jenis (misalnya, tidak digunakan, dicadangkan, dll.) Dari setiap area memori. Dengan membuat iterator yang menghasilkan bingkai dari area yang tidak digunakan, kita bisa membuat yang valid </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terjadi pada fungsi baru </font></font><code>init_frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi ini menggunakan kombinator untuk mengubah peta awal </font></font><code>MemoryMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi iterator dari frame fisik yang digunakan:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, kami memanggil metode </font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengkonversi kartu memori ke iterator </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kemudian kami menggunakan metode ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>filter</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk melewati daerah yang tidak dapat diakses atau tidak dapat diakses. </font><font style="vertical-align: inherit;">Loader memperbarui kartu memori untuk semua pemetaan yang dibuatnya, sehingga frame yang digunakan oleh kernel (kode, data atau tumpukan) atau untuk menyimpan informasi tentang boot sudah ditandai sebagai </font></font><code>InUse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau serupa. </font><font style="vertical-align: inherit;">Dengan demikian, kita dapat yakin bahwa frame </font></font><code>Usable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak digunakan di </font><font style="vertical-align: inherit;">tempat lain </font><font style="vertical-align: inherit;">.</font></font><br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>map</code></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">range</a>  Rust         . <br></li><li>    :         <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>step_by</code></a> .  4096  (= 4 ) —   ,      .      ,         .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>flat_map</code></a>  <code>map</code> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang Anda dapat mengubah fungsi kita </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengirimkan salinan </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gantinya </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kali ini pemetaan alamat berhasil dan kami kembali melihat hitam dan putih </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Baru!"</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di belakang layar, metode ini </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat tabel halaman yang hilang sebagai berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilih bingkai yang tidak digunakan dari yang dikirimkan </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nol bingkai untuk membuat tabel halaman kosong baru. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Petakan entri tabel tingkat lebih tinggi ke bingkai ini. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pergi ke tingkat tabel berikutnya. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun fungsi kami </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya kode sampel, kami sekarang dapat membuat pemetaan baru untuk halaman sewenang-wenang. </font><font style="vertical-align: inherit;">Ini akan diperlukan untuk mengalokasikan memori dan mengimplementasikan multithreading di artikel mendatang.</font></font><br><br><a name="5"></a><h1>  Ringkasan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam artikel ini, kami belajar tentang berbagai metode mengakses kerangka fisik tabel halaman, termasuk pemetaan identitas, pemetaan memori fisik penuh, pemetaan sementara, dan tabel halaman rekursif. Kami memilih untuk menampilkan memori fisik penuh sebagai metode yang sederhana dan kuat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak dapat memetakan memori fisik dari kernel tanpa akses ke tabel halaman, sehingga diperlukan dukungan bootloader. Rak </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menciptakan pemetaan yang diperlukan melalui fungsi kargo tambahan. Ini menyampaikan informasi yang diperlukan ke kernel sebagai argumen </font></font><code>&amp;BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke fungsi titik masuk. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk implementasi kami, pertama-tama kami secara manual menelusuri tabel halaman, membuat fungsi terjemahan, dan kemudian menggunakan jenis </font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peti</font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami juga belajar cara membuat pemetaan baru di tabel halaman dan cara membuatnya </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di kartu memori yang dikirimkan oleh bootloader.</font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa selanjutnya </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada artikel selanjutnya, kita akan membuat area memori heap untuk kernel kita, yang akan memungkinkan kita untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengalokasikan memori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan menggunakan berbagai </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jenis koleksi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445618/">https://habr.com/ru/post/id445618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445596/index.html">Kiat & trik Kubernetes: halaman kesalahan yang dipersonalisasi di NGINX Ingress</a></li>
<li><a href="../id445600/index.html">[Poll dan jahat] Tuan rumah, baik itu salah</a></li>
<li><a href="../id445602/index.html">PHP Rusia 2019: "stadion" -nya untuk bahasa liga pertama</a></li>
<li><a href="../id445608/index.html">Game over: analis melaporkan peningkatan jumlah serangan DDoS pada segmen game</a></li>
<li><a href="../id445612/index.html">Penyimpanan cluster untuk cluster web kecil berdasarkan drbd + ocfs2</a></li>
<li><a href="../id445620/index.html">Apa yang dilakukan penulis UX?</a></li>
<li><a href="../id445622/index.html">Baru di Jawa 12: The Teeing Collector</a></li>
<li><a href="../id445626/index.html">Seberapa dalam lubang kelinci? CLRium # 5: Pengumpul Sampah</a></li>
<li><a href="../id445632/index.html">Dari parser poster teater Python ke bot Telegram. Bagian 2</a></li>
<li><a href="../id445638/index.html">Magang buta di Museum Seni Modern Garage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>