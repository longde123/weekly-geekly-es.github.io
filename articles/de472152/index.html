<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❤️ 👺 ✖️ Testen von Multithread- und asynchronem Code 💃🏿 👨🏿‍🚀 👩‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Diese Woche bestand die Aufgabe darin, einen Integrationstest für eine Spring Boot-Anwendung unter Verwendung der asynchronen Interaktion mit e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testen von Multithread- und asynchronem Code</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472152/"> Hallo!  Diese Woche bestand die Aufgabe darin, einen Integrationstest für eine Spring Boot-Anwendung unter Verwendung der asynchronen Interaktion mit externen Systemen zu schreiben.  Es wurde viel Material zum Debuggen von Multithread-Code aktualisiert.  Der Artikel „Testen von Multithread-Code und asynchronem Code“ von Jonathan Halterman, dessen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> unten aufgeführt ist, erregte Aufmerksamkeit. <br><a name="habracut"></a><br>  Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shalomman</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schroeder</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FTOH</a> für die wichtigsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codekommentare</a> aus dem Originalartikel. <br><br>  Wenn Sie den Code lange genug schreiben oder nicht, sind Sie wahrscheinlich auf ein Skript gestoßen, in dem Sie Multithread-Code testen müssen.  Es wird allgemein angenommen, dass Threads und Tests nicht gemischt werden sollten.  Dies geschieht normalerweise, weil  Was getestet werden soll, beginnt in einem Multithread-System und kann einzeln ohne Verwendung von Threads getestet werden.  Aber was ist, wenn Sie sie nicht trennen können oder mehr, wenn Multithreading der Aspekt des Codes ist, den Sie testen? <br><br>  Ich bin hier, um Ihnen zu sagen, dass die Threads in den Tests zwar nicht sehr häufig sind, aber durchaus verwendet werden.  Die Software-Polizei wird Sie nicht verhaften, weil Sie einen Thread in einem Unit-Test gestartet haben, obwohl es eine andere Sache ist, wie Sie Multithread-Code tatsächlich testen.  Einige hervorragende asynchrone Technologien wie Akka und Vert.x bieten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testkits</a> , um diese Belastung zu verringern.  Darüber hinaus erfordert das Testen von Multithread-Code normalerweise einen anderen Ansatz als ein typischer synchroner Komponententest. <br><br><h2>  Wir gehen parallel </h2><br>  Der erste Schritt besteht darin, eine Multithread-Aktion zu starten, für die Sie das Ergebnis überprüfen möchten.  Verwenden wir beispielsweise eine hypothetische API, um einen Nachrichtenhandler auf einem Nachrichtenbus zu registrieren und eine Nachricht auf dem Bus zu veröffentlichen, die asynchron in einem separaten Thread an unseren Handler übermittelt wird: <br><br><pre><code class="java hljs">messageBus.registerHandler(message - &gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); }); messageBus.publish(<span class="hljs-string"><span class="hljs-string">"test"</span></span>);</code> </pre> <br>  Es sieht gut aus.  Wenn der Test startet, sollte der Bus unsere Nachricht in einem anderen Thread an den Handler senden, dies ist jedoch nicht sehr nützlich, da wir nichts überprüfen.  Aktualisieren wir unseren Test, um zu bestätigen, dass der Nachrichtenbus unsere Nachricht wie erwartet übermittelt: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); }; messageBus.publish(msg);</code> </pre> <br>  Es sieht besser aus.  Wir führen unseren Test durch und er ist grün.  Cool!  Aber die empfangene Nachricht wurde nirgendwo gedruckt, irgendwo stimmte etwas nicht. <br><br><h2>  Warte eine Sekunde </h2><br>  Wenn im obigen Test eine Nachricht auf dem Nachrichtenbus veröffentlicht wird, wird sie vom Bus in einem anderen Thread an den Handler übermittelt.  Wenn ein Unit-Test-Tool wie JUnit einen Test ausführt, weiß es nichts über Nachrichtenbusflüsse.  JUnit kennt nur den Hauptthread, in dem der Test ausgeführt wird.  Während der Nachrichtenbus damit beschäftigt ist, die Nachricht zuzustellen, schließt der Test die Ausführung im Haupttest-Thread ab und JUnit meldet den Erfolg.  Wie kann man das lösen?  Wir benötigen den Haupttest-Thread, um darauf zu warten, dass der Nachrichtenbus unsere Nachricht übermittelt.  Fügen wir also eine Schlafanweisung hinzu: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); }; messageBus.publish(msg); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Unser Test ist grün und der Ausdruck "Erhalten" wird wie erwartet gedruckt.  Cool!  Aber eine Sekunde Schlaf bedeutet, dass unser Test mindestens eine Sekunde lang durchgeführt wird und nichts Gutes darin ist.  Wir könnten die Schlafzeit verkürzen, aber dann laufen wir Gefahr, den Test abzuschließen, bevor wir eine Nachricht erhalten.  Wir brauchen eine Möglichkeit, um zwischen dem Haupttest-Thread und dem Message-Handler-Thread zu koordinieren.  Wenn wir uns das Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">java.util.concurrent</a> ansehen, werden wir sicher finden, was wir verwenden können.  Was ist mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CountDownLatch</a> ? <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); latch.countDown(); }; messageBus.publish(msg); latch.await();</code> </pre> <br>  Bei diesem Ansatz teilen wir den CountDownLatch zwischen dem Haupttest-Thread und dem Message-Handler-Thread.  Der Haupt-Thread muss auf den Blocker warten.  Der Test-Thread gibt den ausstehenden Haupt-Thread frei, indem er nach dem Empfang der Nachricht countDown () auf dem Blocker aufruft.  Wir müssen keine Sekunde mehr schlafen.  Unser Test dauert genau so lange wie nötig. <br><br><h2>  So glücklich? </h2><br>  Mit unserem neuen Charme, CountDownLatch, beginnen wir, Multithread-Tests zu schreiben, wie die neuesten Fashionistas.  Aber ziemlich schnell stellen wir fest, dass einer unserer Testfälle für immer blockiert ist und nicht endet.  Was ist los?  Stellen Sie sich das Nachrichtenbus-Szenario vor: Der Blocker lässt Sie warten, wird jedoch erst nach Empfang der Nachricht freigegeben.  Wenn der Bus nicht funktioniert und die Nachricht nie zugestellt wird, wird der Test niemals beendet.  Fügen wir dem Blocker also eine Zeitüberschreitung hinzu: <br><br><pre> <code class="java hljs">latch.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);</code> </pre> <br>  Ein blockierter Test schlägt nach 1 Sekunde mit einer TimeoutException-Ausnahme fehl.  Am Ende werden wir das Problem finden und den Test beheben, aber entscheiden, die Zeitüberschreitungen beizubehalten.  Sollte dies jemals wieder vorkommen, würden wir es vorziehen, wenn unser Test für eine Sekunde gesperrt und abgestürzt wird, als für immer zu blockieren und überhaupt nicht abgeschlossen zu werden. <br>  Ein weiteres Problem, das wir beim Schreiben von Tests bemerken, ist, dass sie alle zu bestehen scheinen, auch wenn sie es wahrscheinlich nicht sollten.  Wie ist das möglich?  Betrachten Sie den Nachrichtenverarbeitungstest erneut: <br><br><pre> <code class="java hljs">messageBus.registerHandler(message -&gt; { assertEquals(message, msg); latch.countDown(); };</code> </pre> <br>  Wir hätten CountDownLatch verwenden sollen, um den Abschluss unseres Tests mit dem Haupttest-Thread zu koordinieren, aber was ist mit Asserts?  Wenn die Validierung fehlschlägt, weiß JUnit davon?  Es stellt sich heraus, dass fehlerhafte Überprüfungen von JUnit völlig unbemerkt bleiben, da wir im Haupttest-Thread keine Validierung durchführen.  Versuchen wir ein kleines Skript, um dies zu testen: <br><br><pre> <code class="java hljs">CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); latch.countDown(); }).start(); latch.await();</code> </pre> <br>  Der Test ist grün!  Was machen wir jetzt?  Wir benötigen eine Möglichkeit, Testfehler vom Message-Handler-Stream an den Haupttest-Stream zurückzusenden.  Wenn im Message-Handler-Thread ein Fehler auftritt, muss er im Haupt-Thread erneut angezeigt werden, damit der Test wie erwartet umgedreht wird.  Versuchen wir Folgendes: <br><br><pre> <code class="java hljs">CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); AtomicReference&lt;AssertionError&gt; failure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AtomicReference&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AssertionError e) { failure.set(e); } latch.countDown(); }).start(); latch.await(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (failure.get() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> failure.get();</code> </pre> <br>  Schnellstart und ja, der Test schlägt fehl, wie es sollte!  Jetzt können wir zurückgehen und CountDownLatches, try / catch und AtomicReference-Blöcke zu allen unseren Testfällen hinzufügen.  Cool!  Eigentlich nicht cool, es sieht aus wie ein Boilerplate. <br><br><h2>  Schneiden Sie den Müll aus </h2><br>  Im Idealfall benötigen wir eine API, mit der wir die ausstehende, überprüfende und wiederaufnehmende Ausführung zwischen Threads koordinieren können, damit Komponententests wie erwartet bestanden werden oder fehlschlagen können, unabhängig davon, wo die Prüfung fehlschlägt.  Glücklicherweise bietet ConcurrentUnit ein leichtes Framework, das genau das tut: Kellner.  Lassen Sie uns den obigen Nachrichtenverarbeitungstest zum letzten Mal anpassen und sehen, was Waiter von ConcurrentUnit für uns tun kann: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; Waiter waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Waiter(); messageBus.registerHandler(message -&gt; { waiter.assertEquals(message, msg); waiter.resume(); }; messageBus.publish(msg); waiter.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);</code> </pre> <br>  In diesem Test sehen wir, dass der Kellner den Platz unseres CountDownLatch und unserer AtomicReference eingenommen hat.  Mit Waiter blockieren wir den Haupttest-Thread, führen den Test durch und setzen dann den Haupttest-Thread fort, damit der Test abgeschlossen werden kann.  Wenn die Prüfung fehlschlägt, wird durch Aufrufen von waiter.await die Sperre automatisch aufgehoben und ein Fehler ausgelöst, der dazu führt, dass der Test bestanden wird oder fehlschlägt, selbst wenn die Prüfung von einem anderen Thread aus durchgeführt wurde. <br><br><h2>  Noch paralleler </h2><br>  Nachdem wir zertifizierte Multithread-Tester geworden sind, möchten wir möglicherweise bestätigen, dass mehrere asynchrone Aktionen ausgeführt werden.  Der Kellner von ConcurrentUnit macht dies einfach: <br><br><pre> <code class="java hljs">Waiter waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Waiter(); messageBus.registerHandler(message -&gt; { waiter.resume(); }; messageBus.publish(<span class="hljs-string"><span class="hljs-string">"one"</span></span>); messageBus.publish(<span class="hljs-string"><span class="hljs-string">"two"</span></span>); waiter.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Hier veröffentlichen wir zwei Nachrichten auf dem Bus und überprüfen, ob beide Nachrichten zugestellt wurden. Der Kellner wartet darauf, dass resume () zweimal aufgerufen wird.  Wenn keine Nachrichten zugestellt werden und der Lebenslauf nicht innerhalb von 1 Sekunde zweimal aufgerufen wird, schlägt der Test mit einem TimeoutException-Fehler fehl. <br>  Ein allgemeiner Tipp bei diesem Ansatz ist, sicherzustellen, dass Ihre Zeitüberschreitungen lang genug sind, um alle gleichzeitigen Aktionen auszuführen.  Wenn das zu testende System unter normalen Bedingungen wie erwartet funktioniert, spielt das Zeitlimit keine Rolle und wird nur im Falle eines Systemausfalls aus irgendeinem Grund wirksam. <br><br><h2>  Zusammenfassung </h2><br>  In diesem Artikel haben wir gelernt, dass Multithread-Unit-Tests nicht böse sind und ziemlich einfach durchzuführen sind.  Wir haben den allgemeinen Ansatz kennengelernt, wenn wir den Haupttest-Thread blockieren, Überprüfungen von einigen anderen Threads durchführen und dann den Haupt-Thread fortsetzen.  Und wir haben etwas über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ConcurrentUnit</a> gelernt, das diese Aufgabe erleichtern kann. <br>  Viel Spaß beim Testen! <br><br>  <b>Übersetzt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472152/">https://habr.com/ru/post/de472152/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472128/index.html">Warum mag ich PHP?</a></li>
<li><a href="../de472130/index.html">Wie kann ein Amoklauf des Unternehmens verhindert werden?</a></li>
<li><a href="../de472138/index.html">Digitalisierung der Bildung</a></li>
<li><a href="../de472144/index.html">Pfeifen Sie alle auf Linux, Donner und Blitz</a></li>
<li><a href="../de472148/index.html">Retrogaming: PAL gegen NTSC. Oder warum PAL nicht benötigt wird</a></li>
<li><a href="../de472154/index.html">Wie Sie das Budget für die Serienproduktion von Gebäuden 2 nicht verpassen sollten: Preise für kleine Kunststoffformteile</a></li>
<li><a href="../de472156/index.html">Implementieren des Seitenobjektmusters in Python + pytest</a></li>
<li><a href="../de472158/index.html">"Der Bildungsprozess in der IT und nicht nur": Technologiewettbewerbe und Veranstaltungen der ITMO University</a></li>
<li><a href="../de472160/index.html">Phantom OS: Fenstersubsystem - Steuerelemente ausführen</a></li>
<li><a href="../de472162/index.html">Ausgelagertes E-Mail-Marketing: Wie man baut und was man erwartet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>