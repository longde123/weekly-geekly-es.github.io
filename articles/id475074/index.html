<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👒 👨🏿‍🍳 🧑‍🤝‍🧑 Pengantar ECMAScript 2017 (ES8) 💅🏻 🧀 ⛱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Daftar isi 
 Kata Pengantar 
 Ikhtisar ES7 
 1. Objek 
 2. Nilai Objek 
 3. String.prototype.padEnd 
 4. String.prototype.padStart 
 5. Object.getOwnP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar ECMAScript 2017 (ES8)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475074/"><h4>  Daftar isi </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kata Pengantar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ikhtisar ES7</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Objek</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. Nilai Objek</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. String.prototype.padEnd</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. String.prototype.padStart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Object.getOwnPropertyDescriptor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. Membuntuti koma</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. SharedArrayBuffer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8. Atom</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9. Fungsi-fungsi Async</a> <br><br><a name="section000"></a><h2>  Kata Pengantar </h2><br>  Halo, di masa lalu saya sudah mempertimbangkan inovasi dalam ES6 dan sekarang saatnya untuk membongkar ES8 karena membawa banyak hal baru.  Saya tidak mempertimbangkan ES7 (2016) secara terpisah, karena rilis ini hanya membawa 2 inovasi.  Ini adalah Array.prototype.includes () dan operator eksponensial.  Tapi tetap saja, sebelum memulai ES8, mari kita lihat inovasi dari ES7. <br><br><a name="section0000"></a><h2>  Ikhtisar ES7 </h2><br>  <b>Metode include ()</b> menentukan apakah array berisi elemen tertentu, mengembalikan benar atau salah tergantung pada ini. <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.includes(searchElement[, fromIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>]) : <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span></code> </pre> <br>  searchElement - Item yang akan dicari. <br><br>  fromIndex - Posisi dalam larik tempat mulai mencari elemen searchElement.  Untuk nilai negatif, pencarian dilakukan mulai dengan larik indeks. Panjang + dariIndeks naik.  Nilai standarnya adalah 0. <a name="habracut"></a><br><br>  <b>Contohnya</b> <br><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].includes(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true [1, 2, 3].includes(4); // false [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true [1, 2, NaN].includes(NaN); // true</span></span></code> </pre> <br>  mencakup () dapat diterapkan ke jenis objek lainnya (misalnya, objek mirip array).  Contoh: menggunakan metode include () pada objek argumen. <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([].includes.call(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true console.log([].includes.call(arguments, 'd')); // false })('a','b','c');</span></span></code> </pre> <br>  <b>Operator eksponensial</b> (**) mengembalikan daya dengan basis a dan eksponen alami b.  Meningkatkan ke kekuatan b. <br><br><pre> <code class="javascript hljs">a ** b</code> </pre> <br>  <b>Contohnya</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">2</span></span> ** <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">// 8 3 ** 2 // 9 3 ** 2.5 // 15.588457268119896 10 ** -1 // 0.1 NaN ** 2 // NaN 2 ** 3 ** 2 // 512 2 ** (3 ** 2) // 512 (2 ** 3) ** 2 // 64 -(2 ** 2) // -4 (-2) ** 2 // 4</span></span></code> </pre> <br><a name="section001"></a><h2>  1. Objek </h2><br>  Object.entries () mengembalikan array yang elemen-elemennya adalah array yang sesuai dengan properti enumerated dari pasangan [key, value] yang ditemukan langsung di objek.  Urutan properti adalah sama seperti ketika Anda menggilir properti suatu objek secara manual. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj) : <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span></code> </pre> <br>  obj - Objek yang properti enumerasinya akan dikembalikan sebagai array [kunci, nilai]. <br><br>  Object.entries () mengembalikan properti dalam urutan yang sama seperti pada for ... in loop (perbedaannya adalah bahwa untuk-in juga mencantumkan properti dari rantai prototipe).  Urutan elemen dalam larik yang dikembalikan Object.entries () tidak bergantung pada bagaimana objek dideklarasikan.  Jika urutan tertentu diperlukan, maka array harus diurutkan sebelum metode dipanggil. <br><br>  <b>Contohnya</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj)); <span class="hljs-comment"><span class="hljs-comment">// [ ['foo', 'bar'], ['baz', 42] ] //    var obj = { 0: 'a', 1: 'b', 2: 'c' }; console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ] //    c random   var an_obj = { 100: 'a', 2: 'b', 7: 'c' }; console.log(Object.entries(an_obj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ] // getFoo  ,    var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } }); my_obj.foo = "bar"; console.log(Object.entries(my_obj)); // [ ['foo', 'bar'] ] // non-object     object console.log(Object.entries("foo")); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ] let obj = { one: 1, two: 2 }; for (let [k,v] of Object.entries(obj)) console.log(`${JSON.stringify(k)}: ${JSON.stringify(v)}`) // "one": 1 // "two": 2</span></span></code> </pre> <br>  <b>Konversi Objek ke Peta</b> <br><br>  Konstruktor Map () baru menerima pengulangan nilai.  Dengan Object.entries, Anda dapat dengan mudah mengkonversi Obyek ke Peta.  Ini lebih ringkas daripada menggunakan array 2 elemen array, tetapi kunci hanya bisa berupa string. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(map); <span class="hljs-comment"><span class="hljs-comment">// Map {"foo" =&gt; "bar", "baz" =&gt; 42}</span></span></code> </pre> <br>  Mengapa nilai pengembalian Object.entries () array dan bukan iterator? <br>  Kasus penggunaan yang sesuai dalam kasus ini adalah Object.keys (), dan bukan, misalnya, Map.prototype.entries (). <br><br>  Mengapa Object.entries () mengembalikan hanya properti enumerasi enumerated dengan kunci string? <br><br>  Sekali lagi, ini dilakukan untuk mencocokkan Object.keys ().  Metode ini juga mengabaikan properti yang kuncinya adalah karakter.  Pada akhirnya, mungkin ada metode Reflect.ownEntries () yang mengembalikan semua propertinya sendiri. <br><br>  Lihat object.entries dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">spesifikasi</a> resmi, serta di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">MDN Web Documents</a> . <br><br><a name="section002"></a><h2>  2. Nilai Objek </h2><br>  Object.values ​​() mengembalikan array yang elemen-elemennya adalah nilai-nilai dari properti yang disebutkan yang ditemukan dalam objek.  Urutannya sama seperti jika Anda menggilir objek secara manual. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(obj) : <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span></code> </pre> <br>  obj - Objek yang nilainya dari properti yang disebutkan akan dikembalikan. <br><br>  Metode Object.values ​​() mengembalikan array nilai properti enumerasi objek dalam urutan yang sama dengan for ... in loop.  Perbedaan antara loop dan metode adalah bahwa loop mendaftar properti dari dan dari rantai prototipe. <br><br>  <b>Contohnya</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(obj)); <span class="hljs-comment"><span class="hljs-comment">// ['bar', 42] //    var obj = { 0: 'a', 1: 'b', 2: 'c' }; console.log(Object.values(obj)); // ['a', 'b', 'c']</span></span></code> </pre><br>  Perbedaan antara Object.entries dan Object.values ​​() adalah bahwa yang pertama mengembalikan array yang berisi nama dan nilai properti, sedangkan yang kedua hanya mengembalikan array dengan nilai properti. <br><br>  <b>Contoh perbedaan antara Object.values ​​() dan Object.entries ()</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-string"><span class="hljs-string">'somestring'</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(object)); <span class="hljs-comment"><span class="hljs-comment">// ["somestring", 42, false] console.log(Object.entries(object)); // [ ["a", "somestring"], ["b", 42], ["c", false] ]</span></span></code> </pre> <br>  Lihat Object.values ​​() dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">spesifikasi</a> resmi, serta di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">MDN Web Documents</a> . <br><br><a name="section003"></a><h2>  3. String.prototype.padEnd </h2><br>  Metode padEnd () melengkapi baris saat ini dengan string yang diberikan (akhirnya berulang) sehingga string yang dihasilkan mencapai panjang yang ditentukan.  Penambahan diterapkan di ujung (kanan) dari baris saat ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.prototype.padEnd(maxLength [ , fillString ]) : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br>  maxLength - Panjang baris yang dihasilkan setelah baris saat ini telah diisi.  Jika parameter ini kurang dari panjang garis saat ini, garis saat ini akan dikembalikan apa adanya. <br>  fillString - Sebuah string untuk melengkapi baris saat ini dengan.  Jika baris ini terlalu panjang, akan terpotong dan paling kiri akan diterapkan.  "" (0x0020 SPACE) adalah nilai default untuk parameter ini. <br><br>  <b>Contohnya</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'abc'</span></span>.padEnd(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "abc " 'abc'.padEnd(10, "foo"); // "abcfoofoof" 'abc'.padEnd(6,"123456"); // "abc123"</span></span></code> </pre> <br>  Gunakan kasus untuk mengisi string meliputi: <br><br><ul><li>  Menambahkan penghitung atau pengidentifikasi ke nama file atau URL: 'file 001.txt' </li><li>  Penyelarasan Keluaran Konsol: “Test 001: ✓” </li><li>  Cetak angka heksadesimal atau biner dengan angka digit tetap: '0x00FF' </li></ul><br>  Lihat String.prototype.padEnd dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">spesifikasi</a> resmi, serta di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">MDN Web Documents</a> . <br><br><a name="section004"></a><h2>  4. String.prototype.padStart </h2><br>  Metode padStart () mengisi baris saat ini dengan baris lain (beberapa kali, jika perlu) sehingga garis yang dihasilkan mencapai panjang yang ditentukan.  Pengisian dilakukan di awal (kiri) dari garis saat ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.prototype.padStart(maxLength [, fillString]) : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br>  maxLength - Panjang garis ringkasan setelah selesainya garis saat ini.  Jika nilainya kurang dari panjang garis saat ini, garis saat ini akan dikembalikan tidak berubah. <br><br>  fillString - String untuk mengisi baris saat ini.  Jika string ini terlalu panjang untuk panjang yang diberikan, itu akan dipotong.  Nilai standarnya adalah "" (0x0020 SPACE). <br><br>  <b>Contohnya</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'abc'</span></span>.padStart(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// " abc" 'abc'.padStart(10, "foo"); // "foofoofabc" 'abc'.padStart(6,"123465"); // "123abc" 'abc'.padStart(8, "0"); // "00000abc" 'abc'.padStart(1); // "abc"</span></span></code> </pre> <br>  Mengapa metode padding tidak disebut padLeft dan padRight? <br><br>  Untuk bahasa dua arah atau kanan-ke-kiri, istilah "kiri" dan "kanan" tidak berfungsi.  Oleh karena itu, penamaan padStart dan padEnd mengikuti nama-nama yang ada mulai dengan beginWith dan berakhirWith. <br><br>  Lihat String.prototype.padStart dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">spesifikasi</a> resmi, serta di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">MDN Web Documents</a> . <br><br><a name="section005"></a><h2>  5. Object.getOwnPropertyDescriptor </h2><br>  Metode Object.getOwnPropertyDescriptor () mengembalikan deskriptor properti untuk propertinya sendiri (yaitu, yang terletak langsung di objek, dan tidak diterima melalui rantai prototipe) dari objek yang dikirimkan.  Jika properti tidak ada, pengembalian tidak ditentukan. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(obj, prop) : <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span></code> </pre> <br>  obj - Objek di mana properti dicari. <br><br>  prop - Nama properti yang uraiannya akan dikembalikan. <br><br>  Metode ini memungkinkan Anda untuk melihat deskripsi properti yang tepat.  Properti dalam JavaScript terdiri dari nama string dan deskriptor properti. <br><br>  Deskriptor properti adalah catatan dengan beberapa atribut berikut: <br><br><ul><li>  value - Nilai yang terkait dengan properti (hanya dalam deskriptor data). </li><li>  dapat ditulis - benar jika nilai yang terkait dengan properti dapat diubah, jika tidak palsu (hanya dalam deskriptor data). </li><li>  get - Fungsi yang mengembalikan nilai properti, atau tidak terdefinisi jika tidak ada fungsi seperti itu (hanya di deskriptor akses). </li><li>  set - Fungsi yang mengubah nilai properti, atau tidak terdefinisi jika tidak ada fungsi seperti itu (hanya di deskriptor akses). </li><li>  dapat dikonfigurasi - benar jika jenis pegangan properti ini dapat diubah dan jika properti dapat dihapus dari objek yang mengandungnya, jika tidak palsu. </li><li>  enumerable - true jika properti ini tersedia saat mendaftar properti dari objek yang mengandungnya, jika tidak salah. </li></ul><br>  <b>Contohnya</b> <br><br><pre> <code class="javascript hljs">obj = { get foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; } }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// {set: undefined, enumerable: true, configurable: true, get: ƒ} obj2 = { bar: 42 }; console.log(Object.getOwnPropertyDescriptor(obj2, 'bar')); // {value: 42, writable: true, enumerable: true, configurable: true}</span></span></code> </pre> <br><h4>  Gunakan case untuk Object.getOwnPropertyDescriptor () </h4><br>  Kasus penggunaan <b>pertama</b> : menyalin properti ke objek <br>  Dimulai dengan ES6, JavaScript sudah memiliki metode alat untuk menyalin properti: Object.assign ().  Namun, metode ini menggunakan sederhana dan mengatur operasi untuk menyalin properti yang kuncinya adalah kunci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = source[key]; <span class="hljs-comment"><span class="hljs-comment">// get target[key] = value; // set</span></span></code> </pre>  Ini berarti bahwa itu tidak benar menyalin properti dengan atribut selain yang ditentukan secara default (metode untuk memperoleh, mengatur, menulis, dll.).  Contoh berikut menggambarkan batasan ini.  Sumber objek memiliki installer yang kuncinya adalah foo: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> source = { set foo(value) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(value); } }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(source, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// { get: undefined, set: [Function: foo], enumerable: true, configurable: true }</span></span></code> </pre> <br>  Menggunakan Object.assign () untuk menyalin properti foo ke objek target gagal: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target1 = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(target1, source); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(target1, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// { value: undefined, writable: true, enumerable: true, configurable: true }</span></span></code> </pre>  Untungnya, menggunakan Object.getOwnPropertyDescriptors () bersama dengan Object.defineProperties () berfungsi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target2 = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(target2, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(source)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(target2, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// { get: undefined, set: [Function: foo], enumerable: true, configurable: true }</span></span></code> </pre> <br>  Kasus penggunaan <b>kedua</b> : objek kloning <br>  Kloning dangkal mirip dengan menyalin properti, jadi Object.getOwnPropertyDescriptors () juga merupakan pilihan yang baik di sini. <br><br>  Kali ini kami menggunakan Object.create (), yang memiliki dua parameter: <br>  Parameter pertama menentukan prototipe objek yang dikembalikan. <br><br>  Parameter kedua opsional adalah kumpulan deskriptor properti, mirip dengan yang dikembalikan oleh Object.getOwnPropertyDescriptors (). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clone = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(obj), <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(obj));</code> </pre> <br>  Kasus penggunaan <b>ketiga</b> : objek lintas-platform literal dengan prototipe sewenang-wenang. <br><br>  Cara terbaik secara sintaksis untuk menggunakan objek literal untuk membuat objek dengan prototipe arbitrer adalah dengan menggunakan properti __proto__ khusus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: prot, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, };</code> </pre> <br>  Sayangnya, fitur ini dijamin hanya ada di browser.  Solusi umum adalah Object.create () dan tugas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prot); obj.foo = <span class="hljs-number"><span class="hljs-number">123</span></span>;</code> </pre> <br>  Tetapi Anda juga dapat menggunakan Object.getOwnPropertyDescriptors (): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create( prot, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors({ <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, }) );</code> </pre> <br>  Alternatif lain adalah Object.assign (): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign( <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prot), { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, } );</code> </pre> <br>  Pitfall: menyalin metode menggunakan super. <br><br>  Metode yang super gunakan terikat erat pada objek asalnya (objek tempat penyimpanannya).  Saat ini tidak ada cara untuk menyalin atau memindahkan metode seperti itu ke objek lain. <br><br>  Lihat Object.getOwnPropertyDescriptor dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">spesifikasi</a> resmi, serta di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">MDN Web Documents</a> . <br><br><a name="section006"></a><h2>  6. Membuntuti koma </h2><br>  Menggantung koma (Trailing koma) - dapat berguna saat menambahkan elemen, parameter, atau properti baru ke kode JavaScript.  Jika Anda ingin menambahkan properti baru, Anda cukup menambahkan baris baru tanpa mengubah yang sebelumnya, jika koma menggantung sudah digunakan di dalamnya.  Ini membuat perbedaan dalam kontrol versi pembersih dan perubahan kode bisa kurang merepotkan. <br><br><h4>  Menggantung koma dalam literal </h4><br>  <b>Array</b> <br><br>  JavaScript mengabaikan menggantung koma dalam array: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [0, 1, 2] console.log(arr.length); // 3 var arr2 = [0, 1, 2,,,]; console.log(arr2.length); // 5 arr2.forEach((e) =&gt; console.log(e)); // 0 1 2 console.log(arr.map((e) =&gt; e)); // 0 1 2</span></span></code> </pre> <br>  Jika lebih dari satu titik menggantung digunakan, lubang akan dibuat.  Array dengan "lubang" disebut jarang (array padat tidak memiliki "lubang").  Ketika iterasi array menggunakan, misalnya, Array.prototype.forEach () atau Array.prototype.map (), lubang akan dilewati. <br><br>  <b>Benda-benda</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">"qwerty"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object); <span class="hljs-comment"><span class="hljs-comment">// {foo: "bar", baz: "qwerty", age: 42}</span></span></code> </pre> <br><h4>  Menggantung koma dalam fungsi </h4><br>  <b>Definisi Parameter</b> <br><br>  Definisi parameter fungsi berikut ini valid dan setara satu sama lain.  Menggantung koma tidak memengaruhi properti panjang fungsi atau objek argumennya. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">) </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p,</span></span></span><span class="hljs-function">) </span></span>{} (p) =&gt; {}; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p,</span></span></span><span class="hljs-function">) =&gt;</span></span> {};</code> </pre> <br>  <b>Definisi metode</b> <br><br>  Koma gantung juga berfungsi dengan mendefinisikan metode untuk kelas atau objek. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ one(a,) {}, two(a, b,) {}, } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { one(a,) {}, two(a, b,) {}, };</code> </pre> <br>  <b>Panggilan fungsi</b> <br><br>  Panggilan fungsi berikut ini valid dan setara satu sama lain. <br><br><pre> <code class="javascript hljs">f(p); f(p,); <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>,);</code> </pre> <br>  <b>Koma gantung tidak valid</b> <br><br>  Menentukan parameter fungsi atau memanggil fungsi yang hanya berisi koma akan memunculkan SyntaxError.  Selain itu, saat menggunakan parameter yang tersisa, menggantung koma tidak diperbolehkan. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function">) </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// SyntaxError: missing formal parameter (,) =&gt; {}; // SyntaxError: expected expression, got ',' f(,) // SyntaxError: expected expression, got ',' function f(...p,) {} // SyntaxError: parameter after rest parameter (...p,) =&gt; {} // SyntaxError: expected closing parenthesis, got ','</span></span></code> </pre> <br><h4>  Menggantung Koma dalam Destrukturisasi </h4><br>  Menggantung koma juga dapat digunakan di sebelah kiri saat menggunakan tugas yang merusak. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      [a, b,] = [1, 2]; //      var o = { p: 42, q: true, }; var {p, q,} = o;</span></span></code> </pre> <br>  Sekali lagi, menggunakan parameter yang tersisa, sebuah SyntaxError akan dilempar. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> [a, ...b,] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Uncaught SyntaxError: Rest element must be last element</span></span></code> </pre> <br><h4>  JSON Menggantung Koma </h4><br>  Menggantung koma di objek hanya diperbolehkan dalam ECMAScript 5. Karena JSON didasarkan pada sintaksis JavaScript yang lebih tua dari ES5, <b>koma menggantung</b> tidak diizinkan <b>di JSON.</b> <br><br>  Kedua baris melempar SyntaxError <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(<span class="hljs-string"><span class="hljs-string">'[1, 2, 3, 4, ]'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(<span class="hljs-string"><span class="hljs-string">'{"foo" : 1, }'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Uncaught SyntaxError: Unexpected token ] in JSON // Uncaught SyntaxError: Unexpected token } in JSON</span></span></code> </pre> <br><h4>  Mengapa menggantung koma bermanfaat? </h4><br>  Ada dua manfaatnya. <br><br>  Pertama, mengatur ulang elemen lebih mudah karena Anda tidak perlu menambah atau menghapus koma jika elemen terakhir mengubah posisinya. <br><br>  Kedua, ini membantu sistem kontrol versi melacak apa yang benar-benar berubah.  Misalnya, dari: <br><br><pre> <code class="plaintext hljs">[ 'Foo' ] : [ 'Foo', '' ]</code> </pre> <br>  menyebabkan baris dengan 'foo' dan baris dengan 'bar' ditandai sebagai diubah, meskipun satu-satunya perubahan nyata adalah menambahkan baris terakhir. <br><br>  Lihat Melacak koma di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">MDN Web Documents</a> . <br><br><a name="section007"></a><h2>  7. SharedArrayBuffer </h2><br>  Objek SharedArrayBuffer digunakan untuk membuat buffer split dengan panjang tetap untuk menyimpan data biner primitif, mirip dengan objek ArrayBuffer, tetapi sebaliknya, instance SharedArrayBuffer dapat digunakan untuk membuat tampilan pada memori bersama.  SharedArrayBuffer tidak dapat diputus. <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(length) : <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span></code> </pre>  length - Ukuran, dalam byte, untuk membuat array buffer. <br><br>  kembali - Objek SharedArrayBuffer baru dengan panjang yang ditentukan.  Isinya setelah inisialisasi adalah 0. <br><br>  PostMessage dan kloning terstruktur digunakan untuk membagi memori menggunakan objek SharedArrayBuffer antara satu agen di cluster dan yang lain (agen dapat berupa program utama halaman web atau salah satu pekerja web). <br><br>  Algoritma kloning terstruktur menerima SharedArrayBuffers dan TypedArrays yang dipetakan ke SharedArrayBuffers.  Dalam kedua kasus, objek SharedArrayBuffer diteruskan ke penerima, yang membuat objek SharedArrayBuffer pribadi baru di dalam agen penerima (sama seperti untuk ArrayBuffer).  Namun, blok data bersama yang dirujuk oleh kedua objek SharedArrayBuffer adalah blok data yang sama, dan efek pihak ketiga di blok di salah satu agen akhirnya akan terlihat di agen lain. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sab = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(<span class="hljs-number"><span class="hljs-number">1024</span></span>); worker.postMessage(sab);</code> </pre> <br>  Memori bersama dapat dibuat dan diubah secara bersamaan di pekerja atau utas utama.  Bergantung pada sistem (CPU, OS, browser), mungkin perlu waktu hingga perubahan disebarkan ke semua konteks.  Untuk sinkronisasi, operasi atom diperlukan. <br><br>  Buffer Array Bersama adalah blok bangunan primitif untuk abstraksi paralelisme tingkat yang lebih tinggi.  Mereka memungkinkan Anda untuk berbagi byte dari objek SharedArrayBuffer antara beberapa pekerja dan utas utama (buffer dibagi untuk mengakses byte, membungkusnya dalam Typed Array).  Jenis pertukaran ini memiliki dua keunggulan: <br>  Anda dapat bertukar data antar pekerja lebih cepat. <br><br>  Koordinasi antar pekerja menjadi lebih mudah dan lebih cepat (dibandingkan dengan postMessage ()). <br><br>  Implementasi pekerja adalah sebagai berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// worker.js self.addEventListener ('message', function (event) { const {sharedBuffer} = event.data; const sharedArray = new Int32Array (sharedBuffer); // ··· });</span></span></code> </pre><br>  Pertama, kami mengekstrak buffer array bersama yang dikirim kepada kami, dan kemudian membungkusnya dalam array yang diketik sehingga kami dapat menggunakannya secara lokal. <br><br>  <b>Properti dan metode SharedArrayBuffer.</b> <br><br>  SharedArrayBuffer.length - Panjang konstruktor SharedArrayBuffer yang nilainya 1. <br>  SharedArrayBuffer.prototype - Memungkinkan properti tambahan untuk semua objek SharedArrayBuffer. <br><br>  <b>Mesin Virtual SharedArrayBuffer</b> <br>  <b>Sifat-sifat</b> <br><br>  SharedArrayBuffer.prototype.constructor - Menentukan fungsi yang membuat prototipe objek.  Nilai awal adalah konstruktor SharedArrayBuffer bawaan bawaan. <br><br>  SharedArrayBuffer.prototype.byteLength (Hanya baca) - Ukuran array dalam byte.  Ini diatur ketika array dibuat dan tidak dapat diubah. <br><br>  <b>Metode</b> <br><br>  SharedArrayBuffer.prototype.slice () - Mengembalikan SharedArrayBuffer baru yang isinya adalah salinan dari byte dari SharedArrayBuffer ini dari awal, termasuk hingga akhir, eksklusif.  Jika awal atau akhir negatif, ini merujuk pada indeks dari akhir array, bukan dari awal.  Metode ini memiliki algoritma yang sama dengan Array.prototype.slice (). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  SharedArrayBuffer     const buffer = new SharedArrayBuffer(16); const int32View = new Int32Array(buffer); //  view // produces Int32Array [0, 0, 0, 0] int32View[1] = 42; const sliced = new Int32Array(buffer.slice(4,12)); console.log(sliced); // Int32Array [42, 0]</span></span></code> </pre> <br><pre> <code class="javascript hljs">sab.slice([begin, end]) : <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span></code> </pre> <br>  begin - Indeks nol di mana ekstraksi dimulai.  Anda dapat menggunakan indeks negatif yang menunjukkan ofset dari akhir urutan.  slice (-2) mengekstraksi dua elemen terakhir secara berurutan.  Jika awal tidak ditentukan, irisan dimulai pada indeks 0. <br>  Akhir - Indeks berbasis nol di mana ekstraksi harus diselesaikan. <br><br>  Misalnya, irisan (1,4) mengambil elemen kedua melalui elemen keempat (elemen dengan indeks 1, 2, dan 3).  Anda dapat menggunakan indeks negatif yang menunjukkan ofset dari akhir urutan.  slice (2, -1) mengambil elemen ketiga melalui elemen kedua terakhir dalam urutan.  Jika ujung dihilangkan, irisan mengambil melalui akhir urutan (sab.byteLength). <br><br>  <b>Contohnya</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sab = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(<span class="hljs-number"><span class="hljs-number">1024</span></span>); sab.slice(); <span class="hljs-comment"><span class="hljs-comment">// SharedArrayBuffer { byteLength: 1024 } sab.slice(2); // SharedArrayBuffer { byteLength: 1022 } sab.slice(-2); // SharedArrayBuffer { byteLength: 2 } sab.slice(0, 1); // SharedArrayBuffer { byteLength: 1 }</span></span></code> </pre> <br>  Lihat SharedArrayBuffer dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">spesifikasi</a> resmi, serta di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">MDN Web Documents</a> . <br><br><a name="section008"></a><h2>  8. Atom </h2><br>  Objek Atom menyediakan operasi atom sebagai metode statis.  Digunakan dengan objek SharedArrayBuffer. <br><br>  Operasi atom dipasang di modul Atomics.  Tidak seperti objek global lainnya, Atomics bukan konstruktor.  Itu tidak dapat digunakan dengan operator baru atau untuk memanggil objek Atomics sebagai fungsi.  Semua properti dan metode Atom adalah statis (seperti objek Matematika, misalnya). <br><br>  Ketika memori dibagi, beberapa utas dapat membaca dan menulis data yang sama ke memori.  Operasi atom menjamin bahwa nilai yang diharapkan akan ditulis dan dibaca, dan operasi selesai sebelum operasi berikutnya dimulai, dan mereka tidak akan terganggu. <br><br><h4>  Sifat-sifat </h4><br>  Atomics [Symbol.toStringTag] - Nilai properti ini adalah Atomics. <br><br><h4>  Metode </h4><br>  <b>Operasi atom</b> <br><br><ul><li>  Atomics.add () - Menambahkan nilai yang disajikan ke yang sekarang pada posisi yang ditentukan dalam array.  Mengembalikan nilai sebelumnya pada posisi ini. </li><li>  Atomics.and () - Menghitung bitwise DAN pada posisi array yang ditentukan.  Mengembalikan nilai sebelumnya pada posisi ini. </li><li>  Atomics.compareExchange () - Menyimpan nilai yang disajikan ke posisi array yang ditentukan, jika setara dengan nilai yang disajikan.  Mengembalikan nilai sebelumnya. </li><li> Atomics.exchange() —       .   . </li><li> Atomics.load() —      . </li><li> Atomics.or() —   OR    .      . </li><li> Atomics.store() —       .  . </li><li> Atomics.sub() —          .      . </li><li> Atomics.xor() —   XOR    .      . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode statis Atomics.add () menambahkan nilai ke yang sekarang pada posisi yang ditentukan dalam array dan mengembalikan nilai sebelumnya pada posisi ini. </font><font style="vertical-align: inherit;">Operasi atom ini memastikan bahwa tidak ada penulisan lain yang terjadi sampai nilai yang diubah ditulis kembali.</font></font><br><br><pre> <code class="javascript hljs">Atomics.add(typedArray, index, value) : mixed</code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typedArray - Array perpecahan bilangan bulat. </font><font style="vertical-align: inherit;">Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array atau Uint32Array.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> index - Posisi di typedArray untuk menambah nilai. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> value - Angka yang akan ditambahkan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> return - Nilai sebelumnya pada posisi yang ditentukan (typedArray [index]). </font></font></li></ul><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Melempar TypeError jika tipe typedArray bukan salah satu dari tipe integer yang valid. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Melempar TypeError jika tipe typedArray bukan tipe generik. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Melempar RangeError jika indeks di luar typedArray. </font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contohnya</font></font></b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sab = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(<span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ta = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(sab); Atomics.add(ta, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  0,   Atomics.load(ta, 0); // 12</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomics.add () dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spesifikasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Web Documents</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tunggu dan beri tahu </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode wait () dan wake () dimodelkan berdasarkan futexes (“fast user-space mutex”) Linux dan menyediakan cara untuk menunggu sesaat ketika keadaan tertentu tidak menjadi kenyataan, dan biasanya digunakan sebagai pemblokiran konstruksi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomics.wait () </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memeriksa </font><font style="vertical-align: inherit;">apakah </font><font style="vertical-align: inherit;">nilai yang masih terwakili terkandung dalam posisi yang ditentukan dari array dan sedang tertunda atau timeout. </font><font style="vertical-align: inherit;">Pengembalian ok, tidak sama, atau habis waktu. </font><font style="vertical-align: inherit;">Jika menunggu tidak diizinkan di agen panggilan, maka itu akan menimbulkan kesalahan pengecualian (sebagian besar browser tidak mengizinkan tunggu () di aliran utama browser).</font></font><br><br><ul><li> Atomics.wait() — ,               -.  «ok», «not-equal»  «timed-out».       ,     (    wait()    ). </li><li> Atomics.wake() —   ,         .   ,   . </li><li> Atomics.isLockFree(size) —  ,            .  true,                 (  ).   . </li></ul><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masalah optimasi </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimalisasi membuat kode tidak dapat diprediksi di antara para pekerja. </font><font style="vertical-align: inherit;">Dalam utas tunggal, kompiler dapat melakukan optimasi yang memecahkan kode multithreaded. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambil, misalnya, kode berikut:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sharedArray [<span class="hljs-number"><span class="hljs-number">0</span></span>] === <span class="hljs-number"><span class="hljs-number">123</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam utas tunggal, nilai sharedArray [0] tidak pernah berubah selama eksekusi loop (jika sharedArray adalah array atau array yang diketik yang belum diperbaiki dengan cara apa pun). </font><font style="vertical-align: inherit;">Karena itu, kode dapat dioptimalkan sebagai berikut:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tmp = sharedArray [<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (tmp === <span class="hljs-number"><span class="hljs-number">123</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, dalam mode multithreaded, optimasi ini tidak memungkinkan kami untuk menggunakan template ini untuk menunggu perubahan yang dibuat di utas lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh lain adalah kode berikut:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// main.js sharedArray [1] = 11; sharedArray [2] = 22;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam satu utas, Anda dapat mengatur ulang operasi penulisan ini karena tidak ada yang terbaca di antara keduanya. </font><font style="vertical-align: inherit;">Beberapa utas mengalami masalah saat Anda mengharapkan rekaman dilakukan dalam urutan tertentu:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// worker.js while (sharedArray [2]! == 22); console.log (sharedArray [1]); // 0  11</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jenis optimasi ini membuat hampir tidak mungkin untuk menyinkronkan tindakan beberapa pekerja yang bekerja pada buffer yang sama dengan array umum. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memecahkan masalah optimisasi </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan variabel global Atomics, yang metodenya memiliki tiga kegunaan utama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasus penggunaan pertama: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinkronisasi. </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode atom dapat digunakan untuk menyinkronkan dengan pekerja lain. </font><font style="vertical-align: inherit;">Misalnya, dua operasi berikut memungkinkan Anda untuk membaca dan menulis data dan tidak pernah disusun ulang oleh kompiler:</font></font><br><br><pre> <code class="javascript hljs">Atomics.load (TypedArray &lt;T&gt;, index) : T Atomics.store (TypedArray &lt;T&gt;, index, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: T) : T</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idenya adalah menggunakan operasi biasa untuk membaca dan menulis sebagian besar data, sementara operasi Atom (memuat, menyimpan, dan lainnya) memastikan bahwa membaca dan menulis aman. Seringkali Anda akan menggunakan mekanisme sinkronisasi Anda sendiri, seperti kunci, yang didasarkan pada Atomics. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah contoh yang sangat sederhana yang selalu berfungsi berkat Atomics (Saya melewatkan pengaturan sharedArray):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// main.js console.log ('notified...'); Atomics.store (sharedArray, 0, 123); // worker.js while (Atomics.load (sharedArray, 0)! == 123); console.log ('notified');</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasus penggunaan kedua: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu pemberitahuan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan loop sementara untuk menunggu pemberitahuan tidak terlalu efisien, sehingga Atomics memiliki operasi yang membantu: Atomics.wait (Int32Array, indeks, nilai, batas waktu) dan Atomics.wake (Int32Array, indeks, hitung). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasus penggunaan ketiga: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operasi atom</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa </font><b><font style="vertical-align: inherit;">operasi</font></b><font style="vertical-align: inherit;"> Atom melakukan aritmatika dan tidak dapat terganggu pada saat yang sama, yang membantu sinkronisasi.</font></font> Sebagai contoh: <br><br><pre> <code class="javascript hljs">Atomics.add (TypedArray &lt;T&gt;, index, value) : T</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara kasar, operasi ini melakukan: index + = value; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah dengan nilai sobekan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efek masalah lain dengan memori bersama adalah nilai robek (sampah): saat membaca, Anda dapat melihat nilai menengah - baik nilai sebelum nilai baru ditulis ke memori, maupun nilai baru. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian Tear-Free Reads dari spesifikasi menyatakan bahwa tidak ada kesenjangan jika dan hanya jika:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baik membaca dan menulis terjadi melalui Typed Array (bukan DataViews). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kedua array yang diketikkan disejajarkan dengan buffer array bersama mereka: sharedArray.byteOffset% sharedArray.BYTES_PER_ELEMENT === 0 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kedua array yang diketik memiliki jumlah byte yang sama per elemen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan kata lain, nilai sobek adalah masalah ketika buffer yang sama dari array bersama diakses melalui: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Satu atau lebih DateViews; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada satu atau lebih array yang tidak selaras; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array diketik dengan berbagai ukuran elemen; </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk menghindari kesenjangan nilai dalam kasus ini, gunakan Atomics atau sinkronisasi. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buffer Array yang Dibagikan dalam Penggunaan </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array yang Dibagikan Buffer dan semantik JavaScript untuk menjalankan fungsi yang tertunda. JavaScript memiliki apa yang disebut semantik eksekusi "sebelum selesai": setiap fungsi dapat berharap bahwa itu tidak akan terganggu oleh utas lain sampai selesai. Fungsi menjadi transaksi dan dapat menjalankan algoritme lengkap, sementara tidak ada yang melihat data yang digunakannya dalam kondisi perantara. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array Bersama Buffer menginterupsi siklus ke penyelesaian (RTC): data yang berfungsi berfungsi dapat diubah oleh utas lainnya selama eksekusi fungsi. Namun, kode sepenuhnya mengontrol apakah pelanggaran RTC ini terjadi: jika tidak menggunakan Buffer Array Bersama, itu aman.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini kira-kira mirip dengan bagaimana fungsi asinkron melanggar RTC. Di sana Anda mengaktifkan operasi kunci menggunakan kata kunci tunggu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array Bersama Buffer memungkinkan emscripten untuk mengompilasi pthreads di asm.js. Mengutip halaman dokumentasi emscripten: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[En] [Buffer Array Bersama memungkinkan] Emscripten aplikasi untuk berbagi tumpukan memori utama antara pekerja web. Ini bersama dengan primitif untuk atom tingkat rendah dan dukungan futex memungkinkan Emscripten untuk mengimplementasikan dukungan untuk API Pthreads (POSIX threads). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Ru] [Buffer Array Bersama memungkinkan] Emscripten aplikasi untuk berbagi banyak memori utama antara pekerja web. Bersamaan dengan primitif atom tingkat rendah dan dukungan futex, Emscripten memungkinkan dukungan untuk Pthreads API (utas POSIX).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artinya, Anda dapat mengkompilasi kode C dan C ++ multithreaded di asm.js. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada diskusi yang sedang berlangsung tentang cara terbaik untuk menggunakan multithreading di WebAssembly. </font><font style="vertical-align: inherit;">Mengingat bahwa pekerja web relatif berat, ada kemungkinan bahwa WebAssembly akan memperkenalkan utas yang ringan. </font><font style="vertical-align: inherit;">Anda juga dapat melihat bahwa topik sedang menuju masa depan WebAssembly.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tukar data selain bilangan bulat </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini, hanya array bilangan bulat (panjang hingga 32 bit) yang dapat digunakan. </font><font style="vertical-align: inherit;">Ini berarti bahwa satu-satunya cara untuk berbagi jenis data lain adalah dengan menyandikannya sebagai bilangan bulat. </font><font style="vertical-align: inherit;">Alat yang dapat membantu termasuk:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TextEncoder dan TextDecoder: yang pertama mengubah string menjadi instance Uint8Array, yang terakhir melakukan yang sebaliknya. </font></font></li><li> stringview.js: ,      .   . </li><li> FlatJS:  JavaScript        (,   )    (ArrayBuffer  SharedArrayBuffer). JavaScript + FlatJS    JavaScript. JavaScript  (TypeScript  . .) . </li><li> TurboScript:  JavaScript-    .    asm.js  WebAssembly. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada akhirnya, ada kemungkinan bahwa mekanisme pertukaran data tambahan - tingkat lebih tinggi - akan muncul. Dan eksperimen akan terus mencari tahu seperti apa mekanisme ini seharusnya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seberapa cepat kode menggunakan buffer Array Bersama berfungsi?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lars T. Hansen menulis dua implementasi dari algoritma Mandelbrot (seperti yang dijelaskan dalam artikelnya “ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Taste of JavaScript's New Parallel Primitives</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”, versi berurutan dan versi paralel yang menggunakan beberapa pekerja web. Hingga 4 pekerja web dan, karenanya, inti prosesor, akselerasi meningkat hampir secara linear, dari 6,9 frame per detik (1 pekerja web) menjadi 25,4 frame per detik (4 pekerja web). Lebih banyak pekerja web membawa peningkatan produktivitas tambahan, tetapi lebih sederhana.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hansen mencatat bahwa akselerasinya sangat mengesankan, tetapi pekerjaan paralelnya disebabkan oleh kode yang lebih kompleks. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informasi tambahan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tentang Buffer Array Bersama dan teknologi pendukung:</font></font><br><br><ul><li> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memori bersama - tutorial singkat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oleh Lars T. Hansen</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Taste of Primitives Paralel Baru JavaScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oleh Lars T. Hansen</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SharedArrayBuffer dan Atomics Stage 2.95 ke Stage 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (PDF), slide oleh Shu-yu Guo dan Lars T. Hansen (2016-11-30) [slide yang menyertai kalimat ES]</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dasar-dasar Pekerja Web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oleh Eric Bidelman [pengantar pekerja web].</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teknologi konkurensi JavaScript lainnya: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalan Menuju JavaScript Paralel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” oleh Dave Herman [tinjauan umum ke mana JavaScript bergerak setelah meninggalkan PJS]</font></font></li><li> “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Write massively-parallel GPU code for the browser with WebGL</a> ” by Steve Sanderson [ , ,   WebGL      GPU]. </li><li> “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Concurrency is not parallelism</a> ” by Rob Pike [Rob Pike   «concurrency»  «parallelism»    ]. </li><li> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Using Web Workers</a> " from MDN [  MDN,      web workers]. </li><li> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Shared memory and atomics</a> " by Axel Rauschmayer [     js   Shared Array Buffers  Atomics] </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lihat Objek Atom dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spesifikasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resmi </font><font style="vertical-align: inherit;">, serta di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Web Documents</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="section009"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Fungsi-fungsi Async </font></font></h2><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat fungsi Async menggunakan konstruktor AsyncFunction </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstruktor AsyncFunction menciptakan objek fungsi async baru. </font><font style="vertical-align: inherit;">Dalam JavaScript, setiap fungsi asinkron sebenarnya adalah objek AsyncFunction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa AsyncFunction bukan objek global. </font><font style="vertical-align: inherit;">Itu dapat diperoleh dengan mengeksekusi kode berikut.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}).constructor</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaks</font></font></b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncFunction([arg1[, arg2[, ...argN]],] functionBody)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arg1, arg2, ... argN - Nama yang digunakan oleh fungsi sebagai nama argumen formal. Setiap nama harus berupa string yang cocok dengan pengidentifikasi JavaScript yang valid atau daftar string yang dipisahkan koma; misalnya, "x," "theValue," atau "a, b." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">functionBody - String yang berisi definisi fungsi dalam kode sumber JavaScript. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek fungsi Async yang dibuat dengan konstruktor AsyncFunction akan diuraikan saat fungsi tersebut dibuat. Ini kurang efisien daripada mendeklarasikan fungsi asinkron menggunakan ekspresi fungsi async dan memanggilnya di dalam kode Anda, karena fungsi tersebut diuraikan dengan sisa kode.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua argumen yang diteruskan ke fungsi diperlakukan sebagai nama pengidentifikasi parameter dalam fungsi yang dibuat dalam urutan yang dilewatkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memanggil konstruktor AsyncFunction sebagai fungsi (tanpa menggunakan operator baru) memiliki efek yang sama dengan memanggilnya sebagai konstruktor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi-fungsi Async yang dibuat menggunakan konstruktor AsyncFunction tidak membuat hubungan pendek ke konteks yang membuatnya; Mereka selalu dibuat dalam lingkup global. Ketika mereka mulai, mereka akan dapat mengakses hanya variabel lokal dan variabel global, tetapi tidak memiliki akses ke ruang lingkup di mana konstruktor AsyncFunction dipanggil. Ini berbeda dari menggunakan eval dengan kode untuk fungsi async. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh membuat fungsi async menggunakan konstruktor AsyncFunction</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveAfter2Seconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(x); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AsyncFunction = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}).constructor <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncFunction(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'return await resolveAfter2Seconds(a) + await resolveAfter2Seconds(b);'</span></span>); a(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(v); <span class="hljs-comment"><span class="hljs-comment">//  30  4  });</span></span></code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deklarasi fungsi Async </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deklarasi fungsi async mendefinisikan fungsi asinkron yang mengembalikan objek AsyncFunction. </font><font style="vertical-align: inherit;">Anda juga dapat menentukan fungsi async menggunakan ekspresi fungsi async. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaks</font></font></b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[param[, param[, ... param]]]</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// body }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">name - Nama fungsi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param - Nama argumen yang akan diteruskan ke fungsi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pernyataan - Ekspresi yang mengandung tubuh fungsi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah panggilan, fungsi async mengembalikan Janji. Ketika hasilnya telah diterima, Janji telah selesai, mengembalikan nilai yang diterima. Saat fungsi async melempar pengecualian, Promise akan gagal dengan nilai throws. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi async dapat berisi ekspresi menunggu yang menghentikan sementara eksekusi fungsi async dan menunggu respons dari Janji yang disahkan, kemudian melanjutkan fungsi async dan mengembalikan nilai yang diterima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata kunci yang menunggu hanya valid dalam fungsi asinkron. Dalam konteks lain, Anda akan mendapatkan kesalahan SyntaxError.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tujuan dari fungsi async / await adalah untuk menyederhanakan penggunaan janji secara serempak dan untuk mereproduksi beberapa tindakan pada kelompok Janji. </font><font style="vertical-align: inherit;">Sama seperti Janji adalah seperti panggilan balik terstruktur, async / menunggu seperti kombinasi generator dan janji.</font></font><br><br>  <b>Contoh</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveAfter2Seconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(x); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> resolveAfter2Seconds(<span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> resolveAfter2Seconds(<span class="hljs-number"><span class="hljs-number">30</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + a + b; } add1(<span class="hljs-number"><span class="hljs-number">10</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(v); <span class="hljs-comment"><span class="hljs-comment">//  60  4  }); async function add2(x) { const a = resolveAfter2Seconds(20); const b = resolveAfter2Seconds(30); return x + await a + await b; } add2(10).then(v =&gt; { console.log(v); //  60  2  });</span></span></code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk apa asinkron? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menulis program JS Anda dalam satu file .js, tetapi kode Anda kemungkinan besar akan dipecah menjadi beberapa bagian. Dan hanya satu bagian yang akan dieksekusi sekarang, dan sisanya akan dieksekusi nanti. Fungsi adalah teknik yang paling sering digunakan untuk membagi program menjadi beberapa bagian. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah utama sebagian besar pengembang yang melihat JS untuk pertama kalinya adalah kurangnya pemahaman tentang apa yang tidak akan terjadi segera setelah sekarang. Dengan kata lain, tugas-tugas yang tidak dapat diselesaikan sekarang, menurut definisi, akan berakhir secara tidak sinkron. Dan kita tidak akan memiliki perilaku pemblokiran dari program yang kita asumsikan. (You-Dont-Know-JS / async &amp; kinerja, Jake Archibald).</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ajax(..)  Ajax-,   var data = ajax( "http://some.url.1" ); console.log( data );// !  `data`     Ajax-</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa kesalahannya di sini? </font><font style="vertical-align: inherit;">console.log () dijalankan sebelum kami menerima data dari permintaan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keputusan yang jelas untuk "menunggu" dari sekarang hingga nanti adalah menggunakan panggilan balik:</font></font><br><br><pre> <code class="javascript hljs">ajax( <span class="hljs-string"><span class="hljs-string">"http://some.url.1"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myCallbackFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( data ); <span class="hljs-comment"><span class="hljs-comment">// ,   ! } );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangkan berbagai metode untuk menyelesaikan eksekusi kode sinkron sebelum waktunya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memiliki 3 fungsi getUser, getPosts, getComments.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { getUser, getPosts, getComments } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./db'</span></span>); getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>, (error, user) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); getPosts(user.id, (error, posts) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); getComments(posts[<span class="hljs-number"><span class="hljs-number">0</span></span>].id, (error, comment) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(comments); }); }); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam contoh ini, sulit untuk tidak melihat piramida, yang meningkat dengan penambahan fungsi baru ke dalamnya. Gaya pengkodean ini biasa disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Callback Hell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini adalah pola tertentu yang memberi Anda kontrol atas permintaan (asinkron) yang bersaing, yang memastikan urutan eksekusi mereka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian dari solusi untuk masalah fungsi bersarang adalah dengan menggunakan Promise (yang saya bahas dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terakhir saya </font><font style="vertical-align: inherit;">, yang menghapusnya dan membuat kode lebih bersih. Mereka juga menyediakan cara yang lebih mudah untuk menangani kesalahan. Tetapi banyak yang tidak menyukai sintaks ini.</font></font><br><br><pre> <code class="javascript hljs">getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> getPosts(user,id)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">posts</span></span></span><span class="hljs-function"> =&gt;</span></span> getComments(posts[<span class="hljs-number"><span class="hljs-number">0</span></span>].id)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">comments</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(comments)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generator menjadi alternatif untuk Promise (yang juga saya periksa di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebelumnya </font><font style="vertical-align: inherit;">. Generator itu sendiri tidak cocok untuk menulis kode asinkron, tetapi jika Anda menggunakannya bersama-sama dengan Promise, kami mendapatkan sesuatu yang unik - kode asinkron yang terlihat sinkron. Pada saat yang sama, generator menyediakan mekanisme penanganan kesalahan yang umum dengan menggunakan coba ... tangkap konstruk. Hanya generator yang memiliki satu minus besar - untuk menggunakannya dengan Janji Anda akan memerlukan fungsi terpisah yang akan mengontrol proses generator A. Anda dapat menulis fungsi ini sendiri atau menggunakan perpustakaan pihak ketiga, misalnya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">co</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dalam contoh ini, saya menulis implementasi saya dari fungsi tersebut.</font></font><br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> posts = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getPosts(user.id); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comments = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getComments(posts[<span class="hljs-number"><span class="hljs-number">0</span></span>].id); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(comments); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); } }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iterator = generator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prev</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { value, done } = iterator.next(prev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) resolve(value); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>) value.then(run, reject); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> run(value); } run(); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap metode bekerja dengan kode asinkron memiliki kelebihan dan kekurangan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi panggilan balik (fungsi Calback) - Mudah digunakan, tetapi dengan peningkatan fungsi yang disarangkan, keterbacaan mulai berkurang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promises (Promises) - Elegan dan nyaman, tetapi sulit bagi pemula untuk mengerti. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generator (Generator) - Memungkinkan Anda untuk menulis kode asinkron secara serempak, tetapi mereka memerlukan fungsi terpisah, dan mekanisme pengoperasian generator sangat rumit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi asinkron dibuat berdasarkan Janji dan Generator, untuk membuat bekerja dengan kode asinkron menjadi sederhana dan mudah dimengerti. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memahami apa fungsi asinkron, pertimbangkan contoh berikut:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user); <span class="hljs-comment"><span class="hljs-comment">// { id: 1 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang jika Anda membuat fungsi asinkron (menambahkan kata kunci async), fungsi tersebut akan mengembalikan Janji yang berisi objek dengan properti id. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user); <span class="hljs-comment"><span class="hljs-comment">// Promise { {id: 1} }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, kita dapat mengatakan bahwa fungsi asinkron mengembalikan Promis (atau lebih tepatnya membungkus nilai Promis yang seharusnya dikembalikan). </font><font style="vertical-align: inherit;">Jika nilai yang dikembalikan ke fungsi asinkron sudah menjadi janji, maka itu tidak akan dibalik lagi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendapatkan nilai dari janji, kita dapat menggunakan metode then ().</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; } getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user)); <span class="hljs-comment"><span class="hljs-comment">// { id: 1 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atau kita bisa menggunakan kata kunci tunggu, yang akan dibahas nanti. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita kembali ke contoh pertama kita (hanya kali ini kita akan menggunakan fungsi sebenarnya untuk mengirim permintaan HTTP.</font></font><br><br><pre> <code class="javascript hljs">fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah kode asynchronous yang terlihat seperti menggunakan Promise. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi kita dapat menulis kode asinkron sebagai sinkron jika kita menggunakan fungsi asinkron.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response= <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sendRequest(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); } main();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya hal yang saya tidak suka adalah bahwa operator async hanya dapat digunakan dalam fungsi asinkron. </font><font style="vertical-align: inherit;">Kalau tidak, saya tidak perlu menggunakan fungsi main (). </font><font style="vertical-align: inherit;">Tentu saja, Anda juga dapat menggunakan metode then (), tetapi kemudian kode tersebut tidak lagi terlihat asinkron.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response= <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } sendRequest() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intinya adalah bahwa kita tidak menggunakan fungsi panggilan balik untuk mendapatkan data dari fetch (). </font><font style="vertical-align: inherit;">Sebagai gantinya, kami menggunakan kata kunci tunggu, yang tampaknya memberi tahu runtime: tunggu fungsi fetch () untuk mengeksekusi dan menulis hasilnya ke variabel respons. </font><font style="vertical-align: inherit;">Dan menggunakan fungsi callback, kita katakan: tunggu untuk fungsi fetch () untuk mengeksekusi dan memanggil fungsi callback untuk memproses data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inilah perbedaan yang jelas antara menggunakan fungsi Promise dan async</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Promise function sendRequest() { return fetch(`https://jsonplaceholder.typicode.com/users/1`) .then(data =&gt; data.json()); } //  async function async function sendRequest() { let response = await fetch(`https://jsonplaceholder.typicode.com/users/1`); return response.json(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operator yang menunggu hanya dapat digunakan dalam tubuh fungsi asinkron, dan tindakannya dapat digunakan pada fungsi apa pun yang mengembalikan janji. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menangani pengecualian dalam fungsi-fungsi asinkron, biasanya digunakan konstruksi coba ... tangkap.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Unexpected error"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); <span class="hljs-comment"><span class="hljs-comment">// Error: Unexpected error at sendRequest } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan akhirnya ... </font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//    async; await; async; await; async; await; async; await; In the System(); The function.sleep()s tonight~</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lihat Definisi Fungsi Async dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spesifikasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resmi </font><font style="vertical-align: inherit;">, serta di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Web Documents</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475074/">https://habr.com/ru/post/id475074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475062/index.html">Memperkenalkan Masuk dengan Apple - Sistem Otorisasi Apple</a></li>
<li><a href="../id475064/index.html">.NET Core 3 untuk Windows Desktop</a></li>
<li><a href="../id475066/index.html">The Chronicles of Book Hunger</a></li>
<li><a href="../id475068/index.html">Kami membungkus semua lalu lintas LAN dalam vpn tanpa batas kecepatan</a></li>
<li><a href="../id475072/index.html">Magang melalui mata perusahaan</a></li>
<li><a href="../id475078/index.html">Memahami Pembungkus Properti di SwiftUI</a></li>
<li><a href="../id475086/index.html">Pengetikan API REST untuk pengembang frontend</a></li>
<li><a href="../id475090/index.html">.NET Core dengan Pratinjau Notebook Jupyter 1</a></li>
<li><a href="../id475092/index.html">"Saya akan membacanya nanti": nasib yang sulit dari kumpulan halaman web offline</a></li>
<li><a href="../id475096/index.html">Mengumumkan .NET Core 3.1 Pratinjau 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>