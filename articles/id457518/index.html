<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👔 ➰ 🚀 Rantai Kas Plasma sebagai solusi untuk trilemma skalabilitas blockchain 💪🏼 👨🏿‍🌾 🕔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang, para pembaca! 

 Artikel ini tentang Rantai Kas Plasma dan menjelaskan topik-topik berikut: 



- trilemma skalabilitas dan metode untu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rantai Kas Plasma sebagai solusi untuk trilemma skalabilitas blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457518/">  Selamat siang, para pembaca! <br><br>  Artikel ini tentang Rantai Kas Plasma dan menjelaskan topik-topik berikut: <br><br><ul><li>  trilemma skalabilitas dan metode untuk solusinya; </li><li>  struktur data rantai anak dan tampilannya di rantai akar; </li><li>  implementasi input ke rantai akar; </li><li>  implementasi penarikan dari rantai root. </li></ul><br>  Opporty menggunakan bahasa pemrograman Javascript untuk mengimplementasikan rantai anak, serta Soliditas untuk rantai root.  Contoh kode disediakan dalam bahasa-bahasa ini. <br><br><img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><a name="habracut"></a><br>  Blockchain dan desentralisasi memungkinkan untuk mengoptimalkan dan meningkatkan kinerja hampir semua bidang kehidupan di mana Internet dan teknologi informasi digunakan.  Mereka meningkatkan keandalan, efisiensi keuangan, dan juga memfasilitasi digitalisasi barang dan barang nyata. <br><br>  Kontrak pintar membawa logika bisnis ke jaringan yang didesentralisasi.  Ini memungkinkan Anda untuk membangun aplikasi DAPP baru. <br><br>  Pengerjaan kontrak pintar dan pengoperasian aplikasi yang cepat dengan basis data terdistribusi hanya dapat dimungkinkan jika kondisi skalabilitas terpenuhi. <br><br>  Blokir modern yang terdesentralisasi memiliki beberapa kelemahan.  Yang utama adalah skalabilitas.  Ethereum memproses sekitar 20 tx / s.  Ini tidak cukup dalam realitas keuangan modern.  Pada saat yang sama, Ethereum memiliki tingkat perlindungan setinggi mungkin terhadap peretasan dan gangguan jaringan.  Cryptocurrency lain dan sistem yang dibangun di blockchain tidak memiliki tingkat desentralisasi yang tinggi, yang mengurangi kepercayaan pada jaringan. <br><br><h2>  Trilemma skalabilitas </h2><br>  Ada trilemma skalabilitas blockchain yang mencakup tiga komponen: <br><br><ul><li>  desentralisasi; </li><li>  keamanan </li><li>  skalabilitas. </li></ul><br><h3>  Desentralisasi dalam Trilemma </h3><br>  Desentralisasi, seperti yang disiratkan oleh istilah tersebut, mencerminkan tingkat diversifikasi kepemilikan aktivitas dalam blockchain, serta tingkat diversifikasi pembuatan blok dan menghasilkan entri buku besar baru. <br><br>  Untuk kejelasan, perlu untuk berbicara tentang organisasi yang paling tersentralisasi.  Biasanya database sederhana digunakan sebagai pengganti blockchain.  Organisasi semacam itu dijalankan oleh administrator khusus.  Semua transaksi dapat dibatalkan dengan intervensi manual. <br><br>  Dalam jaringan yang sepenuhnya terdesentralisasi, setiap pengguna dapat berpartisipasi dalam membangun jaringan. <br><br>  Konsekuensi paling penting dari desentralisasi adalah bahwa sebagian besar nilai diberikan kepada komunitas yang terlibat dalam menciptakan blockchain.  Tidak ada tim perantara manajer yang menerima semua manfaat alih-alih mereka yang menghasilkan struktur jaringan itu sendiri.  Faktanya, sebagian besar proyek crypto sepenuhnya dimiliki oleh kontributor atau penggunanya, bukan pendiri.  Ini jelas merupakan model yang lebih menarik bagi mereka yang bukan pendiri. <br><br><h3>  Keamanan di Trilemma </h3><br>  Ini tentang kemampuan blockchain untuk menahan serangan dari sumber eksternal dan menjaga sistem dalam keadaan tidak berubah.  Sebagian besar blockchains tunduk pada banyak ancaman keamanan potensial.  Sangat penting untuk mengetahui tentang vektor serangan dan opsi pertahanan yang paling umum. <br><br>  Dalam hal ini, desentralisasi dan keamanan berjalan beriringan.  Semakin banyak node, semakin sedikit jaringan bergantung pada sisi terpusat dan, oleh karena itu, risiko memiliki titik sentral kegagalan.  Namun, ada banyak vektor serangan lain yang mengancam jaringan desentralisasi, termasuk: <br>  &gt; <b>50% serangan</b> - objek yang memiliki lebih dari 50% dari total token yang belum dibayar sebenarnya memiliki jaringan; <br>  &gt; <b>Sybil Attack</b> - pengguna dapat menghasilkan banyak pengidentifikasi dalam sistem untuk secara efektif mengontrol bagian yang signifikan dalam kepemilikan dan / atau pengambilan keputusan di jaringan; <br>  &gt; <b>DDoS</b> - serangan penolakan layanan terdistribusi (DDoS) terjadi ketika ada niat untuk mengganggu lalu lintas di jaringan, mengisi jaringan dengan transaksi berbahaya; <br>  &gt; <b>Serangan kolusi</b> - satu atau beberapa objek (atau node) memutuskan untuk bersatu untuk melakukan operasi jahat di jaringan. <br><br><h3>  Skalabilitas dalam Trilemma </h3><br>  Tingkat skalabilitas penting karena menentukan throughput akhir, dengan kata lain, batas atas ukuran jaringan.  Pertanyaan paling penting untuk ditanyakan ketika mengevaluasi suatu jaringan adalah: "Berapa banyak pengguna yang dapat ditahan oleh sistem ini?"  Bitcoin saat ini memiliki antara 2,9 dan 5,8 juta pemegang dompet.  EOS memiliki beberapa ribu anggota. <br><br>  Skalabilitas dan desentralisasi dapat hidup berdampingan, tetapi keamanan berkurang.  Pengembang memilih platform yang paling sesuai dengan kebutuhan mereka.  Pengguna melakukan hal yang sama.  Pendapat kedua belah pihak terkadang berbeda.  Beberapa pengguna bersedia mengorbankan keamanan untuk skalabilitas, yang lain bersedia mengorbankan skalabilitas untuk keamanan, tetapi menyeimbangkan jauh lebih sulit. <br><br><h2>  "Holy Grail" dalam teknologi blockchain </h2><br>  Menurut definisi, blockchain hanya memiliki dua dari tiga properti berikut: <br><br><ul><li>  <b>Desentralisasi</b> (setiap peserta hanya memiliki akses ke sumber daya O ©, yaitu ke laptop biasa atau VPS kecil); </li><li>  <b>Skalabilitas</b> (kemampuan untuk memproses transaksi O (n)&gt; O ©); </li><li>  <b>Keamanan</b> (perlindungan terhadap penyusup yang menggunakan sumber daya O (n)). </li></ul><br><img src="https://habrastorage.org/webt/ek/zg/zr/ekzgzredr00odj5mwae4f549hzs.png"><br>  Hijau: Keadaan seimbang dari tiga kondisi. <br>  Merah: keamanan kuat tetapi desentralisasi dan skalabilitas terbatas. <br>  Biru: efisiensi tinggi, tetapi keamanan dan desentralisasi terbatas. <br>  Hitam: desentralisasi tinggi, tetapi tidak ada aspek skalabilitas dan keamanan. <br>  Gray: desentralisasi penuh, dengan kualitas keamanan dan skalabilitas yang minimal atau hilang. <br>  Violet: keseimbangan yang seimbang antara keamanan dan skalabilitas, penolakan desentralisasi. <br><br>  "Cawan Suci" dalam teknologi blockchain berarti menggabungkan ketiga aspek. <br>  Dalam sebagian besar proyek saat ini bekerja dengan cryptocurrency, dua sifat dasar dicapai: desentralisasi dan keamanan.  Skalabilitas menderita. <br><br><h2>  Solusi yang menjanjikan untuk trilemma </h2><br><h3>  Bukti Pasak (PoS) </h3><br>  Proof of Stake (PoS) memberikan peningkatan skalabilitas yang potensial.  POS menggantikan penambangan cryptocurrency berdasarkan sistem Proof of Work (PoW).  Pilihan validator sangat cepat - dengan cara deterministik.  Pada saat yang sama, tidak ada biaya energi dan ramah lingkungan. <br><br><h3>  Sidechains </h3><br>  Dalam jaringan virtual Ethereum, ada kemungkinan membuat jaringan samping di mana proyek dapat memproses transaksi individu dan kemudian hanya mencatat hasil awal dan akhir dalam jaringan Ethereum.  Ini mengurangi beban pada EVM, tetapi memberikan lebih banyak kepercayaan dalam pengelolaan sidechain.  Dengan demikian, kepercayaan pada pihak ketiga mengurangi desentralisasi. <br><br><h3>  Sharding </h3><br>  Sharding memecah transaksi menjadi potongan data yang lebih kecil.  Alih-alih setiap node individu dalam jaringan yang memproses seluruh transaksi, node dibagi menjadi kelompok-kelompok, dan kelompok-kelompok node ini memproses potongan data tertentu.  Kemudian, selama pemrosesan, potongan-potongan data ini diasimilasi ulang untuk penyimpanan permanen pada blockchain. <br><br><h3>  Tambah ukuran blok </h3><br>  Litecoin dan Bitcoin Cash (BCH) adalah "garpu" untuk blockchain Bitcoin.  Forking pada dasarnya menyalin satu blockchain.  Setelah bercabang, Anda dapat membuat perubahan.  Baik LTC dan BCH meningkatkan ukuran setiap blok, yang memungkinkan untuk menyimpan lebih banyak transaksi per blok, sehingga meningkatkan kecepatan pemrosesan transaksi. <br><br><h3>  Jaringan kilat </h3><br>  Solusi sidechain pertama adalah kilat.  Gagasan utama dari Lightning Network adalah bahwa tidak semua transaksi harus dicatat dalam blockchain, karena ini membebani jaringan.  Jika pengguna mentransfer dana satu sama lain beberapa kali, maka mendaftarkan setiap transfer adalah opsional.  Cukup hanya dengan membuka semacam saluran pembayaran dan menuliskan data tentang pembukaannya di blockchain.  Saluran ini akan tetap terbuka sesuai kebutuhan.  Ketika akan diperlukan untuk menutupnya, hasil dari semua transaksi yang dilakukan dalam saluran ini hanya ditulis ke blockchain.  Mengikuti gagasan ini, Anda dapat membuat seluruh jaringan saluran untuk pembayaran.  Maka transaksi pada blockchain akan lebih jarang digunakan. <br><br>  Saluran pembayaran hanyalah kombinasi dari beberapa transaksi.  Saluran dapat ditutup oleh salah satu anggotanya.  Tindakan ini akan mirip dengan membuka brankas, yang memungkinkan Anda untuk mengambil dana milik peserta dan menuliskan data pada transfer mereka ke blockchain. <br>  Teknologi ini menjadi sangat kuat ketika beberapa saluran tersebut digabungkan menjadi jaringan yang disebut The Lightning Network.  Jaringan ini dibangun khusus untuk Bitcoin. <br><br><h3>  Raiden jaringan </h3><br>  Untuk Ethereum, mitra Lightning yang paling terkenal adalah Raiden Network. <br>  Ini adalah solusi untuk penskalaan di luar blockchain utama.  Ini kompatibel dengan transfer token ERC-20 di saluran pembayaran dua arah. <br><br>  Arsitektur dasarnya kompleks, tetapi interaksi dengan Raiden membutuhkan pengembang untuk hanya berinteraksi dengan API untuk membuat aplikasi yang dapat diukur pada Raiden. <br><br>  Raiden dirancang untuk memberikan pembayaran instan dan komisi rendah, meningkatkan kerahasiaan transaksi dan pembayaran mikro.  Sebagian besar saluran pembayaran ada di luar jaringan dan hanya sesekali membentuk transaksi dalam rantai root, yang secara signifikan mengurangi throughput rantai anak. <br><br><h2>  Solusi optimal </h2><br>  Ideolog petir telah menciptakan konsep childchain baru yang memecahkan masalah kecepatan blockchain. <br><br>  Peluang praktis mengimplementasikan konsep Plasma dan Plasma Cash. <br><br>  Plasma adalah serangkaian kontrak pintar yang berjalan di atas rantai akar Ethereum dan terdiri dari jaringan rantai anak yang terhubung ke rantai akar dalam struktur pohon hierarkis. <br><br>  Artinya, keamanan rootchain Ethereum digunakan untuk mengoptimalkan skalabilitas. <br><br><h2>  Uang Tunai Plasma: Opsi Opporty </h2><br>  <b>Opporty menggunakan implementasi Plasma Cash dalam versi pertama.</b> <br><br>  Model ini adalah implementasi plasma paling efektif dalam hal skalabilitas. <br>  Plasma Cash adalah sistem yang didasarkan pada penggunaan pengidentifikasi unik untuk setiap token dalam rantai Plasma.  Yaitu, NFT diterapkan dan token dalam jaringan menerima nomor seri unik. <br><br>  Fitur Uang Tunai Plasma: <br><br><ul><li>  Validasi Sharded di sisi klien - pelanggan hanya perlu memantau rantai Plasma mereka untuk mendapatkan token mereka.  Ini berarti bahwa throughput transaksi dapat meningkat tanpa menambah beban pada pengguna individu. </li><li>  Penyederhanaan keluar massal - massa keluar menjadi kurang dari ancaman bagi jaringan, karena pencuri harus menyerahkan transaksi keluar untuk setiap token yang ingin dicuri. </li><li>  Kurangnya konfirmasi dua arah - transaksi tidak lagi membutuhkan pengiriman dan konfirmasi dua langkah.  Sebagai gantinya, transaksi dapat dihabiskan segera setelah dimasukkan dalam rantai utama. </li></ul><br>  Kerugian: <br><br>  Denominasi besar token - karena setiap token harus diberi nomor seri, Anda tidak dapat menghasilkan token kecil sewenang-wenang.  Hal ini disebabkan oleh fakta bahwa pada titik tertentu nilai pembelian token akan lebih dari nilai token itu sendiri. <br><br><h3>  Struktur Transaksi dalam Uang Tunai Plasma yang Tepat </h3><br>  Opporty menggunakan Javascript untuk mengimplementasikan childchain.  Setiap transaksi dalam Opporty Plasma Cash memiliki struktur yang serupa: <br><br><pre><code class="plaintext hljs">const transactionFields = [ {name: 'prevHash'}, {name: 'prevBlock', int: true, default: 0}, {name: 'tokenId', isDecimal: true}, {name: 'newOwner'}, {name: 'type'}, {name: 'signature'}, ]</code> </pre> <br>  Elemen utama di sini adalah tautan ke blok prevBlock sebelumnya (diperlukan untuk bergerak di sekitar rantai blok), tokenId token identifier (harus unik), serta pemilik baru pemilik terakhir token. <br><br>  Selanjutnya, untuk merakit blok dan mendapatkan hash rantai root, jenis khusus pohon Patricia Merkle Trie digunakan.  Pohon yang sama digunakan dalam Ethereum.  Ini memiliki tampilan yang dikompresi.  Pada saat yang sama, Anda masih dapat menerima bukti penyertaan atau non-penyertaan transaksi dalam suatu blok. <br>  Tanda tangan adalah tanda tangan pada kurva elips. <br><br>  Transaksi yang menghabiskan token dengan tokenId yang diberikan hanya valid jika itu termasuk dalam pohon Merkle di posisi tokenId, yaitu, untuk setiap token di pohon Merkle hanya ada satu "tempat" yang menghabiskan token ini di mana transaksi diizinkan.  Format ini memungkinkan pengguna untuk memeriksa riwayat lengkap rantai Plasma, serta membuktikan dan menyangkal kepemilikan untuk token tertentu. <br><br>  Untuk menghabiskan token, Anda perlu memvalidasi rantai, memeriksa blok yang hilang, dan hanya kemudian menandatangani kembali transaksi bersama dengan seluruh sejarah. <br><br>  Bloknya adalah sebagai berikut: <br><br><pre> <code class="plaintext hljs">const blockFields = [ {name: 'prevHash'}, {name: 'blockNum', isDecimal: true}, {name: 'transactions'}, {name: 'merkleRoot'}, {name: 'time'} ]</code> </pre> <br>  Pada tingkat dasar, blockchain hanyalah rantai blok dengan tautan ke blok sebelumnya.  Struktur seperti itu memungkinkan untuk memperoleh sifat kekekalan, yaitu, tidak menulis ulang sejarah.  merkleRoot memungkinkan untuk menulis pos pemeriksaan ke rantai root. <br><br>  Di rantai akar, di tingkat kontrak pintar, sepertinya ini (Bahasa Soliditas): <br><br><pre> <code class="plaintext hljs">/* * Block structure (represents one block in a chain) */ struct Block { uint block_num; bytes32 merkle_root; uint time; /* * Transaction structure (decoded from RLP form) */ struct Transaction { bytes32 prevhash; uint prev_block; uint token_id; address new_owner; }</code> </pre><br>  Pengkodean dilakukan dengan menggunakan pengodean / decoding - fungsi serialisasi / deserialisasi RLP. <br><br><h3>  Cara memasukkan Uang Plasma </h3><br>  Siapa pun dapat menyetor dana ke dalam Plasma Cash hanya dengan mentransfer eter ke kontrak pintar.  Akibatnya, token OPP akan diterima pada posisi tokenId tertentu. <br><br>  Berikut ini adalah implementasi dalam Solidity: <br><br><pre> <code class="plaintext hljs">function deposit() public payable { uint token_id = uint(keccak256(msg.sender, msg.value, deposit_blk)); // token.index = deposit_blk; tokens[token_id] = msg.value; deposit_blk += 1; emit DepositAdded(msg.sender, msg.value, token_id, current_blk); }</code> </pre> <br>  Yaitu, tokenId dihasilkan sebagai angka acak (hash).  Selanjutnya, suatu peristiwa dihasilkan yang dipindai dalam rantai anak. <br><br><h3>  Cara-cara menarik ke Tunai Plasma </h3><br>  Setiap orang dapat menarik tokennya dengan memberikan dua transaksi terakhir dalam riwayat kepemilikan token. <br><br>  Implementasi keluar dari rantai root: <br><br><pre> <code class="plaintext hljs">function startExit(uint block_num, bytes tx1, bytes tx0, bytes proof1, bytes proof0) public returns (uint exit_id) { require(checkPatriciaProof(keccak256(tx1), childChain[block_num].merkle_root, proof1)); bytes32 prev_hash; uint prev_blk; uint token_id; address new_owner; (prev_hash, prev_blk, token_id, new_owner,) = getTransactionFromRLP(tx1); require(msg.sender == new_owner); require(tokens[token_id] &gt; 0); bytes32 hashPrevTx = keccak256(tx0); require(checkPatriciaProof(hashPrevTx, childChain[prev_blk].merkle_root, proof0)); require(prev_hash == hashPrevTx); Exit storage record = exitRecords[token_id]; require(record.block_num == 0); record.block_num = block_num; record.new_owner = msg.sender; record.prev_block = prev_blk; if (childChain[block_num].time &gt; block.timestamp - week) record.priority = childChain[block_num].time; else record.priority = block.timestamp - week; exits.add(record.priority); exit_ids[record.priority].push(token_id); emit ExitAdded(msg.sender, record.priority, token_id); return token_id; }</code> </pre><br>  Pertama, dua transaksi diperiksa.  Jika pengguna saat ini adalah pemilik transaksi, maka kami cukup menambahkan outputnya ke struktur dan biarkan dua minggu untuk kesempatan untuk menantang output. <br><br>  Kesimpulannya dapat ditantang dalam tiga cara: <br><br><ul><li>  Memberikan konfirmasi pengeluaran untuk transaksi: </li></ul><br><pre> <code class="plaintext hljs">function challengeSpent(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); require(prev_block == record.block_num &amp;&amp; record.block_num &lt; blk_num); require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  Jika ada transaksi yang sudah menghabiskan token yang ditampilkan, maka penarikan seperti itu akan dibatalkan! <br><br><ul><li>  Bukti pengeluaran untuk transaksi sebelumnya: </li></ul><br><pre> <code class="plaintext hljs">/* * Challenge exit by providing * a proof of a transaction spending P(C) that appears before C */ function challengeDoubleSpend(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); // bytes32 prev_hash; uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); // check if token double spent require(prev_block == record.prev_block &amp;&amp; blk_num &lt; record.block_num); // require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  Ini adalah cek yang sama seolah-olah token telah dihabiskan sebelum penarikan.  Pertama, periksa transaksi di root hash.  Selanjutnya, kami menghapus output jika sudah digunakan. <br><br><ul><li>  memberikan transaksi dalam riwayat transaksi token sebelumnya. </li></ul><br>  Ini mungkin cerita yang salah, jadi Anda perlu mengonfirmasi dengan transaksi anak: <br><br><pre> <code class="plaintext hljs">// */ function challengeInvalidHistory(uint exit_id, uint blk_num, bytes tx0, bytes proof) public { // check if proof is valid require(checkPatriciaProof(keccak256(tx0), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); bytes32 prev_hash; uint token_id; (prev_hash, , token_id, ) = getTransactionFromRLP(tx0); //require(exit_id == token_id); require(tokens[token_id] &gt; 0); // transaction should be before exit tx in history require(blk_num &lt; record.block_num - 1); challenged[exit_id] = blk_num; emit ChallengedInvalidHistory(exit_id, token_id); }</code> </pre><br>  Memanggil skrip pertama dan kedua segera memblokir output. <br><br>  Panggilan ke skenario ketiga dapat dijawab dengan memberikan keturunan langsung.  Itu harus sama dengan atau di depan transaksi induk. <br><br><pre> <code class="plaintext hljs">/* * Respond to invalid history challenge by providing * the direct child of C*, which must be either equal to or before P( C ) */ function respondChallenge(uint exit_id, uint blk_num, bytes childtx, bytes proof) public { require(challenged[exit_id] &gt; 0); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); require(checkPatriciaProof(keccak256(childtx), childChain[blk_num].merkle_root, proof)); // get transaction from rlpencoded form bytes32 prev_hash; uint prev_block; uint token_id; (prev_hash, prev_block, token_id, ) = getTransactionFromRLP(childtx); // if direct child if (prev_block == challenged[exit_id] ) { if (blk_num &lt;= record.prev_block &amp;&amp; token_id == exit_id ) { delete challenged[exit_id]; emit ExitRespondedEvent(exit_id); } else { exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); } } }</code> </pre><br>  Yaitu, jika transaksi anak yang benar diterima, hasilnya disengketakan dan tetap dalam antrian! <br>  Setelah membangun bagian dari protokol Plasma Tunai yang Tepat, kesimpulan berikut dibuat: <br>  Protokol ini memberikan keamanan melalui rantai root Ethereum. <br><br>  Dengan menyulitkan prosedur input dan output dari rantai root dan kompresi keadaan (blok transaksi), kami memeriksa semua metode output dan input ke rantai root, dan juga menyelidiki struktur data dasar: transaksi dan blok. <br><br>  Menggunakan sidechain berdasarkan jaringan Ethereum, Anda dapat secara signifikan mempercepat transaksi.  Peluang menerima hingga <b>300.000</b> transaksi per detik pada satu operator.  Ini lebih dari apa yang dapat diberikan oleh sistem pembayaran saat ini. <br><br>  Terlepas dari beberapa masalah ketersediaan data, operator memberikan tingkat stabilitas tinggi dari blockchain dan memungkinkan untuk melakukan transaksi bisnis internasional yang efektif. <br><br>  Plasma Cash membawa peningkatan skalabilitas yang sangat besar.  Oleh karena itu, Opporty menggunakan Plasma sebagai bagian dari protokol PoE-nya. <br><br><h3>  Tautan yang bermanfaat </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Plasma kertas putih</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Git hub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gunakan case dan deskripsi arsitektur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kertas jaringan petir</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457518/">https://habr.com/ru/post/id457518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457508/index.html">Parenting vs Machine Learning: membandingkan seorang ibu muda</a></li>
<li><a href="../id457510/index.html">Gunakan mcrouter untuk mengukur memcached secara horizontal</a></li>
<li><a href="../id457512/index.html">Replikasi logis antara versi PostgreSQL</a></li>
<li><a href="../id457514/index.html">Nevanger</a></li>
<li><a href="../id457516/index.html">Menulis Model Ancaman</a></li>
<li><a href="../id457522/index.html">Naikkan layanan milis Anda atau gunakan solusi yang sudah jadi? Apa yang saya pelajari selama 5 tahun di UniSender</a></li>
<li><a href="../id457524/index.html">Kamera kedalaman - revolusi diam (saat robot akan melihat) Bagian 1</a></li>
<li><a href="../id457526/index.html">Media teknis sebagai bazar</a></li>
<li><a href="../id457532/index.html">Sudah saatnya untuk menjadi bagian dari proyek open source</a></li>
<li><a href="../id457534/index.html">Versi bersertifikat - penggaruk yang kita pilih</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>