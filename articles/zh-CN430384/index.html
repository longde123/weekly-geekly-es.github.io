<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤐 👨🏽‍🏭 🔑 根据噪声特征创建地图 🤦 ™️ 😩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我的网站上最受欢迎的文章之一是关于多边形地图的生成 （Habré中的翻译 ）。 创建这样的卡需要大量的努力。 但是我不是从这个开始的，而是从一个简单得多的任务开始的，我将在这里进行描述。 这种简单的技术使您可以用少于50行的代码创建此类卡： 


 我不会解释如何绘制此类卡：它取决于语言，图形库，平...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>根据噪声特征创建地图</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430384/"> 我的网站上最受欢迎的文章之一是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于多边形地图</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">生成</a> （Habré中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">翻译</a> ）。 创建这样的卡需要大量的努力。 但是我不是从这个开始的，而是从一个简单得多的任务开始的，我将在这里进行描述。 这种简单的技术使您可以用少于50行的代码创建此类卡： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/95e/c42/b1695ec42f626197fddd201f7f40fa8a.png"></div><br> 我不会解释如何<em>绘制</em>此类卡：它取决于语言，图形库，平台等。 我将仅说明如何使用地图数据<em>填充数组</em> 。 <br><br><h2> 噪音 </h2><br> 生成2D贴图的标准方法是使用有限频段的噪声作为构建块，例如Perlin噪声或单工噪声。 噪声函数如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/159/49e/85515949e4c77ba82599050333ec79fa.png" alt="图片"></div><br> 我们为地图上的每个点分配一个介于0.0到1.0之间的数字。 在此图像中，0.0是黑色，而1.0是白色。 <a name="habracut"></a> 以下是使用类C语言的语法设置每个网格点颜色的方法： <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; value[y][x] = noise(nx, ny); } }</code> </pre> <br> 该循环在Javascript，Python，Haxe，C ++，C＃，Java和大多数其他流行语言中都将起作用，因此我将以类似C的语法显示它，以便将其转换为所需的语言。 在本教程的其余部分中，我将展示添加新函数时循环主体的变化（线<code>value[y][x]=…</code> ）。 该演示将显示一个完整的示例。 <br><br> 在某些库中，有必要对结果值进行移位或相乘，以便将它们返回的范围从0.0到1.0。 <br><br><h2> 身高 </h2><br> 噪声本身只是数字的集合。 我们需要赋予它<em>意义</em> 。 您可以想到的第一件事是将噪声值绑定到高度（这称为“高度图”）。 让我们以上面显示的噪声并将其绘制为高度： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/047/4bf/8d9/0474bf8d9dd73ad63fefc84140385f50.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/cb9/c53/b14cb9c535820e30c6eab79dda6322ec.png"></div><br> 除了内部循环外，代码几乎相同。 现在看起来像这样： <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(nx, ny);</code> </pre> <br> 是的，就是这样。 地图数据保持不变，但现在我将其称为<code>elevation</code> （高度），而不是<code>value</code> 。 <br><br> 我们有很多山丘，但仅此而已。 怎么了 <br><br><h3> 频次 </h3><br> 噪声可以在任何<em>频率</em>下产生。 到目前为止，我只选择了一种频率。 让我们看看它是如何影响的。 <br><br>  <strong>尝试使用滑块</strong> （在原始文章中） <strong>更改值，</strong>并查看在不同频率下会发生什么： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/ox/dh/puoxdhmnucu5e3miflqogwqddwq.gif"></div><br> 它只是改变比例。 起初，这似乎不是很有用，但事实并非如此。 我还有另外一本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">教程</a> （用Habré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">翻译</a> ）解释了该<em>理论</em> ：诸如频率，幅度，八度，粉红色和蓝色噪声等概念。 <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(freq * nx, freq * ny);</code> </pre> <br> 有时召回与频率成反比<em>的波长</em>有时也很有用。 当频率增加一倍时，大小只会减半。 波长加倍，所有光子都加倍。 波长是以像素/图块/米或您为地图选择的任何其他单位测量的距离。 它与频率有关： <code>wavelength = map_size / frequency</code> 。 <br><br><h3> 八度 </h3><br> 为了使高度图更有趣，我们将<em>添加不同频率的噪声</em> ： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dr/wt/uj/drwtujuho39t3uluoanf5vthl6o.png"></div><br><br><pre> <code class="cpp hljs">elevation[y][x] = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny);</code> </pre> <br> 让我们在一张地图中混合大型低频山丘和小型高频山丘。  <strong>移动滑块</strong> （在原始文章中），以向混合添加小丘陵： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/km/wh/bb/kmwhbbf29gwpdqcwtrbrnsighhw.gif"></div><br> 现在，它更像我们需要的分形浮雕！ 我们可以获得丘陵和崎rough的山脉，但仍然没有平坦的平原。 为此，您还需要其他一些东西。 <br><br><h3> 重新分配 </h3><br> 噪声函数为我们提供0到1之间的值（或从-1到+1，取决于库）。 要创建平坦的平原，我们可以<em>将高度提高到幂</em> 。  <strong>移动滑块</strong> （在原始文章中）获得不同的角度。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/px/wc/3dpxwcatvtjknukqlih0hs7fecs.gif"></div><br><pre> <code class="cpp hljs">e = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny); elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br>  <em>较高的</em>值会<em>降低到达平原的平均高度</em> ，而较低的值会提高到达山峰的平均高度。 我们需要省略它们。 我使用幂函数是因为它们更简单，但是您可以使用任何曲线。 我有一个更复杂的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示</a> 。 <br><br> 现在我们有了一个逼真的海拔图，让我们添加生物群落！ <br><br><h2> 生物群落 </h2><br> 噪声给出数字，但是我们需要一张包含森林，沙漠和海洋的地图。 您可以做的第一件事是将小高地变成水： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/hu/hv/ethuhvixmvjso_zt-_ev3gtu-tu.gif"></div><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; waterlevel) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LAND; }</code> </pre> <br> 哇，这已经变得像程序产生的世界了！ 我们有水，草和雪。 但是，如果我们需要更多呢？ 让我们来序列水，沙，草，森林，大草原，沙漠和雪： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fd/aa0/237/5fdaa023713e487a95fed02484380d03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/1d9/8b4/6561d98b4ceda31b7ff49ece890e4e83.png"></div><br>  <i>根据身高的救济</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FOREST; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JUNGLE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SAVANNAH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DESERT; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; }</code> </pre> <br> 哇，看起来很棒！ 对于您的游戏，您可以更改值和生物群系。 孤岛危机将会有更多的丛林。 天际有更多的冰雪。 但是，无论您如何更改数字，此方法都非常有限。 凸版类型对应于高度，因此形成条状。 为了使它们更有趣，我们需要基于其他内容来选择生物群落。 让我们为湿度创建<em>第二个</em>噪声图。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/1e3/de8/4f41e3de81e756ee9097be620ff5e08e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7c/b6a/317/c7cb6a31702505881dbbf3d2ddb1244b.png"></div><br>  <i>上面是高处的噪音；</i>  <i>底部-湿度噪声</i> <br><br> 现在，让我们<em>一起</em>使用高度和湿度。 在下面显示的第一个图像中，y轴是高度（从上图获取），x轴是湿度（第二个图像更高）。 这给了我们一个引人注目的地图： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/34c/6c1/0e934c6c1358e89adc1b8e4e11b4b21c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d11/e8e/3cad11e8edae614c2600342c37d6d4eb.png"></div><br>  <i>基于两个噪声值的缓解</i> <br><br> 小高度是海洋和海岸。 大高度是岩石和下雪。 在这之间，我们得到了各种各样的生物群落。 代码如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, m)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OCEAN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SCORCHED; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BARE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TUNDRA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.6</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SHRUBLAND; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TAIGA; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.83</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DECIDUOUS_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_RAIN_FOREST; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUBTROPICAL_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_SEASONAL_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_RAIN_FOREST; }</code> </pre> <br> 如有必要，您可以根据游戏要求更改所有这些值。 <br><br> 如果我们不需要生物群落，那么平滑的渐变（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a> ）可以创建颜色： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/963/61d/bd496361d481367788a33ebece885cb6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/799/58e/28e79958eb0b9990fa9e1978fa727def.png"></div><br> 对于生物群系和梯度，单个噪声值不能提供足够的可变性，但是两个就足够了。 <br><br><h2> 气候状况 </h2><br> 在上一节中，我用<em>海拔</em>代替了<em>温度</em> 。 高度越高，温度越低。 但是，地理纬度也会影响温度。 让我们同时使用高度和纬度来控制温度： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/fz/qn/mrfzqnq2ouo7zupt4kscz5a2gv8.png"></div><br> 在两极（大纬度）附近，气候较冷，而在山顶（大高度）上，气候也较冷。 到目前为止，我的工作还不是很辛苦：要正确使用这些参数，您需要进行许多细微的设置。 <br><br> 还有<em>季节性的</em>气候变化。 在夏季和冬季，北半球和南半球变暖和变冷，但在赤道，情况变化不大。 在这里也可以做很多事情，例如，可以模拟盛行的风和洋流，生物群落对气候的影响以及海洋对温度的平均影响。 <br><br><h2> 岛屿 </h2><br> 在某些项目中，我需要地图的边框为水。 这将世界变成一个或多个岛屿。 有很多方法可以做到这一点，但是我在多边形地图生成器中使用了一个非常简单的解决方案：我将高度更改为<code>e = e + a - b*d^c</code> ，其中<code>d</code>是距中心的距离（比例为0-1）。 另一种选择是更改<code>e = (e + a) * (1 - b*d^c)</code> 。 常数<code>a</code>使所有事物升高， <code>b</code>使边缘降低，而<code>c</code>控制下降率。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/gb/s4/uqgbs4h2ifsrwd2hsfvrrhue3ju.png"></div><br>  <em>我对此并不完全满意，</em>还有很多事情要做。 应该是曼哈顿距离还是欧几里得距离？ 它应该取决于到中心的距离还是到边缘的距离？ 距离应该是平方的，还是线性的，或具有其他程度？ 应该是加/减，乘/除，还是其他？ 在原始文章中， <b>尝试</b>加，a = 0.1，b = 0.3，c = 2.0，或<b>尝试</b>乘以a = 0.05，b = 1.00，c = 1.5。 适合您的选项取决于您的项目。 <br><br> 为什么要坚持使用标准数学函数？ 正如我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关RPG中的损坏</a> （在Habré上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">翻译</a> ）中所讲的那样，每个人（包括我在内）都使用数学函数，例如多项式，指数分布等，但是在计算机上，我们不能局限于此。 我们可以使用查找表<code>e = e + height_adjust[d]</code>来获取<em>任何</em>形成函数并在此处使用。 到目前为止，我还没有研究过这个问题。 <br><br><h2> 尖刺的噪音 </h2><br> 除了将高度提高到幂之外，我们可以使用绝对值创建尖峰： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ridgenoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">0.5</span></span> - noise(nx, ny))); }</code> </pre> <br> 要增加八度，我们可以改变高频的幅度，以便只有山峰才能接收到增加的噪声： <br><br><pre> <code class="cpp hljs">e0 = <span class="hljs-number"><span class="hljs-number">1</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); e1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) * e0; e2 = <span class="hljs-number"><span class="hljs-number">0.25</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) * (e0+e1); e = e0 + e1 + e2; elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/co/ku/kg/cokukg_3lgom28_bnm3cu4u-4dc.gif"></div><br> 我对这项技术没有太多的经验，所以我需要进行实验以学习如何很好地使用它。 将尖峰的低频噪声与非尖峰的高频噪声混合可能也很有趣。 <br><br><h2> 梯田 </h2><br> 如果将高度四舍五入到下n个水平，则会得到梯田： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/bo/5k/zvbo5k_de80zv8utx6fxorpxfha.png"></div><br> 这是应用<code>e = f(e)</code>形式的高度重新分配函数的结果。 上面，我们使用<code>e = Math.pow(e, exponent)</code>来锐化山峰； 在这里，我们使用<code>e = Math.round(e * n) / n</code>创建平台。 如果使用非步进功能，则梯形可以倒圆或仅出现在特定高度。 <br><br><h2> 树的位置 </h2><br> 通常我们使用分形噪声来表示高度和湿度，但也可以用来放置空间不均匀的物体，例如树木和石头。 对于高度，我们使用低频的高振幅（“红色噪声”）。 要放置物体，您需要使用高频高振幅（“蓝噪声”）。 左边是蓝色的噪音图案。 右边是噪声大于相邻值的地方： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/u4/ze/xou4zen4vzp46h3l7ecmcmdqsda.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yc = <span class="hljs-number"><span class="hljs-number">0</span></span>; yc &lt; height; yc++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xc = <span class="hljs-number"><span class="hljs-number">0</span></span>; xc &lt; width; xc++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> max = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     for (int yn = yc - R; yn &lt;= yc + R; yn++) { for (int xn = xc - R; xn &lt;= xc + R; xn++) { double e = value[yn][xn]; if (e &gt; max) { max = e; } } } if (value[yc][xc] == max) { //    xc,yc } } }</span></span></code> </pre> <br> 为每个生物群系选择不同的R，我们可以获得可变的树木密度： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/e0e/32a/764e0e32ac9171654161a94a29f66118.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/940/61f/aa194061fd97796c08238123b57199c7.png"></div><br> 可以使用这种噪声来放置树是很棒的，但是其他算法通常更有效并且可以创建更均匀的分布：泊松点，范图块或图形抖动。 <br><br><h2> 超越无限 </h2><br> 在位置（x，y）的生物群系的计算独立于所有其他位置的计算。 这种<strong>局部计算</strong>具有两个方便的属性：可以并行计算，并且可以用于无尽的地形。  <strong>将鼠标光标放在</strong>左侧<strong>的小地图上</strong> （在原始文章中），以在右侧生成地图。 您可以生成卡的任何部分而无需生成（甚至不存储）整个卡。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/932/152/98b932152f6c24f496034283fa904499.png"><img src="https://habrastorage.org/getpro/habr/post_images/6a5/811/c84/6a5811c84c56c1706aedbc505fc32aa9.png"><br><br><h2> 实作 </h2><br> 使用噪声生成地形是一种流行的解决方案，在Internet上，您可以找到针对许多不同语言和平台的教程。 用于生成不同语言的卡的代码大致相同。 这是三种不同语言的最简单循环： <br><br><ul><li>  <b>Javascript：</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nx, ny</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2D(nx, ny) / 2 + 0.5; } let value = []; for (let y = 0; y &lt; height; y++) { value[y] = []; for (let x = 0; x &lt; width; x++) { let nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>C ++：</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::Perlin gen; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetValue(nx, ny, 0) / 2.0 + 0.5; } double value[height][width]; for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>Python：</b> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> opensimplex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OpenSimplex gen = OpenSimplex() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2d(nx, ny) / 2.0 + 0.5 value = [] for y in range(height): value.append([0] * width) for x in range(width): nx = x/width - 0.5 ny = y/height - 0.5 value[y][x] = noise(nx, ny)</span></span></code> </pre> </li></ul><br> 所有的噪声库都差不多。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对于Python</a> ，请尝试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">opensimplex；</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对于C ++</a> ，请尝试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">libnoise；</a>对于Javascript，请尝试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">simplex-noise</a> 。 对于大多数流行的语言，有许多噪声库。 或者，您可以了解Perlin噪音的工作原理或亲自了解噪音。  <em>我没做</em> <br><br> 在针对您的语言的不同噪声库中，应用程序的详细信息可能会略有不同（一些返回值的范围是0.0到1.0，其他返回值的范围是-1.0到+1.0），但是基本思想是相同的。 对于真实的项目，可能需要将<code>noise</code>函数和<code>gen</code>对象包装在一个类中，但是这些细节无关紧要，因此我将它们设置为全局。 <br><br> 对于这样一个简单的项目，使用什么噪声都没有关系：Perlin噪声，单纯形噪声，OpenSimplex噪声，值噪声，中点偏移，菱形算法或傅立叶逆变换。 它们每个都有其优缺点，但是对于类似的卡生成器，它们都创建或多或少相同的输出值。 <br><br> 地图<em>的渲染</em>取决于平台和游戏，因此我没有实现它。 该代码仅用于生成高度和生物群落，其渲染取决于游戏中使用的样式。 您可以在项目中复制，移植和使用它。 <br><br><h2> 实验 </h2><br> 我研究了混合八度音阶，将度数提升至幂，以及将高度与湿度结合起来以创建生物群系。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里，</a>您可以研究一个交互式图形，该图形可以让您试验所有这些参数，从而显示代码组成： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/yq/xn/lhyqxnbeaj0friycenleop7mcdw.png"></div><br> 这是一个示例代码： <br><br><pre> <code class="cpp hljs">var rng1 = PM_PRNG.create(seed1); var rng2 = PM_PRNG.create(seed2); var gen1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng1.nextDouble.bind(rng1)); var gen2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng2.nextDouble.bind(rng2)); <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen1.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen2.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { var nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; var e = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.13</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.06</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.03</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); e /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>+<span class="hljs-number"><span class="hljs-number">0.25</span></span>+<span class="hljs-number"><span class="hljs-number">0.13</span></span>+<span class="hljs-number"><span class="hljs-number">0.06</span></span>+<span class="hljs-number"><span class="hljs-number">0.03</span></span>); e = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, <span class="hljs-number"><span class="hljs-number">5.00</span></span>); var m = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.75</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); m /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.75</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* draw biome(e, m) at x,y */</span></span> } }</code> </pre> <br> 有一个困难：对于高湿噪声，必须使用不同的种子，否则它们将变成相同的种子，并且卡片看起来不会那么有趣。 在Javascript中，我使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">prng-parkmiller库</a> ； 在C ++中，可以使用两个单独的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">linear_congruential_engine对象</a> ； 在Python中，您可以创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">random.Random类的</a>两个单独的实例。 <br><br><h2> 思想 </h2><br> 我喜欢这种方法来<b>简化</b>地图生成。 它速度快，只需要很少的代码即可产生不错的结果。 <br><br> 我不喜欢他在这种方法上的局限性。 本地计算意味着每个点都独立于所有其他点。 地图的不同区域<em>没有相互连接</em> 。 地图上的每个地方“似乎”都一样。 没有全球性的限制，例如“在地图上应该有3至5个湖泊”或全球性的特征，例如从最高峰的顶部流入海洋的河流。 另外，我不喜欢这样的事实，为了获得良好的画面，您需要长时间配置参数。 <br><br> 我为什么推荐它？ 我认为这是一个很好的起点，特别是对于独立游戏和游戏果酱。 我的两个朋友<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a>短短30天的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">游戏大赛中</a>写下了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“狂神王国”</a>的最初版本。 他们要求我帮助创建地图。 我使用了这种技术（加上一些其他功能，这些功能原来并不是很有用），并为它们绘制了地图。 几个月后，在收到玩家的反馈并仔细研究了游戏的设计之后，我们基于Voronoi多边形创建了一个更高级的地图生成器， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此进行了</a>介绍（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">译自</a> Habré）。 此卡生成器不使用本文所述的技术。 它使用噪音以完全不同的方式创建地图。 <br><br><h2> 附加信息 </h2><br> 噪声功能可以完成<em>很多</em>很酷的事情。 如果您在Internet上搜索，则可以找到各种选项，例如湍流，波涛，脊形多重分形，振幅阻尼，阶梯形，voronoi噪声，分析导数，域扭曲等。 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此页面</a>作为灵感来源。 我在这里不考虑它们；我的文章集中在简单性上。 <br><br> 该项目受到我以前的地图生成项目的影响： <br><br><ul><li> 我将Perlin的整体噪音用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“狂神”卡生成器的第一个领域</a> 。 我们在前六个月的alpha测试中使用了它，然后将其替换为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Voronoi多边形上的地图生成器</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该生成器是</a>专门为在alpha测试期间确定的游戏要求而创建的。 生物群落及其文章的颜色均来自这些项目。 </li><li> 在研究音频信号的处理时，我写了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">噪声教程</a> ，解释了诸如频率，幅度，八度和噪声的“颜色”等概念。 适用于声音的相同概念也适用于基于噪声的卡生成。 当时，我创建了一些原始的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示浮雕生成器</a> ，但是我没有完成它们。 </li><li> 有时我会尝试寻找界限。 我想知道创建引人注目的地图最少需要多少代码。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这个小型项目中，</a>我达到了<b>零</b>行代码-一切都由图像滤镜完成（湍流，阈值，颜色渐变）。 这让我感到高兴和悲伤。 图像过滤器可以在多大程度上执行地图生成？ 在足够大。 以上关于“平滑颜色渐变方案”的所有描述均来自此实验。 噪声层是湍流图像滤波器。 八度音阶是彼此叠加的图像； 学位工具在Photoshop中称为“曲线校正”。 </li></ul><br> 让我感到困扰的是，游戏开发人员为基于噪声的地形生成（包括中点位移）编写的大多数代码都与声音和图像过滤器中的相同。 另一方面，它仅用几行代码即可产生相当不错的结果，这就是我撰写本文的原因。 这是一个<em>快速简便的参考点</em> 。 通常，我不会长时间使用此类卡，但是一旦发现哪种类型的卡更适合游戏设计，就立即用更复杂的地图生成器替换它们。 这是我的标准模式：从非常简单的内容开始，然后在我更好地了解要使用的系统之后才进行替换。 <br><br> 在噪声中，还有<em>很多</em>事情可以做，在本文中我只提到了一些。 尝试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Noise Studio</a>交互式测试各种功能。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430384/">https://habr.com/ru/post/zh-CN430384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430374/index.html">数据工程及其他：毁录会议录像带和幻灯片</a></li>
<li><a href="../zh-CN430376/index.html">JavaScript指南第6部分：异常，分号，模板文字</a></li>
<li><a href="../zh-CN430378/index.html">J2CL-迟到总比不到好</a></li>
<li><a href="../zh-CN430380/index.html">JavaScript指南第5部分：数组和循环</a></li>
<li><a href="../zh-CN430382/index.html">JavaScript指南第4部分：功能</a></li>
<li><a href="../zh-CN430386/index.html">印度将建设固态存储电站</a></li>
<li><a href="../zh-CN430388/index.html">网络峰会非会议</a></li>
<li><a href="../zh-CN430392/index.html">如何使用PieceofScript“ bike”开发和测试API</a></li>
<li><a href="../zh-CN430394/index.html">使用RxJava在Android中实现即时搜索</a></li>
<li><a href="../zh-CN430396/index.html">链复制：构建有效的KV存储库（第1/2部分）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>