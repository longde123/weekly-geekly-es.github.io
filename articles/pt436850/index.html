<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏼‍🤝‍🧑🏼 🦏 🤴🏻 Erros comuns ao escrever testes de unidade. Palestra Yandex 👈🏽 🦃 🖖🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se você domina uma pequena lista de erros típicos que ocorrem ao escrever testes de unidade, pode até gostar de escrevê-los. Hoje, o chefe do grupo de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erros comuns ao escrever testes de unidade. Palestra Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/436850/">  Se você domina uma pequena lista de erros típicos que ocorrem ao escrever testes de unidade, pode até gostar de escrevê-los.  Hoje, o chefe do grupo de desenvolvimento Yandex.Browser para Android, Konstantin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">kzaikin</a> Zaikin, compartilhará sua experiência com os leitores da Habr. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZyGZjpxF9Fo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Eu tenho um relatório prático.  Espero que isso beneficie todos vocês - aqueles que já estão escrevendo testes de unidade, e aqueles que estão apenas pensando em escrever, e aqueles que estão tentando e que não tiveram sucesso. <a name="habracut"></a><br><br>  Temos um projeto bem grande.  Um dos maiores projetos móveis da Rússia.  Temos muito código, muitos testes.  Os testes são perseguidos em cada solicitação de pool, eles não caem ao mesmo tempo. <br><br>  Quem sabe que cobertura de teste ele tem no projeto?  Zero, tudo bem.  Quem tem testes de unidade no projeto?  E quem acredita que testes de unidade não são necessários?  Não vejo nada de errado nisso, há pessoas sinceramente convencidas disso, e minha história deve ajudá-las a se convencer disso. <br><br>  Felizmente, milhares de testes ecológicos - não viemos imediatamente.  Não há bala de prata, e a principal idéia do meu relatório na tela: <br><br><img src="https://habrastorage.org/webt/w1/0y/wm/w10ywme1xumvi5asap7gp0a5iee.jpeg"><br><br>  O ditado chinês está escrito em hieróglifos que uma jornada de mil ou mais começa com um passo.  Parece que existe um análogo desse ditado. <br><br>  Decidimos há muito tempo que precisamos melhorar nosso produto, nosso código e estamos caminhando para isso de propósito.  Dessa maneira, encontramos muitas inchaços, um ancinho subaquático, e reunimos algumas crenças. <br><br><img src="https://habrastorage.org/webt/ks/9z/5w/ks9z5wmzmkghfc-vireaf5rdvvg.jpeg"><br><br>  Por que precisamos de testes? <br><br>  Para que os recursos antigos não caiam quando introduzimos novos.  Para ter um selo no GitHub.  Para refatorar os recursos existentes - um pensamento profundo, ele precisa ser revelado para aqueles que não escrevem testes.  Para que os recursos existentes não caiam durante a refatoração, nos protegeremos com testes.  Para o chefe enviar uma solicitação de pool, sim. <br><br>  Minha opinião - por favor, não a associe à opinião da minha equipe - de que os testes nos ajudam.  Eles permitem que você execute seu código sem colocá-lo em produção, sem instalá-lo em dispositivos, você o inicia e executa muito rapidamente.  Você pode executar todos os casos de esquina que você não obtém na vida útil do dispositivo e na produção, e seu testador não os encontrará.  Mas você, como desenvolvedor, irá inventá-los, verificá-los e corrigir erros em um estágio inicial. <br><br>  Muito importante: os testes informam como, de acordo com o desenvolvedor, o código deve funcionar e o que, de acordo com o desenvolvedor, seus métodos devem fazer.  Estes não são comentários que se afastam e, depois de um tempo, os úteis se tornam prejudiciais.  Acontece que nos comentários uma coisa está escrita e o código é completamente diferente.  Os testes de unidade nesse sentido não podem mentir.  Se o teste for verde, ele documenta o que está acontecendo lá.  O teste falhou - você violou a intenção principal do desenvolvedor. <br><br>  Comprometer contratos.  Estes não são contratos assinados e carimbados, mas contratos de software para comportamento de classe.  Se você refatorar, nesse caso, os contratos serão violados e os testes cairão se você os quebrar.  Se os contratos forem salvos, os testes permanecerão verdes, você terá mais confiança de que sua refatoração está correta. <br><br><img src="https://habrastorage.org/webt/pr/z0/fc/prz0fclospeod5fnxeum2bi19gw.jpeg"><br><br>  Esta é a ideia geral de todo o meu relatório.  Você pode mostrar a primeira linha e sair. <br><br>  Muitas pessoas pensam que o código de teste é mais ou menos, não é para produção, então você pode escrevê-lo.  Eu discordo totalmente disso e acho que os testes devem ser abordados antes de tudo de forma responsável, bem como o código de produção.  Se você abordá-los da mesma maneira, os testes o beneficiarão.  Caso contrário, será uma mancha. <br><br>  Mais especificamente, as duas linhas abaixo se referem a qualquer código, ao que parece. <br><br>  BEIJO - mantenha simples, estúpido.  Não há necessidade de complicar.  Os testes devem ser simples.  E o código de produção deve ser simples, mas os testes são especialmente.  Se você tiver testes fáceis de ler, provavelmente serão bem escritos, bem expressos, fáceis de testar.  Mesmo durante a solicitação do pool, uma pessoa que analisa seus novos testes entenderá o que você queria dizer.  E se algo quebrar, você pode entender facilmente o que aconteceu. <br><br>  SECA - não se repita.  Nos testes, o desenvolvedor costuma usar a técnica proibida que ninguém parece usar na produção - copiar e colar.  Na produção de um desenvolvedor que copia e cola ativamente, eles simplesmente não entendem.  Nos testes, essa é uma prática normal, infelizmente.  Não há necessidade de fazer isso, porque - a primeira linha.  Se você escrever os testes honestamente, como um código realmente bom, os testes serão úteis para você. <br><br>  Enquanto desenvolvíamos centenas de milhares de linhas de código, escrevendo milhares de testes, coletando rakes, acumulei comentários típicos sobre os testes.  Sou muito preguiçoso e, quando fui às solicitações de pool e observei os mesmos erros, com base no princípio DRY, decidi anotar esses problemas típicos, e fiz isso primeiro no Wiki interno e depois publiquei cheiros práticos de teste no GitHub que você pode seguir quando você escreve testes. <br><br><img src="https://habrastorage.org/webt/oj/k1/u2/ojk1u2fjmy269sioq4vin6yylua.jpeg"><br><br>  Vou listar por pontos.  Incremente um contador em sua mente se você se lembrar de um cheiro de teste.  Se você contar até cinco, poderá levantar a mão e gritar "Bingo!"  E no final, eu me pergunto quem contou quanto.  Meu contador será igual ao número de pontos, eu mesmo os colecionei. <br><br><img src="https://habrastorage.org/webt/nm/pw/8n/nmpw8nk89hl6gmggyims0llmn28.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link do GitHub</a></sub></sup> </h5><br>  A coisa mais difícil de programar que você conhece.  E nos testes isso é realmente importante.  Se você não nomear bem o teste, provavelmente não poderá formular o que o teste verifica. <br><br>  Os seres humanos são criaturas bastante simples, são facilmente presos em nomes.  Portanto, peço que você chame bem os testes.  Formule um teste para verificar e seguir regras simples. <br><br><h4>  no_action_or_assertion </h4><br>  Se o nome do teste não contiver uma descrição do que o teste verifica, por exemplo, você tem a classe Controller e escreve o teste testController, o que você verifica?  O que esse teste deve fazer?  Muito provavelmente, nada ou muitas coisas para verificar.  Nem um nem outro nos convém.  Portanto, no nome do teste, você precisa escrever o que verificamos. <br><br><h4>  long_name </h4><br>  Você não pode ir para o outro extremo.  O nome do teste deve ser curto o suficiente para que uma pessoa possa analisá-lo facilmente.  Nesse sentido, o Kotlin é ótimo porque permite escrever nomes de teste entre aspas com espaços em inglês normal.  Eles são mais fáceis de ler.  Mas ainda assim, nomes longos são cheiro. <br><br>  Se o nome do seu teste for muito longo, você provavelmente colocará muitos métodos de teste em uma classe de teste e precisará esclarecer o que está verificando.  Nesse caso, você precisa dividir sua classe de teste em várias.  Não precisa ter medo disso.  Você terá um nome de classe de teste que verifica o nome do seu código de produção e haverá nomes curtos de teste. <br><br><h4>  older_prefix </h4><br>  Isso é atavismo.  Anteriormente, em Java, todos testavam usando JUnit, onde até a quarta versão havia um acordo de que os métodos de teste deveriam começar com a palavra teste.  Aconteceu, todo mundo ainda chama assim.  Mas há um problema, em inglês a palavra test é o verbo "check".  As pessoas são facilmente capturadas nessa armadilha e não escrevem mais nenhum outro verbo.  Escreva testController.  É fácil verificar a si mesmo: se você não escreveu um verbo, o que sua classe de teste deveria fazer, provavelmente você não verificou algo, não o escreveu bem o suficiente.  Portanto, sempre solicito que você remova a palavra teste dos nomes dos métodos de teste. <br><br>  Eu digo coisas muito simples, mas, curiosamente, elas ajudam.  Se os testes forem bem-chamados, provavelmente sob o capô eles ficarão bem.  É muito simples <br><br><img src="https://habrastorage.org/webt/1e/_h/b3/1e_hb3te9onmzprsqcvilm2i_cc.jpeg"><br><br>  Na verdade, eu li ids de cheiros de teste como no GitHub.  O link está abaixo, você pode andar e usar. <br><br><h4>  multiple_asserts </h4><br>  No método de teste, existem muitas afirmações.  Então, talvez ou não?  Talvez.  Isso é bom ou ruim?  Eu acho que isso é muito ruim.  Se você escreveu várias asserções em um método de teste, verifica várias instruções.  Se você testar seu teste e a primeira afirmação cair, o teste alcançará a segunda afirmação?  Não chegará.  Você já após a queda de sua montagem em algum lugar do IC consegue que o teste caísse, vá consertar algo, preencha novamente, ele cairá na próxima afirmação.  Poderia muito bem ser. <br><br>  Nesse caso, seria muito mais interessante se você usasse esse método de teste em vários, e todos os métodos com várias afirmações caíssem ao mesmo tempo, porque seriam lançados independentemente um do outro. <br><br>  Mais algumas asserções podem mascarar as diferentes ações que são executadas com a classe de teste.  Eu recomendo escrever um teste - um afirmar.  Os ativos podem ser bastante complicados.  Meu colega, no primeiro relatório, demonstrou um código em que ele usou a excelente afirmação de que a construção e o combinador.  Eu realmente amo combates no JUnit, então você pode usá-lo também.  Para o leitor de teste, acaba sendo apenas uma declaração curta.  O GitHub tem exemplos de todos esses odores e como corrigi-los.  Há um exemplo de código incorreto e algum código válido.  Tudo isso é feito na forma de um projeto que você pode baixar, abrir, compilar e executar todos os testes. <br><br><h4>  many_tests_in_one </h4><br>  O próximo cheiro está intimamente relacionado ao anterior.  Você faz algo com o sistema - você faz uma afirmação.  Fazendo outra coisa com o sistema, algumas operações longas - fazendo uma afirmação - fazendo outra coisa.  De fato, você simplesmente viu vários métodos e obtém bons e sólidos métodos de teste. <br><br><h4>  repeating_setup </h4><br>  Isso se refere à verbosidade.  Se você tem uma classe de teste e cada método de teste executa os mesmos métodos no início. <br><br>  Uma classe de teste na qual os mesmos métodos são executados no início.  Parece um pouco, mas em todo método de teste esse lixo está presente.  E se é comum a todos os métodos de teste, por que não levá-lo ao construtor ou bloco <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Antes</a> ou Bloco <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Antes de</a> Cada na JUnit 5. Se você fizer isso, a legibilidade de cada método melhorará, além de você se livrar do pecado SECO.  Tais testes são mais fáceis de manter e mais fáceis de ler. <br><br><img src="https://habrastorage.org/webt/jz/e6/pt/jze6ptgcma9s-f62hobgcoj5jbu.jpeg"><br><br>  A confiabilidade dos testes é muito importante.  Existem sinais pelos quais se pode determinar que o teste irá chorar, seja verde ou vermelho.  Quando o desenvolvedor escreve, ele tem certeza de que é verde e, por algum motivo, os testes ficam verdes ou vermelhos, o que nos dá dor e incerteza em geral de que os testes são úteis.  Não temos certeza dos testes, o que significa que não temos certeza de que sejam úteis. <br><br><h4>  aleatório </h4><br>  Eu próprio escrevi testes que continham Math.random (), faziam números aleatórios, faziam algo com eles.  Não há necessidade de fazer isso.  Esperamos que o sistema de teste entre no sistema de teste na mesma configuração e a saída dele também deve ser a mesma.  Portanto, em testes de unidade, por exemplo, você nunca precisa executar nenhuma operação com a rede.  Como o servidor pode não responder, pode haver horários diferentes, outra coisa. <br><br>  Se você precisar de um teste que funcione com a rede, faça um proxy local, qualquer coisa, mas em nenhum caso vá para uma rede real.  Isso é o mesmo aleatório.  E, claro, você não pode usar dados aleatórios.  Se você precisar fazer alguma coisa, faça alguns exemplos com condições de contorno, com más condições, mas elas devem ser codificadas. <br><br><h4>  tread_sleep </h4><br>  Um problema clássico que os desenvolvedores enfrentam ao tentar testar algum tipo de código assíncrono.  É que fiz algo no teste e preciso esperar até que seja concluído.  Como fazer?  Thread.sleep (), é claro. <br><br>  Há um problema.  Quando você desenvolveu seu teste, por exemplo, em algumas máquinas de escrever, ele funciona a certa velocidade.  Você executa os testes em outra máquina.  E o que acontecerá se o seu sistema não conseguir funcionar durante o tempo Thread.sleep ()?  O teste fica vermelho.  Isso é inesperado.  Portanto, a recomendação aqui é que, se você estiver executando operações assíncronas, não as teste.  Quase qualquer operação assíncrona pode ser implantada para que você tenha algum tipo de mecanismo condicional que forneça operação assíncrona e um bloco de código executado de forma síncrona.  Por exemplo, o AsyncTask possui um bloco de código executado de forma síncrona.  Você pode testá-lo facilmente de forma síncrona, sem nenhum assincronismo.  Não há necessidade de testar o próprio AsyncTask, é uma classe de estrutura, por que testá-lo?  Suporte e sua vida será mais fácil. <br><br>  Thread.sleep () é muito doloroso.  Além de piorar a confiabilidade dos testes, pois permite que eles chorem por causa de diferentes tempos nos dispositivos, isso também diminui a execução dos testes.  Quem gostaria que seus testes de unidade, que deveriam ser executados em milissegundos, fossem executados por cinco segundos, porque eu coloquei o sono em marcha? <br><br><h4>  modify_global </h4><br>  O cheiro típico é que alteramos algum tipo de variável estática global no início do teste para verificar se nosso sistema está funcionando corretamente, mas não retornamos no final.  Então, temos uma situação interessante: na máquina, o desenvolvedor executou os testes em uma sequência, primeiro verificou a variável global com o valor padrão, depois, no teste, ele a alterou e depois fez outra coisa.  Ambos os testes são verdes.  E no CI, aconteceu que os testes começaram na ordem inversa.  E um ou ambos os testes serão vermelhos, embora todos sejam verdes. <br><br>  Você precisa limpar depois de si mesmo.  Regras do escoteiro neste sentido: alterou a variável global - retorne ao estado original.  Melhor ainda, verifique se os estados globais não são usados.  Mas este é um pensamento mais profundo.  É sobre o fato de que os testes às vezes destacam defeitos na arquitetura.  Se tivermos que mudar estados globais e retorná-los ao estado original para escrever testes, estamos todos bem na nossa arquitetura?  Nós realmente precisamos de variáveis ​​globais, por exemplo?  Como regra, você pode ficar sem eles injetando algumas classes de contextos ou algo assim, para que você possa reinicializar, injetar e reinicializá-los sempre que no teste. <br><br><h4>  @VisibleForTesting </h4><br>  Teste de cheiro para avançado.  A necessidade de usar tal coisa não surge no primeiro dia, como regra.  Você já testou alguma coisa e precisou traduzir a classe em algum estado específico.  E você se torna um backdoor.  Você tem uma classe de produção e cria um método específico que nunca será chamado em produção e, por meio dela, injeta algo na classe ou altera seu estado.  Assim, quebrando maliciosamente o encapsulamento.  Na produção, sua classe funciona de alguma forma, mas nos testes, na verdade, é uma classe diferente, você se comunica com ela através de outras entradas e saídas.  E aqui você pode obter uma situação em que você altera a produção, mas os testes não percebem.  Os testes continuam a atravessar a porta dos fundos e não notaram que, por exemplo, as exceções começaram a disparar no construtor, uma vez que passam por outro construtor. <br><br>  Em geral, você deve testar suas classes com as mesmas entradas e saídas da produção.  Não deve haver acesso a nenhum método apenas para testes. <br><br><img src="https://habrastorage.org/webt/dy/sf/s0/dysfs0rl9n6ftff4nt3ftwpy988.jpeg"><br><br>  Quantos de nossos 15 mil testes são realizados?  Cerca de 20 minutos, a cada solicitação de pool, no Team City, os desenvolvedores são forçados a esperar.  Só porque 15 mil são muitos testes.  E nesta seção, compilei cheiros que atrasam os testes.  Embora o thread_sleep já estivesse lá. <br><br><h4>  desnecessary_android_test </h4><br>  O Android tem testes de instrumentação, eles são lindos, executados em um dispositivo ou emulador.  Isso elevará seu projeto completamente, de verdade, mas eles são muito lentos.  E para eles você precisa até criar um emulador inteiro.  Mesmo se você imaginar que possui um emulador levantado no CI - coincide apenas com um -, a execução do teste no emulador levará muito mais tempo do que na máquina host, por exemplo, usando Robolectric.  Embora existam outros métodos.  Essa é uma estrutura que permite trabalhar com classes da estrutura do Android na máquina host, em Java puro.  Nós o usamos bastante ativamente.  Anteriormente, o Google era um pouco legal sobre isso, mas agora os próprios googlers falam sobre isso em vários relatórios, é recomendado para uso. <br><br><h4>  desnecessary_robolectric </h4><br>  A estrutura Android do Robolectric é emulada.  Não está completo lá, embora a implementação seja mais longe, mais completa.  É um Android quase real, rodando apenas no seu desktop, laptop ou CI.  Mas também não precisa ser usado em qualquer lugar.  Robolectric não é gratuito.  Se você tem um teste que você heroicamente transferiu da instrumentação Android para o Robolectric, você deve pensar - talvez vá ainda mais longe, se livrar do Robolectric, transformá-lo no teste JUnit mais simples?  Os testes robolétricos levam tempo para inicializar, tentar carregar recursos, inicializar sua atividade, aplicativo e tudo mais.  Isso leva algum tempo.  Isso não é um segundo, são milissegundos, às vezes dezenas e centenas.  Mas quando existem muitos testes, mesmo isso importa. <br><br>  Existem técnicas que se livram do Robolectric.  Você pode isolar seu código por meio de interfaces, agrupando toda a parte da plataforma com interfaces.  Depois, haverá apenas um teste de host JUnit.  O JUnit na máquina host é muito rápido, há uma quantidade mínima de sobrecarga; esses testes podem ser executados aos milhares e dezenas de milhares; eles executarão um minuto, alguns minutos.  Infelizmente, nossos testes são executados por um longo tempo porque temos muitos testes de instrumentação Android, porque temos uma parte nativa no navegador e somos forçados a executá-los em um emulador ou dispositivo real.  Por que tanto tempo. <br><br>  Eu não vou mais aborrecer você.  Quantos cheiros você tem?  Até agora, sete no máximo.  Inscreva-se no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">canal</a> , coloque as estrelas. <br><br><img src="https://habrastorage.org/webt/ph/cs/52/phcs52po2jsf1lbjumu1um2e3ha.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436850/">https://habr.com/ru/post/pt436850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436838/index.html">Entendendo redes neurais convolucionais através de visualizações no PyTorch</a></li>
<li><a href="../pt436840/index.html">O caminho do brilho para a neurociência: um podcast temático sobre carreiras em marketing de mídia e conteúdo</a></li>
<li><a href="../pt436842/index.html">Solução Veeam para backup e recuperação de máquinas virtuais na plataforma Nutanix AHV. Parte 2</a></li>
<li><a href="../pt436846/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 348 (14-20 de janeiro de 2019)</a></li>
<li><a href="../pt436848/index.html">NSA anuncia lançamento de ferramenta interna para engenharia reversa</a></li>
<li><a href="../pt436852/index.html">Abrandar para impulsionar o desenvolvimento</a></li>
<li><a href="../pt436854/index.html">Rust 1.32 Release</a></li>
<li><a href="../pt436856/index.html">Plano de desenvolvimento de TI de acordo com o Ministério das Comunicações: soberania digital, blockchain em serviços habitacionais e comunitários, software para “realidade mudada”</a></li>
<li><a href="../pt436858/index.html">Esperanto, Elven e Klingon</a></li>
<li><a href="../pt436860/index.html">Dell e Alienware na CES 2019: um guia para todas as principais inovações</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>