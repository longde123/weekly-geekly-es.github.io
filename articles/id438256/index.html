<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¼â€ğŸ’¼ ğŸ‘¨ğŸ»â€ğŸš€ ğŸ‘©ğŸ½â€âœˆï¸ Lakukan lebih banyak dengan pola di C # 8.0 ğŸ‘ƒğŸ» ğŸ¢ ğŸ‘°ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Visual Studio 2019 Pratinjau 2 sudah keluar! Dan dengan itu, beberapa fitur C # 8.0 siap untuk Anda coba. Sebagian besar tentang pencocokan pola, mesk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lakukan lebih banyak dengan pola di C # 8.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/438256/"><img width="120" align="left" src="https://habrastorage.org/webt/8w/rq/7v/8wrq7vfhyqv2saamr2d5z2jha5o.png"><p>  Visual Studio 2019 Pratinjau 2 sudah keluar!  Dan dengan itu, beberapa fitur C # 8.0 siap untuk Anda coba.  Sebagian besar tentang pencocokan pola, meskipun saya akan menyentuh beberapa berita lain dan perubahan pada akhirnya. </p><br><a name="habracut"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Asli di Blog</a> <br><br><h1>  Lebih banyak pola di lebih banyak tempat </h1><br><p> Ketika C # 7.0 memperkenalkan pencocokan pola, kami mengatakan bahwa kami berharap untuk menambahkan <em>lebih banyak</em> pola di <em>lebih banyak</em> tempat di masa depan.  Waktunya telah tiba!  Kami menambahkan apa yang kami sebut <em>pola rekursif</em> , serta bentuk ekspresi yang lebih kompak dari pernyataan <code>switch</code> yang disebut (Anda tebak!) Beralih <em>ekspresi</em> . </p><br><p>  Berikut adalah contoh pola C # 7.0 sederhana untuk memulai kami: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { get; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { get; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>=&gt; (X, Y) = (x, y); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>=&gt; (x, y) = (X, Y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>; } }</code> </pre><br><h2>  Alihkan ekspresi </h2><br><p>  Pertama, mari kita amati bahwa banyak pernyataan <code>switch</code> benar-benar tidak melakukan banyak pekerjaan menarik dalam badan-badan kasing.  Seringkali mereka semua hanya menghasilkan nilai, baik dengan menugaskannya ke variabel atau dengan mengembalikannya (seperti di atas).  Dalam semua situasi itu, pernyataan pergantian terus terang agak kikuk.  Rasanya seperti fitur bahasa 5-dekade-tua itu, dengan banyak upacara. </p><br><p>  Kami memutuskan sudah waktunya untuk menambahkan bentuk ekspresi <code>switch</code> .  Ini dia, diterapkan pada contoh di atas: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> }; }</code> </pre><br><p>  Ada beberapa hal di sini yang berubah dari pernyataan switch.  Mari kita daftar mereka: </p><br><ul><li>  Kata kunci <code>switch</code> adalah "infix" antara nilai yang diuji dan daftar case <code>{...}</code> .  Itu membuatnya lebih komposisional dengan ekspresi lain, dan juga lebih mudah untuk membedakan secara visual dari pernyataan switch. </li><li>  Kata kunci <code>case</code> dan <code>:</code> telah diganti dengan panah lambda <code>=&gt;</code> untuk singkatnya. </li><li>  <code>default</code> telah diganti dengan pola <code>_</code> discard for brevity. </li><li>  Tubuh adalah ekspresi!  Hasil dari body yang dipilih menjadi hasil dari ekspresi switch. </li></ul><br><p>  Karena ekspresi perlu memiliki nilai atau melempar pengecualian, ekspresi switch yang mencapai akhir tanpa kecocokan akan melempar pengecualian.  Compiler melakukan pekerjaan yang baik untuk memperingatkan Anda ketika hal ini mungkin terjadi, tetapi tidak akan memaksa Anda untuk mengakhiri semua ekspresi switch dengan catch-all: Anda mungkin tahu lebih baik! </p><br><p>  Tentu saja, karena metode <code>Display</code> kami sekarang terdiri dari pernyataan pengembalian tunggal, kami dapat menyederhanakannya menjadi ekspresi-tubuh: </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; $<span class="hljs-string"><span class="hljs-string">"({pX}, {pY})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  Sejujurnya, saya tidak yakin panduan format apa yang akan kami berikan di sini, tetapi harus jelas bahwa ini jauh lebih jelas dan jelas, terutama karena singkatnya biasanya Anda dapat memformat sakelar dengan cara "tabular", seperti di atas , dengan pola dan badan pada baris yang sama, dan <code>=&gt;</code> berbaris di bawah satu sama lain. </p><br><p>  Ngomong-ngomong, kami berencana untuk mengizinkan koma tertinggal <code>,</code> setelah kasus terakhir sesuai dengan semua "daftar yang dipisahkan koma dalam kurung kurawal" di C #, tetapi Pratinjau 2 belum mengizinkannya. </p><br><h2>  Pola properti </h2><br><p>  Berbicara tentang singkatnya, polanya tiba-tiba menjadi elemen terberat dari ekspresi saklar di atas!  Mari kita lakukan sesuatu tentang itu. </p><br><p>  Perhatikan bahwa ekspresi sakelar menggunakan <em>pola tipe</em> <code>Point p</code> (dua kali), serta klausa <code>when</code> untuk menambahkan kondisi tambahan untuk <code>case</code> pertama. </p><br><p>  Dalam C # 8.0 kami menambahkan lebih banyak elemen opsional ke pola tipe, yang memungkinkan pola itu sendiri menggali lebih jauh ke dalam nilai yang sedang dicocokkan dengan pola.  Anda dapat menjadikannya <em>pola properti</em> dengan menambahkan <code>{...}</code> mengandung pola bersarang untuk diterapkan pada properti atau bidang yang dapat diakses nilai.  Ini mari kita menulis ulang ekspresi switch sebagai berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } p =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: var x, Y: var y } p =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  Kedua kasus masih memeriksa bahwa <code>o</code> adalah sebuah <code>Point</code> .  Kasus pertama kemudian menerapkan pola konstan <code>0</code> secara rekursif ke properti <code>X</code> dan <code>Y</code> dari <code>p</code> , memeriksa apakah mereka memiliki nilai itu.  Dengan demikian kita dapat menghilangkan klausa <code>when</code> dalam hal ini dan banyak kasus umum. </p><br><p>  Kasus kedua menerapkan pola <code>var</code> untuk masing-masing <code>X</code> dan <code>Y</code>  Ingat bahwa pola <code>var</code> di C # 7.0 selalu berhasil, dan cukup mendeklarasikan variabel baru untuk menyimpan nilai.  Jadi <code>x</code> dan <code>y</code> bisa mengandung nilai int <code>pX</code> dan <code>pY</code> . </p><br><p>  Kami tidak pernah menggunakan <code>p</code> , dan bahkan dapat menghilangkannya di sini: </p><br><pre> <code class="cpp hljs"> Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: var x, Y: var y } =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span></code> </pre><br><p>  Satu hal yang tetap benar dari semua pola tipe termasuk pola properti, adalah bahwa mereka memerlukan nilai menjadi nol.  Itu membuka kemungkinan pola properti "kosong" <code>{}</code> digunakan sebagai pola "tidak-nol" yang ringkas.  Misalnya, kita dapat mengganti kasing mundur dengan dua kasing berikut: </p><br><pre> <code class="cpp hljs"> {} =&gt; o.ToString(), null =&gt; <span class="hljs-string"><span class="hljs-string">"null"</span></span></code> </pre><br><p>  <code>{}</code> Berurusan dengan objek nonnull yang tersisa, dan <code>null</code> mendapatkan nulls, sehingga sakelarnya lengkap dan kompilator tidak akan mengeluh tentang nilai yang jatuh. </p><br><h2>  Pola posisi </h2><br><p>  Pola properti tidak benar-benar membuat <code>Point</code> kedua <em>lebih pendek</em> , dan tampaknya tidak sepadan dengan masalah di sana, tetapi ada lebih banyak yang bisa dilakukan. </p><br><p>  Perhatikan bahwa kelas <code>Point</code> memiliki metode <code>Deconstruct</code> , yang disebut <em>dekonstruktor</em> .  Dalam C # 7.0, dekonstruktur memungkinkan nilai didekonstruksi pada tugas, sehingga Anda bisa menulis misalnya: </p><br><pre> <code class="cpp hljs">(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">// split up the Point according to its deconstructor</span></span></code> </pre><br><p>  C # 7.0 tidak mengintegrasikan dekonstruksi dengan pola.  Itu berubah dengan <em>pola posisi</em> yang merupakan cara tambahan bahwa kita memperluas pola tipe di C # 8.0.  Jika jenis yang cocok adalah tipe tuple atau memiliki dekonstruktor, kita dapat menggunakan pola posisi sebagai cara ringkas menerapkan pola rekursif tanpa harus menyebutkan properti: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>=&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point(var x, var y) =&gt; $<span class="hljs-string"><span class="hljs-string">"({x}, {y})"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre><br><p>  Setelah objek dicocokkan sebagai sebuah <code>Point</code> , dekonstruktor diterapkan, dan pola bersarang diterapkan ke nilai yang dihasilkan. </p><br><p>  Dekonstruksi tidak selalu tepat.  Mereka hanya boleh ditambahkan ke tipe yang benar-benar jelas nilai mana yang.  Untuk kelas <code>Point</code> , misalnya, aman dan intuitif untuk mengasumsikan bahwa nilai pertama adalah <code>X</code> dan yang kedua adalah <code>Y</code> , sehingga ekspresi saklar di atas adalah intuitif dan mudah dibaca. </p><br><h2>  Pola Tuple </h2><br><p>  Kasus khusus pola posisi yang sangat berguna adalah ketika diterapkan pada tupel.  Jika pernyataan sakelar diterapkan ke ekspresi tupel secara langsung, kami bahkan membiarkan set kurung tambahan dihilangkan, seperti pada <code>switch (x, y, z)</code> alih-alih <code>switch ((x, y, z))</code> . </p><br><p>  Pola Tuple bagus untuk menguji beberapa input sekaligus.  Berikut ini adalah implementasi sederhana dari mesin negara: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey)</span></span></span><span class="hljs-function"> </span></span>=&gt; (current, transition) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close) =&gt; Closed, (Closed, Open) =&gt; Opened, (Closed, Lock) when hasKey =&gt; Locked, (Locked, Unlock) when hasKey =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException($<span class="hljs-string"><span class="hljs-string">"Invalid transition"</span></span>) };</code> </pre><br><p>  Tentu saja kita bisa memilih untuk memasukkan <code>hasKey</code> dalam tuple yang diaktifkan daripada menggunakan <code>when</code> klausa - itu benar-benar masalah selera: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey)</span></span></span><span class="hljs-function"> </span></span>=&gt; (current, transition, hasKey) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close, _) =&gt; Closed, (Closed, Open, _) =&gt; Opened, (Closed, Lock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Locked, (Locked, Unlock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException($<span class="hljs-string"><span class="hljs-string">"Invalid transition"</span></span>) };</code> </pre><br><p>  Secara keseluruhan, saya harap Anda dapat melihat bahwa pola rekursif dan beralih ekspresi dapat mengarah pada logika program yang lebih jelas dan deklaratif. </p><br><h1>  Fitur C # 8.0 lainnya di Pratinjau 2 </h1><br><p>  Sementara fitur pola adalah yang utama untuk online di VS 2019 Pratinjau 2, Ada beberapa yang lebih kecil yang saya harap Anda juga akan menemukan yang berguna dan menyenangkan.  Saya tidak akan menjelaskan lebih lanjut di sini, tetapi hanya memberi Anda penjelasan singkat tentang masing-masing. </p><br><h2>  Menggunakan deklarasi </h2><br><p>  Dalam C #, <code>using</code> pernyataan selalu menyebabkan tingkat bersarang, yang bisa sangat mengganggu dan merusak keterbacaan.  Untuk kasus sederhana di mana Anda hanya ingin sumber daya dibersihkan di akhir ruang lingkup, Anda sekarang harus <em>menggunakan deklarasi</em> .  Menggunakan deklarasi hanyalah deklarasi variabel lokal dengan kata kunci <code>using</code> di depan, dan isinya dibuang di akhir blok pernyataan saat ini.  Jadi alih-alih: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var options = Parse(args)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } ... } <span class="hljs-comment"><span class="hljs-comment">// options disposed here }</span></span></code> </pre><br><p>  Anda cukup menulis </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> var options = Parse(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">// options disposed here</span></span></code> </pre><br><h2>  Struct ref sekali pakai </h2><br><p>  Referensi struct diperkenalkan di C # 7.2, dan ini bukan tempat untuk mengulangi kegunaannya, tetapi sebagai imbalannya mereka datang dengan beberapa batasan yang parah, seperti tidak dapat mengimplementasikan antarmuka.  Struct Ref sekarang dapat sekali pakai tanpa menerapkan antarmuka <code>IDisposable</code> , hanya dengan memiliki metode <code>Dispose</code> di dalamnya. </p><br><h2>  Fungsi lokal statis </h2><br><p>  Jika Anda ingin memastikan fungsi lokal Anda tidak menimbulkan biaya runtime yang terkait dengan variabel "capturing" (referensi) dari lingkup terlampir, Anda dapat mendeklarasikannya sebagai <code>static</code> .  Kemudian kompiler akan mencegah referensi apa pun yang dideklarasikan dalam fungsi melampirkan - kecuali fungsi lokal statis lainnya! </p><br><h1>  Perubahan sejak Pratinjau 1 </h1><br><p>  Fitur utama dari Pratinjau 1 adalah jenis referensi yang dapat dibatalkan dan aliran async.  Keduanya telah berevolusi sedikit di Pratinjau 2, jadi jika Anda sudah mulai menggunakannya, berikut ini baik untuk diperhatikan. </p><br><h2>  Jenis referensi tidak dapat dibatalkan </h2><br><p>  Kami telah menambahkan lebih banyak opsi untuk mengontrol peringatan yang dapat <code>#nullable</code> baik dalam sumber (melalui arahan <code>#pragma warning</code> <code>#nullable</code> dan <code>#pragma warning</code> ) dan di tingkat proyek.  Kami juga mengubah keikutsertaan file proyek ke <code>&lt;NullableContextOptions&gt;enable&lt;/NullableContextOptions&gt;</code> . </p><br><h2>  Async stream </h2><br><p>  Kami mengubah bentuk antarmuka <code>IAsyncEnumerable&lt;T&gt;</code> yang diharapkan oleh kompiler!  Ini membuat kompiler tidak sinkron dengan antarmuka yang disediakan di .NET Core 3.0 Preview 1, yang dapat menyebabkan Anda mengalami sejumlah masalah.  Namun, .NET Core 3.0 Preview 2 akan segera keluar, dan itu membawa antarmuka kembali sinkron. </p><br><h1>  Miliki itu! </h1><br><p>  Seperti biasa, kami ingin umpan balik Anda!  Silakan bermain-main dengan fitur pola baru pada khususnya.  Apakah Anda mengalami dinding bata?  Apakah ada yang mengganggu?  Apa saja skenario keren dan berguna yang Anda temukan untuk mereka?  Tekan tombol umpan balik dan beri tahu kami! </p><br><p>  Selamat melakukan peretasan </p><br><p>  Mads Torgersen, pemimpin desain untuk C # </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438256/">https://habr.com/ru/post/id438256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438244/index.html">Kami berurusan dengan peraturan kriptografi Rusia ... menggunakan contoh penangkapan seorang raja narkoba</a></li>
<li><a href="../id438248/index.html">GitHub Action Life</a></li>
<li><a href="../id438250/index.html">Ketidaktahuan tentang prinsip-prinsip keamanan informasi tidak terkecuali</a></li>
<li><a href="../id438252/index.html">Mengapa tidak melepas portal real estat. Bagian 1</a></li>
<li><a href="../id438254/index.html">Eclipse Meluncurkan GlassFish 5.1 untuk Java EE 8</a></li>
<li><a href="../id438260/index.html">"Modern" C ++: sesi ratapan dengan ratapan</a></li>
<li><a href="../id438262/index.html">Sistem cyber-fisik di dunia modern</a></li>
<li><a href="../id438264/index.html">Enkripsi Lalu Lintas dalam Sambungan Langsung, Bagian 1</a></li>
<li><a href="../id438266/index.html">Mengapa pentesting penting untuk bisnis Anda?</a></li>
<li><a href="../id438270/index.html">Love Kubernetes di Mail.ru Group: 14 Februari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>