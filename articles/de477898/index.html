<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇 👩🏼‍💻 ✅ Einführung in die kontextorientierte Kotlin-Programmierung 👩🏿‍🤝‍👩🏽 👨🏻‍⚕️ 🏈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist eine Übersetzung von Eine Einführung in die kontextorientierte Programmierung in Kotlin 

 In diesem Artikel werde ich versuchen, ein neues P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in die kontextorientierte Kotlin-Programmierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/477898/">  <i>Dies ist eine Übersetzung von <a href="https://proandroiddev.com/an-introduction-context-oriented-programming-in-kotlin-2e79d316b0a2">Eine Einführung in die kontextorientierte Programmierung in Kotlin</a></i> <br><br>  In diesem Artikel werde ich versuchen, ein neues Phänomen zu beschreiben, das als Nebenprodukt der raschen Entwicklung der Kotlin-Sprache entstanden ist.  Dies ist ein neuer Ansatz zum Entwerfen der Architektur von Anwendungen und Bibliotheken, den ich als kontextorientierte Programmierung bezeichnen werde. <br><br><h2>  Ein paar Worte zu Funktionsberechtigungen </h2><br>  Bekanntlich gibt es drei Hauptprogrammierparadigmen ( <i>Anmerkung von Pedant</i> : Es gibt andere Paradigmen): <br><br><ul><li>  Prozedurale Programmierung </li><li>  Objektorientierte Programmierung </li><li>  Funktionale Programmierung </li></ul><a name="habracut"></a><br>  Alle diese Ansätze arbeiten auf die eine oder andere Weise mit Funktionen.  Betrachten wir dies unter dem Gesichtspunkt der Auflösung von Funktionen oder der Planung ihrer Aufrufe (dh der Auswahl der Funktion, die an dieser Stelle verwendet werden soll).  Die prozedurale Programmierung ist durch die Verwendung globaler Funktionen und deren statische Auflösung auf der Grundlage des Funktionsnamens und der Argumenttypen gekennzeichnet.  Natürlich können Typen nur bei statisch typisierten Sprachen verwendet werden.  In Python werden Funktionen beispielsweise nach Namen aufgerufen, und wenn die Argumente falsch sind, wird zur Laufzeit während der Programmausführung eine Ausnahme ausgelöst.  Die Auflösung von Funktionen in Sprachen mit prozeduralem Ansatz basiert nur auf dem Namen der Prozedur / Funktion und ihren Parametern und erfolgt in den meisten Fällen statisch. <br><br>  Ein objektorientierter Programmierstil begrenzt den Funktionsumfang.  Funktionen sind nicht global, sondern Teil von Klassen und können nur für eine Instanz der entsprechenden Klasse aufgerufen werden ( <i>Anmerkung von Pedant</i> : Einige klassische prozedurale Sprachen haben ein modulares System und daher einen Geltungsbereich; prozedurale Sprache! = C). <br><br>  Natürlich können wir eine Mitgliedsfunktion einer Klasse immer durch eine globale Funktion durch ein zusätzliches Argument des Typs des aufgerufenen Objekts ersetzen, aber aus syntaktischer Sicht ist der Unterschied ziemlich bedeutend.  In diesem Fall sind die Methoden beispielsweise in der Klasse gruppiert, auf die sie sich beziehen, und daher ist klarer ersichtlich, welche Art von Verhalten die Objekte dieses Typs liefern. <br><br>  Am wichtigsten ist hier natürlich die Kapselung, aufgrund derer einige Felder einer Klasse oder ihr Verhalten privat und nur für Mitglieder dieser Klasse zugänglich sein können (Sie können dies nicht in einem rein prozeduralen Ansatz angeben), und der Polymorphismus, dank dessen die tatsächlich verwendete Methode nicht nur anhand des Namens bestimmt wird Methode, sondern auch basierend auf dem Typ des Objekts, von dem es aufgerufen wird.  Das Auslösen eines Methodenaufrufs in einem objektorientierten Ansatz hängt vom Typ des zur Laufzeit definierten Objekts, dem Namen der Methode und dem Typ der Argumente in der Kompilierungsphase ab. <br><br>  Ein funktionaler Ansatz bringt in Bezug auf die Funktionsauflösung nichts grundlegend Neues.  In funktionsorientierten Sprachen gelten in der Regel bessere Regeln für die Unterscheidung zwischen Sichtbarkeitsbereichen ( <i>Pedant-Hinweis</i> : Wiederum sind nicht alle prozeduralen Sprachen in C enthalten, es gibt auch solche, in denen Sichtbarkeitsbereiche gut abgegrenzt sind), mit denen die Sichtbarkeit von Funktionen auf der Grundlage des Systems genauer gesteuert werden kann Module, aber ansonsten erfolgt die Auflösung zur Kompilierungszeit basierend auf der Art der Argumente. <br><br><h2>  Was ist das </h2><br>  Beim Objektansatz haben wir beim Aufrufen einer Methode für ein Objekt die Argumente, aber zusätzlich haben wir einen expliziten (im Fall von Python) oder einen impliziten Parameter, der eine Instanz der aufgerufenen Klasse darstellt (im Folgenden werden alle Beispiele in Kotlin geschrieben): <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ println(<span class="hljs-string"><span class="hljs-string">"    </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre> <br>  Verschachtelte Klassen und Closures erschweren die Sache ein wenig: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doBSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doASomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: B{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doBSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ println(<span class="hljs-string"><span class="hljs-string">"    </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${this@A}</span></span></span><span class="hljs-string">"</span></span>) } } b.doBSomething() } }</code> </pre> <br>  In diesem Fall gibt es zwei implizite <i>Bedingungen</i> für die Funktion <i>doBSomething</i> : Die eine entspricht einer Instanz der Klasse <i>B</i> und die andere ergibt sich aus dem Abschluss von Instanz <i>A.</i>  Das Gleiche passiert im weitaus häufigeren Fall des Lambda-Verschlusses.  Es ist wichtig zu beachten, dass dies in diesem Fall nicht nur als impliziter Parameter funktioniert, sondern auch als Bereich oder Kontext für alle Funktionen und Objekte, die im lexikalischen Bereich aufgerufen werden.  Die Methode doBSomething hat also Zugriff auf alle Mitglieder der Klasse <i>A</i> (öffentlich oder privat) sowie auf die Mitglieder von <i>B</i> selbst. <br><br><h2>  Und hier ist Kotlin </h2><br>  Kotlin gibt uns ein völlig neues "Spielzeug" - <a href="https://kotlinlang.org/docs/reference/extensions.html">Erweiterungsfunktionen</a> .  ( <i>Anmerkung von Pedant</i> : Eigentlich sind sie nicht so neu, sie existieren auch in C #.)  Sie können eine Funktion wie <i>A.doASomething</i> () an einer beliebigen Stelle im Programm definieren, nicht nur in <i>A.</i>  In dieser Funktion gibt es einen impliziten Parameter namens receiver, der auf Instanz <i>A</i> verweist, auf der die Methode aufgerufen wird: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">doASomthing</span></span></span></span>(){ println(<span class="hljs-string"><span class="hljs-string">" -   </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = A() a.doASomthing() }</code> </pre> <br>  Erweiterungsfunktionen haben keinen Zugriff auf die privaten Mitglieder ihres Empfängers, sodass die Kapselung nicht verletzt wird. <br><br>  Das nächste wichtige Ding, das Kotlin hat, sind Codeblöcke mit Empfängern.  Sie können einen beliebigen Codeblock ausführen, indem Sie etwas als Empfänger verwenden: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doInternalSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> A.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doASomthing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = A() with(a){ doInternalSomething() doASomthing() } }</code> </pre> <br>  In diesem Beispiel könnten beide Funktionen ohne ein zusätzliches „ <i>a</i> “ aufgerufen werden, da die with-Funktion den gesamten Code des nachfolgenden Blocks in den Kontext von a einfügt.  Dies bedeutet, dass alle Funktionen in diesem Block so aufgerufen werden, als wären sie auf dem (explizit übergebenen) Objekt <i>a</i> aufgerufen worden. <br><br>  Der letzte Schritt an dieser Stelle in der kontextorientierten Programmierung ist die Möglichkeit, Erweiterungen als Mitglieder einer Klasse zu deklarieren.  In diesem Fall wird die Erweiterungsfunktion in einer anderen Klasse wie folgt definiert: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> B.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doBSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = A() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = B() with(a){ b.doBSomething() <span class="hljs-comment"><span class="hljs-comment">//   } b.doBSomething() //   }</span></span></code> </pre> <br>  Es ist wichtig, dass <i>B</i> hier ein neues Verhalten bekommt, aber nur, wenn es sich in einem bestimmten lexikalischen Kontext befindet.  Eine Erweiterungsfunktion ist ein reguläres Mitglied der Klasse <i>A.</i>  Dies bedeutet, dass die Auflösung der Funktion statisch basierend auf dem Kontext erfolgt, in dem sie aufgerufen wird. Die tatsächliche Implementierung wird jedoch durch die Instanz von <i>A bestimmt</i> , die als Kontext übergeben wird.  Die Funktion kann sogar mit dem Zustand des Objekts <i>a</i> interagieren. <br><br><h2>  Kontextorientierter Versand </h2><br>  Zu Beginn des Artikels haben wir verschiedene Ansätze zum Verteilen von Funktionsaufrufen erörtert, und zwar aus einem bestimmten Grund.  Tatsache ist, dass Sie mit den Erweiterungsfunktionen in Kotlin auf eine neue Art und Weise mit dem Disponieren arbeiten können.  Die Entscheidung, welche bestimmte Funktion verwendet werden soll, basiert nun nicht nur auf der Art ihrer Parameter, sondern auch auf dem lexikalischen Kontext ihres Aufrufs.  Das heißt, der gleiche Ausdruck in unterschiedlichen Kontexten kann unterschiedliche Bedeutungen haben.  Aus Sicht der Implementierung ändert sich natürlich nichts, und wir haben immer noch ein explizites Empfängerobjekt, das das Dispatching für seine Methoden und Erweiterungen definiert, die im Hauptteil der Klasse selbst beschrieben sind (Member-Erweiterungen). Aus syntaktischer Sicht ist dies jedoch ein anderer Ansatz . <br><br>  Schauen wir uns an, wie sich der kontextorientierte Ansatz vom klassischen objektorientierten Ansatz unterscheidet, und nehmen wir als Beispiel das klassische Problem der arithmetischen Operationen mit Zahlen in Java.  Die <i>Zahlenklasse</i> in Java und Kotlin ist das übergeordnete Element für alle Zahlen, aber im Gegensatz zu spezialisierten Zahlen wie Double werden die mathematischen Operationen nicht definiert.  So können Sie beispielsweise nicht schreiben: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n: Number = <span class="hljs-number"><span class="hljs-number">1.0</span></span> n + <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-comment"><span class="hljs-comment">//  `plus`     `Number`</span></span></code> </pre><br>  Der Grund hierfür ist, dass es nicht möglich ist, arithmetische Operationen für alle numerischen Typen konsistent zu definieren.  Beispielsweise unterscheidet sich die Ganzzahldivision von der Gleitkommadivision.  In einigen besonderen Fällen weiß der Benutzer, welche Art von Operation erforderlich ist, aber normalerweise macht es keinen Sinn, solche Dinge global zu definieren.  Eine objektorientierte (und tatsächlich funktionale) Lösung besteht darin, einen neuen Vererbungstyp der <i>Number-</i> Klasse zu definieren, die erforderlichen Operationen darin auszuführen und diese bei Bedarf zu verwenden (in Kotlin 1.3 können Sie Inline-Klassen verwenden).  Definieren wir stattdessen einen Kontext mit diesen Operationen und wenden Sie ihn lokal an: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NumberOperations</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> DoubleOperations: NumberOperations{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() + other.toDouble() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() - other.toDouble() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() * other.toDouble() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() / other.toDouble() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n1: Number = <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n2: Number = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> res = with(DoubleOperations){ (n1 + n2)/<span class="hljs-number"><span class="hljs-number">2</span></span> } println(res) }</code> </pre><br>  In diesem Beispiel erfolgt die Berechnung von <i>res</i> in einem Kontext, der zusätzliche Operationen definiert.  Ein Kontext muss nicht lokal definiert werden, sondern kann implizit als Empfänger einer Funktion übergeben werden.  Zum Beispiel können Sie dies tun: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> NumberOperations.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n1: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">, n2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = (n1 + n2)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> res = DoubleOperations.calculate(n1, n2)</code> </pre><br>  Dies bedeutet, dass die Logik der Operationen innerhalb des Kontexts vollständig von der Implementierung dieses Kontexts getrennt ist und in einem anderen Teil des Programms oder sogar in einem anderen Modul geschrieben werden kann.  In diesem einfachen Beispiel ist ein Kontext ein zustandsloser Singleton, es können jedoch auch Zustandskontexte verwendet werden. <br><br>  Denken Sie auch daran, dass Kontexte verschachtelt werden können: <br><br><pre> <code class="kotlin hljs">with(a){ with(b){ doSomething() } }</code> </pre><br>  Dies führt dazu, dass das Verhalten beider Klassen kombiniert wird. Diese Funktion ist jedoch heute schwer zu steuern, da keine Erweiterungen mit mehreren Empfängern vorhanden sind ( <a href="https://youtrack.jetbrains.com/issue/KT-10468">KT-10468</a> ). <br><br><h2>  Die Kraft expliziter Koroutinen </h2><br>  Eines der besten Beispiele für einen kontextorientierten Ansatz wird in der Kotlinx-Coroutines-Bibliothek verwendet.  Eine Erklärung der Idee findet sich in einem <a href="https://medium.com/%40elizarov/explicit-concurrency-67a8e8fd9b25">Artikel von</a> Roman Elizarov.  An dieser <i>Stelle</i> möchte ich nur betonen, dass es sich bei <i>CoroutineScope</i> um ein kontextorientiertes Design mit einem statusbehafteten Kontext handelt.  CoroutineScope spielt zwei Rollen: <br><br><ul><li>  Es enthält den <i>CoroutineContext</i> , der zum Ausführen von Coroutine erforderlich ist und beim <i>Starten</i> einer neuen Coroutine geerbt wird. </li><li>  Es enthält den Status der übergeordneten Coroutine, sodass Sie ihn abbrechen können, wenn die generierte Coroutine einen Fehler auslöst. </li></ul><br>  Strukturierte Parallelität ist auch ein gutes Beispiel für eine kontextorientierte Architektur: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> CoroutineScope.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomeWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} GlobalScope.launch{ launch{ delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) doSomeWork() } }</code> </pre><br>  <i>DoSomeWork</i> ist hier eine Kontextfunktion, die jedoch außerhalb ihres Kontexts definiert ist.  Die Startmethoden erstellen zwei verschachtelte Kontexte, die den lexikalischen Bereichen der entsprechenden Funktionen entsprechen (in diesem Fall sind beide Kontexte vom gleichen Typ, sodass der innere Kontext den äußeren Kontext verdeckt).  Ein guter Ausgangspunkt für das Erlernen von Kotlin-Koroutinen ist der offizielle Leitfaden. <br><br><h2>  DSL </h2><br>  Für Kotlin gibt es eine Vielzahl von Aufgaben, die üblicherweise als Aufgaben zum Aufbau von DSL (Domain Specific Language) bezeichnet werden.  In diesem Fall wird DSL als Code verstanden, der einen benutzerfreundlichen Builder mit einer komplexen Struktur bereitstellt.  Tatsächlich ist die Verwendung des Begriffs DSL hier nicht ganz richtig  In solchen Fällen wird die grundlegende Kotlin-Syntax einfach ohne besondere Tricks verwendet. Verwenden wir jedoch diesen allgemeinen Begriff. <br><br>  DSL-Builder sind in den meisten Fällen kontextorientiert.  Wenn Sie beispielsweise ein HTML-Element erstellen möchten, müssen Sie zunächst prüfen, ob dieses bestimmte Element an dieser Stelle hinzugefügt werden kann.  Die Bibliothek <a href="https://github.com/Kotlin/kotlinx.html">kotlinx.html stellt</a> dazu kontextbasierte Klassenerweiterungen <a href="https://github.com/Kotlin/kotlinx.html">bereit</a> , die ein bestimmtes Tag darstellen.  Tatsächlich besteht die gesamte Bibliothek aus Kontexterweiterungen für vorhandene DOM-Elemente. <br><br>  Ein weiteres Beispiel ist der <a href="https://github.com/edvin/tornadofx">TornadoFX GUI Builder</a> .  Der gesamte Builder des Szenendiagramms ist als Folge verschachtelter Context Builder angeordnet, wobei die inneren Blöcke für das Erstellen von Kindern für die äußeren Blöcke oder das Anpassen der Parameter der Eltern verantwortlich sind.  Hier ist ein Beispiel aus der offiziellen Dokumentation: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> root = gridPane{ tabpane { gridpaneConstraints { vhGrow = Priority.ALWAYS } tab(<span class="hljs-string"><span class="hljs-string">"Report"</span></span>, HBox()) { label(<span class="hljs-string"><span class="hljs-string">"Report goes here"</span></span>) } tab(<span class="hljs-string"><span class="hljs-string">"Data"</span></span>, GridPane()) { tableview&lt;Person&gt; { items = persons column(<span class="hljs-string"><span class="hljs-string">"ID"</span></span>, Person::idProperty) column(<span class="hljs-string"><span class="hljs-string">"Name"</span></span>, Person::nameProperty) column(<span class="hljs-string"><span class="hljs-string">"Birthday"</span></span>, Person::birthdayProperty) column(<span class="hljs-string"><span class="hljs-string">"Age"</span></span>, Person::ageProperty).cellFormat { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it &lt; <span class="hljs-number"><span class="hljs-number">18</span></span>) { style = <span class="hljs-string"><span class="hljs-string">"-fx-background-color:#8b0000; -fx-text-fill:white"</span></span> text = it.toString() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { text = it.toString() } } } } } }</code> </pre><br>  In diesem Beispiel definiert der lexikalische Bereich seinen Kontext (was logisch ist, da er den GUI-Abschnitt und seine interne Struktur darstellt) und hat Zugriff auf übergeordnete Kontexte. <br><br><h2>  Was kommt als nächstes? Mehrere Empfänger </h2><br>  Die kontextorientierte Programmierung bietet Kotlin-Entwicklern viele Tools und eröffnet neue Möglichkeiten für die Gestaltung der Anwendungsarchitektur.  Brauchen wir noch etwas  Wahrscheinlich ja <br><br>  Derzeit ist die Entwicklung in einem kontextbezogenen Ansatz durch die Tatsache begrenzt, dass Sie Erweiterungen definieren müssen, um eine Art kontextbezogenes Klassenverhalten zu erzielen.  Das ist in Ordnung, wenn es um eine benutzerdefinierte Klasse geht, aber was ist, wenn wir dasselbe für eine Klasse aus einer Bibliothek wollen?  Oder möchten wir eine Erweiterung für ein Verhalten erstellen, dessen Umfang bereits begrenzt ist (z. B. eine Erweiterung in CoroutineScope hinzufügen)?  Kotlin erlaubt derzeit nicht, dass Nebenstellenfunktionen mehr als einen Empfänger haben.  Es können jedoch mehrere Empfänger zur Sprache hinzugefügt werden, ohne die Abwärtskompatibilität zu beeinträchtigen.  Die Möglichkeit der Verwendung mehrerer Empfänger wird derzeit diskutiert ( <a href="https://youtrack.jetbrains.com/issue/KT-10468">KT-10468</a> ) und als <a href="https://github.com/Kotlin/KEEP">KEEP-</a> Anforderung <a href="https://github.com/Kotlin/KEEP/pull/176">ausgegeben</a> (UPD: <a href="https://github.com/Kotlin/KEEP/pull/176">bereits ausgegeben</a> ).  Das Problem (oder vielleicht ein Chip) verschachtelter Kontexte besteht darin, dass Sie damit die meisten, wenn nicht sogar alle Optionen für die Verwendung von Typklassen ( <a href="https://github.com/Kotlin/KEEP/pull/87">Typklassen</a> ) abdecken können. Dies ist ein weiteres sehr wünschenswertes Merkmal der vorgeschlagenen Funktionen.  Es ist eher unwahrscheinlich, dass beide Funktionen gleichzeitig in der Sprache implementiert werden. <br><br><h2>  Zusatz </h2><br>  Wir möchten uns bei unserem hauptberuflichen Pedant- und Haskell-Liebhaber <a href="https://research.jetbrains.org/researchers/shimuuar">Alexei Khudyakov</a> für seine Kommentare zum Text des Artikels und Änderungen an meiner ziemlich freien Verwendung von Begriffen bedanken.  Ich danke auch Ilya Ryzhenkov für wertvolle Kommentare und das Korrekturlesen der englischen Version des Artikels. <br><br>  Autor des Originalartikels: <a href="https://research.jetbrains.org/researchers/altavir">Alexander Nozik</a> , stellvertretender Leiter des <a href="https://research.jetbrains.org/groups/npm">Labors für kernphysikalische Versuchsmethoden</a> bei <a href="https://research.jetbrains.org/">JetBrains Research</a> . <br><br>  Übersetzt von: <a href="https://research.jetbrains.org/researchers/pklimai">Petr Klimay</a> , Forscher <a href="https://research.jetbrains.org/groups/npm">am Labor für kernphysikalische Versuchsmethoden</a> bei <a href="https://research.jetbrains.org/">JetBrains Research</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477898/">https://habr.com/ru/post/de477898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477878/index.html">Wie wettbewerbsfähige Spiele Ihnen helfen, besser zu arbeiten</a></li>
<li><a href="../de477882/index.html">40 Kanäle und Chats für DevOps-Interessierte</a></li>
<li><a href="../de477886/index.html">Schulcurriculum zur Schaffung von virtueller und erweiterter Realität</a></li>
<li><a href="../de477892/index.html">DevOps: 2019 Ergebnisse und nächste Vorhersage von der DevOps Community</a></li>
<li><a href="../de477894/index.html">work & dev fun (damentals) # 0. Was Sie erwartet und wie Sie einen angehenden Entwickler zu einem selbstbewussten Nachwuchs entwickeln können?</a></li>
<li><a href="../de477900/index.html">Primzahlen - wie groß ist unsere Ohnmacht?</a></li>
<li><a href="../de477902/index.html">Universelles DSL. Ist es möglich?</a></li>
<li><a href="../de477904/index.html">Programmgesteuertes Suchen nach gemeinsamem Code mit oEmbed</a></li>
<li><a href="../de477906/index.html">Slurm: 50% Rabatt auf Black Friday Online-Kurse</a></li>
<li><a href="../de477908/index.html">Puppetry 3: automatisiertes Testen ohne eine einzige Codezeile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>