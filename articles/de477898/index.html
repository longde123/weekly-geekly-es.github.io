<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëá üë©üèº‚Äçüíª ‚úÖ Einf√ºhrung in die kontextorientierte Kotlin-Programmierung üë©üèø‚Äçü§ù‚Äçüë©üèΩ üë®üèª‚Äç‚öïÔ∏è üèà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist eine √úbersetzung von Eine Einf√ºhrung in die kontextorientierte Programmierung in Kotlin 

 In diesem Artikel werde ich versuchen, ein neues P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in die kontextorientierte Kotlin-Programmierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/477898/">  <i>Dies ist eine √úbersetzung von <a href="https://proandroiddev.com/an-introduction-context-oriented-programming-in-kotlin-2e79d316b0a2">Eine Einf√ºhrung in die kontextorientierte Programmierung in Kotlin</a></i> <br><br>  In diesem Artikel werde ich versuchen, ein neues Ph√§nomen zu beschreiben, das als Nebenprodukt der raschen Entwicklung der Kotlin-Sprache entstanden ist.  Dies ist ein neuer Ansatz zum Entwerfen der Architektur von Anwendungen und Bibliotheken, den ich als kontextorientierte Programmierung bezeichnen werde. <br><br><h2>  Ein paar Worte zu Funktionsberechtigungen </h2><br>  Bekanntlich gibt es drei Hauptprogrammierparadigmen ( <i>Anmerkung von Pedant</i> : Es gibt andere Paradigmen): <br><br><ul><li>  Prozedurale Programmierung </li><li>  Objektorientierte Programmierung </li><li>  Funktionale Programmierung </li></ul><a name="habracut"></a><br>  Alle diese Ans√§tze arbeiten auf die eine oder andere Weise mit Funktionen.  Betrachten wir dies unter dem Gesichtspunkt der Aufl√∂sung von Funktionen oder der Planung ihrer Aufrufe (dh der Auswahl der Funktion, die an dieser Stelle verwendet werden soll).  Die prozedurale Programmierung ist durch die Verwendung globaler Funktionen und deren statische Aufl√∂sung auf der Grundlage des Funktionsnamens und der Argumenttypen gekennzeichnet.  Nat√ºrlich k√∂nnen Typen nur bei statisch typisierten Sprachen verwendet werden.  In Python werden Funktionen beispielsweise nach Namen aufgerufen, und wenn die Argumente falsch sind, wird zur Laufzeit w√§hrend der Programmausf√ºhrung eine Ausnahme ausgel√∂st.  Die Aufl√∂sung von Funktionen in Sprachen mit prozeduralem Ansatz basiert nur auf dem Namen der Prozedur / Funktion und ihren Parametern und erfolgt in den meisten F√§llen statisch. <br><br>  Ein objektorientierter Programmierstil begrenzt den Funktionsumfang.  Funktionen sind nicht global, sondern Teil von Klassen und k√∂nnen nur f√ºr eine Instanz der entsprechenden Klasse aufgerufen werden ( <i>Anmerkung von Pedant</i> : Einige klassische prozedurale Sprachen haben ein modulares System und daher einen Geltungsbereich; prozedurale Sprache! = C). <br><br>  Nat√ºrlich k√∂nnen wir eine Mitgliedsfunktion einer Klasse immer durch eine globale Funktion durch ein zus√§tzliches Argument des Typs des aufgerufenen Objekts ersetzen, aber aus syntaktischer Sicht ist der Unterschied ziemlich bedeutend.  In diesem Fall sind die Methoden beispielsweise in der Klasse gruppiert, auf die sie sich beziehen, und daher ist klarer ersichtlich, welche Art von Verhalten die Objekte dieses Typs liefern. <br><br>  Am wichtigsten ist hier nat√ºrlich die Kapselung, aufgrund derer einige Felder einer Klasse oder ihr Verhalten privat und nur f√ºr Mitglieder dieser Klasse zug√§nglich sein k√∂nnen (Sie k√∂nnen dies nicht in einem rein prozeduralen Ansatz angeben), und der Polymorphismus, dank dessen die tats√§chlich verwendete Methode nicht nur anhand des Namens bestimmt wird Methode, sondern auch basierend auf dem Typ des Objekts, von dem es aufgerufen wird.  Das Ausl√∂sen eines Methodenaufrufs in einem objektorientierten Ansatz h√§ngt vom Typ des zur Laufzeit definierten Objekts, dem Namen der Methode und dem Typ der Argumente in der Kompilierungsphase ab. <br><br>  Ein funktionaler Ansatz bringt in Bezug auf die Funktionsaufl√∂sung nichts grundlegend Neues.  In funktionsorientierten Sprachen gelten in der Regel bessere Regeln f√ºr die Unterscheidung zwischen Sichtbarkeitsbereichen ( <i>Pedant-Hinweis</i> : Wiederum sind nicht alle prozeduralen Sprachen in C enthalten, es gibt auch solche, in denen Sichtbarkeitsbereiche gut abgegrenzt sind), mit denen die Sichtbarkeit von Funktionen auf der Grundlage des Systems genauer gesteuert werden kann Module, aber ansonsten erfolgt die Aufl√∂sung zur Kompilierungszeit basierend auf der Art der Argumente. <br><br><h2>  Was ist das </h2><br>  Beim Objektansatz haben wir beim Aufrufen einer Methode f√ºr ein Objekt die Argumente, aber zus√§tzlich haben wir einen expliziten (im Fall von Python) oder einen impliziten Parameter, der eine Instanz der aufgerufenen Klasse darstellt (im Folgenden werden alle Beispiele in Kotlin geschrieben): <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ println(<span class="hljs-string"><span class="hljs-string">"    </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre> <br>  Verschachtelte Klassen und Closures erschweren die Sache ein wenig: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doBSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doASomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: B{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doBSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ println(<span class="hljs-string"><span class="hljs-string">"    </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${this@A}</span></span></span><span class="hljs-string">"</span></span>) } } b.doBSomething() } }</code> </pre> <br>  In diesem Fall gibt es zwei implizite <i>Bedingungen</i> f√ºr die Funktion <i>doBSomething</i> : Die eine entspricht einer Instanz der Klasse <i>B</i> und die andere ergibt sich aus dem Abschluss von Instanz <i>A.</i>  Das Gleiche passiert im weitaus h√§ufigeren Fall des Lambda-Verschlusses.  Es ist wichtig zu beachten, dass dies in diesem Fall nicht nur als impliziter Parameter funktioniert, sondern auch als Bereich oder Kontext f√ºr alle Funktionen und Objekte, die im lexikalischen Bereich aufgerufen werden.  Die Methode doBSomething hat also Zugriff auf alle Mitglieder der Klasse <i>A</i> (√∂ffentlich oder privat) sowie auf die Mitglieder von <i>B</i> selbst. <br><br><h2>  Und hier ist Kotlin </h2><br>  Kotlin gibt uns ein v√∂llig neues "Spielzeug" - <a href="https://kotlinlang.org/docs/reference/extensions.html">Erweiterungsfunktionen</a> .  ( <i>Anmerkung von Pedant</i> : Eigentlich sind sie nicht so neu, sie existieren auch in C #.)  Sie k√∂nnen eine Funktion wie <i>A.doASomething</i> () an einer beliebigen Stelle im Programm definieren, nicht nur in <i>A.</i>  In dieser Funktion gibt es einen impliziten Parameter namens receiver, der auf Instanz <i>A</i> verweist, auf der die Methode aufgerufen wird: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">doASomthing</span></span></span></span>(){ println(<span class="hljs-string"><span class="hljs-string">" -   </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$this</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = A() a.doASomthing() }</code> </pre> <br>  Erweiterungsfunktionen haben keinen Zugriff auf die privaten Mitglieder ihres Empf√§ngers, sodass die Kapselung nicht verletzt wird. <br><br>  Das n√§chste wichtige Ding, das Kotlin hat, sind Codebl√∂cke mit Empf√§ngern.  Sie k√∂nnen einen beliebigen Codeblock ausf√ºhren, indem Sie etwas als Empf√§nger verwenden: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doInternalSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> A.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doASomthing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = A() with(a){ doInternalSomething() doASomthing() } }</code> </pre> <br>  In diesem Beispiel k√∂nnten beide Funktionen ohne ein zus√§tzliches ‚Äû <i>a</i> ‚Äú aufgerufen werden, da die with-Funktion den gesamten Code des nachfolgenden Blocks in den Kontext von a einf√ºgt.  Dies bedeutet, dass alle Funktionen in diesem Block so aufgerufen werden, als w√§ren sie auf dem (explizit √ºbergebenen) Objekt <i>a</i> aufgerufen worden. <br><br>  Der letzte Schritt an dieser Stelle in der kontextorientierten Programmierung ist die M√∂glichkeit, Erweiterungen als Mitglieder einer Klasse zu deklarieren.  In diesem Fall wird die Erweiterungsfunktion in einer anderen Klasse wie folgt definiert: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> B.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doBSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = A() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = B() with(a){ b.doBSomething() <span class="hljs-comment"><span class="hljs-comment">//   } b.doBSomething() //   }</span></span></code> </pre> <br>  Es ist wichtig, dass <i>B</i> hier ein neues Verhalten bekommt, aber nur, wenn es sich in einem bestimmten lexikalischen Kontext befindet.  Eine Erweiterungsfunktion ist ein regul√§res Mitglied der Klasse <i>A.</i>  Dies bedeutet, dass die Aufl√∂sung der Funktion statisch basierend auf dem Kontext erfolgt, in dem sie aufgerufen wird. Die tats√§chliche Implementierung wird jedoch durch die Instanz von <i>A bestimmt</i> , die als Kontext √ºbergeben wird.  Die Funktion kann sogar mit dem Zustand des Objekts <i>a</i> interagieren. <br><br><h2>  Kontextorientierter Versand </h2><br>  Zu Beginn des Artikels haben wir verschiedene Ans√§tze zum Verteilen von Funktionsaufrufen er√∂rtert, und zwar aus einem bestimmten Grund.  Tatsache ist, dass Sie mit den Erweiterungsfunktionen in Kotlin auf eine neue Art und Weise mit dem Disponieren arbeiten k√∂nnen.  Die Entscheidung, welche bestimmte Funktion verwendet werden soll, basiert nun nicht nur auf der Art ihrer Parameter, sondern auch auf dem lexikalischen Kontext ihres Aufrufs.  Das hei√üt, der gleiche Ausdruck in unterschiedlichen Kontexten kann unterschiedliche Bedeutungen haben.  Aus Sicht der Implementierung √§ndert sich nat√ºrlich nichts, und wir haben immer noch ein explizites Empf√§ngerobjekt, das das Dispatching f√ºr seine Methoden und Erweiterungen definiert, die im Hauptteil der Klasse selbst beschrieben sind (Member-Erweiterungen). Aus syntaktischer Sicht ist dies jedoch ein anderer Ansatz . <br><br>  Schauen wir uns an, wie sich der kontextorientierte Ansatz vom klassischen objektorientierten Ansatz unterscheidet, und nehmen wir als Beispiel das klassische Problem der arithmetischen Operationen mit Zahlen in Java.  Die <i>Zahlenklasse</i> in Java und Kotlin ist das √ºbergeordnete Element f√ºr alle Zahlen, aber im Gegensatz zu spezialisierten Zahlen wie Double werden die mathematischen Operationen nicht definiert.  So k√∂nnen Sie beispielsweise nicht schreiben: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n: Number = <span class="hljs-number"><span class="hljs-number">1.0</span></span> n + <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-comment"><span class="hljs-comment">//  `plus`     `Number`</span></span></code> </pre><br>  Der Grund hierf√ºr ist, dass es nicht m√∂glich ist, arithmetische Operationen f√ºr alle numerischen Typen konsistent zu definieren.  Beispielsweise unterscheidet sich die Ganzzahldivision von der Gleitkommadivision.  In einigen besonderen F√§llen wei√ü der Benutzer, welche Art von Operation erforderlich ist, aber normalerweise macht es keinen Sinn, solche Dinge global zu definieren.  Eine objektorientierte (und tats√§chlich funktionale) L√∂sung besteht darin, einen neuen Vererbungstyp der <i>Number-</i> Klasse zu definieren, die erforderlichen Operationen darin auszuf√ºhren und diese bei Bedarf zu verwenden (in Kotlin 1.3 k√∂nnen Sie Inline-Klassen verwenden).  Definieren wir stattdessen einen Kontext mit diesen Operationen und wenden Sie ihn lokal an: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NumberOperations</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : Number } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> DoubleOperations: NumberOperations{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() + other.toDouble() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() - other.toDouble() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() * other.toDouble() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Number.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toDouble() / other.toDouble() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n1: Number = <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n2: Number = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> res = with(DoubleOperations){ (n1 + n2)/<span class="hljs-number"><span class="hljs-number">2</span></span> } println(res) }</code> </pre><br>  In diesem Beispiel erfolgt die Berechnung von <i>res</i> in einem Kontext, der zus√§tzliche Operationen definiert.  Ein Kontext muss nicht lokal definiert werden, sondern kann implizit als Empf√§nger einer Funktion √ºbergeben werden.  Zum Beispiel k√∂nnen Sie dies tun: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> NumberOperations.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n1: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">, n2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = (n1 + n2)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> res = DoubleOperations.calculate(n1, n2)</code> </pre><br>  Dies bedeutet, dass die Logik der Operationen innerhalb des Kontexts vollst√§ndig von der Implementierung dieses Kontexts getrennt ist und in einem anderen Teil des Programms oder sogar in einem anderen Modul geschrieben werden kann.  In diesem einfachen Beispiel ist ein Kontext ein zustandsloser Singleton, es k√∂nnen jedoch auch Zustandskontexte verwendet werden. <br><br>  Denken Sie auch daran, dass Kontexte verschachtelt werden k√∂nnen: <br><br><pre> <code class="kotlin hljs">with(a){ with(b){ doSomething() } }</code> </pre><br>  Dies f√ºhrt dazu, dass das Verhalten beider Klassen kombiniert wird. Diese Funktion ist jedoch heute schwer zu steuern, da keine Erweiterungen mit mehreren Empf√§ngern vorhanden sind ( <a href="https://youtrack.jetbrains.com/issue/KT-10468">KT-10468</a> ). <br><br><h2>  Die Kraft expliziter Koroutinen </h2><br>  Eines der besten Beispiele f√ºr einen kontextorientierten Ansatz wird in der Kotlinx-Coroutines-Bibliothek verwendet.  Eine Erkl√§rung der Idee findet sich in einem <a href="https://medium.com/%40elizarov/explicit-concurrency-67a8e8fd9b25">Artikel von</a> Roman Elizarov.  An dieser <i>Stelle</i> m√∂chte ich nur betonen, dass es sich bei <i>CoroutineScope</i> um ein kontextorientiertes Design mit einem statusbehafteten Kontext handelt.  CoroutineScope spielt zwei Rollen: <br><br><ul><li>  Es enth√§lt den <i>CoroutineContext</i> , der zum Ausf√ºhren von Coroutine erforderlich ist und beim <i>Starten</i> einer neuen Coroutine geerbt wird. </li><li>  Es enth√§lt den Status der √ºbergeordneten Coroutine, sodass Sie ihn abbrechen k√∂nnen, wenn die generierte Coroutine einen Fehler ausl√∂st. </li></ul><br>  Strukturierte Parallelit√§t ist auch ein gutes Beispiel f√ºr eine kontextorientierte Architektur: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> CoroutineScope.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomeWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{} GlobalScope.launch{ launch{ delay(<span class="hljs-number"><span class="hljs-number">100</span></span>) doSomeWork() } }</code> </pre><br>  <i>DoSomeWork</i> ist hier eine Kontextfunktion, die jedoch au√üerhalb ihres Kontexts definiert ist.  Die Startmethoden erstellen zwei verschachtelte Kontexte, die den lexikalischen Bereichen der entsprechenden Funktionen entsprechen (in diesem Fall sind beide Kontexte vom gleichen Typ, sodass der innere Kontext den √§u√üeren Kontext verdeckt).  Ein guter Ausgangspunkt f√ºr das Erlernen von Kotlin-Koroutinen ist der offizielle Leitfaden. <br><br><h2>  DSL </h2><br>  F√ºr Kotlin gibt es eine Vielzahl von Aufgaben, die √ºblicherweise als Aufgaben zum Aufbau von DSL (Domain Specific Language) bezeichnet werden.  In diesem Fall wird DSL als Code verstanden, der einen benutzerfreundlichen Builder mit einer komplexen Struktur bereitstellt.  Tats√§chlich ist die Verwendung des Begriffs DSL hier nicht ganz richtig  In solchen F√§llen wird die grundlegende Kotlin-Syntax einfach ohne besondere Tricks verwendet. Verwenden wir jedoch diesen allgemeinen Begriff. <br><br>  DSL-Builder sind in den meisten F√§llen kontextorientiert.  Wenn Sie beispielsweise ein HTML-Element erstellen m√∂chten, m√ºssen Sie zun√§chst pr√ºfen, ob dieses bestimmte Element an dieser Stelle hinzugef√ºgt werden kann.  Die Bibliothek <a href="https://github.com/Kotlin/kotlinx.html">kotlinx.html stellt</a> dazu kontextbasierte Klassenerweiterungen <a href="https://github.com/Kotlin/kotlinx.html">bereit</a> , die ein bestimmtes Tag darstellen.  Tats√§chlich besteht die gesamte Bibliothek aus Kontexterweiterungen f√ºr vorhandene DOM-Elemente. <br><br>  Ein weiteres Beispiel ist der <a href="https://github.com/edvin/tornadofx">TornadoFX GUI Builder</a> .  Der gesamte Builder des Szenendiagramms ist als Folge verschachtelter Context Builder angeordnet, wobei die inneren Bl√∂cke f√ºr das Erstellen von Kindern f√ºr die √§u√üeren Bl√∂cke oder das Anpassen der Parameter der Eltern verantwortlich sind.  Hier ist ein Beispiel aus der offiziellen Dokumentation: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> root = gridPane{ tabpane { gridpaneConstraints { vhGrow = Priority.ALWAYS } tab(<span class="hljs-string"><span class="hljs-string">"Report"</span></span>, HBox()) { label(<span class="hljs-string"><span class="hljs-string">"Report goes here"</span></span>) } tab(<span class="hljs-string"><span class="hljs-string">"Data"</span></span>, GridPane()) { tableview&lt;Person&gt; { items = persons column(<span class="hljs-string"><span class="hljs-string">"ID"</span></span>, Person::idProperty) column(<span class="hljs-string"><span class="hljs-string">"Name"</span></span>, Person::nameProperty) column(<span class="hljs-string"><span class="hljs-string">"Birthday"</span></span>, Person::birthdayProperty) column(<span class="hljs-string"><span class="hljs-string">"Age"</span></span>, Person::ageProperty).cellFormat { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it &lt; <span class="hljs-number"><span class="hljs-number">18</span></span>) { style = <span class="hljs-string"><span class="hljs-string">"-fx-background-color:#8b0000; -fx-text-fill:white"</span></span> text = it.toString() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { text = it.toString() } } } } } }</code> </pre><br>  In diesem Beispiel definiert der lexikalische Bereich seinen Kontext (was logisch ist, da er den GUI-Abschnitt und seine interne Struktur darstellt) und hat Zugriff auf √ºbergeordnete Kontexte. <br><br><h2>  Was kommt als n√§chstes? Mehrere Empf√§nger </h2><br>  Die kontextorientierte Programmierung bietet Kotlin-Entwicklern viele Tools und er√∂ffnet neue M√∂glichkeiten f√ºr die Gestaltung der Anwendungsarchitektur.  Brauchen wir noch etwas  Wahrscheinlich ja <br><br>  Derzeit ist die Entwicklung in einem kontextbezogenen Ansatz durch die Tatsache begrenzt, dass Sie Erweiterungen definieren m√ºssen, um eine Art kontextbezogenes Klassenverhalten zu erzielen.  Das ist in Ordnung, wenn es um eine benutzerdefinierte Klasse geht, aber was ist, wenn wir dasselbe f√ºr eine Klasse aus einer Bibliothek wollen?  Oder m√∂chten wir eine Erweiterung f√ºr ein Verhalten erstellen, dessen Umfang bereits begrenzt ist (z. B. eine Erweiterung in CoroutineScope hinzuf√ºgen)?  Kotlin erlaubt derzeit nicht, dass Nebenstellenfunktionen mehr als einen Empf√§nger haben.  Es k√∂nnen jedoch mehrere Empf√§nger zur Sprache hinzugef√ºgt werden, ohne die Abw√§rtskompatibilit√§t zu beeintr√§chtigen.  Die M√∂glichkeit der Verwendung mehrerer Empf√§nger wird derzeit diskutiert ( <a href="https://youtrack.jetbrains.com/issue/KT-10468">KT-10468</a> ) und als <a href="https://github.com/Kotlin/KEEP">KEEP-</a> Anforderung <a href="https://github.com/Kotlin/KEEP/pull/176">ausgegeben</a> (UPD: <a href="https://github.com/Kotlin/KEEP/pull/176">bereits ausgegeben</a> ).  Das Problem (oder vielleicht ein Chip) verschachtelter Kontexte besteht darin, dass Sie damit die meisten, wenn nicht sogar alle Optionen f√ºr die Verwendung von Typklassen ( <a href="https://github.com/Kotlin/KEEP/pull/87">Typklassen</a> ) abdecken k√∂nnen. Dies ist ein weiteres sehr w√ºnschenswertes Merkmal der vorgeschlagenen Funktionen.  Es ist eher unwahrscheinlich, dass beide Funktionen gleichzeitig in der Sprache implementiert werden. <br><br><h2>  Zusatz </h2><br>  Wir m√∂chten uns bei unserem hauptberuflichen Pedant- und Haskell-Liebhaber <a href="https://research.jetbrains.org/researchers/shimuuar">Alexei Khudyakov</a> f√ºr seine Kommentare zum Text des Artikels und √Ñnderungen an meiner ziemlich freien Verwendung von Begriffen bedanken.  Ich danke auch Ilya Ryzhenkov f√ºr wertvolle Kommentare und das Korrekturlesen der englischen Version des Artikels. <br><br>  Autor des Originalartikels: <a href="https://research.jetbrains.org/researchers/altavir">Alexander Nozik</a> , stellvertretender Leiter des <a href="https://research.jetbrains.org/groups/npm">Labors f√ºr kernphysikalische Versuchsmethoden</a> bei <a href="https://research.jetbrains.org/">JetBrains Research</a> . <br><br>  √úbersetzt von: <a href="https://research.jetbrains.org/researchers/pklimai">Petr Klimay</a> , Forscher <a href="https://research.jetbrains.org/groups/npm">am Labor f√ºr kernphysikalische Versuchsmethoden</a> bei <a href="https://research.jetbrains.org/">JetBrains Research</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477898/">https://habr.com/ru/post/de477898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477878/index.html">Wie wettbewerbsf√§hige Spiele Ihnen helfen, besser zu arbeiten</a></li>
<li><a href="../de477882/index.html">40 Kan√§le und Chats f√ºr DevOps-Interessierte</a></li>
<li><a href="../de477886/index.html">Schulcurriculum zur Schaffung von virtueller und erweiterter Realit√§t</a></li>
<li><a href="../de477892/index.html">DevOps: 2019 Ergebnisse und n√§chste Vorhersage von der DevOps Community</a></li>
<li><a href="../de477894/index.html">work & dev fun (damentals) # 0. Was Sie erwartet und wie Sie einen angehenden Entwickler zu einem selbstbewussten Nachwuchs entwickeln k√∂nnen?</a></li>
<li><a href="../de477900/index.html">Primzahlen - wie gro√ü ist unsere Ohnmacht?</a></li>
<li><a href="../de477902/index.html">Universelles DSL. Ist es m√∂glich?</a></li>
<li><a href="../de477904/index.html">Programmgesteuertes Suchen nach gemeinsamem Code mit oEmbed</a></li>
<li><a href="../de477906/index.html">Slurm: 50% Rabatt auf Black Friday Online-Kurse</a></li>
<li><a href="../de477908/index.html">Puppetry 3: automatisiertes Testen ohne eine einzige Codezeile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>