<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🌾 ⚪️ 👩‍👩‍👦 Desbloquear automaticamente o contêiner LUKS raiz após uma inicialização a quente 🤳🏿 🗜️ 🌒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por que as pessoas geralmente criptografam unidades de seus computadores pessoais e, às vezes, servidores? É claro que ninguém roubou fotos de seus ga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desbloquear automaticamente o contêiner LUKS raiz após uma inicialização a quente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457396/"><p>  Por que as pessoas geralmente criptografam unidades de seus computadores pessoais e, às vezes, servidores?  É claro que ninguém roubou fotos de seus gatos de estimação favoritos do disco!  Isso é apenas azar: uma unidade criptografada exige que você insira uma frase-chave do teclado a cada inicialização e é longa e chata.  Removê-lo para que, pelo menos às vezes, não seja necessário recrutá-lo.  Sim, para que o significado da criptografia não seja perdido. </p><br><div class="spoiler">  <b class="spoiler_title">Gato pela atenção</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sr/rt/ny/srrtnywyggbrscsufm8ux8tvxmu.jpeg" alt="Cat"></p></div></div><br><p>  Bem, removê-lo completamente não vai funcionar.  Você pode criar um arquivo de chave em uma unidade flash USB, e ele também funcionará.  E sem uma unidade flash (e sem um segundo computador na rede) é possível?  Se você tiver sorte com o BIOS, pode quase!  Abaixo do corte, haverá um guia sobre como configurar a criptografia de disco através do LUKS com as seguintes propriedades: </p><br><ol><li>  A senha ou o arquivo de chave não é armazenado em nenhum lugar no formato aberto (ou no formato equivalente a aberto) quando o computador é desligado. </li><li> Na primeira vez que você liga o computador, você deve inserir uma senha. </li><li>  Nas reinicializações subsequentes (antes de desligar), uma senha não é necessária. </li></ol><br><p>  As instruções foram testadas no CentOS 7.6, Ubuntu 19.04 e openSUSE Leap 15.1 em máquinas virtuais e em hardware real (desktop, laptop e dois servidores).  Eles devem trabalhar em outras distribuições que tenham uma versão funcional do Dracut. </p><br><p>  E sim, no bom sentido, isso deveria ter acabado no hub "administração anormal do sistema", mas não existe esse hub. </p><a name="habracut"></a><br><p>  Sugiro usar um slot separado no contêiner LUKS e armazenar a chave para ele ... na RAM! </p><br><div class="spoiler">  <b class="spoiler_title">Que tipo de slot?</b> <div class="spoiler_text"><p> O contêiner LUKS implementa criptografia em vários níveis.  Os dados úteis no disco são criptografados com uma cifra simétrica, geralmente <code>aes-xts-plain64</code> .  A chave para essa cifra simétrica (chave mestra) é gerada no estágio de criação do contêiner como uma sequência aleatória de bytes.  A chave mestra é armazenada em forma criptografada, no caso geral - em várias cópias (slots).  Por padrão, apenas um dos oito slots está ativo.  Cada slot ativo possui uma frase-chave separada (ou um arquivo-chave separado), com o qual você pode descriptografar a chave mestra.  Do ponto de vista do usuário, você pode desbloquear a unidade usando qualquer uma das várias frases-chave diferentes (ou arquivos-chave).  No nosso caso, usando uma frase-chave (slot 0) ou um pedaço de memória usado como arquivo-chave (slot 6). </p></div></div><br><p>  O BIOS na maioria das placas-mãe não limpa a memória durante a reinicialização ou você pode configurá-lo para não limpar (exceção conhecida: "Intel Corporation S1200SP / S1200SP, BIOS S1200SP.86B.03.01.0042.013020190050 em 30/01/2019").  Portanto, você pode armazenar a chave lá.  Quando a energia é desligada, o conteúdo da própria RAM é apagado após um tempo, junto com uma cópia desprotegida da chave. </p><br><p>  Então vamos lá. </p><br><h3 id="shag-pervyy-ustanovit-sistemu-na-zashifrovannyy-s-pomoschyu-luks-disk">  Etapa 1: instalar o sistema em um disco criptografado usando LUKS </h3><br><p>  Nesse caso, a partição do disco (por exemplo, <code>/dev/sda1</code> ) montada em <code>/boot</code> deve permanecer não criptografada e a outra partição na qual todo o resto (por exemplo, <code>/dev/sda2</code> ) deve ser criptografado.  O sistema de arquivos na partição criptografada pode ser qualquer um, você também pode usar o LVM para que o sistema de arquivos raiz, o volume para troca e tudo o mais, exceto <code>/boot</code> no mesmo contêiner.  Isso corresponde ao particionamento de disco padrão no CentOS 7 e Debian ao escolher a opção de criptografia.  O SUSE faz tudo de maneira diferente (criptografa <code>/boot</code> ) e, portanto, requer particionamento manual do disco. </p><br><p>  O resultado deve ser algo como o seguinte: </p><br><pre> <code class="plaintext hljs">$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 10G 0 disk ├─sda1 8:1 0 1G 0 part /boot └─sda2 8:2 0 9G 0 part └─luks-d07a97d7-3258-408c-a17c-e2fb56701c69 253:0 0 9G 0 crypt ├─centos_centos--encrypt2-root 253:1 0 8G 0 lvm / └─centos_centos--encrypt2-swap 253:2 0 1G 0 lvm [SWAP]</code> </pre> <br><p>  No caso de usar UEFI, também haverá uma partição de sistema EFI. </p><br><blockquote>  Para usuários Debian e Ubuntu: substitua o pacote <code>initramfs-tools</code> pelo <code>dracut</code> . <br><pre> <code class="plaintext hljs"># apt install --no-install-recommends dracut</code> </pre> <br><br>  <code>initramfs-tools</code> implementa lógica incorreta no nosso caso, aplicada a seções criptografadas com um arquivo de chave.  Essas seções são ignoradas completamente ou o conteúdo do arquivo-chave é copiado para o initramfs (ou seja, como resultado, para o disco), o que não é necessário. </blockquote><br><h3 id="shag-vtoroy-sozdat-klyuchevoy-fayl-kotoryy-budet-ispolzovatsya-dlya-avtomaticheskogo-razblokirovaniya-diska-posle-goryachey-perezagruzki">  Etapa 2: criar um arquivo de chave que será usado para desbloquear automaticamente a unidade após uma reinicialização a quente </h3><br><p>  128 bits aleatórios são suficientes para nós, ou seja,  16 bytes.  O arquivo será armazenado em um disco criptografado; portanto, quem não conhece a chave de criptografia e não possui acesso root ao sistema carregado não a lê. </p><br><pre> <code class="plaintext hljs"># touch -m 0600 /root/key # head -c16 /dev/urandom &gt; /root/key</code> </pre> <br><p>  Existem bits verdadeiramente aleatórios suficientes no arquivo de chaves, para que o algoritmo PBKDF lento, que torna uma chave de criptografia difícil de escolher a partir de uma frase-chave potencialmente fraca, não seja realmente necessário.  Portanto, ao adicionar uma chave, você pode reduzir o número de iterações: </p><br><pre> <code class="plaintext hljs"># cryptsetup luksAddKey --key-slot=6 --iter-time=1 /dev/sda2 /root/key Enter any existing passphrase:</code> </pre> <br><p>  Como você pode ver, o arquivo de chave é armazenado em um disco criptografado e, portanto, não representa risco à segurança se o computador estiver desligado. </p><br><h3 id="shag-tretiy-vydelit-mesto-v-fizicheskoy-pamyati-dlya-hraneniya-klyucha">  Etapa três: alocar espaço na memória física para armazenar a chave </h3><br><p>  O Linux possui pelo menos três drivers diferentes que permitem acessar a memória física em um endereço conhecido.  Esse é o <code>linux/drivers/char/mem.c</code> , que também é responsável pelo dispositivo <code>/dev/mem</code> , além <code>phram</code> módulos <code>phram</code> (emula um chip MTD, fornece o dispositivo <code>/dev/mtd0</code> ) e o <code>nd_e820</code> (usado ao trabalhar com o NVDIMM, fornece <code>/dev/pmem0</code> ).  Todos eles têm características desagradáveis: </p><br><ul><li>  <code>/dev/mem</code> não <code>/dev/mem</code> ser gravado ao usar o Secure Boot se a distribuição <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usa o conjunto de patches LOCKDOWN</a> de Matthew Garrett (e esse conjunto de patches é necessário se a distribuição oferecer suporte ao Secure Boot com um gerenciador de inicialização assinado pela Microsoft); </li><li>  <code>phram</code> não <code>phram</code> disponível no CentOS e no Fedora - o mantenedor simplesmente não <code>phram</code> a opção correspondente ao criar o kernel; </li><li>  <code>nd_e820</code> precisa reservar pelo menos 128 megabytes de memória - é assim que o NVDIMM funciona.  Mas esta é a única opção em execução no CentOS com inicialização segura. </li></ul><br><p>  Como não há opção ideal, todos os três são considerados abaixo. </p><br><blockquote>  Ao usar qualquer um dos métodos, é necessário extremo cuidado para não afetar acidentalmente dispositivos ou intervalos de memória diferentes do necessário.  Isto é especialmente verdade para computadores que já possuem chips MTD ou módulos NVDIMM.  Ou seja, <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> pode não ser o dispositivo que corresponde à área de memória reservada para armazenar a chave.  A numeração dos dispositivos existentes, nos quais os arquivos e scripts de configuração dependem, também pode ser confusa.  Portanto, é recomendável desabilitar temporariamente todos os serviços que dependem de dispositivos existentes <code>/dev/mtd*</code> e <code>/dev/pmem*</code> . </blockquote><p>  É <code>memmap</code> memória física do Linux, passando a opção <code>memmap</code> para o <code>memmap</code> .  Estamos interessados ​​em dois tipos dessa opção: </p><br><ul><li>  <code>memmap=4K$0x10000000</code> reservas (ou seja, marcas reservadas para que o próprio kernel não use) 4 kilobytes de memória, começando com o endereço físico 0x10000000; </li><li>  <code>memmap=128M!0x10000000</code> marca 128 megabytes de memória física, começando com o endereço 0x10000000, como NVDIMM (obviamente falso, mas servirá para nós). </li></ul><br><p>  A opção c <code>$</code> é adequada para uso com <code>/dev/mem</code> e <code>phram</code> , a opção c <code>!</code>  - para <code>nd_e820</code> .  Ao usar <code>$</code> endereço inicial da memória reservada deve ser um múltiplo de <code>0x1000</code> (ou seja, 4 kilobytes), ao usar <code>!</code>  - um múltiplo de <code>0x8000000</code> (ou seja, 128 megabytes). </p><br><p>  Importante: o cifrão ( <code>$</code> ) nos arquivos de configuração do GRUB é um caractere especial e deve ser escapado.  E duas vezes: uma vez - ao gerar o <code>grub.cfg</code> partir de <code>/etc/default/grub</code> , uma segunda vez - ao interpretar o arquivo de configuração resultante no estágio de inicialização.  I.e.  em <code>/etc/default/grub</code> , a seguinte linha deve aparecer eventualmente: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 ...  ..."</code> </pre> <br><p>  Sem escapar duas vezes do sinal <code>$</code> , o sistema simplesmente não inicializa, pois pensa que possui apenas 4 kilobytes de memória.  Não há tais dificuldades com um ponto de exclamação: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=128M!0x10000000 ...  ..."</code> </pre> <br><p>  O cartão de memória físico (e é necessário descobrir quais endereços reservar) é acessível ao <code>root</code> no pseudo- <code>/proc/iomem</code> : </p><br><pre> <code class="plaintext hljs"># cat /proc/iomem ... 000f0000-000fffff : reserved 000f0000-000fffff : System ROM 00100000-7ffddfff : System RAM 2b000000-350fffff : Crash kernel 73a00000-7417c25e : Kernel code 7417c25f-747661ff : Kernel data 74945000-74c50fff : Kernel bss 7ffde000-7fffffff : reserved 80000000-febfffff : PCI Bus 0000:00 fd000000-fdffffff : 0000:00:02.0 ...</code> </pre> <br><p>  A RAM está marcada como "RAM do sistema", basta reservar uma de suas páginas para armazenar a chave.  Adivinhar qual parte da memória do BIOS não toca na reinicialização não funcionará com confiabilidade antecipadamente.  A menos que haja outro computador com exatamente a mesma versão do BIOS e a mesma configuração de memória no qual este manual já foi concluído.  Portanto, no caso geral, você terá que agir por tentativa e erro.  Como regra, quando o BIOS é reinicializado, ele altera os dados somente no início e no final de cada intervalo de memória.  Geralmente, é suficiente retirar 128 megabytes ( <code>0x8000000</code> ) das bordas.  Para máquinas virtuais KVM com 1 GB de memória ou mais, as opções propostas ( <code>memmap=4K$0x10000000</code> e <code>memmap=128M!0x10000000</code> ) funcionam. </p><br><p>  Ao usar o módulo <code>phram</code> , precisamos de outro parâmetro de linha de comando do kernel, que, de fato, diz ao módulo qual parte da memória física usar - a nossa, reservada.  O parâmetro é chamado <code>phram.phram</code> e contém três partes: o nome (arbitrário até 63 caracteres, será visível em <code>sysfs</code> ), o endereço inicial e o comprimento.  O endereço inicial e o comprimento devem ser os mesmos do <code>memmap</code> , mas os sufixos <code>K</code> e <code>M</code> não <code>M</code> suportados. </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 phram.phram=savedkey,0x10000000,4096 ..."</code> </pre> <br><p>  Após editar o arquivo <code>/etc/default/grub</code> você precisará gerar novamente o arquivo de configuração real que o GRUB lê na inicialização.  O comando correto para isso depende da distribuição. </p><br><pre> <code class="plaintext hljs"># grub2-mkconfig -o /boot/grub2/grub.cfg # CentOS (Legacy BIOS) # grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg # CentOS (UEFI) # update-grub # Debian, Ubuntu # update-bootloader --reinit # SUSE</code> </pre> <br><p>  Após atualizar a configuração do GRUB, o computador deve ser reiniciado, mas faremos isso mais tarde quando atualizarmos o initramfs. </p><br><h3 id="shag-chetvertyy-nastroit-luks-na-chtenie-klyucha-iz-pamyati">  Quarto passo: configure o LUKS para ler a chave da memória </h3><br><p>  <code>/etc/crypttab</code> configurações de criptografia da <code>/etc/crypttab</code> são armazenadas no <code>/etc/crypttab</code> .  Cada linha consiste em quatro campos: </p><br><ul><li>  o dispositivo que deve ser obtido ao desbloquear, </li><li>  dispositivo criptografado </li><li>  onde obter o arquivo de teclas ( <code>none</code> significa digitar uma frase-chave no teclado), </li><li>  campo opcional para opções. </li></ul><br><p>  Se o arquivo-chave existe, mas não se encaixa, o Dracut solicita a frase-chave.  O que, de fato, será necessário na primeira inicialização. </p><br><p>  Um exemplo do <code>/etc/crypttab</code> de uma distribuição recém-instalada: </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   luks-d07....69 UUID=d07....69 none</code> </pre> <br><p>  O arquivo-chave no nosso caso será um pedaço de memória física.  I.e.  <code>/dev/mem</code> , <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> , dependendo da tecnologia de acesso à memória selecionada.  São necessárias opções para indicar qual parte do arquivo é a chave. </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   #   /dev/mem: luks-d07....69 UUID=d07....69 /dev/mem keyfile-offset=0x10000000,keyfile-size=16 #   phram: luks-d07....69 UUID=d07....69 /dev/mtd0 keyfile-size=16 #   nd_e820: luks-d07....69 UUID=d07....69 /dev/pmem0 keyfile-size=16</code> </pre> <br><p>  Só que não vai funcionar assim. </p><br><p>  O ponto é como o systemd determina quando um dispositivo pode ser desbloqueado.  Ou seja, ele pega o dispositivo da terceira coluna e aguarda a unidade do dispositivo correspondente se tornar ativa.  Parece lógico: não faz sentido tentar desbloquear o contêiner LUKS até que um dispositivo com um arquivo de chave seja exibido.  Mas a unidade do dispositivo não é a mesma que o próprio dispositivo.  O Systemd, por padrão, cria unidades de dispositivo apenas para dispositivos do kernel relacionados a subsistemas de dispositivos de bloco e interfaces de rede.  Os dispositivos <code>/dev/mem</code> e <code>/dev/mtd0</code> são caracter por caracter, portanto, não são monitorados por padrão e nunca serão reconhecidos como prontos. </p><br><p>  Você precisará informar ao systemd que ele deve rastreá-las criando regras do <code>/etc/udev/rules.d/99-mem.rules</code> arquivo <code>/etc/udev/rules.d/99-mem.rules</code> : </p><br><pre> <code class="plaintext hljs"># /dev/mem KERNEL=="mem", TAG+="systemd" # /dev/mtd* KERNEL=="mtd*", TAG+="systemd" #  /dev/pmem*      </code> </pre> <br><h3 id="shag-pyatyy-peregenerirovat-initramfs">  Etapa 5: regenerar o initramfs </h3><br><blockquote>  Lembro a você: este artigo discute apenas distribuições usando o Dracut.  Incluindo aqueles onde não é usado por padrão, mas é acessível e eficiente. </blockquote><p>  Você precisa regenerar o initramfs para atualizar o arquivo <code>/etc/crypttab</code> lá.  E também - para incluir módulos adicionais do kernel e regras do udev lá.  Caso contrário, o dispositivo <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> não será criado.  O parâmetro de configuração do Dracut <code>force_drivers</code> é responsável por ativar e carregar módulos adicionais do kernel, e o <code>install_items</code> é responsável por arquivos adicionais.  Criamos o arquivo <code>/etc/dracut.conf.d/mem.conf</code> com o seguinte conteúdo (é necessário um espaço após as aspas de abertura, este é um separador): </p><br><pre> <code class="plaintext hljs">#   /dev/mem: install_items+=" /etc/udev/rules.d/99-mem.rules" #   phram: install_items+=" /etc/udev/rules.d/99-mem.rules" force_drivers+=" phram" #   nd_e820: force_drivers+=" nd_e820 nd_pmem"</code> </pre> <br><p>  Na verdade, initramfs de regeneração: </p><br><pre> <code class="plaintext hljs"># dracut -f</code> </pre> <br><blockquote>  Para usuários do Debian e Ubuntu, o mantenedor colocou uma rake: o arquivo resultante é chamado incorretamente.  Você precisa renomeá-lo para que ele seja nomeado da mesma maneira que prescrita na configuração do GRUB: <br><pre> <code class="plaintext hljs"># mv /boot/initramfs-5.0.0-19-generic.img /boot/initrd.img-5.0.0-19-generic</code> </pre> <br><br>  Ao instalar novos kernels, a criação automática de initramfs via Dracut é realizada corretamente, o bug afeta apenas o lançamento manual do <code>dracut -f</code> . </blockquote><br><h3 id="shag-shestoy-perezagruzit-kompyuter">  Etapa 6: Reinicie seu computador </h3><br><p>  É necessária uma reinicialização para que as alterações nas configurações do GRUB e Dracut entrem em vigor. </p><br><pre> <code class="plaintext hljs"># reboot</code> </pre> <br><p>  Nesse estágio, não há chave na memória, portanto, você precisará digitar uma senha. </p><br><p>  Após a reinicialização, você precisa verificar se o backup da memória funcionou corretamente.  No mínimo, no pseudo- <code>/proc/iomem</code> memória necessária deve ser marcada como "reservada" (ao usar <code>/dev/mem</code> ou <code>phram</code> ) ou como "Memória Persistente (legada)". </p><br><p>  Mesmo ao usar <code>phram</code> ou <code>nd_e820</code> você precisa garantir que o dispositivo <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> realmente se refira à área de memória reservada anteriormente e não a outra coisa. </p><br><pre> <code class="plaintext hljs"># cat /sys/class/mtd/mtd0/name #  : "savedkey" # cat /sys/block/pmem0/device/resource #    </code> </pre> <br><p>  Se não for assim, você precisará descobrir qual dos dispositivos <code>/dev/mtd*</code> ou <code>/dev/pmem*</code> "nosso" e, em seguida, corrigir / etc / crypttab, gerar novamente o initramfs e verificar novamente o resultado após outra reinicialização. </p><br><h3 id="shag-sedmoy-nastroit-kopirovanie-klyuchevogo-fayla-v-pamyat">  Sétima etapa: configurar a cópia do arquivo-chave na memória </h3><br><p>  O arquivo de chave será copiado para a memória antes da reinicialização.  Uma das maneiras de executar qualquer comando no estágio de desligamento do sistema é registrá-lo na diretiva <code>ExecStop</code> no serviço systemd.  Para que o systemd entenda que isso não é um daemon e não jure pela falta da diretiva <code>ExecStart</code> , você precisa especificar o tipo de serviço como <code>ExecStart</code> - <code>ExecStart</code> e também sugerir que o serviço seja considerado em execução, mesmo se nenhum processo de trabalho estiver associado a ele.  Então, aqui está o arquivo <code>/etc/systemd/system/savekey.service</code> .  É necessário deixar apenas uma das variantes fornecidas da diretiva <code>ExecStop</code> . </p><br><pre> <code class="plaintext hljs">[Unit] Description=Saving LUKS key into RAM Documentation=https://habr.com/ru/post/457396/ [Service] Type=oneshot RemainAfterExit=true #   /dev/mem: ExecStop=/bin/sh -c 'dd if=/root/key of=/dev/mem bs=1 seek=$((0x10000000))' #   /dev/mtd0: ExecStop=/bin/dd if=/root/key of=/dev/mtd0 #   /dev/pmem0: ExecStop=/bin/dd if=/root/key of=/dev/pmem0 [Install] WantedBy=default.target</code> </pre> <br><p>  A construção com <code>/bin/sh</code> necessária, pois o <code>dd</code> não entende a notação hexadecimal. </p><br><p>  Ativamos o serviço, verifique: </p><br><pre> <code class="plaintext hljs"># systemctl enable savekey # systemctl start savekey # reboot</code> </pre> <br><p>  Durante a reinicialização subsequente, você não precisa inserir a senha no disco.  E, se necessário, isso geralmente significa que o endereço inicial da área de memória reservada foi selecionado incorretamente.  Não há problema em corrigir e regenerar vários arquivos e reiniciar o computador duas vezes. </p><br><p>  Ao usar <code>phram</code> ou <code>nd_e820</code> somente a configuração do GRUB precisará ser editada.  Ao usar <code>/dev/mem</code> endereço inicial também é mencionado em <code>/etc/crypttab</code> (portanto, o initramfs precisará ser regenerado) e no serviço systemd. </p><br><p>  Mas isso não é tudo. </p><br><h3 id="voprosy-bezopasnosti">  Questões de segurança </h3><br><p>  Qualquer discussão sobre problemas de segurança é baseada em um modelo de ameaça.  I.e.  sobre os objetivos e meios do atacante.  Estou ciente de que alguns dos exemplos abaixo são absurdos. </p><br><p>  As situações com acesso físico a um computador desligado não são diferentes daquelas sem um armazenamento de chaves configurado na memória.  Existem os mesmos tipos de ataques destinados a obter frases-chave, incluindo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Evil Maid</a> , e os mesmos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recursos de segurança</a> .  Não paramos com eles, pois não há nada de novo. </p><br><p>  Situações mais interessantes são quando o computador está ligado. </p><br><p>  <strong>Situação 1</strong> .  O invasor não tem acesso físico ao computador, não conhece a senha, mas possui acesso root via ssh.  O objetivo é a chave para descriptografar o disco.  Por exemplo, para acessar backups setor por setor antigos de uma imagem de disco da máquina virtual. </p><br><p>  Na verdade, a chave no disco está no arquivo <code>/root/key</code> .  A questão é como isso se relaciona com o que aconteceu antes da implementação desta instrução.  Resposta: para luks1, a ameaça não é nova.  Existe um <code>dmsetup table --target crypt --showkeys</code> que mostra a chave mestra, ou seja,  também dados que permitem acesso a backups antigos.  Para luks2, a redução de segurança nesse cenário realmente ocorre: as chaves dm-crypt são armazenadas no chaveiro no nível do kernel e é impossível visualizá-las no espaço do usuário. </p><br><p>  <strong>Situação 2</strong> .  O invasor pode usar o teclado e olhar para a tela, mas não está pronto para abrir o gabinete.  Por exemplo, usei a senha vazada da IPMI ou interceptei uma sessão noVNC na nuvem.  Ele não conhece a frase-chave, também não conhece outras senhas.  O objetivo é o acesso root. </p><br><p>  Por favor: reinicie via <code>Ctrl-Alt-Del</code> , adicionando a opção do kernel <code>init=/bin/sh</code> via GRUB.  A senha não era necessária, pois a chave foi lida com êxito na memória.  Para se proteger disso, você teria que impedir que o GRUB carregasse o que não está no menu.  Infelizmente, essa funcionalidade é implementada de maneira diferente em diferentes distribuições. </p><br><p>  A partir da versão 7.2, o CentOS possui o <code>grub2-setpassword</code> , que realmente protege o GRUB com uma senha.  Outras distribuições podem ter seus próprios utilitários para a mesma tarefa.  Se não estiverem, você poderá editar diretamente os arquivos no diretório <code>/etc/grub.d</code> e gerar <code>grub.cfg</code> . </p><br><p>  No arquivo <code>/etc/grub.d/10_linux</code> , altere a variável CLASS, adicione a opção <code>--unrestricted</code> ao final, se não estiver lá: </p><br><pre> <code class="plaintext hljs">CLASS="--class gnu-linux --class gnu --class os --unrestricted"</code> </pre> <br><p>  No arquivo <code>/etc/grub.d/40_custom</code> adicione as linhas especificando o nome de usuário e a senha necessários para editar a linha de comando do kernel: </p><br><pre> <code class="plaintext hljs">set superusers="root" password_pbkdf2 root grub.pbkdf2....... #    grub2-mkpasswd-pbkdf2</code> </pre> <br><p>  Ou, se essa funcionalidade precisar ser desativada, aqui está uma linha como esta: </p><br><pre> <code class="plaintext hljs">set superusers=""</code> </pre> <br><p>  <strong>Situação 3</strong> .  O invasor tem acesso ao computador incluído, permitindo a inicialização a partir de mídia não confiável.  Pode ser um acesso físico sem abrir o caso ou acessar via IPMI.  O objetivo é o acesso root. </p><br><p>  Ele pode carregar seu GRUB a partir de uma unidade flash USB ou CD-ROM e adicionar <code>init=/bin/sh</code> aos parâmetros do seu kernel, como no exemplo anterior.  Portanto, a inicialização de qualquer mídia horrível deve ser proibida no BIOS.  E também proteja as configurações do BIOS alteradas com uma senha. </p><br><p>  <strong>Situação 4</strong> .  O invasor tem acesso físico ao computador incluído, incluindo a capacidade de abrir o caso.  O objetivo é descobrir a chave ou obter acesso root. </p><br><p>  Em geral, esta é uma situação perdedora de qualquer maneira.  O ataque aos módulos de memória, resfriando-os ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ataque de inicialização a frio</a> ) não foi cancelado.  Além disso, teoricamente (não foi verificado), você pode tirar vantagem do fato de que os discos SATA modernos oferecem suporte à reconexão a quente.  Quando o computador reiniciar, desconecte o disco, altere <code>grub.cfg</code> para <code>init=/bin/sh</code> , reconecte, permita que o sistema reinicie.  Acontece (se bem entendi) o acesso root. </p><br><p>  O mesmo pode ser feito por um funcionário inescrupuloso de uma hospedagem em nuvem, fazendo um instantâneo de uma máquina virtual com sua modificação subsequente. </p><br><h3 id="prochie-voprosy">  Outros assuntos </h3><br><p>  <strong>Manter a chave na memória durante uma reinicialização é uma zombaria.</strong>  <strong>Use após livre na sua forma mais pura.</strong>  <strong>Uma solução mais limpa é usar o kexec e adicionar a chave aos initramfs gerados dinamicamente.</strong>  <strong>Ele também protege contra a substituição de parâmetros do kernel</strong> .  Sim, se o kexec estiver funcionando.  Distribuições modernas tornaram a configuração do kexec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muito complicada</a> . </p><br><p>  <strong>Nos datacenters, e mais ainda na nuvem, o poder nunca desaparece.</strong>  <strong>Acontece que a frase-chave não é mais necessária?</strong>  De fato, <em>se</em> você tem tanta certeza disso, pode excluí-lo.  Ele se tornará um servidor em funcionamento, a chave do disco que ninguém conhece¹ e, portanto, não será divulgado, mas o sistema no qual pode ser atualizado usando meios regulares.    —        <code>sudo poweroff</code> . </p><br><p> ¹    <code>/root/key</code> —         ,        cron. </p><br><p> <strong>   ?  IPMI,       </strong> .    IPMI      Java.        . </p><br><p> <strong>   ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> SSH</a></strong> . !    .  ,      <code>sudo reboot</code> ,      ? </p><br><p>             ,         .     SSH       ,      .       ,      ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457396/">https://habr.com/ru/post/pt457396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457380/index.html">OpenGL ultramoderno. Parte 2</a></li>
<li><a href="../pt457382/index.html">7 hábitos de programadores de alto desempenho</a></li>
<li><a href="../pt457386/index.html">Apresentando as interfaces virtuais do Linux: túneis</a></li>
<li><a href="../pt457390/index.html">Madagascar - ilha dos contrastes</a></li>
<li><a href="../pt457392/index.html">Economias no desenvolvimento de plataformas cruzadas móveis: estudo de caso da Skyeng</a></li>
<li><a href="../pt457398/index.html">Mas estou fazendo besteira? Por que os desenvolvedores vão para o gemba</a></li>
<li><a href="../pt457400/index.html">O número de vítimas de desastres nucleares como Chernobyl é exagerado em termos de drama</a></li>
<li><a href="../pt457402/index.html">Como organizar o desenvolvimento e suporte de um blog no WordPress no 2T19 e não corrigi-lo</a></li>
<li><a href="../pt457404/index.html">Notícias do mundo do OpenStreetMap nº 465 (11/06/2019 - 17/06/2019)</a></li>
<li><a href="../pt457406/index.html">Quanto ganham os graduados de várias universidades russas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>