<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüåæ ‚ö™Ô∏è üë©‚Äçüë©‚Äçüë¶ Desbloquear automaticamente o cont√™iner LUKS raiz ap√≥s uma inicializa√ß√£o a quente ü§≥üèø üóúÔ∏è üåí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por que as pessoas geralmente criptografam unidades de seus computadores pessoais e, √†s vezes, servidores? √â claro que ningu√©m roubou fotos de seus ga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desbloquear automaticamente o cont√™iner LUKS raiz ap√≥s uma inicializa√ß√£o a quente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457396/"><p>  Por que as pessoas geralmente criptografam unidades de seus computadores pessoais e, √†s vezes, servidores?  √â claro que ningu√©m roubou fotos de seus gatos de estima√ß√£o favoritos do disco!  Isso √© apenas azar: uma unidade criptografada exige que voc√™ insira uma frase-chave do teclado a cada inicializa√ß√£o e √© longa e chata.  Remov√™-lo para que, pelo menos √†s vezes, n√£o seja necess√°rio recrut√°-lo.  Sim, para que o significado da criptografia n√£o seja perdido. </p><br><div class="spoiler">  <b class="spoiler_title">Gato pela aten√ß√£o</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sr/rt/ny/srrtnywyggbrscsufm8ux8tvxmu.jpeg" alt="Cat"></p></div></div><br><p>  Bem, remov√™-lo completamente n√£o vai funcionar.  Voc√™ pode criar um arquivo de chave em uma unidade flash USB, e ele tamb√©m funcionar√°.  E sem uma unidade flash (e sem um segundo computador na rede) √© poss√≠vel?  Se voc√™ tiver sorte com o BIOS, pode quase!  Abaixo do corte, haver√° um guia sobre como configurar a criptografia de disco atrav√©s do LUKS com as seguintes propriedades: </p><br><ol><li>  A senha ou o arquivo de chave n√£o √© armazenado em nenhum lugar no formato aberto (ou no formato equivalente a aberto) quando o computador √© desligado. </li><li> Na primeira vez que voc√™ liga o computador, voc√™ deve inserir uma senha. </li><li>  Nas reinicializa√ß√µes subsequentes (antes de desligar), uma senha n√£o √© necess√°ria. </li></ol><br><p>  As instru√ß√µes foram testadas no CentOS 7.6, Ubuntu 19.04 e openSUSE Leap 15.1 em m√°quinas virtuais e em hardware real (desktop, laptop e dois servidores).  Eles devem trabalhar em outras distribui√ß√µes que tenham uma vers√£o funcional do Dracut. </p><br><p>  E sim, no bom sentido, isso deveria ter acabado no hub "administra√ß√£o anormal do sistema", mas n√£o existe esse hub. </p><a name="habracut"></a><br><p>  Sugiro usar um slot separado no cont√™iner LUKS e armazenar a chave para ele ... na RAM! </p><br><div class="spoiler">  <b class="spoiler_title">Que tipo de slot?</b> <div class="spoiler_text"><p> O cont√™iner LUKS implementa criptografia em v√°rios n√≠veis.  Os dados √∫teis no disco s√£o criptografados com uma cifra sim√©trica, geralmente <code>aes-xts-plain64</code> .  A chave para essa cifra sim√©trica (chave mestra) √© gerada no est√°gio de cria√ß√£o do cont√™iner como uma sequ√™ncia aleat√≥ria de bytes.  A chave mestra √© armazenada em forma criptografada, no caso geral - em v√°rias c√≥pias (slots).  Por padr√£o, apenas um dos oito slots est√° ativo.  Cada slot ativo possui uma frase-chave separada (ou um arquivo-chave separado), com o qual voc√™ pode descriptografar a chave mestra.  Do ponto de vista do usu√°rio, voc√™ pode desbloquear a unidade usando qualquer uma das v√°rias frases-chave diferentes (ou arquivos-chave).  No nosso caso, usando uma frase-chave (slot 0) ou um peda√ßo de mem√≥ria usado como arquivo-chave (slot 6). </p></div></div><br><p>  O BIOS na maioria das placas-m√£e n√£o limpa a mem√≥ria durante a reinicializa√ß√£o ou voc√™ pode configur√°-lo para n√£o limpar (exce√ß√£o conhecida: "Intel Corporation S1200SP / S1200SP, BIOS S1200SP.86B.03.01.0042.013020190050 em 30/01/2019").  Portanto, voc√™ pode armazenar a chave l√°.  Quando a energia √© desligada, o conte√∫do da pr√≥pria RAM √© apagado ap√≥s um tempo, junto com uma c√≥pia desprotegida da chave. </p><br><p>  Ent√£o vamos l√°. </p><br><h3 id="shag-pervyy-ustanovit-sistemu-na-zashifrovannyy-s-pomoschyu-luks-disk">  Etapa 1: instalar o sistema em um disco criptografado usando LUKS </h3><br><p>  Nesse caso, a parti√ß√£o do disco (por exemplo, <code>/dev/sda1</code> ) montada em <code>/boot</code> deve permanecer n√£o criptografada e a outra parti√ß√£o na qual todo o resto (por exemplo, <code>/dev/sda2</code> ) deve ser criptografado.  O sistema de arquivos na parti√ß√£o criptografada pode ser qualquer um, voc√™ tamb√©m pode usar o LVM para que o sistema de arquivos raiz, o volume para troca e tudo o mais, exceto <code>/boot</code> no mesmo cont√™iner.  Isso corresponde ao particionamento de disco padr√£o no CentOS 7 e Debian ao escolher a op√ß√£o de criptografia.  O SUSE faz tudo de maneira diferente (criptografa <code>/boot</code> ) e, portanto, requer particionamento manual do disco. </p><br><p>  O resultado deve ser algo como o seguinte: </p><br><pre> <code class="plaintext hljs">$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 10G 0 disk ‚îú‚îÄsda1 8:1 0 1G 0 part /boot ‚îî‚îÄsda2 8:2 0 9G 0 part ‚îî‚îÄluks-d07a97d7-3258-408c-a17c-e2fb56701c69 253:0 0 9G 0 crypt ‚îú‚îÄcentos_centos--encrypt2-root 253:1 0 8G 0 lvm / ‚îî‚îÄcentos_centos--encrypt2-swap 253:2 0 1G 0 lvm [SWAP]</code> </pre> <br><p>  No caso de usar UEFI, tamb√©m haver√° uma parti√ß√£o de sistema EFI. </p><br><blockquote>  Para usu√°rios Debian e Ubuntu: substitua o pacote <code>initramfs-tools</code> pelo <code>dracut</code> . <br><pre> <code class="plaintext hljs"># apt install --no-install-recommends dracut</code> </pre> <br><br>  <code>initramfs-tools</code> implementa l√≥gica incorreta no nosso caso, aplicada a se√ß√µes criptografadas com um arquivo de chave.  Essas se√ß√µes s√£o ignoradas completamente ou o conte√∫do do arquivo-chave √© copiado para o initramfs (ou seja, como resultado, para o disco), o que n√£o √© necess√°rio. </blockquote><br><h3 id="shag-vtoroy-sozdat-klyuchevoy-fayl-kotoryy-budet-ispolzovatsya-dlya-avtomaticheskogo-razblokirovaniya-diska-posle-goryachey-perezagruzki">  Etapa 2: criar um arquivo de chave que ser√° usado para desbloquear automaticamente a unidade ap√≥s uma reinicializa√ß√£o a quente </h3><br><p>  128 bits aleat√≥rios s√£o suficientes para n√≥s, ou seja,  16 bytes.  O arquivo ser√° armazenado em um disco criptografado; portanto, quem n√£o conhece a chave de criptografia e n√£o possui acesso root ao sistema carregado n√£o a l√™. </p><br><pre> <code class="plaintext hljs"># touch -m 0600 /root/key # head -c16 /dev/urandom &gt; /root/key</code> </pre> <br><p>  Existem bits verdadeiramente aleat√≥rios suficientes no arquivo de chaves, para que o algoritmo PBKDF lento, que torna uma chave de criptografia dif√≠cil de escolher a partir de uma frase-chave potencialmente fraca, n√£o seja realmente necess√°rio.  Portanto, ao adicionar uma chave, voc√™ pode reduzir o n√∫mero de itera√ß√µes: </p><br><pre> <code class="plaintext hljs"># cryptsetup luksAddKey --key-slot=6 --iter-time=1 /dev/sda2 /root/key Enter any existing passphrase:</code> </pre> <br><p>  Como voc√™ pode ver, o arquivo de chave √© armazenado em um disco criptografado e, portanto, n√£o representa risco √† seguran√ßa se o computador estiver desligado. </p><br><h3 id="shag-tretiy-vydelit-mesto-v-fizicheskoy-pamyati-dlya-hraneniya-klyucha">  Etapa tr√™s: alocar espa√ßo na mem√≥ria f√≠sica para armazenar a chave </h3><br><p>  O Linux possui pelo menos tr√™s drivers diferentes que permitem acessar a mem√≥ria f√≠sica em um endere√ßo conhecido.  Esse √© o <code>linux/drivers/char/mem.c</code> , que tamb√©m √© respons√°vel pelo dispositivo <code>/dev/mem</code> , al√©m <code>phram</code> m√≥dulos <code>phram</code> (emula um chip MTD, fornece o dispositivo <code>/dev/mtd0</code> ) e o <code>nd_e820</code> (usado ao trabalhar com o NVDIMM, fornece <code>/dev/pmem0</code> ).  Todos eles t√™m caracter√≠sticas desagrad√°veis: </p><br><ul><li>  <code>/dev/mem</code> n√£o <code>/dev/mem</code> ser gravado ao usar o Secure Boot se a distribui√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usa o conjunto de patches LOCKDOWN</a> de Matthew Garrett (e esse conjunto de patches √© necess√°rio se a distribui√ß√£o oferecer suporte ao Secure Boot com um gerenciador de inicializa√ß√£o assinado pela Microsoft); </li><li>  <code>phram</code> n√£o <code>phram</code> dispon√≠vel no CentOS e no Fedora - o mantenedor simplesmente n√£o <code>phram</code> a op√ß√£o correspondente ao criar o kernel; </li><li>  <code>nd_e820</code> precisa reservar pelo menos 128 megabytes de mem√≥ria - √© assim que o NVDIMM funciona.  Mas esta √© a √∫nica op√ß√£o em execu√ß√£o no CentOS com inicializa√ß√£o segura. </li></ul><br><p>  Como n√£o h√° op√ß√£o ideal, todos os tr√™s s√£o considerados abaixo. </p><br><blockquote>  Ao usar qualquer um dos m√©todos, √© necess√°rio extremo cuidado para n√£o afetar acidentalmente dispositivos ou intervalos de mem√≥ria diferentes do necess√°rio.  Isto √© especialmente verdade para computadores que j√° possuem chips MTD ou m√≥dulos NVDIMM.  Ou seja, <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> pode n√£o ser o dispositivo que corresponde √† √°rea de mem√≥ria reservada para armazenar a chave.  A numera√ß√£o dos dispositivos existentes, nos quais os arquivos e scripts de configura√ß√£o dependem, tamb√©m pode ser confusa.  Portanto, √© recomend√°vel desabilitar temporariamente todos os servi√ßos que dependem de dispositivos existentes <code>/dev/mtd*</code> e <code>/dev/pmem*</code> . </blockquote><p>  √â <code>memmap</code> mem√≥ria f√≠sica do Linux, passando a op√ß√£o <code>memmap</code> para o <code>memmap</code> .  Estamos interessados ‚Äã‚Äãem dois tipos dessa op√ß√£o: </p><br><ul><li>  <code>memmap=4K$0x10000000</code> reservas (ou seja, marcas reservadas para que o pr√≥prio kernel n√£o use) 4 kilobytes de mem√≥ria, come√ßando com o endere√ßo f√≠sico 0x10000000; </li><li>  <code>memmap=128M!0x10000000</code> marca 128 megabytes de mem√≥ria f√≠sica, come√ßando com o endere√ßo 0x10000000, como NVDIMM (obviamente falso, mas servir√° para n√≥s). </li></ul><br><p>  A op√ß√£o c <code>$</code> √© adequada para uso com <code>/dev/mem</code> e <code>phram</code> , a op√ß√£o c <code>!</code>  - para <code>nd_e820</code> .  Ao usar <code>$</code> endere√ßo inicial da mem√≥ria reservada deve ser um m√∫ltiplo de <code>0x1000</code> (ou seja, 4 kilobytes), ao usar <code>!</code>  - um m√∫ltiplo de <code>0x8000000</code> (ou seja, 128 megabytes). </p><br><p>  Importante: o cifr√£o ( <code>$</code> ) nos arquivos de configura√ß√£o do GRUB √© um caractere especial e deve ser escapado.  E duas vezes: uma vez - ao gerar o <code>grub.cfg</code> partir de <code>/etc/default/grub</code> , uma segunda vez - ao interpretar o arquivo de configura√ß√£o resultante no est√°gio de inicializa√ß√£o.  I.e.  em <code>/etc/default/grub</code> , a seguinte linha deve aparecer eventualmente: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 ...  ..."</code> </pre> <br><p>  Sem escapar duas vezes do sinal <code>$</code> , o sistema simplesmente n√£o inicializa, pois pensa que possui apenas 4 kilobytes de mem√≥ria.  N√£o h√° tais dificuldades com um ponto de exclama√ß√£o: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=128M!0x10000000 ...  ..."</code> </pre> <br><p>  O cart√£o de mem√≥ria f√≠sico (e √© necess√°rio descobrir quais endere√ßos reservar) √© acess√≠vel ao <code>root</code> no pseudo- <code>/proc/iomem</code> : </p><br><pre> <code class="plaintext hljs"># cat /proc/iomem ... 000f0000-000fffff : reserved 000f0000-000fffff : System ROM 00100000-7ffddfff : System RAM 2b000000-350fffff : Crash kernel 73a00000-7417c25e : Kernel code 7417c25f-747661ff : Kernel data 74945000-74c50fff : Kernel bss 7ffde000-7fffffff : reserved 80000000-febfffff : PCI Bus 0000:00 fd000000-fdffffff : 0000:00:02.0 ...</code> </pre> <br><p>  A RAM est√° marcada como "RAM do sistema", basta reservar uma de suas p√°ginas para armazenar a chave.  Adivinhar qual parte da mem√≥ria do BIOS n√£o toca na reinicializa√ß√£o n√£o funcionar√° com confiabilidade antecipadamente.  A menos que haja outro computador com exatamente a mesma vers√£o do BIOS e a mesma configura√ß√£o de mem√≥ria no qual este manual j√° foi conclu√≠do.  Portanto, no caso geral, voc√™ ter√° que agir por tentativa e erro.  Como regra, quando o BIOS √© reinicializado, ele altera os dados somente no in√≠cio e no final de cada intervalo de mem√≥ria.  Geralmente, √© suficiente retirar 128 megabytes ( <code>0x8000000</code> ) das bordas.  Para m√°quinas virtuais KVM com 1 GB de mem√≥ria ou mais, as op√ß√µes propostas ( <code>memmap=4K$0x10000000</code> e <code>memmap=128M!0x10000000</code> ) funcionam. </p><br><p>  Ao usar o m√≥dulo <code>phram</code> , precisamos de outro par√¢metro de linha de comando do kernel, que, de fato, diz ao m√≥dulo qual parte da mem√≥ria f√≠sica usar - a nossa, reservada.  O par√¢metro √© chamado <code>phram.phram</code> e cont√©m tr√™s partes: o nome (arbitr√°rio at√© 63 caracteres, ser√° vis√≠vel em <code>sysfs</code> ), o endere√ßo inicial e o comprimento.  O endere√ßo inicial e o comprimento devem ser os mesmos do <code>memmap</code> , mas os sufixos <code>K</code> e <code>M</code> n√£o <code>M</code> suportados. </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 phram.phram=savedkey,0x10000000,4096 ..."</code> </pre> <br><p>  Ap√≥s editar o arquivo <code>/etc/default/grub</code> voc√™ precisar√° gerar novamente o arquivo de configura√ß√£o real que o GRUB l√™ na inicializa√ß√£o.  O comando correto para isso depende da distribui√ß√£o. </p><br><pre> <code class="plaintext hljs"># grub2-mkconfig -o /boot/grub2/grub.cfg # CentOS (Legacy BIOS) # grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg # CentOS (UEFI) # update-grub # Debian, Ubuntu # update-bootloader --reinit # SUSE</code> </pre> <br><p>  Ap√≥s atualizar a configura√ß√£o do GRUB, o computador deve ser reiniciado, mas faremos isso mais tarde quando atualizarmos o initramfs. </p><br><h3 id="shag-chetvertyy-nastroit-luks-na-chtenie-klyucha-iz-pamyati">  Quarto passo: configure o LUKS para ler a chave da mem√≥ria </h3><br><p>  <code>/etc/crypttab</code> configura√ß√µes de criptografia da <code>/etc/crypttab</code> s√£o armazenadas no <code>/etc/crypttab</code> .  Cada linha consiste em quatro campos: </p><br><ul><li>  o dispositivo que deve ser obtido ao desbloquear, </li><li>  dispositivo criptografado </li><li>  onde obter o arquivo de teclas ( <code>none</code> significa digitar uma frase-chave no teclado), </li><li>  campo opcional para op√ß√µes. </li></ul><br><p>  Se o arquivo-chave existe, mas n√£o se encaixa, o Dracut solicita a frase-chave.  O que, de fato, ser√° necess√°rio na primeira inicializa√ß√£o. </p><br><p>  Um exemplo do <code>/etc/crypttab</code> de uma distribui√ß√£o rec√©m-instalada: </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   luks-d07....69 UUID=d07....69 none</code> </pre> <br><p>  O arquivo-chave no nosso caso ser√° um peda√ßo de mem√≥ria f√≠sica.  I.e.  <code>/dev/mem</code> , <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> , dependendo da tecnologia de acesso √† mem√≥ria selecionada.  S√£o necess√°rias op√ß√µes para indicar qual parte do arquivo √© a chave. </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   #   /dev/mem: luks-d07....69 UUID=d07....69 /dev/mem keyfile-offset=0x10000000,keyfile-size=16 #   phram: luks-d07....69 UUID=d07....69 /dev/mtd0 keyfile-size=16 #   nd_e820: luks-d07....69 UUID=d07....69 /dev/pmem0 keyfile-size=16</code> </pre> <br><p>  S√≥ que n√£o vai funcionar assim. </p><br><p>  O ponto √© como o systemd determina quando um dispositivo pode ser desbloqueado.  Ou seja, ele pega o dispositivo da terceira coluna e aguarda a unidade do dispositivo correspondente se tornar ativa.  Parece l√≥gico: n√£o faz sentido tentar desbloquear o cont√™iner LUKS at√© que um dispositivo com um arquivo de chave seja exibido.  Mas a unidade do dispositivo n√£o √© a mesma que o pr√≥prio dispositivo.  O Systemd, por padr√£o, cria unidades de dispositivo apenas para dispositivos do kernel relacionados a subsistemas de dispositivos de bloco e interfaces de rede.  Os dispositivos <code>/dev/mem</code> e <code>/dev/mtd0</code> s√£o caracter por caracter, portanto, n√£o s√£o monitorados por padr√£o e nunca ser√£o reconhecidos como prontos. </p><br><p>  Voc√™ precisar√° informar ao systemd que ele deve rastre√°-las criando regras do <code>/etc/udev/rules.d/99-mem.rules</code> arquivo <code>/etc/udev/rules.d/99-mem.rules</code> : </p><br><pre> <code class="plaintext hljs"># /dev/mem KERNEL=="mem", TAG+="systemd" # /dev/mtd* KERNEL=="mtd*", TAG+="systemd" #  /dev/pmem*      </code> </pre> <br><h3 id="shag-pyatyy-peregenerirovat-initramfs">  Etapa 5: regenerar o initramfs </h3><br><blockquote>  Lembro a voc√™: este artigo discute apenas distribui√ß√µes usando o Dracut.  Incluindo aqueles onde n√£o √© usado por padr√£o, mas √© acess√≠vel e eficiente. </blockquote><p>  Voc√™ precisa regenerar o initramfs para atualizar o arquivo <code>/etc/crypttab</code> l√°.  E tamb√©m - para incluir m√≥dulos adicionais do kernel e regras do udev l√°.  Caso contr√°rio, o dispositivo <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> n√£o ser√° criado.  O par√¢metro de configura√ß√£o do Dracut <code>force_drivers</code> √© respons√°vel por ativar e carregar m√≥dulos adicionais do kernel, e o <code>install_items</code> √© respons√°vel por arquivos adicionais.  Criamos o arquivo <code>/etc/dracut.conf.d/mem.conf</code> com o seguinte conte√∫do (√© necess√°rio um espa√ßo ap√≥s as aspas de abertura, este √© um separador): </p><br><pre> <code class="plaintext hljs">#   /dev/mem: install_items+=" /etc/udev/rules.d/99-mem.rules" #   phram: install_items+=" /etc/udev/rules.d/99-mem.rules" force_drivers+=" phram" #   nd_e820: force_drivers+=" nd_e820 nd_pmem"</code> </pre> <br><p>  Na verdade, initramfs de regenera√ß√£o: </p><br><pre> <code class="plaintext hljs"># dracut -f</code> </pre> <br><blockquote>  Para usu√°rios do Debian e Ubuntu, o mantenedor colocou uma rake: o arquivo resultante √© chamado incorretamente.  Voc√™ precisa renome√°-lo para que ele seja nomeado da mesma maneira que prescrita na configura√ß√£o do GRUB: <br><pre> <code class="plaintext hljs"># mv /boot/initramfs-5.0.0-19-generic.img /boot/initrd.img-5.0.0-19-generic</code> </pre> <br><br>  Ao instalar novos kernels, a cria√ß√£o autom√°tica de initramfs via Dracut √© realizada corretamente, o bug afeta apenas o lan√ßamento manual do <code>dracut -f</code> . </blockquote><br><h3 id="shag-shestoy-perezagruzit-kompyuter">  Etapa 6: Reinicie seu computador </h3><br><p>  √â necess√°ria uma reinicializa√ß√£o para que as altera√ß√µes nas configura√ß√µes do GRUB e Dracut entrem em vigor. </p><br><pre> <code class="plaintext hljs"># reboot</code> </pre> <br><p>  Nesse est√°gio, n√£o h√° chave na mem√≥ria, portanto, voc√™ precisar√° digitar uma senha. </p><br><p>  Ap√≥s a reinicializa√ß√£o, voc√™ precisa verificar se o backup da mem√≥ria funcionou corretamente.  No m√≠nimo, no pseudo- <code>/proc/iomem</code> mem√≥ria necess√°ria deve ser marcada como "reservada" (ao usar <code>/dev/mem</code> ou <code>phram</code> ) ou como "Mem√≥ria Persistente (legada)". </p><br><p>  Mesmo ao usar <code>phram</code> ou <code>nd_e820</code> voc√™ precisa garantir que o dispositivo <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> realmente se refira √† √°rea de mem√≥ria reservada anteriormente e n√£o a outra coisa. </p><br><pre> <code class="plaintext hljs"># cat /sys/class/mtd/mtd0/name #  : "savedkey" # cat /sys/block/pmem0/device/resource #    </code> </pre> <br><p>  Se n√£o for assim, voc√™ precisar√° descobrir qual dos dispositivos <code>/dev/mtd*</code> ou <code>/dev/pmem*</code> "nosso" e, em seguida, corrigir / etc / crypttab, gerar novamente o initramfs e verificar novamente o resultado ap√≥s outra reinicializa√ß√£o. </p><br><h3 id="shag-sedmoy-nastroit-kopirovanie-klyuchevogo-fayla-v-pamyat">  S√©tima etapa: configurar a c√≥pia do arquivo-chave na mem√≥ria </h3><br><p>  O arquivo de chave ser√° copiado para a mem√≥ria antes da reinicializa√ß√£o.  Uma das maneiras de executar qualquer comando no est√°gio de desligamento do sistema √© registr√°-lo na diretiva <code>ExecStop</code> no servi√ßo systemd.  Para que o systemd entenda que isso n√£o √© um daemon e n√£o jure pela falta da diretiva <code>ExecStart</code> , voc√™ precisa especificar o tipo de servi√ßo como <code>ExecStart</code> - <code>ExecStart</code> e tamb√©m sugerir que o servi√ßo seja considerado em execu√ß√£o, mesmo se nenhum processo de trabalho estiver associado a ele.  Ent√£o, aqui est√° o arquivo <code>/etc/systemd/system/savekey.service</code> .  √â necess√°rio deixar apenas uma das variantes fornecidas da diretiva <code>ExecStop</code> . </p><br><pre> <code class="plaintext hljs">[Unit] Description=Saving LUKS key into RAM Documentation=https://habr.com/ru/post/457396/ [Service] Type=oneshot RemainAfterExit=true #   /dev/mem: ExecStop=/bin/sh -c 'dd if=/root/key of=/dev/mem bs=1 seek=$((0x10000000))' #   /dev/mtd0: ExecStop=/bin/dd if=/root/key of=/dev/mtd0 #   /dev/pmem0: ExecStop=/bin/dd if=/root/key of=/dev/pmem0 [Install] WantedBy=default.target</code> </pre> <br><p>  A constru√ß√£o com <code>/bin/sh</code> necess√°ria, pois o <code>dd</code> n√£o entende a nota√ß√£o hexadecimal. </p><br><p>  Ativamos o servi√ßo, verifique: </p><br><pre> <code class="plaintext hljs"># systemctl enable savekey # systemctl start savekey # reboot</code> </pre> <br><p>  Durante a reinicializa√ß√£o subsequente, voc√™ n√£o precisa inserir a senha no disco.  E, se necess√°rio, isso geralmente significa que o endere√ßo inicial da √°rea de mem√≥ria reservada foi selecionado incorretamente.  N√£o h√° problema em corrigir e regenerar v√°rios arquivos e reiniciar o computador duas vezes. </p><br><p>  Ao usar <code>phram</code> ou <code>nd_e820</code> somente a configura√ß√£o do GRUB precisar√° ser editada.  Ao usar <code>/dev/mem</code> endere√ßo inicial tamb√©m √© mencionado em <code>/etc/crypttab</code> (portanto, o initramfs precisar√° ser regenerado) e no servi√ßo systemd. </p><br><p>  Mas isso n√£o √© tudo. </p><br><h3 id="voprosy-bezopasnosti">  Quest√µes de seguran√ßa </h3><br><p>  Qualquer discuss√£o sobre problemas de seguran√ßa √© baseada em um modelo de amea√ßa.  I.e.  sobre os objetivos e meios do atacante.  Estou ciente de que alguns dos exemplos abaixo s√£o absurdos. </p><br><p>  As situa√ß√µes com acesso f√≠sico a um computador desligado n√£o s√£o diferentes daquelas sem um armazenamento de chaves configurado na mem√≥ria.  Existem os mesmos tipos de ataques destinados a obter frases-chave, incluindo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Evil Maid</a> , e os mesmos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recursos de seguran√ßa</a> .  N√£o paramos com eles, pois n√£o h√° nada de novo. </p><br><p>  Situa√ß√µes mais interessantes s√£o quando o computador est√° ligado. </p><br><p>  <strong>Situa√ß√£o 1</strong> .  O invasor n√£o tem acesso f√≠sico ao computador, n√£o conhece a senha, mas possui acesso root via ssh.  O objetivo √© a chave para descriptografar o disco.  Por exemplo, para acessar backups setor por setor antigos de uma imagem de disco da m√°quina virtual. </p><br><p>  Na verdade, a chave no disco est√° no arquivo <code>/root/key</code> .  A quest√£o √© como isso se relaciona com o que aconteceu antes da implementa√ß√£o desta instru√ß√£o.  Resposta: para luks1, a amea√ßa n√£o √© nova.  Existe um <code>dmsetup table --target crypt --showkeys</code> que mostra a chave mestra, ou seja,  tamb√©m dados que permitem acesso a backups antigos.  Para luks2, a redu√ß√£o de seguran√ßa nesse cen√°rio realmente ocorre: as chaves dm-crypt s√£o armazenadas no chaveiro no n√≠vel do kernel e √© imposs√≠vel visualiz√°-las no espa√ßo do usu√°rio. </p><br><p>  <strong>Situa√ß√£o 2</strong> .  O invasor pode usar o teclado e olhar para a tela, mas n√£o est√° pronto para abrir o gabinete.  Por exemplo, usei a senha vazada da IPMI ou interceptei uma sess√£o noVNC na nuvem.  Ele n√£o conhece a frase-chave, tamb√©m n√£o conhece outras senhas.  O objetivo √© o acesso root. </p><br><p>  Por favor: reinicie via <code>Ctrl-Alt-Del</code> , adicionando a op√ß√£o do kernel <code>init=/bin/sh</code> via GRUB.  A senha n√£o era necess√°ria, pois a chave foi lida com √™xito na mem√≥ria.  Para se proteger disso, voc√™ teria que impedir que o GRUB carregasse o que n√£o est√° no menu.  Infelizmente, essa funcionalidade √© implementada de maneira diferente em diferentes distribui√ß√µes. </p><br><p>  A partir da vers√£o 7.2, o CentOS possui o <code>grub2-setpassword</code> , que realmente protege o GRUB com uma senha.  Outras distribui√ß√µes podem ter seus pr√≥prios utilit√°rios para a mesma tarefa.  Se n√£o estiverem, voc√™ poder√° editar diretamente os arquivos no diret√≥rio <code>/etc/grub.d</code> e gerar <code>grub.cfg</code> . </p><br><p>  No arquivo <code>/etc/grub.d/10_linux</code> , altere a vari√°vel CLASS, adicione a op√ß√£o <code>--unrestricted</code> ao final, se n√£o estiver l√°: </p><br><pre> <code class="plaintext hljs">CLASS="--class gnu-linux --class gnu --class os --unrestricted"</code> </pre> <br><p>  No arquivo <code>/etc/grub.d/40_custom</code> adicione as linhas especificando o nome de usu√°rio e a senha necess√°rios para editar a linha de comando do kernel: </p><br><pre> <code class="plaintext hljs">set superusers="root" password_pbkdf2 root grub.pbkdf2....... #    grub2-mkpasswd-pbkdf2</code> </pre> <br><p>  Ou, se essa funcionalidade precisar ser desativada, aqui est√° uma linha como esta: </p><br><pre> <code class="plaintext hljs">set superusers=""</code> </pre> <br><p>  <strong>Situa√ß√£o 3</strong> .  O invasor tem acesso ao computador inclu√≠do, permitindo a inicializa√ß√£o a partir de m√≠dia n√£o confi√°vel.  Pode ser um acesso f√≠sico sem abrir o caso ou acessar via IPMI.  O objetivo √© o acesso root. </p><br><p>  Ele pode carregar seu GRUB a partir de uma unidade flash USB ou CD-ROM e adicionar <code>init=/bin/sh</code> aos par√¢metros do seu kernel, como no exemplo anterior.  Portanto, a inicializa√ß√£o de qualquer m√≠dia horr√≠vel deve ser proibida no BIOS.  E tamb√©m proteja as configura√ß√µes do BIOS alteradas com uma senha. </p><br><p>  <strong>Situa√ß√£o 4</strong> .  O invasor tem acesso f√≠sico ao computador inclu√≠do, incluindo a capacidade de abrir o caso.  O objetivo √© descobrir a chave ou obter acesso root. </p><br><p>  Em geral, esta √© uma situa√ß√£o perdedora de qualquer maneira.  O ataque aos m√≥dulos de mem√≥ria, resfriando-os ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ataque de inicializa√ß√£o a frio</a> ) n√£o foi cancelado.  Al√©m disso, teoricamente (n√£o foi verificado), voc√™ pode tirar vantagem do fato de que os discos SATA modernos oferecem suporte √† reconex√£o a quente.  Quando o computador reiniciar, desconecte o disco, altere <code>grub.cfg</code> para <code>init=/bin/sh</code> , reconecte, permita que o sistema reinicie.  Acontece (se bem entendi) o acesso root. </p><br><p>  O mesmo pode ser feito por um funcion√°rio inescrupuloso de uma hospedagem em nuvem, fazendo um instant√¢neo de uma m√°quina virtual com sua modifica√ß√£o subsequente. </p><br><h3 id="prochie-voprosy">  Outros assuntos </h3><br><p>  <strong>Manter a chave na mem√≥ria durante uma reinicializa√ß√£o √© uma zombaria.</strong>  <strong>Use ap√≥s livre na sua forma mais pura.</strong>  <strong>Uma solu√ß√£o mais limpa √© usar o kexec e adicionar a chave aos initramfs gerados dinamicamente.</strong>  <strong>Ele tamb√©m protege contra a substitui√ß√£o de par√¢metros do kernel</strong> .  Sim, se o kexec estiver funcionando.  Distribui√ß√µes modernas tornaram a configura√ß√£o do kexec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muito complicada</a> . </p><br><p>  <strong>Nos datacenters, e mais ainda na nuvem, o poder nunca desaparece.</strong>  <strong>Acontece que a frase-chave n√£o √© mais necess√°ria?</strong>  De fato, <em>se</em> voc√™ tem tanta certeza disso, pode exclu√≠-lo.  Ele se tornar√° um servidor em funcionamento, a chave do disco que ningu√©m conhece¬π e, portanto, n√£o ser√° divulgado, mas o sistema no qual pode ser atualizado usando meios regulares.    ‚Äî        <code>sudo poweroff</code> . </p><br><p> ¬π    <code>/root/key</code> ‚Äî         ,        cron. </p><br><p> <strong>   ?  IPMI,       </strong> .    IPMI      Java.        . </p><br><p> <strong>   ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> SSH</a></strong> . !    .  ,      <code>sudo reboot</code> ,      ? </p><br><p>             ,         .     SSH       ,      .       ,      ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457396/">https://habr.com/ru/post/pt457396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457380/index.html">OpenGL ultramoderno. Parte 2</a></li>
<li><a href="../pt457382/index.html">7 h√°bitos de programadores de alto desempenho</a></li>
<li><a href="../pt457386/index.html">Apresentando as interfaces virtuais do Linux: t√∫neis</a></li>
<li><a href="../pt457390/index.html">Madagascar - ilha dos contrastes</a></li>
<li><a href="../pt457392/index.html">Economias no desenvolvimento de plataformas cruzadas m√≥veis: estudo de caso da Skyeng</a></li>
<li><a href="../pt457398/index.html">Mas estou fazendo besteira? Por que os desenvolvedores v√£o para o gemba</a></li>
<li><a href="../pt457400/index.html">O n√∫mero de v√≠timas de desastres nucleares como Chernobyl √© exagerado em termos de drama</a></li>
<li><a href="../pt457402/index.html">Como organizar o desenvolvimento e suporte de um blog no WordPress no 2T19 e n√£o corrigi-lo</a></li>
<li><a href="../pt457404/index.html">Not√≠cias do mundo do OpenStreetMap n¬∫ 465 (11/06/2019 - 17/06/2019)</a></li>
<li><a href="../pt457406/index.html">Quanto ganham os graduados de v√°rias universidades russas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>