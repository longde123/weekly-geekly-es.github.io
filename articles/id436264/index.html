<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥙 ⌛️ 👎🏼 Mono-repositori: tolong jangan (bagian 2) 🚏 👱🏿 🎞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Jadi, bagian baru dari holivar yang dijanjikan tentang monorepositori. Pada bagian pertama, kami membahas terjemahan sebuah artikel ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mono-repositori: tolong jangan (bagian 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436264/"> Halo semuanya! <br><br>  Jadi, bagian baru dari holivar yang dijanjikan tentang monorepositori.  Pada bagian pertama, kami membahas terjemahan sebuah artikel oleh seorang insinyur terkemuka dari Lyft (dan sebelumnya Twitter) tentang apa saja kerugian dari monorepositori dan mengapa mereka meratakan hampir semua kelebihan dari pendekatan ini.  Secara pribadi, saya sangat setuju dengan argumen yang disajikan dalam artikel asli.  Tetapi, seperti yang dijanjikan, untuk mengakhiri diskusi ini, saya ingin menyuarakan beberapa poin lagi, menurut saya bahkan lebih penting dan lebih praktis. <br><a name="habracut"></a><br>  Saya akan bercerita sedikit tentang diri saya - saya bekerja di kedua proyek kecil dan yang relatif besar, saya menggunakan polirepositori dalam proyek dengan lebih dari 100 layanan mikro (dan SLA 99,999%).  Saat ini saya sedang terlibat dalam terjemahan mono-repositori kecil (sebenarnya tidak, hanya js + java backend depan) dari maven ke bazel.  Tidak berfungsi di Google, Facebook, Twitter, mis.  Saya tidak merasa senang menggunakan repositori yang dikonfigurasi dan disetel dengan benar. <br><br>  Jadi, sebagai permulaan, apa itu monorepositori?  Komentar pada terjemahan artikel asli menunjukkan bahwa banyak yang percaya bahwa mono-repositori adalah ketika semua 5 pengembang perusahaan bekerja pada satu repositori dan menyimpan frontend dan backend di dalamnya bersama-sama.  Tentu saja tidak demikian.  Mono-repositori adalah cara menyimpan semua proyek perusahaan, pustaka, alat bangun, plug-in untuk IDE, skrip penempatan, dan semua lainnya dalam satu repositori besar.  Detail di sini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">trunkbaseddevelopment.com</a> . <br><br>  Apa pendekatan yang disebut ketika perusahaan kecil, dan itu tidak memiliki begitu banyak proyek, modul, komponen?  Ini juga merupakan monorepositori, hanya yang kecil. <br>  Secara alami, artikel asli mengatakan bahwa semua masalah yang dijelaskan mulai muncul pada skala tertentu.  Oleh karena itu, mereka yang menulis bahwa repositori mono dengan 1,5 digger berfungsi dengan baik tentu saja benar. <br><br>  Jadi, fakta pertama yang ingin saya perbaiki: <b>monorepositori adalah awal yang baik untuk proyek baru Anda</b> .  Menempatkan semua kode dalam satu tumpukan, pada awalnya Anda hanya akan mendapatkan satu keuntungan, karena  mendukung banyak repositori tentu akan menambah sedikit overhead. <br><br>  Lalu apa masalahnya?  Dan masalahnya, seperti disebutkan dalam artikel asli, dimulai pada skala tertentu.  Dan yang paling penting, jangan lewatkan momen ketika skala seperti itu telah tiba. <br><br>  Oleh karena itu, saya cenderung untuk menegaskan bahwa pada dasarnya masalah yang muncul bukan masalah dari "menempatkan semua kode Anda dalam satu tumpukan" pendekatan itu sendiri, tetapi ini adalah masalah repositori kode sumber yang cukup besar.  Yaitu  dengan asumsi bahwa Anda menggunakan polrepositori untuk berbagai layanan / komponen, dan salah satu layanan ini menjadi sangat besar (seberapa besar, kita akan membahas sedikit kemudian), maka Anda kemungkinan besar akan mendapatkan masalah yang sama persis, tetapi juga tanpa kelebihan repositori mono (jika mereka Tentu saja ada). <br><br>  Jadi, seberapa besar repositori mulai dianggap bermasalah? <br>  Pasti ada 2 indikator yang tergantung pada ini - jumlah kode dan jumlah pengembang yang bekerja dengan kode ini.  Jika proyek Anda memiliki kode terabyte, tetapi 1-2 orang bekerja dengannya, maka kemungkinan besar mereka hampir tidak akan melihat masalah (well, atau setidaknya akan lebih mudah untuk tidak melakukan apa-apa, bahkan jika mereka memperhatikan :) <br><br>  Bagaimana menentukan bahwa sudah saatnya memikirkan bagaimana meningkatkan repositori Anda?  Tentu saja, ini adalah indikator subjektif, kemungkinan besar pengembang Anda akan mulai mengeluh bahwa ada sesuatu yang tidak sesuai dengan mereka.  Tetapi masalahnya adalah mungkin sudah terlambat untuk mengubah sesuatu.  Biarkan saya memberi Anda beberapa angka pribadi: jika kloning repositori Anda membutuhkan lebih dari 10 menit, jika membangun proyek membutuhkan lebih dari 20-30 menit, jika jumlah pengembang melebihi 50, dan seterusnya. <br><br><div class="spoiler">  <b class="spoiler_title">Fakta menarik dari praktik pribadi:</b> <div class="spoiler_text">  Saya bekerja pada monolit yang agak besar dalam tim yang terdiri dari sekitar 50 pengembang, dibagi menjadi beberapa tim kecil.  Pengembangan dilakukan dalam fitur brunch, dan penggabungan terjadi tepat sebelum fitur membeku.  Suatu hari saya menghabiskan 3 hari di gabungan cabang tim kami setelah 6 tim lain membeku di depan saya. <br></div></div><br>  Sekarang mari kita melihat daftar masalah-masalah yang muncul dalam repositori besar (beberapa dari mereka disebutkan dalam artikel asli, beberapa tidak). <br><br><h4>  1) Waktu pengunduhan repositori </h4><br>  Di satu sisi, kita dapat mengatakan bahwa ini adalah operasi satu kali yang dilakukan pengembang selama pengaturan awal workstation-nya.  Secara pribadi, saya sering mengalami situasi di mana saya ingin mengkloning proyek ke folder tetangga, menggali lebih dalam, dan kemudian menghapusnya.  Namun, jika kloning membutuhkan waktu lebih dari 10-20 menit, ini tidak akan nyaman. <br><br>  Tetapi di samping itu, jangan lupa bahwa sebelum membangun proyek pada server CI, Anda perlu mengkloning repositori untuk setiap agen build.  Dan di sini Anda mulai mencari tahu cara menghemat waktu ini, karena jika setiap perakitan memakan waktu 10-20 menit lebih lama, dan hasil perakitan muncul 10-20 menit kemudian, ini tidak cocok untuk siapa pun.  Jadi repositori mulai muncul dalam gambar mesin virtual dari mana agen ditempatkan, kompleksitas tambahan dan biaya tambahan untuk mendukung solusi ini muncul. <br><br><h4>  2) Bangun waktu </h4><br>  Ini adalah poin yang cukup jelas yang telah dibahas berkali-kali.  Bahkan, jika Anda memiliki banyak kode sumber, maka perakitan dalam hal apa pun akan memakan waktu yang cukup lama.  Situasi yang umum adalah ketika setelah mengubah satu baris kode Anda harus menunggu setengah jam sampai perubahan disusun kembali dan diuji.  Bahkan, hanya ada satu jalan keluar - untuk menggunakan sistem build yang dibangun di sekitar hasil caching dan build tambahan. <br><br>  Tidak ada banyak pilihan di sini - meskipun fakta bahwa fitur caching ditambahkan ke tingkat yang sama (sayangnya, saya tidak menggunakannya dalam praktik), mereka tidak membawa manfaat praktis karena fakta bahwa sistem pembangunan tradisional tidak memiliki hasil yang dapat diulang (build direproduksi).  Yaitu  karena efek samping dari build sebelumnya, bagaimanapun, pada beberapa titik akan perlu untuk memanggil pembersihan cache (pendekatan standar standar <code>maven clean build</code> ).  Oleh karena itu, hanya ada opsi untuk menggunakan Bazel / Buck / Pants dan yang lainnya menyukainya.  Kenapa ini tidak terlalu bagus, kita akan bahas nanti. <br><br><h4>  3) Pengindeksan IDE </h4><br>  Proyek saya saat ini diindeks di Intellij IDEA selama 30 hingga 40 menit.  Bagaimana dengan milikmu?  Tentu saja, Anda dapat membuka hanya sebagian dari proyek atau mengecualikan semua modul yang tidak perlu dari pengindeksan, tapi ... Masalahnya adalah pengindeksan ulang terjadi setiap kali Anda beralih dari satu cabang ke cabang lainnya.  Itu sebabnya saya ingin mengkloning proyek di direktori tetangga.  Beberapa orang mulai melakukan cache cache IDE :) <br>  &lt;Gambar DiCaprio dengan mata menyipit&gt; <br><br><h4>  4) Buat log </h4><br>  Server CI apa yang Anda gunakan?  Apakah ini menyediakan antarmuka yang nyaman untuk melihat dan menavigasi beberapa gigabytes log bangunan?  Sayangnya milik saya bukan :( <br><br><h4>  5) Sejarah komitmen </h4><br>  Apakah Anda suka menonton komit sejarah?  Saya suka, terutama di alat dengan antarmuka grafis (saya melihat informasi yang lebih baik secara visual, jangan dimarahi :). <br><div class="spoiler">  <b class="spoiler_title">Ini adalah apa yang tampak seperti komit sejarah di repositori saya</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/h1/y5/_4/h1y5_4hjo4iyeo6frm57gjwsvgk.png" alt="gambar"><br></div></div><br>  Apakah kamu menyukainya?  Apakah itu nyaman?  Secara pribadi, saya tidak! <br><br><h4>  6) Tes yang rusak </h4><br>  Apa yang terjadi jika seseorang dapat menjalankan tes yang rusak / kode yang tidak dikompilasi ke master?  Anda tentu akan mengatakan bahwa CI Anda tidak memungkinkan Anda untuk melakukan ini.  Bagaimana dengan tes tidak stabil yang penulis lewati, dan tidak ada orang lain?  Sekarang bayangkan kode ini menyebar ke mesin-mesin 300 pengembang, dan tidak satu pun dari mereka dapat merakit proyek?  Apa yang harus dilakukan dalam situasi seperti itu?  Tunggu penulis untuk memperhatikan dan memperbaiki?  Benar untuknya?  Kembalikan perubahan?  Tentu saja, idealnya, hanya layak melakukan kode yang baik, dan menulis segera tanpa bug.  Maka masalah seperti itu tidak akan muncul. <br>  (bagi mereka yang tidak memahami petunjuk dalam tangki, pembicaraannya adalah bahwa efek negatif jika ini terjadi di repositori dengan 10 pengembang dan dalam repositori dengan 300 akan sedikit berbeda) <br><br><h4>  7) Gabungkan bot </h4><br>  Pernah mendengar hal seperti itu?  Apakah Anda tahu mengapa Anda membutuhkannya?  Anda akan tertawa, tetapi ini adalah alat lain yang seharusnya tidak ada :) Bayangkan saja waktu pembangunan proyek Anda adalah 30 menit.  Dan 100 pengembang sedang mengerjakan proyek Anda.  Misalkan masing-masing dari mereka mendorong 1 komit per hari.  Sekarang bayangkan CI jujur, yang memungkinkan Anda untuk menggabungkan perubahan pada master hanya setelah mereka diterapkan pada komit terbaru dari master (rebase). <br><br>  Perhatian, pertanyaannya adalah: berapa jam harus dalam sehari untuk server CI yang jujur ​​untuk mencekik perubahan dari semua pengembang?  Jawaban yang benar adalah 50. Mereka yang menjawab dengan benar dapat mengambil wortel dari rak.  Nah, atau bayangkan bagaimana Anda baru saja memotong komit Anda ke komit terakhir ke master, memulai perakitan, dan ketika sudah selesai, master sudah pergi 20 komit di depan.  Semua lagi? <br><br>  Jadi menggabungkan bot atau menggabungkan antrian adalah layanan yang mengotomatiskan proses rebasing semua permintaan menggabungkan master baru, menjalankan tes dan menggabungkan itu sendiri, dan juga dapat menggabungkan komit ke dalam batch dan mengujinya bersama-sama.  Hal yang sangat berguna.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mergify.io</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">k8s test-infra Prow</a> dari Google, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bors-ng</a> , dll. (Saya berjanji untuk menulis lebih banyak tentang ini di masa depan) <br><br>  Sekarang untuk masalah yang kurang teknis: <br><br><h4>  8) Menggunakan alat build tunggal </h4><br>  Sejujurnya, masih menjadi misteri bagi saya mengapa merakit seluruh repositori mono menggunakan satu sistem pembangunan umum.  Mengapa tidak membangun javascript dengan Benang, java dengan gradle, Scala dengan sbt, dll?  Jika seseorang mengetahui jawaban untuk pertanyaan ini (tidak menebak atau menyarankan, yaitu tahu), tulis di komentar. <br><br>  Tentu saja, tampak jelas bahwa menggunakan sistem satu bangun lebih baik daripada beberapa yang berbeda.  Tetapi mereka masih memahami bahwa segala hal universal jelas lebih buruk daripada yang khusus, karena  kemungkinan besar hanya memiliki subset dari semua fungsi khusus.  Tetapi lebih buruk lagi, bahasa pemrograman yang berbeda mungkin memiliki paradigma yang berbeda dalam hal perakitan, manajemen ketergantungan, dll., Yang akan sangat sulit untuk dibungkus dalam satu pembungkus umum.  Saya tidak ingin membahas detail, saya akan memberikan satu contoh tentang bazel (lihat detail dalam artikel terpisah) - kami menemukan 5 implementasi independen aturan perakitan javascript untuk bazel dari 5 perusahaan berbeda di GitHub, bersama dengan yang resmi dari Google.  Ini layak dipertimbangkan. <br><br><h4>  9) Pendekatan umum </h4><br>  Menanggapi artikel asli, CTO dari Chef menulis jawabannya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monorepo: tolong lakukan!</a>  .  Dalam tanggapannya, ia berpendapat bahwa "hal utama dalam monorepo adalah membuat Anda berbicara dan membuat kekurangan terlihat."  Maksudnya adalah ketika Anda ingin mengubah API Anda, Anda harus menemukan semua penggunaannya dan mendiskusikan perubahan Anda dengan pengelola potongan kode ini. <br><br>  Jadi pengalaman saya justru sebaliknya.  Jelas bahwa ini sangat tergantung pada budaya rekayasa dalam tim, tetapi saya melihat minus yang kuat dalam pendekatan ini.  Bayangkan Anda menggunakan pendekatan tertentu yang telah melayani Anda dengan setia selama beberapa waktu.  Jadi Anda memutuskan untuk beberapa alasan, memecahkan masalah yang sama, untuk menggunakan metode yang sedikit berbeda, mungkin lebih modern.  Apa kemungkinan bahwa menambahkan pendekatan baru akan melalui tinjauan? <br><br>  Di masa lalu saya, saya menerima komentar beberapa kali seperti "kami sudah memiliki jalur yang terbukti, gunakan itu" dan "jika Anda ingin menerapkan pendekatan baru, perbarui kode di semua 120 tempat di mana pendekatan lama digunakan dan dapatkan pembaruan dari semua tim yang bertanggung jawab untuk potongan kode ini. "  Biasanya antusiasme "inovator" berakhir di sini. <br><br>  Dan berapa banyak, menurut pendapat Anda, akankah biaya untuk menulis layanan baru dalam bahasa pemrograman baru?  Dalam repositori - tidak sama sekali.  Anda membuat repositori baru dan menulis, dan bahkan mengambil sistem build yang paling cocok.  Dan sekarang hal yang sama di monorepositori? <br><br>  Saya mengerti betul bahwa "standardisasi, penggunaan kembali, berbagi kode", tetapi proyek harus dikembangkan.  Menurut pendapat subjektif saya, monorepositori agak mencegah ini. <br><br><h4>  10) Sumber terbuka </h4><br>  Baru-baru ini saya ditanya: “ <b>adakah alat sumber terbuka untuk repositori mono?</b> ” Saya menjawab: “Masalahnya adalah alat repositori mono, anehnya, dikembangkan di dalam repositori mono itu sendiri.  Oleh karena itu, memasukkannya ke sumber terbuka cukup sulit! ” <br><br>  Sebagai contoh, lihat proyek di Github dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin bazel untuk Intellij IDEA</a> .  Google mengembangkannya dalam repositori internal, dan kemudian "memercikkan" bagian-bagiannya di Github dengan hilangnya riwayat komit, tanpa kemampuan untuk mengirim permintaan tarik, dan sebagainya.  Saya tidak berpikir itu open source (di sini adalah contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PR kecil saya</a> , yang ditutup, bukan penggabungan, dan kemudian perubahan muncul di versi berikutnya).  Ngomong-ngomong, fakta ini disebutkan dalam artikel asli bahwa mono-repositori mencegah mereka memposting di sumber terbuka dan membuat komunitas di sekitar proyek.  Saya pikir banyak yang tidak mementingkan argumen ini. <br><br><h4>  Alternatif </h4><br>  Nah, jika kita berbicara tentang apa yang harus dilakukan untuk menghindari semua masalah ini?  Tepat ada satu saran - berusaha keras untuk memiliki repositori sekecil mungkin. <br>  Tapi apa hubungannya monorepositori dengan itu?  Dan meskipun pendekatan ini menghalangi Anda untuk memiliki repositori yang kecil, ringan dan independen. <br><br>  Apa kerugian dari pendekatan polyrepository?  Saya melihat tepat 1: ketidakmampuan untuk melacak siapa yang menjadi konsumen API Anda.  Ini terutama benar dari pendekatan dalam layanan microservices <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"tidak berbagi"</a> , di mana kode tidak meraba-raba antara layanan microser.  (Omong-omong, apakah Anda pikir ada orang yang menggunakan pendekatan ini di mono-repositori?) Sayangnya, masalah ini perlu diselesaikan baik dengan cara organisasi, atau mencoba menggunakan alat penelusuran kode yang mendukung repositori independen (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://sourcegraph.com /</a> ). <br><br>  Bagaimana dengan komentar seperti <b>“kami mencoba polyrepositories, tetapi kemudian kami harus terus-menerus mengimplementasikan fitur dalam beberapa repositori sekaligus, yang melelahkan, dan kami menggabungkan semuanya menjadi satu boiler”</b> ?  Jawabannya sangat sederhana: <b>"jangan bingung masalah pendekatan dengan dekomposisi yang tidak tepat</b> . <b>"</b>  Tidak ada yang mengklaim bahwa repositori harus berisi tepat satu layanan microser dan hanya itu.  Ketika saya menggunakan polyrepository, kami dengan sempurna mengumpulkan satu keluarga dengan layanan microser yang terkait erat dalam satu repositori.  Namun demikian, dengan mempertimbangkan bahwa ada lebih dari 100 layanan, ada lebih dari 20 repositori seperti itu. Hal yang paling penting untuk dipikirkan dalam hal dekomposisi adalah bagaimana layanan ini akan digunakan. <br><br>  Tapi bagaimana dengan argumen tentang versi itu?  Lagi pula, repositori mono memungkinkan Anda untuk tidak memiliki versi dan menyebarkan semuanya dari satu komit!  Pertama, versi adalah yang paling sederhana dari semua masalah yang disuarakan di sini.  Bahkan dalam hal lama seperti maven ada plugin versi maven yang memungkinkan Anda untuk menurunkan versi dengan hanya satu klik.  Dan kedua, dan yang paling penting, apakah perusahaan Anda memiliki aplikasi seluler?  Jika demikian, maka Anda sudah memiliki versi, dan Anda tidak akan mendapatkan apa-apa dari ini! <br><br>  Yah, masih ada argumen utama yang mendukung repositori tunggal - ini memungkinkan Anda untuk melakukan refactoring di seluruh basis kode dalam satu komit!  Bahkan tidak.  Sebagaimana disebutkan dalam artikel asli, karena keterbatasan yang diterapkan penyebaran.  Anda harus selalu ingat bahwa untuk waktu yang lama (durasinya tergantung pada bagaimana proses Anda dibangun), Anda akan memiliki 2 versi layanan yang sama secara paralel.  Misalnya, pada proyek terakhir saya, sistem kami berada di negara ini selama beberapa jam di setiap penyebaran.  Ini mengarah pada fakta bahwa tidak mungkin untuk melakukan refactoring global yang mempengaruhi antarmuka interaksi dalam satu komit, bahkan dalam repositori tunggal. <br><br><h4>  Alih-alih kesimpulan: </h4><br>  Jadi, beberapa rekan yang dihormati dan sedikit yang bekerja di Google, Facebook, dll.  dan datang ke sini untuk mempertahankan repositori mono mereka, saya ingin mengatakan: "Jangan khawatir, Anda melakukan segalanya dengan benar, nikmati penyetelan Anda, yang menghabiskan ratusan ribu atau jutaan jam manusia.  Mereka sudah dibelanjakan, jadi jika Anda tidak menggunakan, maka tidak ada yang mau. " <br><br>  Dan untuk semua orang: <b>"Anda bukan Google, jangan gunakan repositori tunggal!"</b> <br><br>  <b>P.S.</b>  seperti yang dicatat oleh Bobuk yang disegani di podcast <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">radio-T</a> ketika membahas artikel aslinya: “Ada ~ 20 perusahaan di dunia yang dapat menggunakan repositori tunggal.  <b>Sisanya seharusnya tidak mencoba</b> . ” </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436264/">https://habr.com/ru/post/id436264/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436250/index.html">Atasan Pengisap Darah Keluar dari Konteks atau Mengapa Mereka Selalu Gagal</a></li>
<li><a href="../id436254/index.html">Bot untuk Starcraft di Rust, C atau bahasa lainnya</a></li>
<li><a href="../id436256/index.html">Mendapatkan pekerjaan di Jerman akan lebih mudah</a></li>
<li><a href="../id436260/index.html">Kesalahan dan perangkap Startups dalam mematenkan IP mereka</a></li>
<li><a href="../id436262/index.html">* Pembaruan Ethereum "Constantinople" ditunda karena kerentanan potensial ditemukan pada saat terakhir</a></li>
<li><a href="../id436266/index.html">Penskalaan Ekstrim di Alibaba JDK</a></li>
<li><a href="../id436268/index.html">Kami mengumpulkan setumpuk lengkap</a></li>
<li><a href="../id436270/index.html">35% dari penonton Runet tidak menggunakan komputer untuk Internet sama sekali</a></li>
<li><a href="../id436272/index.html">Pemrograman Visual untuk Sonoff Basic</a></li>
<li><a href="../id436274/index.html">Aplikasi seluler untuk pendaftaran kecelakaan sedang dibuat di Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>