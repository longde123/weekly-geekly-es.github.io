<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏾 🙌🏾 🤷🏻 最小的自动化。 第1.1部分。 虚拟化基础 👊🏼 🙎🏼 💇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="上一篇文章介绍了虚拟化网络的体系结构，底层覆盖，VM之间的软件包路径等。 
 Roman Gorge受到她的启发，因此决定撰写有关虚拟化的评论文章。 

 在本文中，我们将涉及（或尝试涉及）以下问题：网络功能的虚拟化实际上是如何发生的，用于启动和管理VM的主要产品的后端是如何实现的，以及虚拟交换的工...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>最小的自动化。 第1.1部分。 虚拟化基础</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467801/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章介绍</a>了虚拟化网络的体系结构，底层覆盖，VM之间的软件包路径等。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Roman Gorge</a>受到她的启发，因此决定撰写有关虚拟化的评论文章。 <br><br> 在本文中，我们将涉及（或尝试涉及）以下问题：网络功能的虚拟化实际上是如何发生的，用于启动和管理VM的主要产品的后端是如何实现的，以及虚拟交换的工作方式（OVS和Linux桥接器）。 <br><br> 虚拟化的主题是广泛而深入的，不可能解释虚拟机管理程序的所有工作细节（并且没有必要）。 我们将把自己的知识限制在理解任何虚拟化解决方案（不一定是电信公司）的操作所必需的最少知识上。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6a7/8ec/aa6/6a78ecaa6f26c867f0a37f010511ef7a.png" width="800"></a> <br><br><h1> 目录内容 </h1><br><ul><li>  <b>虚拟化简介和简要历史</b> </li><li>  <b>虚拟资源的类型-计算，存储，网络</b> </li><li>  <b>虚拟切换</b> </li><li>  <b>虚拟化工具-libvirt，virsh等</b> </li><li>  <b>结论</b> </li></ul><br><hr><br><br><a name="habracut"></a><br><br><h1> 虚拟化简介和简要历史 </h1><br><br> 现代虚拟化技术的历史可以追溯到1999年，当时年轻的VMware公司发布了一款名为VMware Workstation的产品。 这是用于桌面/客户端应用程序的虚拟化产品。 服务器端虚拟化后来以ESX Server产品的形式出现，该产品后来演变为ESXi（我的意思是集成的）-这是与IT和Telco共同用作服务器应用程序管理程序的同一产品。 <br><br> 在开源方面，有两个主要项目将虚拟化引入了Linux： <br><ul><li>  KVM（基于内核的虚拟机）是一个Linux内核模块，它允许内核充当管理程序（创建启动和管理VM的必要基础结构）。 它是在2007年的内核版本2.6.20中添加的。 </li><li>  QEMU（快速仿真器）-直接仿真虚拟机的硬件（CPU，磁盘，RAM，包括USB端口在内的任何东西），并与KVM结合使用以实现几乎“本机”的性能。 </li></ul><br><br><blockquote> 实际上，目前，KE的所有功能都可以在QEMU中使用，但这并不重要，因为大多数Linux虚拟化用户并不直接使用KVM / QEMU，而是通过至少一个抽象级别来访问它们，但以后会更多。 <br></blockquote><br><br> 如今，VMware ESXi和Linux QEMU / KVM是主导市场的两个主要管理程序。 它们还是两种不同类型的管理程序的代表： <br><ul><li> 类型1-虚拟机管理程序直接在硬件（裸机）上运行。 这是VMware ESXi，Linux KVM，Hyper-V </li><li> 类型2-系统管理程序在主机OS（操作系统）内部启动。 这是VMware Workstation或Oracle VirtualBox。 </li></ul><br><br> 关于什么更好和什么不好的讨论不在本文的讨论范围之内。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d74/dfe/fa6/d74dfefa6a9c07a43bca6f4a07db1a3d.gif" width="600"><br><br> 钢铁生产商还必须尽自己的一份努力，以确保表现令人满意。 <br><br> 也许最重要和使用最广泛的是Intel VT（虚拟化技术），这是Intel为x86处理器开发的一组扩展，用于虚拟机管理程序的有效运行（在某些情况下是必需的，例如，如果不打开VT，则KVM将无法工作-x，如果没有它，系统管理程序将被迫从事纯软件仿真，而无需硬件加速。 <br> 其中最著名的两个扩展是VT-x和VT-d。 第一个对提高虚拟化期间的CPU性能非常重要，因为它为某些功能提供了硬件支持（VT-x 99.9％Guest OS代码直接在物理处理器上执行，仅在最必要的情况下才输出输出），第二个是直接连接物理设备到虚拟机（对于前向虚拟功能（VF）SRIOV，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">必须启用</a> VT-d）。 <br><br> 下一个重要概念是完全虚拟化和半虚拟化之间的区别。 <br> 完全虚拟化是好的，它允许您在任何处理器上运行任何操作系统，但是效率极低，绝对不适合高负载系统。 <br> 简而言之，准虚拟化是指Guest OS知道其在虚拟环境中运行并与虚拟机管理程序合作以实现更高的效率。 即，出现来宾管理程序界面。 <br> 当今使用的绝大多数操作系统都支持半虚拟化-在Linux内核中，这是从2.6.20版内核开始出现的。 <br><br> 为了使虚拟机正常工作，不仅需要虚拟处理器（vCPU）和虚拟内存（RAM）；还需要仿真PCI设备。 也就是说，实际上，需要一组驱动程序来管理虚拟网络接口，磁盘等。 <br> 在Linux KVM虚拟机管理程序中，该任务是通过实现<b>virtio</b> （解决方案）解决的， <b>virtio</b>是用于开发和使用虚拟化I / O设备的框架。 <br>  Virtio是附加的抽象级别，它使您可以在半虚拟化的虚拟机管理程序中模拟各种I / O设备，从而为虚拟机一侧提供统一的标准化接口。 这使您可以将virtio驱动程序代码重用于各种固有设备。  Virtio包括： <br><ul><li> 前端驱动程序-虚拟机中的内容 </li><li> 后端驱动程序-虚拟机管理程序中的功能 </li><li> 传输驱动程序-连接后端和前端的内容 </li></ul><br> 通过这种模块化，您可以在不影响虚拟机驱动程序的情况下更改虚拟机管理程序中使用的技术（此刻对于网络加速技术和整个Cloud解决方案非常重要，但稍后会介绍更多信息）。 <br> 也就是说，当来宾操作系统“知道”它在虚拟环境中运行时，存在来宾-管理程序连接。 <br><blockquote> 如果您曾经在RFP中写过一个问题或在RFP中回答过一个问题，“您的产品是否支持virtio？” 它只是要支持前端virtio驱动程序。 <br></blockquote><br><br><h1> 虚拟资源的类型-计算，存储，网络 </h1><br> 虚拟机由什么组成？ <br> 虚拟资源有三种主要类型： <br><br><ul><li> 计算-处理器和RAM </li><li> 存储-虚拟机系统磁盘和块存储 </li><li> 网络-网卡和输入/输出设备 </li></ul><br><br><hr><br><br><h1> 计算 </h1><br><br><h2> 中央处理器 </h2><br> 从理论上讲，QEMU能够模拟任何类型的处理器及其相应的标志和功能;在实践中，它们可以使用主机模型并在将标志传输到Guest OS之前先关闭它们的标志，或者使用命名模型并按点打开/关闭标志。 <br><br> 默认情况下，QEMU将模拟来宾OS识别为QEMU虚拟CPU的处理器。 这不是最佳处理器类型，尤其是在虚拟机中运行的应用程序使用CPU标志进行工作时。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了解有关QEMU中不同CPU型号的更多信息</a> 。 <br><br>  QEMU / KVM还允许您控制处理器拓扑，线程数，缓存大小，将vCPU绑定到物理核心等等。 <br><br> 对于虚拟机是否需要此操作取决于在Guest OS上运行的应用程序的类型。 例如，众所周知的事实是，对于处理具有高PPS的数据包的应用程序，重要的是进行<b>CPU固定</b> ，即，不允许将物理处理器转移到其他虚拟机。 <br><br><h2> 记忆体 </h2><br> 接下来的是RAM。 从主机操作系统的角度来看，使用QEMU / KVM启动的虚拟机与在操作系统用户空间中运行的任何其他进程没有什么不同。 相应地，将虚拟机分配内存的过程由内核Host OS中的相同调用执行，就像您启动了例如Chrome浏览器一样。 <br><br><blockquote> 在继续介绍虚拟机中RAM的故事之前，您需要讲解并解释术语<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NUMA-</a></b>非统一内存访问。 <br> 现代物理服务器的体系结构涉及两个或多个处理器（CPU）的存在，并且与之相关联的是随机存取存储器（RAM）。 这样一堆处理器+内存称为一个节点或节点。 各种NUMA节点之间的通信通过特殊的总线<b>-QPI</b> （QuickPath互连）进行 <br><br> 本地NUMA节点被分配-当操作系统中运行的进程使用位于同一NUMA节点中的处理器和RAM时，远程NUMA节点-当操作系统中运行的进程使用位于不同NUMA节点中的处理器和RAM时，也就是说，对于处理器和内存的交互，需要通过QPI总线进行数据传输。 <br></blockquote><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea3/360/7e9/ea33607e91282db8bda346d7f63cf9fd.png" width="600"><br><br> 从虚拟机的角度来看，在启动虚拟机时已经为它分配了内存，但实际上并非如此，并且内核Host OS会为Guest OS中的应用程序请求额外的内存向QEMU / KVM进程分配新的内存部分（尽管可能还会有如果您直接指定QEMU / KVM在启动时直接将所有内存分配给虚拟机，则为例外。 <br><br> 内存不是按字节分配的，而是按一定大小的<b>页面</b>分配的。 页面大小是可配置的，理论上可以是任何大小，但实际上大小为4kB（默认），2MB和1GB。 最后两个大小称为<b>HugePages</b> ，通常用于为内存密集型虚拟机分配内存。 在<b>转换后备缓冲区</b> （ <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TLB</a></b> ）中查找页面的虚拟地址与物理内存之间匹配的过程中使用HugePages的原因，而后者又受到限制，并且仅存储有关最后使用的页面的信息。 如果在TLB中没有有关所需页面的信息，则会发生称为未<b>命中TLB的</b>过程，您需要使用主机操作系统处理器来查找与所需页面相对应的物理存储单元。 <br><br> 该过程效率低下且速度慢，因此使用了较少的较大尺寸的页面。 <br>  QEMU / KVM还允许您模拟来宾操作系统的各种NUMA拓扑，仅从特定的NUMA节点主机操作系统获取虚拟机的内存，等等。 最常见的做法是从分配给虚拟机的处理器本地的NUMA节点获取虚拟机的内存。 原因是希望避免在连接物理服务器CPU插槽的<b>QPI</b>总线上造成不必要的负载（当然，如果您的服务器有2个或更多插槽，这是合乎逻辑的）。 <br><br><hr><br><br><h1> 贮藏 </h1><br> 如您所知，RAM被称为操作内存，因为它的内容在关闭电源或重新引导操作系统时就会消失。 要存储信息，您需要持久性存储设备（ROM）或<b>持久性存储</b> 。 <br> 持久性存储主要有两种类型： <br><ul><li> 块存储-一块磁盘空间，可用于安装文件系统和创建分区。 如果不客气，那么您可以将其当作普通磁盘使用。 </li><li> 对象存储-信息只能保存为对象（文件），可通过HTTP / HTTPS访问。 对象存储的典型示例是AWS S3或Dropbox。 </li></ul><br><br> 虚拟机需要<b>持久性存储</b> ，但是，如果虚拟机“驻留”在主机OS RAM中，该怎么做？ 简而言之，对虚拟磁盘控制器的任何来宾OS调用都会被QEMU / KVM拦截，并转换为主机OS物理磁盘上的记录。 该方法效率低下，因此，在此以及网络设备中，使用virtio驱动程序来代替完全模拟IDE或iSCSI设备。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关此内容的更多信息。 因此，虚拟机通过virtio驱动程序访问其虚拟磁盘，然后QEMU / KVM将传输的信息写入物理磁盘。 重要的是要了解，在主机操作系统中，可以将磁盘后端实现为CEPH，NFS或iSCSI架子。 <br><br> 模拟持久性存储的最简单方法是将Host OS某个目录中的文件用作虚拟机的磁盘空间。  QEMU / KVM支持这种文件的许多不同格式-raw，vdi，vmdk等。 但是，使用最广泛的格式是<b>qcow2</b> （QEMU写入时复制版本2）。 通常，以某种方式，qcow2是一个结构化文件，没有任何操作系统。 大量虚拟机以qcow2-映像（映像）的形式分发，并且是虚拟机系统磁盘的副本，以qcow2格式打包。 这有几个优点-qcow2编码比字节到字节磁盘的原始副本占用的空间少得多，QEMU / KVM可以调整qcow2文件的大小，这意味着可以更改虚拟机磁盘的大小，还支持AES qcow2加密（这很有意义，因为虚拟机的映像可能包含知识产权）。 <br><br> 此外，当虚拟机启动时，QEMU / KVM使用qcow2文件作为系统磁盘（尽管这也是一项有趣的任务，但这里省略了加载虚拟机的过程），并且虚拟机具有通过virtio读取数据/将数据写入qcow2文件的能力。司机。 因此，获取虚拟机映像的过程是可行的，因为在任何时候qcow2文件都包含虚拟机系统磁盘的完整副本，并且该映像可用于备份，传输到其他主机等。 <br><br> 通常，此qcow2文件将在来宾操作系统中定义为<i>/ dev / vda设备</i> ，并且来宾操作系统会将磁盘空间划分为多个分区并安装文件系统。 同样，由QEMU / KVM作为<i>/ dev / vdX</i>设备连接的以下qcow2文件可以用作虚拟机中的<b>块存储</b>来存储信息（这正是Openstack Cinder组件的工作方式）。 <br><hr><br><br><h1> 联播网 </h1><br> 在我们的虚拟资源列表上，最后一个是网卡和I / O设备。 虚拟机像物理主机一样，需要<b>PCI / PCIe总线</b>来连接I / O设备。  QEMU / KVM能够仿真不同类型的芯片组-q35或i440fx（第一个支持PCIe，第二个支持传统PCI），以及各种PCI拓扑，例如，为NUMA节点来宾OS创建单独的PCI总线（PCI扩展器总线）。 <br><br> 创建PCI / PCIe总线后，必须将I / O设备连接到它。 通常，它可以是从网卡到物理GPU的任何东西。 当然，还有完全虚拟化的网卡（例如，完全e1000虚拟化的接口）和半虚拟化的网卡（例如，virtio）或物理NIC。 最后一个选项用于需要获得线速数据包速率的数据平面虚拟机-路由器，防火墙等。 <br><br> 这里有两种主要方法<b>-PCI直通</b>和<b>SR-IOV</b> 。 它们之间的主要区别在于，对于PCI-PT，该驱动程序仅在Guest OS内部使用，而对于SRIOV，则使用Host OS驱动程序（用于创建<b>VF-虚拟功能</b> ）和Guest OS驱动程序来控制SR-IOV VF。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">瞻博网络撰写了</a>有关PCI-PT和SRIOV的出色细节。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/380/fb7/ff1380fb7061d5294514b79b4a368cfb.png" width="600"><br><br><blockquote> 为了澄清起见，值得注意的是PCI直通和SR-IOV是互补技术。  SR-IOV正在将物理功能划分为虚拟功能。 这是在主机OS级别完成的。 同时，主机操作系统将虚拟功能视为另一个PCI / PCIe设备。 他接下来对他们做什么并不重要。 <br><br>  PCI-PT是一种用于在来宾操作系统中转发任何主机操作系统PCI设备的机制，包括由SR-IOV设备创建的虚拟功能 <br></blockquote><br><br> 因此，我们检查了虚拟资源的主要类型，下一步是了解虚拟机如何通过网络与外界通信。 <br><hr><br><br><h1> 虚拟切换 </h1><br><br> 如果有一个虚拟机，并且它具有一个虚拟接口，那么显然会出现将数据包从一个VM传输到另一个VM的问题。 在基于Linux的虚拟机管理程序（例如KVM）中，可以使用Linux桥接器解决此问题，但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Open vSwitch</a> （OVS）项目已获得广泛接受。 <br> 有几种核心功能使OVS能够广泛传播，并成为许多云计算平台（例如Openstack）和虚拟化解决方案使用的事实上的核心数据包交换方法。 <br><ul><li> 网络状态传输-在虚拟机管理程序之间迁移VM时，任务是传输ACL，QoS，L2 / L3转发表等。  OVS可以做到。 </li><li> 内核和用户空间中数据包传输机制（数据路径）的实现 </li><li>  CUPS（控制/用户平面分离）架构-允许您将数据包处理功能转移到专用芯片组（例如，Broadcom和Marvell芯片组可以做到），并通过控制平面OVS对其进行控制。 </li><li> 支持远程流量控制方法-OpenFlow协议（hi，SDN）。 </li></ul><br><br> 乍一看，OVS架构看上去很吓人，但是乍一看。 <br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/18f/4fa/e1e18f4fa99d66a99a4da3c06e1df33a.png" width="600"><br><br> 要使用OVS，您需要了解以下内容： <br><ul><li>  <b>数据路径</b> -包在这里处理。 类比是铁开关的开关结构。 数据路径包括已在数据路径中编程的接收数据包，处理报头，流表中的匹配项。 如果OVS在内核中运行，它将作为内核模块实现。 如果OVS在用户空间中运行，则这是用户空间Linux中的一个过程。 </li><li>  <b>vswitchd</b>和<b>ovsdb</b>是用户空间中的守护程序，它直接实现交换机的功能，存储配置，设置流向数据路径并对其进行编程。 </li><li>  OVS设置和故障排除工具包<b>-ovs-vsctl，ovs-dpctl，ovs-ofctl，ovs-appctl</b> 。 在ovsdb中注册端口配置，注册应切换到哪个流，收集统计信息等等所需的全部操作。 好人<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为此写了一篇文章</a> 。 </li></ul><br><br>  <b>虚拟机的网络设备如何以OVS结尾？</b> <br><br> 为了解决此问题，我们需要以某种方式将位于操作系统用户空间中的虚拟接口与位于内核中的数据路径OVS互连起来。 <br><br> 在Linux操作系统中，数据包通过两个特殊接口在内核和用户空间进程之间传输。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 两个接口都使用向/从特殊文件写入/读取数据包来将数据包从用户空间进程传输到内核，反之亦然-文件描述符（FD）（如果数据路径OVS位于内核中，这是虚拟交换性能较差的原因之一-每个数据包）需要通过FD进行写入/读取） </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TUN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（隧道）-在L3模式下工作的设备，允许您将IP数据包写入FD或从FD读取。</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（网络分接头）-与tun接口相同+可以对以太网帧执行操作，即 </font><font style="vertical-align: inherit;">在L2模式下工作。</font></font></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a2/3fc/fc8/5a23fcfc86e0c6cbfdf8dc80cc562bbf.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是为什么当虚拟机在Host OS中运行时，您可以使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ip链接</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ifconfig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令查看创建的TAP接口的原因</font><font style="vertical-align: inherit;">-这是virtio的“响应”部分，在内核Host OS中是“可见”的。</font><font style="vertical-align: inherit;">还值得注意的是，TAP接口与虚拟机中的virtio接口具有相同的MAC地址。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ovs-vsctl命令</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将TAP接口添加到</font><i><font style="vertical-align: inherit;">OVS-</font></i><font style="vertical-align: inherit;">然后，由OVS切换到TAP接口的任何程序包都将通过文件描述符传输到虚拟机。</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建虚拟机的实际过程可能有所不同，即 </font><font style="vertical-align: inherit;">首先，您可以创建一个OVS桥，然后告诉虚拟机创建连接到该OVS的接口，反之亦然。</font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，如果我们需要能够在同一虚拟机管理程序上运行的两个或多个虚拟机之间传输数据包，我们只需要创建一个OVS桥并使用ovs-vsctl命令向其添加TAP接口。可以轻松地搜索需要哪些团队。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚拟机管理程序上可能有多个OVS桥接器，例如，这就是Openstack Neutron的工作方式，或者虚拟机可以位于不同的命名空间中以实现多租户。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果虚拟机位于不同的OVS桥接器中？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了解决这个问题，还有另一种工具</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-veth对</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Veth对可以表示为通过电缆连接的一对网络接口-一切“飞”入一个接口，从另一个“飞”入。</font><font style="vertical-align: inherit;">Veth对用于将多个OVS桥接器或Linux桥接器彼此连接。</font><font style="vertical-align: inherit;">另一个重要的一点是，veth对的一部分可以位于不同的命名空间Linux OS中，也就是说，veth对还可以用于在网络级别上相互通信命名空间。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 虚拟化工具-libvirt，virsh等 </font></font></h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在前面的章节中，我们研究了虚拟化的理论基础，在这一章中，我们将讨论可直接用于用户的工具，这些工具可用于在KVM虚拟机管理程序上启动和更改虚拟机。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们详细介绍三个主要组件，它们涵盖了虚拟机所有类型操作的90％：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> libvirt </font></font></li><li> virsh CLI </li><li> virt-install </li></ul><br><br><blockquote> ,      CLI-,    , ,     qemu_system_x86_64    virt manager,    .      Cloud-, Openstack, ,    libvirt. <br></blockquote><br><br><h2> libvirt </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirt是一个大型开源项目，它开发了用于管理虚拟机管理程序的一组工具和驱动程序。它不仅支持QEMU / KVM，还支持ESXi，LXC等。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其流行的主要原因是用于通过一组XML文件进行交互的结构化且直观的界面，以及能够通过API进行自动化的功能。应当注意，libvirt并未描述虚拟机监控程序的所有可能功能，它只是</font><font style="vertical-align: inherit;">从项目参与者的角度</font><font style="vertical-align: inherit;">提供了一个方便的界面，用于使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有用</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的虚拟机监控程序功能</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是的，libvirt是当今虚拟化世界中的事实上的标准。只需</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用libvirt </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">的应用程序列表即可</font></a><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6f/115/f2f/b6f115f2f06f3fe06ee4727ec121c865.png" width="700"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于libvirt的好消息是，所有必需的软件包都已预先安装在所有最常用的主机操作系统（Ubuntu，CentOS和RHEL）中，因此您很有可能不必编译必需的软件包并编译libvirt。</font><font style="vertical-align: inherit;">在最坏的情况下，您将必须使用适当的批处理安装程序（apt，yum等）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始安装和启动后，libvirt默认会创建Linux桥virbr0及其最小配置。</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 例如，这就是为什么在安装Ubuntu Server时，会在ifconfig Linux bridge virbr0命令的输出中看到的原因-这是运行libvirtd守护程序的结果 </font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该Linux桥接器不会连接到任何物理接口，但是，它可用于在单个虚拟机管理程序内通信虚拟机。</font><font style="vertical-align: inherit;">Libvirt当然可以与OVS一起使用，但是，为此，用户必须使用适当的OVS命令独立创建OVS桥。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建虚拟机所需的任何虚拟资源（计算，网络，存储）在libvirt中均表示为对象。</font><font style="vertical-align: inherit;">一组不同的XML文件负责描述和创建这些对象的过程。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">详细描述创建虚拟网络和虚拟存储的过程没有多大意义，因为libvirt文档中对该应用程序进行了很好的描述：</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">联网</font></font></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">贮藏</a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在libvirt术语中，具有所有连接的PCI设备的虚拟机本身称为域。这也是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirt内部的一个对象</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，由一个单独的XML文件描述。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">严格来说，此XML文件是具有所有虚拟资源（RAM，处理器，网络设备，磁盘等）的虚拟机。通常，此XML文件称为libvirt XML或转储XML。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不太可能会有人了解libvirt XML的所有参数，但是，有文档时就不需要这样做。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，用于Ubuntu Desktop Guest OS的libvirt XML将非常简单-40至50行。</font><font style="vertical-align: inherit;">由于在libvirt XML（NUMA拓扑，CPU拓扑，CPU固定等）中还描述了所有性能优化，因此对于网络功能，libvirt XML可能非常复杂并且包含数百行。</font><font style="vertical-align: inherit;">任何将其软件作为虚拟机发布的网络设备制造商都推荐了libvirt XML的示例。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virsh CLI </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virsh实用程序是用于管理libvirt的“本地”命令行。</font><font style="vertical-align: inherit;">它的主要目的是管理描述为XML文件的libvirt对象。</font><font style="vertical-align: inherit;">典型示例是开始，停止，定义，销毁等。</font><font style="vertical-align: inherit;">也就是说，对象的生命周期-生命周期管理。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">libvirt</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档中也提供了所有virsh命令和标志的描述</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 安装virt </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于与libvirt进行交互的另一个实用程序。主要优点之一是您不必处理XML格式，而可以使用virsh-install中可用的标志。第二个重点是网络上的大量示例和信息。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，无论使用哪种实用程序，最终都是由libvirt控制虚拟机管理程序，因此了解其操作的架构和原理很重要。</font></font><br><hr><br><br><h1> 结论 </h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中，我们研究了使用虚拟机所需的最少理论知识。</font><font style="vertical-align: inherit;">我故意不给出命令的实际示例和结论，因为可以在Web上找到尽可能多的示例，并且我没有设定编写“循序渐进指南”的任务。</font><font style="vertical-align: inherit;">如果您对特定主题或技术感兴趣，请留下您的评论并提出问题。</font></font><br><hr><br><br><h1> 有用的链接 </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解QEMU设备</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KVM / SR-IOV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li></ul><br><hr><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 谢谢啦 </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我的同事，虚拟网络开发专家</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Alexander Shalimov</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">用于评论和编辑。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我的同事，虚拟化领域专家Yevgeny Yakovlev提出了意见和更正。 </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467801/">https://habr.com/ru/post/zh-CN467801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467789/index.html">Java 13刚刚到来，ZGC已开始共享内存，CDS本身可以记住类和其他技术奇迹</a></li>
<li><a href="../zh-CN467791/index.html">Google Data Studio中的页面滚动分析</a></li>
<li><a href="../zh-CN467793/index.html">单人互联网公司的无聊技术堆栈</a></li>
<li><a href="../zh-CN467795/index.html">关于加密货币和国家法规的说明</a></li>
<li><a href="../zh-CN467797/index.html">“为……而笑”：为什么您需要没有“战斗”应用程序的软件工具</a></li>
<li><a href="../zh-CN467803/index.html">python + matplotlib中的自定义物理交互的基本模拟</a></li>
<li><a href="../zh-CN467807/index.html">在俄罗斯买卖加密货币：方法，合法化，风险</a></li>
<li><a href="../zh-CN467811/index.html">架构和编程Fairchild Channel F</a></li>
<li><a href="../zh-CN467813/index.html">审查FSTEC第17阶的变更</a></li>
<li><a href="../zh-CN467817/index.html">关于生成设计模式的一些知识</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>