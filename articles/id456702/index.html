<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™†ğŸ½ ğŸ¥¢ â« Keamanan ponsel OAuth 2.0 ğŸ‘¸ğŸ¿ ğŸ‡ğŸ¿ ğŸ‘©ğŸ»â€ğŸ³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Popularitas aplikasi seluler terus meningkat. Begitu juga protokol OAuth 2.0 pada aplikasi seluler. Itu tidak cukup untuk menerapkan standar seperti m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Keamanan ponsel OAuth 2.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/456702/"><img src="https://habrastorage.org/getpro/habr/post_images/def/8b1/158/def8b1158655952902bf05be9fb7f308.jpg" alt="gambar"><br><br>  Popularitas aplikasi seluler terus meningkat.  Begitu juga protokol OAuth 2.0 pada aplikasi seluler.  Itu tidak cukup untuk menerapkan standar seperti membuat protokol OAuth 2.0 aman di sana.  Seseorang perlu mempertimbangkan spesifikasi aplikasi seluler dan menerapkan beberapa mekanisme keamanan tambahan. <br><br>  Pada artikel ini, saya ingin berbagi konsep serangan OAuth 2.0 seluler dan mekanisme keamanan yang digunakan untuk mencegah masalah tersebut.  Konsep yang dijelaskan bukan hal baru tetapi ada kekurangan informasi terstruktur tentang topik ini.  Tujuan utama artikel ini adalah untuk mengisi celah ini. <br><a name="habracut"></a><br><h1>  OAuth 2.0 sifat dan tujuan </h1><br>  OAuth 2.0 adalah protokol <i>otorisasi</i> yang menjelaskan cara layanan klien untuk mendapatkan akses yang aman ke sumber daya pengguna pada penyedia layanan.  Berkat OAuth 2.0, pengguna tidak perlu memasukkan kata sandi di luar penyedia layanan: seluruh proses dikurangi dengan mengklik tombol "Saya setuju untuk memberikan akses ke ...". <br><br>  Penyedia adalah layanan yang memiliki data pengguna dan, dengan izin pengguna, memberikan layanan pihak ketiga (klien) dengan akses yang aman ke data ini.  Klien adalah aplikasi yang ingin menyimpan data pengguna oleh penyedia. <br><br>  Segera setelah protokol OAuth 2.0 dirilis, protokol ini diadaptasi untuk <i>otentikasi</i> , meskipun tidak dimaksudkan untuk itu.  Menggunakan OAuth 2.0 untuk otentikasi menggeser vektor serangan dari data yang disimpan di penyedia layanan ke akun pengguna layanan klien. <br><br>  Tetapi otentikasi hanyalah permulaan.  Pada saat aplikasi seluler dan pemuliaan konversi, mengakses aplikasi hanya dengan satu tombol terdengar bagus.  Pengembang mengadaptasi OAuth 2.0 untuk penggunaan mobile.  Tentu saja, tidak banyak yang khawatir tentang keamanan dan spesifikasi aplikasi seluler: zap dan masuk ke dalam produksi mereka pergi!  Kemudian lagi, OAuth 2.0 tidak berfungsi dengan baik di luar aplikasi web: ada masalah yang sama di aplikasi seluler dan desktop. <br><br>  Jadi, mari kita cari tahu cara membuat ponsel OAuth 2.0 aman. <br><br><h1>  Bagaimana cara kerjanya? </h1><br>  Ada dua masalah keamanan OAuth 2.0 seluler utama: <br><br><ol><li>  Klien tidak tepercaya.  Beberapa aplikasi seluler tidak memiliki backend untuk OAuth 2.0, sehingga bagian klien dari aliran protokol berjalan di perangkat seluler. <br></li><li>  Pengalihan dari browser ke aplikasi seluler berperilaku berbeda tergantung pada pengaturan sistem, urutan aplikasi yang diinstal dan sihir lainnya. <br></li></ol><br>  Mari kita lihat lebih dalam masalah ini. <br><br><h4>  Aplikasi seluler adalah klien publik </h4><br>  Untuk memahami akar dan konsekuensi dari masalah pertama, mari kita lihat bagaimana OAuth 2.0 bekerja dalam kasus interaksi server-ke-server dan kemudian membandingkannya dengan OAuth 2.0 dalam hal interaksi klien-ke-server. <br><br>  Dalam kedua kasus, semuanya dimulai dengan register layanan klien pada layanan provider dan menerima <code>client_id</code> dan <code>,</code> dalam beberapa kasus <code>, client_secret. client_id</code>  <code>, client_secret. client_id</code> adalah nilai publik, dan itu diperlukan untuk identifikasi layanan klien yang bertentangan dengan nilai <code>client_secret</code> , yang bersifat pribadi.  Anda dapat membaca lebih lanjut tentang proses pendaftaran di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 7591</a> . <br><br>  Skema di bawah ini menunjukkan cara OAuth 2.0 beroperasi dalam hal interaksi server-ke-server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/689/61f/9a668961fd270118492bec6134a1aca9.png"><br>  <i>Asal gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  Protokol OAuth 2.0 dapat dibagi menjadi tiga langkah utama: <br><br><ol><li>  [langkah AC] Terima <code>code</code> <code>authorization_code</code> (selanjutnya, <code>code</code> ). <br></li><li>  [langkah DE] Pertukarkan <code>code</code> ke <code>access_token</code> . <br></li><li>  Dapatkan sumber daya melalui <code>access_token</code> . </li></ol><br><br>  Mari kita uraikan proses mendapatkan nilai <code>code</code> : <br><br><ol><li>  [Langkah A] Klien mengalihkan pengguna ke penyedia layanan. <br></li><li>  [Langkah B] Penyedia layanan meminta izin dari pengguna untuk memberikan data kepada klien (panah B ke atas).  Pengguna menyediakan akses data (panah B ke kanan). <br></li><li>  [Langkah C] Penyedia layanan mengembalikan <code>code</code> ke browser pengguna yang mengalihkan <code>code</code> ke klien. <br></li></ol><br>  Mari kita bicara lebih banyak tentang proses mendapatkan <code>access_token</code> : <br><br><ol><li>  [Langkah D] Server klien mengirimkan permintaan untuk <code>access_token</code> .  <code>Code</code> , <code>client_secret</code> dan <code>redirect_uri</code> termasuk dalam permintaan. <br></li><li>  [Langkah E] Dalam kasus <code>code</code> valid, <code>client_secret</code> dan <code>redirect_uri</code> , <code>access_token</code> disediakan. <br></li></ol><br>  Permintaan untuk <code>access_token</code> dilakukan sesuai dengan skema server-ke-server: oleh karena itu, secara umum, penyerang harus meretas server layanan klien atau server penyedia layanan untuk mencuri <code>access_token</code> . <br><br>  Sekarang mari kita lihat skema mobile OAuth 2.0 tanpa backend (interaksi client-to-server). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>Asal gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Skema utama dibagi menjadi beberapa langkah utama yang sama: <br><br><ol><li>  [langkah 1-4 dalam gambar] Dapatkan <code>code</code> . </li><li>  [langkah 5-6 dalam gambar] Pertukarkan <code>code</code> ke <code>access_token</code> </li><li>  Dapatkan akses sumber daya melalui <code>access_token</code> </li></ol><br>  Namun, dalam hal ini aplikasi seluler juga memiliki fungsi server;  Oleh karena itu, <code>client_secret</code> akan tertanam ke dalam aplikasi.  Akibatnya, <code>client_secret</code> tidak dapat disembunyikan dari penyerang di perangkat seluler.  <code>client_secret</code> dapat diekstraksi dengan dua cara: dengan menganalisis lalu lintas aplikasi ke server atau dengan rekayasa terbalik.  Keduanya dapat dengan mudah diimplementasikan, dan itulah sebabnya <code>client_secret</code> tidak berguna di perangkat seluler. <br><br>  Anda mungkin bertanya: "Mengapa kita tidak segera mendapatkan <code>access_token</code> ?"  Anda mungkin berpikir bahwa langkah tambahan ini tidak perlu.  Selain itu ada skema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hibah Implisit</a> yang memungkinkan klien untuk menerima <code>access_token</code> segera.  Meskipun, dalam beberapa kasus, ini dapat digunakan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implisit Grant</a> tidak akan berfungsi untuk ponsel aman OAuth 2.0. <br><br><h4>  Pengalihan pada perangkat seluler </h4><br>  Secara umum, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skema URI Khusus</a> dan mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppLink</a> digunakan untuk pengalihan browser-ke-aplikasi.  Tidak satu pun dari mekanisme ini yang dapat seaman peramban mengarahkan sendiri. <br><br>  <i>Skema URI khusus</i> (atau tautan dalam) digunakan dengan cara berikut: pengembang menentukan skema aplikasi sebelum penyebaran.  Skema dapat berupa apa saja, dan satu perangkat dapat memiliki beberapa aplikasi dengan skema yang sama. <br><br>  Itu membuat segalanya lebih mudah ketika setiap skema pada perangkat sesuai dengan satu aplikasi.  Tetapi bagaimana jika dua aplikasi mendaftarkan skema yang sama pada satu perangkat?  Bagaimana sistem operasi memutuskan aplikasi mana yang akan dibuka ketika dihubungi melalui Skema URI Khusus?  Android akan menampilkan jendela dengan pilihan aplikasi dan tautan untuk diikuti.  iOS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak memiliki prosedur untuk ini</a> dan, oleh karena itu, aplikasi mana pun dapat dibuka.  Bagaimanapun, penyerang mendapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesempatan untuk mencegat kode atau access_token</a> . <br><br>  Tidak seperti Skema URI Kustom, <i>AppLink</i> menjamin untuk membuka aplikasi yang tepat, tetapi mekanisme ini memiliki beberapa kelemahan: <br><br><ol><li>  Setiap klien layanan harus menjalani <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prosedur verifikasi</a> . <br></li><li>  Pengguna Android dapat mematikan AppLink untuk aplikasi tertentu dalam pengaturan. <br></li><li>  Versi Android yang lebih lama dari 6.0 dan versi iOS yang lebih tua dari 9.0 tidak mendukung AppLink. <br></li></ol><br>  Semua kekurangan AppLink ini meningkatkan kurva belajar untuk klien layanan potensial dan dapat mengakibatkan kegagalan pengguna OAuth 2.0 dalam beberapa keadaan.  Itu sebabnya banyak pengembang tidak memilih mekanisme AppLink sebagai pengganti peralihan browser dalam protokol OAuth 2.0. <br><br><h1>  Oke, apa yang bisa diserang? </h1><br>  Masalah Mobile OAuth 2.0 telah menciptakan beberapa serangan spesifik.  Mari kita lihat siapa mereka dan bagaimana mereka bekerja. <br><br><a name="1"></a><h4>  Serangan Intersepsi Kode Otorisasi </h4><br>  Mari kita pertimbangkan situasi di mana perangkat pengguna memiliki aplikasi yang sah (klien OAuth 2.0) dan aplikasi jahat yang mendaftarkan skema yang sama dengan yang sah.  Gambar di bawah ini menunjukkan skema serangan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d79/b98/46e/d79b9846e18e85a546b32a5927cdd627.png"><br>  <i>Asal gambar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Inilah masalahnya: pada langkah keempat, browser mengembalikan <code>code</code> dalam aplikasi melalui Skema URI Kustom dan, oleh karena itu, <code>code</code> dapat dicegat oleh aplikasi jahat (karena terdaftar skema yang sama dengan aplikasi yang sah).  Kemudian aplikasi jahat mengubah <code>code</code> ke <code>access_token</code> dan menerima akses ke data pengguna. <br><br>  Apa perlindungannya?  Dalam beberapa kasus, Anda dapat menggunakan komunikasi antar-proses;  kita akan membicarakannya nanti.  Secara umum, Anda memerlukan skema yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kunci Bukti untuk Pertukaran Kode</a> .  Itu dijelaskan dalam skema di bawah ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac2/289/967/ac2289967122b9d5f458e35ab2a0d902.png"><br>  <i>Asal gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  Permintaan klien memiliki beberapa parameter tambahan: <code>code_verifier</code> , <code>code_challenge</code> (dalam skema <code>t(code_verifier)</code> ) dan <code>code_challenge_method</code> (dalam skema <code>t_m</code> ). <br><br>  <code>Code_verifier</code> - adalah angka acak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan panjang minimum 256 bit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yang digunakan hanya sekali</a> .  Jadi, klien harus membuat <code>code_verifier</code> baru untuk setiap permintaan <code>code</code> . <br><br>  <code>Code_challenge_method</code> - ini adalah nama fungsi konversi, sebagian besar SHA-256. <br><br>  <code>Code_challenge</code> - adalah <code>code_verifier</code> yang <code>code_challenge_method</code> konversi <code>code_challenge_method</code> dan yang dikodekan dalam URL Safe Base64. <br><br>  Konversi <code>code_verifier</code> menjadi <code>code_challenge</code> diperlukan untuk menolak serangan vektor berdasarkan intersepsi <code>code_verifier</code> (misalnya, dari log sistem perangkat) ketika meminta <code>code</code> . <br><br>  Jika perangkat pengguna <b>tidak mendukung</b> SHA-256, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>client is allowed to use plain conversion of code_verifier</code></a> .  Dalam semua kasus lain, SHA-256 harus digunakan. <br><br>  Beginilah skema ini bekerja: <br><br><ol><li>  Klien membuat <code>code_verifier</code> dan menghafalnya. <br></li><li>  Klien memilih <code>code_challenge_method</code> dan menerima <code>code_challenge</code> dari <code>code_verifier</code> . <br></li><li>  [Langkah A] Klien meminta <code>code</code> , dengan <code>code_challenge</code> dan <code>code_challenge_method</code> ditambahkan ke permintaan. <br></li><li>  [Langkah B] Penyedia menyimpan <code>code_challenge</code> dan <code>code_challenge_method</code> di server dan mengembalikan <code>code</code> ke klien. <br></li><li>  [Langkah C] Klien meminta <code>access_token</code> , dengan <code>code_verifier</code> ditambahkan padanya. <br></li><li>  Penyedia menerima <code>code_challenge</code> dari <code>code_challenge</code> masuk, dan kemudian membandingkannya dengan <code>code_challenge</code> , yang disimpannya. <br></li><li>  [Langkah D] Jika nilainya cocok, penyedia memberi klien <code>access_token</code> . <br></li></ol><br>  Untuk memahami mengapa <code>code_challenge</code> intersepsi kode, mari kita lihat bagaimana aliran protokol terlihat dari perspektif penyerang. <br><br><ol><li>  Pertama, <code>code</code> permintaan aplikasi yang sah ( <code>code_challenge</code> dan <code>code_challenge_method</code> dikirim bersama dengan <b>permintaan</b> ). <br></li><li>  <code>code</code> intersep aplikasi berbahaya (tetapi bukan <code>code_challenge</code> , karena kode <code>_challenge</code> tidak ada dalam respons). <br></li><li>  Aplikasi berbahaya meminta <code>access_token</code> (dengan <code>code</code> valid, tetapi <b>tanpa</b> <code>code_verifier</code> valid). <br></li><li>  Server memperhatikan ketidakcocokan <code>code_challenge</code> dan memunculkan pesan kesalahan. <br></li></ol><br>  Perhatikan bahwa penyerang tidak dapat menebak <code>code_verifier</code> (nilai 256 bit acak!) Atau menemukannya di suatu tempat di log (karena permintaan pertama benar-benar dikirimkan <code>code_challenge</code> ). <br><br>  Jadi, <code>code_challenge</code> menjawab pertanyaan dari penyedia layanan: "Apakah <code>access_token</code> diminta oleh klien aplikasi yang sama yang meminta <code>code</code> atau yang berbeda?". <br><br><h4>  OAuth 2.0 CSRF </h4><br>  OAuth 2.0 CSRF relatif tidak berbahaya ketika OAuth 2.0 digunakan untuk otorisasi.  Ini adalah cerita yang sama sekali berbeda ketika OAuth 2.0 digunakan untuk otentikasi.  Dalam hal ini OAuth 2.0, CSRF sering mengarah pada pengambilalihan akun. <br><br>  Mari kita bicara lebih banyak tentang serangan CSRF yang sesuai dengan OAuth 2.0 melalui contoh klien aplikasi taksi dan penyedia provider.com.  Pertama, seorang penyerang di perangkatnya sendiri masuk ke akun <code>attacker@provider.com</code> dan menerima <code>code</code> untuk taksi.  Kemudian dia menghentikan proses OAuth 2.0 dan menghasilkan tautan: <br><br><pre> <code class="plaintext hljs">com.taxi.app://oauth? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4</code> </pre> <br>  Kemudian penyerang mengirimkan tautan ini kepada korbannya, misalnya, dalam bentuk surat atau pesan teks dari taksi.  Korban mengklik tautan, aplikasi taksi membuka dan menerima <code>access_token</code> .  Akibatnya, mereka menemukan diri mereka di akun taksi <b>penyerang</b> .  Tidak menyadari itu, korban menggunakan akun ini: melakukan perjalanan, memasukkan data pribadi, dll. <br><br>  Sekarang penyerang dapat login ke akun taksi korban kapan saja, karena terhubung ke <a href=""><code>attacker@provider.com</code></a> .  Serangan login CSRF memungkinkan pelanggar untuk mencuri akun. <br><br>  Serangan CSRF biasanya ditolak dengan token CSRF (disebut juga <code>state</code> ), dan OAuth 2.0 tidak terkecuali.  Cara menggunakan token CSRF: <br><br><ol><li>  Aplikasi klien menghasilkan dan menyimpan token CSRF di perangkat seluler klien. <br></li><li>  Aplikasi klien mencakup token CSRF dalam permintaan akses <code>code</code> . <br></li><li>  Server mengembalikan token CSRF yang sama dengan <code>code</code> dalam tanggapannya. <br></li><li>  Aplikasi klien membandingkan token CSRF yang masuk dan disimpan.  Jika nilainya cocok, prosesnya berjalan. <br></li></ol><br>  Persyaratan token CSRF: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nonce</a> harus minimal 256 bit dan diterima dari sumber sekuens pseudo-acak yang baik. <br><br>  Singkatnya, token CSRF memungkinkan klien aplikasi untuk menjawab pertanyaan berikut: "Apakah itu saya yang memprakarsai permintaan <code>access_token</code> atau seseorang mencoba menipu saya?". <br><br><h4>  Rahasia klien dengan hardcode </h4><br>  Aplikasi seluler tanpa backend terkadang menyimpan nilai-nilai <code>client_id</code> dan <code>client_secret</code> hardcode.  Tentu saja mereka dapat dengan mudah diekstraksi dengan aplikasi reverse engineering. <br><br>  Dampak mengekspos <code>client_id</code> dan <code>client_secret</code> sangat tergantung pada seberapa banyak penyedia layanan kepercayaan menaruh pada <code>client_id</code> , pair <code>client_secret</code> tertentu.  Satu menggunakannya hanya untuk membedakan satu klien dari yang lain sementara yang lain membuka titik akhir API tersembunyi atau membuat batas tingkat yang lebih lunak untuk beberapa klien. <br><br>  Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa Kunci dan Rahasia OAuth API Tidak Aman di Aplikasi Seluler</a> menjelaskan lebih lanjut tentang topik ini. <br><br><h4>  Aplikasi berbahaya bertindak sebagai klien yang sah </h4><br>  Beberapa aplikasi jahat dapat meniru aplikasi yang sah dan menampilkan layar persetujuan atas nama mereka (layar persetujuan adalah layar tempat pengguna melihat: "Saya setuju untuk memberikan akses ke ...").  Pengguna dapat mengklik "izinkan" dan berikan datanya aplikasi berbahaya kepada. <br><br>  Android dan iOS menyediakan mekanisme aplikasi pemeriksaan silang.  Penyedia aplikasi dapat memastikan bahwa aplikasi klien itu sah dan sebaliknya. <br><br>  Sayangnya, jika mekanisme OAuth 2.0 menggunakan utas melalui peramban, tidak mungkin untuk bertahan melawan serangan ini. <br><br><h4>  Serangan lainnya </h4><br>  Kami melihat lebih dekat pada serangan eksklusif untuk ponsel OAuth 2.0.  Namun, jangan lupa tentang OAuth 2.0 asli: substitusi <code>redirect_uri</code> , intersepsi lalu lintas melalui koneksi tidak aman, dll.  Anda dapat membaca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h1>  Bagaimana cara melakukannya dengan aman? </h1><br>  Kami telah mempelajari cara kerja protokol OAuth 2.0 dan kerentanan apa yang dimilikinya pada perangkat seluler.  Sekarang mari kita pisahkan bagian-bagian yang terpisah untuk memiliki skema OAuth 2.0 seluler yang aman. <br><br><h4>  Bagus, buruk OAuth 2.0 </h4><br>  Mari kita mulai dengan cara yang benar untuk menggunakan layar persetujuan.  Perangkat seluler memiliki dua cara untuk membuka halaman web dalam aplikasi seluler. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/740/d1e/75a/740d1e75aedec07de286cf9d7fc49292.png"><br><br>  Cara pertama adalah melalui Browser Custom Tab (di sebelah kiri dalam gambar).  <b>Catatan</b> : Browser Custom Tab untuk Android disebut Chrome Custom Tab, dan untuk iOS - SafariViewController.  Itu hanya tab browser yang ditampilkan di aplikasi: tidak ada peralihan visual di antara aplikasi. <br><br>  Cara kedua adalah melalui WebView (di sebelah kanan dalam gambar) dan saya menganggapnya buruk sehubungan dengan ponsel OAuth 2.0. <br><br>  WebView adalah browser tertanam untuk aplikasi seluler. <br><br>  " <i>Browser tertanam</i> " berarti akses ke cookie, penyimpanan, cache, riwayat, dan data Safari serta Chrome lainnya dilarang untuk WebView.  Kebalikannya juga benar: Safari dan Chrome tidak bisa mendapatkan akses ke data WebView. <br><br>  " <i>Browser aplikasi seluler</i> " berarti aplikasi seluler yang menjalankan WebView memiliki akses <b>penuh</b> ke cookie, penyimpanan, cache, riwayat, dan data WebView lainnya. <br><br>  Sekarang, bayangkan: pengguna mengklik "masuk dengan ..." dan WebView dari aplikasi jahat meminta login dan kata sandinya dari penyedia layanan. <br><br>  Gagal epik: <br><br><ol><li>  Pengguna memasukkan login dan kata sandi untuk akun penyedia layanan di aplikasi, yang dapat dengan mudah mencuri data ini. <br></li><li>  OAuth 2.0 pada awalnya dikembangkan untuk <i>tidak memasukkan login dan kata sandi penyedia layanan.</i> <i><br></i> <br>  Pengguna terbiasa memasukkan login dan kata sandi di mana saja sehingga meningkatkan kemungkinan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memancing</a> . <br></li></ol><br>  Mempertimbangkan semua kontra WebView, kesimpulan yang jelas menawarkan dirinya sendiri: gunakan Tab Kustom Browser untuk layar persetujuan. <br><br>  Jika ada orang yang mendukung WebView alih-alih Tab Kustom Browser, saya sangat menghargai jika Anda menulisnya di komentar. <br><br><h4>  Skema OAuth 2.0 seluler yang aman </h4><br>  Kita akan menggunakan skema Pemberian Kode Otorisasi, karena memungkinkan kita untuk menambahkan <code>code_challenge</code> serta <code>state</code> dan mempertahankan terhadap serangan intersepsi kode dan OAuth 2.0 CSRF. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>Asal gambar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Permintaan akses kode (langkah 1-2) akan terlihat sebagai berikut: <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> 3D% 3D &amp; <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br>  Pada langkah 3, browser mendapat respons dengan mengalihkan: <br><br><pre> <code class="plaintext hljs">com.mail.cloud.app://outh? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> </pre> <br>  Pada langkah 4, browser membuka Skema URI Khusus dan memberikan token CSRF ke aplikasi klien. <br>  permintaan <code>access_token</code> (langkah 5): <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/token? code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br>  Langkah terakhir membawa respons dengan <code>access_token</code> . <br><br>  Skema ini umumnya aman, tetapi ada beberapa kasus khusus ketika OAuth 2.0 bisa lebih sederhana dan lebih aman. <br><br><h4>  Android IPC </h4><br>  Android memiliki mekanisme komunikasi data dua arah antara proses: IPC (komunikasi antar proses).  IPC lebih baik daripada Skema URI Khusus karena dua alasan: <br><br><ol><li>  Aplikasi yang membuka saluran IPC dapat mengkonfirmasi keaslian aplikasi yang dibuka oleh sertifikatnya.  Kebalikannya juga benar: aplikasi yang dibuka dapat mengkonfirmasi keaslian aplikasi yang membukanya. <br></li><li>  Jika pengirim mengirim permintaan melalui saluran IPC, ia dapat menerima jawaban melalui saluran yang sama.  Bersama dengan cross-check (item 1), itu berarti bahwa tidak ada proses asing yang dapat mencegat <code>access_token</code> . <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/dac/d7c/1a9/dacd7c1a98a6d1c7227b7e8e5e24757f.png"><br><br>  Oleh karena itu, kita dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implisit Hibah</a> untuk menyederhanakan skema OAuth 2.0 seluler.  Tidak ada <code>code_challenge</code> dan <code>state</code> juga berarti lebih sedikit permukaan serangan.  Kami juga dapat menurunkan risiko aplikasi jahat bertindak seperti klien yang sah yang mencoba mencuri akun pengguna. <br><br><h4>  SDK untuk klien </h4><br>  Selain menerapkan skema OAuth 2.0 seluler yang aman ini, penyedia harus mengembangkan SDK untuk kliennya.  Ini akan menyederhanakan implementasi OAuth 2.0 di sisi klien dan sekaligus mengurangi jumlah kesalahan dan kerentanan. <br><br><h1>  Kesimpulan </h1><br>  Biarkan saya meringkasnya untuk Anda.  Berikut adalah <i>daftar periksa</i> (dasar) <i>untuk OAuth 2.0 yang aman</i> untuk penyedia OAuth 2.0: <br><br><ol><li>  Fondasi yang kuat sangat penting.  Dalam hal mobile OAuth 2.0, yayasan adalah skema atau protokol yang dipilih untuk implementasi.  Sangat mudah untuk membuat kesalahan saat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerapkan skema OAuth 2.0 Anda sendiri</a> .  Yang lain sudah mengetuk dan mempelajari pelajaran mereka;  tidak ada yang salah dengan belajar dari kesalahan mereka dan membuat implementasi yang aman dalam sekali jalan.  Skema OAuth 2.0 seluler yang paling aman dijelaskan dalam <i>Bagaimana melakukannya dengan aman</i> ? <br></li><li>  <code>Access_token</code> dan data sensitif lainnya harus disimpan di Keychain untuk iOS dan di Penyimpanan Internal untuk Android.  Penyimpanan ini secara khusus dikembangkan hanya untuk itu.  Penyedia Konten dapat digunakan di Android, tetapi harus dikonfigurasi dengan aman. <br></li><li>  <code>Client_secret</code> tidak <b>berguna</b> , kecuali disimpan di backend.  Jangan memberikannya kepada klien publik. <br></li><li>  Jangan gunakan WebView untuk layar persetujuan;  gunakan tab khusus browser. <br></li><li>  Untuk bertahan melawan serangan intersepsi kode, gunakan <code>code_challenge</code> . <br></li><li>  Untuk mempertahankan diri dari OAuth 2.0 CSRF, gunakan <code>state</code> . <br></li><li>  Gunakan HTTPS di <b>mana-mana</b> , dengan downgrade dilarang ke HTTP.  Berikut ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo 3 menit yang</a> menjelaskan alasannya (dengan contoh dari bug bug). <br></li><li>  Ikuti <b>standar</b> kriptografi (pilihan algoritma, panjang token, dll).  Anda dapat menyalin data dan mencari tahu mengapa itu dilakukan dengan cara ini, tetapi jangan roll crypto Anda sendiri. <br></li><li>  <code>Code</code> harus digunakan hanya sekali, dengan umur yang pendek. <br></li><li>  Dari sisi klien aplikasi, periksa apa yang Anda buka untuk OAuth 2.0;  dan dari sisi penyedia aplikasi, periksa siapa yang membuka Anda untuk OAuth 2.0. <br></li><li>  Ingatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerentanan OAuth 2.0 yang umum</a> .  Mobile OAuth 2.0 memperbesar dan melengkapi yang asli, oleh karena itu, <code>redirect_uri</code> memeriksa kecocokan yang tepat dan rekomendasi lain untuk OAuth 2.0 asli masih berlaku. <br></li><li>  Anda harus memberi klien Anda SDK.  Mereka akan memiliki lebih sedikit bug dan kerentanan dan akan lebih mudah bagi mereka untuk mengimplementasikan OAuth 2.0 Anda. <br></li></ol><br><h1>  Bacaan lebih lanjut </h1><br><ol><li>  "Kerentanan OAuth 2.0 seluler" " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.youtube.com/watch?v=vjCF_O6aZIg</a> <br></li><li>  Penelitian kondisi ras OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://hackerone.com/reports/55140</a> <br></li><li>  Hampir semuanya tentang OAuth 2.0 di satu tempat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://oauth.net/2/</a> <br></li><li>  Mengapa Kunci dan Rahasia OAuth API Tidak Aman di Aplikasi Seluler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developer.okta.com/blog/2019/01/22/oauth-api-keys-arent-safe-in-mobile-apps</a> <br></li><li>  [RFC] OAuth 2.0 untuk Aplikasi Asli <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc8252</a> <br></li><li>  [RFC] Kunci Bukti untuk Pertukaran Kode oleh Klien Publik OAuth <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc7636</a> <br></li><li>  [RFC] OAuth 2.0 Model Ancaman dan Pertimbangan Keamanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc6819</a> <br></li><li>  [RFC] OAuth 2.0 Protokol Registrasi Klien Dinamis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc7591</a> <br></li><li>  Google OAuth 2.0 untuk Aplikasi Seluler &amp; Desktop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> <br></li></ol><br><h1>  Kredit </h1><br>  Terima kasih untuk semua yang membantu saya menulis artikel ini.  Terutama kepada Sergei Belov, Andrei Sumin, Andrey Labunets untuk umpan balik tentang perincian teknis, kepada Pavel Kruglov untuk terjemahan bahasa Inggris dan kepada Daria Yakovleva untuk bantuan dengan merilis versi Rusia dari artikel ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456702/">https://habr.com/ru/post/id456702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456686/index.html">Seluk-beluk wawancara ketika mempekerjakan udalenka</a></li>
<li><a href="../id456690/index.html">Headphone Sehari-hari oleh Case Guru - CGPods Sport</a></li>
<li><a href="../id456692/index.html">Naik turunnya Visual Basic</a></li>
<li><a href="../id456696/index.html">Bagaimana bunga pinjaman bertambah dan bagaimana cara menerapkannya</a></li>
<li><a href="../id456700/index.html">GeekUniversity Membuka Rekrutmen di Fakultas Manajemen Produk</a></li>
<li><a href="../id456704/index.html">Enam cara penguji bisa mendapatkan keuntungan (selain pengujian fungsional)</a></li>
<li><a href="../id456710/index.html">Apa itu platform kode rendah / tanpa kode dan CRM, CRM +, ERP</a></li>
<li><a href="../id456712/index.html">Pencatatan lalu lintas selektif untuk layanan SOAP</a></li>
<li><a href="../id456714/index.html">Memahami angka floating point (bagian 0)</a></li>
<li><a href="../id456716/index.html">Bukan data yang sangat besar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>