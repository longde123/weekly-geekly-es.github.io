<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚖 🍑 🎹 Arquitectura de la aplicación Flutter 101: Vanilla, Scoped Model, BLoC 👛 🕦 🚌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(publicado originalmente en Medium ) 


 Flutter proporciona un marco moderno de estilo de reacción, una rica colección de widgets y herramientas, per...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arquitectura de la aplicación Flutter 101: Vanilla, Scoped Model, BLoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438524/"><p><img src="https://habrastorage.org/webt/2j/2p/yu/2j2pyudr-kde4fqeczqoic_9lpq.png"></p><br><p>  (publicado originalmente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Medium</a> ) </p><br><p>  Flutter proporciona un marco moderno de estilo de reacción, una rica colección de widgets y herramientas, pero no hay nada similar a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">guía</a> de Android <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para la arquitectura de aplicaciones</a> . </p><br><p>  De hecho, no existe una arquitectura definitiva que cumpla con todos los requisitos posibles, sin embargo, admitamos que la mayoría de las aplicaciones móviles en las que estamos trabajando tienen al menos algunas de las siguientes funciones: </p><br><ol><li>  Solicitar / cargar datos desde / a la red. </li><li>  Mapear, transformar, preparar datos y presentarlos al usuario. </li><li>  Poner / obtener datos a / de la base de datos. </li></ol><br><p>  Teniendo esto en cuenta, he creado una aplicación de muestra que está resolviendo exactamente el mismo problema utilizando tres enfoques diferentes de la arquitectura. <a name="habracut"></a></p><br><p>  Al usuario se le presenta un botón "Cargar datos del usuario" en el centro de la pantalla.  Cuando el usuario hace clic en el botón, se activa la carga asíncrona de datos y el botón se reemplaza con un indicador de carga.  Después de cargar los datos, el indicador de carga se reemplaza con los datos. </p><br><p>  Empecemos </p><br><p><img src="https://habrastorage.org/webt/c5/by/8g/c5by8gjmz_oov-ukuy4_dwo4njs.gif"></p><br><h2 id="data">  Datos </h2><br><p> Para simplificar, he creado la clase <code>Repository</code> que contiene el método <code>getUser()</code> que emula una llamada de red asíncrona y devuelve el objeto <code>Future&lt;User&gt;</code> con valores codificados. </p><br><p>  Si no está familiarizado con Futures y la programación asincrónica en Dart, puede obtener más información al respecto siguiendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este tutorial</a> y leyendo un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documento</a> . </p><br><pre> <code class="plaintext hljs">class Repository { Future&lt;User&gt; getUser() async { await Future.delayed(Duration(seconds: 2)); return User(name: 'John', surname: 'Smith'); } }</code> </pre> <br><pre> <code class="plaintext hljs">class User { User({ @required this.name, @required this.surname, }); final String name; final String surname; }</code> </pre> <br><h2 id="vanilla">  Vainilla </h2><br><p>  Construyamos la aplicación de la forma en que lo harían la mayoría de los desarrolladores después de leer la documentación oficial de Flutter. </p><br><p>  Navegando a la pantalla <code>VanillaScreen</code> usando <code>Navigator</code> </p><br><pre> <code class="plaintext hljs">Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; VanillaScreen(_repository), ), );</code> </pre> <br><p>  Como el estado del widget podría cambiar varias veces durante la vida útil del widget, deberíamos extender <code>StatefulWidget</code> .  Implementar un widget con estado también requiere tener una clase de <code>State</code> .  Los campos <code>bool _isLoading</code> y <code>User _user</code> en la clase <code>_VanillaScreenState</code> representan el estado del widget.  Ambos campos se inicializan antes de que se <code>build(BuildContext context)</code> método <code>build(BuildContext context)</code> . </p><br><pre> <code class="plaintext hljs">class VanillaScreen extends StatefulWidget { VanillaScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _VanillaScreenState(); } class _VanillaScreenState extends State&lt;VanillaScreen&gt; { bool _isLoading = false; User _user; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Vanilla'), ), body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), ), ); } Widget _buildBody() { if (_user != null) { return _buildContent(); } else { return _buildInit(); } } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { setState(() { _isLoading = true; }); widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); }); }, ), ); } Widget _buildContent() { return Center( child: Text('Hello ${_user.name} ${_user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Cuando se crea el objeto de estado del widget, se llama al método <code>build(BuildContext context)</code> para construir la IU.  Todas las decisiones sobre los widgets que deben construirse para representar el estado actual se toman en el código de declaración de UI. </p><br><pre> <code class="plaintext hljs">body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), )</code> </pre> <br><p>  Para mostrar el indicador de progreso cuando el usuario hace clic en el botón "Cargar detalles del usuario" que hacemos a continuación. </p><br><pre> <code class="plaintext hljs">setState(() { _isLoading = true; });</code> </pre> <br><blockquote>  Llamar a setState () notifica al marco que el estado interno de este objeto ha cambiado de una manera que podría afectar la interfaz de usuario en este subárbol, lo que hace que el marco programe una compilación para este objeto Estado. </blockquote><p>  Eso significa que después de llamar <code>setState()</code> método <code>setState()</code> el marco vuelve a llamar <code>setState()</code> método <code>build(BuildContext context)</code> y <strong>se reconstruye todo el árbol de widgets</strong> .  Como <code>_isLoading</code> ahora está establecido en el método <code>true</code> , se llama a <code>_buildBody()</code> lugar de <code>_buildBody()</code> y el indicador de carga se muestra en la pantalla.  Exactamente lo mismo sucede cuando manejamos la devolución de llamada desde <code>getUser()</code> y llamamos a <code>setState()</code> para reasignar los campos <code>_isLoading</code> y <code>_user</code> . </p><br><pre> <code class="plaintext hljs">widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); });</code> </pre> <br><h3 id="pros">  Pros </h3><br><ol><li>  Fácil de aprender y entender. </li><li>  No se requieren bibliotecas de terceros. </li></ol><br><h3 id="cons">  Contras </h3><br><ol><li>  Todo el árbol de widgets se reconstruye cada vez que cambia el estado del widget. </li><li>  Está rompiendo el principio de responsabilidad única.  Widget no solo es responsable de construir la interfaz de usuario, también es responsable de la carga de datos, la lógica empresarial y la gestión del estado. </li><li>  Las decisiones sobre cómo se debe representar el estado actual se toman en el código de declaración de UI.  Si tuviéramos un poco más complejo, la legibilidad del código de estado disminuiría. </li></ol><br><h2 id="scoped-model">  Modelo de alcance </h2><br><p>  Scoped Model es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete de terceros</a> que no está incluido en el marco de Flutter.  Así es como lo describen los desarrolladores de Scoped Model: </p><br><blockquote>  Un conjunto de utilidades que le permiten pasar fácilmente un modelo de datos desde un widget principal a sus descendientes.  Además, también reconstruye todos los elementos secundarios que usan el modelo cuando se actualiza el modelo.  Esta biblioteca se extrajo originalmente de la base de código Fuchsia. </blockquote><p>  Construyamos la misma pantalla usando el modelo con alcance.  Primero, necesitamos instalar el paquete Scoped Model agregando la dependencia <code>pubspec.yaml</code> a <code>pubspec.yaml</code> en <code>dependencies</code> sección de <code>dependencies</code> . </p><br><pre> <code class="plaintext hljs">scoped_model: ^1.0.1</code> </pre> <br><p>  Echemos un vistazo al widget <code>UserModelScreen</code> y compárelo con el ejemplo anterior que se creó sin usar el Modelo con ámbito.  Echemos un vistazo al widget UserModelScreen y compárelo con el ejemplo anterior que se creó sin usar el Modelo con ámbito.  Como queremos que nuestro modelo esté disponible para todos los descendientes del widget, debemos envolverlo con ScopedModel genérico y proporcionar un widget y un modelo. </p><br><pre> <code class="plaintext hljs">class UserModelScreen extends StatefulWidget { UserModelScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserModelScreenState(); } class _UserModelScreenState extends State&lt;UserModelScreen&gt; { UserModel _userModel; @override void initState() { _userModel = UserModel(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return ScopedModel( model: _userModel, child: Scaffold( appBar: AppBar( title: const Text('Scoped model'), ), body: SafeArea( child: ScopedModelDescendant&lt;UserModel&gt;( builder: (context, child, model) { if (model.isLoading) { return _buildLoading(); } else { if (model.user != null) { return _buildContent(model); } else { return _buildInit(model); } } }, ), ), ), ); } Widget _buildInit(UserModel userModel) { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { userModel.loadUserData(); }, ), ); } Widget _buildContent(UserModel userModel) { return Center( child: Text('Hello ${userModel.user.name} ${userModel.user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  En el ejemplo anterior, todo el árbol de widgets se reconstruyó cuando cambió el estado del widget.  Pero, ¿realmente necesitamos reconstruir toda la pantalla?  Por ejemplo, AppBar no debería cambiar en absoluto, por lo que no tiene sentido reconstruirlo.  Idealmente, deberíamos reconstruir solo aquellos widgets que se actualizan.  Scoped Model puede ayudarnos a resolver eso. </p><br><p>  <code>ScopedModelDescendant&lt;UserModel&gt;</code> se utiliza para encontrar <code>UserModel</code> en el árbol de widgets.  Se reconstruirá automáticamente cada vez que <code>UserModel</code> notifique que se ha producido un cambio. </p><br><p>  Otra mejora es que <code>UserModelScreen</code> ya no es responsable de la administración del estado y la lógica comercial. </p><br><p>  Echemos un vistazo al código de <code>UserModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModel extends Model { UserModel(this._repository); final Repository _repository; bool _isLoading = false; User _user; User get user =&gt; _user; bool get isLoading =&gt; _isLoading; void loadUserData() { _isLoading = true; notifyListeners(); _repository.getUser().then((user) { _user = user; _isLoading = false; notifyListeners(); }); } static UserModel of(BuildContext context) =&gt; ScopedModel.of&lt;UserModel&gt;(context); }</code> </pre> <br><p>  Ahora <code>UserModel</code> retiene y administra el estado.  Para notificar a los oyentes (y reconstruir descendientes) que el cambio tuvo lugar, se debe llamar al método <code>notifyListeners()</code> . </p><br><h3 id="pros-1">  Pros </h3><br><ol><li>  Lógica empresarial, gestión de estado y separación de código de UI. </li><li>  Fácil de aprender <br><h3 id="cons">  Contras </h3></li><li>  Requiere una biblioteca de terceros. </li><li>  A medida que el modelo se vuelve más y más complejo, es difícil hacer un seguimiento de cuándo debe llamar a <code>notifyListeners()</code> . </li></ol><br><h2 id="bloc">  BLoC </h2><br><p>  BLoC (componentes de lógica de negocio) es un patrón recomendado por los desarrolladores de Google.  Aprovecha la funcionalidad de las transmisiones para administrar y propagar los cambios de estado. </p><br><p>  <strong>Para desarrolladores de Android:</strong> puede pensar en el objeto <code>Bloc</code> como <code>ViewModel</code> y en <code>StreamController</code> como <code>LiveData</code> .  Esto hará que el siguiente código sea muy sencillo ya que ya está familiarizado con los conceptos. </p><br><pre> <code class="plaintext hljs">class UserBloc { UserBloc(this._repository); final Repository _repository; final _userStreamController = StreamController&lt;UserState&gt;(); Stream&lt;UserState&gt; get user =&gt; _userStreamController.stream; void loadUserData() { _userStreamController.sink.add(UserState._userLoading()); _repository.getUser().then((user) { _userStreamController.sink.add(UserState._userData(user)); }); } void dispose() { _userStreamController.close(); } } class UserState { UserState(); factory UserState._userData(User user) = UserDataState; factory UserState._userLoading() = UserLoadingState; } class UserInitState extends UserState {} class UserLoadingState extends UserState {} class UserDataState extends UserState { UserDataState(this.user); final User user; }</code> </pre> <br><p>  No se requieren llamadas a métodos adicionales para notificar a los suscriptores cuando cambia el estado. </p><br><p>  He creado 3 clases para representar posibles estados de la pantalla: </p><br><p>  <code>UserInitState</code> para el estado, cuando el usuario abre una pantalla con un botón en el centro. </p><br><p>  <code>UserLoadingState</code> para el estado, cuando se muestra el indicador de carga mientras se cargan los datos. </p><br><p>  <code>UserDataState</code> para el estado, cuando los datos se cargan y se muestran en la pantalla. </p><br><p>  Propagar cambios de estado de esta manera nos permite deshacernos de toda la lógica en el código de declaración de UI.  En el ejemplo con Scoped Model, todavía estábamos verificando si <code>_isLoading</code> es <code>true</code> en el código de declaración de UI para decidir qué widget deberíamos renderizar.  En el caso de BLoC, estamos propagando el estado de la pantalla y la única responsabilidad del widget <code>UserBlocScreen</code> es representar la interfaz de usuario para este estado. </p><br><pre> <code class="plaintext hljs">class UserBlocScreen extends StatefulWidget { UserBlocScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserBlocScreenState(); } class _UserBlocScreenState extends State&lt;UserBlocScreen&gt; { UserBloc _userBloc; @override void initState() { _userBloc = UserBloc(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Bloc'), ), body: SafeArea( child: StreamBuilder&lt;UserState&gt;( stream: _userBloc.user, initialData: UserInitState(), builder: (context, snapshot) { if (snapshot.data is UserInitState) { return _buildInit(); } if (snapshot.data is UserDataState) { UserDataState state = snapshot.data; return _buildContent(state.user); } if (snapshot.data is UserLoadingState) { return _buildLoading(); } }, ), ), ); } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { _userBloc.loadUserData(); }, ), ); } Widget _buildContent(User user) { return Center( child: Text('Hello ${user.name} ${user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } @override void dispose() { _userBloc.dispose(); super.dispose(); } }</code> </pre> <br><p>  <code>UserBlocScreen</code> código de <code>UserBlocScreen</code> volvió aún más simple en comparación con los ejemplos anteriores.  Para escuchar los cambios de estado, estamos utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">StreamBuilder</a> .  <code>StreamBuilder</code> es un <code>StatefulWidget</code> que se basa en la última instantánea de interacción con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Stream</a> . </p><br><h3 id="pros-2">  Pros </h3><br><p>  No se necesitan bibliotecas de terceros. <br>  Lógica empresarial, gestión del estado y separación lógica de la interfaz de usuario. <br>  Es reactivo  No se necesitan llamadas adicionales como en el caso de <code>notifyListeners()</code> Scoped Model <code>notifyListeners()</code> . </p><br><h3 id="cons-1">  Contras </h3><br><p>  Se requiere experiencia trabajando con streams o rxdart. </p><br><h2 id="links">  Enlaces </h2><br><p>  Puede verificar el código fuente de los ejemplos anteriores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este repositorio de github.</a> </p><br><p>  Originalmente el artículo se publica en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Medium</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438524/">https://habr.com/ru/post/438524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438512/index.html">Compresión de datos de Huffman</a></li>
<li><a href="../438514/index.html">Cómo no he trabajado durante un año en Sberbank</a></li>
<li><a href="../438516/index.html">Cuándo guardar la longitud de una matriz en una variable local en C #</a></li>
<li><a href="../438518/index.html">Creando tu jsfiddle, parte 2</a></li>
<li><a href="../438522/index.html">Ecualizador estratégico</a></li>
<li><a href="../438526/index.html">Las redes neuronales artificiales crecen células de navegación como en el cerebro.</a></li>
<li><a href="../438530/index.html">Hipster Podcasts # 1</a></li>
<li><a href="../438534/index.html">Modbus en el microcontrolador ruso K1986BE92QI</a></li>
<li><a href="../438536/index.html">Bajo el capó del chatbot: qué puede hacer RocketBot y cómo funciona</a></li>
<li><a href="../438538/index.html">Teamlead Conf 2019 Msk: sobre otro formato de comunicación</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>