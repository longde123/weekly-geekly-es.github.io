<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòö üë®üèº‚Äçüé® ‚§¥Ô∏è JavaScript: explorando objetos üçØ üíß üëáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O material, cuja tradu√ß√£o publicamos hoje, √© dedicado ao estudo de objetos - uma das principais ess√™ncias do JavaScript. Ele foi desenvolvido principa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript: explorando objetos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420615/">  O material, cuja tradu√ß√£o publicamos hoje, √© dedicado ao estudo de objetos - uma das principais ess√™ncias do JavaScript.  Ele foi desenvolvido principalmente para desenvolvedores iniciantes que desejam otimizar seus conhecimentos sobre objetos. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/vo/lg/xb/volgxbgclrhdnqvvi_qdqfc1yna.jpeg"></a> <br><br>  Objetos em JavaScript s√£o cole√ß√µes din√¢micas de propriedades que, al√©m disso, cont√™m uma propriedade "oculta" que √© um prot√≥tipo do objeto.  Propriedades de objetos s√£o caracterizadas por chaves e valores.  Vamos come√ßar a conversa sobre objetos JS com chaves. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Chaves de propriedade do objeto</font> </h2><br>  A chave de propriedade do objeto √© uma sequ√™ncia exclusiva.  Voc√™ pode usar dois m√©todos para acessar propriedades: acessando-as por um per√≠odo e especificando a chave do objeto entre colchetes.  Ao acessar propriedades por meio de um ponto, a chave deve ser um identificador JavaScript v√°lido.  Considere um exemplo: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> obj = {  <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span> } obj.message //<span class="hljs-string"><span class="hljs-string">"A message"</span></span> obj[<span class="hljs-string"><span class="hljs-string">"message"</span></span>] //<span class="hljs-string"><span class="hljs-string">"A message"</span></span></code> </pre> <br>  Ao tentar acessar uma propriedade inexistente de um objeto, uma mensagem de erro n√£o aparecer√°, mas o valor <code>undefined</code> ser√° retornado: <br><br><pre> <code class="hljs objectivec">obj.otherProperty <span class="hljs-comment"><span class="hljs-comment">//undefined</span></span></code> </pre> <br>  Ao usar colchetes para acessar propriedades, voc√™ pode usar chaves que n√£o s√£o identificadores JavaScript v√°lidos (por exemplo, a chave pode ser uma sequ√™ncia que cont√©m espa√ßos).  Eles podem ter qualquer valor que possa ser convertido em uma sequ√™ncia: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> french = {}; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>] = <span class="hljs-string"><span class="hljs-string">"thank you very much"</span></span>; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//"thank you very much"</span></span></code> </pre> <br>  Se valores n√£o-string forem usados ‚Äã‚Äãcomo chaves, eles ser√£o automaticamente convertidos em strings (usando, se poss√≠vel, o <code>toString()</code> ): <br><br><pre> <code class="hljs powershell">et obj = {}; //Number obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">"Number 1"</span></span>; obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true //Object let number1 = { toString : function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } } obj[<span class="hljs-type"><span class="hljs-type">number1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true</code> </pre> <br>  Neste exemplo, o objeto <code>number1</code> √© usado como chave.  Ao tentar acessar uma propriedade, ela √© convertida na linha <code>1</code> e o resultado dessa convers√£o √© usado como chave. <br><br><h2>  <font color="#3AC1EF">Valores da propriedade do objeto</font> </h2><br>  As propriedades do objeto podem ser valores, objetos ou fun√ß√µes primitivos. <br><br><h3>  <font color="#3AC1EF">Objeto como um valor de propriedade do objeto</font> </h3><br>  Objetos podem ser colocados em outros objetos.  Considere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo</a> : <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = { title : <span class="hljs-string"><span class="hljs-string">"The Good Parts"</span></span>, author : {   firstName : <span class="hljs-string"><span class="hljs-string">"Douglas"</span></span>,   lastName : <span class="hljs-string"><span class="hljs-string">"Crockford"</span></span> } } book.author.firstName; <span class="hljs-comment"><span class="hljs-comment">//"Douglas"</span></span></code> </pre> <br>  Uma abordagem semelhante pode ser usada para criar namespaces: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> app = {}; app.authorService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; app.bookService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} };</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Funcionar como um valor de propriedade do objeto</font> </h3><br>  Quando uma fun√ß√£o √© usada como um valor de propriedade do objeto, ela geralmente se torna um m√©todo de objeto.  Dentro do m√©todo, para acessar o objeto atual, use a <code>this</code> . <br><br>  Essa palavra-chave, no entanto, pode ter significados diferentes, dependendo de como a fun√ß√£o foi chamada.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> voc√™ pode ler sobre situa√ß√µes em que <code>this</code> perde contexto. <br><br><h2>  <font color="#3AC1EF">A natureza din√¢mica dos objetos</font> </h2><br>  Objetos em JavaScript, por natureza, s√£o entidades din√¢micas.  Voc√™ pode adicionar propriedades a qualquer momento, o mesmo vale para a exclus√£o de propriedades: <br><br><pre> <code class="hljs ruby">let obj = {}; obj.message = <span class="hljs-string"><span class="hljs-string">"This is a message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   obj.otherMessage = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    delete obj.otherMessage; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> </code> </pre> <br><h2>  <font color="#3AC1EF">Objetos como matrizes associativas</font> </h2><br>  Os objetos podem ser considerados como matrizes associativas.  Chaves de matriz associativas s√£o os nomes de propriedade do objeto.  Para acessar a chave, n√£o √© necess√°rio examinar todas as propriedades, ou seja, a opera√ß√£o de acesso √† chave de uma matriz associativa baseada em um objeto √© realizada em O (1). <br><br><h2>  <font color="#3AC1EF">Prot√≥tipos de Objetos</font> </h2><br>  Os objetos t√™m um link "oculto", <code>__proto__</code> , apontando para um objeto prot√≥tipo do qual o objeto herda propriedades. <br><br>  Por exemplo, um objeto criado usando um literal de objeto tem um link para <code>Object.prototype</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; obj.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype; <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Objetos vazios</font> </h3><br>  Como acabamos de ver, o objeto "vazio", <code>{}</code> , na verdade n√£o √© t√£o vazio, pois cont√©m uma refer√™ncia ao <code>Object.prototype</code> .  Para criar um objeto verdadeiramente vazio, voc√™ precisa usar a seguinte constru√ß√£o: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)</code> </pre> <br>  Gra√ßas a isso, um objeto sem prot√≥tipo ser√° criado.  Esses objetos s√£o geralmente usados ‚Äã‚Äãpara criar matrizes associativas. <br><br><h3>  <font color="#3AC1EF">Chain Cadeia de prot√≥tipo</font> </h3><br>  Objetos prot√≥tipos podem ter seus pr√≥prios prot√≥tipos.  Se voc√™ tentar acessar uma propriedade de um objeto que n√£o est√° nele, o JavaScript tentar√° encontrar essa propriedade no prot√≥tipo desse objeto e, se a propriedade desejada n√£o estiver l√°, ser√° feita uma tentativa de encontr√°-la no prot√≥tipo do prot√≥tipo.  Isso continuar√° at√© que a propriedade desejada seja encontrada ou at√© o fim da cadeia de prot√≥tipos. <br><br><h2>  <font color="#3AC1EF">Valores de tipo primitivo e wrappers de objeto</font> </h2><br>  O JavaScript permite que voc√™ trabalhe com os valores de tipos primitivos como objetos, no sentido em que a linguagem permite acessar suas propriedades e m√©todos. <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span> <span class="hljs-string"><span class="hljs-string">"text"</span></span>.toUpperCase(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"TEXT"</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>.toString(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br>  Al√©m disso, √© claro, os valores dos tipos primitivos n√£o s√£o objetos. <br><br>  Para organizar o acesso √†s ‚Äúpropriedades‚Äù dos valores dos tipos primitivos, o JavaScript, se necess√°rio, cria objetos de wrapper que, depois de se tornarem desnecess√°rios, s√£o destru√≠dos.  O processo de cria√ß√£o e destrui√ß√£o de objetos wrapper √© otimizado pelo mecanismo JS. <br><br>  Os wrappers de objetos t√™m valores de tipos num√©rico, de sequ√™ncia e l√≥gico.  Objetos dos tipos correspondentes s√£o representados pelas fun√ß√µes de construtor <code>Number</code> , <code>String</code> e <code>Boolean</code> . <br><br><h2>  <font color="#3AC1EF">Prot√≥tipos incorporados</font> </h2><br>  Os objetos Number herdam propriedades e m√©todos do prot√≥tipo <code>Number.prototype</code> , que √© o descendente de <code>Object.prototype</code> : <br><br><pre> <code class="hljs pgsql">var <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__ === Number.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__.__proto__ === <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  O prot√≥tipo de objetos string √© <code>String.prototype</code> .  O prot√≥tipo de objetos booleanos √© <code>Boolean.prototype</code> .  O prot√≥tipo de matrizes (que tamb√©m s√£o objetos) √© <code>Array.prototype</code> . <br><br>  Fun√ß√µes em JavaScript tamb√©m s√£o objetos que possuem um prot√≥tipo <code>Function.prototype</code> .  Fun√ß√µes t√™m m√©todos como <code>bind()</code> , <code>apply()</code> e <code>call()</code> . <br><br>  Todos os objetos, fun√ß√µes e objetos que representam valores de tipo primitivo (exceto valores <code>null</code> e <code>undefined</code> ) herdam propriedades e m√©todos do <code>Object.prototype</code> .  Isso leva ao fato de que, por exemplo, todos eles t√™m um <code>toString()</code> . <br><br><h2>  <font color="#3AC1EF">Estendendo objetos incorporados com polyfills</font> </h2><br>  O JavaScript facilita a extens√£o de objetos incorporados com novos recursos usando os chamados polyfills.  Um polyfill √© um peda√ßo de c√≥digo que implementa recursos que n√£o s√£o suportados por nenhum navegador. <br><br><h3>  <font color="#3AC1EF">‚ñçUso de polyfills</font> </h3><br>  Por exemplo, h√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">polyfill</a> para o m√©todo <code>Object.assign()</code> .  Permite adicionar uma nova fun√ß√£o ao <code>Object</code> se ela n√£o estiver dispon√≠vel. <br><br>  O mesmo se aplica ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">polyfill</a> <code>Array.from()</code> , que, se o m√©todo <code>from()</code> n√£o estiver no objeto <code>Array</code> , o equipar√° com esse m√©todo. <br><br><h3>  <font color="#3AC1EF">F Polifill e prot√≥tipos</font> </h3><br>  Com a ajuda de polyfills, novos m√©todos podem ser adicionados aos prot√≥tipos de objetos.  Por exemplo, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">polyfill</a> para <code>String.prototype.trim()</code> permite equipar todos os objetos de string com o m√©todo <code>trim()</code> : <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = "   A text "; <span class="hljs-type"><span class="hljs-type">text</span></span>.trim(); //"A text"</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O polyfill</a> para <code>Array.prototype.find()</code> permite equipar todas as matrizes com o m√©todo <code>find()</code> .  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">polyfill</a> para <code>Array.prototype.findIndex()</code> funciona de maneira semelhante: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"C"</span></span>, <span class="hljs-string"><span class="hljs-string">"D"</span></span>, <span class="hljs-string"><span class="hljs-string">"E"</span></span>]; arr.indexOf(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Heran√ßa √∫nica</font> </h2><br>  O comando <code>Object.create()</code> permite criar novos objetos com um determinado objeto de prot√≥tipo.  Este comando √© usado no JavaScript para implementar um √∫nico mecanismo de heran√ßa.  Considere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookPrototype = { <span class="hljs-attr"><span class="hljs-attr">getFullTitle</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title + <span class="hljs-string"><span class="hljs-string">" by "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.author; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(bookPrototype); book.title = <span class="hljs-string"><span class="hljs-string">"JavaScript: The Good Parts"</span></span>; book.author = <span class="hljs-string"><span class="hljs-string">"Douglas Crockford"</span></span>; book.getFullTitle();<span class="hljs-comment"><span class="hljs-comment">//JavaScript: The Good Parts by Douglas Crockford</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Heran√ßa m√∫ltipla</font> </h2><br>  O comando <code>Object.assign()</code> copia propriedades de um ou mais objetos para o objeto de destino.  Pode ser usado para implementar v√°rios esquemas de heran√ßa.  Aqui est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authorDataService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookDataService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userDataService = { <span class="hljs-attr"><span class="hljs-attr">getUsers</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, authorDataService, bookDataService, userDataService ); dataService.getAuthors(); dataService.getBooks(); dataService.getUsers();</code> </pre> <br><h2>  <font color="#3AC1EF">Objetos imut√°veis</font> </h2><br>  O comando <code>Object.freeze()</code> permite congelar um objeto.  Voc√™ n√£o pode adicionar novas propriedades a esse objeto.  As propriedades n√£o podem ser exclu√≠das, nem seus valores podem ser alterados.  Ao usar este comando, um objeto se torna imut√°vel ou imut√°vel: <br><br><pre> <code class="hljs pgsql">"use strict"; let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "Functional-Light JavaScript", author : "Kyle Simpson" }); book.title = "Other title";//: Cannot assign <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> property <span class="hljs-string"><span class="hljs-string">'title'</span></span></code> </pre> <br>  O comando <code>Object.freeze()</code> executa o chamado "congelamento superficial" dos objetos.  Isso significa que objetos aninhados em um objeto "congelado" podem ser modificados.  Para realizar um "congelamento profundo" de um objeto, √© necess√°rio "congelar" recursivamente todas as suas propriedades. <br><br><h2>  <font color="#3AC1EF">Clonando Objetos</font> </h2><br>  Para criar clones (c√≥pias) de objetos, voc√™ pode usar o comando <code>Object.assign()</code> : <br><br><pre> <code class="hljs pgsql">let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "JavaScript Allong√©", author : "Reginald Braithwaite" }); let clone = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.assign({}, book);</code> </pre> <br>  Este comando executa c√≥pia superficial de objetos, ou seja, copia apenas propriedades de n√≠vel superior.  Objetos aninhados acabam sendo comuns para objetos originais e suas c√≥pias. <br><br><h2>  <font color="#3AC1EF">Literal do objeto</font> </h2><br>  Literais de objeto fornecem aos desenvolvedores uma maneira simples e direta de criar objetos: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span> : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, }</code> </pre> <br>  No entanto, esse m√©todo de cria√ß√£o de objetos tem desvantagens.  Em particular, com essa abordagem, todas as propriedades do objeto est√£o dispon√≠veis ao p√∫blico, os m√©todos do objeto podem ser redefinidos, eles n√£o podem ser usados ‚Äã‚Äãpara criar novas inst√¢ncias dos mesmos objetos: <br><br><pre> <code class="hljs pgsql">timer.fn;//<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> timer.start = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { console.log("New implementation"); }</code> </pre> <br><h2>  <font color="#3AC1EF">M√©todo Object.create ()</font> </h2><br>  Os dois problemas mencionados acima podem ser resolvidos atrav√©s do uso conjunto dos m√©todos <code>Object.create()</code> e <code>Object.freeze()</code> . <br><br>  Aplicamos essa t√©cnica ao nosso exemplo anterior.  Primeiro, crie um prot√≥tipo congelado <code>timerPrototype</code> que contenha todos os m√©todos necess√°rios para v√°rias inst√¢ncias do objeto.  Depois disso, crie um objeto sucessor do <code>timerPrototype</code> : <br><br><pre> <code class="hljs pgsql">let timerPrototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} }); let timer = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(timerPrototype); timer.__proto__ === timerPrototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Se o prot√≥tipo estiver protegido contra altera√ß√µes, o objeto que √© seu herdeiro n√£o poder√° alterar as propriedades definidas no prot√≥tipo.  Agora, os m√©todos <code>start()</code> e <code>stop()</code> n√£o podem ser substitu√≠dos: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; timer.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"New implementation"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//: Cannot assign to read only property 'start' of object</span></span></code> </pre> <br>  A <code>Object.create(timerPrototype)</code> pode ser usada para criar v√°rios objetos com o mesmo prot√≥tipo. <br><br><h2>  <font color="#3AC1EF">Fun√ß√£o construtora</font> </h2><br>  O JavaScript possui as chamadas fun√ß√µes construtoras, que s√£o "a√ß√∫car sint√°tico" para executar as etapas acima para criar novos objetos.  Considere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; } Timer.prototype = { <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTodos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(getTodos);</code> </pre> <br>  Voc√™ pode usar qualquer fun√ß√£o como construtor.  O construtor √© chamado usando a <code>new</code> palavra-chave.  Um objeto criado usando uma fun√ß√£o de construtor chamada <code>FunctionConstructor</code> receber√° um prot√≥tipo <code>FunctionConstructor.prototype</code> : <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Aqui, para impedir uma altera√ß√£o no prot√≥tipo, novamente, voc√™ pode congelar o prot√≥tipo: <br><br><pre> <code class="hljs pgsql">Timer.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} });</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Palavra-chave novo</font> </h3><br>  Quando um comando do formul√°rio <code>new Timer()</code> √© executado, as mesmas a√ß√µes s√£o executadas como a fun√ß√£o <code>newTimer()</code> executa abaixo: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Timer.prototype); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> returnObj = Timer.call(newObj, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(returnObj) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnObj;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newObj; }</code> </pre> <br>  Um novo objeto √© criado aqui, cujo prot√≥tipo √© <code>Timer.prototype</code> .  Em seguida, a fun√ß√£o <code>Timer</code> √© chamada, configurando os campos para o novo objeto. <br><br><h2>  <font color="#3AC1EF">Palavra-chave da classe</font> </h2><br>  O ECMAScript 2015 introduziu uma nova maneira de executar as a√ß√µes acima, que √© outro lote de "a√ß√∫car sint√°tico".  Estamos falando da palavra-chave da <code>class</code> e das constru√ß√µes relacionadas a ela associadas.  Considere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Timer{ constructor(callback){   this.fn = callback; } <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {} stop() {} } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br>  Um objeto criado usando a palavra-chave da <code>class</code> base em uma classe chamada <code>ClassName</code> ter√° o prot√≥tipo <code>ClassName.prototype</code> .  Ao criar um objeto com base em uma classe, use a <code>new</code> palavra-chave: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  O uso de classes n√£o torna os prot√≥tipos imut√°veis.  Se necess√°rio, eles ter√£o que ser "congelados" da mesma maneira que j√° fizemos: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br><h2>  <font color="#3AC1EF">Heran√ßa baseada em prot√≥tipo</font> </h2><br>  No JavaScript, os objetos herdam propriedades e m√©todos de outros objetos.  As fun√ß√µes e classes do construtor s√£o "a√ß√∫car sint√°tico" para criar objetos prot√≥tipos que cont√™m todos os m√©todos necess√°rios.  Utilizando-os, s√£o criados novos objetos que s√£o herdeiros do prot√≥tipo, cujas propriedades s√£o espec√≠ficas para uma inst√¢ncia espec√≠fica, s√£o definidas usando a fun√ß√£o construtora ou os mecanismos de classe. <br><br>  Seria bom se as fun√ß√µes e classes do construtor pudessem automaticamente tornar os prot√≥tipos imut√°veis. <br><br>  Os pontos fortes da heran√ßa do prot√≥tipo s√£o a economia de mem√≥ria.  O fato √© que um prot√≥tipo √© criado apenas uma vez, ap√≥s o qual todos os objetos criados em sua base o utilizam. <br><br><h3>  <font color="#3AC1EF">Problem O problema da falta de mecanismos de encapsulamento embutidos</font> </h3><br>  O modelo de heran√ßa do prot√≥tipo n√£o usa a separa√ß√£o das propriedades dos objetos em privada e p√∫blica.  Todas as propriedades dos objetos est√£o dispon√≠veis ao p√∫blico. <br><br>  Por exemplo, o comando <code>Object.keys()</code> retorna uma matriz que cont√©m todas as chaves de propriedade do objeto.  Ele pode ser usado para iterar sobre todas as propriedades de um objeto: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //  } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br>  H√° um padr√£o que imita propriedades privadas, contando com o fato de que os desenvolvedores n√£o acessar√£o aquelas propriedades cujos nomes come√ßam com um sublinhado ( <code>_</code> ): <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(callback){   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fn = callback;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._timerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><h2>  <font color="#3AC1EF">Recursos de f√°brica</font> </h2><br>  Objetos encapsulados em JavaScript podem ser criados usando fun√ß√µes de f√°brica.  √â assim: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> TodoStore(callback){   let fn = callback;     <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {},   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> stop() {}     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,      stop   }); }</code> </pre> <br>  Aqui a vari√°vel <code>fn</code> √© privada.  Somente os m√©todos <code>start()</code> e <code>stop()</code> est√£o dispon√≠veis publicamente.  Esses m√©todos n√£o podem ser modificados externamente.  A palavra-chave this n√£o √© usada aqui, portanto, ao usar esse m√©todo de cria√ß√£o de objetos, o problema de perder <code>this</code> contexto √© irrelevante. <br><br>  O comando <code>return</code> usa um literal de objeto contendo apenas fun√ß√µes.  Al√©m disso, essas fun√ß√µes s√£o declaradas em encerramento e compartilham um estado comum.  Para congelar uma API p√∫blica de um objeto, o comando <code>Object.freeze()</code> j√° conhecido √© <code>Object.freeze()</code> . <br><br>  Aqui, nos exemplos, usamos o objeto <code>Timer</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Neste</a> material, voc√™ pode encontrar sua implementa√ß√£o completa. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Em JavaScript, os valores de tipos primitivos, objetos comuns e fun√ß√µes s√£o tratados como objetos.  Os objetos t√™m uma natureza din√¢mica, podem ser usados ‚Äã‚Äãcomo matrizes associativas.  Objetos s√£o herdeiros de outros objetos.  As fun√ß√µes e classes do construtor s√£o "a√ß√∫car sint√°tico", pois permitem criar objetos com base em prot√≥tipos.  Voc√™ pode usar o m√©todo <code>Object.create()</code> para organizar heran√ßa √∫nica e <code>Object.create()</code> para organizar heran√ßa m√∫ltipla.  Voc√™ pode usar as fun√ß√µes de f√°brica para criar objetos encapsulados. <br><br>  <b>Caros leitores!</b>  Se voc√™ veio ao JavaScript de outros idiomas, conte-nos sobre o que voc√™ gosta ou n√£o nos objetos JS, em compara√ß√£o com a implementa√ß√£o de objetos nos idiomas que voc√™ j√° conhece. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420615/">https://habr.com/ru/post/pt420615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420605/index.html">Vis√£o Geral do Algoritmo da Entrevista de Trabalho - Gera√ß√£o de Conjunto</a></li>
<li><a href="../pt420607/index.html">Eventos digitais em Moscou de 20 a 26 de agosto</a></li>
<li><a href="../pt420609/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 327 (13 a 19 de agosto de 2018)</a></li>
<li><a href="../pt420611/index.html">Modelando emaranhamento qu√¢ntico em C #</a></li>
<li><a href="../pt420613/index.html">11 bibliotecas (conjuntos de componentes) para o React Native que voc√™ deve conhecer em 2018</a></li>
<li><a href="../pt420617/index.html">Guia de web design para desenvolvedores</a></li>
<li><a href="../pt420619/index.html">Imagens responsivas: truques CSS que economizam tempo</a></li>
<li><a href="../pt420623/index.html">Aplicativos C ++ distribu√≠dos com um m√≠nimo de esfor√ßo</a></li>
<li><a href="../pt420625/index.html">KDD 2018, primeiro dia, tutoriais</a></li>
<li><a href="../pt420627/index.html">Programa√ß√£o ass√≠ncrona em C #: como voc√™ est√° se saindo com o desempenho?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>