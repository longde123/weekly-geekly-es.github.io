<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíµ ‚ôéÔ∏è üî∞ Le temps est fragment√©; un peu sur la similitude des syst√®mes distribu√©s et un mod√®le de m√©moire faible ‚úíÔ∏è üë©üèª‚Äçüè´ üë®üèø‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! 

 Aujourd'hui, nous aimerions aborder une fois de plus le sujet de l'ex√©cution simultan√©e et s√©quentielle dans divers programmes, en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le temps est fragment√©; un peu sur la similitude des syst√®mes distribu√©s et un mod√®le de m√©moire faible</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/430926/">  Bonjour √† tous! <br><br>  Aujourd'hui, nous aimerions aborder une fois de plus le sujet de l'ex√©cution simultan√©e et s√©quentielle dans divers programmes, en particulier dans les syst√®mes distribu√©s.  En septembre dernier, nous avons publi√© un article ¬´La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">synchronicit√© est un mythe</a> ¬ª sur ce sujet et nous publions maintenant la traduction d'une √©tude plus s√©rieuse qui, nous l'esp√©rons, vous aidera √† mieux naviguer dans les syst√®mes distribu√©s. <br><a name="habracut"></a><br><blockquote>  Il n'y a qu'un seul vrai probl√®me en informatique: admettre que les erreurs d'invalidation du cache sont mal nomm√©es.  Ce ne sont que des erreurs unitaires li√©es √† l'utilisation du temps. </blockquote> - Auteur inconnu <br><br>  Le temps est une chose √©trange. <br><br>  Cette fois est si √©trange, parce que nous voulons vraiment, vraiment croire qu'elle est compl√®tement rationalis√©e.  Il nous semble que tout √©v√©nement √† 15h00 se produit (comme nous le dirions) avant tout √©v√©nement √† 16h00 - sans exceptions, arguments ou compromis. <br><br>  Cependant, l'informatique conna√Æt de nombreux exemples lorsqu'il est n√©cessaire d'aborder cette exigence de mani√®re moins stricte.  Il se manifeste au niveau des processeurs, des compilateurs, des n≈ìuds de r√©seau.  Encore et encore dans les calculs, √† diff√©rents niveaux de la pile, nous nous retrouvons dans des situations o√π nous sommes confront√©s √† deux √©v√©nements, et nous ne savons pas dans quel ordre ils se sont produits.  Le temps n'est √©videmment pas total;  elle est fragment√©e. <br><br>  Pourquoi?  Le fait est que nous ne le savons pas, car le niveau d'abstraction sur lequel nous existons ne fournit pas de r√©ponse √† cette question.  Qu'elle soit accidentelle ou non, nos abstractions de calcul ne donnent aucune garantie quant √† la proc√©dure.  La libert√© de r√©organiser les √©v√©nements vous permet souvent de cr√©er des syst√®mes beaucoup plus productifs et abordables. <br><br>  Le processeur peut avoir un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le de commande de m√©moire</a> ;  il refl√®te les garanties que le processeur ne veut pas vous donner de garanties au stade de l'assemblage - par exemple, quelle instruction a √©t√© ex√©cut√©e plus t√¥t et laquelle plus tard.  Le processeur d√©cide exactement comment transmettre les instructions et les ex√©cute dans le d√©sordre - c'est-√†-dire qu'il utilise ses puces plus efficacement que je ne l'aurais pens√©. <br><br>  Un langage peut avoir un <i>mod√®le de correspondance de m√©moire</i> (¬´mod√®le de m√©moire¬ª pour faire court);  il refl√®te les garanties que le langage ne vous donne pas lors de la g√©n√©ration d'un assembly, par exemple, lors de la distribution d'instructions sur plusieurs threads.  Une telle r√©organisation est par d√©finition inh√©rente au mod√®le mat√©riel de la m√©moire et explique dans une large mesure pourquoi un tel concept de temps ¬´faible¬ª est fourni dans les compilateurs.  C'est dans le cadre d'un tel mod√®le de m√©moire impl√©ment√© dans le langage que vous programmez lorsque vous √©crivez du code non bloquant. <br><br>  Un exemple c√©l√®bre d'un mod√®le de m√©moire impl√©ment√© au niveau du langage est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le de m√©moire forte et faible</a> dans la norme C ++ 11.  Par d√©faut, C ++ fournit des op√©rations atomiques avec synchronisation, mais il peut √©galement affaiblir le mod√®le d'acc√®s √† la m√©moire pour am√©liorer les performances.  Le comportement ainsi fourni est destin√© √† servir d'abstraction aux principales architectures de processeur utilis√©es aujourd'hui (x86, POWER et ARM). <br><br>  Enfin, un syst√®me distribu√© peut avoir son propre mod√®le de coh√©rence;  il refl√®te les garanties que le syst√®me ne va pas vous donner concernant l'ordre des √©v√©nements sur les clients et les r√©pliques du r√©seau informatique mondial.  Les r√©ordonnances qui sont directement li√©es √† la latence de communication ou au manque de synchronisation expliquent principalement pourquoi dans un syst√®me distribu√©, vous ne pouvez pas vous passer du mod√®le de temps faible mentionn√©.  C'est ce mod√®le de coh√©rence que vous programmez lorsque vous √©crivez une application distribu√©e. <br><br>  Dans la pratique, il existe un √©norme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">zoo</a> de mod√®les de coh√©rence que vous pouvez utiliser lors de la programmation d'un syst√®me distribu√©.  Dans toutes ces situations, ces mod√®les d√©crivent le comportement (souhait√©) du syst√®me observ√© de l'ext√©rieur de ce syst√®me.  Si je - un client ou un flux sp√©cifique - √©cris une valeur, puis la lis imm√©diatement, est-il garanti que je verrai d√©finitivement un enregistrement pas plus ancien que le mien?  Si le temps n'√©tait pas fragment√©, si nous avions toujours une id√©e claire de l'ordre dans lequel se d√©roulent les op√©rations dans notre syst√®me - naturellement, la r√©ponse √† cette question serait affirmative.  Il serait √©trange de poser une telle question. <br><br>  Mais le temps est fragmentaire - il est donc n√©cessaire de soulever une telle question. <br><br><h4>  Mod√®les de coh√©rence - je veux dire, mod√®les de m√©moire </h4><br>  Parler d'un ordre aussi fragment√© est souvent difficile et toujours d√©sagr√©able.  Nous voudrions partir du fait qu'√† tous les niveaux de la pile, le temps est toujours absolument absolu - que ce soit avec des transactions ACID ou des op√©rations / verrous atomiques.  Plus les garanties sont strictes, plus il est naturellement facile de programmer avec elles! <br><br>  Mais nous aspirons tous √† la vitesse.  Qu'il s'agisse de syst√®mes distribu√©s o√π il est n√©cessaire de sacrifier une coh√©rence stricte pour des raisons de disponibilit√©, ou de programmation non bloquante, o√π un mod√®le de m√©moire faible est utilis√© pour √©viter les co√ªts de synchronisation, il est g√©n√©ralement conseill√© pour un programmeur travaillant avec n'importe quel niveau de la pile d'aller dans ces arguments complexes. . <br><br>  La coh√©rence des mod√®les de m√©moire partag√©e et la coh√©rence des mod√®les de m√©moire distribu√©e sont toutes deux <i>abstraites</i> .  Ils d√©crivent le programmeur travaillant avec le syst√®me, l'interface de ce syst√®me.  Ils permettent de comprendre quels types de comportements correspondent √† un mod√®le de m√©moire faible, √©tant donn√© que les propri√©t√©s g√©n√©rales de l'ordre des √©v√©nements dans le syst√®me, que nous tenons pour acquis, n'y agissent plus.  Il peut sembler que ces deux mod√®les de m√©moire sont similaires, cependant, les deux communaut√©s ont d√©velopp√© leurs propres discours de discussion.  Les valeurs utilis√©es diff√®rent, bien qu'elles se chevauchent. <br><br>  Nous imaginons d√©j√† √† quel point cela peut √™tre confus.  Que faire? <br><br><h4>  Description du temps en tant qu'entit√©, impliquant entre deux et huit types d'ordre partiel </h4><br>  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">son livre de 2014,</a> Sebastian Burkhardt cherche √† fournir une description exhaustive des nombreuses options de mod√®les de coh√©rence.  Avec cette caract√©ristique, ainsi que d'autres structures math√©matiques, deux variantes de l'ordre logique des √©v√©nements sont utilis√©es: ¬´visibilit√©¬ª et ¬´arbitrage¬ª, pr√©c√©demment √©galement mentionn√©es dans d'autres travaux de Burkhardt et al, voir, par exemple, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> sur le pointage et la v√©rification types de donn√©es r√©pliqu√©es (2014). <br><br>  La ¬´visibilit√©¬ª est un ordre partiel inh√©rent au conditionnement potentiel.  Il vous permet de suivre quels √©v√©nements (√©ventuellement dans d'autres r√©pliques) sont visibles pour quels autres √©v√©nements.  Il n'y a aucune exigence de visibilit√© autre que l'acyclicit√©;  les √©v√©nements d'un objet peuvent √™tre visibles par les √©v√©nements d'un autre objet, et l'op√©ration de lecture ou d'√©criture d'un √©v√©nement n'affecte pas sa visibilit√© pour les autres √©v√©nements. <br><br>  ¬´L'arbitraire¬ª est un ordre g√©n√©ral qui vous permet de suivre comment un syst√®me distribu√© dans lequel une situation de choix se produit jugera quel √©v√©nement se produit plus t√¥t et lequel plus tard. <br><br>  √âtant donn√© que les mod√®les de coh√©rence distribu√©e sont similaires aux mod√®les de m√©moire, il s'av√®re que de tels ph√©nom√®nes de visibilit√© et d'al√©atoire peuvent √©galement √™tre utiles lors de l'examen des mod√®les de m√©moire.  En particulier, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans l'annexe de son article de 2014,</a> Burkhardt d√©montre "√† quel point" le mod√®le de m√©moire faible de C ++ 11 est √† la coh√©rence objet par causalit√©, mais avec quelques √©carts int√©ressants.  Cela sera discut√© dans la suite de l'article. <br><br>  Pour commencer, √©toffons la visibilit√© et l'al√©atoire, en tenant compte de la ¬´lecture¬ª et de ¬´l'ordre des changements¬ª.  Lors de la ¬´lecture¬ª, la visibilit√© entre deux objets quelconques ne sera prise en compte que dans les situations o√π la lecture et l'√©criture touchent le m√™me objet, et lors de la lecture d'un seul enregistrement (ou plusieurs) peut √™tre visible. <br>  Cela correspond √† une situation dans laquelle un processeur avec une m√©moire partag√©e √† un moment donn√© peut enregistrer des informations dans une seule cellule de m√©moire pour un objet particulier, m√™me si diff√©rents threads peuvent y acc√©der √† diff√©rents moments de cause √† effet (d'autre part, dans un syst√®me distribu√©, la logique un objet peut √™tre enregistr√© imm√©diatement dans de nombreuses r√©pliques distinctes). <br><br>  L '¬´ordre de modification¬ª correspond √† la m√™me √©tape de concr√©tisation de l'arbitraire, il est objectif et ne permet que des enregistrements.  Encore une fois, cette sp√©cialisation est bas√©e sur le fait qu'avec une sp√©cification de m√©moire faible, les garanties cat√©gorielles ne sont donn√©es qu'au niveau d'un objet. <br><br>  Ensuite, discutons des axiomes de coh√©rence formul√©s par Burkhardt et al. Et voyons comment ils s'appliquent √† un mod√®le de m√©moire faible.  Remarque: m√™me en d√©pit du mot ¬´axiomes¬ª, ce sont simplement des propri√©t√©s qui peuvent ou non √™tre fournies dans divers mod√®les de m√©moire.  L'article de Burkhardt se concentre sur les propri√©t√©s qui d√©terminent la causalit√© inter-objets. <br><br><h4>  La coh√©rence finalement </h4><br>  Pour un √©v√©nement particulier, il ne peut y avoir un nombre ind√©fini d'√©v√©nements qui ne le voient pas.  Autrement dit, tout √©v√©nement <i>est finalement</i> visible pour le syst√®me. <br><br>  La construction logique de telles conditions dans un syst√®me avec un mod√®le de m√©moire faible devrait √™tre un peu plus difficile: il faut soutenir que pour un <i>enregistrement</i> particulier <i>,</i> il ne peut pas y avoir un nombre infini d'op√©rations de lecture qui ne liraient pas cet enregistrement ou des enregistrements ant√©rieurs (dans l'ordre de modification). <br><br>  Dans la sp√©cification C ++ 11, la conformit√© √† cet axiome n'est pas garantie, bien qu'en pratique il soit difficile de trouver un contre-exemple. <br><br><h4>  Coh√©rence √©th√©r√©e </h4><br>  Lors du suivi de la ¬´conditionnalit√© potentielle¬ª au niveau des flux / op√©rations client et en ce qui concerne la visibilit√© / lisibilit√©, vous devez comprendre qu'il n'y a pas de temps de retour.  C'est pourquoi il est n√©cessaire que les fermetures lors de la commande des flux impliquant une lecture soient acycliques.  En r√®gle g√©n√©rale, il ne fait aucun doute que cette propri√©t√© sera observ√©e dans les syst√®mes distribu√©s, mais c'est cette propri√©t√© qui ne permet pas la visibilit√© de l'utilisateur dans certaines versions sp√©culatives si le syst√®me a un mod√®le de m√©moire faible. <br><br>  Burkhardt et al soulignent que cet axiome n'est "pas confirm√©" dans la sp√©cification C ++ 11, et il n'est pas clair "ne valide pas" si "des cycles satisfaisants" peuvent √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">observ√©s dans la pratique</a> . <br><br><h4>  Axiomes de conditionnalit√© </h4><br>  Pour sp√©cifier exactement √† quoi le ph√©nom√®ne de conditionnalit√© se rapporte dans un mod√®le de m√©moire faible, nous devons d√©terminer pr√©cis√©ment quels √©v√©nements peuvent influencer les r√©sultats de quels autres √©v√©nements.  Pour commencer, consid√©rons nos axiomes de cause √† effet standard: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">garanties de session</a> .  Ce sont quatre qualit√©s interd√©pendantes refl√©tant les propri√©t√©s de coh√©rence des op√©rations de lecture et d'√©criture qui se produisent dans diff√©rents flux, de plus, elles doivent √™tre sp√©cifi√©es au niveau de chaque objet (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Burkhardt et al</a> ., <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fig.23</a> ). <br><br><ul><li>  RYW (Lire vos enregistrements): l'op√©ration de lecture suivant l'op√©ration d'√©criture se fait dans la m√™me cellule, au sein du m√™me flux / r√©plique / session, elle doit lire des donn√©es non moins pertinentes que l'enregistrement.  La variante de cette propri√©t√© pour les syst√®mes distribu√©s est sp√©cifi√©e exclusivement en termes de visibilit√©, tandis que la variante pour un mod√®le de m√©moire faible doit √™tre bas√©e √† la fois sur l'ordre de lecture et sur l'ordre de changement. </li><li>  RM (lectures monolithiques): les lectures suivantes (dans le m√™me flux, dans la m√™me cellule) devraient √©galement voir des donn√©es non moins pertinentes √† l'avenir. </li><li>  WFR (d'abord lu, puis √©crit): si l'√©criture suit la lecture dans le flux, dans la m√™me cellule, alors dans l'ordre des changements elle devrait aller plus tard que l'op√©ration de lecture. </li><li>  MW (Monolithic Records): les enregistrements ult√©rieurs (au sein du flux, dans la m√™me cellule) devraient aller plus tard dans l'ordre de modification. </li></ul><br>  Les versions originales de WFR et MW existent en deux versions, pour le hasard et la visibilit√©;  mais cela n'est important que lorsque vous travaillez avec des cellules de donn√©es plus complexes qu'avec des registres d'entiers. <br><br>  Ces propri√©t√©s refl√®tent les notions de conditionnalit√©, conformes √† notre bon sens;  cependant, ils manquent le plus int√©ressant.  En particulier, lors de l'analyse dans un mod√®le de m√©moire faible, ces ph√©nom√®nes de conditionnalit√© sont limit√©s par les limites du flux / r√©plique / session et de la cellule / objet sp√©cifique o√π l'entr√©e est effectu√©e: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un article de Burkhardt et al</a> .  dans ce cas, on parle de ¬´visibilit√© conditionnelle objet par condition¬ª et ¬´arbitraire arbitraire objet par condition¬ª, voir √©galement fig.  23. Ces ph√©nom√®nes ne limitent pas compl√®tement le comportement du syst√®me lorsque diff√©rents flux √©crivent des informations dans diff√©rentes cellules. <br><br>  Ensuite, les axiomes du conditionnement inter-objets d√©crivent l'effet des relations de cause √† effet au niveau de divers objets / cellules de m√©moire. <br><br><ul><li>  COCV (Cross-Object Conditional Visibility): le m√™me cas que RYW, mais sans la condition que la lecture finale doit √™tre faite tout dans le m√™me thread / r√©plique / session.  Les lectures d'un objet qui sont objectivement post√©rieures aux enregistrements de cet objet devraient prendre des donn√©es non moins pertinentes que celles entr√©es lors de l'enregistrement. </li></ul><br>  La sp√©cification C ++ 11 refl√®te ces propri√©t√©s.  Veuillez noter: ils sont d√©finis de telle mani√®re que les restrictions sur la visibilit√© de l'enregistrement et l'arbitraire de l'ordre de modification ne refl√®tent pas trop ces d√©finitions. <br><br>  Mais cela ne s'applique pas √† cette derni√®re propri√©t√©. <br><br><ul><li>  COCA (Cross-Object Conditional Arbitrary): similaire aux enregistrements monolithiques, mais s'applique √† diff√©rents flux, similaire au COCV - c'est RYW pour diff√©rents flux.  Cependant, √©tant donn√© que l'ordre de modification n'affecte que les enregistrements d'un seul objet, la formulation d'un mod√®le de m√©moire faible permet au syst√®me d'avoir une distribution incoh√©rente des √©v√©nements d'enregistrement dans diff√©rents objets, et les enregistrements peuvent ne correspondre ni aux lectures ni √† l'ordre √† l'int√©rieur du flux. </li></ul><br>  Plus pr√©cis√©ment, COCA dans un mod√®le de m√©moire faible est une propri√©t√© beaucoup plus faible.  C'est pourquoi avec un mod√®le de m√©moire faible, le code suivant peut retourner <code>{x ‚â° 0, y ‚â° 0}</code> . <br><br> <code>Thread A: y := 0; x := 1; return x <br> Thread B: x := 0; y := 1; return y</code> <br> <br>  L'ordre dans chaque flux peut √™tre incompatible avec l'ordre objet par ordre et l'ordre de modification.  Attention: avec RYW il n'y a pas <code>x := 0 ‚Üí x := 1</code> dans l'ordre de modification et pour <code>y</code> la m√™me chose;  ainsi, l'ordre de modification doit contenir <code>x := 1 ‚Üí x := 0</code> et <code>y := 1 ‚Üí y := 0</code> .  Ainsi, l'ordre de modification forme √©videmment un cycle dans l'ordre des flux. <br>  Une telle boucle est autoris√©e dans COCA avec un mod√®le de m√©moire faible.  Ce n'est pas que l'ordre des flux / lectures est contraire √† l'ordre de modification, mais que chaque flux voit un historique d'enregistrement coh√©rent.  Ces histoires ne sont coh√©rentes avec les histoires d'autres flux que si nous limitons objectivement la port√©e de leur application. <br><br><h4>  Qu'est-ce que tout cela signifie? </h4><br>  Le temps est fragment√©. <br><br>  M√™me s'il nous semble que le temps s'√©coule de mani√®re tr√®s ordonn√©e, l'√©tude des syst√®mes distribu√©s et d'un mod√®le de m√©moire faible vous montre clairement que ce n'est pas le cas.  C'est pourquoi dans ces deux situations, notre sur-approximation standard, selon laquelle le temps est total, limite les performances - que nous ne pouvons pas nous permettre. <br>  Puis, reconnaissant que le temps est vraiment fragment√©, nous trouvons de nombreuses petites mais importantes diff√©rences entre les vari√©t√©s d'une telle partialit√©.  M√™me les deux domaines mentionn√©s ci-dessus, qui semblent si similaires √† premi√®re vue, dans de nombreuses nuances subtiles, permettent de distinguer quels types particuliers d'√©v√©nements sont consid√©r√©s comme affectant mutuellement. <br><br>  Il est n√©cessaire de comprendre plus en d√©tail les d√©tails techniques de diverses propri√©t√©s d√©j√† apr√®s que quelqu'un puisse exprimer les propri√©t√©s d'un champ dans la langue d'un autre. <br><br>  Le temps est fragment√©.  Peut-√™tre que nous devons juste nous y habituer. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430926/">https://habr.com/ru/post/fr430926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430914/index.html">Analyse des prix du march√© noir pour les donn√©es personnelles et perc√©e</a></li>
<li><a href="../fr430916/index.html">D√©tecteur de dioxyde de carbone MT8057S. Non-r√©vision avec la participation d'un non-√©mulateur</a></li>
<li><a href="../fr430918/index.html">√Ä propos de Flutter, en bref: les bases</a></li>
<li><a href="../fr430922/index.html">Exemple de calcul pour standard t√©l√©phonique</a></li>
<li><a href="../fr430924/index.html">Programmation Ada</a></li>
<li><a href="../fr430928/index.html">√Ä propos de la "maison intelligente": comment cr√©er un r√©tro-√©clairage "intelligent"</a></li>
<li><a href="../fr430930/index.html">√Ä propos des graphiques 3D en mots simples</a></li>
<li><a href="../fr430932/index.html">Les pirates ont vol√© plus de 21 millions de roubles d'une banque russe</a></li>
<li><a href="../fr430934/index.html">G√©n√©rateur de masque d'extension de plan de num√©rotation Asterisk</a></li>
<li><a href="../fr430936/index.html">DEFCON 21. La conf√©rence DNS peut √™tre dangereuse pour votre sant√©. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>