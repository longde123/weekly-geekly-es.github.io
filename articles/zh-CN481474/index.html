<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏻 🕵🏻 👨🏽‍🚀 我们来自另一个测试-我们正在测试MSTest上的数据库 👨‍👧‍👧 🧚🏽 👨🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="作为通用原则进行测试 
 我们已经庆祝千年了将近25年，并且测试才刚刚进入我们的生活...很难说服新手开发人员在他们的工作中使用这种惊人的技术...我们对开发人员的看法，仅仅是凡人，而且并非总是可以理解测试是基础可持续发展的系统！ 说服售货员测试新产品并不意味着要吃新产品是多么困难！ 即使是经验丰富...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们来自另一个测试-我们正在测试MSTest上的数据库</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481474/"><h4> 作为通用原则进行测试 </h4><br> 我们已经庆祝千年了将近25年，并且测试才刚刚进入我们的生活...很难说服新手开发人员在他们的工作中使用这种惊人的技术...我们对开发人员的看法，仅仅是凡人，而且并非总是可以理解测试是基础可持续发展的系统！ 说服售货员测试新产品并不意味着要吃新产品是多么困难！ 即使是经验丰富的保安人员，显然也采用老式的方法-他们试图追赶并选择测试。 而且您不会向他们证明，如果主上帝本人不鄙视在其工作中使用TDD（请记住大洪水），那么正如他们所说，上帝本人已下令... <br><br> 离婚人数在增加-为什么？ 是的，都一样！  TDD！ 先测试-然后结婚！ 不，穿着宽松的羊皮大衣的轻信小矮人，热衷于色情广告，正把他们的年轻妻子推向生产... <br><br> 好吧，我们与您一起进行另一项测试，首先是测试-然后是其他一切！ <br><br><h4> 我通过步态认出测试员... </h4><br> 因此，当我开始编写下一个代码优先的数据库时，我想到了，为什么不直接在VisualStudio内置的测试中对DAL层进行自动测试呢？ <br><br> 而我做到了！ 对EntityFramework透明，没有任何掩饰，也没有伪造物品的欺诈行为。 谁在乎-揭露VS，穿上像测试员一样的衣服，走吧！  （我总是打扮得像个测试员） <br><br><div class="spoiler">  <b class="spoiler_title">测试服</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tg/pv/kw/tgpvkwgvjzb4zf7tt-navdbcazi.jpeg" alt="图片"><br></div></div><a name="habracut"></a><br><h4> 对所有人说谎，这是测试！ </h4><br><div class="spoiler">  <b class="spoiler_title">生活案例：</b> <div class="spoiler_text"> 使用以下代码处理了一个项目： <br><br><pre><code class="plaintext hljs">ObjectLink link = this.ObjectLinks.ToList().Where(x =&gt; x.SpotCode.ToLowerInvariant() == code.ToLowerInvariant()).SingleOrDefault();</code> </pre> <br> 该代码未包含在测试中，因为它没有时间-迫切需要启动与营销相关的新功能。 手动检查时一切正常，我已经放松了……但是比尔·盖茨却没有引起注意…… <br><br> 那是一个充满诗意的圣彼得堡秋天，雪和雨轻轻抚摸着我的脸，污垢从裤子的腿上快乐地流下来，陌生的女孩笑着穿过铺开的化妆品，路过的卡车倒了……我已经去过我的手指在鼻子里刺了一下，那时它是危险的，没有宣战，之前黎明时分，微软切断了铁丝网，并发布了核心3.0更新。 托管人已经更新，我也进行了更新，为什么要使用旧的托管人-我比托管人还差吗？ 我检查了所有类似内容并推出了更新程序……然后我露出了眼睛！ 新功能不起作用！ 似乎我之前已经测试过了-会发生什么？ <br><br> 这就是发生的事情：旧的Billy决定从LINQ ToLowerInvariant中删除它...现在您需要提前调用它并插入完成的值...如果代码包含测试，在测试时我会立即注意到它。 很好的是，我本人注意到了所有内容，而不必向客户发誓，因为测试人员为羞于脸红而感到羞愧……我必须解决问题并重新进行部署。 <br></div></div><br><h4> 设备和材料： </h4><br>  Microsoft VisualStudio 2019 <br>  asp.net Core 3.1（我可以在Studio中安装它，如果可以通过安装其他框架项目菜单进行交付） <br>  SQL Server Express（随Studio附带） <br>  Git对Visual Studio的扩展（包括） <br><br> 通常，在单元测试中，每个测试都应该隔离，并且它们之间的状态不会持久。 因此，我们实际上将获得集成测试，但是我们将为此使用MSTest。 希望他们不要为此而带我们去警察。 <br><br> 在多个版本中，我遇到了使用Mock对象测试数据库的情况。 <br> 乍一看，这个想法是好的，直到表之间开始复杂的交互。 <br> 然后，设置模拟将比测试自身花费更多。 但实际上它是-Control + C-Control + V！ 我们都是已经在模拟层中的EF，数据库，DataAnnotations或FluentAPI副本中注册的数据库约束。 复制有点像破坏模式……是的，公民，破坏……不好！ <br><br> 而且，如果模拟配置很复杂，例如我们在这里的限制中犯了错误，那么事实证明-模拟测试将通过，但是真正的基础上会有错误吗？ <br><br> 这一切都使我感兴趣，因此我决定测试一种新方法。 <br><br> 这个想法一如既往地来自TRIZ： <i>理想的系统虽然不存在，但其功能得以实现</i> 。 而且我认为我需要在测试中使用数据库本身。 <br> 这对我来说是可行的。 我想分享一下，希望有人帮忙。 <br><br> 模拟的缺点： <br><br><ul><li> 许多预设可以测试 </li><li> 测试变得肮脏，很多额外的代码 </li><li> 难以测试迁移 </li><li> 只有在监督下才能表现良好，实际上会产生未知错误 </li><li> 当更改数据库的结构时，您需要不断地进入模拟并在那里进行所有更改 </li></ul><br> 实际测试的优点： <br><br><ul><li> 该程序的行为与战斗服务器上的行为完全相同 </li><li> 测试更简单，您可以以相同的方式在数据库中填充数据，一个接一个地构建它们 </li><li> 我们自己可以通过对测试进行编号来调整数据库的清洁度（在MSTest中，它们是按字母顺序执行的） </li><li> 您可以看到执行测试的时间（在真实服务器上会有所不同，但是至少可以看到顺序-更长10倍，两倍），并且您已经可以评估程序的工作效率（有效或无效） </li><li> 可以测试存储过程 </li></ul><br> 我一直在研究这种方法，但这种方法存在一些困难，但是我们将成功解决这些问题，并且我的坚强后盾将与您同在！ <br><br> 走吧 <br><br> 我们创建一个新项目ASP.Net Core 3.1 Web应用程序（模型-视图-控制器），将身份验证更改为单个用户帐户（在应用程序中存储用户帐户），然后单击创建 <br><br><img src="https://habrastorage.org/webt/n1/oq/5c/n1oq5cv0fxxqnuu0sdgdwda7xem.jpeg" alt="图片"><br><br> 从现在开始，我将项目快照保存到git中，您可以下载并上传每个分支以进行实验 <br><br>  <a href="https://github.com/3263927/Habr_1" rel="nofollow">github.com/3263927/Habr_1</a> <br><br>  <b>快照：Snapshot_0_Project已创建</b> <br><br><div class="spoiler">  <b class="spoiler_title">关于仓库</b> <div class="spoiler_text"> 即使我一个人工作，我也总是使用存储库-现在它变得非常方便，可以直接内置到Visual Studio中，无需命令行，一切都可以从VS正常运行。 您可以尝试并更改所需的任何内容，然后始终可以修复提交回滚或切换到旧分支。 我建议大家节省很多时间和精力。 并免费与github集成。 没错，几年前那里有些老兄删除了所有内容...因此，以防万一，我将所有项目放入Dropbox，每周更新一次，并存档所有项目，然后手动将最新版本上传到Google云端硬盘。 好吧，在SD电话上有120个演出，在突然之间突然出现了储备……几个口袋里有副本的闪存驱动器实在是看不见了！ <br></div></div><br> 至此，我已经创建了一个存储库，因此现在我需要计划创建新分支的工作。 将来，使用Snapshot关键字可以在出现问题时找到恢复点。 <br><br> 我将直接从VisualStudio在存储库中创建一个新分支，并将其简称为“人才之姐妹”（笑话，Snap_1_DataBases）。 <br><br>  <b>目标：建立有效的联系和基础</b> 。 <br><br> 我们开始建立我们的基地。 <br><br> 我必须马上说，我们将有3个数据库-一个测试（在本地计算机上），另一个生产（在远程服务器上，正在运行），另一个在本地工作（以在DEBUG配置中检查站点的运行状况）。 <br><br> 逻辑是这样的： <br><br><ul><li> 如果我们想在本地计算机上运行该站点并查看其工作方式，那么Habr1_Local将为我们工作 </li><li> 如果我们将代码投入生产，那么Habr1_Production将起作用 </li><li> 当我们的测试基础架构开始测试时，它必须找到Habr1_Test基础并运行它 </li></ul><br> 但是，我们有一个矛盾-只有两种配置，即Debug和Release。 这仍然是一个问题，但是它将得到解决。 <br><br> 因此，我们创建了一个最低限度的程序-首先，我们只是检查是否至少有一个数据库对我们有用。 让我们用Visual Studio本身创建它吧！ <br><br> 打开appsettings.json文件 <br><br> 有以下几行： <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"ConnectionStrings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"DefaultConnection"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server=(localdb)\\mssqllocaldb;Database=aspnet-WebApp-[- ,   ];Trusted_Connection=True;MultipleActiveResultSets=true"</span></span> },</code> </pre> <br> 在那里，您需要输入正确的连接字符串名称，服务器名称和数据库名称。 我必须马上说在生产中使用其他连接，但是现在我们不需要了。 我们的任务是创建两个数据库（本地数据库和测试数据库，生产只是一个示例-将在发布配置中使用。然后可以用运行中的远程数据库代替）。 <br><br> 为什么需要这个？ <br><br>  Visual Studio配置允许您通过在Visual Studio面板中切换配置来更改某些设置： <br><br><img src="https://habrastorage.org/webt/qa/8k/nr/qa8knrxqxt8komoewxxf-b-s2qs.jpeg" alt="图片"><br><br> 通常，开发环境只声明一个DEBUG常量，然后可以从代码中的任何位置读取该常量，并了解我们当前所处的配置，哪个配置处于活动状态。 <br><br> 远程调试器并非始终可用，例如在托管主机上。 我们可以在本地运行asp.net服务器，然后将数据库连接到远程服务器，然后可以看到生产中的所有错误。 在发行版配置中，我们将执行此操作，并且调试配置将与我们的本地数据库一起使用。 而且出于安全原因，我们不会进行测试配置-为了避免意外删除任何数据，而忘记切换配置 <br><br> 因此，我们开始更改连接字符串。 <br><br> 服务器名称-您可以在选项卡视图中看到它-&gt; SQL Server对象资源管理器 <br><br><img src="https://habrastorage.org/webt/mk/-1/tc/mk-1tcplz6dtcpzupszdzpesh84.jpeg" alt="图片"><br><br>  （我会谨慎删除计算机的名称，否则，您将通过IP计算我的计算机并输入一些内容）。 <br><br> 所以我有这个（localdb）\ ProjectsV13。 我不知道为什么，在安装过程中我调用了SQL。 <br> 这意味着我们的连接字符串正在变成 <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"DefaultConnection"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server=(localdb)\\ProjectsV13;Database=Habr1_Local; Trusted_Connection=True;MultipleActiveResultSets=true"</span></span></code> </pre> <br> 您可能有所不同，但只有ProjectV13。 其余的应该这样保留。 <br> 将DefaultConnection更改为Habr1_Local <br><br> 原来是这样的： <br><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"ConnectionStrings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Habr1_Local"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server=(localdb)\\ProjectsV13;Database=Habr1_Local;Trusted_Connection=True;MultipleActiveResultSets=true"</span></span> },</code> </pre> <br> 现在，您需要转到Startup.cs文件，并在其中用Habr1_Local替换DefaultConnection： <br><br><pre> <code class="cs hljs">services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt; options.UseSqlServer(Configuration.GetConnectionString(<span class="hljs-string"><span class="hljs-string">"DefaultConnection"</span></span>)));</code> </pre> <br> 变成 <br><br><pre> <code class="cs hljs">services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt; options.UseSqlServer(Configuration.GetConnectionString(<span class="hljs-string"><span class="hljs-string">"Habr1_Local"</span></span>)));</code> </pre><br> 我们在Debug配置中启动我们的项目，浏览器打开，我们看到第一页，单击Login按钮，在此处输入任何有效的电子邮件（它将不向您发送字母，它只是验证格式），然后单击Login-，我们看到此屏幕： <br><br><img src="https://habrastorage.org/webt/p3/u3/r4/p3u3r4gkdanievaornpxfxwoous.jpeg" alt="图片"><br><br> 单击“应用迁移”，我们等待等到蓝色按钮右侧出现确认迁移已通过且您需要刷新页面，更新，单击“确认”以重新发送数据并显示“登录失败”的屏幕时，确认： <br><br><img src="https://habrastorage.org/webt/fc/sw/pc/fcswpc-tqd0gyuhz70cyefi9uls.jpeg" alt="图片"><br><br> 如果可以看到这样的屏幕，则一切正常-一旦请求通过并返回了无效的登录尝试，那么就没有数据库错误，但是根本找不到这样的用户。 <br><br><div class="spoiler">  <b class="spoiler_title">关于迁移的一点：</b> <div class="spoiler_text"> 这是一个复杂的工具，在本文中几乎没有必要触摸它，但是您可以稍微触摸一下。 <br> 例如，您需要将数据库的状态更改为特定状态-您可以为此创建数据库快照，或为每种状态创建多个快照，然后以编程方式和使用特殊命令启用/禁用这些映像。 <br><br> 或者，当您在本地计算机上进行开发时，然后需要将服务器上数据库的新状态与本地服务器上的新状态同步，将生产服务器更新为其本地数据库的状态并自动执行-您还可以应用迁移。 这实际上是这个蓝色按钮。 该库知道其状态与代码状态不同，并正在尝试同步这些状态。 为此，将在数据库中创建一个特殊表，其中包含数据库结构的编码状态。 <br><br> 不幸的是，该工具由于没有可视界面而变得复杂，因此您需要从命令行使用它。 当您需要通过Git传递状态时，使用迁移非常方便-只需创建数据库快照（如C＃文件）即可。 但是此工具有一个危险-如果配置不正确，它可能会擦除数据库中的数据，因此应谨慎使用。 <br></div></div><br> 检查数据库的可用性-Visual Studio应该已经创建了它 <br><br><img src="https://habrastorage.org/webt/op/6i/c_/op6ic_e4cdoarqotsmz441fkmkc.jpeg" alt="图片"><br><br> 如果没有数据库，那就出了问题–要么没有安装SQL Server，要么总的来说是其他什么，就像在开玩笑说程序员是否是医生一样：“医生，我的腿很痛……-好吧，不是我知道，我有一条相同的腿，没有受伤！” <br><br> 此时，我再创建两个连接字符串，appsettings.json采用以下形式： <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"ConnectionStrings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Habr1_Local"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server=(localdb)\\ProjectsV13;Database=Habr1_Local;Trusted_Connection=True;MultipleActiveResultSets=true"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Habr1_Test"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server=(localdb)\\ProjectsV13;Database=Habr1_Test;Trusted_Connection=True;MultipleActiveResultSets=true"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Habr1_Production"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server=(localdb)\\ProjectsV13;Database=Habr1_Production;Trusted_Connection=True;MultipleActiveResultSets=true"</span></span> },</code> </pre><br> 我进行提交，并将以下快照放入存储库中： <br><br>  <b>快照：Snap_1_DataBases</b> <br><br> 创建一个新分支，Snap_2_Configurations <br><br>  <b>目标：创建工作配置</b> <br><br> 在切换配置时，我们可以从程序中的任何地方考虑当前的配置（实际上，不是任何配置，在View中都无法使用-我们需要做一个特殊的功能，但这对这个项目并不重要）： <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DEBUG  DEBUG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta">  RELEASE ( DEBUG   ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br> 打开Startup.cs文件，并将ConfigureServices方法转换为此： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { String ConnStr = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DEBUG ConnStr = "Habr1_Local"; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> ConnStr = "Habr1_Production"; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt; options.UseSqlServer( Configuration.GetConnectionString(ConnStr))); services.AddDefaultIdentity&lt;IdentityUser&gt;(options =&gt; options.SignIn.RequireConfirmedAccount = true) .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;(); services.AddControllersWithViews(); services.AddRazorPages(); }</span></span></code> </pre><br> 如您所见，我们用变量替换了Habr1_Local，现在根据配置，连接字符串将为Habr1_Local或Habr1_Production <br><br> 现在，您可以启动项目并检查如何根据配置创建数据库 <br><br> 我们在面板上选择DEBUG，开始，登录，应用迁移，并检查数据库是否已创建（Habr1_Local） <br><br> 我们停止项目，选择发布配置，开始，登录，应用迁移，检查数据库是否已创建-我们有2个基础。 <br><br> 做完了！ <br><br>  <b>快照：Snap_3_HabrDB</b> <br><br>  <b>目的：创建一个单独的数据库项目，然后可以在不同的项目中使用</b> <br><br> 为什么要一个单独的项目？ <br><br> 单个项目具有以下优点： <br><br><ul><li> 它们可以在其他项目中使用。 </li><li> 如果没有更改，它们不会重新编译，这意味着总的编译时间减少了 </li><li> 单个项目更易于测试。 </li></ul><br> 因此，解决方案上的右键-添加-&gt;新解决方案文件夹，将其命名为DB。 <br> 然后，右键单击已创建的文件夹-添加新项目-&gt; .net standard，名称为HabrDB。 <br> 由于某种原因，我将其创建为.net standard 2.0，因此需要将其更改为2.1 <br>  （在创建它提供物理路径时，也应使其位于DB文件夹中，并且也应位于物理位置）。 <br><br> 对我来说看起来像这样： <br><br><img src="https://habrastorage.org/webt/g4/kb/wu/g4kbwu45mu92my9ucaanuldtuhs.jpeg" alt="图片"><br><br> 因此，我们在项目中有一些ApplicationDBContext，并且创建了另一个我们自己的？ 他们会互相冲突吗？ 现在，我们将与他们成为朋友。 对于同一个数据库，我们将有两个不同的上下文，它们不会通过实体框架相交。 我们将为他们提供不同的架构名称：默认情况下，一个将保留为dbo，另一个将为“ habr”。 <br><br> 如果通过组合的根部连接此类上下文，则可以几乎透明地在其他项目中回收它们。  （例如，仓库环境和员工环境） <br><br> 还有一个构架时刻，有时您需要向用户添加一些属性，这并不直接适用于本文的主题，但是我们只是想知道如何做到这一点。 另外，我们将能够彼此独立地创建和删除上下文。 一个好主意是将安全性表与个人数据分开，并在数据库级别对其进行加密（我们在此项目中不会这样做，但是总的来说，有时这是必需的，包括法律规定）。 <br><br> 是的，这样测试起来更容易，您不能一次创建所有表，而只能一次创建测试给定上下文所需的表。 <br><br> 我创建一个新的项目快照-阶段4。 <br><br>  <b>此阶段的目标是：</b> <br><br><ul><li> 将标准用户更改为高级 </li><li> 更改Srartup.cs文件中的用户 </li><li> 在LoginPartial和ViewImports中更改用户 </li><li> 创建新的迁移以自动以新格式创建数据库 </li></ul><br> 因此，我们将ApplicationDBContext类从WebApp项目转移到HabrDB。 <br><br> 它不是可移植的，只是被复制了。 我们从WebApp中将其删除，从HabrDB项目中将其打开，并将其命名空间更改为HabrDB，会出现很多错误。 <br><br> 是的，在这个项目中没有必要的软件包，现在我们将交付它们。 <br><br> 通过nuget，在HabrDB项目中，您需要安装Microsoft.AspNetCore.Identity.EntityFrameworkCore。 <br><br><img src="https://habrastorage.org/webt/wj/-d/q4/wj-dq4ldm5nx32fs9hvzdiya5ys.jpeg" alt="图片"><br><br> 我们单击灯泡，它为我们提供了安装最新版本的灯泡。 <br><br> 最终的SecurityDBContext文件（还必须重命名）采用以下形式： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.AspNetCore.Identity.EntityFrameworkCore; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.EntityFrameworkCore; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">HabrDB</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SecurityDBContext</span></span> : <span class="hljs-title"><span class="hljs-title">IdentityDbContext</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SecurityDBContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DbContextOptions&lt;SecurityDBContext&gt; options</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">)</span></span> { } } }</code> </pre> <br> 组装之后，我们会<s>仔细处理</s>有错误<s>的文件</s> ，这是正确的-我们删除了ApplicationDBContext并将其替换为SecurityDBContext。 现在，您需要使用SecurityDBContext替换整个项目中到ApplicationDBContext的所有链接。 <br><br> 此后，在我的项目中，WebApp引用上出现了黄色三角形，表明某些链接无法正常工作。 我清理了项目（构建-&gt;干净的解决方案），关闭了项目，从项目文件夹中删除了所有的Debug，Release，Obj和Bin目录，此后，我再次打开了项目，一段时间后，我在Internet上搜索了必要的链接并加载了它们，并三角形消失了-一切都很好。 <br><br> 现在，从WebApp项目中删除Data文件夹，在SQL Server Object Explorer窗口中删除我们的数据库（Habr1_Local和Habr1_Production）并运行该项目。 我们尝试登录-现在提供了应用迁移的提示，而不是提供错误的提示。 <br><br><img src="https://habrastorage.org/webt/z_/ex/ca/z_excar1pqk18n8pdmyvf3eobog.jpeg" alt="图片"><br><br> 没错，我们删除了所有迁移所在的Data文件夹，现在框架不知道该怎么做。 但这太酷了吗？ 为什么呢？ 然后，我们现在将扩展用户类。 <br><br> 向HabrDB项目添加一个新文件： <br>  ApplicationUser.cs <br><br> 我们从IdentityUser继承它 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.AspNetCore.Identity; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">HabrDB</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ApplicationUser</span></span>:<span class="hljs-title"><span class="hljs-title">IdentityUser</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String NickName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime BirthDate { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String PassportNumber { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre> <br> 在类头的SecurityDBContext文件中添加： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SecurityDBContext</span></span> : <span class="hljs-title"><span class="hljs-title">IdentityDbContext</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ApplicationUser</span></span>&gt;</code> </pre> <br> 这是必需的，以便EntityFramework知道现在创建数据库时，您需要使用AppllicationUser类中的高级用户模型，而不是标准模型。 <br><br>  Startup.cs文件中的ConfigureServices方法采用以下形式： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { String ConnStr = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DEBUG ConnStr = "Habr1_Local"; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> ConnStr = "Habr1_Production"; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> services.AddDbContext&lt;SecurityDBContext&gt;(options =&gt; options.UseSqlServer( Configuration.GetConnectionString(ConnStr))); services.AddDefaultIdentity&lt;ApplicationUser&gt;(options =&gt; options.SignIn.RequireConfirmedAccount = true) .AddEntityFrameworkStores&lt;SecurityDBContext&gt;(); services.AddControllersWithViews(); services.AddRazorPages(); }</span></span></code> </pre> <br>  （用IdentityUser替换IdentityUser） <br><br> 在_ViewImports.cshtml文件中，添加以下行 <br><br>  <a href="https://habr.com/ru/users/using/" class="user_link">使用</a> HabrDB <br><br> 现在，所有视图都将看到带有基础的项目，并且您无需在视图开始时<a href="https://habr.com/ru/users/using/" class="user_link">使用</a> HabrDB进行编写。 <br><br> 在_LoginPartial.cshtml文件中，将所有IdentityUser更改为ApplicationUser。 <br><br>  <a href="https://habr.com/ru/users/using/" class="user_link">使用</a> Microsoft.AspNetCore.Identity <br>  <a href="https://habr.com/ru/users/inject/" class="user_link">注入</a> SignInManager SignInManager <br>  <a href="https://habr.com/ru/users/inject/" class="user_link">注入</a> UserManager UserManager <br><br> 以防万一，我们正在编译项目，以便知道我们没有错误，并且我们也没有忘记在任何地方替换任何东西。 <br><br> 现在进行迁移。 <br><br> 您需要打开Package Manager控制台，选择DB / HabrDB项目并对其进行写入 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">add</span></span>-migration initial</code> </pre> <br> 这是我得到的： <br><br><img src="https://habrastorage.org/webt/95/zv/aj/95zvaj1nj3d42hnzq2rk_bvncvo.jpeg" alt="图片"><br><br> 迁移爸爸出现在HabrDB项目中，并且其中包含文件，可以让我们自动创建数据库，但现在有了我们的其他字段-NickName，BirthDate，PassportNumber。 <br><br> 让我们尝试一下它的工作方式-让我们运行并尝试登录（不要注册，您必须在那输入复杂的密码）： <br><br><img src="https://habrastorage.org/webt/01/ib/0u/01ib0ufzxz_bds3n2scb5pqgyoi.jpeg" alt="图片"><br><br> 我被提议进行迁移，并且我同意-这是我们的基础： <br><br><img src="https://habrastorage.org/webt/qg/af/js/qgafjs_fgtlnj39nlru_bxb9a2a.jpeg" alt="图片"><br><br> 在这个阶段，一切 <br><br>  <b>快照：Snap_4_Security已</b>准备就绪 <br><br> 创建第五张照片。 <br><br>  <b>目标：</b> <br><br><ul><li> 使测试连接字符串起作用 </li><li> 创建一个数据库测试项目 </li><li> 使测试项目创建基础并测试有用的东西 </li></ul><br> 我们右键单击DB爸爸，创建一个新项目-MSTest .net core。 <br> 将这个项目中的唯一文件重命名为DBTest并认为... <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此外，这将是困难的。 </font></font><br><br> 问题 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们如何创建一个保证与测试数据库通信的上下文，即，不仅使用来自另一个项目（WebApp）的ConnectionString，还可以使用某种方式与Release / Debug配置连接？..可以创建一个新的配置，例如Test ？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不，这是潜在的数据丢失-某种程度上我们忘记了忘记忘记从测试配置切换，单击运行所有测试按钮-然后删除整个数据库...不，此选项不起作用... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所以我们将清楚地创建一个测试上下文！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开HabrDBContext文件并将其内容更改为：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.EntityFrameworkCore; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.Extensions.Configuration; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">HabrDB</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HabrDBContext</span></span>:<span class="hljs-title"><span class="hljs-title">DbContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String ConnectionString = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IConfigurationRoot Configuration { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HabrDBContext </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTestContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DirectoryInfo info = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectoryInfo(Directory.GetCurrentDirectory()); DirectoryInfo temp = info.Parent.Parent.Parent.Parent; String CurDir = Path.Combine(temp.ToString(), <span class="hljs-string"><span class="hljs-string">"WebApp"</span></span>); String ConnStr = <span class="hljs-string"><span class="hljs-string">"Habr1_Test"</span></span>; Configuration = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationBuilder().SetBasePath(CurDir).AddJsonFile(<span class="hljs-string"><span class="hljs-string">"appsettings.json"</span></span>).Build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbContextOptionsBuilder&lt;HabrDBContext&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionString = Configuration.GetConnectionString(ConnStr); builder.UseSqlServer(connectionString); ConnectionString = connectionString; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 通过Nuget，将以下库添加到数据库： </font></font><br><br><pre> <code class="plaintext hljs">Microsoft.AspNetCore.Identity.EntityFrameworkCore Microsoft.EntityFrameworkCore Microsoft.EntityFrameworkCore.SqlServer Microsoft.Extensions.Configuration.FileExtensions Microsoft.Extensions.Configuration.Json</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CreateTestContext方法只能返回一个名为Habr1_Test的连接字符串。您需要将其带入另一个项目。为了仅通过一项设置就不会通过引用连接项目，我们要求构建器根据给定的connectionString创建选项，为此，我们从测试项目的编译目录到项目根目录遍历目录链，从各个部分收集WebApp项目的路径，请为我们添加配置文件appsettings.json（用于存储我们的设置），然后将其编译为配置。从此配置进一步，我们采用connectionString并记住它（稍后我们将需要它）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在大型项目中，您可以将设置移动到带有字符串，DLL或用于通过缓存访问设置数据的对象的单独项目中。现在，一个简单的方法就足够了。</font></font><br><br> 为什么这样 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以将测试ConnectionString直接放入测试项目中并使用它初始化数据库，也可以在数据库中创建测试ConnectionString。</font><font style="vertical-align: inherit;">但是，那将是一件令人不愉快的事情：所有连接字符串将存储在不同的位置。</font><font style="vertical-align: inherit;">我一个人知道自己的头上有很多漏洞，例如，当数据库或服务器的名称更改时，我会忘记更改某些内容，因此我将所有连接字符串都放在一个位置，所以我可以这样做。</font><font style="vertical-align: inherit;">现在，通过更改配置文件appsettings.json，您可以管理所有连接。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让我们尝试对基础进行一些有用的操作，例如创建一些内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在HabrDB项目中，我创建了DBClasses文件夹，那里只有数据库表类。</font><font style="vertical-align: inherit;">我们首先处理代码，如果我能想象自己在做什么，通常对我来说更方便。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建一个这样的表： </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ComponentModel.DataAnnotations; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ComponentModel.DataAnnotations.Schema; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">HabrDB.DBClasses</span></span> { [Table(<span class="hljs-string"><span class="hljs-string">"Phones"</span></span>, Schema =<span class="hljs-string"><span class="hljs-string">"Habr"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Phone</span></span> { [Key] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String Model { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime DayZero { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了美观，我们将我的班级称为“电话”，而数据库中的表应采用复数形式：“电话”。</font><font style="vertical-align: inherit;">因此，我在Table属性中指示要为我的表命名的名称以及应在数据库中使用的命名空间（在SQL中称为Schema）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在还有另一个美学问题：在数据库类中，我们将拥有一堆不同的基础结构方法，然后在堆中又有了另一个不同的表，所有这些都可以创建局部类。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在HabrDBContext.cs文件中的单词类之后添加单词partial-像这样：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HabrDBContext</span></span>:<span class="hljs-title"><span class="hljs-title">DbContext</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建HabrDBContext.cs文件的副本-只需在文件上按CTRL + C-CTRL + V，创建它的副本，将源文件的名称更改为HabrDBContext_Infrastructure.cs，将新文件名更改为HabrDBContext_Data.cs </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在新文件中，编写：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> HabrDB.DBClasses; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.EntityFrameworkCore; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">HabrDB</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HabrDBContext</span></span>:<span class="hljs-title"><span class="hljs-title">DbContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DbSet&lt;Phone&gt; Phones { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在很漂亮-我们在一个地方处理数据，在另一个地方处理基础架构。</font><font style="vertical-align: inherit;">文件是不同的，但是类是相同的-构建项目时，环境本身会将其从多个组装成一个。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，尝试一下！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将我们唯一的测试类中的代码替换为：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> HabrDB; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> HabrDB.DBClasses; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.VisualStudio.TestTools.UnitTesting; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">DBTest</span></span> { [TestClass] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DBTest</span></span> { [TestMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMethod1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { String PhoneName = <span class="hljs-string"><span class="hljs-string">"Nokia"</span></span>; DateTime now = DateTime.Now; HabrDBContext db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HabrDBContext().CreateTestContext(); db.Database.EnsureCreated(); List&lt;Phone&gt; Phones = db.Phones.ToList(); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">0</span></span>, Phones.Count); Phone ph = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phone(); ph.Model = PhoneName; ph.DayZero = now; db.Phones.Add(ph); db.SaveChanges(); Phone ph1 = db.Phones.Single(); Assert.AreEqual(PhoneName, ph1.Model); Assert.AreEqual(now, ph1.DayZero); } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单击“测试资源管理器”选项卡上的播放按钮（或单击“测试”-&gt;“运行所有测试”），然后... </font></font><br><br><img src="https://habrastorage.org/webt/9w/qe/68/9wqe686vdpg6jet-epu30oakdou.jpeg" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误！</font><font style="vertical-align: inherit;">这是那些。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们读了他们写给我们的东西：</font></font><br><br><pre> <code class="plaintext hljs">Message: Test method DBTest.DBTest.TestMethod1 threw exception: System.InvalidOperationException: No database provider has been configured for this DbContext. A provider can be configured by overriding the DbContext.OnConfiguring method or by using AddDbContext on the application service provider. If AddDbContext is used, then also ensure that your DbContext type accepts a DbContextOptions&lt;TContext&gt; object in its constructor and passes it to the base constructor for DbContext.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用英语胡说八道... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，我们会随机采取行动！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以将此函数复制到文件HabrDBContext_Infrastructure.cs吗？</font><font style="vertical-align: inherit;">试试吧！</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnConfiguring</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DbContextOptionsBuilder optionsBuilder</span></span></span><span class="hljs-function">)</span></span> { String ConnStr = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Configuration == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DEBUG ConnStr = "Habr1_Local"; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> ConnStr= "Habr1_Production"; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> Configuration = new ConfigurationBuilder() .SetBasePath(Directory.GetCurrentDirectory()) .AddJsonFile("appsettings.json").Build(); ConnectionString = Configuration.GetConnectionString(ConnStr); } optionsBuilder.UseSqlServer(ConnectionString); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们开始... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那是幸运的！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个新的基地已经创建并在其中-我们的桌子！</font></font><br><br><img src="https://habrastorage.org/webt/an/cv/1a/ancv1ahppxwymetpwayqqwdtlzg.jpeg" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么这样</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在OnConfiguring和CreateTestContext函数上放置几个断点，您将看到首先调用CreateTestContext方法并将连接字符串保存在ConnectionString对象中。一切似乎都还可以。但是随后有人尝试调用OnConfiguring ...是谁？让我们看一下调用堆栈-是的，这是测试中的db.Database.EnsureCreated（）行！事实是我们还没有这样的基础-它的确保创建方法创建了它。但是，此方法不再使用参数，并且必须以某种方式在调用构造函数和确保创建之间保留上下文。此外，当我们从项目本身使用此上下文时（例如，不在测试中，而在网站上），各种中间件，DI和其他吸引人的机制也将尝试调用它，因此我们将预见所有内容-无论谁调用我们的数据库，如果他想致电OnConfiguring-他将有这样的机会。我们已经提供了一切。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次运行测试-并... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次出错？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据库已经存在，数据就在...怎么了？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基础是一个持久的对象，即使我们重新启动项目也可以保留……现在真正困难的部分开始了。如何删除所有这些表？如何删除数据，重置所有索引？</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快照：Snap_5_ContextCrafting已经准备就绪，</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，编写DAL-数据访问层。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建HabrDBContext_Data.cs文件的副本，将其命名为HabrDBContext_DAL.cs </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并写入：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> HabrDB.DBClasses; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.EntityFrameworkCore; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">HabrDB</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HabrDBContext</span></span>:<span class="hljs-title"><span class="hljs-title">DbContext</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddPhone</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Phone ph</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Phones.Add(ph); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SaveChangesAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;List&lt;Phone&gt;&gt; GetAllPhones() { List&lt;Phone&gt; phones = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Phones.ToListAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> phones; } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是对我们数据的包装。如果我在访问数据库的界面中进行了某些更改，以处理在我调用它的整个项目中进行的搜索，则我不希望这样做。因此，我们将创建一个抽象层-数据访问层。他将成为站点的基本机制和MVC机制或其他机制之间的中介。而且-巧合？ -我们立即有测试对象！使用测试的另一个原因是它们会引发连接性低的解决方案。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改测试中的功能代码-并更改其名称之一。现在我们知道我们正在测试什么！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加电话！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不会做存储库，对于一个演示项目，这是一个冗余解决方案。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，您可以通过startup.cs中的DI连接所有内容，但是对于演示项目而言，这太令人困惑了，因此让我们将其保留为这样</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 新的测试功能代码： </font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddPhone_Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { String PhoneName = <span class="hljs-string"><span class="hljs-string">"Nokia"</span></span>; DateTime now = DateTime.Now; HabrDBContext db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HabrDBContext().CreateTestContext(); db.Database.EnsureCreated(); List&lt;Phone&gt; Phones = db.GetAllPhones().Result; Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">0</span></span>, Phones.Count); Phone ph = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phone(); ph.Model = PhoneName; ph.DayZero = now; db.AddPhone(ph); Phone ph1 = db.Phones.Single(); Assert.AreEqual(PhoneName, ph1.Model); Assert.AreEqual(now, ph1.DayZero); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将从测试数据库中删除带有电话的线路，然后再次运行测试-它应该可以工作。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果它不起作用，那么您仍然有其他选择。</font><font style="vertical-align: inherit;">一切对我来说都是绿色的：</font></font><br><br><img src="https://habrastorage.org/webt/kc/vz/ea/kcvzeaiyug4owclncwblblpqoaw.jpeg" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是db.GetAllPhones（）。</font><font style="vertical-align: inherit;">事实是我们的DAL函数是异步的。</font><font style="vertical-align: inherit;">但是测试方法本身是普通的，因此无法在其中调用wait。</font><font style="vertical-align: inherit;">让我们尝试删除数据，使方法异步，然后看看会发生什么。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的功能已成为异步任务-否则，测试将不会开始，无论何时调用异步方法，我们都需要等待</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddPhone_Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { String PhoneName = <span class="hljs-string"><span class="hljs-string">"Nokia"</span></span>; DateTime now = DateTime.Now; HabrDBContext db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HabrDBContext().CreateTestContext(); db.Database.EnsureCreated(); List&lt;Phone&gt; Phones = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> db.GetAllPhones(); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">0</span></span>, Phones.Count); Phone ph = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phone(); ph.Model = PhoneName; ph.DayZero = now; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> db.AddPhone(ph); Phone ph1 = db.Phones.Single(); Assert.AreEqual(PhoneName, ph1.Model); Assert.AreEqual(now, ph1.DayZero); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要的是，其中存在异步调用的所有测试函数都将返回Task而不是void-否则测试将不会启动或不会等待异步数据的返回并继续执行，并且会出现错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，或多或少的作品。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快照：Snap_6_Dal</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有什么，有</font><b><font style="vertical-align: inherit;">必要</font></b><font style="vertical-align: inherit;">手动删除数据吗？当然不是！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要从数据库中删除表的功能... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用db.Database.EnsureDeleted是很酷的...的确有可能！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是更好的是没有必要的……事实是，在这个项目中，我们的基地没有与密码连接。而且，如果数据库与密码相关联，则需要通过SQL Management Studio单独创建它，并且当从db.Database.EnsureDeleted中删除它时，它将连同所有密码，访问权限，用户权限以及框架下次尝试创建它时一起删除，那么就根本无法访问数据库，您将不得不重新配置所有内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是第一。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，最好不要做不必要的工作，因此数据库测试比与外部机制无关的常规功能要花费更长的时间，并且最好以所有可能的方式来优化测试时间。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三个：也许在一个测试中，我们将需要删除一些或几次表并重新创建它，而其他表保持不变。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们尝试调用db.Database.EnsureDeleted函数，按一下括号，看看它接受什么，以及它是否有重载…… </font></font><br><br><img src="https://habrastorage.org/webt/uh/by/ti/uhbytib40xtjnbwfapd26iqtrus.jpeg" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是的，不是很多…… </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，让我们编写我们自己的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">立即使用右键将新项目添加到解决方案中（在解决方案本身中），在解决方案上添加-&gt; .net standard C＃，并将其称为Extensions。检查它是否为2.1版本。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，您需要将Extensions项目中的唯一文件重命名为DBContextExtensions.cs并在其中放置以下代码：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.EntityFrameworkCore; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.EntityFrameworkCore.Infrastructure; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Extensions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DBContextExtensions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EnsureDeleted&lt;TEntity&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> DatabaseFacade db, DbSet&lt;TEntity&gt; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TEntity : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { TableDescription Table = GetTableName(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { res = db.ExecuteSqlRaw(<span class="hljs-string"><span class="hljs-string">$"DROP TABLE [</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Table.Schema}</span></span></span><span class="hljs-string">].[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Table.TableName}</span></span></span><span class="hljs-string">];"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TableDescription GetTableName&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> DbSet&lt;T&gt; dbSet) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbContext = dbSet.GetDbContext(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> model = dbContext.Model; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entityTypes = model.GetEntityTypes(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entityType = entityTypes.First(t =&gt; t.ClrType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tableNameAnnotation = entityType.GetAnnotation(<span class="hljs-string"><span class="hljs-string">"Relational:TableName"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tableSchemaAnnotation = entityType.GetAnnotation(<span class="hljs-string"><span class="hljs-string">"Relational:Schema"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tableName = tableNameAnnotation.Value.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> schemaName = tableSchemaAnnotation.Value.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TableDescription { Schema = schemaName, TableName = tableName }; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DbContext GetDbContext&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> DbSet&lt;T&gt; dbSet) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> infrastructure = dbSet <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IInfrastructure&lt;IServiceProvider&gt;; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serviceProvider = infrastructure.Instance; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentDbContext = serviceProvider.GetService(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ICurrentDbContext)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ICurrentDbContext; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentDbContext.Context; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TableDescription</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String Schema { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String TableName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从Nuget添加Microsoft.EntityFrameworkCore，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个包Microsoft.EntityFrameworkCore.Relational </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extensions是一种非常方便的机制。使用它，您可以为类对象添加其他功能，即我们在第一个参数类型之前的this关键字。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EnsureDeleted&lt;TEntity&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> DatabaseFacade db, DbSet&lt;TEntity&gt; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TEntity : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示可扩展类型。这意味着在我们编写完此代码之后，DatabaseFacade对象将具有一个新方法-具有参数的ConfirmDeleted，这将是我们刚编写的函数！其中TEntity：class的末尾表示TEntity具有约束-使用限制，并且如果我们尝试不按类而是按其他方式将其概括，则将出现编译时错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我预见到您的逻辑问题-为什么会这样？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，从SecureDeleted调用的GetTableName函数需要此限制。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">她为什么需要这个限制？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，从GetTableName调用的什么函数GetDbContext也需要此限制... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及为什么</font><font style="vertical-align: inherit;">需要</font><font style="vertical-align: inherit;">此限制？你问高音，你会是正确的...</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们尝试使用该行中的GetDbContext方法扩展的dbSet</font></font><br><br><pre> <code class="cs hljs">Public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DbContext GetDbContext&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> DbSet&lt;T&gt; dbSet) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，要求T是引用类型，而class只是其中的一种。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，所有这些困难-对于一个很小但非常有用的功能-不要将字符串值作为参数传递给sureDeleted方法。因为我记性不好。我希望DBContext告诉我它具有哪些表，并且已经从该数据集中计算出上下文，并通过服务提供者将其带入当前上下文，然后从该上下文中获取模型，从中进行类型化，然后查找具有这些类型的类型。与数据集相同（该数据已经在GetTableName中），然后通过注释获取表和架构的名称，将其传递给确保删除（EnsureDeleted），然后该死！同样，没有诸如removetable之类的函数，您必须从字符串构造一些SQL syrniki ...好吧，至少可以通过某种方式实现！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而且，确保函数删除是例外，因此您无法考虑删除表的过程，如果那里有任何相关数据，则在删除相关表之后，立即尝试再次删除该表，不要打扰。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将方法添加到测试中（最后）</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteTable_Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HabrDBContext db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HabrDBContext().CreateTestContext(); db.Database.EnsureDeleted(db.Phones); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行，检查，呼气... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次运行-应该可以。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，每次运行测试时，都会创建必要的表，然后将其删除。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快照：Snap_7_Extensions</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通往新的</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">痔疮</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视野</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，存在一个问题-HabrDBContext对象对我们而言不是持久性的（在每个测试方法中创建）。</font><font style="vertical-align: inherit;">（是的，要隔离Kagbe单元测试的想法。我们正在努力打破它！警察看不见是很好的……）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，在每种测试方法中，都会重新创建上下文，并且我们不能在函数之间共享该对象这样它对所有人都是通用的，并且为所有测试创建一次。</font><font style="vertical-align: inherit;">不能吗 </font><font style="vertical-align: inherit;">好吧，好的，我们将在每个函数中编写代码。</font></font><br><br><pre> <code class="cs hljs">HabrDBContext db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HabrDBContext().CreateTestContext(); db.Database.EnsureCreated();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 并调用最后一个方法 </font></font><br><br><pre> <code class="cs hljs">HabrDBContext db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HabrDBContext().CreateTestContext(); db.Database.EnsureDeleted(db.Phones);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及其他一些桌子... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是很好，所以我们将考虑如何解决这个问题...由于我们的穿着像测试员一样，我们需要匹配图像-我们将寻求解决方案！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类具有如此有趣的功能-静态成员。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就像您想象一个图形和从该图形创建的对象一样，事实证明静态成员是不是该图形创建的对象所固有的成员，而是该图形本身。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这已经很有趣了... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在让我们尝试！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的测试类称为DBTest，为其创建一个静态对象-db</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> HabrDB; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> HabrDB.DBClasses; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.VisualStudio.TestTools.UnitTesting; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Extensions; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">DBTest</span></span> { [TestClass] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DBTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HabrDBContext db; [TestMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AA0_init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HabrDBContext().CreateTestContext(); db.Database.EnsureCreated(); } [TestMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddPhone_Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { String PhoneName = <span class="hljs-string"><span class="hljs-string">"Nokia"</span></span>; DateTime now = DateTime.Now; List&lt;Phone&gt; Phones = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> db.GetAllPhones(); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">0</span></span>, Phones.Count); Phone ph = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phone(); ph.Model = PhoneName; ph.DayZero = now; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> db.AddPhone(ph); Phone ph1 = db.Phones.Single(); Assert.AreEqual(PhoneName, ph1.Model); Assert.AreEqual(now, ph1.DayZero); } [TestMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteTable_Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { db.Database.EnsureDeleted(db.Phones); } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有效！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是对这样的数字方法有些愚蠢。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有解决办法！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊的测试属性！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在测试项目中，创建一个名为DBTestBase的新类，并从中继承我们的DBTest类。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您需要从DBTest中除去以下所有内容：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> HabrDB; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> HabrDB.DBClasses; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.VisualStudio.TestTools.UnitTesting; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Extensions; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">DBTest</span></span> { [TestClass] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DBTest</span></span>:<span class="hljs-title"><span class="hljs-title">DBTestBase</span></span> { [TestMethod] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddPhone_Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { String PhoneName = <span class="hljs-string"><span class="hljs-string">"Nokia"</span></span>; DateTime now = DateTime.Now; List&lt;Phone&gt; Phones = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> db.GetAllPhones(); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">0</span></span>, Phones.Count); Phone ph = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phone(); ph.Model = PhoneName; ph.DayZero = now; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> db.AddPhone(ph); Phone ph1 = db.Phones.Single(); Assert.AreEqual(PhoneName, ph1.Model); Assert.AreEqual(now, ph1.DayZero); } [ClassCleanup] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteTable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { db.Database.EnsureDeleted(db.Phones); } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DBTestBase类的内容： </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> HabrDB; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.VisualStudio.TestTools.UnitTesting; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">DBTest</span></span> { [TestClass] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DBTestBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HabrDBContext db{ <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Executes once before the test run. (Optional) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="context"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> [AssemblyInitialize] public static void AssemblyInit(TestContext context) { db = new HabrDBContext().CreateTestContext(); db.Database.EnsureCreated(); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Executes before this class creation </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="context"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> [ClassInitialize] public static void TestFixtureSetup(TestContext context) { } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Executes Before each test </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> [TestInitialize] public void Setup() { } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Executes once after the test run </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> [AssemblyCleanup] public static void AssemblyCleanup() { } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Runs once after all tests in this class are executed. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Not guaranteed that it executes instantly after all tests from the class. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> [ClassCleanup] public static void TestFixtureTearDown() { } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Executes after each test </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> [TestCleanup] public void TearDown() { //db.Database.EnsureDeleted();//don`t call! delete database instead of tables! } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在一切都清楚了！</font><font style="vertical-align: inherit;">我们的数据库是作为DBTestBase类的静态部分创建的，因此从它继承的所有类都可以访问该数据库。</font><font style="vertical-align: inherit;">这意味着数据库仅创建一次-开始测试时。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将[ClassCleanup]属性添加到任何类的任何方法中-并获得“更干净”的测试-这样的函数将在完成该类的所有测试之后执行某些操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，它将删除此测试中创建的所有表，而无需触及数据库本身。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于所有这些特殊功能均已从指标中排除，因此我们可以看到我们的功能正常工作的时间-我们添加了一些左对象，并且选择功能的工作时间急剧增加-这意味着我们的DAL功能有问题，并且如果您测试一个功能在一种测试方法中，将立即清楚问题出在哪里。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您也可以根据功能创建播放列表。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这对于例如调用数据准备功能（仅用于测试）是必需的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，DAL函数将更新此数据，然后再更新另一个DAL函数，例如，它会考虑某些问题，或从该数据显示报告，然后删除该数据。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们可以从真实的业务流程中模仿一些用户操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要记住的主要事情是，除了这些测试属性外，还按字母顺序调用测试。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，如果您需要某种静态序列，则应将其命名为：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T1_AddPhone_Test，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T2_RemovePhone_Test </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，现在您不必担心我们的数据库-所有内容都将进行完整测试！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在该睡觉了！我还有一个女孩在那里没有测试... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成功测试！再见！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">git存储库项目：</font><a href="https://github.com/3263927/Habr_1" rel="nofollow"><font style="vertical-align: inherit;">https</font></a><font style="vertical-align: inherit;"> : </font></font><a href="https://github.com/3263927/Habr_1" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//github.com/3263927/Habr_1</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果对此主题很有趣，请在评论中写下评论，然后我写一篇关于测试身份，角色，声明，3D身份验证并编写我的TypeFilterAttribute的帖子（因为标准的一个缓存，并且如果您从某个角色中删除某个人，那么他在结​​婚之前仍将拥有这个角色。直到接受测试，婚姻才会出现！：/） </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我已经可以了，我通过了考试</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ek/8u/bl/ek8ublhenuarw7809onfz2l_nx4.jpeg" alt="图片"><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481474/">https://habr.com/ru/post/zh-CN481474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481458/index.html">狂热的程序员。 摘要第2部分+摘要表。 鱼，巨人和导师</a></li>
<li><a href="../zh-CN481460/index.html">消息传递-> OTP内的PubSub</a></li>
<li><a href="../zh-CN481462/index.html">教育软件的历史：个人计算机和虚拟教师的发展</a></li>
<li><a href="../zh-CN481466/index.html">如果您需要很多不同的环境，如何在Jenkins中构建项目</a></li>
<li><a href="../zh-CN481470/index.html">全年智能花环</a></li>
<li><a href="../zh-CN481476/index.html">我如何开始在会议上发言并且无法停止</a></li>
<li><a href="../zh-CN481478/index.html">STM32 + CMSIS + STM32CubeIDE</a></li>
<li><a href="../zh-CN481480/index.html">这是常态：什么是法线贴图以及它们如何工作</a></li>
<li><a href="../zh-CN481482/index.html">使用PHP SDK交叉发布到Facebook页面</a></li>
<li><a href="../zh-CN481484/index.html">人工智能试图避免问题学习复杂行为</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>