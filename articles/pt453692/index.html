<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õµÔ∏è ü§∂üèΩ üë®üèª‚Äçüéì Jogo 3D Shaders para Iniciantes: Efeitos üë©üèΩ‚Äçüíª üßõüèΩ ü¶î</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ A primeira parte ] 

 Depois de lidar com o b√°sico, nesta parte do artigo, implementamos efeitos como contornos de objetos, bloom, SSAO, blur, profu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jogo 3D Shaders para Iniciantes: Efeitos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453692/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A primeira parte</a> ] <br><br>  Depois de lidar com o b√°sico, nesta parte do artigo, implementamos efeitos como contornos de objetos, bloom, SSAO, blur, profundidade de campo, pixeliza√ß√£o e outros. <br><br><h2>  Esbo√ßos </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/96f/9b2/3b896f9b246e1695fa908b4bdc145480.gif"></div><br>  Criar contornos em torno da geometria da cena d√° ao jogo uma apar√™ncia √∫nica que se assemelha a quadrinhos ou desenhos animados. <br><br><h3>  Material difuso </h3><br>  O sombreador de contorno precisa de uma textura de entrada para reconhecer e colorir as bordas.  Os candidatos a essa textura de entrada podem ser cores difusas de materiais, cores de texturas difusas, v√©rtice normal ou mesmo cores de mapas normais. <br><br><pre><code class="cpp hljs">uniform <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> vec4 diffuse ; } p3d_Material; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 diffuseColor = p3d_Material.diffuse.rgb; fragColor = vec4(diffuseColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Esse √© um pequeno shader de fragmento que transforma a cor difusa de um material de geometria em uma textura de buffer de quadro.  Essa textura de cor difusa do buffer do quadro ser√° a textura de entrada para o sombreador de caminho. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/abd/05c/f0babd05caf7104156c15929995c9279.gif"></div><br>  Essa √© a textura da cor difusa do material do buffer de quadros, que exibe as cores que definimos no Blender.  O sombreador de contorno reconhecer√° as bordas da cena e as colorir√°. <br><br>  Note-se que a cor difusa dos materiais n√£o funcionar√° se certas partes da cena n√£o tiverem sua pr√≥pria cor difusa do material. <br><br><h3>  Criando arestas </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/a0d/57a/33aa0d57aeba90366ddd95865ea0d6c6.gif"></div><br>  Criar arestas √© semelhante ao uso de filtros de reconhecimento de arestas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GIMP</a> . <br><br>  Todos os c√°lculos para esta t√©cnica de sombreamento s√£o realizados em um sombreador de fragmento.  Para criar contornos para o sombreador de v√©rtice, basta passar quatro v√©rtices da malha retangular para a sa√≠da para caber na tela. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D materialDiffuseTexture; // ... vec2 texSize = textureSize(materialDiffuseTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy; // ...</span></span></code> </pre> <br>  Antes de come√ßar a reconhecer as bordas, √© necess√°rio preparar a textura recebida com a qual trabalharemos.  Como a textura possui um tamanho de tela, podemos calcular as coordenadas UV, conhecendo as coordenadas do fragmento e o tamanho da textura recebida. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int separation = 1; // ...</span></span></code> </pre> <br>  <code>separation</code> pode ser personalizada para se adequar ao seu gosto.  Quanto maior a separa√ß√£o, mais grossas as bordas ou linhas. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... vec4 mx = vec4(0); vec4 mn = vec4(1); int x = -1; int y = -1; for (int i = 0; i &lt; 9; ++i) { vec4 color = texture ( materialDiffuseTexture , (texCoord + (vec2(x, y) * separation)) / texSize ); mx = max(color, mx); mn = min(color, mn); x += 1; if (x &gt;= 2) { x = -1; y += 1; } } float alpha = ((mx.r + mx.g + mx.b) / 3) - ((mn.r + mn.g + mn.b) / 3); if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/d24/e56/42fd24e5682700e1e7cd5186bebc33af.gif"></div><br>  A t√©cnica de reconhecimento de bordas encontra altera√ß√µes nas cores da textura recebida.  Focalizando o fragmento atual, ele usa a janela de fragmentos 3x3 para encontrar as cores mais brilhantes e mais escuras das nove amostras.  Ent√£o ela subtrai do brilho de uma cor o brilho de outra, obtendo a diferen√ßa. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lineRgb = vec3(0.012, 0.014, 0.022); // ... vec4 lineColor = vec4(lineRgb, alpha); // ... fragColor = lineColor; // ...</span></span></code> </pre> <br>  Essa diferen√ßa √© usada no canal alfa da cor de sa√≠da.  Se n√£o houver diferen√ßa, a aresta ou a linha n√£o ser√° desenhada.  Se houver uma diferen√ßa, a aresta √© desenhada. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br>  Tente experimentar o valor limite.  Agora √© zero.  Qualquer valor diferente de zero se torna uma aresta; esse limite pode ser alterado.  Isso √© especialmente √∫til para texturas de entrada mais ruidosas com pequenas diferen√ßas.  No caso de uma textura barulhenta, geralmente √© necess√°rio criar contornos apenas para grandes diferen√ßas. <br><br><h3>  C√≥digo fonte </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">material-diffuse.frag</a> </li><li>  <a href="">outline.frag</a> </li></ul><br><h2>  Nevoeiro </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/02c/e52/5af02ce52f813b27461f79e5dca5fe20.gif"></div><br>  O nevoeiro (ou n√©voa, como √© chamado no Blender) adiciona neblina atmosf√©rica √† cena, criando misteriosas partes salientes e amolecidas.  As partes salientes aparecem quando alguma geometria cai subitamente na pir√¢mide de visibilidade da c√¢mera. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_FogParameters { vec4 color ; float start ; float end ; } p3d_Fog; // ...</span></span></code> </pre> <br>  O Panda3D possui uma estrutura de dados conveniente que cont√©m todos os par√¢metros de neblina, mas voc√™ pode transferi-los para o shader manualmente. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float fogIntensity = clamp ( ( p3d_Fog.end - vertexPosition.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; // ...</span></span></code> </pre> <br>  No exemplo de c√≥digo, um modelo linear √© usado para calcular o brilho da neblina ao se afastar da c√¢mera.  Em vez disso, voc√™ pode usar o modelo exponencial.  O brilho do nevoeiro √© zero antes ou no in√≠cio do nevoeiro.  Quando a posi√ß√£o do v√©rtice se aproxima do final do nevoeiro, <code>fogIntensity</code> aproxima da unidade.  Para todos os v√©rtices ap√≥s o final do nevoeiro, o <code>fogIntensity</code> limitado a 1 a partir de cima. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = mix ( outputColor , p3d_Fog.color , fogIntensity ); // ...</span></span></code> </pre> <br>  Com base no brilho do nevoeiro, misturamos a cor do nevoeiro com a cor de sa√≠da.  √Ä medida que o <code>fogIntensity</code> aproxima da unidade, haver√° cada vez menos <code>outputColor</code> e mais e mais cores de nevoeiro.  Quando o <code>fogIntensity</code> atinge a unidade, apenas a cor do nevoeiro permanece. <br><br><h3>  Nevoeiro nos contornos </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/ee8/d49/e1fee8d490abe10ecb798df618f183f7.gif"></div><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D positionTexture; // ... vec4 position = texture(positionTexture, texCoord / texSize); float fogIntensity = clamp ( ( p3d_Fog.end - position.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; vec4 lineWithFogColor = mix ( lineColor , p3d_Fog.color , fogIntensity ); fragColor = vec4(lineWithFogColor.rgb, alpha); // ...</span></span></code> </pre> <br>  O Path Shader aplica neblina √†s cores das bordas para uma imagem mais hol√≠stica.  Se ele n√£o fizesse isso, a geometria dos contornos seria obscurecida pelo nevoeiro, o que pareceria estranho.  No entanto, ele ainda cria contornos nas arestas mais externas da geometria do palco com o moinho, porque as arestas v√£o al√©m da geometria - para onde n√£o h√° posi√ß√µes de v√©rtices. <br><br>  <code>positionTexture</code> √© uma textura de buffer de quadro que cont√©m as posi√ß√µes dos v√©rtices do espa√ßo da vista.  Voc√™ aprender√° sobre isso quando implementarmos o shader SSAO. <br><br><h3>  C√≥digo fonte </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">base.frag</a> </li><li>  <a href="">outline.frag</a> </li></ul><br><h2>  Bloom </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/744/f35/31d744f35168ac87f609474998802b12.gif"></div><br>  Adicionar bloom √† cena pode criar uma ilus√£o convincente do modelo de ilumina√ß√£o.  Objetos emissores de luz se tornam mais convincentes e os reflexos da luz recebem uma quantidade adicional de brilho. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//... float separation = 3; int samples = 15; float threshold = 0.5; float amount = 1; // ...</span></span></code> </pre> <br>  Voc√™ pode personalizar essas configura√ß√µes ao seu gosto.  A separa√ß√£o aumenta o tamanho do desfoque.  Amostras determina a for√ßa do desfoque.  O limite determina o que ser√° e o que n√£o ser√° afetado por esse efeito.  Quantidade controla a quantidade de sa√≠da de bloom. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int size = samples; int size2 = size * size; int x = 0; int y = 0; // ... float value = 0; vec4 result = vec4(0); vec4 color = vec4(0); // ... for (int i = 0; i &lt; size2; ++i) { // ... } // ...</span></span></code> </pre> <br>  Essa t√©cnica come√ßa passando <code>samples</code> tamanho de janela para <code>samples</code> centralizadas em rela√ß√£o ao fragmento atual.  Parece uma janela usada para criar caminhos. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... color = texture ( bloomTexture , ( gl_FragCoord.xy + vec2(x * separation, y * separation) ) / texSize ); value = ((0.3 * color.r) + (0.59 * color.g) + (0.11 * color.b)); if (value &lt; threshold) { color = vec4(0); } result += color; // ...</span></span></code> </pre> <br>  Esse c√≥digo obt√©m a cor da textura recebida e transforma os valores de vermelho, verde e azul em um valor em escala de cinza.  Se o valor em escala de cinza for menor que o limite, ele descartar√° essa cor, tornando-a preta. <br><br>  Passando por todas as amostras dentro da janela, ele acumula todos os seus valores no <code>result</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... result = result / size2; // ...</span></span></code> </pre> <br>  Depois de concluir a coleta de amostras, ele divide a soma das amostras de cores pelo n√∫mero de amostras coletadas.  O resultado √© a cor do meio do pr√≥prio fragmento e de seus vizinhos.  Ao fazer isso para cada fragmento, obtemos uma imagem borrada.  Esse tipo de desfoque √© chamado de desfoque de caixa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/16f/ea4/f9016fea492bc7b136ef6437a683c937.gif"></div><br>  Aqui voc√™ v√™ o processo de execu√ß√£o do algoritmo bloom. <br><br><h3>  C√≥digo fonte </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">bloom.frag</a> </li></ul><br><h2>  Oclus√£o ambiental do espa√ßo da tela (SSAO) </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/5ab/5bf/f935ab5bf4794caae3be90b611ad771c.gif"></div><br>  O SSAO √© um desses efeitos que voc√™ n√£o sabe que existem, mas assim que voc√™ sabe que n√£o pode mais viver sem eles.  Ele pode transformar uma cena med√≠ocre em uma cena incr√≠vel!  Em cenas est√°ticas, a oclus√£o do ambiente pode ser inserida na textura, mas para cenas mais din√¢micas precisamos de um sombreador.  O SSAO √© uma das t√©cnicas de sombreamento mais sofisticadas, mas depois que voc√™ descobrir isso, voc√™ se tornar√° um sombreador principal. <br><br>  Observe que o termo ‚Äúespa√ßo na tela‚Äù no t√≠tulo n√£o est√° totalmente correto, porque nem todos os c√°lculos s√£o realizados no espa√ßo na tela. <br><br><h3>  Dados recebidos </h3><br>  O shader SSAO precisar√° da seguinte entrada. <br><br><ul><li>  Vetores de posi√ß√µes de v√©rtices no espa√ßo de visualiza√ß√£o. </li><li>  Vetores normais para os v√©rtices no espa√ßo de visualiza√ß√£o. </li><li>  Vetores de amostra no espa√ßo tangente. </li><li>  Vetores de ru√≠do no espa√ßo tangente. </li><li>  A matriz de proje√ß√£o na lente da c√¢mera. </li></ul><br><h3>  Posi√ß√£o </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/f36/d42/2d2f36d425c2596288d8982158687354.png"></div><br>  N√£o √© necess√°rio armazenar posi√ß√µes de v√©rtice na textura do buffer do quadro.  Podemos recri√°-los a partir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">do buffer de profundidade da c√¢mera</a> .  Estou escrevendo um guia para iniciantes, portanto, n√£o usaremos essa otimiza√ß√£o e come√ßaremos os neg√≥cios imediatamente.  Na sua implementa√ß√£o, voc√™ pode facilmente usar o buffer de profundidade. <br><br><pre> <code class="cpp hljs">PT(Texture) depthTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(<span class="hljs-string"><span class="hljs-string">"depthTexture"</span></span>); depthTexture-&gt;set_format(Texture::Format::F_depth_component32); PT(GraphicsOutput) depthBuffer = graphicsOutput-&gt;make_texture_buffer(<span class="hljs-string"><span class="hljs-string">"depthBuffer"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, depthTexture); depthBuffer-&gt;set_clear_color(LVecBase4f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); NodePath depthCameraNP = window-&gt;make_camera(); DCAST(Camera, depthCameraNP.node())-&gt;set_lens(window-&gt;get_camera(<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;get_lens()); PT(DisplayRegion) depthBufferRegion = depthBuffer-&gt;make_display_region(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); depthBufferRegion-&gt;set_camera(depthCameraNP);</code> </pre> <br>  Se voc√™ decidir usar o buffer de profundidade, eis como voc√™ pode configur√°-lo no Panda3D. <br><br><pre> <code class="cpp hljs">in vec4 vertexPosition; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fragColor = vertexPosition; }</code> </pre> <br>  Aqui est√° um sombreador simples para renderizar as posi√ß√µes dos v√©rtices no espa√ßo de visualiza√ß√£o em uma textura de buffer de quadro.  Uma tarefa mais dif√≠cil √© ajustar a textura do buffer de quadros para que os componentes do vetor de fragmento obtidos por ele n√£o sejam limitados ao intervalo <code>[0, 1]</code> e que cada um tenha uma precis√£o suficientemente alta (um n√∫mero suficientemente grande de bits).  Por exemplo, se algum tipo de posi√ß√£o de v√©rtice interpolado for <code>&lt;-139.444444566, 0.00000034343, 2.5&gt;</code> , n√£o ser√° poss√≠vel salv√°-lo na textura como <code>&lt;0.0, 0.0, 1.0&gt;</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... FrameBufferProperties fbp = FrameBufferProperties::get_default(); // ... fbp.set_rgba_bits(32, 32, 32, 32); fbp.set_rgb_color(true); fbp.set_float_color(true); // ...</span></span></code> </pre> <br>  Aqui est√° um c√≥digo de exemplo que prepara uma textura de buffer de quadro para armazenar posi√ß√µes de v√©rtice.  Ele precisa de 32 bits para vermelho, verde, azul e alfa, ent√£o desabilita a restri√ß√£o de valores pelo intervalo <code>[0, 1]</code> .  A chamada para <code>set_rgba_bits(32, 32, 32, 32)</code> define o volume de bits e desativa a restri√ß√£o. <br><br><pre> <code class="cpp hljs"> glTexImage2D ( GL_TEXTURE_2D , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB32F , <span class="hljs-number"><span class="hljs-number">1200</span></span> , <span class="hljs-number"><span class="hljs-number">900</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB , GL_FLOAT , <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> );</code> </pre> <br>  Aqui est√° uma liga√ß√£o semelhante no OpenGL.  <code>GL_RGB32F</code> define os bits e desativa a restri√ß√£o. <br><br><blockquote>  Se o buffer de cores tiver uma v√≠rgula fixa, os componentes dos valores inicial e final, bem como os √≠ndices de mistura, antes de calcular a equa√ß√£o de mistura, ser√£o limitados a [0, 1] ou [-1, 1], respectivamente, para os buffers de cores normalizados e com sinaliza√ß√£o normalizados e assinados.  Se o buffer de cores tiver um ponto flutuante, a restri√ß√£o n√£o ser√° atendida. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Fonte</a> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17b/2d0/2ad/17b2d02ad53c411dc251d90fdc16fdf3.png"></div><br>  Aqui voc√™ v√™ as posi√ß√µes dos v√©rtices;  o eixo y est√° para cima. <br><br>  Lembre-se que o Panda3D define o eixo z como um vetor apontando para cima, enquanto no OpenGL o eixo y olha para cima.  O shader de posi√ß√£o exibe as posi√ß√µes dos v√©rtices com um z para cima, porque no Panda3D <br>  o par√¢metro <code>gl-coordinate-system default</code> est√° configurado. <br><br><h3>  Normal </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c4/064/9c5/0c40649c525edd7bcf3c829d6e948789.gif"></div><br>  Para a orienta√ß√£o correta das amostras obtidas no shader SSAO, precisamos dos normais para os v√©rtices.  O c√≥digo de amostra gera v√°rios vetores de amostragem distribu√≠dos no hemisf√©rio, mas voc√™ pode usar a esfera e resolver completamente o problema da necessidade de normais. <br><br><pre> <code class="cpp hljs">in vec3 vertexNormal; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 normal = normalize(vertexNormal); fragColor = vec4(normal, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Como o shader de posi√ß√£o, o shader normal √© muito simples.  Lembre-se de normalizar os normais para os v√©rtices e lembre-se de que eles est√£o no espa√ßo de visualiza√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/a82/f00/57ba82f003b0ab9c2aafa7c9affa28bb.gif"></div><br>  Os normais para os v√©rtices s√£o mostrados aqui;  o eixo y est√° para cima. <br><br>  Lembre-se de que o Panda3D considera o eixo z como o vetor ascendente e o OpenGL como o eixo y.  O sombreador normal exibe as posi√ß√µes dos v√©rtices com o eixo z apontando para cima, porque o <code>gl-coordinate-system default</code> configurado no Panda3D. <br><br><h3>  Amostras </h3><br>  Para determinar o valor da oclus√£o do ambiente para qualquer fragmento, precisamos amostrar a √°rea circundante. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; numberOfSamples; ++i) { LVecBase3f sample = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) ).normalized(); float rand = randomFloats(generator); sample[0] *= rand; sample[1] *= rand; sample[2] *= rand; float scale = (float) i / (float) numberOfSamples; scale = lerp(0.1, 1.0, scale * scale); sample[0] *= scale; sample[1] *= scale; sample[2] *= scale; ssaoSamples.push_back(sample); } // ...</span></span></code> </pre> <br>  O c√≥digo de amostra gera 64 amostras aleat√≥rias distribu√≠das em um hemisf√©rio.  Essas <code>ssaoSamples</code> ser√£o passadas para o shader SSAO. <br><br><pre> <code class="cpp hljs"> LVecBase3f sample = LVecBase3f ( randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> ).normalized();</code> </pre> <br>  Se voc√™ deseja distribuir suas amostras por uma esfera, altere o intervalo do componente aleat√≥rio z para que ele mude de menos um para um. <br><br><h3>  O barulho </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; 16; ++i) { LVecBase3f noise = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , 0.0 ); ssaoNoise.push_back(noise); } // ...</span></span></code> </pre> <br>  Para cobrir bem a √°rea amostrada, precisamos gerar vetores de ru√≠do.  Esses vetores de ru√≠do podem girar amostras ao redor da parte superior da superf√≠cie. <br><br><h3>  Oclus√£o ambiental </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c1d/bb4/d35c1dbb4e0e9dfeedc3bd4285f26004.gif"></div><br>  O SSAO realiza sua tarefa amostrando o espa√ßo de visualiza√ß√£o ao redor do fragmento.  Quanto mais amostras abaixo da superf√≠cie, mais escura a cor do fragmento.  Essas amostras est√£o localizadas no fragmento e indicam na dire√ß√£o geral do normal ao v√©rtice.  Cada amostra √© usada para procurar uma posi√ß√£o na textura da posi√ß√£o do buffer do quadro.  A posi√ß√£o retornada √© comparada com a amostra.  Se a amostra estiver mais distante da c√¢mera do que a posi√ß√£o, a amostra em dire√ß√£o ao fragmento ser√° oclu√≠da. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/b9a/f1d/cb7b9af1d4dc613f337da5a253ef5a8c.gif"></div><br>  Aqui voc√™ v√™ o espa√ßo acima da superf√≠cie amostrada para oclus√£o. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float radius = 1.1; float bias = 0.026; float lowerRange = -2; float upperRange = 2; // ...</span></span></code> </pre> <br>  Como algumas outras t√©cnicas, o shader SSAO possui v√°rios par√¢metros de controle que podem ser alterados para obter a apar√™ncia desejada.  o vi√©s √© adicionado √† dist√¢ncia da amostra para a c√¢mera.  Este par√¢metro pode ser usado para combater manchas.  raio aumenta ou diminui a √°rea de cobertura do espa√ßo da amostra.  lowerRange e upperRange alteram o intervalo padr√£o da m√©trica do fator de <code>[0, 1]</code> para qualquer valor selecionado.  Ao aumentar o alcance, voc√™ pode aumentar o contraste. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); vec3 normal = texture(normalTexture, texCoord).xyz; int noiseX = int(gl_FragCoord.x - 0.5) % 4; int noiseY = int(gl_FragCoord.y - 0.5) % 4; vec3 random = noise[noiseX + (noiseY * 4)]; // ...</span></span></code> </pre> <br>  Obtemos a posi√ß√£o, vetor normal e aleat√≥rio para uso posterior.  Lembre-se de que no exemplo de c√≥digo, 16 vetores aleat√≥rios foram criados.  Um vetor aleat√≥rio √© selecionado com base na posi√ß√£o da tela dos fragmentos atuais. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 tangent = normalize(random - normal * dot(random, normal)); vec3 binormal = cross(normal, tangent); mat3 tbn = mat3(tangent, binormal, normal); // ...</span></span></code> </pre> <br>  Usando um vetor aleat√≥rio e um vetor normal, coletamos a matriz da tangente, binormal e normal.  Precisamos dessa matriz para transformar os vetores de amostra do espa√ßo tangente para o espa√ßo de pesquisa. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float occlusion = NUM_SAMPLES; for (int i = 0; i &lt; NUM_SAMPLES; ++i) { // ... } // ...</span></span></code> </pre> <br>  Tendo uma matriz, o shader pode fazer um loop atrav√©s de todas as amostras no loop, subtraindo o n√∫mero de amostras fechadas. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 sample = tbn * samples[i]; sample = position.xyz + sample * radius; // ...</span></span></code> </pre> <br>  Usando a matriz, coloque a amostra ao lado da posi√ß√£o do v√©rtice / fragmento e dimensione-a pelo raio. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offset = vec4(sample, 1.0); offset = lensProjection * offset; offset.xyz /= offset.w; offset.xyz = offset.xyz * 0.5 + 0.5; // ...</span></span></code> </pre> <br>  Usando a posi√ß√£o da amostra no espa√ßo de visualiza√ß√£o, n√≥s a transformamos do espa√ßo de visualiza√ß√£o para o espa√ßo de recorte e depois para o espa√ßo UV. <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">-1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  N√£o se esque√ßa de que os componentes do espa√ßo de recorte est√£o no intervalo de menos um a um e as coordenadas UV est√£o no intervalo de zero a um.  Para converter as coordenadas do espa√ßo de recorte em coordenadas UV, multiplique-as por um segundo e adicione um segundo. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offsetPosition = texture(positionTexture, offset.xy); float occluded = 0; if (sample.y + bias &lt;= offsetPosition.y) { occluded = 0; } else { occluded = 1; } // ...</span></span></code> </pre> <br>  Usando as coordenadas de deslocamento UV obtidas projetando a amostra 3D na textura de posi√ß√£o 2D, encontramos o vetor de posi√ß√£o correspondente.  Isso nos leva do espa√ßo de visualiza√ß√£o para o espa√ßo de recorte para o espa√ßo UV e depois volta para o espa√ßo de visualiza√ß√£o.  O sombreador executa esse loop para determinar se existe alguma geometria atr√°s da amostra, no local da amostra ou na frente da amostra.  Se a amostra estiver localizada na frente ou em alguma geometria, ela simplesmente n√£o ser√° levada em considera√ß√£o em rela√ß√£o ao fragmento sobreposto.  Se a amostra estiver atr√°s de alguma geometria, ela ser√° levada em considera√ß√£o em rela√ß√£o ao fragmento sobreposto. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float intensity = smoothstep ( 0.0 , 1.0 , radius / abs(position.y - offsetPosition.y) ); occluded *= intensity; occlusion -= occluded; // ...</span></span></code> </pre> <br>  Agora, adicione peso a essa posi√ß√£o de amostra com base em qu√£o longe est√° dentro ou fora do raio.  Em seguida, subtraia essa amostra da m√©trica de oclus√£o, pois pressup√µe que todas as amostras foram sobrepostas antes do loop. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... occlusion /= NUM_SAMPLES; // ... fragColor = vec4(vec3(occlusion), position.a); // ...</span></span></code> </pre> <br>  Divida o n√∫mero de sobreposi√ß√µes pelo n√∫mero de amostras para converter o indicador de oclus√£o do intervalo <code>[0, NUM_SAMPLES]</code> no intervalo <code>[0, 1]</code> .  Zero significa oclus√£o completa, unidades n√£o significam oclus√£o.  Agora atribua oclus√£o √† cor do fragmento, e √© isso. <br><br>  Observe que no c√≥digo de exemplo, o canal alfa recebe o valor alfa da textura da posi√ß√£o no buffer do quadro para evitar sobreposi√ß√£o de fundo. <br><br><h3>  Desfocar </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/566/2a7/5b15662a7c46db6b8102fe9eabae17c9.gif"></div><br>  A textura do buffer de quadro SSAO √© um pouco barulhenta, ent√£o voc√™ deve desfoc√°-lo para suavizar. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( ssaoTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ).rgb; xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  O shader de desfoque do SSAO √© um desfoque de caixa comum.  Como o shader de flora√ß√£o, ele desenha uma janela sobre a textura recebida e calcula a m√©dia de cada fragmento com os valores de seus vizinhos. <br><br>  Observe que o <code>parameters.x</code> √© um par√¢metro de separa√ß√£o. <br><br><h3>  Cor ambiente </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 ssaoBlurTexSize = textureSize(ssaoBlurTexture, 0).xy; vec2 ssaoBlurTexCoord = gl_FragCoord.xy / ssaoBlurTexSize; float ssao = texture(ssaoBlurTexture, ssaoBlurTexCoord).r; vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex * ssao; // ...</span></span></code> </pre> <br>  O desafio final para o SSAO est√° novamente nos c√°lculos de ilumina√ß√£o.  Aqui vemos como a oclus√£o √© encontrada no buffer de textura SSAO e √© inclu√≠da no c√°lculo da luz ambiente. <br><br><h3>  C√≥digo fonte </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">position.frag</a> </li><li>  <a href="">normal.frag</a> </li><li>  <a href="">ssao.frag</a> </li><li>  <a href="">blur.frag</a> </li></ul><br><h2>  Profundidade de campo </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/eb0/10f/6efeb010f4623ff49b928d72550f7985.gif"></div><br>  A profundidade de campo tamb√©m √© esse efeito, tendo aprendido sobre o que, voc√™ n√£o pode viver sem ele.  Do ponto de vista art√≠stico, voc√™ pode us√°-lo para atrair a aten√ß√£o do visualizador para um objeto espec√≠fico.  Mas, no caso geral, a profundidade de campo, √† custa de um pequeno esfor√ßo, acrescenta uma grande parcela de realismo. <br><br><h3>  Em foco </h3><br>  O primeiro passo √© renderizar a cena completamente em foco.  Renderize-o na textura do buffer do quadro.  Ser√° um dos valores de entrada para a profundidade do buffer do campo. <br><br><h3>  Fora de foco </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 result = vec4(0); for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( blurTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ); xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  O segundo passo √© desfocar a cena como se estivesse completamente fora de foco.  Assim como no bloom e no SSAO, voc√™ pode usar o desfoque de caixa.  Renderize esta cena desfocada para a textura do buffer do quadro.  Ser√° outro valor de entrada para a profundidade do sombreador de campo. <br><br>  Observe que o <code>parameters.x</code> √© um par√¢metro de separa√ß√£o. <br><br><h3>  Confus√£o </h3><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d68/067/83a/d6806783a567c4708d8f13dcb0763f7c.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float focalLengthSharpness = 100; float blurRate = 6; // ...</span></span></code> </pre> <br>  Voc√™ pode personalizar essas op√ß√µes ao seu gosto.  <code>focalLengthSharpness</code> afeta a <code>focalLengthSharpness</code> da cena na dist√¢ncia focal.  Quanto menor a <code>focalLengthSharpness</code> , mais desfocada ser√° a dist√¢ncia focal.  <code>blurRate</code> afeta a velocidade de desfoque da cena ao se afastar da dist√¢ncia focal.  Quanto menor o <code>blurRate</code> , menos borrada ser√° a cena ao <code>blurRate</code> afastar do ponto de foco. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 focusColor = texture(focusTexture, texCoord); vec4 outOfFocusColor = texture(outOfFocusTexture, texCoord); // ...</span></span></code> </pre> <br>  Vamos precisar de cores em foco e em uma imagem desfocada. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); // ...</span></span></code> </pre> <br>  Tamb√©m podemos precisar da posi√ß√£o do v√©rtice no espa√ßo de visualiza√ß√£o.  Voc√™ pode reaplicar a textura das posi√ß√µes do buffer de quadro usado para o SSAO. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float blur = clamp ( pow ( blurRate , abs(position.y - focalLength.x) ) / focalLengthSharpness , 0 , 1 ); // ... fragColor = mix(focusColor, outOfFocusColor, blur); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E aqui a confus√£o acontece. </font><font style="vertical-align: inherit;">Quanto mais pr√≥ximo </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de um, mais ele usar√° </font></font><code>outOfFocusColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um valor zero </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa que esse fragmento est√° totalmente em foco. </font><font style="vertical-align: inherit;">Com </font></font><code>blur &gt;= 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este fragmento √© completamente desfocado.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fonte </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blur.frag</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depth-of-field.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posteriza√ß√£o </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/078/84d/f1807884d79c5c73915ce9adf6ead5cb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posteriza√ß√£o, ou amostragem de cores, √© o processo de redu√ß√£o do n√∫mero de cores exclusivas em uma imagem. </font><font style="vertical-align: inherit;">Voc√™ pode usar esse shader para dar ao jogo uma apar√™ncia c√¥mica ou retr√¥. </font><font style="vertical-align: inherit;">Se voc√™ combin√°-lo com um esbo√ßo, voc√™ obt√©m um estilo de desenho animado real.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float levels = 8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode experimentar com este par√¢metro. </font><font style="vertical-align: inherit;">Quanto maior, mais flores permanecer√£o como resultado.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 texColor = texture(posterizeTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos precisar da cor recebida. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 grey = vec3((texColor.r + texColor.g + texColor.b) / 3.0); vec3 grey1 = grey; grey = floor(grey * levels) / levels; texColor.rgb += (grey - grey1); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu n√£o vi esse m√©todo de posteriza√ß√£o. </font><font style="vertical-align: inherit;">Depois de verific√°-lo, vi que ele cria resultados mais bonitos em compara√ß√£o aos m√©todos convencionais. </font><font style="vertical-align: inherit;">Para reduzir a paleta de cores, primeiro converta a cor em um valor em escala de cinza. </font><font style="vertical-align: inherit;">N√≥s discretizamos a cor, amarrando-a a um dos n√≠veis. </font><font style="vertical-align: inherit;">Calculamos a diferen√ßa entre o valor discretizado em escala de cinza e o valor n√£o discretizado em escala de cinza. </font><font style="vertical-align: inherit;">Adicione essa diferen√ßa √† cor de entrada. </font><font style="vertical-align: inherit;">Essa diferen√ßa √© a quantidade pela qual a cor deve aumentar / diminuir para atingir um valor discreto em escala de cinza.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texColor; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√£o se esque√ßa de atribuir o valor da cor de entrada √† cor do fragmento. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cel shading </font></font></h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d1/f9c/133/2d1f9c1333960c0299388fc51323a8b3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A posteriza√ß√£o pode fazer a imagem parecer um sombreamento de cel, porque o processo de discretizar cores difusas e difusas em tons discretos. </font><font style="vertical-align: inherit;">Queremos usar apenas cores difusas s√≥lidas sem detalhes finos do mapa normal e um valor pequeno </font></font><code>levels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fonte </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posterize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixeliza√ß√£o </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/0b9/9bc/3960b99bc2f1fa900c40a1c9f32169bc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pixeliza√ß√£o de um jogo em 3D pode dar uma apar√™ncia interessante ou poupar tempo que levaria para criar toda a arte de pixel manualmente. </font><font style="vertical-align: inherit;">Combine-o com a posteriza√ß√£o para criar uma verdadeira apar√™ncia retr√¥.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int pixelSize = 5; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode ajustar o tamanho do pixel. </font><font style="vertical-align: inherit;">Quanto maior, mais rugosa ser√° a imagem.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/818/aee/413818aee5509763cc383f800b837cfb.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float x = int(gl_FragCoord.x) % pixelSize; float y = int(gl_FragCoord.y) % pixelSize; x = floor(pixelSize / 2.0) - x; y = floor(pixelSize / 2.0) - y; x = gl_FragCoord.x + x; y = gl_FragCoord.y + y; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa t√©cnica anexa cada fragmento ao centro da janela em tamanho de pixel n√£o sobreposta mais pr√≥xima. </font><font style="vertical-align: inherit;">Essas janelas se alinham sobre a textura recebida. </font><font style="vertical-align: inherit;">Fragmentos no centro da janela determinam a cor de outros fragmentos na janela.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texture(pixelizeTexture, vec2(x, y) / texSize); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depois de determinarmos a coordenada do fragmento desejado a ser usado, retire sua cor da textura recebida e atribua-a √† cor do fragmento. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fonte </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixelize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afiar </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/674/617/b52674617a0733ee1fe0d525b0053750.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O efeito de nitidez (nitidez) aumenta o contraste nas bordas da imagem. </font><font style="vertical-align: inherit;">√â √∫til quando os gr√°ficos acabam sendo muito suaves.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alterando o valor, podemos controlar a magnitude da nitidez do resultado. </font><font style="vertical-align: inherit;">Se o valor for zero, a imagem n√£o ser√° alterada. </font><font style="vertical-align: inherit;">Com valores negativos, a imagem come√ßa a parecer estranha.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float neighbor = amount * -1; float center = amount * 4 + 1; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentos adjacentes s√£o multiplicados por </font></font><code>amount * -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O fragmento atual √© multiplicado por </font></font><code>amount * 4 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 color = texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 1) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x - 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 0) / texSize).rgb * center + texture(sharpenTexture, vec2(gl_FragCoord.x + 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y - 1) / texSize).rgb * neighbor ; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os fragmentos vizinhos est√£o na parte superior, inferior, esquerda e direita. </font><font style="vertical-align: inherit;">Depois de multiplicar os vizinhos e o fragmento atual por seus valores, o resultado √© somado.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = vec4(color, texture(sharpenTexture, texCoord).a); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Essa quantidade √© a cor final do fragmento. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fonte </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sharpen.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gr√£o de filme </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f3/16e/232/2f316e232598d07fa8114f8db32c12a7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A granula√ß√£o do filme (em pequenas doses, e n√£o como no exemplo) pode adicionar realismo, que √© invis√≠vel at√© que esse efeito seja removido. </font><font style="vertical-align: inherit;">Geralmente, essas s√£o as imperfei√ß√µes que tornam a imagem gerada digitalmente mais convincente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que a granula√ß√£o do filme geralmente √© o √∫ltimo efeito aplicado ao quadro antes de ser exibido.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Valor </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.1; // ...</span></span></code> </pre> <br> <code>amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">controla a visibilidade do gr√£o do filme. </font><font style="vertical-align: inherit;">Quanto maior o valor, mais "neve" na imagem.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Brilho aleat√≥rio </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform float osg_FrameTime; //... float toRadians = 3.14 / 180; //... float randomIntensity = fract ( 10000 * sin ( ( gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime ) * toRadians ) ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este trecho de c√≥digo calcula o brilho aleat√≥rio necess√°rio para ajustar o valor. </font></font><br><br><pre> <code class="cpp hljs">Time Since F1 = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> Frame Number = F1 F3 F4 F5 F6 osg_FrameTime = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor </font></font><code>osg_FrameTime</code> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornecido pelo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panda3D. </font><font style="vertical-align: inherit;">Um tempo de quadro √© um registro de data e hora com informa√ß√µes sobre quantos segundos se passaram desde o primeiro quadro. </font><font style="vertical-align: inherit;">O c√≥digo de amostra usa-o para animar a granula√ß√£o do filme, que </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser√° diferente em cada quadro.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... ( gl_FragCoord.x + gl_FragCoord.y * 8009 // Large number here. // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para gr√£os est√°ticos, os filmes devem ser substitu√≠dos por um </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grande n√∫mero. </font><font style="vertical-align: inherit;">Para evitar a visualiza√ß√£o de padr√µes, voc√™ pode tentar n√∫meros diferentes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/358/2bd/6d2/3582bd6d2d67eb5ac1fdcdf8d52800e6.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... * sin ( ( gl_FragCoord.x + gl_FragCoord.y * someNumber // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar pontos ou pontos de granula√ß√£o de filme, s√£o utilizadas as duas coordenadas ex, ey. </font><font style="vertical-align: inherit;">Se voc√™ usar x, somente as linhas verticais ser√£o exibidas; se voc√™ usar y, somente as linhas horizontais ser√£o exibidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No c√≥digo, uma coordenada √© multiplicada por outra para destruir a simetria diagonal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/ad6/d5a/4c0ad6d5ada5d533b6dc31bbfa7aa0fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, voc√™ pode se livrar do multiplicador de coordenadas e obter um efeito de chuva completamente aceit√°vel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que, para animar o efeito da chuva, multiplique a sa√≠da </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experimente as coordenadas xey para mudar a dire√ß√£o da chuva. </font><font style="vertical-align: inherit;">Para um banho descendente, deixe apenas a coordenada x.</font></font><br><br><pre> <code class="cpp hljs">input = (gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime) * toRadians frame(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) =</code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usado como uma fun√ß√£o hash. </font><font style="vertical-align: inherit;">As coordenadas do fragmento s√£o hash com valores de sa√≠da </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gra√ßas a isso, aparece uma propriedade conveniente - quaisquer que sejam os dados de entrada (grandes ou pequenos), o intervalo de sa√≠da estar√° na faixa de menos um a um.</font></font><br><br><pre> <code class="cpp hljs">fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) = fract(<span class="hljs-number"><span class="hljs-number">6400.723818964882</span></span>) = <span class="hljs-number"><span class="hljs-number">0.723818964882</span></span></code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em combina√ß√£o com </font></font><code>fract</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m usado como gerador de n√∫meros pseudo-aleat√≥rios.</font></font><br><br><pre> <code class="cpp hljs">&gt;&gt;&gt; [<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(fract(<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(x * toRadians)) * <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 0, 1, 2, 2, 3, 4, 4, 5, 6] &gt;&gt;&gt; [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fract(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10000</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(x * toRadians)) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 4, 8, 0, 2, 1, 7, 0, 0, 5]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, olhe para a primeira linha de n√∫meros e depois para a segunda. </font><font style="vertical-align: inherit;">Cada linha √© determin√≠stica, mas o padr√£o √© menos percept√≠vel na segunda do que na segunda. </font><font style="vertical-align: inherit;">Portanto, apesar do resultado ser </font></font><code>fract(10000 * sin(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determin√≠stico, o padr√£o √© reconhecido muito mais fraco.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/6e7/f0f/b886e7f0feda6760c5fc87df6680680f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui vemos como o fator </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© primeiro 1, depois 10, depois 100 e depois 1000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä medida que o multiplicador dos valores de sa√≠da aumenta, o </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">padr√£o se torna menos percept√≠vel. </font><font style="vertical-align: inherit;">Por esse motivo, o c√≥digo </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© multiplicado por 10.000.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cor do fragmento </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 texSize = textureSize(filmGrainTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; vec4 color = texture(filmGrainTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Converta as coordenadas do fragmento em coordenadas UV. </font><font style="vertical-align: inherit;">Usando essas coordenadas UV, procuramos a cor da textura do fragmento atual.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... amount *= randomIntensity; color.rgb += amount; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Altere o valor para um brilho aleat√≥rio e adicione-o √† cor. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = color; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Defina a cor do fragmento, e √© isso. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fonte </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">film-grain.frag</font></font></a> </li></ul><br><h2>  Agradecimentos </h2><br><ul><li>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Kiwi Soda Font</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453692/">https://habr.com/ru/post/pt453692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453676/index.html">Conectando-se ao Windows via SSH como no Linux</a></li>
<li><a href="../pt453678/index.html">Como ver reverbera√ß√£o ou transmiss√£o de v√≠deo pelo som atrav√©s da √°gua - 2</a></li>
<li><a href="../pt453682/index.html">Desenvolvimento do ‚Äúfirmware‚Äù mais simples para FPGAs instalados em Redd. Parte 2. C√≥digo do Programa</a></li>
<li><a href="../pt453686/index.html">Semana 22 de Seguran√ßa: estat√≠sticas de amea√ßas, cavalos de Troia banc√°rios e explora√ß√µes populares</a></li>
<li><a href="../pt453688/index.html">Java n√£o √© apenas uma empresa sangrenta, mas tamb√©m aplicativos r√°pidos e sens√≠veis √† lat√™ncia</a></li>
<li><a href="../pt453694/index.html">Conecte-se ao Windows via SSH como no Linux</a></li>
<li><a href="../pt453696/index.html">Liga√ß√£o bidirecional angular, um pouco mais de compreens√£o</a></li>
<li><a href="../pt453698/index.html">Informa√ß√£o qu√¢ntica na consci√™ncia qu√¢ntica</a></li>
<li><a href="../pt453700/index.html">Li√ß√µes sobre SDL 2: Li√ß√£o 1 - Ol√°, SDL 2</a></li>
<li><a href="../pt453706/index.html">Como passei no exame de certifica√ß√£o do Google Cloud Professional Data Engineer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>