<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÜ ü§í ü§öüèº [DotNetBook] Pengecualian: Jenis Arsitektur Sistem üõµ üï∫ üè¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan artikel ini, saya terus menerbitkan serangkaian artikel, yang hasilnya akan menjadi buku tentang karya .NET CLR, dan .NET secara umum. Untuk ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[DotNetBook] Pengecualian: Jenis Arsitektur Sistem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/419927/"><p><img width="350" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png" align="left">  Dengan artikel ini, saya terus menerbitkan serangkaian artikel, yang hasilnya akan menjadi buku tentang karya .NET CLR, dan .NET secara umum.  Untuk tautan - selamat datang ke kucing. </p><br><h2 id="arhitektura-isklyuchitelnoy-situacii">  Arsitektur Pengecualian </h2><br><p> Mungkin salah satu masalah terpenting tentang topik pengecualian adalah masalah membangun arsitektur pengecualian dalam aplikasi Anda.  Pertanyaan ini menarik karena berbagai alasan.  Bagi saya, hal utama adalah kesederhanaan yang nampak yang tidak selalu jelas apa yang harus dilakukan.  Properti ini melekat dalam semua konstruksi dasar yang digunakan di mana-mana: properti ini <code>IEnumerable</code> , dan <code>IDisposable</code> dan <code>IObservable</code> dan lainnya.  Di satu sisi, mereka memberi isyarat oleh kesederhanaan mereka, melibatkan diri mereka dalam menggunakan diri mereka dalam berbagai situasi.  Dan di sisi lain, mereka penuh dengan pusaran air dan fords, dari mana, tidak tahu bagaimana kadang-kadang tidak keluar sama sekali.  Dan, mungkin, melihat volume masa depan, pertanyaan Anda telah matang: jadi apa itu dalam situasi luar biasa? </p><br><blockquote><h3>  Catatan </h3><br>  Bab yang diterbitkan di Habr√© tidak diperbarui dan, mungkin, sudah agak ketinggalan zaman.  Dan karena itu, silakan buka teks asli untuk teks yang lebih baru: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub, daftar isi</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  Buku CLR: <a href="">GitHub, bab</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Rilis 0,5.2 buku, PDF: <a href="">Rilis GitHub</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p><a name="habracut"></a><br><p>  Tetapi untuk sampai pada kesimpulan tentang konstruksi arsitektur kelas situasi luar biasa, kami harus mengumpulkan beberapa pengalaman dengan Anda mengenai klasifikasi mereka.  Setelah semua, hanya setelah memahami apa yang akan kita hadapi, bagaimana dan dalam situasi apa programmer harus memilih jenis kesalahan, dan di mana - membuat pilihan mengenai menangkap atau melompati pengecualian, Anda dapat memahami bagaimana Anda bisa membangun sistem tipe sedemikian rupa sehingga menjadi jelas bagi pengguna Anda kode.  Oleh karena itu, kami akan mencoba untuk mengklasifikasikan situasi luar biasa (bukan jenis pengecualian itu sendiri, tetapi situasi yang tepat) sesuai dengan berbagai kriteria. </p><br><h3 id="po-teoreticheskoy-vozmozhnosti-perehvata-proektiruemogo-isklyucheniya">  Menurut kemungkinan teoritis menangkap pengecualian yang diproyeksikan </h3><br><p>  Dalam hal intersepsi teoritis, pengecualian dapat dengan mudah dibagi menjadi dua jenis: mereka yang akan mencegat secara akurat dan mereka yang sangat mungkin untuk mencegat.  Mengapa <em>dengan tingkat probabilitas yang tinggi</em> ?  Karena akan selalu ada seseorang yang akan mencoba mencegat, walaupun ini tidak harus dilakukan sepenuhnya. </p><br><p>  Mari kita pertama-tama mengungkapkan fitur-fitur kelompok pertama: pengecualian yang harus dan akan ditangkap. </p><br><p>  Ketika kami memperkenalkan pengecualian jenis ini, di satu sisi kami memberi tahu subsistem eksternal bahwa kami berada dalam posisi di mana tindakan lebih lanjut dalam data kami tidak masuk akal.  Di sisi lain, kami berarti bahwa tidak ada global yang rusak dan jika kami dihapus, tidak ada yang akan berubah, dan karena itu pengecualian ini dapat dengan mudah dicegat untuk memperbaiki situasi.  Properti ini sangat penting: properti menentukan kekritisan kesalahan dan keyakinan bahwa jika Anda menangkap pengecualian dan menghapus sumber daya, Anda dapat dengan aman mengeksekusi kode lebih lanjut. </p><br><p>  Kelompok kedua, betapapun anehnya kedengarannya, bertanggung jawab atas pengecualian yang tidak perlu ditangkap.  Mereka hanya dapat digunakan untuk menulis ke log kesalahan, tetapi tidak untuk memperbaiki situasi.  Contoh paling sederhana adalah pengecualian grup <code>ArgumentException</code> dan <code>NullReferenceException</code> .  Memang, dalam situasi normal, Anda tidak boleh, misalnya, menangkap pengecualian <code>ArgumentNullException</code> karena sumber masalahnya di sini adalah Anda, dan bukan orang lain.  Jika Anda menangkap pengecualian ini, maka Anda menganggap bahwa Anda melakukan kesalahan dan memberikan metode yang tidak dapat Anda berikan kepada: </p><br><pre> <code class="plaintext hljs">void SomeMethod(object argument) { try { AnotherMethod(argument); } catch (ArgumentNullException exception) { // Log it } }</code> </pre> <br><p>  Dalam metode ini, kami mencoba menangkap <code>ArgumentNullException</code> .  Tapi menurut saya, intersepsi itu terlihat sangat aneh: melemparkan argumen yang benar ke metode sepenuhnya menjadi perhatian kita.  Tidak akan benar untuk bereaksi setelah fakta: dalam situasi seperti itu, hal yang paling benar yang dapat dilakukan adalah memeriksa data yang dikirimkan terlebih dahulu, sebelum memanggil metode, atau bahkan lebih baik, untuk membangun kode sedemikian rupa sehingga menerima parameter yang salah tidak mungkin dilakukan. </p><br><p>  Kelompok lain adalah penghapusan kesalahan fatal.  Jika cache tertentu rusak dan operasi subsistem tidak akan benar dalam hal apa pun?  Maka ini adalah kesalahan fatal dan kode yang paling dekat dengan stack tidak akan dijamin untuk mencegatnya: </p><br><pre> <code class="plaintext hljs">T GetFromCacheOrCalculate() { try { if(_cache.TryGetValue(Key, out var result)) { return result; } else { T res = Strategy(Key); _cache[Key] = res; return res; } } catch (CacheCorreptedException exception) { RecreateCache(); return GetFromCacheOrCalculate(); } }</code> </pre> <br><p>  Dan biarkan <code>CacheCorreptedException</code> menjadi pengecualian yang berarti "cache pada hard drive tidak konsisten."  Kemudian ternyata bahwa jika penyebab kesalahan seperti itu berakibat fatal bagi subsistem caching (misalnya, tidak ada izin ke file cache), maka kode selanjutnya jika tidak dapat membuat kembali cache dengan perintah <code>RecreateCache</code> , dan karena itu fakta menangkap pengecualian ini adalah kesalahan itu sendiri. </p><br><h3 id="po-fakticheskomu-perehvatu-isklyuchitelnoy-situacii">  Pada intersepsi sebenarnya pengecualian </h3><br><p>  Pertanyaan lain yang menghentikan pemikiran kami dalam algoritme pemrograman adalah pemahaman: apakah layak untuk menangkap pengecualian ini atau lainnya atau layakkah seseorang yang memahami untuk membiarkannya melaluinya.  Menerjemahkan ke dalam bahasa istilah pertanyaan yang perlu kita selesaikan adalah untuk membedakan antara bidang tanggung jawab.  Mari kita lihat kode berikut: </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { public class WildStrategy : StrategyBase { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { ?try? { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { } } } } using JetFinance.Strategies; using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); ?try? { boo.DoSomethingWild(); } catch(StrategyException exception) { } }</code> </pre><br><p>  Manakah dari dua strategi yang diusulkan lebih benar?  Area tanggung jawab sangat penting.  Pada awalnya, mungkin terlihat bahwa karena pekerjaan <code>WildInvestment</code> dan konsistensinya sepenuhnya bergantung pada <code>WildStrategy</code> , jika <code>WildInvestment</code> mengabaikan pengecualian ini, itu akan naik ke level yang lebih tinggi dan tidak perlu melakukan hal lain.  Namun, harap dicatat bahwa ada masalah arsitektur murni: metode <code>Main</code> menangkap pengecualian dari satu lapisan arsitektur dengan menggunakan metode yang berbeda secara arsitektur.  Seperti apa dalam hal penggunaan?  Ya, secara umum, ini terlihat seperti ini: </p><br><ul><li>  kekhawatiran untuk pengecualian ini hanya kalah dari kami; </li><li>  pengguna kelas ini tidak yakin bahwa pengecualian ini dilemparkan melalui sejumlah metode sebelum kita secara khusus </li><li>  kita mulai menggambar kecanduan yang tidak perlu, yang kita singkirkan, menyebabkan lapisan perantara. </li></ul><br><p>  Namun, kesimpulan lain mengikuti dari kesimpulan ini: kita harus menetapkan <code>catch</code> dalam metode <code>DoSomethingWild</code> .  Dan ini agak aneh bagi kami: <code>WildInvestment</code> tampaknya sangat tergantung pada seseorang.  Yaitu  jika <code>PlayRussianRoulette</code> tidak dapat bekerja, maka <code>DoSomethingWild</code> juga: ia tidak memiliki kode kembali, tetapi harus memainkan roulette.  Apa yang harus dilakukan dalam situasi yang tampaknya tanpa harapan?  Jawabannya sebenarnya sederhana: berada di lapisan lain, <code>DoSomethingWild</code> harus membuang pengecualiannya sendiri, yang merujuk ke lapisan ini dan membungkus sumber asli sebagai sumber masalah - di <code>InnerException</code> : </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { pubilc class WildStrategy { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { try { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { throw new FailedInvestmentException("Oops", exception); } } } public class InvestmentException : Exception { /* .. */ } public class FailedInvestmentException : Exception { /* .. */ } } using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); try { boo.DoSomethingWild(); } catch(FailedInvestmentException exception) { } }</code> </pre> <br><p>  Mengubah pengecualian ke yang lain, kami pada dasarnya mentransfer masalah dari satu lapisan aplikasi ke lapisan lain, menjadikan pekerjaannya lebih dapat diprediksi dari sudut pandang pengguna kelas ini: metode <code>Main</code> . </p><br><h3 id="po-voprosam-pereispolzovaniya">  Untuk masalah penggunaan kembali </h3><br><p>  Sangat sering kita menghadapi tugas yang sulit: di satu sisi, kita terlalu malas untuk membuat jenis pengecualian baru, dan ketika kita memutuskan, tidak selalu jelas apa yang harus didorong: jenis yang harus diambil sebagai basis sebagai basis.  Tetapi justru keputusan inilah yang menentukan seluruh arsitektur situasi luar biasa.  Mari kita membahas solusi populer dan menarik beberapa kesimpulan. </p><br><p>  Saat memilih jenis pengecualian, Anda dapat mencoba mengambil solusi yang sudah ada: cari pengecualian dengan makna yang sama dalam nama dan gunakan itu.  Misalnya, jika kami diberi entitas melalui parameter yang entah bagaimana tidak cocok dengan kami, kami dapat melempar <code>InvalidArgumentException</code> , yang mengindikasikan penyebab kesalahan dalam Pesan.  Skenario ini terlihat bagus, terutama mengingat bahwa <code>InvalidArgumentException</code> termasuk dalam kelompok pengecualian yang tidak dikenakan tangkapan wajib.  Tetapi memilih <code>InvalidDataException</code> akan buruk jika Anda bekerja dengan data apa pun.  Hanya karena jenis ini ada di zona <code>System.IO</code> , dan ini hampir tidak apa yang Anda lakukan.  Yaitu  ternyata menemukan jenis yang ada karena malas melakukan sendiri hampir selalu menjadi pendekatan yang salah.  Hampir tidak ada pengecualian yang dibuat untuk lingkaran tugas umum.  Hampir semua dari mereka diciptakan untuk situasi tertentu dan penggunaannya kembali akan menjadi pelanggaran berat arsitektur situasi luar biasa.  Selain itu, setelah menerima pengecualian dari jenis tertentu (misalnya, <code>System.IO.InvalidDataException</code> sama), pengguna akan bingung: di satu sisi, ia akan melihat sumber masalah di <code>System.IO</code> sebagai pengecualian namespace, dan di sisi lain, namespace yang sama sekali berbeda untuk titik melempar.  Plus, memikirkan aturan untuk melempar pengecualian ini, itu akan pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Referenceource.microsoft.com</a> dan menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semua tempat di mana itu dilemparkan</a> : </p><br><ul><li> <code>internal class System.IO.Compression.Inflater</code> </li> </ul><br><p>  Dan dia akan mengerti itu <del>  hanya seseorang yang tangannya bengkok </del>  pilihan jenis pengecualian membingungkannya, karena metode yang melempar pengecualian tidak terlibat dalam kompresi. </p><br><p>  Selain itu, untuk menyederhanakan penggunaan kembali, Anda cukup mengambil dan membuat satu pengecualian dengan mendeklarasikan bidang <code>ErrorCode</code> dengan kode kesalahan dan hidup bahagia selamanya.  Tampaknya: solusi yang bagus.  Lempar pengecualian yang sama di mana-mana, mengatur kode, menangkap hanya satu <code>catch</code> sehingga meningkatkan stabilitas aplikasi: dan tidak ada lagi yang bisa dilakukan.  Namun, mohon tidak setuju dengan posisi ini.  Bertindak dengan cara ini sepanjang aplikasi, di satu sisi, tentu saja, Anda menyederhanakan hidup Anda.  Tetapi di sisi lain, Anda membuang kemampuan untuk menangkap subkelompok pengecualian, disatukan oleh beberapa fitur umum.  Bagaimana ini dilakukan, misalnya, dengan <code>ArgumentException</code> , yang dengan sendirinya menggabungkan seluruh kelompok pengecualian dengan warisan.  Minus serius kedua adalah lembar kode yang terlalu besar dan tidak dapat dibaca yang akan mengatur pemfilteran dengan kode kesalahan.  Tetapi jika Anda mengambil situasi yang berbeda: ketika finalisasi kesalahan seharusnya tidak penting bagi pengguna akhir, pengenalan tipe generalisasi ditambah kode kesalahan terlihat sudah menjadi aplikasi yang jauh lebih benar: </p><br><pre> <code class="plaintext hljs">public class ParserException : Exception { public ParserError ErrorCode { get; } public ParserException(ParserError errorCode) { ErrorCode = errorCode; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket, // ... } // Usage throw new ParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Kode yang melindungi panggilan parser hampir selalu acuh tak acuh untuk alasan apa parsing diblokir: fakta kesalahan itu sendiri penting untuk itu.  Namun, jika ini tetap menjadi penting, pengguna akan selalu dapat mengekstrak kode kesalahan dari <code>ErrorCode</code> .  Untuk melakukan ini, tidak perlu mencari kata-kata yang diperlukan dengan substring di <code>Message</code> . </p><br><p>  Jika Anda mulai dari mengabaikan masalah penggunaan kembali, Anda bisa membuat tipe pengecualian untuk setiap situasi.  Di satu sisi, ini terlihat logis: satu jenis kesalahan adalah satu jenis pengecualian.  Namun, di sini, seperti dalam segala hal, hal utama adalah tidak berlebihan: memiliki operasi yang luar biasa pada setiap titik rilis, Anda menyebabkan masalah untuk intersepsi: kode metode panggilan akan kelebihan beban dengan <code>catch</code> block.  Lagi pula, ia perlu menangani semua jenis pengecualian yang ingin Anda berikan kepadanya.  Kekurangan lainnya adalah murni arsitektur.  Jika Anda tidak menggunakan warisan, maka Anda mengacaukan pengguna pengecualian ini: mungkin ada banyak kesamaan di antara mereka, dan Anda harus mencegatnya secara individual. </p><br><p>  Namun demikian, ada skenario yang baik untuk memperkenalkan tipe tertentu untuk situasi tertentu.  Misalnya, ketika kerusakan terjadi bukan untuk seluruh entitas secara keseluruhan, tetapi untuk metode tertentu.  Maka jenis ini harus berada dalam hierarki warisan di tempat sedemikian rupa sehingga tidak ada pemikiran untuk mencegatnya bersama dengan sesuatu yang lain: misalnya, memilihnya melalui cabang warisan yang terpisah. </p><br><p>  Selain itu, jika Anda menggabungkan kedua pendekatan ini, Anda bisa mendapatkan kotak alat yang sangat kuat untuk bekerja dengan sekelompok kesalahan: Anda bisa memperkenalkan tipe abstrak umum untuk mewarisi situasi khusus tertentu.  Kelas dasar (tipe generalisasi kami) harus dilengkapi dengan properti abstrak yang menyimpan kode kesalahan, dan ahli waris akan menimpa properti ini untuk menentukan kode kesalahan ini: </p><br><pre> <code class="plaintext hljs">public abstract class ParserException : Exception { public abstract ParserError ErrorCode { get; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket } public class MissingModifierParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingModifier; } public class MissingBracketParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingBracket; } // Usage throw new MissingModifierParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Apa properti indah yang kita dapatkan dengan pendekatan ini? </p><br><ul><li>  di satu sisi, kami mempertahankan penangkapan pengecualian dengan tipe dasar; </li><li>  di sisi lain, menangkap pengecualian dengan tipe dasar, masih mungkin untuk mengetahui situasi tertentu; </li><li>  dan ditambah untuk semua itu mungkin untuk mencegat untuk tipe tertentu, dan bukan untuk yang dasar, tanpa menggunakan struktur datar kelas. </li></ul><br><p>  Bagi saya, ini adalah pilihan yang sangat nyaman. </p><br><h3 id="po-otnosheniyu-k-edinoy-gruppe-povedencheskih-situaciy">  Sehubungan dengan satu kelompok situasi perilaku </h3><br><p>  Kesimpulan apa yang dapat ditarik berdasarkan alasan yang dijelaskan sebelumnya?  Mari kita coba merumuskannya: </p><br><p>  Untuk memulai, mari kita putuskan apa yang dimaksud dengan situasi.  Ketika kita berbicara tentang kelas dan objek, kita terutama terbiasa dengan entitas yang beroperasi dengan keadaan internal di mana kita dapat melakukan tindakan.  Ternyata dengan melakukan itu kami menemukan jenis situasi perilaku pertama: tindakan pada entitas tertentu.  Selanjutnya, jika Anda melihat grafik objek seolah-olah dari luar, Anda akan melihat bahwa itu secara logis digabungkan ke dalam kelompok fungsional: yang pertama berkaitan dengan caching, yang kedua berurusan dengan basis data, yang ketiga melakukan perhitungan matematis.  Lapisan dapat melewati semua grup fungsional ini: lapisan logging dari berbagai status internal, proses logging, jejak pemanggilan metode.  Lapisan dapat lebih mencakup: menggabungkan beberapa kelompok fungsional.  Misalnya, lapisan model, lapisan pengontrol, lapisan presentasi.  Kelompok-kelompok ini dapat berada dalam majelis yang sama, atau dalam kelompok yang sama sekali berbeda, tetapi masing-masing dari mereka dapat menciptakan situasi yang luar biasa. </p><br><p>  Ternyata jika Anda berdebat dengan cara ini, Anda dapat membangun beberapa hierarki jenis situasi luar biasa, berdasarkan jenis yang dimiliki grup atau lapisan tertentu, sehingga menciptakan kemampuan untuk menangkap pengecualian pada kode untuk navigasi semantik yang mudah dalam hierarki jenis ini. </p><br><p>  Mari kita lihat kodenya: </p><br><pre> <code class="plaintext hljs">namespace JetFinance { namespace FinancialPipe { namespace Services { namespace XmlParserService { } namespace JsonCompilerService { } namespace TransactionalPostman { } } } namespace Accounting { /* ... */ } }</code> </pre><br><p>  Seperti apa bentuknya?  Bagi saya, ruang nama adalah peluang besar untuk secara alami mengelompokkan jenis pengecualian sesuai dengan situasi perilaku mereka: segala sesuatu yang termasuk dalam kelompok tertentu harus ada di sana, termasuk pengecualian.  Selain itu, ketika Anda menerima pengecualian tertentu, di samping nama jenisnya, Anda akan melihat namespace-nya, yang dengan jelas akan menentukan afiliasinya.  Ingat contoh penggunaan ulang yang buruk dari tipe <code>InvalidDataException</code> yang sebenarnya didefinisikan dalam namespace <code>System.IO</code> ?  Yang termasuk dalam namespace ini berarti bahwa pada dasarnya pengecualian dari tipe ini dapat dibuang dari kelas yang terletak di <code>System.IO</code> namespace atau yang lebih bersarang.  Tetapi pengecualian itu sendiri dikeluarkan dari tempat yang sama sekali berbeda, membingungkan peneliti tentang masalah yang muncul.  Dengan memfokuskan tipe pengecualian pada ruang nama yang sama dengan tipe yang melempar pengecualian ini, Anda menjaga arsitektur tipe konsisten di satu sisi dan, di sisi lain, membuatnya lebih mudah bagi pengembang akhir untuk memahami alasan apa yang terjadi. </p><br><p>  Apa cara pengelompokan kedua pada level kode?  Warisan: </p><br><pre> <code class="plaintext hljs">public abstract class LoggerExceptionBase : Exception { protected LoggerExceptionBase(..); } public class IOLoggerException : LoggerExceptionBase { internal IOLoggerException(..); } public class ConfigLoggerException : LoggerExceptionBase { internal ConfigLoggerException(..); }</code> </pre><br><p>  Selain itu, jika dalam kasus entitas aplikasi biasa, pewarisan berarti pewarisan perilaku dan data, yang menggabungkan jenis dengan menjadi bagian dari <em>satu kelompok entitas</em> , maka dalam kasus pengecualian, warisan berarti milik <em>satu kelompok situasi</em> , karena esensi pengecualian bukanlah esensi, tetapi problematis. </p><br><p>  Menggabungkan kedua metode pengelompokan ini, kita dapat menarik beberapa kesimpulan: </p><br><ul><li>  di dalam majelis ( <code>Assembly</code> ) harus menyajikan jenis pengecualian dasar yang dilemparkan majelis ini.  Jenis pengecualian ini harus berada di ruang nama root untuk perakitan.  Ini akan menjadi lapisan pertama pengelompokan; </li><li>  Selanjutnya, di dalam perakitan itu sendiri, mungkin ada satu atau lebih ruang nama yang berbeda.  Masing-masing membagi majelis menjadi beberapa zona fungsional, sehingga mendefinisikan kelompok-kelompok situasi yang muncul dalam majelis ini.  Ini bisa menjadi zona pengendali, entitas basis data, algoritma pemrosesan data, dan lainnya.  Bagi kami, ruang nama ini adalah pengelompokan jenis berdasarkan afiliasi fungsional, dan dari sudut pandang pengecualian, pengelompokan berdasarkan zona masalah dari majelis yang sama; </li><li>  pewarisan pengecualian hanya bisa berasal dari tipe di namespace yang sama atau di root lebih.  Ini menjamin pemahaman yang jelas tentang situasi oleh pengguna akhir dan tidak adanya intersepsi pengecualian <em>kiri</em> saat disadap oleh tipe dasar. :     <code>global::Finiki.Logistics.OhMyException</code> ,  <code>catch(global::Legacy.LoggerExeption exception)</code> ,      : </li></ul><br><pre> <code class="plaintext hljs">namespace JetFinance.FinancialPipe { namespace Services.XmlParserService { public class XmlParserServiceException : FinancialPipeExceptionBase { // .. } public class Parser { public void Parse(string input) { // .. } } } public abstract class FinancialPipeExceptionBase : Exception { } } using JetFinance.FinancialPipe; using JetFinance.FinancialPipe.Services.XmlParserService; var parser = new Parser(); try { parser.Parse(); } catch (XmlParserServiceException exception) { // Something wrong in parser } catch (FinancialPipeExceptionBase exception) { // Something else wrong. Looks critical because we don't know real reason }</code> </pre><br><p> ,   :        , ,   ,       <code>XmlParserServiceException</code> . ,   ,      ,  <code>JetFinance.FinancialPipe.FinancialPipeExceptionBase</code> ,       :    <code>XmlParserService</code>    ,       .          ,               <code>catch</code>      :          . </p><br><p>     ? </p><br><ul><li>        .     .     ‚Äî      ,       : , -, UI.  Yaitu     ; </li><li>        ,   :      ,      <code>catch</code> ; </li><li>       ‚Äì      .        ; </li><li>             ,       .      :       ,         , ,  . ,   -    :        ,   ‚Äî  ,  , ,        ; </li><li>         </li><li>       ,      :     ; </li><li>           ,  Mixed Mode c ErrorCode. </li></ul><br><h3 id="po-istochniku-oshibki">    </h3><br><p>             . ,     ,     : </p><br><ul><li>  unsafe ,    .      :         ,      (,   )     ; </li><li>     ,   ,      , ..       .        ,             ,     .  ,       ,       .            ‚Äî        ‚Äî  <code>InnerExcepton</code> .            ‚Äî          ; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode kami sendiri yang dimasukkan secara acak ke kondisi tidak konsisten. </font><font style="vertical-align: inherit;">Parsing teks adalah contoh yang bagus. </font><font style="vertical-align: inherit;">Tidak ada dependensi eksternal, tidak ada penarikan </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi ada kesalahan parsing.</font></font></li></ul><br><blockquote><h3>  Tautan ke seluruh buku </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  Buku CLR: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Rilis 0,5.0 buku, PDF: <a href="">Rilis GitHub</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419927/">https://habr.com/ru/post/id419927/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419917/index.html">Neural networks: implementasi tugas tentang jamur pada Tensor Flow dan Python</a></li>
<li><a href="../id419919/index.html">Kontrol versi di dalam SQL Server</a></li>
<li><a href="../id419921/index.html">Cara menjatuhkan 10 juta paket per detik</a></li>
<li><a href="../id419923/index.html">Pekerjaan sementara saya, jam tangan motherboard</a></li>
<li><a href="../id419925/index.html">Kontrol versi file individual menggunakan GitHub Gist</a></li>
<li><a href="../id419929/index.html">[DotNetBook] Acara pengecualian dan cara mendapatkan StackOverflow dan ExecutionEngineException dari awal</a></li>
<li><a href="../id419931/index.html">[DotNetBook] Saatnya menghibur cerita: situasi yang sangat luar biasa</a></li>
<li><a href="../id419933/index.html">Cara melakukan pencarian pengguna di Github menggunakan Angular</a></li>
<li><a href="../id419935/index.html">Tepat sekali TIDAK persis sama: analisis artikel</a></li>
<li><a href="../id419939/index.html">Bagaimana saya membuat navigasi di Bereaksi Asli tidak begitu mengerikan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>