<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤§ ğŸ‘´ğŸ¼ ğŸ¥ CQRS: prinsip "divide and conquer" dalam pelayanan seorang programmer ğŸ‘†ğŸ½ â­ï¸ ğŸ˜º</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Arsitektur Puff adalah keselamatan di dunia pengembangan perusahaan. Dengan bantuannya, Anda dapat membongkar besi, memparalelkan proses, dan memulihk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CQRS: prinsip "divide and conquer" dalam pelayanan seorang programmer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/psb/blog/440172/"> Arsitektur Puff adalah keselamatan di dunia pengembangan perusahaan.  Dengan bantuannya, Anda dapat membongkar besi, memparalelkan proses, dan memulihkan ketertiban dalam kode.  Kami mencoba menggunakan pola CQRS ketika mengembangkan proyek perusahaan.  Semuanya menjadi lebih logis dan ... lebih rumit.  Baru-baru ini, saya berbicara tentang apa yang harus saya hadapi di pertemuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panda-Meetup C # .Net</a> , dan sekarang saya berbagi dengan Anda. <br><br><img src="https://habrastorage.org/webt/dx/rt/hg/dxrthgzb-ad0b1hfie06jz_3x-m.jpeg"><br><a name="habracut"></a><br>  Pernahkah Anda memperhatikan seperti apa aplikasi perusahaan Anda?  Mengapa tidak seperti Apple dan Google?  Ya, karena kami kekurangan waktu.  Persyaratan sering berubah, istilah untuk perubahan mereka biasanya "kemarin".  Dan apa yang paling tidak menyenangkan, bisnis tidak suka kesalahan. <br><br><img src="https://habrastorage.org/webt/nw/cm/6a/nwcm6aby-nd9z5rchxienijheqk.png"><br><br>  Agar bisa hidup dengan ini, para pengembang mulai membagi aplikasi mereka menjadi beberapa bagian.  Semuanya dimulai sederhana - dengan data.  Banyak yang akrab dengan skema ketika data terpisah, klien terpisah, sementara logika disimpan di tempat yang sama dengan data. <br><br><img src="https://habrastorage.org/webt/5d/yg/xa/5dygxacluuk_6axv8ttxi0moahi.png"><br><br>  Garis besar yang bagus.  DBMS terbesar memiliki ekstensi prosedural yang berfungsi penuh untuk SQL.  Ada pepatah tentang Oracle: "Di mana ada Oracle, ada logika."  Sulit untuk berdebat tentang kenyamanan dan kecepatan konfigurasi seperti itu. <br><br>  Tetapi kami memiliki aplikasi perusahaan, dan ada masalah: logikanya sulit untuk diukur.  Dan tidak masuk akal untuk memuat kapasitas DBMS, yang sudah menderita masalah dengan penggalian dan pembaruan data, dan juga tugas-tugas bisnis yang sepele. <br><br>  Yah, alat pemrograman logika bisnis yang dibangun ke dalam DBMS, jujur, lemah untuk membuat aplikasi normal perusahaan.  Mempertahankan logika bisnis dalam T-SQL / PL-SQL adalah hal yang menyakitkan.  Bukan tanpa alasan bahwa bahasa OOP tersebar luas di antara aplikasi perusahaan: C #, Java, Anda tidak perlu melangkah jauh untuk contoh. <br><br><img src="https://habrastorage.org/webt/0l/bf/7o/0lbf7oxhdqiob8np3x2oagupxv4.png"><br><br>  Tampaknya solusi logis: kami menyoroti logika bisnis.  Dia akan hidup di servernya, basisnya sendiri, klien sendiri. <br><br>  Apa yang bisa diperbaiki dalam arsitektur tiga tingkat ini?  Arsitektur terlibat dalam lapisan logika bisnis, saya ingin menghindari ini.  Logika bisnis tidak ingin tahu apa pun tentang penyimpanan data.  UI juga merupakan dunia terpisah di mana ada entitas yang tidak spesifik untuk logika bisnis. <br><br>  Meningkatkan layer akan membantu.  Solusi ini terlihat hampir sempurna, ia memiliki semacam keindahan batin. <br><br><img src="https://habrastorage.org/webt/zw/lv/he/zwlvhelbpekiq63iyifzvuldvna.png"><br><br>  Kami memiliki DAL (Lapisan Akses Data) - data dipisahkan dari logika, biasanya repositori CRUD menggunakan ORM, ditambah prosedur tersimpan untuk kueri kompleks.  Opsi ini memungkinkan Anda untuk berkembang cukup cepat, dan memiliki kinerja yang dapat diterima. <br><br>  Logika bisnis dapat menjadi bagian dari layanan atau menjadi lapisan terpisah.  Interaksi antar lapisan dapat dilakukan melalui objek transportasi (DTO). <br><br>  Permintaan dari UI masuk ke layanan, ia berkomunikasi dengan logika bisnis, naik ke DAL untuk mengakses data.  Pendekatan ini disebut N-tier, dan memiliki keunggulan yang jelas. <br><br>  Setiap lapisan memiliki tujuan dan sasaran yang jelas, yang kita, sebagai programmer, sangat sukai.  Setiap lapisan beton hanya terlibat dalam bisnisnya sendiri.  Layanan dapat ditingkatkan secara horizontal.  Pendekatannya jelas bahkan untuk pengembang pemula, seseorang dengan cepat memahami cara kerja sistem.  Sangat mudah untuk melacak semua interaksi saat permintaan berubah dari awal hingga selesai. <br><br>  Konsistensi lain: semua subsistem proyek bekerja dengan data yang sama, Anda tidak perlu khawatir bahwa kami mencatat data di satu tempat dan pengguna tidak melihatnya di bagian lain. <br><br><h3>  Kue Lapis 1. N-Tier </h3><br>  Di bawah ini adalah contoh fragmen khas dari aplikasi yang dibangun berdasarkan prinsip-prinsip ini.  Kami memiliki persyaratan moneter, di sini saya memeriksa model Anemik.  Dan ada repositori klasik, bekerja dengan yang melewati ORM. <br><br><img src="https://habrastorage.org/webt/uj/bw/wa/ujbwwazglo6mvhy9x5dzt0qei4g.png"><br><br>  Ini adalah layanan khas, mereka juga disebut manajer.  Ia bekerja dengan repositori, menerima permintaan, dan memberikan jawaban kepada klien.  Dalam layanan ini kami melihat beberapa kebingungan: kami memiliki proses pemrosesan, proses untuk bekerja dengan UI dan proses untuk beberapa unit pengendalian internal, mereka saling berhubungan lemah. <br><br>  Beginilah bentuk khas dari layanan ini.  Misalnya, pendaftaran klaim moneter. <br><br><img src="https://habrastorage.org/webt/g5/ux/lv/g5uxlv_eu-2xmky8lwlyk4-agvc.png"><br><br>  Kami menerima data, melakukan beberapa pemeriksaan bisnis.  Kemudian ada pembaruan, dan setelahnya beberapa tindakan pasca, misalnya, mengirim pemberitahuan atau menulis ke log pengguna. <br><br>  Dalam pendekatan ini, terlepas dari segala keindahannya, ada masalah.  Sangat sering dalam aplikasi perusahaan, bebannya asimetris: operasi baca adalah satu atau dua perintah daripada menulis.  Sudah ada masalah dengan penskalaan basis data itu sendiri.  Tentu saja, ini dilakukan, dan bahkan melalui DBMS pada skala basis data, partisi disebut.  Tetapi itu sulit.  Jika ini dilakukan dengan kualifikasi yang salah atau dilakukan lebih awal dari yang diperlukan, partisi akan gagal. <br><br>  Misalnya, di salah satu sistem kami volume data mencapai 25 TB, masalah muncul.  Kami sendiri mencoba meningkatkan skala, mengundang orang-orang tangguh dari perusahaan terkenal.  Mereka melihat dan berkata: kita perlu 14 jam downtime lengkap dari pangkalan.  Kami berpikir dan berkata: kawan, itu tidak akan berhasil, bisnis tidak akan menerimanya. <br><br>  Selain volume basis data, jumlah metode dalam layanan dan repositori bertambah.  Misalnya, dalam layanan untuk klaim moneter ada lebih dari seratus metode.  Sulit untuk mempertahankan, ada konflik konstan ketika menggabungkan permintaan, review kode lebih sulit untuk dilakukan.  Dan jika kita mempertimbangkan bahwa prosesnya berbeda, kelompok pengembang yang berbeda mengerjakannya, maka tugas melacak semua perubahan yang terkait dengan masalah menjadi sakit kepala nyata. <br><br><h3>  Puff pastry 2. CQRS </h3><br>  Jadi apa yang harus dilakukan?  Ada solusi yang ditemukan di Roma kuno: memecah belah dan memerintah. <br><br><img src="https://habrastorage.org/webt/1s/wf/un/1swfunmbkv6_g1gevmg-be1qsoo.png"><br><br>  Seperti yang mereka katakan, semua yang baru sudah lama terlupakan.  Kembali pada tahun 1988, Bertrand Meyer merumuskan prinsip pemrograman CQS imperatif - pemisahan command-query - untuk bekerja dengan objek.  Semua metode jelas dibagi menjadi dua jenis.  Yang pertama - Permintaan - permintaan yang mengembalikan hasil tanpa mengubah status objek.  Artinya, ketika Anda melihat persyaratan moneter klien, tidak ada yang harus menulis ke database bahwa klien telah melihat ini dan itu, seharusnya tidak ada efek samping dalam permintaan. <br><br>  Yang kedua - Perintah - perintah yang mengubah keadaan suatu objek tanpa mengembalikan data.  Artinya, Anda memesan sesuatu untuk diubah, dan sebagai imbalannya jangan menunggu laporan 10 ribu baris. <br><br><img src="https://habrastorage.org/webt/sz/tj/cn/sztjcny-m7hn7pnx4zn-37_dkly.png"><br><br>  Di sini, model data baca jelas dipisahkan dari model tulis.  Sebagian besar logika bisnis berfungsi pada operasi tulis.  Membaca dapat bekerja pada representasi terwujud atau secara umum atas dasar yang berbeda.  Mereka dapat dibagi dan disinkronkan melalui acara atau layanan internal.  Ada banyak pilihan. <br><br>  CQRS tidak rumit.  Kita harus dengan jelas membedakan tim yang mengubah keadaan sistem, tetapi tidak mengembalikan apa pun.  Di sini pendekatannya mungkin lebih seimbang.  Tidak terlalu menakutkan jika perintah mengembalikan hasil eksekusi: kesalahan atau, misalnya, pengidentifikasi entitas yang dibuat, maka tidak ada kejahatan dalam hal ini.  Penting bahwa tim tidak bekerja dengan permintaan, tidak boleh mencari data dan mengembalikan entitas bisnis. <br><br>  Permintaan - semuanya sederhana di sana.  Itu tidak mengubah kondisi sehingga tidak ada efek samping.  Ini berarti bahwa jika kita memanggil permintaan dua kali berturut-turut, dan tidak ada perintah lain, keadaan objek dalam kedua kasus harus tetap identik.  Ini memungkinkan Anda untuk memparalelkan kueri.  Menariknya, model terpisah untuk kueri tidak diperlukan untuk pekerjaan, karena  tidak ada gunanya menggambar logika bisnis dari model domain untuk ini. <br><br><h3>  Proyek CQRS kami </h3><br>  Inilah yang ingin kami lakukan dalam proyek kami: <br><br><img src="https://habrastorage.org/webt/rc/jt/d_/rcjtd_xtvea4sppjzzpi1jumbzy.png"><br><br>  Aplikasi kami yang ada telah beroperasi sejak 2006, ia memiliki arsitektur berlapis klasik.  Kuno tapi masih berfungsi.  Tidak ada yang ingin mengubahnya dan bahkan tidak tahu harus menggantikannya dengan apa.  Momen datang ketika perlu untuk mengembangkan sesuatu yang baru, dari awal secara praktis.  Pada 2011-2012, Event Sourcing dan CQRS adalah topik yang sangat modis.  Kami pikir itu keren, sehingga kami bisa menyimpan keadaan asli objek dan kejadian yang mengarah padanya. <br><br>  Artinya, kita tidak memperbarui objek.  Ada kondisi asli dan di sebelahnya adalah apa yang diterapkan padanya.  Dalam hal ini, ada nilai tambah yang besar - kita dapat memulihkan keadaan suatu objek kapan saja dalam sejarah.  Padahal, majalah itu tidak lagi dibutuhkan.  Saat kami menyimpan acara, kami memahami apa yang sebenarnya terjadi.  Artinya, bukan hanya nilai klien di sel "alamat" telah diperbarui, kami akan mencatat peristiwa yang tepat, misalnya, perpindahan klien. <br><br>  Jelas bahwa skema semacam itu bekerja lambat ketika menerima data, jadi kami memiliki basis data terpisah dengan representasi materi untuk seleksi.  Yah, dan sinkronisasi acara: dengan setiap kedatangan acara dengan perubahan status, publikasi terjadi.  Secara teori, semuanya tampak baik-baik saja, tapi ... Saya belum pernah bertemu orang yang sepenuhnya menyadari ini pada produksi, pada beban tinggi dengan konsistensi bisnis yang dapat diterima. <br><br><img src="https://habrastorage.org/webt/a_/gb/l4/a_gbl4c68c45lor9e9it0tptgsw.png"><br><br>  Skema dapat dikembangkan lebih lanjut jika penangan dan perintah / permintaan dipisahkan.  Di sini, sebagai contoh, kami memiliki tim - klaim moneter terdaftar: ada tanggal, jumlah, pelanggan, dan bidang lainnya. <br><br>  Kami membatasi prosesor registrasi klaim moneter yang hanya dapat menerima tim kami (di mana TCommand: ICommand).  Kami dapat menulis penangan tanpa mengubah yang lama, hanya dengan menambahkan persyaratan yang kompleks.  Misalnya, perbarui tanggal terlebih dahulu, kemudian tulis nilainya, dan di sini Anda mengirim pemberitahuan kepada klien - semua ini ditulis dalam penangan yang berbeda per perintah. <br><br>  Bagaimana kita menyebabkan semua ini?  Ada operator yang tahu di mana ia menyimpan semua penangan ini. <br><br><img src="https://habrastorage.org/webt/x5/ru/oy/x5ruoyjo7opvudu_ee7o72oa1dy.png"><br><br>  Dispatcher diteruskan (misalnya, melalui wadah DI) ke API.  Dan ketika perintah itu tiba, itu hanya mengeksekusi.  Dia tahu di mana wadah itu, di mana tim berada, dan mengeksekusi mereka.  Dengan permintaan - sama. <br><br>  Apa masalah dengan skema seperti itu: semua interaksi menjadi kurang jelas.  Kami membangun hierarki pada jenis yang terdaftar dalam wadah, dan kemudian menanggapi perintah / permintaan kami.  Ini membutuhkan desain arsitektur yang sangat jelas.  Tindakan apa pun dengan satu metode dengan satu parameter tidak lagi terbatas.  Anda menulis perintah, menulis pawang, mendaftar dalam wadah.  Jumlah overhead meningkat.  Dalam proyek besar, masalah muncul dengan navigasi dasar.  Kami memutuskan untuk pergi dengan cara yang lebih klasik. <br><br>  Untuk komunikasi asinkron, bus layanan Rebus digunakan. <br><br><img src="https://habrastorage.org/webt/yw/nj/qw/ywnjqwtw7grnr-vh790ed2vthqs.png"><br><br>  Untuk tugas-tugas sederhana, itu sudah lebih dari cukup. <br><br>  CQRS membuat Anda mendekati kode sedikit berbeda, berkonsentrasi pada proses, karena semua tindakan dilahirkan sebagai bagian dari proses.  Kami mengalokasikan repositori untuk permintaan, secara terpisah membuat pemrosesan perintah terkait, dan secara terpisah memproses permintaan terkait.  Untuk membaca, kami tidak menggunakan repositori terpisah, kami hanya bekerja dengan ORM dalam tim. <br><br><img src="https://habrastorage.org/webt/wh/6n/yt/wh6nytrv98oixsxcnwxxrtculis.png"><br><br>  Di sini, misalnya, adalah metode dari mana segala sesuatu yang berlebihan dibuang.  Dalam tim registrasi klaim uang, kami mendaftarkan permintaan dan mempublikasikan acara di bus bahwa klaim uang terdaftar. <br><br><img src="https://habrastorage.org/webt/wh/6n/yt/wh6nytrv98oixsxcnwxxrtculis.png"><br><br>  Siapa pun yang tertarik dengan ini akan bereaksi padanya.  Misalnya, otentikasi dan pencatatan pengguna akan berfungsi di sana. <br><br>  Berikut ini contoh permintaan.  Semuanya menjadi sederhana juga: kita membaca dan memberikan ke repositori. <br><br><img src="https://habrastorage.org/webt/od/2g/wj/od2gwj9ud2gzo_61i9tcw6d0keu.png"><br><br>  Saya ingin tinggal secara terpisah di Rebus.Saga.  Ini adalah pola yang memungkinkan Anda untuk memecah transaksi bisnis menjadi aksi atom.  Ini memungkinkan Anda untuk memblokir tidak sekaligus, tetapi secara bertahap dan pada gilirannya. <br><br><img src="https://habrastorage.org/webt/d_/t9/t5/d_t9t5foqvuzu3gkpp8nmvqhmfa.jpeg"><br><br>  Elemen pertama mengambil tindakan dan mengirim pesan, pelanggan kedua meresponsnya, memenuhinya, mengirimkan pesannya, yang sudah ditanggapi oleh bagian ketiga sistem.  Jika semuanya berakhir dengan baik, Saga membuat pesannya sendiri dari tipe yang ditentukan, yang akan ditanggapi oleh pelanggan lain. <br><br>  Mari kita lihat seperti apa kelas untuk memproses klaim uang dalam kasus ini.  Semuanya jelas: ada perintah, ada permintaan yang berhubungan dengan proses registrasi, yah, bus dengan log. <br><br><img src="https://habrastorage.org/webt/bl/nm/7m/blnm7mchtolurp463y6_m_o6biq.png"><br><br>  Dalam hal ini, ada satu penangan.  Ketika suatu peristiwa terjadi dan sebuah tim datang untuk mendaftarkan klaim moneter, ia menanggapinya.  Di dalam, semuanya sama seperti sebelumnya, tetapi kekhasannya adalah ada proses pengelompokan. <br><br><img src="https://habrastorage.org/webt/ns/wi/iz/nswiizzxxzxajbkardg73qvtmq0.png"><br><br>  Karena itu, ini menjadi sedikit lebih mudah, lebih sedikit perubahan pada setiap file. <br><br><h3>  Kesimpulan </h3><br>  Apa yang perlu Anda ingat ketika bekerja dengan CQRS?  Anda memerlukan pendekatan yang lebih baik untuk mendesain, karena menulis ulang prosesnya sedikit lebih rumit.  Ada overhead kecil, lebih banyak kelas telah menjadi, tetapi ini tidak kritis.  Kode menjadi kurang terhubung, namun, itu bukan karena CQRS, tetapi karena transisi ke bus.  Tapi CQRS yang mendorong kami untuk menggunakan interaksi acara ini.  Kode menjadi lebih sering ditambahkan daripada diubah.  Ada lebih banyak kelas, tetapi mereka sekarang lebih terspesialisasi. <br><br>  Apakah semua orang perlu meninggalkan semuanya dan secara besar-besaran beralih ke CQRS?  Tidak, Anda perlu melihat skenario mana yang paling cocok untuk proyek tertentu.  Misalnya, jika subsistem Anda berfungsi dengan direktori, CQRS tidak diperlukan, pendekatan layered klasik memberikan hasil yang lebih sederhana dan nyaman. <br><br>  Versi lengkap kinerja di Panda Meetup tersedia di bawah ini. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/J9U0svFKX9A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Jika Anda ingin mempelajari lebih dalam topik ini, masuk akal untuk mempelajari sumber daya ini: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gaya arsitektur CQRS - dari Microsoft</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blog Alexander Bendyu</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh Universitas Contoso dengan CQRS, MediatR, AutoMapper, dan lainnya - oleh Jimmy Bogard</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CQRS - oleh Martin Fowler</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rebus</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440172/">https://habr.com/ru/post/id440172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440162/index.html">Contoh jaringan saraf sederhana di C / C ++</a></li>
<li><a href="../id440164/index.html">Akankah monetisasi data pengguna menjadi tren di tahun 2019?</a></li>
<li><a href="../id440166/index.html">Kompresi penunjuk Java</a></li>
<li><a href="../id440168/index.html">Laporan video dari FunTech ML-meetup</a></li>
<li><a href="../id440170/index.html">Analisis insiden yang terkait dengan serangan dunia maya pada proyek-proyek blockchain</a></li>
<li><a href="../id440174/index.html">Microsoft Q # Coding Contest - Winter 2019</a></li>
<li><a href="../id440176/index.html">Tujuh tren keamanan dunia maya untuk 2019</a></li>
<li><a href="../id440178/index.html">Menghapus rekursi dengan Python</a></li>
<li><a href="../id440180/index.html">Q # Kontes Pemrograman: Microsoft Q # Kontes Pengkodean</a></li>
<li><a href="../id440182/index.html">IBM Watson Studio - Platform Pengembangan Aplikasi AI Berbasis Cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>