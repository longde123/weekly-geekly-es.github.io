<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö™Ô∏è üç¢ üö£üèº Durch die Portierung eines Spiels auf PSVita wurde die Gesamtleistung verbessert üëêüèª üë©üèΩ‚Äç‚öñÔ∏è üéí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auf dem Level k√∂nnen Tausende von Feinden sein. 

 Defender's Quest: Das Tal des vergessenen DX hatte schon immer langj√§hrige Probleme mit der Geschwi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Durch die Portierung eines Spiels auf PSVita wurde die Gesamtleistung verbessert</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414135/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/937/148/2a1/9371482a13b17c628afe9e994e6df76f.jpg" alt="Bild"></div><br>  <i>Auf dem Level k√∂nnen Tausende von Feinden sein.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Defender's Quest: Das Tal des vergessenen DX hatte</a> schon immer langj√§hrige Probleme mit der Geschwindigkeit, und ich habe es endlich geschafft, sie zu l√∂sen.  Der Hauptanreiz f√ºr eine massive Geschwindigkeitssteigerung war unser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Port auf der PlayStation Vita</a> .  Das Spiel wurde bereits auf dem PC ver√∂ffentlicht und funktionierte auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Xbox One</a> mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PS4</a> gut, wenn nicht sogar perfekt.  Aber ohne eine wesentliche Verbesserung des Spiels k√∂nnten wir es niemals auf Vita starten. <br><br>  Wenn ein Spiel langsamer wird, geben Kommentatoren im Internet normalerweise einer Programmiersprache oder einer Engine die Schuld.  Es ist wahr, dass Sprachen wie C # und Java teurer sind als C und C ++, und Tools wie Unity haben unl√∂sbare Probleme, wie z. B. die Speicherbereinigung.  Tats√§chlich kommen die Leute auf solche Erkl√§rungen, weil Sprache und Engine die offensichtlichsten Eigenschaften von Software sind.  Aber die wahren M√∂rder der Leistung k√∂nnen dumme winzige Details sein, die nichts mit Architektur zu tun haben. <br><a name="habracut"></a><br><h1>  0. Profiling Tools </h1><br>  Es gibt nur einen wirklichen Weg, um das Spiel schneller zu machen - das Erstellen von Profilen.  Finden Sie heraus, wof√ºr der Computer zu viel Zeit verbringt, und verbringen Sie weniger Zeit damit, oder, noch besser, verschwenden Sie √ºberhaupt keine Zeit. <br><br>  Das einfachste Profiling-Tool ist der Standard-Windows-Systemmonitor (Leistungsmonitor): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/b29/a69/ea3b29a690d6fe0ce9c6014abb6a9a62.png"></div><br>  Tats√§chlich ist dies ein ziemlich flexibles Werkzeug und es ist sehr einfach, damit zu arbeiten.  Dr√ºcken Sie einfach Strg + Alt + Entf, √∂ffnen Sie den "Task-Manager" und klicken Sie auf die Registerkarte "Leistung".  F√ºhren Sie jedoch nicht zu viele andere Programme aus.  Wenn Sie genau hinschauen, k√∂nnen Sie leicht Spitzen in der CPU-Auslastung und sogar Speicherlecks erkennen.  Dies ist ein nicht informativer Weg, aber es kann der erste Schritt sein, langsame Orte zu finden. <br><br>  Defender's Quest ist in der Hochsprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haxe</a> geschrieben, die in andere Sprachen kompiliert wurde (mein Hauptziel war C ++).  Dies bedeutet, dass jedes Tool, das C ++ - Profile erstellen kann, auch meinen von Haxe generierten C ++ - Code profilieren kann.  Als ich die Ursachen der Probleme verstehen wollte, startete ich den Performance Explorer von Visual Studio aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/999/a24/932/999a24932b41cd329e28bcb6c5076725.png"></div><br>  Dar√ºber hinaus haben verschiedene Konsolen ihre eigenen Profiling-Tools, was sehr praktisch ist, aber aufgrund der NDA kann ich Ihnen nichts dar√ºber erz√§hlen.  Aber wenn Sie Zugriff auf sie haben, aber stellen Sie sicher, dass Sie sie verwenden! <br><br>  Anstatt ein schreckliches Tutorial √ºber die Verwendung von Profiling-Tools wie Performance Explorer zu schreiben, lasse ich einfach einen Link zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> und gehe zum Hauptthema √ºber - erstaunliche Dinge, die zu einer enormen Steigerung der Produktivit√§t gef√ºhrt haben, und wie ich sie gefunden habe ! <br><br><h1>  1. Problemerkennung </h1><br>  Die Spieleleistung ist nicht nur die Geschwindigkeit selbst, sondern auch die Wahrnehmung.  Defender's Quest ist ein Tower Defense-Genre-Spiel, das mit 60 FPS gerendert wird, jedoch eine variable Spielgeschwindigkeit im Bereich von 1 / 4x bis 16x aufweist.  Unabh√§ngig von der Spielgeschwindigkeit verwendet die Simulation einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">festen Zeitstempel</a> mit 60 Aktualisierungen pro Sekunde und 1x Simulationszeit.  Das hei√üt, wenn Sie das Spiel mit einer Geschwindigkeit von 16x ausf√ºhren, funktioniert die Aktualisierungslogik tats√§chlich mit einer Frequenz von <em>960 FPS</em> .  Ehrlich gesagt, das sind zu hohe Anfragen f√ºr das Spiel!  Aber ich habe diesen Modus erstellt, und wenn sich herausstellt, dass er langsam ist, werden die Spieler ihn definitiv bemerken. <br><br>  Und im Spiel gibt es <em>so ein</em> Level: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/5e1/694/ed95e16941a18fe9a71b7333d537f1d9.png"></div><br>  Dies ist die letzte Bonusschlacht "Endless 2", es ist auch "mein pers√∂nlicher Albtraum".  Der Screenshot wurde im New Game + -Modus aufgenommen, in dem die Feinde nicht nur viel st√§rker sind, sondern auch Funktionen wie die Wiederherstellung der Gesundheit haben.  Die Lieblingsstrategie des Spielers besteht darin, Drachen auf das maximale Roar-Level zu pumpen (AOE-Angriff, der Feinde bet√§ubt) und eine Reihe von Rittern hinter sich zu lassen, deren R√ºcksto√ü maximal gepumpt ist, um alle, die an den Drachen vorbeikommen, in ihren Aktionsbereich zur√ºckzuschieben.  Der kumulative Effekt ist, dass eine riesige Gruppe von Monstern endlos an einem Ort bleibt, viel l√§nger als die Spieler √ºberleben m√ºssten, wenn sie sie tats√§chlich t√∂ten w√ºrden.  Da die Spieler <em>auf</em> Wellen <em>warten m√ºssen</em> und sie nicht <em>t√∂ten</em> m√ºssen, um Belohnungen und Erfolge zu erhalten, ist eine solche Strategie absolut effektiv und brillant - genau das ist das Verhalten der Spieler, die ich stimuliert habe. <br><br>  Leider stellt sich heraus, dass dies auch ein <em>pathologischer</em> Fall f√ºr die Leistung ist, <em>insbesondere</em> wenn Spieler mit 16- oder 8-facher Geschwindigkeit spielen m√∂chten.  Nat√ºrlich werden nur die Hardcore-Spieler versuchen, die Errungenschaft ‚ÄûHundertste Welle‚Äú in New Game + auf der Stufe Endless 2 zu erreichen, aber sie sind nur diejenigen, die das Spiel am lautesten sprechen, deshalb wollte ich, dass sie gl√ºcklich sind. <br><br>  Es ist nur ein 2D-Spiel mit einer Reihe von Sprites. Was k√∂nnte daran falsch sein? <br><br>  Und in der Tat.  Lass es uns richtig machen. <br><br><h1>  2. Kollisionsaufl√∂sung </h1><br>  Schauen Sie sich diesen Screenshot an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/bd2/116/098bd2116180a0b3ea3c9a66339b7fa3.png"></div><br>  Sehen Sie diesen Bagel um den Waldl√§ufer?  Dies ist ihr Aufprallbereich - beachten Sie, dass es auch eine tote Zone gibt, in der es <em>keine</em> Ziele treffen kann.  Jede Klasse hat ihren eigenen Angriffsbereich und jeder Verteidiger hat einen anderen Gr√∂√üenbereich, abh√§ngig von der Stufe des Boosts und den pers√∂nlichen Parametern.  Und theoretisch kann jeder Verteidiger auf jeden Feind in seiner Reichweite zielen.  Gleiches gilt f√ºr bestimmte Arten von Feinden.  Es k√∂nnen bis zu 36 Verteidiger auf der Karte sein (ohne die Hauptfigur Azru), aber es gibt keine Obergrenze f√ºr die Anzahl der Feinde.  Jeder Verteidiger und Feind verf√ºgt √ºber eine Liste m√∂glicher Ziele, die auf der Grundlage von Aufrufen erstellt wurde, um den Bereich bei jedem Aktualisierungsschritt zu √ºberpr√ºfen (abz√ºglich der logischen Abschaltung derjenigen, die im Moment nicht angreifen k√∂nnen, usw.). <br><br>  Videoprozessoren sind heute sehr schnell - wenn Sie sie nicht zu stark belasten, k√∂nnen sie fast eine beliebige Anzahl von Polygonen verarbeiten.  Aber selbst die schnellsten CPUs haben sehr leicht ‚ÄûEngp√§sse‚Äú bei einfachen Verfahren, insbesondere bei solchen, die exponentiell wachsen.  Das ist der Grund, warum sich ein 2D-Spiel als langsamer herausstellen kann als ein viel sch√∂neres 3D-Spiel - nicht weil der Programmierer es nicht bew√§ltigen konnte (vielleicht auch zumindest in meinem Fall), sondern im Prinzip, weil die Logik manchmal teurer sein kann. als zeichnen!  Die Frage ist nicht, wie viele Objekte sich auf dem Bildschirm befinden, sondern was sie <em>tun</em> . <br><br>  Lassen Sie uns die Kollisionserkennung untersuchen und beschleunigen.  Zum Vergleich m√∂chte ich sagen, dass die Kollisionserkennung vor der Optimierung bis zu ~ 50% der CPU-Zeit im Hauptkampfzyklus in Anspruch nahm.  Nach der Optimierung weniger als 5%. <br><br><h2>  Es dreht sich alles um Quadrantenb√§ume </h2><br>  Die Hauptl√∂sung f√ºr das Problem der langsamen Kollisionserkennung besteht darin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, den Raum aufzuteilen</a> - und von Anfang an haben wir eine qualitativ hochwertige Implementierung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des Quadrantenbaums verwendet</a> .  Im Wesentlichen wird der Raum effektiv getrennt, sodass viele optionale Kollisionspr√ºfungen √ºbersprungen werden k√∂nnen. <br><br>  In jedem Frame aktualisieren wir den gesamten Quadrantenbaum (QuadTree), um die Position jedes Objekts zu verfolgen. Wenn der Feind oder Verteidiger auf jemanden zielen m√∂chte, bittet er QuadTree um eine Liste der Objekte in der N√§he.  Der Profiler sagte uns jedoch, dass beide Operationen viel langsamer sind, als sie sein sollten. <br><br>  Was ist hier falsch? <br><br>  Wie sich herausstellte - viel. <br><br><h2>  String-Eingabe </h2><br>  Da ich sowohl Feinde als auch Verteidiger in einem Quadrantenbaum hielt, musste ich angeben, wonach ich suchte, und dies geschah folgenderma√üen: <br><br> <code>var things:Array&lt;XY&gt; = _qtree.queryRange(zone.bounds, "e"); //"e" -   "enemy"</code> <br> <br>  Im Fachjargon der Programmierer wird dies als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeichenfolgentypcode</a> bezeichnet. Dies ist unter anderem deshalb schlecht, weil Zeichenfolgenvergleiche immer langsamer sind als Ganzzahlvergleiche. <br><br>  Ich nahm schnell ganzzahlige Konstanten auf und ersetzte den Code durch diesen: <br><br> <code>var things:Array&lt;XY&gt; = _qtree.queryRange(zone.bounds, QuadTree.ENEMY);</code> <br> <br>  (Ja, es hat sich wahrscheinlich gelohnt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Enum Abstract</a> f√ºr maximale <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typensicherheit</a> zu verwenden, aber ich hatte es eilig und musste zuerst die Arbeit erledigen.) <br><br>  Allein diese √Ñnderung hat einen <em>gro√üen</em> Beitrag geleistet, da diese Funktion jedes Mal, wenn jemand eine neue Liste von Zielen ben√∂tigt, <em>st√§ndig</em> und rekursiv aufgerufen wird. <br><br><h2>  Array gegen Vektor </h2><br>  Schauen Sie sich das an: <br><br> <code>var things:Array&lt;XY&gt;</code> <br> <br>  Haxe-Arrays sind ActionScript- und JS-Arrays insofern sehr √§hnlich, als sie Sammlungen von Objekten mit ver√§nderbarer Gr√∂√üe sind, aber in Haxe sind sie stark typisiert. <br><br>  Es gibt jedoch eine andere Datenstruktur, die mit statischen Zielsprachen wie cpp effizienter ist, n√§mlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haxe.ds.Vector</a> .  Haxe-Vektoren sind im Wesentlichen dieselben wie Arrays, au√üer dass sie beim Erstellen eine feste Gr√∂√üe erhalten. <br><br>  Da meine Quadrantenb√§ume bereits ein festes Volumen hatten, habe ich Arrays durch Vektoren ersetzt, um eine sp√ºrbare Geschwindigkeitssteigerung zu erzielen. <br><br><h2>  Fordern Sie nur das an, was Sie brauchen </h2><br>  Zuvor hat meine <code>queryRange</code> Funktion eine Liste von Objekten und <code>XY</code> Instanzen zur√ºckgegeben.  Sie enthielten die x / y-Koordinaten des referenzierten Spielobjekts und seine eindeutige Ganzzahlkennung (Suchindex im Hauptarray).  Das Spielobjekt, das die Anforderung ausf√ºhrt, hat diese XYs empfangen, eine Ganzzahlkennung extrahiert, um sein Ziel zu erhalten, und dann den Rest vergessen. <br><br>  Warum sollte ich all diese Verweise f√ºr jeden QuadTree-Knoten <em>rekursiv</em> und sogar <em>960 Mal pro Frame</em> an XY-Objekte √ºbergeben <em>?</em>  Es reicht mir, eine Liste von Ganzzahlkennungen zur√ºckzugeben. <br><br>  <strong><em>PROFESSIONELLER HINWEIS: Ganzzahlen lassen sich viel schneller √ºbertragen als fast alle anderen Datentypen!</em></strong> <br><br>  Im Vergleich zu anderen Korrekturen war dies recht einfach, aber das Leistungswachstum war immer noch sp√ºrbar, da diese interne Schleife sehr aktiv genutzt wurde. <br><br><h2>  Optimierung der Schwanzrekursion </h2><br>  Es gibt eine elegante Sache namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tail-Call-Optimierung</a> .  Es ist schwer zu erkl√§ren, deshalb zeige ich Ihnen besser ein Beispiel. <br><br>  Es war: <br><br> <code>nw.queryRange(Range, -1, result); <br> ne.queryRange(Range, -1, result); <br> sw.queryRange(Range, -1, result); <br> se.queryRange(Range, -1, result); <br> return result;</code> <br> <br>  Es wurde: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> se.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, sw.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, ne.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, nw.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, result))));</code> </pre> <br>  Der Code gibt die gleichen logischen Ergebnisse zur√ºck, aber laut Profiler ist die zweite Option schneller, zumindest bei der √úbersetzung in cpp.  Beide Beispiele f√ºhren genau die gleiche Logik aus: Sie nehmen √Ñnderungen an der Ergebnisdatenstruktur vor und √ºbergeben sie an die n√§chste Funktion, bevor sie zur√ºckkehren.  Wenn wir dies rekursiv tun, k√∂nnen wir vermeiden, dass der Compiler tempor√§re Referenzen generiert, da er das Ergebnis der vorherigen Funktion einfach sofort zur√ºckgeben kann, anstatt sich in einem zus√§tzlichen Schritt daran zu halten.  Oder so √§hnlich.  Ich verstehe nicht ganz, wie das funktioniert, also lies den Beitrag unter dem obigen Link. <br><br>  (Nach meinem Wissen verf√ºgt die aktuelle Version des Haxe-Compilers nicht √ºber eine Optimierungsfunktion f√ºr die Schwanzrekursion, das hei√üt, es ist wahrscheinlich die Arbeit des C ++ - Compilers. Seien Sie also nicht √ºberrascht, wenn dieser Trick bei der √úbersetzung von Haxe-Code nicht in cpp funktioniert.) <br><br><h2>  Objekt-Pooling </h2><br>  Wenn ich genaue Ergebnisse ben√∂tige, muss ich QuadTree bei jedem Update-Aufruf zerst√∂ren und neu erstellen.  Das Erstellen neuer QuadTree-Instanzen ist eine recht h√§ufige Aufgabe, aber bei einer gro√üen Anzahl neuer AABB- und XY-Objekte f√ºhrten die von ihnen abh√§ngigen QuadTrees zu einer starken Speicher√ºberlastung.  Da es sich um sehr einfache Objekte handelt, w√§re es logisch, viele solcher Objekte im Voraus zuzuweisen und sie nur st√§ndig wiederzuverwenden.  Dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektpool bezeichnet</a> . <br><br>  Ich habe so etwas gemacht: <br><br> <code>nw = new QuadTree( new AABB( cx - hs2x, cy - hs2y, hs2x, hs2y) ); <br> ne = new QuadTree( new AABB( cx + hs2x, cy - hs2y, hs2x, hs2y) ); <br> sw = new QuadTree( new AABB( cx - hs2x, cy + hs2y, hs2x, hs2y) ); <br> se = new QuadTree( new AABB( cx + hs2x, cy + hs2y, hs2x, hs2y) );</code> <br> <br>  Aber dann habe ich den Code durch folgenden ersetzt: <br><br> <code>nw = new QuadTree( AABB.get( cx - hs2x, cy - hs2y, hs2x, hs2y) ); <br> ne = new QuadTree( AABB.get( cx + hs2x, cy - hs2y, hs2x, hs2y) ); <br> sw = new QuadTree( AABB.get( cx - hs2x, cy + hs2y, hs2x, hs2y) ); <br> se = new QuadTree( AABB.get( cx + hs2x, cy + hs2y, hs2x, hs2y) );</code> <br> <br>  Wir verwenden das Open-Source- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HaxeFlixel-</a> Framework und haben dies mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FlxPool-</a> HaxeFlixel-Klasse implementiert.  Bei solch hochspezialisierten Optimierungen ersetze ich h√§ufig einige der grundlegenden Flixel-Elemente (z. B. Kollisionserkennung) durch meine eigene Implementierung (wie bei QuadTrees), aber FlxPool ist besser als alles, was ich selbst geschrieben habe, und es macht genau das, was es ben√∂tigt. <br><br><h2>  Spezialisierung bei Bedarf </h2><br>  Ein <code>XY</code> Objekt ist eine einfache Klasse mit den Eigenschaften <code>x</code> , <code>y</code> und <code>int_id</code> .  Da es in einer besonders aktiv verwendeten internen Schleife verwendet wurde, konnte ich viele Speicherzuweisungsbefehle und -operationen speichern, indem ich all diese Daten in eine spezielle Datenstruktur verschob, die dieselbe Funktionalit√§t wie <code>Vector&lt;XY&gt;</code> bietet.  Ich habe diese neue <code>XYVector</code> Klasse <code>XYVector</code> und das Ergebnis ist hier zu sehen.  Dies ist eine sehr hoch spezialisierte Anwendung, die nicht gleichzeitig flexibel ist, aber uns einige Geschwindigkeitsverbesserungen gebracht hat. <br><br><h2>  Eingebaute Funktionen </h2><br>  Nachdem wir die breite Phase der Kollisionserkennung abgeschlossen haben, m√ºssen wir viele √úberpr√ºfungen durchf√ºhren, um herauszufinden, welche Objekte tats√§chlich kollidieren.  Wo immer m√∂glich, versuche ich Punkte und Zahlen zu vergleichen, nicht Zahlen und Zahlen, aber manchmal muss ich Letzteres tun.  In jedem Fall erfordert dies alles seine eigenen speziellen Kontrollen: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> static function _collide_circleCircle(a:Zone, b:Zone):Bool { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dx:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerX - b.centerX; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dy:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerY - b.centerY; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (dx * dx) + (dy * dy); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (a.radius2) + (b.radius2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d2 &lt; r2; }</code> </pre> <br><br>  All dies kann mit einem einzigen <code>inline</code> verbessert werden: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> function _collide_circleCircle(a:Zone, b:Zone):Bool { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dx:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerX - b.centerX; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dy:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerY - b.centerY; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (dx * dx) + (dy * dy); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (a.radius2) + (b.radius2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d2 &lt; r2; }</code> </pre> <br><br>  Wenn wir einer Funktion Inline hinzuf√ºgen, weisen wir den Compiler an, diesen Code zu kopieren und einzuf√ºgen und die Variablen einzuf√ºgen, wenn er verwendet wird, und keine externe Funktion extern aufzurufen, was zu unn√∂tigen Kosten f√ºhrt.  Das Einbetten ist nicht immer anwendbar (z. B. erh√∂ht es die Codemenge), ist jedoch ideal f√ºr Situationen, in denen kleine Funktionen immer wieder aufgerufen werden. <br><br><h2>  Wir erinnern an Konflikte </h2><br>  Die eigentliche Lehre hier ist, dass Optimierungen in der realen Welt nicht immer vom gleichen Typ sind.  Solche Korrekturen sind eine Mischung aus fortschrittlichen Techniken, billigen Hacks, der Anwendung logischer Empfehlungen und der Beseitigung dummer Fehler.  All dies im Allgemeinen gibt uns einen Leistungsschub. <br><br>  Aber trotzdem - <em>sieben Mal messen, eins schneiden!</em> <br><br>  Zwei Stunden pedantische Optimierung der Funktion, die alle sechs Frames aufgerufen wird und 0,001 ms dauert, sind trotz der H√§sslichkeit und Dummheit des Codes keine M√ºhe wert. <br><br><h1>  3. Sortieren Sie alles </h1><br>  Tats√§chlich war es eine meiner letzten Verbesserungen, aber es erwies sich als so vorteilhaft, dass es seinen eigenen Titel verdient.  Dar√ºber hinaus war es das einfachste und hat sich immer wieder bew√§hrt.  Der Profiler zeigte mir ein Verfahren, das ich √ºberhaupt nicht verbessern konnte - die Hauptschleife draw (), die zu lange dauerte.  Der Grund war die Funktion, mit der alle Bildschirmelemente vor dem Rendern sortiert wurden - das <em>Sortieren</em> aller Sprites dauerte viel l√§nger als das Zeichnen! <br><br>  Wenn Sie sich die Screenshots aus dem Spiel ansehen, werden Sie sehen, dass alle Feinde und Verteidiger zuerst nach <code>y</code> und dann nach <code>x</code> sortiert sind, sodass sich die Elemente von hinten nach vorne von links nach rechts √ºberlappen, wenn wir uns von links oben nach rechts unten bewegen. <br><br>  Eine M√∂glichkeit, die Sortierung zu √ºberlisten, besteht darin, die Rendering-Sortierung einfach durch den Rahmen zu f√ºhren.  Dies ist ein n√ºtzlicher Trick f√ºr einige kostspielige Funktionen, f√ºhrte jedoch sofort zu sehr auff√§lligen visuellen Fehlern, sodass er nicht zu uns passte. <br><br>  Schlie√ülich kam die Entscheidung von einem der HaxeFlixel-Betreuer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jens Fisher</a> .  Er fragte: "Haben Sie sichergestellt, dass Sie einen Sortieralgorithmus verwenden, der f√ºr fast sortierte Arrays schnell ist?" <br><br>  Nein!  Es stellte sich heraus, dass nein.  Ich habe die Array-Sortierung aus der Haxe-Standardbibliothek verwendet (ich denke, es war die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenf√ºhrungssortierung</a> - eine gute Wahl f√ºr allgemeine F√§lle. Aber ich hatte einen ganz <em>besonderen</em> Fall. Beim Sortieren in jedem Frame √§ndert die Sortierposition nur eine sehr kleine Anzahl von Sprites, auch wenn es viele davon gibt Ich habe den alten Sortieraufruf durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sortieren nach Eins√§tzen ersetzt</a> und <em>boom!</em> - die Geschwindigkeit wurde sofort erh√∂ht. <br><br><h1>  4. Andere technische Probleme </h1><br>  Kollisionserkennung und -sortierung waren gro√üe Erfolge in der Logik von <code>update()</code> und <code>draw()</code> , aber viele weitere Fallstricke waren in aktiv verwendeten internen Schleifen verborgen. <br><br><h2>  Std.is () und Besetzung </h2><br>  In verschiedenen "hei√üen" inneren Schleifen hatte ich einen √§hnlichen Code: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Std.<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(something,<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>)) { var typed:<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = cast(something,<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>); }</code> </pre> <br><br>  In der Haxe-Sprache gibt <code>Std.is()</code> , ob ein Objekt zu einem bestimmten Typ (Typ) oder einer Klasse (Klasse) geh√∂rt, und <code>cast</code> versucht, es w√§hrend der Programmausf√ºhrung in einen bestimmten Typ umzuwandeln. <br><br>  Es gibt sichere und ungesch√ºtzte Versionen von <code>cast</code> Abg√ºssen, die zu einer verringerten Leistung f√ºhren, ungesch√ºtzte Abg√ºsse jedoch nicht. <br><br>  Sicher: <code>cast(something, Type);</code> <br><br>  Ungesch√ºtzt: <code>var typed:Type = cast something;</code> <br><br>  Wenn ein unsicherer Zauberversuch fehlschl√§gt, erhalten wir null, w√§hrend ein sicherer Zauber eine Ausnahme ausl√∂st.  Aber wenn wir keine Ausnahme machen wollen, wozu dann eine sichere Besetzung?  Ohne Fang schl√§gt der Vorgang immer noch fehl, arbeitet jedoch langsamer. <br><br>  Dar√ºber hinaus ist es sinnlos, einer sicheren <code>Std.is()</code> Pr√ºfung <code>Std.is()</code> .  Der einzige Grund, einen sicheren Cast zu verwenden, ist eine garantierte Ausnahme. Wenn wir jedoch den Typ vor dem Cast √ºberpr√ºfen, garantieren wir bereits, dass der Cast nicht fehlschl√§gt! <br><br>  Ich kann die <code>Std.is()</code> mit einer <code>Std.is()</code> Besetzung etwas beschleunigen, nachdem <code>Std.is()</code> √ºberpr√ºft <code>Std.is()</code> .  Aber warum m√ºssen wir dasselbe neu schreiben, wenn ich den Typ der Klasse √ºberhaupt nicht √ºberpr√ºfen muss? <br><br>  Angenommen, ich habe ein <code>CreatureSprite</code> , das eine Instanz einer Unterklasse von <code>DefenderSprite</code> oder <code>EnemySprite</code> .  Anstatt <code>Std.is(this,DefenderSprite)</code> wir in <code>CreatureSprite</code> ein Ganzzahlfeld mit Werten wie <code>CreatureType.DEFENDER</code> oder <code>CreatureType.ENEMY</code> erstellen, die noch schneller √ºberpr√ºft werden. <br><br>  Ich wiederhole, es lohnt sich, das Problem nur an den Stellen zu beheben, an denen eine deutliche Verlangsamung deutlich erkennbar ist. <br><br>  √úbrigens k√∂nnen Sie mehr √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sichere</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ungesch√ºtzte</a> Besetzung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haxe-Handbuch</a> lesen. <br><br><h2>  Serialisierung / Deserialisierung des Universums </h2><br>  Es war √§rgerlich, solche Stellen im Code zu finden: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:SomeClass </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SomeClass.fromXML(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toXML()); }</code> </pre> <br>  Ja.  Um ein Objekt zu kopieren, <em>serialisieren</em> wir <em>es in XML</em> und <em>analysieren</em> dann das <em>gesamte XML.</em> Danach verwerfen wir das XML sofort und geben ein neues Objekt zur√ºck.  Dies ist wahrscheinlich der langsamste Weg, ein Objekt zu kopieren. Au√üerdem wird der Speicher √ºberlastet.  Anfangs habe ich XML-Aufrufe geschrieben, um sie zu speichern und von der Festplatte zu laden, und ich glaube, ich war zu faul, um die richtigen Kopierverfahren zu schreiben. <br><br>  Wahrscheinlich w√§re alles in Ordnung, wenn diese Funktion selten verwendet w√ºrde, aber diese Aufrufe entstanden an unangemessenen Stellen mitten im Spiel.  Also setzte ich mich und begann zu schreiben und die richtige Kopierfunktion zu testen. <br><br><h2>  Sag nein zu Null </h2><br>  Die Gleichheitspr√ºfung f√ºr Null wird h√§ufig verwendet. Bei der √úbersetzung von Haxe in cpp f√ºhrt ein Objekt, das einen unbestimmten Wert zul√§sst, zu unn√∂tigen Kosten, die nicht entstehen, wenn der Compiler davon ausgehen kann, dass das Objekt niemals null sein wird.  Dies gilt insbesondere f√ºr Basistypen wie <code>Int</code> - Haxe, die die G√ºltigkeit eines undefinierten Werts f√ºr sie im statischen Zielsystem durch ihr ‚ÄûPacken‚Äú implementieren. Dies tritt nicht nur f√ºr Variablen auf, die explizit als null deklariert sind ( <code>var myVar:Null&lt;Int&gt;</code> ), sondern auch f√ºr Dinge wie <code>?myParam:Int</code> ( <code>?myParam:Int</code> ).  Dar√ºber hinaus verursachen die Nullpr√ºfungen selbst unn√∂tigen Abfall. <br><br>  Ich konnte einige dieser Probleme beheben, indem ich mir den Code ansah und √ºber Alternativen nachdachte. Kann ich eine einfachere √úberpr√ºfung durchf√ºhren, die immer dann zutrifft, wenn das Objekt null ist?  Kann ich null viel fr√ºher in der Kette von Funktionsaufrufen abfangen und ein einfaches Integer- oder Boolesches Flag an untergeordnete Aufrufe weitergeben?  Kann ich alles so strukturieren, dass der Wert <em>niemals</em> null wird?  Usw.  Wir k√∂nnen Nullpr√ºfungen und nullwertf√§hige Werte nicht vollst√§ndig eliminieren, aber es hat mir sehr geholfen, sie aus Funktionen zu entfernen. <br><br><h1>  5. Downloadzeit </h1><br>  Auf PSVita hatten wir besonders ernsthafte Probleme mit der Ladezeit einiger Szenen.  Bei der Profilerstellung stellte sich heraus, dass die Gr√ºnde haupts√§chlich auf Textrasterung, unn√∂tiges Software-Rendering, kostspieliges Rendern von Schaltfl√§chen und andere Dinge zur√ºckzuf√ºhren sind. <br><br><h2>  Text </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HaxeFlixel</a> basiert auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenFL</a> , das ein fantastisches und zuverl√§ssiges TextField bietet.  Aber ich habe FlxText-Objekte unvollst√§ndig verwendet - FlxText-Objekte haben ein internes OpenFL-Textfeld, das gerastert ist.  Es stellte sich jedoch heraus, dass ich die meisten dieser komplexen Textfunktionen nicht ben√∂tigte, aber aufgrund der dummen Art, mein UI-System einzurichten, mussten die Textfelder gerendert werden, bevor alle anderen Objekte gefunden wurden.  Dies f√ºhrte beispielsweise beim Laden eines Popup-Fensters zu kleinen, aber sp√ºrbaren Spr√ºngen. <br><br>  Hier habe ich drei Korrekturen vorgenommen: Erstens habe ich so viel Text wie m√∂glich durch Raster-Schriftarten ersetzt.  Flixel bietet integrierte Unterst√ºtzung f√ºr verschiedene Raster-Schriftformate, einschlie√ülich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AngelCodes BMFont</a> , wodurch die Arbeit mit Unicode, Stil und Kerning <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vereinfacht wird. Die Rastertext-</a> API unterscheidet sich jedoch geringf√ºgig von der Nur-Text-API, sodass ich eine kleine Wrapper-Klasse schreiben musste vereinfachen Sie den √úbergang.  (Ich gab ihm einen passenden Namen <code>FlxUITextHack</code> ). <br><br>  Dies verbesserte die Arbeit geringf√ºgig - Bitmap-Schriftarten werden sehr schnell gerendert -, erh√∂hte jedoch die Komplexit√§t geringf√ºgig: Ich musste speziell separate Zeichens√§tze vorbereiten und je nach Gebietsschema Schaltlogik hinzuf√ºgen, anstatt nur ein Textfeld einzurichten, das die gesamte Arbeit erledigte. <br><br>  Die zweite Korrektur bestand darin, ein neues UI-Objekt zu erstellen, das ein einfacher <em>Platzhalter</em> f√ºr den Text war, aber dieselben √∂ffentlichen Eigenschaften wie der Text hatte.  Ich habe es "Textbereich" genannt und eine neue Klasse daf√ºr in meiner UI-Bibliothek erstellt, damit mein UI-System diese Textbereiche wie echte Textfelder verwenden kann, aber es wird nichts gerendert, bis es die Gr√∂√üe und Position f√ºr alles andere berechnet.  Als meine Szene vorbereitet war, begann ich, diese Textbereiche durch echte Textfelder (oder Textfelder von Bitmap-Schriftarten) zu ersetzen. <br><br>  Die dritte Korrektur betraf die Wahrnehmung.  Wenn es auch innerhalb einer halben Sekunde Pausen zwischen Eingabe und Reaktion gibt, nimmt der Spieler dies als Bremsen wahr.  Daher habe ich versucht, alle Szenen zu finden, in denen die Eingabe bis zum n√§chsten √úbergang verz√∂gert ist, und entweder eine durchscheinende Ebene mit dem Wort "Laden ..." oder nur eine Ebene ohne Text hinzugef√ºgt.  Eine solche einfache Korrektur hat die <em>Wahrnehmung der</em> Reaktionsf√§higkeit des Spiels erheblich verbessert, da unmittelbar nach dem Ber√ºhren des Steuerelements etwas passiert, selbst wenn die Anzeige des Men√ºs einige Zeit in Anspruch nimmt. <br><br><h2>  Software-Rendering </h2><br>  Die meisten Men√ºs verwenden eine Kombination aus Software-Skalierung und 9-Slice-Compositing.  Dies geschah, weil es in der PC-Version eine aufl√∂sungsunabh√§ngige Benutzeroberfl√§che gab, die mit einem Seitenverh√§ltnis von 4: 3 und 16: 9 arbeiten konnte, entsprechend skaliert.  Bei PSVita kennen wir <em>die</em> Aufl√∂sung bereits <em>,</em> dh wir ben√∂tigen nicht alle diese hochaufl√∂senden Ressourcen und Echtzeit-Skalierungsalgorithmen.  Wir k√∂nnen Ressourcen einfach auf die genaue Aufl√∂sung vorrendern und sie auf dem Bildschirm platzieren. <br><br>  Zuerst habe ich das UI-Markup f√ºr Vita-Bedingungen eingegeben, bei dem das Spiel auf die Verwendung paralleler Ressourcen umgestellt wurde.  Dann musste ich diese Ressourcen erstellen, die f√ºr eine Berechtigung vorbereitet waren.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HaxeFlixel-Debugger hat</a> sich hier als sehr n√ºtzlich erwiesen. Ich habe mein Skript hinzugef√ºgt, damit der Raster-Cache einfach auf die Festplatte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geleert</a> wird.  Dann habe ich eine spezielle Build-Konfiguration f√ºr Windows erstellt, die die Berechtigung f√ºr Vita simuliert, alle Spielmen√ºs der Reihe nach ge√∂ffnet, zum Debugger gewechselt und den Exportbefehl f√ºr die skalierten Versionen der Ressourcen als vorgefertigte PNGs gestartet.  Dann habe ich sie einfach umbenannt und als Ressourcen f√ºr Vita verwendet. <br><br><h2>  Rendern von Schaltfl√§chen </h2><br>  Mein UI-System hatte ein echtes Problem mit Schaltfl√§chen - als sie erstellt wurden, haben die Schaltfl√§chen den Standardressourcensatz gerendert, und einen Moment sp√§ter haben sie die Gr√∂√üe des UI-Startcodes ge√§ndert (und erneut gerendert), und manchmal sogar das <em>dritte</em> Mal, bevor die gesamte Benutzeroberfl√§che geladen wurde .  Ich habe dieses Problem gel√∂st, indem ich Optionen hinzugef√ºgt habe, die das Rendern von Schaltfl√§chen bis zur letzten Stufe verz√∂gerten. <br><br><h2>  Optionaler Textscan </h2><br>  Das Magazin wurde besonders langsam geladen.  Zuerst dachte ich, das Problem liege bei den Textfeldern, aber nein.  Der Zeitschriftentext k√∂nnte Links zu anderen Seiten enthalten, die durch Sonderzeichen im Rohtext selbst gekennzeichnet sind.  Diese Zeichen wurden sp√§ter ausgeschnitten und zur Berechnung der Position des Links verwendet. <br><br>  Es stellte sich heraus.  dass ich <em>jedes Textfeld</em> gescannt habe, um diese Zeichen zu finden und durch korrekt formatierte Links zu ersetzen, ohne vorher zu pr√ºfen, ob dieses Textfeld ein Sonderzeichen enth√§lt!  Schlimmer noch, je nach Design wurden Links <em>nur</em> auf der Inhaltsseite verwendet, aber ich habe sie in jedem Textfeld auf jeder Seite √ºberpr√ºft. <br><br>  Ich habe es geschafft, all diese √úberpr√ºfungen mit dem if-Konstrukt des Formulars "Verwendet dieses Textfeld √ºberhaupt Links" zu umgehen.  Die Antwort auf diese Frage war normalerweise nein.  Schlie√ülich stellte sich heraus, dass die Seite, deren Laden am l√§ngsten dauerte, die Indexseite war.  Da es sich im Journalmen√º nie √§ndert, warum zwischenspeichern wir es nicht? <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Speicherprofilerstellung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwindigkeit ist nicht nur die CPU. </font><font style="vertical-align: inherit;">Speicher kann auch ein Problem sein, insbesondere auf schwachen Plattformen wie Vita. </font><font style="vertical-align: inherit;">Selbst wenn Sie es geschafft haben, den letzten Speicherverlust zu beseitigen, haben Sie m√∂glicherweise immer noch Probleme mit der Verwendung des S√§gezahnspeichers in einer Speicherbereinigungsumgebung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist S√§gezahnspeicher? </font><font style="vertical-align: inherit;">Der Garbage Collector funktioniert wie folgt: Daten und Objekte, die Sie nicht verwenden, sammeln sich im Laufe der Zeit an und werden regelm√§√üig gel√∂scht. </font><font style="vertical-align: inherit;">Sie haben jedoch keine klare Kontrolle dar√ºber, wann dies geschieht, sodass das Diagramm zur Speichernutzung wie eine S√§ge aussieht:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/d66/464/7fcd664644c9d2b8bbfe3ac82d60ae2b.png"></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nimm den M√ºll raus </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Reinigung nicht sofort erfolgt, ist die Gesamtmenge an RAM, die Sie verwenden, normalerweise gr√∂√üer als Sie wirklich ben√∂tigen. Wenn Sie jedoch </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamtmenge des System-RAM </font><em><font style="vertical-align: inherit;">√ºberschreiten</font></em><font style="vertical-align: inherit;"> , kann eines von zwei Dingen passieren: Auf einem PC verwenden Sie wahrscheinlich nur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Auslagerungsdatei</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">dh, Sie </font><font style="vertical-align: inherit;">konvertieren vor√ºbergehend einen Teil des Festplattenspeichers in virtuellen RAM. Eine Alternative in Umgebungen mit begrenztem Speicher (z. B. Konsolen) besteht darin, die Anwendung zum Absturz zu bringen, selbst wenn nicht genug von einem miserablen Bytepaar vorhanden war. Und dies wird auch dann passieren, wenn Sie diese Bytes nicht verwenden und die Garbage Collection bald in ihnen durchgef√ºhrt wird!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gute an Haxe ist, dass es vollst√§ndig Open Source ist, das hei√üt, Sie sind nicht in einer Black Box eingeschlossen, die Sie nicht reparieren k√∂nnen, wie dies bei Unity der Fall ist. </font><font style="vertical-align: inherit;">Und das hxcpp-Backend bietet eine umfassende Speicherbereinigungsverwaltung direkt √ºber die API! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben sie verwendet, um den Speicher nach einem gro√üen Level sofort zu l√∂schen, um innerhalb der vorgegebenen Grenzen zu bleiben: </font></font><br><br> <code>cpp.vm.Gc.run(false); //   (true/false - /  )</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie sollten ihn nicht unfreiwillig verwenden, wenn Sie nicht wissen, was Sie tun, aber es ist praktisch, dass solche Tools vorhanden sind, wenn sie ben√∂tigt werden.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Problemumgehung durch Design </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All diese Leistungsverbesserungen waren mehr als genug, um das Spiel f√ºr den PC zu optimieren, aber wir haben auch versucht, eine Version f√ºr PSVita zu ver√∂ffentlichen, und wir hatten langfristige Pl√§ne f√ºr den Nintendo Switch, sodass wir alles vom Code bis zum Drop komprimieren mussten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber oft gibt es ‚ÄûTunnelblick‚Äú, wenn Sie sich nur auf technische Hacks konzentrieren und vergessen, dass eine einfache √Ñnderung des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Designs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Situation erheblich verbessern kann </font><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beschleunigungseffekte mit hoher Geschwindigkeit </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei 16x treten viele Effekte so schnell auf, dass der Spieler sie nicht einmal sieht. Wir haben bereits einen Trick angewendet - der Blitz von Azra wurde mit der Geschwindigkeit des Spiels einfacher und die Anzahl der Partikel f√ºr AOE-Angriffe ist geringer. Wir haben diese Technik durch Deaktivieren von Hochgeschwindigkeitsschadenzahlen und √§hnlichen Tricks erg√§nzt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben auch festgestellt, dass die 16-fache Geschwindigkeit irgendwann </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">langsamer sein kann</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als die 8-fache Geschwindigkeit, wenn sich zu viele Objekte auf dem Bildschirm befinden. Wenn also die Anzahl der Gegner auf ein bestimmtes Limit ansteigt, haben wir die Spielgeschwindigkeit automatisch auf das 8-fache oder 4-fache reduziert. In der Praxis wird der Spieler dies wahrscheinlich nur in Endless Battle 2 sehen. Dies erm√∂glicht eine reibungslose Leistung und ein reibungsloses Rendern, ohne die CPU zu √ºberlasten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben auch Einschr√§nkungen speziell f√ºr die Plattform verwendet. </font><font style="vertical-align: inherit;">In Vita √ºberspringen wir den Blitzeffekt, wenn Azra den Charakter ausl√∂st oder beschleunigt, und verwenden andere √§hnliche Tricks.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> K√∂rper verstecken </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und was ist mit dem riesigen Haufen Feinde in der unteren rechten Ecke von Endless Battle 2 - es gibt buchst√§blich Hunderte oder sogar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tausende von</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Feinden, die √ºbereinander ziehen. </font><font style="vertical-align: inherit;">Warum √ºberspringen wir nicht einfach das Rendern derjenigen, die wir nicht einmal sehen k√∂nnen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein listiger Entwurfstrick, der eine listige Programmierung erfordert, da wir einen intelligenten Algorithmus ben√∂tigen, der versteckte Objekte definiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die meisten dieser Spiele werden mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Algorithmus des K√ºnstlers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gezeichnet. </font><font style="vertical-align: inherit;">Die vorherigen Objekte in der Zeichnungsliste werden durch alles blockiert, was nach ihnen kommt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Umkehren der Reihenfolge des Renderns des K√ºnstleralgorithmus k√∂nnen Sie eine ‚ÄûTitelkarte‚Äú erstellen und herausfinden, was ausgeblendet werden soll. Ich habe eine gef√§lschte "Leinwand" mit 8 Ebenen der "Dunkelheit" (nur eine zweidimensionale Anordnung von Bytes) mit einer viel niedrigeren Aufl√∂sung als ein echtes Schlachtfeld erstellt. Ab dem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Rendering-Liste nehmen wir den Begrenzungsrahmen jedes Objekts und ‚Äûzeichnen‚Äú ihn auf die Leinwand, wobei wir die ‚ÄûDunkelheit‚Äú des Punkts f√ºr jedes ‚ÄûPixel‚Äú, das von dem Begrenzungsrahmen mit niedriger Aufl√∂sung abgedeckt wird, um 1 erh√∂hen. Gleichzeitig lesen wir die durchschnittliche "Dunkelheit" des Bereichs, in dem wir zeichnen werden. Tats√§chlich sagen wir voraus, wie viele </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neuzeichnungen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes Objekt mit einem echten </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Zeichenaufruf</font></a><font style="vertical-align: inherit;"> erfahren wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die vorhergesagte Anzahl von Neuzeichnungen hoch genug ist, markiere ich den Feind als "begraben" mit zwei Schwellenwerten - vollst√§ndig begraben, dh vollst√§ndig unsichtbar oder teilweise begraben, dh er wird gezogen, ohne jedoch einen Gesundheitsbalken zu erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(√úbrigens ist hier die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion zum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úberpr√ºfen von Neuzeichnungen.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit dies korrekt funktioniert, m√ºssen Sie die Aufl√∂sung der ausgeblendeten Karte korrekt konfigurieren. </font><font style="vertical-align: inherit;">Wenn es zu gro√ü ist, m√ºssen wir eine zus√§tzliche Reihe vereinfachter Zeichenaufrufe ausf√ºhren. Wenn es zu klein ist, werden wir Objekte zu aggressiv ausblenden und visuelle Fehler erhalten. </font><font style="vertical-align: inherit;">Wenn Sie die Karte richtig ausw√§hlen, ist der Effekt kaum sp√ºrbar, aber die Geschwindigkeitssteigerung ist sehr sp√ºrbar - es gibt keine M√∂glichkeit, etwas schneller zu zeichnen, als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es √ºberhaupt nicht zu zeichnen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bessere Vorspannung als Bremsen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mitten in den K√§mpfen bemerkte ich h√§ufiges Bremsen, was sicher durch eine Pause in der M√ºllabfuhr verursacht wurde. </font><font style="vertical-align: inherit;">Die Profilerstellung hat jedoch gezeigt, dass dies nicht der Fall ist. </font><font style="vertical-align: inherit;">Weitere Tests ergaben, dass dies zu Beginn der Spawn-Welle von Feinden geschieht, und sp√§ter stellte ich fest, dass dies nur dann geschieht, wenn es sich um eine Welle von Feinden handelt, die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuvor nicht existierte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Offensichtlich hat ein feindlicher Konfigurationscode das Problem verursacht, und nat√ºrlich wurde beim Erstellen von Profilen in den Grafikeinstellungen eine ‚Äûhei√üe‚Äú Funktion gefunden. </font><font style="vertical-align: inherit;">Ich fing an, an einem komplexen Multithread-Download-Setup zu arbeiten, aber dann wurde mir klar, dass ich einfach alle feindlichen Grafikladevorg√§nge in das Battle Preload einbauen konnte. </font><font style="vertical-align: inherit;">Unabh√§ngig davon waren dies sehr kleine Downloads, selbst auf den langsamsten Plattformen, die weniger als eine Sekunde zur gesamten Ladezeit des Kampfes beitrugen, aber sie vermieden ein sehr merkliches Bremsen w√§hrend des Spiels.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir behalten uns den Vorrat f√ºr sp√§ter vor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie in einer Umgebung mit begrenztem Speicher arbeiten, k√∂nnen Sie den alten Trick unserer Branche verwenden - einfach so ein gro√ües St√ºck Speicher zuweisen und es dann bis zum Ende des Projekts vergessen. Wenn Sie am Ende des Projekts das gesamte verf√ºgbare Speicherbudget verschwendet haben, k√∂nnen Sie dank dieses ‚ÄûNotgroschen‚Äú gerettet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir befanden uns in einer solchen Situation - wir brauchten nur ein Dutzend Bytes, um die Assembly f√ºr PSVita zu speichern, aber zur H√∂lle - wir haben diesen Trick vergessen und sind deshalb h√§ngen geblieben! Die einzigen verbleibenden Optionen waren Wochen verzweifelter und schmerzhafter Code-Operationen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber warte einen Moment! Eine meiner (erfolglosen) Optimierungen bestand darin, so viele Ressourcen wie m√∂glich und </font><em><font style="vertical-align: inherit;">dauerhaft zu</font></em><font style="vertical-align: inherit;"> laden</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern im Speicher, da ich f√§lschlicherweise angenommen habe, dass eine gro√üe Ladezeit durch das Lesen von Ressourcen w√§hrend der Ausf√ºhrung des Programms verursacht wurde. </font><font style="vertical-align: inherit;">Es stellte sich heraus, dass dies nicht der Fall war, sodass fast alle diese zus√§tzlichen Anforderungen f√ºr das Vorladen und die ewige Speicherung vollst√§ndig entfernt werden konnten und ich immer noch freien Speicher hatte!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dinge loswerden, die wir nicht benutzen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Arbeit am Build f√ºr PSVita haben wir besonders deutlich gemacht, dass es eine Reihe von Dingen gibt, die wir einfach nicht brauchen. Aufgrund der geringen Aufl√∂sung waren der Quellgrafikmodus und der HD-Grafikmodus nicht zu unterscheiden. Daher haben wir f√ºr alle Sprites die Originalgrafiken verwendet. Es ist uns auch gelungen, die Funktion zum Ersetzen der Palette mithilfe eines speziellen Pixel-Shaders zu verbessern (fr√ºher haben wir die Funktion des Programm-Renderings verwendet). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Beispiel war die Kampfkarte selbst - auf dem PC und den Heimkonsolen haben wir ein paar Kachelkarten √ºbereinander gestapelt, um eine mehrschichtige Karte zu erstellen. Da sich die Karte jedoch nie √§ndert, k√∂nnen wir auf Vita einfach alles zu einem fertigen Bild zusammenbacken, damit es in einem Draw Call aufgerufen wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzlich zu den zus√§tzlichen Ressourcen hatte das Spiel viele zus√§tzliche Anrufe, zum Beispiel, dass Verteidiger und Feinde in jedem Frame ein Regenerationssignal sendeten, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch wenn sie nicht in der Lage waren, sich zu regenerieren</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn die Benutzeroberfl√§che f√ºr eine solche Kreatur ge√∂ffnet war, wurde sie in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedem Frame</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> neu gezeichnet </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt ein halbes Dutzend anderer Beispiele f√ºr kleine Algorithmen, die etwas innerhalb einer ‚Äûhei√üen‚Äú Funktion berechnen, aber nirgendwo Ergebnisse zur√ºckgeben. </font><font style="vertical-align: inherit;">Normalerweise waren dies die Ergebnisse der Erstellung der Struktur in den fr√ºhen Entwicklungsstadien, daher haben wir sie einfach ausgeschnitten.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NaNopocalypse </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Fall war lustig. </font><font style="vertical-align: inherit;">Der Profiler berichtete, dass die Berechnung der Winkel viel Zeit in Anspruch nimmt. </font><font style="vertical-align: inherit;">Hier ist der generierte Haxe C ++ - Code im Profiler:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/387/7d5/4f43877d538fc9c44c34e5bfaa72bd45.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist eine dieser Funktionen, die Werte wie annehmen </font></font><code>-90</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und in konvertieren </font></font><code>270</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Manchmal erhalten Sie Werte wie </font></font><code>-724</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die in wenigen Zyklen auf reduziert werden </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus irgendeinem Grund wurde ein Wert an diese Funktion √ºbergeben </font></font><code>-2147483648</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d8/6bc/9c8/7d86bc9c84d9e75a345b898ff44940a1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns die Berechnungen durchf√ºhren. Wenn wir in jedem Zyklus 360 zu -2147483648 addieren, dauert es ungef√§hr 5.965.233 Iterationen, bis er gr√∂√üer als 0 wird und den Zyklus abschlie√üt. √úbrigens wurde dieser Zyklus mit jedem Update (nicht in jedem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frame</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - in jedem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Update</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !) </font><em><font style="vertical-align: inherit;">Durchgef√ºhrt</font></em><font style="vertical-align: inherit;"> - jedes Mal, wenn das Projektil (oder etwas anderes) seinen Winkel √§nderte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich war es meine Schuld, weil ich einen Wert √ºbergeben habe </font></font><code>NaN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- einen speziellen Wert, der "Keine Zahl" (keine Zahl) bedeutet, was normalerweise einen Fehler signalisiert, der zuvor im Code aufgetreten ist. Wenn Sie es auf eine Ganzzahl bringen, ohne es vorher zu √ºberpr√ºfen, passieren solche seltsamen Dinge. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als vor√ºbergehende Korrektur habe ich einen Scheck hinzugef√ºgt</font></font><code>Math.isNan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den Winkel zur√ºcksetzen, wenn ein solches (eher seltenes, aber unvermeidliches) Ereignis eintritt. </font><font style="vertical-align: inherit;">Gleichzeitig suchte ich weiter nach der Grundursache des Fehlers, fand sie und die Verz√∂gerung verschwand sofort. </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass Sie eine gro√üe Geschwindigkeitssteigerung erzielen k√∂nnen, wenn Sie nicht 6 Millionen bedeutungslose Iterationen durchf√ºhren! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Ein Fix f√ºr diesen Fehler wurde </font><font style="vertical-align: inherit;">in HaxeFlixel selbst </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eingef√ºgt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .)</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úberlisten Sie sich nicht </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sowohl OpenFL als auch HaxeFlixel basieren auf Ressourcen-Caching. </font><font style="vertical-align: inherit;">Dies bedeutet, dass beim Laden einer Ressource beim n√§chsten Empfang diese Ressource aus dem Cache entnommen und nicht erneut von der Festplatte geladen wird. </font><font style="vertical-align: inherit;">Dieses Verhalten kann √ºberschrieben werden und ist manchmal sinnvoll. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich geriet jedoch in einige seltsame, weit hergeholte Dinge: Ich lud die Ressource herunter und forderte das System ausdr√ºcklich </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Ergebnisse </font><em><font style="vertical-align: inherit;">nicht</font></em><font style="vertical-align: inherit;"> zwischenzuspeichern, da ich mir v√∂llig sicher war, was ich tat, und keinen Speicher im Cache ‚Äûverschwenden‚Äú wollte. </font><font style="vertical-align: inherit;">Jahre sp√§ter haben mich diese ‚Äûintelligenten‚Äú Aufrufe dazu gebracht, immer wieder dieselbe Ressource zu laden, das Spiel zu verlangsamen und wertvollen Speicher zu verschwenden, den ich durch das Verlassen des Caches ‚Äûgespeichert‚Äú habe.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Au√üerdem lohnt es sich m√∂glicherweise nicht, Levels wie Endless Battle 2 zu absolvieren </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ja, es ist gro√üartig, dass wir all diese kleinen Tricks implementiert haben, um die Geschwindigkeit zu erh√∂hen. Ehrlich gesagt haben wir die meisten von ihnen erst bemerkt, als wir damit begannen, das Spiel auf weniger leistungsf√§hige Systeme zu portieren, als die Probleme auf einigen Ebenen v√∂llig unertr√§glich wurden. Ich bin froh, dass wir es am Ende geschafft haben, die Geschwindigkeit zu erh√∂hen, aber ich denke, dass das pathologische Level-Design auch vermieden werden sollte. Endless Battle 2 hat das System zu stark belastet, insbesondere im Vergleich zu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allen anderen Levels des Spiels</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbst nach all diesen √Ñnderungen kann die PSVita-Version das urspr√ºngliche Endless 2-Design nicht bew√§ltigen, und ich wollte die Geschwindigkeit der Basismodelle XB1 und PS4 nicht riskieren. Deshalb habe ich die Balance f√ºr die Konsolenversionen von Endless 2 ge√§ndert. Ich habe die Anzahl der Gegner verringert, aber deren Eigenschaften erh√∂ht so dass das Level ungef√§hr die gleiche Schwierigkeit hat. Au√üerdem haben wir bei PSVita die Anzahl der Wellen auf einhundert begrenzt, um das Risiko eines Speicherausfalls zu vermeiden, aber keine Einschr√§nkungen f√ºr PS4 und XB1 hinzugef√ºgt. Dank dessen ist das Erreichen der Ausdauerleistung auf allen Konsolen immer noch gleich schwierig. In der PC-Version blieb das Design des Endless Batlte 2 Level unver√§ndert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All dies war eine Lektion f√ºr uns, die wir bei der Erstellung von Defender's Quest II ber√ºcksichtigen werden - wir werden sehr aufmerksam auf Levels ohne Obergrenze f√ºr die Anzahl der Feinde auf dem Bildschirm sein! </font><font style="vertical-align: inherit;">Nat√ºrlich sind die "endlosen" Missionen f√ºr Tower Defense-Fans sehr attraktiv, daher werde ich sie nicht vollst√§ndig los, aber was ist mit den Levels mit Kontrollpunkten, an denen der Spieler alles auf dem Bildschirm zerst√∂ren MUSS, bevor er zu den n√§chsten Wellen √ºbergeht? </font><font style="vertical-align: inherit;">Dies erm√∂glicht es uns nicht nur, die Anzahl der Gegner auf dem Bildschirm zu begrenzen, sondern auch das Speichern in der Mitte des Levels zu realisieren, ohne den Zustand der verr√ºckten Suppe von Objekten in einem intensiven Kampf zu serialisieren. Es reicht aus, nur die Koordinaten der Verteidiger zu speichern, Level zu erh√∂hen usw.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Gedanken zum Schluss </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Spieleleistung ist ein komplexes Thema, da die Spieler oft nicht verstehen, was es ist, und wir sollten von ihnen kein solches Verst√§ndnis erwarten. Aber ich hoffe, dass dieser Artikel ein wenig f√ºr Sie klargestellt hat, wie alles im Inneren aussieht, und Sie haben mehr dar√ºber gelernt, wie Design, technische Kompromisse und einfach dumme Entscheidungen Spiele verlangsamen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Fazit ist, dass selbst in einem Spiel mit einem guten Design, das von einem talentierten Team entwickelt wurde, solche kleinen ‚Äûrostigen‚Äú Codefragmente absolut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºberall</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu finden </font><em><font style="vertical-align: inherit;">sind</font></em><font style="vertical-align: inherit;"> . In der Praxis wirkt sich jedoch nur ein kleiner Teil davon tats√§chlich auf die Leistung aus. Die F√§higkeit, sie zu erkennen und zu beseitigen, ist Kunst und Wissenschaft gleicherma√üen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich bin froh, dass wir all diese Vorteile bei der Entwicklung von Defender's Quest II nutzen werden. </font><font style="vertical-align: inherit;">Wenn wir keinen Port f√ºr PSVita erstellt h√§tten, h√§tte ich wahrscheinlich nicht einmal die H√§lfte dieser Optimierungen ausprobiert. </font><font style="vertical-align: inherit;">Und selbst wenn Sie das Spiel nicht f√ºr PSVita kaufen, k√∂nnen Sie sich bei dieser kleinen Konsole bedanken, die die Geschwindigkeit von Defender's Quest erheblich verbessert hat.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414135/">https://habr.com/ru/post/de414135/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414125/index.html">Wie wir VMware vSAN ‚Ñ¢ getestet haben: Warum es in der Praxis funktioniert</a></li>
<li><a href="../de414127/index.html">Installieren Sie 3CX auf einem Hosting f√ºr 2,99 Euro / Monat. in 10 Minuten</a></li>
<li><a href="../de414129/index.html">Master in Theoretischer Informatik an der St. Petersburg State University</a></li>
<li><a href="../de414131/index.html">Die Auswirkung der Signalfrequenz auf die Energie von Funkverbindungen im freien Raum</a></li>
<li><a href="../de414133/index.html">Puzzlespieldesign am Beispiel von In The Shadows</a></li>
<li><a href="../de414137/index.html">SPA-Entwicklungserfahrung auf VueJS + Nuxt</a></li>
<li><a href="../de414139/index.html">Ver√∂ffentlichung eines inoffiziellen MTProto-Proxys in Python, Protokollfunktionen</a></li>
<li><a href="../de414141/index.html">7 Regeln f√ºr die Gestaltung von Leiterplatten</a></li>
<li><a href="../de414149/index.html">Die Gr√ºnde f√ºr den schlechten Klang der meisten Android-Smartphones</a></li>
<li><a href="../de414151/index.html">Fintech-Digest: Banken melden Sch√§den durch Hackerangriffe, Western Union weigert sich, mit Kryptow√§hrungen zu arbeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>