<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗞️ 🔇 👩🏼‍🏭 Komprimierung großer Anordnungen von Primzahlen 🎂 👴🏾 🏇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit den Eigenschaften von Primzahlen können Sie selten anders als in Form eines vorberechneten Arrays damit arbeiten - und vorzugsweise so umfangreich...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Komprimierung großer Anordnungen von Primzahlen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417753/"><img src="https://habrastorage.org/webt/sr/yf/y8/sryfy8c2vpyfx-euoq7v_v3p_sa.jpeg" alt="Sandkasten" align="left"><br><p>  Mit den Eigenschaften von Primzahlen können Sie selten anders als in Form eines vorberechneten Arrays damit arbeiten - und vorzugsweise so umfangreich wie möglich.  Das natürliche Speicherformat in Form von ganzen Zahlen mit der einen oder anderen Ziffernkapazität leidet gleichzeitig an einigen Nachteilen, die mit dem Wachstum des Datenvolumens signifikant werden. <br></p><p></p><p>  Das Format von 16-Bit-Ganzzahlen ohne Vorzeichen mit der Größe einer solchen Tabelle beträgt also ungefähr 13 Kilobyte. Es enthält nur 6542 Primzahlen: gefolgt von der Zahl 65531 sind die Werte für eine höhere Bittiefe.  Ein solcher Tisch ist nur als Spielzeug geeignet. <br></p><p></p><p>  Das beliebteste 32-Bit-Integer-Format in der Programmierung sieht viel solider aus - es ermöglicht Ihnen, etwa 203 Millionen einfache zu speichern.  Eine solche Tabelle belegt jedoch bereits etwa 775 Megabyte. <br></p><p></p><p>  Das 64-Bit-Format bietet noch mehr Perspektiven.  Mit einer theoretischen Potenz in der Größenordnung von 1e + 19 Werten hätte die Tabelle jedoch eine Größe von 64 Exabyte. <br></p><br><a name="habracut"></a><br><p></p><p>  Es wird nicht wirklich angenommen, dass unsere fortschrittliche Menschheit in absehbarer Zeit jemals eine Tabelle mit Primzahlen eines solchen Volumens berechnen wird.  Und hier geht es weniger um Volumen als um die Zählzeit der verfügbaren Algorithmen.  Wenn beispielsweise die Tabelle aller einfachen 32-Bit-Tabellen in wenigen Stunden noch unabhängig berechnet werden kann (Abb. 1), dauert es mehrere Tage, bis die Tabelle um mindestens eine Größenordnung größer ist.  Aber solche Bände heute - das ist nur das Anfangsniveau. <br></p><br><br><img src="https://habrastorage.org/webt/ut/qn/gq/utqngqsvjfyolxj1afp9n--6jxw.jpeg" alt="Abb. 1"><br><br><p>  Wie aus dem Diagramm ersichtlich ist, geht die spezifische Berechnungszeit nach dem Startruck reibungslos in asymptotisches Wachstum über.  Er ist ziemlich langsam.  Dies ist jedoch Wachstum, was bedeutet, dass das Mining aller nächsten Daten im Laufe der Zeit immer schwieriger wird.  Wenn Sie einen bedeutenden Durchbruch erzielen möchten, müssen Sie die Arbeit über die Kerne hinweg parallelisieren (und sie lässt sich gut parallelisieren) und an Supercomputer hängen.  Mit der Aussicht, die ersten 10 Milliarden einfach in einer Woche und 100 Milliarden - nur in einem Jahr - zu bekommen.  Natürlich gibt es schnellere Algorithmen zur einfachen Berechnung als die in meinen Hausaufgaben verwendete triviale Büste, aber im Wesentlichen ändert dies nichts an der Sache: Nach zwei oder drei Größenordnungen wird die Situation ähnlich. <br></p><p></p><p>  Daher wäre es schön, die Zählarbeiten einmal durchgeführt zu haben, das Ergebnis in einer vorgefertigten tabellarischen Form zu speichern und bei Bedarf zu verwenden. <br></p><p></p><p>  Aufgrund der Offensichtlichkeit der Idee stößt das Netzwerk auf viele Links zu vorgefertigten Listen von Primzahlen, die bereits von jemandem berechnet wurden.  Leider sind sie in den meisten Fällen nur für Studentenhandwerk geeignet: eines davon wandert beispielsweise von Ort zu Ort und umfasst 50 Millionen einfache.  Dieser Betrag kann nur Uneingeweihte in Erstaunen versetzen: Es wurde bereits oben erwähnt, dass Sie auf einem Heimcomputer in wenigen Stunden die Tabelle aller einfachen 32-Bit-Tabellen unabhängig berechnen können und sie viermal größer ist.  Wahrscheinlich vor 15 bis 20 Jahren war eine solche Liste in der Tat eine heldenhafte Leistung für die Laiengemeinschaft.  Im Zeitalter von Multi-Core-Multi-Gigahertz- und Multi-Gigabyte-Geräten ist dies heute nicht mehr beeindruckend. <br></p><p></p><p>  Ich hatte das Glück, den Zugang zu einer viel repräsentativeren Tabelle einfacher zu kennen, die ich weiter als Illustration und Opfer für meine Feldversuche verwenden werde.  Zum Zwecke der Verschwörung werde ich sie <b>1TPrimo nennen</b> .  Es enthält alle Primzahlen weniger als eine Billion. <br></p><p></p><p>  Am Beispiel von 1TPrimo ist leicht zu erkennen, mit welchen Volumes Sie umgehen müssen.  Mit einer Kapazität von rund 37,6 Milliarden Werten im 64-Bit-Integer-Format umfasst diese Liste 280 Gigabyte.  Übrigens - der Teil davon, der in 32 Ziffern passen könnte, macht nur 0,5% der Anzahl der darin dargestellten Zahlen aus.  Dies macht absolut klar, dass jede ernsthafte Arbeit mit Primzahlen zwangsläufig zu einer Gesamtbittiefe von 64 Bit (oder mehr) führt. <br></p><p></p><p>  Somit ist die düstere Tendenz offensichtlich: Eine irgendwie ernste Tabelle von Primzahlen hat unvermeidlich ein Titanvolumen.  Und wir müssen das irgendwie bekämpfen. <br></p><p></p><p>  Das erste, was mir beim Betrachten einer Tabelle einfällt (Abb. 2), ist, dass sie aus nahezu identischen aufeinander folgenden Werten besteht, die sich nur in einer oder zwei der letzten Dezimalstellen unterscheiden: <br></p><br><p><br><img src="https://habrastorage.org/webt/y7/hk/f5/y7hkf5s75ii-jdujarftwhpd14i.jpeg" alt="Abb. 2"><br><br></p><br><p>  Einfach gesagt, aus den allgemeinsten, abstrakten Überlegungen: Wenn die Datei viele doppelte Daten enthält, sollte sie vom Archivierer gut komprimiert werden.  In der Tat ergab die Komprimierung der 1TPrimo-Tabelle mit dem beliebten 7-Zip-Dienstprogramm bei Standardeinstellungen ein ziemlich hohes Komprimierungsverhältnis: 8,5.  Die Verarbeitungszeit auf einem 8-Core-Server mit einer durchschnittlichen Auslastung aller Kerne von etwa 80 bis 90% betrug - bei der enormen Größe der Quelltabelle - 14 Stunden und 12 Minuten.  Universelle Komprimierungsalgorithmen wurden für einige abstrakte, verallgemeinerte Vorstellungen von Daten entwickelt.  In einigen speziellen Fällen können spezielle Komprimierungsalgorithmen, die auf den bekannten Merkmalen des eingehenden Datensatzes basieren, viel effektivere Indikatoren aufzeigen, denen diese Arbeit gewidmet ist.  Und wie effektiv es wird, wird unten deutlich. <br></p><p></p><p>  Die engen Zahlenwerte benachbarter Primzahlen erfordern eine Entscheidung, diese Werte nicht selbst zu speichern, sondern die Intervalle (Unterschiede) zwischen ihnen.  In diesem Fall können erhebliche Einsparungen erzielt werden, da die Bittiefe der Intervalle viel geringer ist als die Bittiefe der Anfangsdaten (Abb. 3). <br></p><br><p><br><img src="https://habrastorage.org/webt/7-/lk/ka/7-lkkafdhzaus8yglobx1t5t25w.jpeg" alt="Abb. 3"><br><br></p><br><p>  Und es scheint, dass es nicht von der Bittiefe der einfachen abhängt, die das Intervall erzeugen.  Eine erschöpfende Suche zeigt, dass typische Werte von Intervallen für Primzahlen, die von verschiedenen Stellen in der 1TPrimo-Tabelle stammen, innerhalb von Einheiten, Zehnern, manchmal Hunderten liegen und - als erster Arbeitssatz - wahrscheinlich in den Bereich von 8 Bit passen könnten Ganzzahlen ohne Vorzeichen, d. h. Bytes.  Dies wäre sehr praktisch und würde im Vergleich zum 64-Bit-Format sofort zu einer 8-fachen Datenkomprimierung führen - nur irgendwo auf dem Niveau, das der 7-Zip-Archivierer demonstriert.  Darüber hinaus sollte die Einfachheit der Komprimierungs- und Dekomprimierungsalgorithmen im Vergleich zu 7-zip im Prinzip einen großen Einfluss auf die Geschwindigkeit der Komprimierung und den Zugriff auf Daten haben.  Klingt verlockend. <br></p><p></p><p>  Es ist absolut klar, dass die von ihren Absolutwerten in die relativen Intervalle zwischen ihnen konvertierten Daten nur zum Wiederherstellen einer Reihe von Werten geeignet sind, die vom Anfang der Primärtabelle an in einer Reihe stehen.  Wenn wir einer solchen Intervalltabelle jedoch eine minimale Blockindexstruktur hinzufügen, können wir mit unbedeutenden zusätzlichen Gemeinkosten sowohl das Tabellenelement anhand seiner Nummer als auch das nächstgelegene Element anhand eines willkürlich festgelegten Werts und diese Operationen zusammen mit der Hauptoperation wiederherstellen, jedoch bereits blockweise Sequenzbeispiele - im Allgemeinen erschöpft es den Löwenanteil möglicher Abfragen zu solchen Daten.  Die statistische Verarbeitung wird natürlich komplizierter, bleibt aber dennoch recht transparent  Es gibt keinen besonderen Trick, es "on the fly" aus den verfügbaren Intervallen wiederherzustellen, wenn auf den erforderlichen Datenblock zugegriffen wird. <br></p><p></p><p>  Aber leider.  Ein einfaches numerisches Experiment mit 1TPrimo-Daten zeigt, dass bereits am Ende der dritten zehn Millionen (dies ist weniger als ein Hundertstel Prozent des 1TPrimo-Volumens) - und dann überall sonst - die Intervalle zwischen benachbarten Primzahlen regelmäßig außerhalb des Bereichs von 0..255 liegen. <br></p><p></p><p>  Ein etwas kompliziertes numerisches Experiment zeigt jedoch, dass das Wachstum des maximalen Intervalls zwischen benachbarten Primzahlen mit dem Wachstum der Tabelle selbst sehr, sehr langsam ist - was bedeutet, dass die Idee in gewisser Weise immer noch gut ist. <br></p><p></p><p>  Der zweite, genauere Blick auf die Tabelle der Intervalle legt nahe, dass es möglich ist, nicht den Unterschied selbst, sondern seine Hälfte zu speichern.  Da alle Primzahlen größer als 2 offensichtlich ungerade sind, sind ihre Unterschiede offensichtlich gerade.  Dementsprechend können die Differenzen ohne Wertverlust um 2 reduziert werden;  und der Vollständigkeit halber kann man auch eins vom erhaltenen Quotienten subtrahieren, um den Nullwert, der nicht anders beansprucht wurde, sinnvoll zu verwenden (Fig. 4).  Eine solche Verringerung der Intervalle wird im Folgenden als monolithisch bezeichnet, im Gegensatz zu der losen, porösen Ausgangsform, bei der sich herausstellte, dass alle ungeraden Werte und Null nicht beansprucht wurden. <br></p><br><p><br><img src="https://habrastorage.org/webt/ix/ob/fp/ixobfp-kfzmw2gkwjrkkmwcfxn4.jpeg" alt="Abb. 4"><br><br></p><br><p>  Es ist zu beachten, dass, da das Intervall zwischen den ersten beiden einfachen (2 und 3) nicht in dieses Schema passt, 2 aus der Intervalltabelle ausgeschlossen werden muss und diese Tatsache die ganze Zeit berücksichtigt wird. <br></p><p></p><p>  Mit dieser einfachen Technik können Sie Intervalle von 2 bis 512 im Wertebereich 0..255 codieren. Wieder einmal wird die Hoffnung lebendig, dass die Differenzmethode es uns ermöglicht, eine viel leistungsfähigere Folge von Primzahlen zu packen.  Und das zu Recht: Ein Lauf von 37,6 Milliarden Werten in der 1TPrimo-Liste ergab nur 6 (sechs!) Intervalle, die nicht im Bereich von 2..512 liegen. <br></p><p></p><p>  Aber das waren gute Nachrichten;  Das Schlimme ist, dass diese sechs Intervalle ziemlich frei über die Liste verteilt sind und das erste bereits am Ende des ersten Drittels der Liste auftritt, wodurch die verbleibenden zwei Drittel zu Ballast werden, der für diese Komprimierungsmethode ungeeignet ist (Abb. 5): <br></p><br><p><br><img src="https://habrastorage.org/webt/k_/0y/aw/k_0yaw46rbatmne64qzj0vp9mus.jpeg" alt="Abb. 5"><br><br></p><br><p>  Solch ein Flush (einige unglückliche sechs Stücke für fast vierzig Milliarden! - und auf Sie ...) sogar mit einer Fliege in der Salbe zum Vergleich - um die Ehre des Teers zu zeigen.  Aber leider ist dies ein Muster, kein Unfall.  Wenn wir das erste Auftreten von Intervallen zwischen Primzahlen in Abhängigkeit von der Datenlänge verfolgen, wird klar, dass dieses Phänomen in der Genetik von Primzahlen liegt, obwohl es extrem langsam fortschreitet (Abb. 6 *). <br></p><br><p><br><img src="https://habrastorage.org/webt/sj/c_/ah/sjc_ah1hgw7ud9xewa3_s47edhq.jpeg" alt="Abb. 6"><br><br></p><br><p>  * Zeitplan zusammengestellt nach dem thematischen Ort von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thomas R. Nisley</a> , <br>  Dies sind mehrere Größenordnungen besser als die Leistung der 1TPrimo-Liste </p><br><p></p><p>  Aber auch dieser sehr langsame Fortschritt deutet eindeutig an: Man kann sich auf eine bestimmte vorgegebene Bittiefe eines Intervalls nur bei einer bestimmten vorgegebenen Potenz der Liste beschränken.  Das heißt, es ist nicht als universelle Lösung geeignet. <br></p><p></p><p>  Die Tatsache, dass Sie mit der vorgeschlagenen Methode zum Komprimieren einer Folge von Primzahlen eine einfache kompakte Tabelle mit einer Kapazität von fast 12 Milliarden Werten implementieren können, ist jedoch bereits ein gutes Ergebnis.  Eine solche Tabelle belegt ein Volumen von 11,1 Gigabyte - gegenüber 89,4 Gigabyte in einem trivialen 64-Bit-Format.  Sicherlich kann für eine Reihe von Anwendungen eine solche Lösung ausreichend sein. <br></p><p></p><p>  Und was interessant ist: Das Verfahren zum Übersetzen einer 64-Bit-1TPrimo-Tabelle in das Format von 8-Bit-Intervallen mit einer Blockstruktur unter Verwendung nur eines Prozessorkerns (für die Parallelisierung müssten Sie auf eine erhebliche Komplikation des Programms zurückgreifen, und es hat sich absolut nicht gelohnt) und nicht mehr als 5 % der Prozessorlast (die meiste Zeit für Dateivorgänge) dauerte nur 19 Minuten. Gegen - ich erinnere mich - 14 Stunden auf acht Kernen bei 80-90% der vom 7-Zip-Archivierer aufgewendeten Last. <br></p><p></p><p>  Natürlich wurde nur das erste Drittel der Tabelle dieser Übersetzung unterzogen, bei der der Intervallbereich 512 nicht überschreitet. Wenn wir also die vollen 14 Stunden auf dasselbe Drittel bringen, sollten 19 Minuten mit fast 5 Stunden des 7-Zip-Archivierers verglichen werden.  Bei einer vergleichbaren Komprimierung (8 und 8,5) beträgt der Unterschied etwa das 15-fache.  Wenn man bedenkt, dass der Löwenanteil der Arbeitszeit des Rundfunkprogramms durch Dateivorgänge belegt war, wäre der Unterschied auf einem schnelleren Festplattensystem noch größer.  Und intellektuell sollte die Betriebszeit von 7-zip auf acht Kernen immer noch auf einem Thread gezählt werden, und dann wird der Vergleich wirklich angemessen. <br></p><p></p><p>  Die Auswahl aus einer solchen Datenbank unterscheidet sich zeitlich kaum von der Auswahl aus der Tabelle der entpackten Daten und wird fast ausschließlich durch den Zeitpunkt der Dateivorgänge bestimmt.  Die spezifischen Zahlen hängen stark von der spezifischen Hardware ab. Auf meinem Server dauerte der Zugriff auf einen beliebigen Datenblock durchschnittlich 37,8 μs, während das sequentielle Lesen von Blöcken - 4,2 μs pro Block, zum vollständigen Entpacken des Blocks - weniger als 1 μs betrug.  Das heißt, es macht keinen Sinn, die Dekomprimierung von Daten mit der Arbeit eines Standardarchivierers zu vergleichen.  Und das ist ein großes Plus. <br></p><p></p><p>  Und schließlich bieten die Beobachtungen eine weitere dritte Lösung, mit der alle Einschränkungen der Datenleistung beseitigt werden: Codierungsintervalle mit Werten variabler Länge.  Diese Technik ist seit langem in kompressionsbezogenen Anwendungen weit verbreitet.  Seine Bedeutung ist, dass, wenn in der Eingabe festgestellt wird, dass einige Werte häufig gefunden werden, einige weniger häufig sind und einige sehr selten sind, wir den ersten mit Funktionscodes, den zweiten mit authentischeren Codes und den dritten codieren können - sehr lang (vielleicht sogar sehr lang, weil es keine Rolle spielt: Trotzdem sind solche Daten sehr selten).  Infolgedessen kann die Gesamtlänge der empfangenen Codes viel kürzer als die Eingabedaten sein. <br></p><p></p><p>  Wenn wir uns bereits die grafische Darstellung des Erscheinungsbilds der Intervalle in Abb. 7 ansehen, können wir davon ausgehen, dass die Intervalle 2, 4, 6 usw. sind.  erscheinen früher als Intervalle, z. B. 100, 102, 104 usw., dann sollte das erstere weiterhin viel häufiger auftreten als das letztere.  Und umgekehrt - wenn die Intervalle 514 erst bei 11,99 Milliardstel, 516 - ab 16,2 Milliardstel und 518 - im Allgemeinen erst bei 87,7 Milliardstel auftreten, werden sie sehr selten auftreten.  Das heißt, a priori können wir die umgekehrte Beziehung zwischen der Größe des Intervalls und seiner Häufigkeit in einer Folge von Primzahlen annehmen.  Und das bedeutet - Sie können eine einfache Struktur erstellen, die Codes variabler Länge für sie implementiert. <br></p><p></p><p>  Natürlich sollten Statistiken über die Häufigkeit von Intervallen für die Wahl einer bestimmten Codierungsmethode entscheidend sein.  Glücklicherweise ist im Gegensatz zu willkürlichen Daten die Häufigkeit von Intervallen zwischen Primzahlen - die an sich ein für alle Mal streng bestimmt sind - auch ein genau bestimmtes, ein für alle Mal definiertes Merkmal. <br></p><p></p><p>  Abbildung 7 zeigt den Frequenzgang der Intervalle für die gesamte 1TPrimo-Liste: <br></p><br><p><br><img src="https://habrastorage.org/webt/7q/ga/ii/7qgaii-1mwxlmuvicojaklwrbuk.jpeg" alt="Abb. 7"><br><br></p><br><p>  Hier muss noch einmal erwähnt werden, dass das Intervall zwischen den allerersten Primzahlen 2 und 3 aus dem Diagramm ausgeschlossen ist: Dieses Intervall ist 1 und tritt unabhängig von der Potenz der Liste genau einmal in der Folge von Primzahlen auf.  Dieses Intervall ist so eigenartig, dass es einfacher ist, 2 aus der Liste der einfachen zu entfernen, als ständig zu Reservierungen abzuweichen.  Die Sim wird als <b>virtuelle Primzahl</b> deklariert: Sie ist in den Listen nicht sichtbar, aber vorhanden.  Wie dieser Gopher. <br></p><p></p><p>  Auf den ersten Blick bestätigt der Frequenzgraph die in einigen Absätzen oben genannte a priori-Annahme vollständig.  Es zeigt deutlich die statistische Heterogenität der Intervalle und die hohe Häufigkeit kleiner Werte im Vergleich zu großen.  In der zweiten, konvexeren Ansicht erweist sich die Grafik jedoch als viel interessanter (Abb. 8): <br></p><br><p><br><img src="https://habrastorage.org/webt/qm/4_/xu/qm4_xuzdshet30cdd9ucm7t4q0m.jpeg" alt="Abb. 8"><br><br></p><br><p>  Ganz unerwartet stellt sich heraus, dass die häufigsten Intervalle nicht 2 und 4 sind, wie es aus allgemeinen Überlegungen zu sein schien, sondern 6, 12 und 18, gefolgt von 10 - und erst dann 2 und 4 mit nahezu gleicher Häufigkeit (Unterschied in 7 Ziffern) nach dem Dezimalpunkt).  Darüber hinaus wird die Vielzahl der Spitzenwerte der Zahl 6 im gesamten Diagramm verfolgt. <br></p><p></p><p>  Noch interessanter ist, dass diese versehentlich aufgedeckte Natur des Graphen universell ist - und in allen Details mit all ihren Knicken - über die gesamte Folge einfacher Intervalle, die durch die 1TPrimo-Liste dargestellt werden, wahrscheinlich für jede Folge einfacher Intervalle universell ist (natürlich Eine solch kühne Aussage bedarf eines Beweises, den ich mit großer Freude auf die Schultern von Spezialisten für Zahlentheorie übertrage.  Abbildung 10 zeigt einen Vergleich der vollständigen Intervallstatistik (scharlachrote Linie) mit Stichproben mit begrenztem Intervall, die an mehreren beliebigen Stellen in der 1TPrimo-Liste (Linien anderer Farben) entnommen wurden: <br></p><br><p><br><img src="https://habrastorage.org/webt/xs/jk/hd/xsjkhdqm8aztn2qztye3ftpf0yw.jpeg" alt="Abb. 9"><br></p><br><p>  Aus dieser Grafik ist ersichtlich, dass sich alle diese Proben genau wiederholen, mit nur einem geringen Unterschied im linken und rechten Teil der Figur: Sie scheinen leicht gegen den Uhrzeigersinn um den Intervallpunkt mit einem Wert von 24 gedreht zu sein. Diese Drehung ist wahrscheinlich auf die Tatsache zurückzuführen, dass die höhere links Teile der Grafik basieren auf Samples mit geringerer Bittiefe.  In solchen Samples gibt es noch gar keine oder große Intervalle sind selten, die in Samples mit höheren Bittiefen häufig auftreten.  Dementsprechend spricht ihre Abwesenheit für die Häufigkeit von Intervallen mit niedrigeren Werten.  In Samples mit höheren Bittiefen erscheinen viele neue Intervalle mit großen Werten, daher nimmt die Häufigkeit kleinerer Intervalle geringfügig ab.  Höchstwahrscheinlich verschiebt sich der Drehpunkt mit zunehmender Leistung der Liste in Richtung größerer Werte.  Irgendwo daneben befindet sich der Gleichgewichtspunkt des Graphen, an dem die Summe aller Werte auf der rechten Seite ungefähr gleich der Summe aller Werte auf der linken Seite ist. <br></p><p></p><p>  Diese interessante Natur der Häufigkeit von Intervallen legt nahe, die triviale Struktur von Codes variabler Länge aufzugeben.  Typischerweise besteht eine solche Struktur aus einem Paket von Bits verschiedener Längen und Zwecke.  Zum Beispiel kommt zuerst eine bestimmte Anzahl von Präfixbits, die auf einen bestimmten Wert gesetzt sind, zum Beispiel 0. Dahinter befindet sich ein Stoppbit, das die Vervollständigung des Präfixes anzeigen und dementsprechend vom Präfix abweichen sollte: 1 in diesem Fall.  Das Präfix darf keine Länge haben, dh immer wieder kann die Abtastung sofort mit einem Stoppbit beginnen, wodurch die kürzeste Sequenz bestimmt wird.  Auf das Stoppbit folgt normalerweise ein Suffix, dessen Länge in gewisser Weise durch die Länge des Präfixes bestimmt wird.      ,       ,      —        .      ,        -  .    -    (, , - )  ,          . <br></p><p></p><p>              ,   . <br></p><p></p><p> Und hier sollte noch etwas Wichtiges gesagt werden.  Auf den ersten Blick impliziert die beobachtete Zyklizität die Aufteilung der Intervalle in Tripel: <code>{2,4, <b>6</b> }</code> , <code>{8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> }</code> usw. (die Werte mit der maximalen Häufigkeit in jedem Tripel sind fett markiert). .  Tatsächlich ist der Zyklus hier jedoch etwas anders. <br></p><p></p><p>  Ich werde nicht die ganze Argumentationslinie zitieren, die in der Tat nicht vorhanden ist: Es war eine intuitive Vermutung, ergänzt durch eine Methode zur stumpfen Aufzählung von Optionen, Berechnungen und Stichproben, die zeitweise mehrere Tage dauerte.  Die als Ergebnis offenbarte Zyklizität besteht aus <b>sechs</b> Intervallen <code>{2,4, <b>6</b> ,8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> ,20,22, <b>24</b> }</code> , <code>{26,28, <b>30</b> ,32,34, <b>36</b> }</code> und usw. (Intervalle mit maximaler Frequenz sind wieder fett hervorgehoben). <br></p><p></p><p>  Kurz gesagt, der vorgeschlagene Verpackungsalgorithmus lautet wie folgt. <br></p><p></p><p>  Durch Teilen der Intervalle in Sechser mit geraden Zahlen können wir jedes Intervall <code>g</code> in der Form <code>g = i * 12 + t</code> , wobei <code>i</code> der Index der Sechs ist, zu denen dieses Intervall gehört ( <code>i = {0,1,2,3, ...}</code> ) und <code>t</code> ist ein Schwanz, der einen der Werte aus einem fest definierten, begrenzten und identischen Wert für sechs der Menge darstellt <code>{2,4,6,8,10,12}</code> .  Der Frequenzgang des oben hervorgehobenen Index ist fast genau umgekehrt proportional zu seinem Wert. Daher ist es logisch, den Sechs-Index in eine triviale Struktur eines Codes variabler Länge umzuwandeln, für die oben ein Beispiel angegeben ist.  Die Frequenzcharakteristik des Endes ermöglicht es Ihnen, ihn in zwei Gruppen zu unterteilen, die mit Bitketten unterschiedlicher Länge codiert werden können: Die am häufigsten gefundenen Werte 6 und 12 werden mit einem Bit codiert, die Werte 2, 4, 8 und 10, die viel seltener auftreten, werden mit zwei Bits codiert.  Natürlich wird ein weiteres Bit benötigt, um zwischen diesen beiden Optionen zu unterscheiden. <br></p><p></p><p>  Ein Array, das Bitpakete enthält, wird durch feste Felder ergänzt, die die Startwerte der im Block dargestellten Daten angeben, sowie durch andere Größen, die erforderlich sind, um eine beliebige einfache oder eine Folge einfacher aus den im Block gespeicherten Intervallen wiederherzustellen. <br></p><p></p><p>  Zusätzlich zu dieser Blockindexstruktur wird die Verwendung von Codes variabler Länge durch die zusätzlichen Kosten im Vergleich zu Intervallen mit festen Bits erschwert. <br></p><p></p><p>  Bei Verwendung von Intervallen fester Größe ist das Bestimmen des Blocks, in dem nach einer Primzahl gesucht werden soll, anhand seiner Seriennummer eine ziemlich einfache Aufgabe, da die Anzahl der Intervalle pro Block im Voraus bekannt ist.  Die Suche nach einer einfachen Lösung zum nächstgelegenen Wert hat jedoch keine direkte Lösung.  Alternativ können Sie eine empirische Formel verwenden, mit der Sie die ungefähre Blocknummer mit dem erforderlichen Intervall ermitteln können. Danach müssen Sie durch umfassende Suche nach dem gewünschten Block suchen. <br></p><p></p><p>  Für eine Tabelle mit Codes variabler Länge ist für beide Aufgaben der gleiche Ansatz erforderlich: sowohl zum Abrufen eines Werts nach Zahlen als auch zum Suchen nach Werten.  Da die Länge der Codes variiert, ist nie vorher bekannt, wie viele Unterschiede in einem bestimmten Block gespeichert sind und in welchem ​​Block der gewünschte Wert liegt.  Es wurde experimentell festgestellt, dass mit einer Blockgröße von 512 Bytes (einschließlich einiger Header-Bytes) die Blockkapazität bis zu 10-12 Prozent des Durchschnittswerts betragen kann.  Kleinere Blöcke ergeben eine noch größere relative Streuung.  Gleichzeitig neigt der Durchschnittswert der Blockkapazität selbst dazu, langsam zu sinken, wenn die Tabelle wächst.  Die Auswahl empirischer Formeln zur ungenauen Bestimmung des Anfangsblocks zur Suche nach dem gewünschten Wert sowohl nach Anzahl als auch nach Wert ist keine triviale Aufgabe.  Alternativ können Sie eine komplexere und komplexere Indizierung verwenden. <br></p><p></p><p>  Das ist in der Tat alles. <br></p><p></p><p>  Im Folgenden werden die Feinheiten der Komprimierung einer Primärtabelle unter Verwendung von Codes variabler Länge und die damit verbundenen Strukturen auf formellere und detailliertere Weise beschrieben, und der Code für die Funktionen des Packens und Entpackens von Intervallen in C wird angegeben. <br></p><p></p><p>  Das Ergebnis. <br></p><p></p><p>  Die Datenmenge, die aus Tabelle 1TPrimo in Codes variabler Länge übersetzt wurde, ergänzt durch eine Blockindexstruktur, die ebenfalls nachstehend beschrieben wird, betrug 26.309.295.104 Bytes (24,5 GB), dh das Komprimierungsverhältnis erreicht 11,4.  Offensichtlich nimmt mit zunehmender Bittiefe das Kompressionsverhältnis zu. <br></p><p></p><p>  Die Sendezeit von 280 GB 1TPrimo-Tabelle im neuen Format betrug 1 Stunde.  Dies ist das erwartete Ergebnis nach Experimenten mit Packungsintervallen in Einzelbyte-Ganzzahlen.  In beiden Fällen besteht die Übersetzung der Quelltabelle hauptsächlich aus Dateioperationen und lädt den Prozessor fast nicht (im zweiten Fall ist die Last aufgrund der höheren Rechenkomplexität des Algorithmus immer noch höher).  Die Datenzugriffszeit unterscheidet sich auch nicht sehr von Einzelbyte-Intervallen, aber die Zeit zum Entpacken eines vollständigen Blocks derselben Größe dauerte aufgrund der höheren Komplexität des Algorithmus zum Extrahieren von Codes variabler Länge 1,5 μs. <br></p><p></p><p>  Die Tabelle (Abb. 10) fasst die volumetrischen Eigenschaften der in diesem Text genannten Primzahlentabellen zusammen. <br></p><br><p><br><img src="https://habrastorage.org/webt/dc/jw/6o/dcjw6oz2efm88nqvzolxsz7mx6m.jpeg" alt="Abb. 10"></p><br><p></p><p><br></p><h3>  Beschreibung des Komprimierungsalgorithmus </h3><br><h4>  Bedingungen und Notation </h4><br>  <code>P (prime): P1=3, P2=5, P3=7 ... Pn, Pn1</code> sind Primzahlen gemäß ihrer Seriennummer.  Noch einmal (und zum letzten Mal) betone ich, dass <code>P0=2</code> eine virtuelle Primzahl ist;  Aus Gründen der formalen Einheitlichkeit wird diese Zahl physisch von der Liste der Primzahlen ausgeschlossen. <br><p></p><p>  <code>G (gap)</code> - das Intervall zwischen zwei aufeinanderfolgenden Primzahlen <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code>  <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code> . <br></p><p></p><p>  <code>D (dense)</code> - reduziert auf ein monolithisches Formintervall: <code>D = G/2 -1; D={0,1,2,3 ...}</code>  <code>D = G/2 -1; D={0,1,2,3 ...}</code> .  Die sechs Intervalle in der monolithischen Form sehen aus wie <code>{0,1,2,3,4,5}, {6,7,8,9,10,11}, {12,13,14,15,16,17}</code> usw. <br></p><p></p><p>  <code>Q (quotient)</code> - Index der sechs auf eine monolithische Form reduziert, <code>Q = D div 6; Q={0,1,2,3 ...}</code> <code>Q = D div 6; Q={0,1,2,3 ...}</code> <br></p><p></p><p>  <code>R (remainder)</code> - der Rest der monolithischen sechs <code>R = D mod 6. R</code> immer einen Wert im Bereich <code>{0,1,2,3,4,5}</code> . <br></p><p></p><p>  Die <code>Q</code> und <code>R</code> Werte, die durch das obige Verfahren aus einem beliebigen Intervall <code>G</code> aufgrund ihrer stabilen Frequenzeigenschaften erhalten werden, unterliegen einer Komprimierung und Speicherung in Form von Bitpaketen variabler Länge, die nachstehend beschrieben werden.  Die Bitfolgen, die die Werte von <code>Q</code> und <code>R</code> in einem Paket codieren, werden auf verschiedene Arten erzeugt: Zum Codieren des <code>Q</code> Index wird die Bitkette des Präfixes <code>H</code> , des Flusses <code>F</code> und des Hilfsbits <code>S</code> , und die Bitgruppe des Infix <code>X</code> und des Hilfsbits <code>A</code> werden verwendet, um den Rest <code>R</code> zu codieren <code>R</code> <br></p><p></p><p>  <code>A (arbiter)</code> - ein Bit, das die Größe des Infix <code>X</code> : 0 - Ein-Bit-Infix, 1 - Zwei-Bit. <br></p><p></p><p>  <code>X (infix)</code> - 1- oder 2-Bit-Infix zusammen mit dem Arbiter-Bit <code></code> , das den Wert von <code>R</code> tabellarisch gegenseitig bestimmt (die Tabelle zeigt auch die Häufigkeit der ersten sechs mit solchen Infixen als Referenz): <br></p><br><p><br><img src="https://habrastorage.org/webt/kp/hk/a4/kphka4ymveajnxr8icfzgggln4e.jpeg" alt="Infix-Bits"><br><br></p><br><p>  <code>F (fluxion)</code> ist ein Fluxion, eine Ableitung des Index <code>Q</code> variabler Länge <code>L={0,1,2...}</code> , der zur Unterscheidung zwischen der Semantik von Bitfolgen <code>(), 0, 00, 000,</code> oder <code>1, 01, 001</code> usw. dient. d. <br></p><p></p><p>  Eine Bitkette von Einheiten der Länge <code>L</code> wird ausgedrückt als <code>2^L - 1</code> (das Vorzeichen <code>^</code> bedeutet Exponentiation).  In der C-Notation kann der gleiche Wert durch den Ausdruck <code>1&lt;&lt;L - 1</code> .  Dann kann der Wert der Fluxia der Länge <code>L</code> <code>Q</code> Ausdruck aus <code>Q</code> <br></p><p></p><p></p><pre> F = Q - (1 &lt;&lt; L - 1),
</pre><p></p><p>  und <code>Q</code> aus Fluxia durch Ausdruck wiederherstellen <br></p><p></p><p></p><pre> Q = (1 &lt;&lt; L - 1) + F.
</pre><p></p><p>  Beispielsweise werden für die Größen <code>Q = {0..15}</code> die folgenden Fluxia-Bitketten erhalten: <br></p><br><p><br><img src="https://habrastorage.org/webt/j0/kb/4y/j0kb4y3ob_yutugxxvpwlddqofc.jpeg" alt="Flussbits"><br><br></p><br><p>  Die letzten beiden Bitfelder, die zum Packen / Wiederherstellen von Werten erforderlich sind, sind: <br></p><p></p><p>  <code>H (header)</code> - Präfix, eine auf 0 gesetzte Bitfolge. <br></p><p></p><p>  <code>S (stop)</code> - Stoppbit auf 1 gesetzt, wodurch das Präfix beendet wird. <br></p><p></p><p>  Tatsächlich werden diese Bits zuerst in Bitfolgen verarbeitet. Sie ermöglichen es Ihnen, beim Entpacken oder beim Packen die Größe des Flusses und den Beginn der Arbiter- und Flussfelder zu bestimmen - unmittelbar nach dem Stoppbit. <br></p><p></p><p>  <code>W (width)</code> - die Breite des gesamten Codes in Bits. <br></p><p></p><p>  Die vollständige Struktur des Bitpakets ist in Fig. 11 gezeigt: <br></p><br><p><br><img src="https://habrastorage.org/webt/ke/7u/tz/ke7utzoka0xkdd9dzzux6yden7e.jpeg" alt="Abb. 11"><br><br></p><br><p>  Die aus diesen Ketten wiederhergestellten Werte von <code>Q</code> und <code>R</code> ermöglichen es uns, den Anfangswert des Intervalls wiederherzustellen: <br></p><p></p><p></p><pre> D = Q * 6 + R,
 G = (D + 1) * 2,
</pre><p></p><p>  und die Folge von wiederhergestellten Intervallen ermöglicht es Ihnen, die ursprünglichen Primzahlen von einem gegebenen Basiswert des Blocks (Startblock von Intervallen) wiederherzustellen, indem Sie alle Intervalle dieses Blocks nacheinander hinzufügen. <br></p><p></p><p>  Um mit Bitfolgen zu arbeiten, wird eine 32-Bit-Ganzzahlvariable verwendet, in der die niedrigstwertigen Bits verarbeitet werden und nach deren Verwendung die Bits beim Packen nach links oder beim Entpacken nach rechts verschoben werden. <br></p><p></p><br><h4>  Blockstruktur </h4><br><p></p><p>  Zusätzlich zu Bitfolgen enthält ein Block Informationen, die zum Abrufen oder Hinzufügen von Bits sowie zum Bestimmen des Inhalts eines Blocks erforderlich sind. <br></p><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned int LONG; typedef unsigned long long HUGE; typedef int BOOL; #define TRUE 1 #define FALSE 0 #define BLOCKSIZE (256) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ :   , #define HEADSIZE (8+8+2+2+2) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   , #define BODYSIZE (BLOCKSIZE-HEADSIZE) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           typedef struct { HUGE base; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      HUGE card; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        WORD count; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      WORD delta; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ base+delta =      WORD offset; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        BYTE body[BODYSIZE]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } crunch_block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   put()  get() crunch_block block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ NB:  len/val</span></span>  rev/rel     /<span class="hljs-regexp"><span class="hljs-regexp">/  ,    ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . static struct tail_t { BYTE len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      S  A BYTE val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,   A  - S BYTE rev; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    BYTE rel; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } tails[6] = { { 4, 3, 2, 3 }, { 4, 7, 5, 3 }, { 3, 1, 0, 4 }, { 4,11, 1, 4 }, { 4,15, 3, 4 }, { 3, 5, 4, 4 } }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/             BOOL put(int gap) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1.      int Q, R, L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   (),  (),   int val = gap /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; Q = val / <span class="hljs-number"><span class="hljs-number">6</span></span>; R = val % <span class="hljs-number"><span class="hljs-number">6</span></span>; L = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .., <span class="hljs-number"><span class="hljs-number">0</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> val = Q + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (val) { val <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;= </span></span><span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/    L val = Q - (1 &lt;&lt; L) + 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  val &lt;&lt;= tails[R].len; val += tails[R].val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      val &lt;&lt;= L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   L += L + tails[R].len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2.   val  L   buffer   put_index if (block.offset + L &gt; BODYSIZE * 8) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ !      return FALSE; Q = (block.offset /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      R = block.offset % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.offset += L; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      block.count++; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.delta += gap; if (R &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/        { val &lt;&lt;= R; val |= block.body[Q]; L += R; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     L = L /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> + ((L % <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     while (L-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { block.body[Q++] = (char)val; val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } return TRUE; } /<span class="hljs-regexp"><span class="hljs-regexp">/          int get_index; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int get() { if (get_index &gt;= BODYSIZE * 8) return 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int val = *((int*)&amp;block.body[get_index /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>]) &gt;&gt; get_index % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>   if (val == <span class="hljs-number"><span class="hljs-number">0</span></span>) return -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> !       int Q, R, L, F, M, len; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> , , , ,     L = <span class="hljs-number"><span class="hljs-number">0</span></span>; while (!(val &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) { val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/  -     if ((val &amp; 3) == 1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       R = (val &gt;&gt; 2) &amp; 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   else R = ((val &gt;&gt; 2) &amp; 3) + 2; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   len = tails[R].rel; get_index += 2 * L + len; val &gt;&gt;= len; M = ((1 &lt;&lt; L) - 1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   F = val &amp; M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    Q = F + M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   return 2 * (1 + (6 * Q + tails[R].rev)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         }</span></span></code> </pre><br><p></p><br><h4>  Verbesserungen </h4><br><p></p><p>  Wenn wir die erhaltene Basis von Intervallen demselben 7-Zip-Archivierer zuführen, gelingt es ihm in anderthalb Stunden intensiver Arbeit auf einem 8-Core-Server, die Eingabedatei um fast 5% zu komprimieren.  Das heißt, in der Datenbank der Intervalle variabler Länge aus Sicht des Archivierers besteht immer noch eine gewisse Redundanz.  Es gibt also Grund, ein wenig (im guten Sinne des Wortes) über das Thema der weiteren Reduzierung der Datenredundanz zu spekulieren. <br></p><p></p><p>  Der fundamentale Determinismus der Folge von Intervallen zwischen Primzahlen ermöglicht es, die Codierungseffizienz mit der einen oder anderen Methode genau zu berechnen.  Insbesondere kleine (und eher chaotische) Skizzen ermöglichten es, eine grundlegende Schlussfolgerung über die Vorteile der Codierung von Sechsern gegenüber Tripeln und über die Vorteile der vorgeschlagenen Methode gegenüber trivialen Codes variabler Länge zu ziehen (Abb. 12): <br></p><br><p><br><img src="https://habrastorage.org/webt/w9/_l/9q/w9_l9qaibojgrxt5izuw4j7lxzc.jpeg" alt="Abb. 12"><br><br></p><br><p>  Die störenden Höhen des roten Diagramms deuten jedoch transparent darauf hin, dass es möglicherweise andere Codierungsmethoden gibt, die das Diagramm noch sanfter machen würden. <br></p><p></p><p>  Eine andere Richtung schlägt vor, die Häufigkeit aufeinanderfolgender Intervalle zu überprüfen.  Aus allgemeinen Überlegungen: Da die Intervalle 6, 12 und 18 in einer Population von Primzahlen am häufigsten vorkommen, werden sie wahrscheinlich häufiger in Paaren (Dubletts), Tripeln (Tripletts) und ähnlichen Intervallkombinationen gefunden.  Wenn sich herausstellt, dass die Wiederholbarkeit von Duplets (und vielleicht sogar Triplets ... nun, plötzlich!) In der Gesamtmasse der Intervalle statistisch signifikant ist, ist es sinnvoll, sie in einen separaten Code zu übersetzen. <br></p><p></p><p>  Das vollständige Experiment zeigt eine gewisse Vorherrschaft einzelner Dubletts gegenüber anderen.  Wenn jedoch die absolute Führung für das Paar erwartet wird <code>(6,6)</code> - 1,37% aller Dubletten -, dann sind die anderen Gewinner dieser Bewertung viel weniger offensichtlich: <br></p><p><br><img src="https://habrastorage.org/webt/4m/jq/o-/4mjqo-jyxt27cpw6e6bnasgxl0s.jpeg" alt="Dublettstatistik"><br><br></p><br><p>  Und da das Dublett <code>(6,6)</code> symmetrisch ist und alle anderen notierten Dubletts asymmetrisch sind und in der Rangfolge von Spiegelzwillingen mit derselben Häufigkeit gefunden werden, sollte der Datensatz des Dubletts <code>(6,6)</code> in dieser Reihe in zwei Hälften zwischen nicht unterscheidbaren Zwillingen <code>(6,6)</code> und <code>(6,6)</code> , womit sie 0,68% weit bis an den Rand der Preisliste reichen.  Und dies bestätigt erneut die Beobachtung, dass keine echten Vermutungen über Primzahlen ohne Überraschungen möglich sind. <br></p><p></p><p>  Die Statistik der Drillinge zeigt auch die Führung solcher Dreifachintervalle, die nicht ganz in die spekulative Annahme passen, die von der höchsten Häufigkeit der Intervalle 6, 12, 18 ausgeht. In abnehmender Reihenfolge der Popularität sehen die Frequenzleiter unter den Drillingen wie folgt aus: <br></p><p><br><img src="https://habrastorage.org/webt/nn/if/sw/nnifswq5tugkq5kypoe44qllyj4.jpeg" alt="dreifache Statistik"><br><br></p><p>  usw. <br></p><p></p><p>  Ich befürchte jedoch, dass die Ergebnisse meiner Spekulationen für Programmierer weniger interessant sein werden als für Mathematiker, möglicherweise aufgrund der unerwarteten Korrekturen, die durch die Praxis in intuitive Vermutungen vorgenommen wurden.  Es ist unwahrscheinlich, dass es möglich sein wird, eine wesentliche Dividende aus dem genannten Prozentsatz der Frequenz zugunsten einer weiteren Erhöhung des Kompressionsverhältnisses herauszuholen, während die Komplexität des Algorithmus sehr stark zu wachsen droht. <br></p><p></p><p></p><h4>  Einschränkungen </h4><br><p></p><p>  Es wurde bereits oben angemerkt, dass der Anstieg des Maximalwerts der Intervalle in Verbindung mit der Kapazität von Primzahlen sehr, sehr langsam ist.  Insbesondere ist aus Fig. 6 ersichtlich, dass das Intervall zwischen beliebigen Primzahlen, die im Format einer 64-Bit-Ganzzahl ohne Vorzeichen dargestellt werden können, offensichtlich weniger als 1600 beträgt. <br></p><p></p><p>  Mit der beschriebenen Implementierung können Sie alle 18-Bit-Intervallwerte korrekt verpacken und entpacken (tatsächlich tritt der erste Verpackungsfehler mit einem Eingabeintervall von 442358 auf).  Ich habe nicht genug Vorstellungskraft, um anzunehmen, dass die Datenbank der Primintervalle auf solche Werte anwachsen kann: Nebenbei sind es etwa 100-Bit-Ganzzahlen, und um die Faulheit genauer zu berechnen.  In einem Brandfall ist es nicht schwierig, den Intervallbereich zeitweise zu erweitern. <br></p><p></p><p>  Vielen Dank für das Lesen zu diesem Ort :) <br></p><br><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417753/">https://habr.com/ru/post/de417753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417743/index.html">Legendäre Verstärker - Historische Trendanatomie: Cold Transistor Sound</a></li>
<li><a href="../de417745/index.html">Persönliche Erfahrung: Data Engineering bei Upwork</a></li>
<li><a href="../de417747/index.html">Betreff: "Vergleich von JS-Frameworks: React, Vue und Hyperapp"</a></li>
<li><a href="../de417749/index.html">Project Loon als kommerzielles Projekt: Der erste Vertrag wird unterzeichnet</a></li>
<li><a href="../de417751/index.html">Kunstkamera: E-Meter - Scientology-Gerät zur Messung von Thetanen</a></li>
<li><a href="../de417755/index.html">Studie: 80% der ICOs 2017 gelten als betrügerisch</a></li>
<li><a href="../de417757/index.html">Erstellen eines Bots zur Teilnahme am AI Mini Cup. GPU-Erfahrung</a></li>
<li><a href="../de417759/index.html">Sei meine Gummiente</a></li>
<li><a href="../de417761/index.html">GitLab wechselt von Azure zur Google Cloud Platform. Umzugsnachrichten und Wartungstermine</a></li>
<li><a href="../de417763/index.html">MVIDroid: eine Überprüfung der neuen MVI-Bibliothek (Model-View-Intent)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>