<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóûÔ∏è üîá üë©üèº‚Äçüè≠ Komprimierung gro√üer Anordnungen von Primzahlen üéÇ üë¥üèæ üèáüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit den Eigenschaften von Primzahlen k√∂nnen Sie selten anders als in Form eines vorberechneten Arrays damit arbeiten - und vorzugsweise so umfangreich...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Komprimierung gro√üer Anordnungen von Primzahlen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417753/"><img src="https://habrastorage.org/webt/sr/yf/y8/sryfy8c2vpyfx-euoq7v_v3p_sa.jpeg" alt="Sandkasten" align="left"><br><p>  Mit den Eigenschaften von Primzahlen k√∂nnen Sie selten anders als in Form eines vorberechneten Arrays damit arbeiten - und vorzugsweise so umfangreich wie m√∂glich.  Das nat√ºrliche Speicherformat in Form von ganzen Zahlen mit der einen oder anderen Ziffernkapazit√§t leidet gleichzeitig an einigen Nachteilen, die mit dem Wachstum des Datenvolumens signifikant werden. <br></p><p></p><p>  Das Format von 16-Bit-Ganzzahlen ohne Vorzeichen mit der Gr√∂√üe einer solchen Tabelle betr√§gt also ungef√§hr 13 Kilobyte. Es enth√§lt nur 6542 Primzahlen: gefolgt von der Zahl 65531 sind die Werte f√ºr eine h√∂here Bittiefe.  Ein solcher Tisch ist nur als Spielzeug geeignet. <br></p><p></p><p>  Das beliebteste 32-Bit-Integer-Format in der Programmierung sieht viel solider aus - es erm√∂glicht Ihnen, etwa 203 Millionen einfache zu speichern.  Eine solche Tabelle belegt jedoch bereits etwa 775 Megabyte. <br></p><p></p><p>  Das 64-Bit-Format bietet noch mehr Perspektiven.  Mit einer theoretischen Potenz in der Gr√∂√üenordnung von 1e + 19 Werten h√§tte die Tabelle jedoch eine Gr√∂√üe von 64 Exabyte. <br></p><br><a name="habracut"></a><br><p></p><p>  Es wird nicht wirklich angenommen, dass unsere fortschrittliche Menschheit in absehbarer Zeit jemals eine Tabelle mit Primzahlen eines solchen Volumens berechnen wird.  Und hier geht es weniger um Volumen als um die Z√§hlzeit der verf√ºgbaren Algorithmen.  Wenn beispielsweise die Tabelle aller einfachen 32-Bit-Tabellen in wenigen Stunden noch unabh√§ngig berechnet werden kann (Abb. 1), dauert es mehrere Tage, bis die Tabelle um mindestens eine Gr√∂√üenordnung gr√∂√üer ist.  Aber solche B√§nde heute - das ist nur das Anfangsniveau. <br></p><br><br><img src="https://habrastorage.org/webt/ut/qn/gq/utqngqsvjfyolxj1afp9n--6jxw.jpeg" alt="Abb. 1"><br><br><p>  Wie aus dem Diagramm ersichtlich ist, geht die spezifische Berechnungszeit nach dem Startruck reibungslos in asymptotisches Wachstum √ºber.  Er ist ziemlich langsam.  Dies ist jedoch Wachstum, was bedeutet, dass das Mining aller n√§chsten Daten im Laufe der Zeit immer schwieriger wird.  Wenn Sie einen bedeutenden Durchbruch erzielen m√∂chten, m√ºssen Sie die Arbeit √ºber die Kerne hinweg parallelisieren (und sie l√§sst sich gut parallelisieren) und an Supercomputer h√§ngen.  Mit der Aussicht, die ersten 10 Milliarden einfach in einer Woche und 100 Milliarden - nur in einem Jahr - zu bekommen.  Nat√ºrlich gibt es schnellere Algorithmen zur einfachen Berechnung als die in meinen Hausaufgaben verwendete triviale B√ºste, aber im Wesentlichen √§ndert dies nichts an der Sache: Nach zwei oder drei Gr√∂√üenordnungen wird die Situation √§hnlich. <br></p><p></p><p>  Daher w√§re es sch√∂n, die Z√§hlarbeiten einmal durchgef√ºhrt zu haben, das Ergebnis in einer vorgefertigten tabellarischen Form zu speichern und bei Bedarf zu verwenden. <br></p><p></p><p>  Aufgrund der Offensichtlichkeit der Idee st√∂√üt das Netzwerk auf viele Links zu vorgefertigten Listen von Primzahlen, die bereits von jemandem berechnet wurden.  Leider sind sie in den meisten F√§llen nur f√ºr Studentenhandwerk geeignet: eines davon wandert beispielsweise von Ort zu Ort und umfasst 50 Millionen einfache.  Dieser Betrag kann nur Uneingeweihte in Erstaunen versetzen: Es wurde bereits oben erw√§hnt, dass Sie auf einem Heimcomputer in wenigen Stunden die Tabelle aller einfachen 32-Bit-Tabellen unabh√§ngig berechnen k√∂nnen und sie viermal gr√∂√üer ist.  Wahrscheinlich vor 15 bis 20 Jahren war eine solche Liste in der Tat eine heldenhafte Leistung f√ºr die Laiengemeinschaft.  Im Zeitalter von Multi-Core-Multi-Gigahertz- und Multi-Gigabyte-Ger√§ten ist dies heute nicht mehr beeindruckend. <br></p><p></p><p>  Ich hatte das Gl√ºck, den Zugang zu einer viel repr√§sentativeren Tabelle einfacher zu kennen, die ich weiter als Illustration und Opfer f√ºr meine Feldversuche verwenden werde.  Zum Zwecke der Verschw√∂rung werde ich sie <b>1TPrimo nennen</b> .  Es enth√§lt alle Primzahlen weniger als eine Billion. <br></p><p></p><p>  Am Beispiel von 1TPrimo ist leicht zu erkennen, mit welchen Volumes Sie umgehen m√ºssen.  Mit einer Kapazit√§t von rund 37,6 Milliarden Werten im 64-Bit-Integer-Format umfasst diese Liste 280 Gigabyte.  √úbrigens - der Teil davon, der in 32 Ziffern passen k√∂nnte, macht nur 0,5% der Anzahl der darin dargestellten Zahlen aus.  Dies macht absolut klar, dass jede ernsthafte Arbeit mit Primzahlen zwangsl√§ufig zu einer Gesamtbittiefe von 64 Bit (oder mehr) f√ºhrt. <br></p><p></p><p>  Somit ist die d√ºstere Tendenz offensichtlich: Eine irgendwie ernste Tabelle von Primzahlen hat unvermeidlich ein Titanvolumen.  Und wir m√ºssen das irgendwie bek√§mpfen. <br></p><p></p><p>  Das erste, was mir beim Betrachten einer Tabelle einf√§llt (Abb. 2), ist, dass sie aus nahezu identischen aufeinander folgenden Werten besteht, die sich nur in einer oder zwei der letzten Dezimalstellen unterscheiden: <br></p><br><p><br><img src="https://habrastorage.org/webt/y7/hk/f5/y7hkf5s75ii-jdujarftwhpd14i.jpeg" alt="Abb. 2"><br><br></p><br><p>  Einfach gesagt, aus den allgemeinsten, abstrakten √úberlegungen: Wenn die Datei viele doppelte Daten enth√§lt, sollte sie vom Archivierer gut komprimiert werden.  In der Tat ergab die Komprimierung der 1TPrimo-Tabelle mit dem beliebten 7-Zip-Dienstprogramm bei Standardeinstellungen ein ziemlich hohes Komprimierungsverh√§ltnis: 8,5.  Die Verarbeitungszeit auf einem 8-Core-Server mit einer durchschnittlichen Auslastung aller Kerne von etwa 80 bis 90% betrug - bei der enormen Gr√∂√üe der Quelltabelle - 14 Stunden und 12 Minuten.  Universelle Komprimierungsalgorithmen wurden f√ºr einige abstrakte, verallgemeinerte Vorstellungen von Daten entwickelt.  In einigen speziellen F√§llen k√∂nnen spezielle Komprimierungsalgorithmen, die auf den bekannten Merkmalen des eingehenden Datensatzes basieren, viel effektivere Indikatoren aufzeigen, denen diese Arbeit gewidmet ist.  Und wie effektiv es wird, wird unten deutlich. <br></p><p></p><p>  Die engen Zahlenwerte benachbarter Primzahlen erfordern eine Entscheidung, diese Werte nicht selbst zu speichern, sondern die Intervalle (Unterschiede) zwischen ihnen.  In diesem Fall k√∂nnen erhebliche Einsparungen erzielt werden, da die Bittiefe der Intervalle viel geringer ist als die Bittiefe der Anfangsdaten (Abb. 3). <br></p><br><p><br><img src="https://habrastorage.org/webt/7-/lk/ka/7-lkkafdhzaus8yglobx1t5t25w.jpeg" alt="Abb. 3"><br><br></p><br><p>  Und es scheint, dass es nicht von der Bittiefe der einfachen abh√§ngt, die das Intervall erzeugen.  Eine ersch√∂pfende Suche zeigt, dass typische Werte von Intervallen f√ºr Primzahlen, die von verschiedenen Stellen in der 1TPrimo-Tabelle stammen, innerhalb von Einheiten, Zehnern, manchmal Hunderten liegen und - als erster Arbeitssatz - wahrscheinlich in den Bereich von 8 Bit passen k√∂nnten Ganzzahlen ohne Vorzeichen, d. h. Bytes.  Dies w√§re sehr praktisch und w√ºrde im Vergleich zum 64-Bit-Format sofort zu einer 8-fachen Datenkomprimierung f√ºhren - nur irgendwo auf dem Niveau, das der 7-Zip-Archivierer demonstriert.  Dar√ºber hinaus sollte die Einfachheit der Komprimierungs- und Dekomprimierungsalgorithmen im Vergleich zu 7-zip im Prinzip einen gro√üen Einfluss auf die Geschwindigkeit der Komprimierung und den Zugriff auf Daten haben.  Klingt verlockend. <br></p><p></p><p>  Es ist absolut klar, dass die von ihren Absolutwerten in die relativen Intervalle zwischen ihnen konvertierten Daten nur zum Wiederherstellen einer Reihe von Werten geeignet sind, die vom Anfang der Prim√§rtabelle an in einer Reihe stehen.  Wenn wir einer solchen Intervalltabelle jedoch eine minimale Blockindexstruktur hinzuf√ºgen, k√∂nnen wir mit unbedeutenden zus√§tzlichen Gemeinkosten sowohl das Tabellenelement anhand seiner Nummer als auch das n√§chstgelegene Element anhand eines willk√ºrlich festgelegten Werts und diese Operationen zusammen mit der Hauptoperation wiederherstellen, jedoch bereits blockweise Sequenzbeispiele - im Allgemeinen ersch√∂pft es den L√∂wenanteil m√∂glicher Abfragen zu solchen Daten.  Die statistische Verarbeitung wird nat√ºrlich komplizierter, bleibt aber dennoch recht transparent  Es gibt keinen besonderen Trick, es "on the fly" aus den verf√ºgbaren Intervallen wiederherzustellen, wenn auf den erforderlichen Datenblock zugegriffen wird. <br></p><p></p><p>  Aber leider.  Ein einfaches numerisches Experiment mit 1TPrimo-Daten zeigt, dass bereits am Ende der dritten zehn Millionen (dies ist weniger als ein Hundertstel Prozent des 1TPrimo-Volumens) - und dann √ºberall sonst - die Intervalle zwischen benachbarten Primzahlen regelm√§√üig au√üerhalb des Bereichs von 0..255 liegen. <br></p><p></p><p>  Ein etwas kompliziertes numerisches Experiment zeigt jedoch, dass das Wachstum des maximalen Intervalls zwischen benachbarten Primzahlen mit dem Wachstum der Tabelle selbst sehr, sehr langsam ist - was bedeutet, dass die Idee in gewisser Weise immer noch gut ist. <br></p><p></p><p>  Der zweite, genauere Blick auf die Tabelle der Intervalle legt nahe, dass es m√∂glich ist, nicht den Unterschied selbst, sondern seine H√§lfte zu speichern.  Da alle Primzahlen gr√∂√üer als 2 offensichtlich ungerade sind, sind ihre Unterschiede offensichtlich gerade.  Dementsprechend k√∂nnen die Differenzen ohne Wertverlust um 2 reduziert werden;  und der Vollst√§ndigkeit halber kann man auch eins vom erhaltenen Quotienten subtrahieren, um den Nullwert, der nicht anders beansprucht wurde, sinnvoll zu verwenden (Fig. 4).  Eine solche Verringerung der Intervalle wird im Folgenden als monolithisch bezeichnet, im Gegensatz zu der losen, por√∂sen Ausgangsform, bei der sich herausstellte, dass alle ungeraden Werte und Null nicht beansprucht wurden. <br></p><br><p><br><img src="https://habrastorage.org/webt/ix/ob/fp/ixobfp-kfzmw2gkwjrkkmwcfxn4.jpeg" alt="Abb. 4"><br><br></p><br><p>  Es ist zu beachten, dass, da das Intervall zwischen den ersten beiden einfachen (2 und 3) nicht in dieses Schema passt, 2 aus der Intervalltabelle ausgeschlossen werden muss und diese Tatsache die ganze Zeit ber√ºcksichtigt wird. <br></p><p></p><p>  Mit dieser einfachen Technik k√∂nnen Sie Intervalle von 2 bis 512 im Wertebereich 0..255 codieren. Wieder einmal wird die Hoffnung lebendig, dass die Differenzmethode es uns erm√∂glicht, eine viel leistungsf√§higere Folge von Primzahlen zu packen.  Und das zu Recht: Ein Lauf von 37,6 Milliarden Werten in der 1TPrimo-Liste ergab nur 6 (sechs!) Intervalle, die nicht im Bereich von 2..512 liegen. <br></p><p></p><p>  Aber das waren gute Nachrichten;  Das Schlimme ist, dass diese sechs Intervalle ziemlich frei √ºber die Liste verteilt sind und das erste bereits am Ende des ersten Drittels der Liste auftritt, wodurch die verbleibenden zwei Drittel zu Ballast werden, der f√ºr diese Komprimierungsmethode ungeeignet ist (Abb. 5): <br></p><br><p><br><img src="https://habrastorage.org/webt/k_/0y/aw/k_0yaw46rbatmne64qzj0vp9mus.jpeg" alt="Abb. 5"><br><br></p><br><p>  Solch ein Flush (einige ungl√ºckliche sechs St√ºcke f√ºr fast vierzig Milliarden! - und auf Sie ...) sogar mit einer Fliege in der Salbe zum Vergleich - um die Ehre des Teers zu zeigen.  Aber leider ist dies ein Muster, kein Unfall.  Wenn wir das erste Auftreten von Intervallen zwischen Primzahlen in Abh√§ngigkeit von der Datenl√§nge verfolgen, wird klar, dass dieses Ph√§nomen in der Genetik von Primzahlen liegt, obwohl es extrem langsam fortschreitet (Abb. 6 *). <br></p><br><p><br><img src="https://habrastorage.org/webt/sj/c_/ah/sjc_ah1hgw7ud9xewa3_s47edhq.jpeg" alt="Abb. 6"><br><br></p><br><p>  * Zeitplan zusammengestellt nach dem thematischen Ort von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thomas R. Nisley</a> , <br>  Dies sind mehrere Gr√∂√üenordnungen besser als die Leistung der 1TPrimo-Liste </p><br><p></p><p>  Aber auch dieser sehr langsame Fortschritt deutet eindeutig an: Man kann sich auf eine bestimmte vorgegebene Bittiefe eines Intervalls nur bei einer bestimmten vorgegebenen Potenz der Liste beschr√§nken.  Das hei√üt, es ist nicht als universelle L√∂sung geeignet. <br></p><p></p><p>  Die Tatsache, dass Sie mit der vorgeschlagenen Methode zum Komprimieren einer Folge von Primzahlen eine einfache kompakte Tabelle mit einer Kapazit√§t von fast 12 Milliarden Werten implementieren k√∂nnen, ist jedoch bereits ein gutes Ergebnis.  Eine solche Tabelle belegt ein Volumen von 11,1 Gigabyte - gegen√ºber 89,4 Gigabyte in einem trivialen 64-Bit-Format.  Sicherlich kann f√ºr eine Reihe von Anwendungen eine solche L√∂sung ausreichend sein. <br></p><p></p><p>  Und was interessant ist: Das Verfahren zum √úbersetzen einer 64-Bit-1TPrimo-Tabelle in das Format von 8-Bit-Intervallen mit einer Blockstruktur unter Verwendung nur eines Prozessorkerns (f√ºr die Parallelisierung m√ºssten Sie auf eine erhebliche Komplikation des Programms zur√ºckgreifen, und es hat sich absolut nicht gelohnt) und nicht mehr als 5 % der Prozessorlast (die meiste Zeit f√ºr Dateivorg√§nge) dauerte nur 19 Minuten. Gegen - ich erinnere mich - 14 Stunden auf acht Kernen bei 80-90% der vom 7-Zip-Archivierer aufgewendeten Last. <br></p><p></p><p>  Nat√ºrlich wurde nur das erste Drittel der Tabelle dieser √úbersetzung unterzogen, bei der der Intervallbereich 512 nicht √ºberschreitet. Wenn wir also die vollen 14 Stunden auf dasselbe Drittel bringen, sollten 19 Minuten mit fast 5 Stunden des 7-Zip-Archivierers verglichen werden.  Bei einer vergleichbaren Komprimierung (8 und 8,5) betr√§gt der Unterschied etwa das 15-fache.  Wenn man bedenkt, dass der L√∂wenanteil der Arbeitszeit des Rundfunkprogramms durch Dateivorg√§nge belegt war, w√§re der Unterschied auf einem schnelleren Festplattensystem noch gr√∂√üer.  Und intellektuell sollte die Betriebszeit von 7-zip auf acht Kernen immer noch auf einem Thread gez√§hlt werden, und dann wird der Vergleich wirklich angemessen. <br></p><p></p><p>  Die Auswahl aus einer solchen Datenbank unterscheidet sich zeitlich kaum von der Auswahl aus der Tabelle der entpackten Daten und wird fast ausschlie√ülich durch den Zeitpunkt der Dateivorg√§nge bestimmt.  Die spezifischen Zahlen h√§ngen stark von der spezifischen Hardware ab. Auf meinem Server dauerte der Zugriff auf einen beliebigen Datenblock durchschnittlich 37,8 Œºs, w√§hrend das sequentielle Lesen von Bl√∂cken - 4,2 Œºs pro Block, zum vollst√§ndigen Entpacken des Blocks - weniger als 1 Œºs betrug.  Das hei√üt, es macht keinen Sinn, die Dekomprimierung von Daten mit der Arbeit eines Standardarchivierers zu vergleichen.  Und das ist ein gro√ües Plus. <br></p><p></p><p>  Und schlie√ülich bieten die Beobachtungen eine weitere dritte L√∂sung, mit der alle Einschr√§nkungen der Datenleistung beseitigt werden: Codierungsintervalle mit Werten variabler L√§nge.  Diese Technik ist seit langem in kompressionsbezogenen Anwendungen weit verbreitet.  Seine Bedeutung ist, dass, wenn in der Eingabe festgestellt wird, dass einige Werte h√§ufig gefunden werden, einige weniger h√§ufig sind und einige sehr selten sind, wir den ersten mit Funktionscodes, den zweiten mit authentischeren Codes und den dritten codieren k√∂nnen - sehr lang (vielleicht sogar sehr lang, weil es keine Rolle spielt: Trotzdem sind solche Daten sehr selten).  Infolgedessen kann die Gesamtl√§nge der empfangenen Codes viel k√ºrzer als die Eingabedaten sein. <br></p><p></p><p>  Wenn wir uns bereits die grafische Darstellung des Erscheinungsbilds der Intervalle in Abb. 7 ansehen, k√∂nnen wir davon ausgehen, dass die Intervalle 2, 4, 6 usw. sind.  erscheinen fr√ºher als Intervalle, z. B. 100, 102, 104 usw., dann sollte das erstere weiterhin viel h√§ufiger auftreten als das letztere.  Und umgekehrt - wenn die Intervalle 514 erst bei 11,99 Milliardstel, 516 - ab 16,2 Milliardstel und 518 - im Allgemeinen erst bei 87,7 Milliardstel auftreten, werden sie sehr selten auftreten.  Das hei√üt, a priori k√∂nnen wir die umgekehrte Beziehung zwischen der Gr√∂√üe des Intervalls und seiner H√§ufigkeit in einer Folge von Primzahlen annehmen.  Und das bedeutet - Sie k√∂nnen eine einfache Struktur erstellen, die Codes variabler L√§nge f√ºr sie implementiert. <br></p><p></p><p>  Nat√ºrlich sollten Statistiken √ºber die H√§ufigkeit von Intervallen f√ºr die Wahl einer bestimmten Codierungsmethode entscheidend sein.  Gl√ºcklicherweise ist im Gegensatz zu willk√ºrlichen Daten die H√§ufigkeit von Intervallen zwischen Primzahlen - die an sich ein f√ºr alle Mal streng bestimmt sind - auch ein genau bestimmtes, ein f√ºr alle Mal definiertes Merkmal. <br></p><p></p><p>  Abbildung 7 zeigt den Frequenzgang der Intervalle f√ºr die gesamte 1TPrimo-Liste: <br></p><br><p><br><img src="https://habrastorage.org/webt/7q/ga/ii/7qgaii-1mwxlmuvicojaklwrbuk.jpeg" alt="Abb. 7"><br><br></p><br><p>  Hier muss noch einmal erw√§hnt werden, dass das Intervall zwischen den allerersten Primzahlen 2 und 3 aus dem Diagramm ausgeschlossen ist: Dieses Intervall ist 1 und tritt unabh√§ngig von der Potenz der Liste genau einmal in der Folge von Primzahlen auf.  Dieses Intervall ist so eigenartig, dass es einfacher ist, 2 aus der Liste der einfachen zu entfernen, als st√§ndig zu Reservierungen abzuweichen.  Die Sim wird als <b>virtuelle Primzahl</b> deklariert: Sie ist in den Listen nicht sichtbar, aber vorhanden.  Wie dieser Gopher. <br></p><p></p><p>  Auf den ersten Blick best√§tigt der Frequenzgraph die in einigen Abs√§tzen oben genannte a priori-Annahme vollst√§ndig.  Es zeigt deutlich die statistische Heterogenit√§t der Intervalle und die hohe H√§ufigkeit kleiner Werte im Vergleich zu gro√üen.  In der zweiten, konvexeren Ansicht erweist sich die Grafik jedoch als viel interessanter (Abb. 8): <br></p><br><p><br><img src="https://habrastorage.org/webt/qm/4_/xu/qm4_xuzdshet30cdd9ucm7t4q0m.jpeg" alt="Abb. 8"><br><br></p><br><p>  Ganz unerwartet stellt sich heraus, dass die h√§ufigsten Intervalle nicht 2 und 4 sind, wie es aus allgemeinen √úberlegungen zu sein schien, sondern 6, 12 und 18, gefolgt von 10 - und erst dann 2 und 4 mit nahezu gleicher H√§ufigkeit (Unterschied in 7 Ziffern) nach dem Dezimalpunkt).  Dar√ºber hinaus wird die Vielzahl der Spitzenwerte der Zahl 6 im gesamten Diagramm verfolgt. <br></p><p></p><p>  Noch interessanter ist, dass diese versehentlich aufgedeckte Natur des Graphen universell ist - und in allen Details mit all ihren Knicken - √ºber die gesamte Folge einfacher Intervalle, die durch die 1TPrimo-Liste dargestellt werden, wahrscheinlich f√ºr jede Folge einfacher Intervalle universell ist (nat√ºrlich Eine solch k√ºhne Aussage bedarf eines Beweises, den ich mit gro√üer Freude auf die Schultern von Spezialisten f√ºr Zahlentheorie √ºbertrage.  Abbildung 10 zeigt einen Vergleich der vollst√§ndigen Intervallstatistik (scharlachrote Linie) mit Stichproben mit begrenztem Intervall, die an mehreren beliebigen Stellen in der 1TPrimo-Liste (Linien anderer Farben) entnommen wurden: <br></p><br><p><br><img src="https://habrastorage.org/webt/xs/jk/hd/xsjkhdqm8aztn2qztye3ftpf0yw.jpeg" alt="Abb. 9"><br></p><br><p>  Aus dieser Grafik ist ersichtlich, dass sich alle diese Proben genau wiederholen, mit nur einem geringen Unterschied im linken und rechten Teil der Figur: Sie scheinen leicht gegen den Uhrzeigersinn um den Intervallpunkt mit einem Wert von 24 gedreht zu sein. Diese Drehung ist wahrscheinlich auf die Tatsache zur√ºckzuf√ºhren, dass die h√∂here links Teile der Grafik basieren auf Samples mit geringerer Bittiefe.  In solchen Samples gibt es noch gar keine oder gro√üe Intervalle sind selten, die in Samples mit h√∂heren Bittiefen h√§ufig auftreten.  Dementsprechend spricht ihre Abwesenheit f√ºr die H√§ufigkeit von Intervallen mit niedrigeren Werten.  In Samples mit h√∂heren Bittiefen erscheinen viele neue Intervalle mit gro√üen Werten, daher nimmt die H√§ufigkeit kleinerer Intervalle geringf√ºgig ab.  H√∂chstwahrscheinlich verschiebt sich der Drehpunkt mit zunehmender Leistung der Liste in Richtung gr√∂√üerer Werte.  Irgendwo daneben befindet sich der Gleichgewichtspunkt des Graphen, an dem die Summe aller Werte auf der rechten Seite ungef√§hr gleich der Summe aller Werte auf der linken Seite ist. <br></p><p></p><p>  Diese interessante Natur der H√§ufigkeit von Intervallen legt nahe, die triviale Struktur von Codes variabler L√§nge aufzugeben.  Typischerweise besteht eine solche Struktur aus einem Paket von Bits verschiedener L√§ngen und Zwecke.  Zum Beispiel kommt zuerst eine bestimmte Anzahl von Pr√§fixbits, die auf einen bestimmten Wert gesetzt sind, zum Beispiel 0. Dahinter befindet sich ein Stoppbit, das die Vervollst√§ndigung des Pr√§fixes anzeigen und dementsprechend vom Pr√§fix abweichen sollte: 1 in diesem Fall.  Das Pr√§fix darf keine L√§nge haben, dh immer wieder kann die Abtastung sofort mit einem Stoppbit beginnen, wodurch die k√ºrzeste Sequenz bestimmt wird.  Auf das Stoppbit folgt normalerweise ein Suffix, dessen L√§nge in gewisser Weise durch die L√§nge des Pr√§fixes bestimmt wird.      ,       ,      ‚Äî        .      ,        -  .    -    (, , - )  ,          . <br></p><p></p><p>              ,   . <br></p><p></p><p> Und hier sollte noch etwas Wichtiges gesagt werden.  Auf den ersten Blick impliziert die beobachtete Zyklizit√§t die Aufteilung der Intervalle in Tripel: <code>{2,4, <b>6</b> }</code> , <code>{8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> }</code> usw. (die Werte mit der maximalen H√§ufigkeit in jedem Tripel sind fett markiert). .  Tats√§chlich ist der Zyklus hier jedoch etwas anders. <br></p><p></p><p>  Ich werde nicht die ganze Argumentationslinie zitieren, die in der Tat nicht vorhanden ist: Es war eine intuitive Vermutung, erg√§nzt durch eine Methode zur stumpfen Aufz√§hlung von Optionen, Berechnungen und Stichproben, die zeitweise mehrere Tage dauerte.  Die als Ergebnis offenbarte Zyklizit√§t besteht aus <b>sechs</b> Intervallen <code>{2,4, <b>6</b> ,8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> ,20,22, <b>24</b> }</code> , <code>{26,28, <b>30</b> ,32,34, <b>36</b> }</code> und usw. (Intervalle mit maximaler Frequenz sind wieder fett hervorgehoben). <br></p><p></p><p>  Kurz gesagt, der vorgeschlagene Verpackungsalgorithmus lautet wie folgt. <br></p><p></p><p>  Durch Teilen der Intervalle in Sechser mit geraden Zahlen k√∂nnen wir jedes Intervall <code>g</code> in der Form <code>g = i * 12 + t</code> , wobei <code>i</code> der Index der Sechs ist, zu denen dieses Intervall geh√∂rt ( <code>i = {0,1,2,3, ...}</code> ) und <code>t</code> ist ein Schwanz, der einen der Werte aus einem fest definierten, begrenzten und identischen Wert f√ºr sechs der Menge darstellt <code>{2,4,6,8,10,12}</code> .  Der Frequenzgang des oben hervorgehobenen Index ist fast genau umgekehrt proportional zu seinem Wert. Daher ist es logisch, den Sechs-Index in eine triviale Struktur eines Codes variabler L√§nge umzuwandeln, f√ºr die oben ein Beispiel angegeben ist.  Die Frequenzcharakteristik des Endes erm√∂glicht es Ihnen, ihn in zwei Gruppen zu unterteilen, die mit Bitketten unterschiedlicher L√§nge codiert werden k√∂nnen: Die am h√§ufigsten gefundenen Werte 6 und 12 werden mit einem Bit codiert, die Werte 2, 4, 8 und 10, die viel seltener auftreten, werden mit zwei Bits codiert.  Nat√ºrlich wird ein weiteres Bit ben√∂tigt, um zwischen diesen beiden Optionen zu unterscheiden. <br></p><p></p><p>  Ein Array, das Bitpakete enth√§lt, wird durch feste Felder erg√§nzt, die die Startwerte der im Block dargestellten Daten angeben, sowie durch andere Gr√∂√üen, die erforderlich sind, um eine beliebige einfache oder eine Folge einfacher aus den im Block gespeicherten Intervallen wiederherzustellen. <br></p><p></p><p>  Zus√§tzlich zu dieser Blockindexstruktur wird die Verwendung von Codes variabler L√§nge durch die zus√§tzlichen Kosten im Vergleich zu Intervallen mit festen Bits erschwert. <br></p><p></p><p>  Bei Verwendung von Intervallen fester Gr√∂√üe ist das Bestimmen des Blocks, in dem nach einer Primzahl gesucht werden soll, anhand seiner Seriennummer eine ziemlich einfache Aufgabe, da die Anzahl der Intervalle pro Block im Voraus bekannt ist.  Die Suche nach einer einfachen L√∂sung zum n√§chstgelegenen Wert hat jedoch keine direkte L√∂sung.  Alternativ k√∂nnen Sie eine empirische Formel verwenden, mit der Sie die ungef√§hre Blocknummer mit dem erforderlichen Intervall ermitteln k√∂nnen. Danach m√ºssen Sie durch umfassende Suche nach dem gew√ºnschten Block suchen. <br></p><p></p><p>  F√ºr eine Tabelle mit Codes variabler L√§nge ist f√ºr beide Aufgaben der gleiche Ansatz erforderlich: sowohl zum Abrufen eines Werts nach Zahlen als auch zum Suchen nach Werten.  Da die L√§nge der Codes variiert, ist nie vorher bekannt, wie viele Unterschiede in einem bestimmten Block gespeichert sind und in welchem ‚Äã‚ÄãBlock der gew√ºnschte Wert liegt.  Es wurde experimentell festgestellt, dass mit einer Blockgr√∂√üe von 512 Bytes (einschlie√ülich einiger Header-Bytes) die Blockkapazit√§t bis zu 10-12 Prozent des Durchschnittswerts betragen kann.  Kleinere Bl√∂cke ergeben eine noch gr√∂√üere relative Streuung.  Gleichzeitig neigt der Durchschnittswert der Blockkapazit√§t selbst dazu, langsam zu sinken, wenn die Tabelle w√§chst.  Die Auswahl empirischer Formeln zur ungenauen Bestimmung des Anfangsblocks zur Suche nach dem gew√ºnschten Wert sowohl nach Anzahl als auch nach Wert ist keine triviale Aufgabe.  Alternativ k√∂nnen Sie eine komplexere und komplexere Indizierung verwenden. <br></p><p></p><p>  Das ist in der Tat alles. <br></p><p></p><p>  Im Folgenden werden die Feinheiten der Komprimierung einer Prim√§rtabelle unter Verwendung von Codes variabler L√§nge und die damit verbundenen Strukturen auf formellere und detailliertere Weise beschrieben, und der Code f√ºr die Funktionen des Packens und Entpackens von Intervallen in C wird angegeben. <br></p><p></p><p>  Das Ergebnis. <br></p><p></p><p>  Die Datenmenge, die aus Tabelle 1TPrimo in Codes variabler L√§nge √ºbersetzt wurde, erg√§nzt durch eine Blockindexstruktur, die ebenfalls nachstehend beschrieben wird, betrug 26.309.295.104 Bytes (24,5 GB), dh das Komprimierungsverh√§ltnis erreicht 11,4.  Offensichtlich nimmt mit zunehmender Bittiefe das Kompressionsverh√§ltnis zu. <br></p><p></p><p>  Die Sendezeit von 280 GB 1TPrimo-Tabelle im neuen Format betrug 1 Stunde.  Dies ist das erwartete Ergebnis nach Experimenten mit Packungsintervallen in Einzelbyte-Ganzzahlen.  In beiden F√§llen besteht die √úbersetzung der Quelltabelle haupts√§chlich aus Dateioperationen und l√§dt den Prozessor fast nicht (im zweiten Fall ist die Last aufgrund der h√∂heren Rechenkomplexit√§t des Algorithmus immer noch h√∂her).  Die Datenzugriffszeit unterscheidet sich auch nicht sehr von Einzelbyte-Intervallen, aber die Zeit zum Entpacken eines vollst√§ndigen Blocks derselben Gr√∂√üe dauerte aufgrund der h√∂heren Komplexit√§t des Algorithmus zum Extrahieren von Codes variabler L√§nge 1,5 Œºs. <br></p><p></p><p>  Die Tabelle (Abb. 10) fasst die volumetrischen Eigenschaften der in diesem Text genannten Primzahlentabellen zusammen. <br></p><br><p><br><img src="https://habrastorage.org/webt/dc/jw/6o/dcjw6oz2efm88nqvzolxsz7mx6m.jpeg" alt="Abb. 10"></p><br><p></p><p><br></p><h3>  Beschreibung des Komprimierungsalgorithmus </h3><br><h4>  Bedingungen und Notation </h4><br>  <code>P (prime): P1=3, P2=5, P3=7 ... Pn, Pn1</code> sind Primzahlen gem√§√ü ihrer Seriennummer.  Noch einmal (und zum letzten Mal) betone ich, dass <code>P0=2</code> eine virtuelle Primzahl ist;  Aus Gr√ºnden der formalen Einheitlichkeit wird diese Zahl physisch von der Liste der Primzahlen ausgeschlossen. <br><p></p><p>  <code>G (gap)</code> - das Intervall zwischen zwei aufeinanderfolgenden Primzahlen <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code>  <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code> . <br></p><p></p><p>  <code>D (dense)</code> - reduziert auf ein monolithisches Formintervall: <code>D = G/2 -1; D={0,1,2,3 ...}</code>  <code>D = G/2 -1; D={0,1,2,3 ...}</code> .  Die sechs Intervalle in der monolithischen Form sehen aus wie <code>{0,1,2,3,4,5}, {6,7,8,9,10,11}, {12,13,14,15,16,17}</code> usw. <br></p><p></p><p>  <code>Q (quotient)</code> - Index der sechs auf eine monolithische Form reduziert, <code>Q = D div 6; Q={0,1,2,3 ...}</code> <code>Q = D div 6; Q={0,1,2,3 ...}</code> <br></p><p></p><p>  <code>R (remainder)</code> - der Rest der monolithischen sechs <code>R = D mod 6. R</code> immer einen Wert im Bereich <code>{0,1,2,3,4,5}</code> . <br></p><p></p><p>  Die <code>Q</code> und <code>R</code> Werte, die durch das obige Verfahren aus einem beliebigen Intervall <code>G</code> aufgrund ihrer stabilen Frequenzeigenschaften erhalten werden, unterliegen einer Komprimierung und Speicherung in Form von Bitpaketen variabler L√§nge, die nachstehend beschrieben werden.  Die Bitfolgen, die die Werte von <code>Q</code> und <code>R</code> in einem Paket codieren, werden auf verschiedene Arten erzeugt: Zum Codieren des <code>Q</code> Index wird die Bitkette des Pr√§fixes <code>H</code> , des Flusses <code>F</code> und des Hilfsbits <code>S</code> , und die Bitgruppe des Infix <code>X</code> und des Hilfsbits <code>A</code> werden verwendet, um den Rest <code>R</code> zu codieren <code>R</code> <br></p><p></p><p>  <code>A (arbiter)</code> - ein Bit, das die Gr√∂√üe des Infix <code>X</code> : 0 - Ein-Bit-Infix, 1 - Zwei-Bit. <br></p><p></p><p>  <code>X (infix)</code> - 1- oder 2-Bit-Infix zusammen mit dem Arbiter-Bit <code></code> , das den Wert von <code>R</code> tabellarisch gegenseitig bestimmt (die Tabelle zeigt auch die H√§ufigkeit der ersten sechs mit solchen Infixen als Referenz): <br></p><br><p><br><img src="https://habrastorage.org/webt/kp/hk/a4/kphka4ymveajnxr8icfzgggln4e.jpeg" alt="Infix-Bits"><br><br></p><br><p>  <code>F (fluxion)</code> ist ein Fluxion, eine Ableitung des Index <code>Q</code> variabler L√§nge <code>L={0,1,2...}</code> , der zur Unterscheidung zwischen der Semantik von Bitfolgen <code>(), 0, 00, 000,</code> oder <code>1, 01, 001</code> usw. dient. d. <br></p><p></p><p>  Eine Bitkette von Einheiten der L√§nge <code>L</code> wird ausgedr√ºckt als <code>2^L - 1</code> (das Vorzeichen <code>^</code> bedeutet Exponentiation).  In der C-Notation kann der gleiche Wert durch den Ausdruck <code>1&lt;&lt;L - 1</code> .  Dann kann der Wert der Fluxia der L√§nge <code>L</code> <code>Q</code> Ausdruck aus <code>Q</code> <br></p><p></p><p></p><pre> F = Q - (1 &lt;&lt; L - 1),
</pre><p></p><p>  und <code>Q</code> aus Fluxia durch Ausdruck wiederherstellen <br></p><p></p><p></p><pre> Q = (1 &lt;&lt; L - 1) + F.
</pre><p></p><p>  Beispielsweise werden f√ºr die Gr√∂√üen <code>Q = {0..15}</code> die folgenden Fluxia-Bitketten erhalten: <br></p><br><p><br><img src="https://habrastorage.org/webt/j0/kb/4y/j0kb4y3ob_yutugxxvpwlddqofc.jpeg" alt="Flussbits"><br><br></p><br><p>  Die letzten beiden Bitfelder, die zum Packen / Wiederherstellen von Werten erforderlich sind, sind: <br></p><p></p><p>  <code>H (header)</code> - Pr√§fix, eine auf 0 gesetzte Bitfolge. <br></p><p></p><p>  <code>S (stop)</code> - Stoppbit auf 1 gesetzt, wodurch das Pr√§fix beendet wird. <br></p><p></p><p>  Tats√§chlich werden diese Bits zuerst in Bitfolgen verarbeitet. Sie erm√∂glichen es Ihnen, beim Entpacken oder beim Packen die Gr√∂√üe des Flusses und den Beginn der Arbiter- und Flussfelder zu bestimmen - unmittelbar nach dem Stoppbit. <br></p><p></p><p>  <code>W (width)</code> - die Breite des gesamten Codes in Bits. <br></p><p></p><p>  Die vollst√§ndige Struktur des Bitpakets ist in Fig. 11 gezeigt: <br></p><br><p><br><img src="https://habrastorage.org/webt/ke/7u/tz/ke7utzoka0xkdd9dzzux6yden7e.jpeg" alt="Abb. 11"><br><br></p><br><p>  Die aus diesen Ketten wiederhergestellten Werte von <code>Q</code> und <code>R</code> erm√∂glichen es uns, den Anfangswert des Intervalls wiederherzustellen: <br></p><p></p><p></p><pre> D = Q * 6 + R,
 G = (D + 1) * 2,
</pre><p></p><p>  und die Folge von wiederhergestellten Intervallen erm√∂glicht es Ihnen, die urspr√ºnglichen Primzahlen von einem gegebenen Basiswert des Blocks (Startblock von Intervallen) wiederherzustellen, indem Sie alle Intervalle dieses Blocks nacheinander hinzuf√ºgen. <br></p><p></p><p>  Um mit Bitfolgen zu arbeiten, wird eine 32-Bit-Ganzzahlvariable verwendet, in der die niedrigstwertigen Bits verarbeitet werden und nach deren Verwendung die Bits beim Packen nach links oder beim Entpacken nach rechts verschoben werden. <br></p><p></p><br><h4>  Blockstruktur </h4><br><p></p><p>  Zus√§tzlich zu Bitfolgen enth√§lt ein Block Informationen, die zum Abrufen oder Hinzuf√ºgen von Bits sowie zum Bestimmen des Inhalts eines Blocks erforderlich sind. <br></p><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned int LONG; typedef unsigned long long HUGE; typedef int BOOL; #define TRUE 1 #define FALSE 0 #define BLOCKSIZE (256) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ :   , #define HEADSIZE (8+8+2+2+2) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   , #define BODYSIZE (BLOCKSIZE-HEADSIZE) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           typedef struct { HUGE base; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      HUGE card; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        WORD count; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      WORD delta; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ base+delta =      WORD offset; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        BYTE body[BODYSIZE]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } crunch_block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   put()  get() crunch_block block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ NB:  len/val</span></span>  rev/rel     /<span class="hljs-regexp"><span class="hljs-regexp">/  ,    ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . static struct tail_t { BYTE len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      S  A BYTE val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,   A  - S BYTE rev; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    BYTE rel; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } tails[6] = { { 4, 3, 2, 3 }, { 4, 7, 5, 3 }, { 3, 1, 0, 4 }, { 4,11, 1, 4 }, { 4,15, 3, 4 }, { 3, 5, 4, 4 } }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/             BOOL put(int gap) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1.      int Q, R, L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   (),  (),   int val = gap /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; Q = val / <span class="hljs-number"><span class="hljs-number">6</span></span>; R = val % <span class="hljs-number"><span class="hljs-number">6</span></span>; L = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .., <span class="hljs-number"><span class="hljs-number">0</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> val = Q + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (val) { val <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;= </span></span><span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/    L val = Q - (1 &lt;&lt; L) + 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  val &lt;&lt;= tails[R].len; val += tails[R].val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      val &lt;&lt;= L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   L += L + tails[R].len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2.   val  L   buffer   put_index if (block.offset + L &gt; BODYSIZE * 8) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ !      return FALSE; Q = (block.offset /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      R = block.offset % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.offset += L; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      block.count++; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.delta += gap; if (R &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/        { val &lt;&lt;= R; val |= block.body[Q]; L += R; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     L = L /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> + ((L % <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     while (L-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { block.body[Q++] = (char)val; val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } return TRUE; } /<span class="hljs-regexp"><span class="hljs-regexp">/          int get_index; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int get() { if (get_index &gt;= BODYSIZE * 8) return 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int val = *((int*)&amp;block.body[get_index /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>]) &gt;&gt; get_index % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>   if (val == <span class="hljs-number"><span class="hljs-number">0</span></span>) return -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> !       int Q, R, L, F, M, len; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> , , , ,     L = <span class="hljs-number"><span class="hljs-number">0</span></span>; while (!(val &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) { val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/  -     if ((val &amp; 3) == 1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       R = (val &gt;&gt; 2) &amp; 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   else R = ((val &gt;&gt; 2) &amp; 3) + 2; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   len = tails[R].rel; get_index += 2 * L + len; val &gt;&gt;= len; M = ((1 &lt;&lt; L) - 1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   F = val &amp; M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    Q = F + M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   return 2 * (1 + (6 * Q + tails[R].rev)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         }</span></span></code> </pre><br><p></p><br><h4>  Verbesserungen </h4><br><p></p><p>  Wenn wir die erhaltene Basis von Intervallen demselben 7-Zip-Archivierer zuf√ºhren, gelingt es ihm in anderthalb Stunden intensiver Arbeit auf einem 8-Core-Server, die Eingabedatei um fast 5% zu komprimieren.  Das hei√üt, in der Datenbank der Intervalle variabler L√§nge aus Sicht des Archivierers besteht immer noch eine gewisse Redundanz.  Es gibt also Grund, ein wenig (im guten Sinne des Wortes) √ºber das Thema der weiteren Reduzierung der Datenredundanz zu spekulieren. <br></p><p></p><p>  Der fundamentale Determinismus der Folge von Intervallen zwischen Primzahlen erm√∂glicht es, die Codierungseffizienz mit der einen oder anderen Methode genau zu berechnen.  Insbesondere kleine (und eher chaotische) Skizzen erm√∂glichten es, eine grundlegende Schlussfolgerung √ºber die Vorteile der Codierung von Sechsern gegen√ºber Tripeln und √ºber die Vorteile der vorgeschlagenen Methode gegen√ºber trivialen Codes variabler L√§nge zu ziehen (Abb. 12): <br></p><br><p><br><img src="https://habrastorage.org/webt/w9/_l/9q/w9_l9qaibojgrxt5izuw4j7lxzc.jpeg" alt="Abb. 12"><br><br></p><br><p>  Die st√∂renden H√∂hen des roten Diagramms deuten jedoch transparent darauf hin, dass es m√∂glicherweise andere Codierungsmethoden gibt, die das Diagramm noch sanfter machen w√ºrden. <br></p><p></p><p>  Eine andere Richtung schl√§gt vor, die H√§ufigkeit aufeinanderfolgender Intervalle zu √ºberpr√ºfen.  Aus allgemeinen √úberlegungen: Da die Intervalle 6, 12 und 18 in einer Population von Primzahlen am h√§ufigsten vorkommen, werden sie wahrscheinlich h√§ufiger in Paaren (Dubletts), Tripeln (Tripletts) und √§hnlichen Intervallkombinationen gefunden.  Wenn sich herausstellt, dass die Wiederholbarkeit von Duplets (und vielleicht sogar Triplets ... nun, pl√∂tzlich!) In der Gesamtmasse der Intervalle statistisch signifikant ist, ist es sinnvoll, sie in einen separaten Code zu √ºbersetzen. <br></p><p></p><p>  Das vollst√§ndige Experiment zeigt eine gewisse Vorherrschaft einzelner Dubletts gegen√ºber anderen.  Wenn jedoch die absolute F√ºhrung f√ºr das Paar erwartet wird <code>(6,6)</code> - 1,37% aller Dubletten -, dann sind die anderen Gewinner dieser Bewertung viel weniger offensichtlich: <br></p><p><br><img src="https://habrastorage.org/webt/4m/jq/o-/4mjqo-jyxt27cpw6e6bnasgxl0s.jpeg" alt="Dublettstatistik"><br><br></p><br><p>  Und da das Dublett <code>(6,6)</code> symmetrisch ist und alle anderen notierten Dubletts asymmetrisch sind und in der Rangfolge von Spiegelzwillingen mit derselben H√§ufigkeit gefunden werden, sollte der Datensatz des Dubletts <code>(6,6)</code> in dieser Reihe in zwei H√§lften zwischen nicht unterscheidbaren Zwillingen <code>(6,6)</code> und <code>(6,6)</code> , womit sie 0,68% weit bis an den Rand der Preisliste reichen.  Und dies best√§tigt erneut die Beobachtung, dass keine echten Vermutungen √ºber Primzahlen ohne √úberraschungen m√∂glich sind. <br></p><p></p><p>  Die Statistik der Drillinge zeigt auch die F√ºhrung solcher Dreifachintervalle, die nicht ganz in die spekulative Annahme passen, die von der h√∂chsten H√§ufigkeit der Intervalle 6, 12, 18 ausgeht. In abnehmender Reihenfolge der Popularit√§t sehen die Frequenzleiter unter den Drillingen wie folgt aus: <br></p><p><br><img src="https://habrastorage.org/webt/nn/if/sw/nnifswq5tugkq5kypoe44qllyj4.jpeg" alt="dreifache Statistik"><br><br></p><p>  usw. <br></p><p></p><p>  Ich bef√ºrchte jedoch, dass die Ergebnisse meiner Spekulationen f√ºr Programmierer weniger interessant sein werden als f√ºr Mathematiker, m√∂glicherweise aufgrund der unerwarteten Korrekturen, die durch die Praxis in intuitive Vermutungen vorgenommen wurden.  Es ist unwahrscheinlich, dass es m√∂glich sein wird, eine wesentliche Dividende aus dem genannten Prozentsatz der Frequenz zugunsten einer weiteren Erh√∂hung des Kompressionsverh√§ltnisses herauszuholen, w√§hrend die Komplexit√§t des Algorithmus sehr stark zu wachsen droht. <br></p><p></p><p></p><h4>  Einschr√§nkungen </h4><br><p></p><p>  Es wurde bereits oben angemerkt, dass der Anstieg des Maximalwerts der Intervalle in Verbindung mit der Kapazit√§t von Primzahlen sehr, sehr langsam ist.  Insbesondere ist aus Fig. 6 ersichtlich, dass das Intervall zwischen beliebigen Primzahlen, die im Format einer 64-Bit-Ganzzahl ohne Vorzeichen dargestellt werden k√∂nnen, offensichtlich weniger als 1600 betr√§gt. <br></p><p></p><p>  Mit der beschriebenen Implementierung k√∂nnen Sie alle 18-Bit-Intervallwerte korrekt verpacken und entpacken (tats√§chlich tritt der erste Verpackungsfehler mit einem Eingabeintervall von 442358 auf).  Ich habe nicht genug Vorstellungskraft, um anzunehmen, dass die Datenbank der Primintervalle auf solche Werte anwachsen kann: Nebenbei sind es etwa 100-Bit-Ganzzahlen, und um die Faulheit genauer zu berechnen.  In einem Brandfall ist es nicht schwierig, den Intervallbereich zeitweise zu erweitern. <br></p><p></p><p>  Vielen Dank f√ºr das Lesen zu diesem Ort :) <br></p><br><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417753/">https://habr.com/ru/post/de417753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417743/index.html">Legend√§re Verst√§rker - Historische Trendanatomie: Cold Transistor Sound</a></li>
<li><a href="../de417745/index.html">Pers√∂nliche Erfahrung: Data Engineering bei Upwork</a></li>
<li><a href="../de417747/index.html">Betreff: "Vergleich von JS-Frameworks: React, Vue und Hyperapp"</a></li>
<li><a href="../de417749/index.html">Project Loon als kommerzielles Projekt: Der erste Vertrag wird unterzeichnet</a></li>
<li><a href="../de417751/index.html">Kunstkamera: E-Meter - Scientology-Ger√§t zur Messung von Thetanen</a></li>
<li><a href="../de417755/index.html">Studie: 80% der ICOs 2017 gelten als betr√ºgerisch</a></li>
<li><a href="../de417757/index.html">Erstellen eines Bots zur Teilnahme am AI Mini Cup. GPU-Erfahrung</a></li>
<li><a href="../de417759/index.html">Sei meine Gummiente</a></li>
<li><a href="../de417761/index.html">GitLab wechselt von Azure zur Google Cloud Platform. Umzugsnachrichten und Wartungstermine</a></li>
<li><a href="../de417763/index.html">MVIDroid: eine √úberpr√ºfung der neuen MVI-Bibliothek (Model-View-Intent)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>