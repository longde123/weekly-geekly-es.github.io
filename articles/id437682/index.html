<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â–«ï¸ ğŸšˆ ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ¿ Menulis alat templating Kubernet lain ğŸŒ„ â¤ï¸ ğŸ•¸ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda bekerja dengan lingkungan Kubernetes maka Anda mungkin menggunakan beberapa alat templating yang ada, beberapa dari mereka menjadi bagian da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis alat templating Kubernet lain</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437682/"><p><img src="https://habrastorage.org/webt/hj/xp/t7/hjxpt7lglfmyiz9ut7xcy2ndpl4.png"></p><br><p>  Jika Anda bekerja dengan lingkungan Kubernetes maka Anda mungkin menggunakan beberapa alat templating yang ada, beberapa dari mereka menjadi bagian dari manajer paket seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helm</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ksonnet</a> , atau hanya bahasa templating (Jinja2, Go template dll).  Semua dari mereka memiliki kelemahannya sendiri serta kelebihannya dan kami akan membahasnya dan menulis alat kami sendiri yang akan mencoba menggabungkan fitur-fitur terbaik. </p><a name="habracut"></a><br><h2 id="so-why-not-helm">  Jadi, mengapa tidak Helm? </h2><br><p> Ada sejumlah artikel yang mengkritik Helm (mis. Salah satunya saja: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berpikir dua kali sebelum menggunakan Helm</a> ).  Masalah utama dengan Helm adalah bahwa ia bekerja dengan <em>representasi string</em> dan manifes Kubernetes adalah objek <em>(json)</em> .  Neraka sebenarnya untuk pengembang Helm chart dimulai ketika dia perlu menghitung indentasi untuk manifes <code>yaml</code> , kadang-kadang terlihat seperti ini (ini adalah contoh nyata dari bagan saya): </p><br><pre> <code class="plaintext hljs">spec: jobTemplate: spec: template: spec: containers: - name: my-awesome-container resources: {{ toYaml .Values.resources | indent 14 }}</code> </pre> <br><p><img src="https://habrastorage.org/webt/oh/iw/cz/ohiwczwzpduep0hfxrghx0xtook.jpeg"></p><br><p>  Tapi Helm hari ini adalah de-facto standar untuk kemasan aplikasi Kubernetes.  Keuntungan utama dari Helm adalah komunitas besar dan sejumlah besar repositori publik dengan grafik.  Dan baru-baru ini pengembang Helm telah mengumumkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hub Helm</a> .  Jadi Helm hari ini seperti Docker - ini bukan satu-satunya tetapi memiliki komunitas dan dukungan. </p><br><p>  Ada perubahan yang menjanjikan dengan rilis Helm 3 tetapi tidak ada yang tahu kapan itu bisa terjadi. </p><br><p>  Untuk menyimpulkan, keunggulan Helm: </p><br><ul><li>  Komunitas besar dan sejumlah bagan publik </li><li>  (Relatif) sintaks yang ramah manusia.  Setidaknya itu yaml + go templat;) </li></ul><br><p>  Kekurangan: </p><br><ul><li>  Bekerja dengan string dan bukan objek </li><li>  Jumlah operator dan fungsi terbatas yang dapat Anda gunakan </li></ul><br><h2 id="ok-then-maybe-ksonnet">  Oke, mungkin Ksonnet? </h2><br><p>  Jika Anda membandingkan Helm dengan Ksonnet, yang terakhir memiliki keunggulan besar, yaitu bekerja dengan objek.  Ksonnet adalah alat berbasis bahasa JSON templating Jsonnet.  Fitur keren lainnya tentang Ksonnet adalah memiliki pustaka Jsonnet yang kompatibel dengan Kubernetes-API yang dapat Anda impor ke template Anda dan bekerja dengan objek Kubernetes seperti dalam bahasa OOP: </p><br><pre> <code class="json hljs">local k = import <span class="hljs-string"><span class="hljs-string">"k.libsonnet"</span></span>; local deployment = k.apps.v<span class="hljs-number"><span class="hljs-number">1</span></span>beta<span class="hljs-number"><span class="hljs-number">1</span></span>.deployment; local appDeployment = deployment .new( params.name, params.replicas, container .new(params.name, params.image) .withPorts(containerPort.new(targetPort)), labels);</code> </pre> <br><p>  Terlihat mengesankan, bukan? <br>  Agak kurang rapi ketika Anda bekerja bukan dengan objek API tetapi dengan hanya objek json yang diimpor dari file <code>yaml</code> / <code>json</code> : </p><br><pre> <code class="json hljs">{ global: {}, components: { <span class="hljs-attr"><span class="hljs-attr">"deployment-nginx-deployment-dkecx"</span></span>+: { spec+: { replicas: <span class="hljs-number"><span class="hljs-number">10</span></span>, template+: { spec+: { containers+: [ { name: <span class="hljs-string"><span class="hljs-string">"nginx"</span></span>, image: <span class="hljs-string"><span class="hljs-string">"nginx:latest"</span></span>, ports: [ { containerPort: <span class="hljs-number"><span class="hljs-number">80</span></span>, }, ], }, ], }, }, }, }, }, }</code> </pre> <br><p>  Tapi tetap saja itu adalah sesuatu dan itu lebih baik daripada bekerja dengan string di Helm.  Kerugian dari Ksonnet adalah ia memiliki komunitas yang lebih kecil dan paket yang lebih sedikit daripada Helm (meskipun Anda dapat mengimpor grafik Helm ke proyek Ksonnet Anda, tetapi Anda akan bekerja dengan mereka sebagai objek json, bukan sebagai objek jsonnet-library).  Dan sebagai hasil dari komunitas yang lebih kecil dan kontribusi ada kekurangan beberapa fitur ketika Anda mencoba untuk menulis bagan Anda sendiri.  Salah satunya saya alami sendiri: Anda tahu bahwa di Helm Anda dapat membangun <code>ConfigMap</code> dari direktori yang berisi sejumlah file konfigurasi dengan cara ini: </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: ConfigMap metadata: name: conf data: {{- (.Files.Glob "foo/*").AsConfig | nindent 2 }}</code> </pre> <br><p>  Anda dapat membayangkan frustrasi saya ketika saya mengetahui bahwa tidak ada fitur seperti itu di Ksonnet.  Namun ada beberapa solusi.  Tapi intinya adalah itu hanya contoh dari situasi ketika Anda dengan senang hati menulis bagan Anda dan tiba-tiba kurangnya fitur menghentikan Anda di tengah jalan. <br>  Secara total, keunggulan Ksonnet: </p><br><ul><li>  Bekerja dengan benda </li><li>  Perpustakaan Jsonnet yang kompatibel dengan Kubernetes-API </li><li>  Dukungan impor grafik helm </li></ul><br><p>  Kekurangan: </p><br><ul><li>  Komunitas yang lebih kecil dan jumlah paket asli Ksonnet yang lebih sedikit </li><li>  Kurangnya beberapa fungsi yang dapat Anda gunakan di Helm </li><li>  Sintaks baru =&gt; peningkatan waktu belajar =&gt; peningkatan faktor bus </li><li>  Sintaks kadang-kadang bisa menjadi jelek dan kurang dapat dibaca manusia (terutama ketika membuat solusi untuk kekurangan fitur) </li></ul><br><h2 id="lets-think-of-an-ideal-templating-tool">  Mari kita pikirkan alat templating yang ideal </h2><br><p>  Berikut adalah beberapa kriteria untuk alat templating "ideal": </p><br><ul><li>  Ini harus bekerja dengan objek, bukan string </li><li>  Seharusnya memiliki kemampuan untuk bekerja dengan objek yang kompatibel dengan Kubernetes-API </li><li>  Seharusnya memiliki serangkaian fungsi yang layak untuk bekerja dengan string </li><li>  Ini harus bekerja dengan baik dengan format json dan yaml </li><li>  Itu harus ramah manusia </li><li>  Itu harus sederhana </li><li>  Seharusnya memiliki kemampuan untuk mengimpor grafik Helm yang ada (karena ini adalah kenyataan dan kami ingin memanfaatkan komunitas Helm) </li></ul><br><p>  Cukup untuk sekarang.  Saya membaca daftar ini di kepala saya dan berpikir dalam hati: oke, mengapa tidak mencoba Python?  Mari kita lihat apakah itu sesuai dengan kriteria kami: </p><br><ul><li>  <em>Bekerja dengan benda, bukan string</em> .  Ya, kita bisa menggunakan tipe <code>dict</code> dan <code>list</code> untuk itu. </li><li>  <em>Memiliki kemampuan untuk bekerja dengan objek yang kompatibel dengan Kubernetes-API</em> .  Ya, <code>from kubernetes import client</code> </li><li>  <em>Memiliki serangkaian fungsi yang layak untuk bekerja dengan string</em> .  Banyak! </li><li>  <em>Bekerja dengan baik dengan format json dan yaml</em> .  Dengan sangat baik. </li><li>  <em>Ramah manusia</em>  Tidak ada apa-apa. </li><li>  <em>Sederhana</em>  Ya </li><li>  <em>Kemampuan untuk mengimpor grafik Helm yang ada</em> .  Itu, kita akan menambahkan diri kita sendiri. </li></ul><br><p>  Ok, terlihat menjanjikan.  Saya memutuskan untuk menulis alat templating sederhana di atas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan klien Python Resmi untuk kubernetes</a> dan sekarang izinkan saya menunjukkan kepada Anda apa yang keluar darinya. </p><br><h2 id="meet-karavel">  Temui karavel </h2><br><p>  Tidak ada yang istimewa atau rumit tentang alat ini.  Saya baru saja mengambil perpustakaan Kubernetes (yang memberi saya kemampuan untuk bekerja dengan objek Kubernetes) dan menulis beberapa fungsionalitas dasar untuk grafik Helm yang ada (sehingga orang dapat mengambilnya dan menambahkannya ke grafik mereka sendiri).  Jadi, mari kita melakukan tur. <br>  Pertama-tama, alat ini dapat diakses di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repo Github</a> dan Anda dapat menemukan direktori dengan contoh di sana. </p><br><h2 id="quick-start-with-docker-image">  Mulai cepat dengan gambar Docker </h2><br><p>  Jika Anda ingin mencobanya, cara paling sederhana adalah dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gambar buruh pelabuhan ini</a> : </p><br><pre> <code class="plaintext hljs">$ docker run greegorey/karavel -h usage: karavelcli.py [-h] subcommand ... optional arguments: -h, --help show this help message and exit list of subcommands: subcommand template generates manifests from template ensure ensure helm dependencies</code> </pre> <br><p>  Tentu saja, jika Anda ingin membuat templat bagan, Anda perlu memasang direktori bagan Anda: </p><br><pre> <code class="plaintext hljs">$ cd example $ docker run -v $PWD:/chart greegorey/karavel template .</code> </pre> <br><p>  Jadi, mari kita lihat struktur grafik.  Ini sangat mirip dengan salah satu Helm: </p><br><pre> <code class="plaintext hljs">$ cd example $ tree . . â”œâ”€â”€ dependencies â”œâ”€â”€ prod.yaml â”œâ”€â”€ requirements.yaml â”œâ”€â”€ templates â”‚  â”œâ”€â”€ custom-resource.py â”‚  â”œâ”€â”€ deployment.py â”‚  â””â”€â”€ service-helm.py â””â”€â”€ values.yaml 2 directories, 6 files</code> </pre> <br><p>  Seperti Helm, ia memiliki file <code>requirements.yaml</code> dengan tata letak yang sama: </p><br><pre> <code class="plaintext hljs">dependencies: - name: mysql version: 0.13.1 repository: https://kubernetes-charts.storage.googleapis.com/</code> </pre> <br><p>  Di sini Anda cukup mendaftar dependensi Helm yang ingin Anda impor ke bagan.  Dependensi pergi ke direktori <code>dependencies</code> .  Untuk mengambil atau memperbaruinya gunakan perintah sure: </p><br><pre> <code class="plaintext hljs">$ karavel ensure .</code> </pre> <br><p>  Setelah itu direktori <code>dependencies</code> Anda akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">$ tree dependencies dependencies â””â”€â”€ mysql-0.13.1 â””â”€â”€ mysql â”œâ”€â”€ Chart.yaml â”œâ”€â”€ README.md â”œâ”€â”€ templates â”‚  â”œâ”€â”€ NOTES.txt â”‚  â”œâ”€â”€ _helpers.tpl â”‚  â”œâ”€â”€ configurationFiles-configmap.yaml â”‚  â”œâ”€â”€ deployment.yaml â”‚  â”œâ”€â”€ initializationFiles-configmap.yaml â”‚  â”œâ”€â”€ pvc.yaml â”‚  â”œâ”€â”€ secrets.yaml â”‚  â”œâ”€â”€ svc.yaml â”‚  â””â”€â”€ tests â”‚  â”œâ”€â”€ test-configmap.yaml â”‚  â””â”€â”€ test.yaml â””â”€â”€ values.yaml 4 directories, 13 files</code> </pre> <br><p>  Sekarang setelah kita memastikan dependensi kita mari kita lihat templat.  Pertama, kami membuat penyebaran nginx sederhana: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> kubernetes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> karavel.helpers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Values <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> values = Values().values <span class="hljs-comment"><span class="hljs-comment"># Configure Pod template container container = client.V1Container( name='nginx', image='{}:{}'.format(values.nginx.image.repository, values.nginx.image.tag), ports=[client.V1ContainerPort(container_port=80)]) # Create and configurate a spec section template = client.V1PodTemplateSpec( metadata=client.V1ObjectMeta(labels={'app': 'nginx'}), spec=client.V1PodSpec(containers=[container])) # Create the specification of deployment spec = client.ExtensionsV1beta1DeploymentSpec( replicas=3, template=template) # Instantiate the deployment object deployment = client.ExtensionsV1beta1Deployment( api_version='extensions/v1beta1', kind='Deployment', metadata=client.V1ObjectMeta(name='nginx-deployment'), spec=spec) return deployment # [deployment], (deployment, deployment) are valid</span></span></code> </pre> <br><p>  Jadi, agar templat menjadi valid, Anda harus memiliki fungsi <code>template()</code> yang mengembalikan objek Kubernetes tunggal atau <code>list</code> / tupelnya.  Anda dapat menemukan daftar objek API untuk klien Python di <a href="">sini</a> . <br>  Seperti yang Anda lihat, kodenya bersih, sederhana, mudah dibaca.  Anda bisa bertanya-tanya dari mana berasal <code>values.nginx.image.repository</code> ?  Ia mendapat nilai dari file nilai yang Anda lewati saat menyusun bagan, seperti di Helm: <code>karavel template -f one.yaml --values two.yaml</code> .  Kita akan melihatnya nanti. </p><br><h2 id="okay-what-about-helm-charts">  Oke, bagaimana dengan grafik Helm? </h2><br><p>  Sekarang, kami membuat Penempatan kami sendiri.  Tetapi bagaimana jika kita ingin mengimpor Helm bag atau bagian dari bagan?  Mari kita lihat <code>templates/service-helm.py</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> kubernetes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> karavel.helm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HelmChart <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> karavel.helpers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Values <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> values = Values().values <span class="hljs-comment"><span class="hljs-comment"># Initialize the chart (== helm template --values) chart = HelmChart(name='mysql', version='0.13.1', values=values.mysql.helm) # Get the desired object from chart service = chart.get(name='svc', obj_class=client.V1Service) # Create custom objects to add custom_ports = [ client.V1ServicePort( name='my-custom-port', protocol=values.mysql.protocol, port=values.mysql.port, target_port=39000, ) ] # Add custom objects to the service service.spec['ports'] = custom_ports # Change Helm-generated label service.metadata['labels']['release'] += '-suffix' # Delete Helm-generated label `heritage: Tiller` del service.metadata['labels']['heritage'] return service # [service], (service, service) are valid</span></span></code> </pre> <br><p>  Sederhana ya  Perhatikan baris ini: <code>service = chart.get(name='svc', obj_class=client.V1Service)</code> - kami membuat objek kelas <code>V1Service</code> dari file Helm <code>yaml</code> .  Jika Anda tidak ingin / perlu melakukan itu - Anda selalu dapat bekerja dengan <code>dict</code> . </p><br><h2 id="what-if-i-want-to-create-custom-resource">  Bagaimana jika saya ingin membuat sumber daya khusus? </h2><br><p>  Nah, ada masalah kecil dengan itu.  API Kubernetes tidak menambahkan objek CRD ke definisi json <code>/openapi/v2</code> di <code>/openapi/v2</code> , dan objek Python-client dibuat berdasarkan definisi ini.  Tetapi Anda masih dapat dengan mudah bekerja dengan objek-objek <code>dict</code> .  Seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> kubernetes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> client <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> resource = { <span class="hljs-string"><span class="hljs-string">'apiVersion'</span></span>: <span class="hljs-string"><span class="hljs-string">'stable.example.com/v1'</span></span>, <span class="hljs-string"><span class="hljs-string">'kind'</span></span>: <span class="hljs-string"><span class="hljs-string">'Whale'</span></span>, <span class="hljs-string"><span class="hljs-string">'metadata'</span></span>: client.V1ObjectMeta( name=<span class="hljs-string"><span class="hljs-string">'my-object'</span></span>, ), <span class="hljs-string"><span class="hljs-string">'spec'</span></span>: { <span class="hljs-string"><span class="hljs-string">'image'</span></span>: <span class="hljs-string"><span class="hljs-string">'my-whale-image:0.0.1'</span></span>, <span class="hljs-string"><span class="hljs-string">'tail'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'fins'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resource <span class="hljs-comment"><span class="hljs-comment"># [resource], (resource, resource) are valid</span></span></code> </pre> <br><p>  Masih terlihat bagus, bukan? </p><br><h2 id="can-i-have-values-for-different-environments-eg-devprod">  Bisakah saya memiliki nilai untuk lingkungan yang berbeda, misalnya dev / prod? </h2><br><p>  Ya kamu bisa! <br>  Mari kita lihat <code>values.yaml</code> terlebih dahulu: </p><br><pre> <code class="plaintext hljs">nginx: image: repository: nginx tag: 1.15-alpine mysql: port: 3307 protocol: TCP helm: releaseName: my-release namespace: prod imageTag: '5.7.14' service: type: NodePort</code> </pre> <br><p>  Catat kunci <code>helm</code> di dalam <code>mysql</code> dict: kami menggunakannya ketika menentukan nilai untuk bagan helm: <code>chart = HelmChart(name='mysql', version='0.13.1', values=values.mysql.helm)</code> .  Beberapa grafik Helm memerlukan <code>releaseName</code> untuk penamaan aplikasi dan <code>namespace</code> untuk kebijakan RBAC.  Kedua nilai ini diteruskan ke Helm sebagai argumen <code>--namespace</code> dan <code>NAME</code> dalam <code>helm template</code> . </p><br><p>  Sekarang, Anda dapat menentukan file tambahan untuk prod env, dan templat semua contoh kami: </p><br><pre> <code class="plaintext hljs">$ karavel template -f values.yaml -f prod.yaml . --- # Source: templates/custom-resource.py apiVersion: stable.example.com/v1 kind: Whale metadata: name: my-object spec: fins: 4 image: my-whale-image:0.0.1 tail: 1 --- # Source: templates/deployment.py apiVersion: extensions/v1beta1 kind: Deployment metadata: name: nginx-deployment spec: replicas: 3 template: metadata: labels: app: nginx spec: containers: - image: nginx:1.14-alpine name: nginx ports: - containerPort: 80 --- # Source: templates/service-helm.py apiVersion: v1 kind: Service metadata: annotations: null labels: app: prod-release-mysql chart: mysql-0.13.1 release: prod-release-suffix name: prod-release-mysql spec: ports: - name: my-custom-port port: 3308 protocol: TCP targetPort: 39000 selector: app: prod-release-mysql type: NodePort</code> </pre><br><p>  Setelah itu Anda bisa melakukan <code>kubeclt apply</code> dan menyebarkan objek-objek ini ke dalam cluster. </p><br><h3 id="cool-what-about-encoding-and-base64">  Keren!  Bagaimana dengan encoding dan base64? </h3><br><p> <code>import base64</code> </p> <br><h3 id="what-about-using-vault-for-secrets">  Bagaimana dengan menggunakan Vault untuk rahasia? </h3><br><p> <code>import hvac</code> </p> <br><h3 id="fetching-urls">  Mengambil url? </h3><br><p> <code>import importlib</code> </p> <br><h3 id="secure-hash-functions">  Fungsi hash aman? </h3><br><p> <code>import Crypto</code> </p> <br><p>  Kamu mendapatkannya.  Dengan Python Anda dapat melakukan banyak hal dengan manifes Kubernet Anda. </p><br><h2 id="is-it-nih-syndrome">  Apakah itu sindrom NIH? </h2><br><p>  Tidak :) <br>  Saya <del>  dengan senang hati </del>  menggunakan Helm dalam proyek saya saat ini.  Ada beberapa hal yang saya rindukan.  Saya menggunakan Ksonnet di beberapa proyek saya juga. <br>  Saya ingin menganggap alat ini sebagai bukti konsep bahwa kita dapat memiliki alat templating lebih baik daripada Helm dan tidak terlalu sulit untuk mengembangkannya menggunakan Python.  Jika ada minat / kebutuhan masyarakat akan alat semacam itu, kita dapat bersama-sama terus mengembangkannya.  Atau kita bisa menunggu rilis Helm 3;) </p><br><h2 id="conclusion">  Kesimpulan </h2><br><p>  Saya telah menunjukkan kepada Anda alat templating berbasis Python untuk Kubernetes yang mendukung dan mendukung objek yang kompatibel dengan Kubernetes-API untuk mengimpor grafik Helm.  Setiap komentar dan diskusi dari komunitas dipersilahkan, dan sekali lagi selamat datang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repo</a> . </p><br><p>  Terima kasih telah membaca ini dan semoga harimu menyenangkan! </p><br><h3 id="references">  Referensi </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pustaka klien Python resmi untuk kubernetes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ksonnet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel tentang Medium ini</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437682/">https://habr.com/ru/post/id437682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437670/index.html">Pembaruan Backend MSVC di Visual Studio 2019 Pratinjau 2: Optimasi Baru, OpenMP, dan peningkatan Throughput Build</a></li>
<li><a href="../id437672/index.html">cyberd: Menghitung pengetahuan dari web3</a></li>
<li><a href="../id437674/index.html">Metode pengenalan objek 3D untuk kendaraan tak berawak. Laporan Yandex</a></li>
<li><a href="../id437676/index.html">Universitas dan Akselerator Perusahaan sebagai Pengungkit untuk Meluncurkan Startup B2B di AS</a></li>
<li><a href="../id437680/index.html">Koleksi DIY saya di Youtube</a></li>
<li><a href="../id437684/index.html">Algoritma Tertinggi - Kompendium Bias</a></li>
<li><a href="../id437686/index.html">Learning go: menulis messenger p2p dengan enkripsi ujung ke ujung</a></li>
<li><a href="../id437688/index.html">OpenSceneGraph: Teknik Pemrograman Dasar</a></li>
<li><a href="../id437694/index.html">Analisis utilitas Files.walkFileTree ();</a></li>
<li><a href="../id437696/index.html">Intisari materi menarik untuk pengembang seluler # 283 (pada 21 - 27 Januari)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>