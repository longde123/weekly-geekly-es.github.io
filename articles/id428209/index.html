<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¿ ğŸ¥« ğŸ’„ Buku masak pengembang: Resep Desain Berbasis Domain (Bagian 2, struktur dan interaksi) ğŸ§¡ ğŸšª ğŸ§˜ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Dalam artikel pertama, kami menyoroti ruang lingkup praktik yang ditunjukkan, untuk proyek mana mereka dapat diterapkan, dan untuk man...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku masak pengembang: Resep Desain Berbasis Domain (Bagian 2, struktur dan interaksi)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428209/"><p><img src="https://habrastorage.org/webt/fr/vw/on/frvwonyhe7k6st_x65v67hcbrcs.jpeg" alt="ddd-header"></p><br><h1 id="vvedenie">  Pendahuluan </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dalam artikel pertama,</a> kami menyoroti ruang lingkup praktik yang ditunjukkan, untuk proyek mana mereka dapat diterapkan, dan untuk mana mereka tidak boleh. </p><br><p> Dalam artikel ini, saya ingin memberikan tinjauan singkat tentang prinsip-prinsip dasar DDD, serta berbagi pengalaman pribadi saya dengan aplikasi mereka.  Kami akan berbicara lebih rinci tentang komunikasi dan pendekatan struktural dengan contoh-contoh implementasinya. </p><br><p>  Dalam artikel berikut ini saya akan menuliskan kemungkinan kombinasi pola desain yang diterapkan dengan mempertimbangkan implementasinya, dan pada akhirnya saya akan memberikan contoh implementasi spesifik dari satu layanan mikro kecil. </p><a name="habracut"></a><br><h1 id="ddd">  DDD </h1><br><p>  Ingat definisi sebelumnya: </p><br><blockquote>  Domain-driven design (DDD) adalah pendekatan pengembangan perangkat lunak untuk kepuasan kebutuhan yang komprehensif, dengan secara ketat menghubungkan implementasi dengan model bisnis utama yang berada dalam pengembangan konstan. </blockquote><p>  Buku referensi yang menggambarkan praktik membangun sistem yang rumit adalah Eric Evans ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Domain Driven Dedign</a> (Buku Biru Besar).  Jika Anda membaca artikel ulasan tentang topik ini, Anda sudah mengetahuinya.  Pada saat Anda menggunakan DDD dalam praktek, Anda harus membacanya.  Ini bukan buku termudah untuk dibaca: </p><br><blockquote>  Sumber kanonik untuk DDD adalah buku Eric Evans.  Ini bukan yang paling mudah dibaca dalam literatur perangkat lunak, tetapi itu adalah salah satu dari buku-buku yang cukup membayar investasi yang cukup besar. <br><br>  Martin Fowler: 15 Januari 2014 </blockquote><p>  Jika Anda menggulir isi buku, bagi Anda itu tampaknya tidak cukup terstruktur.  Tapi peta itu akan membantu kita. <br><img src="https://habrastorage.org/webt/oh/5e/tj/oh5etj1mf-uvet2bdyn7y1olj8k.png" alt="DDD-map"></p><br><p>  Di peta adalah praktik-praktik yang akan kita pertimbangkan hari ini. </p><br><p>  Ruang lingkup praktik yang dicakup dalam buku ini sangat besar.  Lingkup praktik yang dapat diterapkan di luar buku ini bahkan lebih besar.  Sebelum Anda melayani setidaknya sebagian dari mereka, identifikasi tujuan Anda.  Saya akan memberikan contoh saya sendiri. </p><br><ul><li>  Tingkatkan produktivitas. </li><li>  Tulis kode yang dapat dipahami. </li><li>  Penskalaan pada tingkat pengembangan perangkat lunak. </li></ul><br><h2 id="edinyy-yazyk">  Bahasa tunggal </h2><br><p>  Pengembangan perangkat lunak jarang mengarah pada penciptaan sesuatu yang baru, sebagai aturan, ini adalah simulasi dari sesuatu yang sudah ada. </p><br><blockquote>  Model adalah representasi dari objek nyata, yang hanya mencakup properti dan fungsi yang diperlukan. </blockquote><p>  Kami tidak dapat membuat produk perangkat lunak yang mencakup seluruh area subjek.  Dimungkinkan untuk mereproduksi hanya bagian itu yang akan mereproduksi fungsionalitas yang diperlukan. </p><br><p>  Contoh model yang baik adalah peta topografi.  Dia adalah model medan.  Peta tidak mengandung padang rumput bidang dan sungai, hanya mencerminkan lokasi objek nyata relatif satu sama lain. </p><br><p>  Untuk membangun model yang jelas dan jelas untuk semua orang, Anda perlu berbicara bahasa yang sama.  Tidak hanya Eric Evans yang memberi tahu kita hal ini, tetapi juga akal sehat.  Jika pemrogram menggunakan istilah mereka, dan mengatur 'slang' mereka sendiri, maka yang pertama tidak akan mengerti apa yang perlu dilakukan.  Bisnis dalam hal ini tidak akan dapat mewujudkan biaya nyata untuk mengembangkan satu atau "fitur" yang lain.  Berapa kali Anda mendengar: "Ya, itu hanya sebuah tombol untuk ditambahkan"? </p><br><p>  Tujuan Anda sebagai perancang sistem haruslah untuk mendapatkan pemahaman maksimal satu sama lain dari seluruh tim.  Bagaimana cara mencapai ini?  Mulailah berbicara.  Jika orang-orang mulai berkomunikasi dalam kelompok dekat mana pun, mereka memiliki serangkaian istilah tertentu yang diterima secara umum.  Di perusahaan yang berbeda, proses pengenalan bahasa yang sama cenderung berbeda.  Ini bisa berupa keputusan yang berkemauan keras atau prosedur yang demokratis.  Bahasa dapat diindikasikan secara eksplisit, dan itu tidak dimasukkan secara eksplisit, dalam hal ini mereka hanya mulai berbicara itu.  Teknik yang baik untuk memperkenalkan bahasa umum adalah dokumentasi umum. </p><br><h3 id="kak-vesti-dokumentaciyu-proekta">  Bagaimana cara menyimpan dokumentasi proyek </h3><br><ol><li>  Setiap komunikasi antara bisnis dan pengembangan harus meningkatkan model Anda. </li><li>  Setelah pertemuan, catat hasilnya dalam bentuk dokumentasi (Scrum artifact), dan tunjukkan dokumentasi ini kepada semua peserta dalam proses pengembangan. </li><li>  Gunakan satu bahasa dalam dokumentasi. </li><li>  Paling penting: jangan buang waktu pada dokumentasi.  Anda masih harus menulis kode, dan dokumentasinya akan ditulis ulang berkali-kali, menghabiskan sumber daya mahal.  Daripada bermain-main dengan aplikasi charting UML untuk waktu yang lama, gunakan serbet, pena, dan kamera di ponsel Anda. </li><li>  Dokumentasi membutuhkan disiplin, Anda tidak dapat menulisnya dari waktu ke waktu. </li><li>  Pisahkan dokumentasi: <br><ul><li> Komentar dalam kode - jelaskan momen yang tidak dapat dipahami secara langsung dalam kode, biarkan <code>#ODO:</code> (hapus saat menggabungkan kode menjadi master).  Ungkapkan pendapat Anda dalam komentar, misalnya, Anda harus menggunakan satu atau beberapa penopang lain saat bekerja dengan kode legasy. </li><li>  Komentar pada proyek <code>README.md</code> di direktori root proyek Anda harus berisi informasi teknis: cara memulai proyek, cara menjalankan tes, dll.  Ini juga merupakan ide bagus untuk mendapatkan peta tempat Anda memiliki semua proyek dan di server mana mereka menjalankannya.  Catat semua perjanjian yang diterima secara terpisah. </li><li>  Dan yang paling penting, basis pengetahuan.  Kumpulan dokumen yang menjelaskan proses bisnis, ini adalah bagian dari dokumen yang tersedia untuk Anda dan bisnis. </li></ul></li><li>  Kesalahan utama dari mereka yang menulis dokumentasi adalah redundansi.  Jangan mencoba untuk menutupi segalanya dan segalanya, sampaikan hanya makna umum.  Dokumentasi harus melengkapi proyek Anda, tetapi tidak menggantinya dengan cara apa pun.  Jangan menuliskan semua istilah yang hanya ambigu.  Jika sebuah definisi membutuhkan lebih dari dua kalimat, itu adalah definisi yang buruk. </li></ol><br><p>  Contoh dokumentasi: </p><br><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">#         . # :  : -    - email -  ## : ###        ,     email  ,    1  (      email  ). ###           .          email . ###  email  email     .    ,    email.   . ###       ,     ,    .   . ###      email,    ,       .   2 . ###                  .    ,     ,             .</span></span></code> </pre><br><p>  Perhatikan bahwa dalam contoh ini kami tidak menentukan kamus eksplisit, namun kami memperbaiki konsep <em>Pengguna</em> , <em>Otorisasi</em> , <em>Registrasi</em> .  Menulis dokumentasi semacam itu tidak akan membutuhkan waktu lebih dari 20 menit oleh pakar. </p><br><p>  Bagi seseorang yang bukan ahli dalam bidang subjek, proses penulisan dokumentasi dianggap sebagai sesuatu yang rumit.  Perlu untuk memisahkan koleksi pengetahuan dan catatan pengetahuan yang dikumpulkan. <code> !=  +  .</code> </p><br><blockquote>  "Apa yang Anda sebut alam semesta," kata yang keempat, "sebenarnya, adalah akumulasi dari dunia yang, seperti kulit busur, berada di atas satu sama lain dan secara bertahap terpisah satu sama lain." <br><br>  - Tidak jelas dinyatakan!  - Mengagumi para abderites.  - Sangat jelas!  "Mereka pikir mereka mengerti filsuf itu, karena mereka tahu betul apa bawang itu." <br><br>  Cerita Aberdeen, Cristov Martin Wieland </blockquote><br><h2 id="ogranichennyy-konteksty-i-domeny">  Konteks dan domain terbatas </h2><br><p>  Bayangkan kita bertindak sebagai perancang startup progresif.  Kita semua suka pizza dingin, mengutuk kurir dan mengisi formulir di situs selama berjam-jam.  Oleh karena itu, kami membuat startup yang luar biasa, â€œEmpat kura-kura dan satu tikusâ€: </p><br><ul><li>  Ada situs tempat pizza terdaftar dan memposting hidangan mereka yang sebenarnya. </li><li>  Pizza ini tidak memiliki layanan kurir sendiri. </li><li>  Ada pelanggan yang tidak dapat mencapai restoran pizza, tetapi mereka siap melakukan pemesanan melalui situs web atau aplikasi seluler. </li><li>  'Fitur' pembunuh: kurir tidak khusus mempekerjakan orang, tetapi orang-orang biasa yang mendaftar melalui aplikasi mobile </li><li>  Kurir menerima pesanan, setelah eksekusi mereka menerima pembayaran untuk pekerjaan yang dilakukan. </li><li>  Butuh waktu lebih lama untuk menunggu kurir seperti itu, tetapi pengiriman, dan pizza yang sesuai, lebih murah. </li></ul><br><p>  Mari kita ingat kembali dokumentasi yang telah kita uraikan di bab sebelumnya.  Di sana, dalam kamus tunggal kami, istilah <em>pendaftaran digunakan</em> .  Tetapi dalam proyek ini kami memiliki beberapa di antaranya: </p><br><ul><li>  Registrasi pelanggan </li><li>  Pendaftaran Pizzeria </li><li>  Registrasi Kurir </li><li>  Registrasi Pesanan </li></ul><br><p>  Bahasa terpadu milik konteks terbatas.  Domain dari dokumentasi di atas adalah 'Sistem Otorisasi'.  Mari kita coba mengalokasikan domain untuk startup kita. </p><br><p>  Tetapi sebelum kita mulai, mari kita lihat sedikit terminologi tentang apa domain itu dan apa konteks yang terbatas itu. </p><br><blockquote>  Domain (Domain) - representasi dari struktur bisnis nyata yang memecahkan masalah tertentu. </blockquote><p>  Sebagai contoh: Sistem logistik, sistem pembayaran, sistem otorisasi, sistem manajemen pesanan. </p><br><p>  Domain dibagi menjadi subdomain, yang menggambarkan struktur yang lebih kecil, misalnya: keranjang pesanan, sistem untuk membangun rute. </p><br><p>  Setiap domain memiliki area tanggung jawab terbatas - fungsi terbatas. </p><br><blockquote>  Bounded context - satu set pembatasan domain yang membantu domain untuk fokus hanya pada satu tugas untuk solusi terbaiknya. </blockquote><p>  Saya suka menyajikan istilah ini sebagai abstraksi.  Domain adalah lingkaran.  Konteks terbatas adalah lingkaran. </p><br><p><img src="https://habrastorage.org/webt/nf/nm/jz/nfnmjzlgui85mvfatppogqv-kdq.jpeg" alt="Domain-daerah"></p><br><p>  Bahkan dalam terminologi DDD, kernel dialokasikan. </p><br><blockquote>  Inti (Core domain) - domain paling penting yang paling menjadi ciri bisnis Anda. </blockquote><p>  Jadi, domain dari proyek "Empat kura-kura dan satu tikus": </p><br><p>  <strong>Bekerja dengan pizzeria</strong> (Pizzaria) </p><br><p>  <em>Konteks</em> : b2b semuanya terkait dengan pizza </p><br><p>  <em>Subdomain</em> : </p><br><ul><li>  pendaftaran pizza baru </li><li>  menambahkan bermacam-macam </li><li>  memperbarui status ketersediaan suatu produk </li></ul><br><p>  <strong>Bekerja dengan klien</strong> (Klien) </p><br><p>  <em>Konteks</em> : b2c, semua yang berhubungan dengan bekerja dengan pelanggan pizza </p><br><p>  <em>Subdomain</em> : </p><br><ul><li>  lihat bermacam-macam </li><li>  bahan informasi </li></ul><br><p>  <strong>Bekerja dengan kurir</strong> (Sistem pengiriman) </p><br><p>  <em>Konteks</em> : b2e, semua yang berhubungan dengan bekerja dengan kurir </p><br><p>  <em>Subdomain</em> : </p><br><ul><li>  pendaftaran kurir </li><li>  penugasan tugas </li><li>  pendaftaran aplikasi untuk penarikan dana yang diperoleh kurir. </li></ul><br><p>  Sistem pemesanan </p><br><p>  <em>Konteks</em> : Kernel.  Memungkinkan Anda mengoordinasikan semua domain individu, memberikan siklus lengkap mulai dari menerima pesanan hingga pengiriman pizza kepada pengguna.  Ini bukan pemain, tetapi memainkan peran sebagai konduktor. </p><br><p>  <em>Subdomain</em> : </p><br><ul><li>  penerimaan pesanan </li><li>  eksekusi pesanan </li><li>  pelacakan status pesanan </li></ul><br><p>  <strong>Sistem Penyelesaian</strong> (Tagihan) </p><br><p>  <em>Konteks</em> : Berisi semua transaksi keuangan.  Ini menyediakan interaksi dengan pusat pemrosesan. </p><br><p>  <em>Subdomain</em> : </p><br><ul><li>  menerima uang untuk pesanan </li><li>  memberikan uang kepada kurir untuk pekerjaan yang dilakukan </li></ul><br><p>  <strong>Sistem Statistik</strong> </p><br><p>  <em>Konteks</em> : Pengumpulan dan pemrosesan (tidak mengeluarkan) informasi analitik. </p><br><p>  <em>Subdomain</em> : </p><br><ul><li>  statistik dana </li><li>  statistik aplikasi </li></ul><br><p>  <strong>Sistem Manajemen</strong> (panel Manajemen) </p><br><p>  <em>Konteks</em> : Penerbitan informasi analitis.  Toolkit keputusan manajemen. </p><br><ul><li>  analisis berdasarkan statistik yang dikumpulkan </li><li>  pra-moderasi pembayaran ke kurir </li></ul><br><p>  Berdasarkan pada domain, mari memetakannya. </p><br><blockquote>  Peta domain (Context map) adalah alat grafis yang memungkinkan Anda untuk menggambarkan hubungan antara masing-masing domain. </blockquote><p><img src="https://habrastorage.org/webt/p1/ks/po/p1kspot2qqut90gzcn1b9fhxyn8.png" alt="Peta konteks"></p><br><p>  Peta menunjukkan tautan antar domain.  Peta ini sangat dangkal, tetapi area subjek tidak dipahami dengan baik.  Ini adalah sketsa pertama, penulisan ulang yang Anda akan mendapatkan hasil yang diharapkan. </p><br><p>  Yang paling penting di peta adalah kita melihat koneksi antar domain.  Struktur seperti itu sangat cocok dengan arsitektur microservice: </p><br><blockquote>  Prinsip utama arsitektur layanan-mikro: konektivitas lemah dan daya rekat kuat. </blockquote><p>  Prinsip ini diberikan dalam buku oleh Sam Newman - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Creating Microservices</a> , ini adalah buku kedua yang harus Anda baca untuk memulai penggunaan praktis dari pendekatan yang dijelaskan dalam artikel ini.  Apa yang dimaksud: domain harus digabungkan secara longgar, tetapi terkait erat secara internal. </p><br><p>  Terjemahan dari istilah-istilah ini diambil dari terjemahan resmi Rusia dan, mungkin, kurang mencerminkan makna yang ditransmisikan.  Dalam istilah aslinya adalah: Kopling rendah (konektivitas, keterlibatan, pegangan, konjugasi), kohesi tinggi (konektivitas, kekuatan). </p><br><h2 id="praktika-realizacii-domennogo-razdelenie">  Praktek Implementasi Berbagi Domain </h2><br><p>  Saya ingin berbagi pengalaman pribadi saya - satu set keputusan berdasarkan informasi.  Saya tidak menganjurkan Anda untuk menggunakan solusi ini.  Tetapi mereka mungkin merupakan pilihan yang baik jika Anda tidak tahu harus mulai dari mana.  Dengan pengalaman pribadi, alat-alat ini akan lebih disesuaikan dengan kebutuhan Anda. </p><br><p>  Prinsip-prinsip utama yang memandu kami: </p><br><ul><li>  Kesederhanaan solusinya.  Jadikan hal-hal rumit menjadi sederhana, tidak sesederhana itu. </li><li>  Pragmatisme  Anda selalu perlu melihat situasinya, dan tanpa adanya solusi yang ada, kembangkan yang baru.  Cobalah untuk menuliskan semuanya, tetapi hindari dogmatisme. </li><li>  Kode! = Dokumentasi.  Kode adalah instruksi untuk mesin, dokumentasi adalah instruksi untuk orang.  Tidak perlu membingungkan mereka dan memberikan satu demi satu. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PADAT</a> </li></ul><br><h3 id="kak-realizovat-domeny">  Bagaimana cara mengimplementasikan domain? </h3><br><p>  Sangat mudah untuk memilih domain sebagai layanan microser terpisah. </p><br><blockquote>  Microservices adalah aplikasi terpisah yang mengimplementasikan logika satu domain. </blockquote><p>  Dalam pengembangan DDD, prinsip mengalokasikan layanan-mikro ke dalam aplikasi terpisah akan dibatasi konteksnya.  Ini tidak meniadakan prinsip teknis pemisahan layanan (jika ini karena kebutuhan untuk memastikan kinerja tinggi).  Tetapi prinsip kontekstual akan dominan dan mengikat. </p><br><h3 id="kak-vydelit-svyazi-mezhdu-domenami">  Bagaimana cara menyoroti hubungan antar domain? </h3><br><p>  Hubungan antar domain selalu merupakan API.  Bisa jadi TETAP api json, gRPC, AMPQ.  Dalam kerangka artikel ini, kami tidak akan membandingkan satu protokol dengan yang lain dan menyoroti kelebihan dan kekurangan mereka, masing-masing memiliki bidang aplikasi sendiri.  Tapi tetap saja, mari kita memikirkan rekomendasi umum: </p><br><p>  <strong>Jadilah fleksibel dalam memilih protokol dan kaku dalam keseragaman implementasinya.</strong> </p><br><p>  Pilih protokol untuk setiap pasangan domain secara individual, jangan mencoba menggunakan http di mana-mana, Anda mungkin perlu antrian yang tidak sinkron di suatu tempat dan keuntungan AMPQ akan menjadi jelas bagi Anda.  Jangan abaikan peluang ini karena Anda TETAP di mana-mana. </p><br><p>  Di sisi lain, jika Anda menerapkan RESTful json, gunakan satu standar penataan data.  Anda dapat bersiap-siap misalnya jsonapi atau openapi.  Jika karena alasan tertentu, solusi siap pakai tidak cocok untuk Anda dan Anda merasa dapat mengembangkan standar Anda, jelaskan, dan gunakan.  Tapi gunakan di mana-mana, jangan membiakkan standar "kebun binatang".  Jika Anda perlu berkomunikasi dengan sistem eksternal di mana mereka tidak tahu apa-apa tentang standar Anda, tulis adaptor layanan-mikro. </p><br><p><img src="https://habrastorage.org/webt/cz/ff/go/czffgobmp7v9lr2pzkjx0-3y5xq.png" alt="Adaptor"></p><br><h3 id="kak-realizovat-sabdomeny">  Bagaimana cara mengimplementasikan subdomain? </h3><br><p>  Sebagai modul terpisah di dalam layanan mikro. </p><br><blockquote>  Modul adalah implementasi dari subdomain, dengan menempatkan logika ke dalam namespace yang terpisah (Namespace) dalam satu layanan microser. </blockquote><p>  Seperti apa bentuknya?  Mari kita lihat sebuah contoh.  Seingat kami, kami memiliki domain sistem pengiriman - domain ini memiliki tiga subdomain: </p><br><ul><li>  pendaftaran kurir </li><li>  masalah tugas (tugas) </li><li>  pendaftaran aplikasi untuk penarikan dana yang diperoleh oleh kurir (penarikan) </li><li>  memeriksa apakah layanan mikro Anda berfungsi, alat bantu, teknis (healt_checker) </li></ul><br><p>  Bayangkan ini semua dalam bentuk struktur folder: </p><br><pre> <code class="bash hljs">$ tree --dirsfirst delivery_system delivery_system â”œâ”€â”€ app/ â”‚ â”œâ”€â”€ health_checker/ â”‚ â”‚ â””â”€â”€ endpoints.rb â”‚ â”œâ”€â”€ registrations/ â”‚ â”‚ â”œâ”€â”€ entities/ â”‚ â”‚ â”œâ”€â”€ forms/ â”‚ â”‚ â”œâ”€â”€ repositories/ â”‚ â”‚ â”œâ”€â”€ interactor/ â”‚ â”‚ â”œâ”€â”€ services/ â”‚ â”‚ â”œâ”€â”€ validations/ â”‚ â”‚ â”œâ”€â”€ endpoints.rb â”‚ â”‚ â””â”€â”€ helpers.rb â”‚ â”œâ”€â”€ tasks â”‚ â”‚ â”œâ”€â”€ entities/ â”‚ â”‚ â”œâ”€â”€ queries/ â”‚ â”‚ â”œâ”€â”€ repositories/ â”‚ â”‚ â”œâ”€â”€ endpoints.rb â”‚ â”‚ â””â”€â”€ helpers.rb â”‚ â””â”€â”€ withdrawals â”‚ â”œâ”€â”€ entities/ â”‚ â”œâ”€â”€ forms/ â”‚ â”œâ”€â”€ repositories/ â”‚ â”œâ”€â”€ interactor/ â”‚ â”œâ”€â”€ services/ â”‚ â”œâ”€â”€ validations/ â”‚ â”œâ”€â”€ endpoints.rb â”‚ â””â”€â”€ helpers.rb â”œâ”€â”€ config/ â”œâ”€â”€ db/ â”œâ”€â”€ docs/ â”œâ”€â”€ lib/ â”‚ â”œâ”€â”€ schemas/ â”‚ â””â”€â”€ values/ â”œâ”€â”€ public â”œâ”€â”€ specs â”œâ”€â”€ config.ru â”œâ”€â”€ Gemfile â”œâ”€â”€ Gemfile.lock â”œâ”€â”€ Rakefile â””â”€â”€ README.md</code> </pre> <br><p>  Setiap folder di <code>apps/</code> direktori mengimplementasikan satu atau subdomain lainnya, dalam setiap domain terdapat berbagai pola: <code>entities</code> , <code>forms</code> , <code>services</code> , dll. Kami akan mempertimbangkan masing-masing pola yang diterapkan secara terperinci di salah satu artikel mendatang. </p><br><p>  Setiap pola tersebut diimplementasikan dalam namespace yang sesuai (Namespace).  Misalnya, formulir untuk membuat aplikasi pembayaran ke kurir: </p><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Withdrawal</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#   module Forms #  class Create end end end</span></span></span></span></code> </pre> <br><h3 id="kak-realizovat-svyazi-mezhdu-sabdomeny">  Bagaimana cara menerapkan komunikasi antar subdomain? </h3><br><p>  Mari kita lihat contoh spesifik.  Kami memiliki akun kurir: <code>Registrations::Entities::Account</code> .  Ini merujuk ke subdomain <code>Registrations</code> - karena kami menganggap domain ini bukan sebagai proses pendaftaran, melainkan sebagai tabel akun dan buku pendaftaran, seperti yang ditunjukkan dalam dokumentasi bisnis kami. </p><br><p>  Kami memiliki dua <em>Proses yang</em> dalam pelaksanaannya kami mengakses akun ini. </p><br><ul><li>  Buat akun (Pendaftaran) </li><li>  Pembuatan aplikasi untuk penarikan dana yang diperoleh oleh kurir (Wihtdrawal) </li></ul><br><p>  Seperti yang kita lihat, dua proses ini milik subdomain yang berbeda - Registrasi dan Wihtdrawal. </p><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Registrations</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serivices</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateAccount</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">account</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Entities::Account</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Withdrwals</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serivices</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateOrder</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">account</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Registrations::Entities::Account</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><p>  Dalam kasus pertama, panggilan ke kelas akan dilaksanakan melalui panggilan ke <code>Entities::Account</code> .  Dan dalam kasus kedua, melalui panggilan eksplisit ke <code>Registrations::Entities::Account</code> .  Yaitu  jika kita secara eksplisit menentukan subdomain, maka kelasnya berasal dari subdomain lain dan oleh karena itu kami jelas menunjukkan hubungannya. </p><br><p>  Jika kelas tidak secara eksplisit diterapkan ke salah satu subdomain, masuk akal untuk memindahkannya ke <code>lib/</code> folder.  Sebagai aturan, ini adalah kelas yang menerapkan pola 'ValueObject'.  Kami akan memeriksa pola ini secara lebih rinci di salah satu artikel berikut. </p><br><h2 id="realizaciya-cherez-model">  Implementasi melalui model. </h2><br><p>  Mengutip Eric Evans: </p><br><blockquote>  Jika arsitektur program, atau setidaknya beberapa bagian pusatnya, tidak sesuai dengan struktur model domain, maka model seperti itu praktis tidak berguna, dan operasi program yang benar juga harus dipertanyakan.  Pada saat yang sama, hubungan yang terlalu kompleks antara model dan fungsi dalam arsitektur perangkat lunak sulit untuk dipahami, dan dalam praktiknya mereka sulit untuk dipertahankan karena perubahan arsitektur. </blockquote><p>  Mari kita ingat contoh model yang baik yang sudah saya kutip di awal artikel ini - peta topografi.  Tujuan kami adalah untuk dapat dengan cepat menemukan jarak antara dua pemukiman.  Kita bisa menggunakan tabel referensi yang menunjukkan dua titik antar kota.  Dan kita bisa menggunakan kartunya.  Baik di sana maupun di sana kita mendapatkan hasil yang sama dalam waktu yang hampir bersamaan.  Tetapi peta lebih kompak, lebih akurat menampilkan area subjek, lebih universal.  Peta sebagai model sangat ekspresif.  Dan jika kita mempertimbangkannya dalam kerangka tugas ini, maka mengukur jarak lebih nyaman di peta daripada di wilayah itu sendiri, yang dicerminkannya.  Model yang mencerminkan area subjek dapat melampaui itu di beberapa properti.  Sungguh menakjubkan. </p><br><p>  Implementasi model selalu merupakan proses kreatif dengan hasil yang tidak terduga.  Kualitas kode Anda bukan kinerjanya, atau kompleksitasnya, melainkan kesederhanaan dan ekspresif.  Tingkatkan itu melalui refactoring yang konstan, buatlah fleksibel dan potong semua yang tidak perlu.  Pisahkan lapisan yang akan bertanggung jawab atas logika bisnis model dari lapisan yang membutuhkannya karena implementasi teknis.  Bagaimana kami berhasil melakukan ini akan dijelaskan nanti. </p><br><hr><br><div class="spoiler">  <b class="spoiler_title">Sumber inspirasi</b> <div class="spoiler_text"><ul><li>  Desain Berorientasi Masalah, Eric J. Evans </li><li>  Membuat Layanan Mikro, Sam Newman </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://gorodinski.com/blog/2013/04/29/sub-domains-and-bounded-contexts-in-domain-driven-design-ddd/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://martinfowler.com/bliki/BoundedContext.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/post/316438/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://dotnetcodr.com/2015/08/06/domain-driven-design-with-web-api-revisited-part-1-introduction/</a> </li><li>  Sejarah Aberdeen, Cristov Martin Wieland </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428209/">https://habr.com/ru/post/id428209/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428193/index.html">Tentang pergi wisata</a></li>
<li><a href="../id428197/index.html">Keuangan pribadi yang efektif. Level 1</a></li>
<li><a href="../id428201/index.html">Lubang mol dalam JavaScript</a></li>
<li><a href="../id428203/index.html">Kami melihat grafik: perkiraan dan perkiraan untuk pasar cloud computing, data pada tahun 2018</a></li>
<li><a href="../id428205/index.html">Lifehacks NaviHaka</a></li>
<li><a href="../id428211/index.html">Buku â€œArsitektur evolusi. Dukungan untuk perubahan terus menerus "</a></li>
<li><a href="../id428213/index.html">Bagaimana menafsirkan prediksi model dalam SHAP</a></li>
<li><a href="../id428217/index.html">Juta panggilan video per hari atau "Hubungi ibu!"</a></li>
<li><a href="../id428219/index.html">Dari mana praktik relokasi massal personel yang memenuhi syarat berasal?</a></li>
<li><a href="../id428221/index.html">Generasi AI dari wajah realistis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>