<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📀 🌋 📄 基于RSA的区块链随机 👩🏿‍🎨 ⚜️ 🌬️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在开发游戏的过程中，我们需要解决一个问题。 在分布式网络中生成随机数很复杂。 几乎所有的区块链都已经面临这个问题。 确实，在任何人之间都不信任的网络中，创建随机数可以解决许多问题。 

 在本文中，我们解释了如何解决游戏中的问题。 其中第一个是Waves Xmas Tree 。 





 最初，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>基于RSA的区块链随机</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/464395/">在开发游戏的过程中，我们需要解决一个问题。 在分布式网络中生成随机数很复杂。 几乎所有的区块链都已经面临这个问题。 确实，在任何人之间都不信任的网络中，创建随机数可以解决许多问题。 <br><br> 在本文中，我们解释了如何解决游戏中的问题。 其中第一个是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Waves Xmas Tree</a> 。 <br><br><img src="https://habrastorage.org/webt/nq/lx/gi/nqlxgizojulzpf3ydp-rmq8g9fc.png"><br><br><a name="habracut"></a><br><br> 最初，我们计划使用来自区块链的信息生成一个数字。 但是，在进一步调查中，很明显可以操纵这种以数字方式创建号码的过程。 我们不得不放弃这个解决方案。 <br><br> 我们提出了一种解决方法，即采用“提交披露”方案。 服务器建议从1到5的数字，并在其中添加“盐”，然后使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Keccak函数</a>对结果进行哈希<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">处理</a> 。 服务器使用已保存的号码预调试了智能合约。 结果是游戏被有效地简化为用户猜测哈希隐藏的数字。 <br><br> 玩家下注，服务器向智能合约发送了一个隐藏的数字和“盐”。 换句话说，显示了卡片。 之后，服务器验证数字并确定用户是赢还是输。 <br><br> 如果服务器未发送数字和“盐”进行验证，则用户赢了。 在这种情况下，有必要提前部署智能合约并为每场比赛安排潜在的获胜机会。 这是不方便，昂贵和费时的。 但是，那时还没有其他安全解决方案。 <br><br> 此后不久，Tradisys团队建议将<b>rsaVerify（）</b>函数添加到Waves协议中。 这将根据公钥和私钥检查RSA签名的有效性。 根据我们的建议，该功能已添加。 <br><br> 我们构建了三个新游戏： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">骰子滚轴</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">投币翻转</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">乘风破浪</a> 。 在它们每个中，都实现了新的随机数技术。 让我们仔细看看它是如何工作的。 <br><br><img src="https://habrastorage.org/webt/ky/wa/af/kywaaf71lfpq-0cl9u-yujcbvb8.png"><br><br> 首先让我们看一下随机数的生成。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到智能合约。 <br><br> 转到<b>脚本选项卡，</b>然后选择<b>反编译</b> 。 您将看到智能合约的代码（或脚本）。 <br><br><img src="https://habrastorage.org/webt/s2/93/x-/s293x-xhotbeck3_j1ghquvhbmo.png"><br><br> 智能合约代码由功能列表组成。 可以通过<b>调用事务</b>运行@Callable。 我们对其中两个感兴趣： <b>下注</b>和<b>下注</b> ： <br><ul><li> 功能投注（playerChoice） </li><li> 功能撤回（gameId，rsaSign） </li></ul><br><br>  1.用户选择范围和下注大小。 <br><br><img src="https://habrastorage.org/webt/7s/0a/qu/7s0aqupmfkhtboadeg0bhtxpyrk.png"><br><br>  2.客户安排下注功能。 对于上面的图片，它会<b>下注（“ 50”）</b> <br><br>  3.客户端将调用事务发送到智能合约地址（广播的InvocationTx）。 作为Call参数的交易包含bet函数。 这意味着调用事务开始在智能合约上执行下注功能（选择：字符串）。 <br><br><img src="https://habrastorage.org/webt/gz/xx/r4/gzxxr4qfp3qzavthif-gifp6k3y.png"><br><br>  4.让我们看一下下注功能： <br><br><pre><code class="scala hljs"><span class="hljs-meta"><span class="hljs-meta">@Callable</span></span>(i) func bet (playerChoice) = { let newGameNum = <span class="hljs-type"><span class="hljs-type">IncrementGameNum</span></span>() let gameId = toBase58String(i.transactionId) let pmt = extract(i.payment) let betNotInWaves = isDefined(pmt.assetId) let feeNotInWaves = isDefined(pmt.assetId) let winAmt = <span class="hljs-type"><span class="hljs-type">ValidateBetAndDefineWinAmt</span></span>(pmt.amount, playerChoice) let txIdUsed = isDefined(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, gameId)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (betNotInWaves) then <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (<span class="hljs-string"><span class="hljs-string">"Bet amount must be in Waves"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (feeNotInWaves) then <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (<span class="hljs-string"><span class="hljs-string">"Transaction's fee must be in Waves"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (txIdUsed) then <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (<span class="hljs-string"><span class="hljs-string">"Passed txId had been used before. Game aborted."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { let playerPubKey58 = toBase58String(i.callerPublicKey) let gameDataStr = <span class="hljs-type"><span class="hljs-type">FormatGameDataStr</span></span>(<span class="hljs-type"><span class="hljs-type">STATESUBMITTED</span></span>, playerChoice, playerPubKey58, height, winAmt, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-type"><span class="hljs-type">ScriptResult</span></span>(<span class="hljs-type"><span class="hljs-type">WriteSet</span></span>(cons(<span class="hljs-type"><span class="hljs-type">DataEntry</span></span>(<span class="hljs-type"><span class="hljs-type">RESERVATIONKEY</span></span>, <span class="hljs-type"><span class="hljs-type">ValidateAndIncreaseReservedAmt</span></span>(winAmt)), cons(<span class="hljs-type"><span class="hljs-type">DataEntry</span></span>(<span class="hljs-type"><span class="hljs-type">GAMESCOUNTERKEY</span></span>, newGameNum), cons(<span class="hljs-type"><span class="hljs-type">DataEntry</span></span>(gameId, gameDataStr), nil)))), <span class="hljs-type"><span class="hljs-type">TransferSet</span></span>(cons(<span class="hljs-type"><span class="hljs-type">ScriptTransfer</span></span>(<span class="hljs-type"><span class="hljs-type">SERVER</span></span>, <span class="hljs-type"><span class="hljs-type">COMMISSION</span></span>, unit), nil))) } }</code> </pre> <br><br> 该函数在智能合约状态下记录新游戏： <br><br><ul><li> 独特的新游戏ID（游戏ID） </li><li> 游戏状态=已提交 </li><li> 玩家选择（范围为50） </li><li> 公钥 </li><li> 潜在奖励（取决于玩家的投注） </li></ul><br><br><img src="https://habrastorage.org/webt/ia/w6/s9/iaw6s9uiyfpaut6mhn8gkolxaou.png"><br><br> 这就是键值数据库在区块链上的外观： <br><br><pre> <code class="scala hljs">{ <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"03WON_0283_448t8Jn9P3717UnXFEVD5VWjfeGE5gBNeWg58H2aJeQEgJ_06574069_09116020000_0229"</span></span>, <span class="hljs-string"><span class="hljs-string">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"2GKTX6NLTgUrE4iy9HtpSSHpZ3G8W4cMfdjyvvnc21dx"</span></span> }</code> </pre> <br><br>  “键”是新游戏的<b>游戏ID</b> 。 其余数据包含在“值”字段中。 这些条目存储在智能合约的“ <b>数据”</b>选项卡中： <br><br><img src="https://habrastorage.org/webt/5l/fi/ur/5lfiurrw9f4mhxvttifuzjue5xm.png"><br><img src="https://habrastorage.org/webt/33/8q/tq/338qtq74ja1r7vylnmx_ska0aoy.png"><br><br>  5.服务器通过区块链API查找发送的交易（新游戏）。 游戏ID已记录在区块链中，因此无法更改或删除它。 <br><br>  6.服务器形成一个撤回功能（gameId，rsaSign），例如： <br><br> 撤回（«FwsuaaShC6DMWdSWQ5osGWtYkVbTEZrsnxqDbVx5oUpq»，«BASE64：Gy69dKdmXUEsAmUrpoWxDLTQOGj5 / qO8COA + QjyPVYTAjxXYvEESJbSiCSBRRCOAliqCWwaS161nWqoTL / TltiIvw3nKyd4RJIBNSIgEWGM1tEtNwwnRwSVHs7ToNfZ2Dvk / GgPUqLFDSjnRQpTHdHUPj9mQ8erWw0r6cJXrzfcagKg3yY / 0wJ6AyIrflR35mUCK4cO7KumdvC9Mx0hr / ojlHhN732nuG8ps4CUlRw3CkNjNIajBUlyKQwpBKmmiy3yJa / QM5PLxqdppmfFS9y0sxgSlfLOgZ51xRDYuS8NViOA7c1JssH48ZtDbBT5yqzRJXs3RnmZcMDr / q0x6Bg ==»） <br><br>  7.服务器将调用事务发送到智能合约（广播InvocationTx）。 交易包含对生成的提现函数（gameId，rsaSign）的调用： <br><br><img src="https://habrastorage.org/webt/5s/qv/a9/5sqva9dije7xwufaactablctnic.png"><br><br> 该功能包含<b>游戏ID</b>和唯一ID的RSA签名。 签名结果不可更改。 <br><br>  <i>这是什么意思？</i> <i><br></i> <br><br> 我们采用相同的值（游戏ID），并对其应用RSA签名方法。  RSA算法就是这样工作的。 由于<b>游戏ID</b>和RSA算法的结果未知，因此无法操纵最终数字。 尝试猜测一个数字也毫无意义。 <br><br>  8.区块链收到运行提现功能的交易（gameId，rsaSign）。 <br><br>  9.在撤回函数（gameId，rsaSign）内部调用了GenerateRandIn函数。 这是一个随机数生成器。 <br><br><pre> <code class="scala hljs"># <span class="hljs-meta"><span class="hljs-meta">@return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ... <span class="hljs-number"><span class="hljs-number">100</span></span> func <span class="hljs-type"><span class="hljs-type">GenerateRandInt</span></span> (gameId,rsaSign) = { # verify <span class="hljs-type"><span class="hljs-type">RSA</span></span> signature to proof random let rsaSigValid = rsaVerify (<span class="hljs-type"><span class="hljs-type">SHA256</span></span>, toBytes(gameId), rsaSign, <span class="hljs-type"><span class="hljs-type">RSAPUBLIC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rsaSigValid) then { let rand = (toInt(sha256(rsaSign)) % <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; rand)) then ((<span class="hljs-number"><span class="hljs-number">-1</span></span> * rand) + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (rand + <span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (<span class="hljs-string"><span class="hljs-string">"Invalid RSA signature"</span></span>) }</code> </pre> <br><br>  <b>rand</b>是一个随机数 <br><br> 首先，使用作为RSA签名结果的字符串。 然后，它通过SHA-256（ <b>sha256（rsaSign）</b> ）进行<b>哈希处理</b> 。 <br><br> 我们无法预测签名结果和后续的哈希。 因此，不可能影响其生成。 为了获得特定范围内的数字（例如1到100），将转换函数转换为Int和％100（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模</a>模拟）。 <br><br> 在本文的开头，我们提到了<b>rsaVerify（）</b>函数，该函数允许通过私钥针对公共密钥检查RSA签名的有效性。 这是GenerateRandInt（gameId，rsaSign）的一部分： <br><br>  rsaVerify（SHA256，toBytes（gameId），rsaSign，RSAPUBLIC） <br><br> 首先，使用RSAPUBLIC公钥和rsaSign字符串。 检查签名的有效性。 如果检查成功，则生成数字。 否则，系统认为签名无效（无效的RSA签名）。 <br><br> 服务器必须使用私钥对游戏ID进行签名，并在2880个块内发送有效的RSA签名。 在部署智能合约时管理该选项。 如果在规定时间内没有任何反应，则用户获胜。 在这种情况下，奖励必须由用户独立发送。 事实证明，作弊对服务器无利可图，因为这会导致损失。 下面有一个例子。 <br><br><img src="https://habrastorage.org/webt/cu/rb/zr/curbzrndrasdpotisjadetjdr_w.png"><br><br> 用户<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">玩骰子滚轮</a> 。 他从6个立方体面中选择2个，并下注14个WAVES。 如果服务器未在设定的时间（2,880块）内向智能合约发送有效的RSA签名，则用户将收到34.44 WAVES。 <br><br> 为了生成数字，我们使用Oracle，即外部系统而不是区块链。 服务器为游戏ID实现RSA签名。 智能合约检查签名的有效性并确定获胜者。 如果服务器什么都不发送，则用户将自动获胜。 <br><br> 该方法确保了操作在技术上是不可能的。 所有Tradisys游戏均基于上述算法-确保我们的游戏公平，透明。 一切都可以公开审核以确保诚实。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN464395/">https://habr.com/ru/post/zh-CN464395/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN464383/index.html">我如何在一个有直接手森林（tslint，更漂亮的设置等）的项目中将事物整理好</a></li>
<li><a href="../zh-CN464385/index.html">Python是C ++的终极案例。 第1/2部分</a></li>
<li><a href="../zh-CN464387/index.html">斯堪的纳维亚传奇中的俄罗斯足迹</a></li>
<li><a href="../zh-CN464391/index.html">来自黑客大会的10篇有趣的报道</a></li>
<li><a href="../zh-CN464393/index.html">如何找到编程课程以及什么是就业保障</a></li>
<li><a href="../zh-CN464399/index.html">R中的Web抓取，第2部分。通过并行计算和使用Rcrawler软件包加快过程</a></li>
<li><a href="../zh-CN464403/index.html">推送到GitLab存储库时如何在shell运行器上运行Java项目</a></li>
<li><a href="../zh-CN464405/index.html">Python是C ++的终极案例。 第2/2部分</a></li>
<li><a href="../zh-CN464407/index.html">世界上最大的视频监控系统如何工作</a></li>
<li><a href="../zh-CN464409/index.html">19世纪政治如何影响当今的数据中心位置</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>