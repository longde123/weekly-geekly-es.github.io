<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏻 🧑🏼‍🤝‍🧑🏻 🛫 JS的工作方式：Shadow DOM技术和Web组件 🧛🏼 🍰 🚣🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[建议阅读]周期的其他19个部分  第1部分： 引擎概述，运行时机制，调用堆栈 
 第2部分： 关于V8内部和代码优化 
 第3部分： 管理内存，四种类型的内存泄漏并进行处理 
 第4部分： 事件循环，异步和通过异步/等待改进代码的五种方法 
 第5部分： WebSocket和HTTP / 2 + ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JS的工作方式：Shadow DOM技术和Web组件</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415881/"><div class="spoiler">  <b class="spoiler_title">[建议阅读]周期的其他19个部分</b> <div class="spoiler_text"> 第1部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引擎概述，运行时机制，调用堆栈</a> <br> 第2部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于V8内部和代码优化</a> <br> 第3部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">管理内存，四种类型的内存泄漏并进行处理</a> <br> 第4部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件循环，异步和通过异步/等待改进代码的五种方法</a> <br> 第5部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebSocket和HTTP / 2 + SSE。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选择什么？</a> <br> 第6部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebAssembly的功能和范围</a> <br> 第7部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web Workers和五个使用方案</a> <br> 第八部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">服务人员</a> <br> 第9部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web推送通知</a> <br> 第10部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用MutationObserver跟踪DOM中的更改</a> <br> 第11部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网页呈现引擎和优化其性能的技巧</a> <br> 第12部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浏览器</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络子系统，优化其性能和安全性</a> <br> 第12部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浏览器</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络子系统，优化其性能和安全性</a> <br> 第13部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CSS和JavaScript动画</a> <br> 第14部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：抽象语法树，解析及其优化</a> <br> 第15部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：类和继承，Babel和TypeScript中的转译</a> <br> 第16部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：存储</a> <br> 第17部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：Shadow DOM技术和Web组件</a> <br> 第18部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：WebRTC和P2P通讯机制</a> <br> 第19部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：自定义元素</a> </div></div><br> 今天，在翻译了17篇专门介绍与JavaScript相关联的所有功能的材料时，我们将讨论Web组件和旨在与之合作的各种标准。 特别要注意Shadow DOM技术。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/8k/li/z5/8kliz5q5jcynt6ggr2rqa-fancc.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">复习</font> </h2><br>  Web组件是旨在描述适用于重用的新DOM元素的API系列。 这些元素的功能与其余代码分开；它们可以在我们自己设计的Web应用程序中使用。 <br><br> 与Web组件相关的技术有四种： <br><br><ul><li> 影子DOM（影子DOM） </li><li>  HTML模板（HTML模板） </li><li> 自定义元素 </li><li>  HTML导入（HTML导入） </li></ul><br> 在本文中，我们将讨论Shadow DOM技术，该技术旨在创建基于组件的应用程序。 它提供了解决您可能已经遇到的常见Web开发问题的方法： <br><br><ul><li> DOM隔离：组件具有隔离的DOM树（这意味着<code>document.querySelector()</code>命令将不允许访问组件的影子DOM中的节点）。 另外，由于DOM组件是隔离的，因此它简化了Web应用程序中的CSS选择器系统，这使开发人员可以在不同的组件中使用相同的通用标识符和类名，而不必担心可能发生名称冲突。 </li><li>  CSS隔离：在影子DOM中描述的CSS规则仅限于此。 这些样式不会离开元素，也不会与其他页面样式混合。 </li><li> 组成：为基于标记的组件开发声明性API。 </li></ul><br><h2>  <font color="#3AC1EF">Shadow DOM技术</font> </h2><br> 假定您已经熟悉DOM和相关API的概念。 如果不是这样，您可以阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>材料。 <br><br>  Shadow DOM与常规DOM基本相同，但有两个区别： <br><br><ul><li> 首先是Shadow DOM的创建和使用方式，尤其是有关Shadow DOM与页面其余部分的关系。 </li><li> 第二个是Shadow DOM与页面有关的行为。 </li></ul><br> 使用DOM时，将创建DOM节点，这些节点作为子级连接到页面的其他元素。 在Shadow DOM技术的情况下，创建了一个隔离的DOM树，该树连接了该元素，但与它的普通子元素分离。 <br><br> 这个孤立的子树称为影子树。 这样的树所附加的元素称为影子主机。 事实证明，添加到影子DOM子树的所有内容都是其所附着元素的本地元素，包括使用<code>&lt;style&gt;</code>标记描述的<code>&lt;style&gt;</code> 。 这就是通过Shadow DOM技术提供CSS隔离的方式。 <br><br><h2>  <font color="#3AC1EF">创建一个影子DOM</font> </h2><br> 影子根是附加到宿主元素的文档的一部分。 将影子根元素附加到该元素后，该元素将获取影子DOM。 为了为某个元素创建影子DOM，您需要使用<code>element.attachShadow()</code>形式的命令： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> header = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'header'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadowRoot = header.attachShadow({<span class="hljs-attr"><span class="hljs-attr">mode</span></span>: <span class="hljs-string"><span class="hljs-string">'open'</span></span>}); shadowRoot.appendChild(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'&lt;p&gt; Shadow DOM &lt;/p&gt;'</span></span>);</code> </pre> <br> 应该注意的是， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a> Shadow DOM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规范中</a> ，列出了DOM影子子树无法连接的元素列表。 <br><br><h2>  <font color="#3AC1EF">Shadow DOM中的合成</font> </h2><br> 组合是Shadow DOM的最重要功能之一，它是创建Web应用程序的一种方法，该方法用于编写HTML代码。 在此过程中，程序员将组成页面的各种构建块（元素）组合在一起，并在必要时将它们相互嵌套。 例如，这些元素是诸如<code>&lt;div&gt;</code> ， <code>&lt;header&gt;</code> ， <code>&lt;form&gt;</code>类的元素，以及用于创建Web应用程序界面的其他元素，包括那些充当其他元素的容器的元素。 <br><br> 组合确定元素的功能，例如<code>&lt;select&gt;</code> ， <code>&lt;form&gt;</code>和<code>&lt;video&gt;</code> ，以包括其他HTML元素作为子元素，以及组织由不同元素组成的此类结构的特殊行为的能力。 <br><br> 例如， <code>&lt;select&gt;</code>元素具有用于以下拉列表的形式呈现<code>&lt;option&gt;</code>元素的装置，该下拉列表具有该列表的元素的预定内容。 <br><br> 考虑组成元素时使用的Shadow DOM的某些功能。 <br><br><h2>  <font color="#3AC1EF">轻度dom</font> </h2><br> 轻型DOM是由组件用户创建的标记。 此DOM在组件的影子DOM之外，并且是组件的子代。 想象一下，您创建了一个名为<code>&lt;better-button&gt;</code>的自定义组件，该组件扩展了标准HTML <code>&lt;button&gt;</code>元素的功能，并且用户需要向该新元素添加图像和一些文本。 看起来是这样的： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  img  span -  Light DOM  extended-button --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"boot.png"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>Launch<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  <code>&lt;extended-button&gt;</code>元素是程序员自己描述的自定义组件，该组件内的HTML代码是其Light DOM-该组件的用户向其添加的内容。 <br><br> 本示例中的影子DOM是<code>&lt;extended-button&gt;</code>组件。 这是组件的本地对象模型，它描述了与CSS外部世界隔离的内部结构，并封装了组件的实现细节。 <br><br><h2>  <font color="#3AC1EF">扁平化的dom</font> </h2><br>  Flattened DOM树表示浏览器如何将Light DOM和Shadow DOM结合在一起在屏幕上显示组件。 在开发人员工具中可以看到的就是这样的DOM树，它就是在页面上显示的。 它可能看起来像这样： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span> #shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined">…</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"boot.png"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>Launch<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">模式</font> </h2><br> 如果必须在网页的HTML标记中不断使用相同的结构，则使用某个模板而不是一次又一次地编写相同的代码将很有用。 以前可以做到这一点，但是现在由于HTML <code>&lt;template&gt;</code>的出现，大大简化了一切，该<code>&lt;template&gt;</code>对现代浏览器提供了出色的支持。 该元素及其内容未显示在DOM中，但是您可以从JavaScript中使用它。 考虑一个简单的例子： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> Paragraph content. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 如果将此设计包含在页面的HTML标记中，则它所描述的<code>&lt;p&gt;</code>标记的内容在明确地附加到文档的DOM之前不会出现在屏幕上。 例如，它可能看起来像这样： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> template = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'my-paragraph'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> templateContent = template.content; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(templateContent);</code> </pre> <br> 还有其他方法可以达到相同的效果，但是，正如已经提到的，模板是非常方便的标准工具，享有良好的浏览器支持。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5dc/501/54c/5dc50154ca3bc462d1e9285334fe462e.png"></div><br>  <i><font color="#999999">HTML浏览器对现代浏览器的支持</font></i> <br><br> 模板本身是有用的，但与自定义元素一起使用时，其功能已完全公开。 自定义元素是单独材料的主题，现在，要了解正在发生的事情，就足以考虑到<code>customElement</code>浏览器<code>customElement</code>允许程序员描述自己的HTML标签并指定使用这些标签创建的元素在屏幕上的外观。 <br><br> 定义一个使用我们的模板作为其影子DOM内容的Web组件。 将此新元素称为<code>&lt;my-paragraph&gt;</code> ： <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-paragraph', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{  constructor() {    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();    let template = document.getElementById(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-paragraph');    let templateContent = template.content;    const shadowRoot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.attachShadow({mode: <span class="hljs-symbol"><span class="hljs-symbol">'ope</span></span>n'}).appendChild(templateContent.cloneNode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } });</code> </pre> <br> 要注意的最重要的事情是，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.cloneNode（）</a>方法制作的模板内容的克隆附加到影子根。 <br><br> 由于我们将模板的内容附加到影子DOM，因此可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">&lt;style&gt;</a>元素的模板中包含一些样式信息，然后将其封装在user元素中。 如果您使用常规DOM而不是Shadow DOM，那么整个方案将无法按预期工作。 <br><br> 例如，可以通过在模板中包含样式信息来对其进行如下修改： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css">   </span><span class="hljs-selector-tag"><span class="css"><span class="hljs-selector-tag">p</span></span></span><span class="css"> {     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: white;     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background-color</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">#666</span></span></span><span class="css">;     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">padding</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">5px</span></span></span><span class="css">;   } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Paragraph content. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 现在，我们描述的用户元素可以在普通网页上使用，如下所示： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">插槽</font> </h2><br>  HTML模板有几个缺点，主要的缺点是模板包含静态标记，例如，不允许使用其帮助显示某些变量的内容，以使其与使用标准HTML的方式相同。模式。 这是<code>&lt;slot&gt;</code>标记所在的<code>&lt;slot&gt;</code> 。 <br><br> 插槽可以看作是占位符，可让您在模板中包含自己的HTML代码。 这使您可以创建通用HTML模板，然后通过向其添加插槽来使它们可自定义。 <br><br> 使用<code>&lt;slot&gt;</code>查看以上模板的外观： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Default text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 如果在标记中包含元素时未指定插槽的内容，或者浏览器不支持使用插槽，则<code>&lt;my-paragraph&gt;</code>元素将仅包含<code>Default text</code>的标准内容。 <br><br> 为了设置插槽的内容，您需要在<code>&lt;my-paragraph&gt;</code>元素中包含带有<code>slot</code>属性的HTML代码，该属性的值等效于应放置此代码的插槽的名称。 <br><br> 和以前一样，可以有任何东西。 例如： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Let's have some different text!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 可以放置在插槽中的元素称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Slotable</a>元素。 <br><br> 请注意，在前面的示例中，我们在插槽中添加了<code>&lt;span&gt;</code>元素，这就是所谓的sloted元素。 它具有为<code>slot</code>属性分配的值<code>my-text</code> ，即与模板中描述的插槽的<code>name</code>属性中使用的值相同的值。 <br><br> 处理完上述标记后，浏览器将创建以下Flattened DOM树： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> #shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Let's have some different text!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 注意元素<code>#shadow-root</code> 。 这只是影子DOM存在的一个指标。 <br><br><h2>  <font color="#3AC1EF">程式化</font> </h2><br> 使用Shadow DOM技术的组件可以在通用的基础上设置样式，它们可以定义自己的样式，或者以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自定义CSS属性</a>的形式提供挂钩，以允许组件用户覆盖默认样式。 <br><br><h3>  <font color="#3AC1EF">components组件中描述的样式</font> </h3><br>  CSS隔离是Shadow DOM技术最显着的功能之一。 即，我们正在谈论以下内容： <br><br><ul><li> 放置了相应组件的页面的CSS选择器不会影响其内部内容。 </li><li> 组件中描述的样式不会影响页面。 它们被隔离在宿主元素中。 </li></ul><br> 影子DOM中使用的CSS选择器在本地应用于组件内容。 实际上，这意味着可以在不同的组件中重用相同的标识符和类名，而无需担心名称冲突。 简单的CSS选择器还意味着使用它们的解决方案具有更好的性能。 <br><br> 看一下<code>#shadow-root</code>元素，它定义了一些样式： <br><br><pre> <code class="hljs xml">#shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#container</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background</span></span></span><span class="css">: white; } </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#container-items</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">display</span></span></span><span class="css">: inline-flex; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container-items"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 以上所有样式都是<code>#shadow-root</code>本地样式。 <br><br> 另外，您可以使用<code>&lt;link&gt;</code>标记在<code>#shadow-root</code>包含外部样式表。 这样的样式也将是本地的。 <br><br><h3>  <font color="#3AC1EF">▍伪类：主机</font> </h3><br>  <code>:host</code>伪<code>:host</code>允许您访问包含影子DOM树的元素并设置此元素的样式： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">display</span></span></span><span class="css">: block; </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*       display: inline */</span></span></span><span class="css"> } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 使用<code>:host</code>伪<code>:host</code> ，请记住，父页面的规则比使用该伪类的元素中指定的规则具有更高的优先级。 这使用户可以从外部覆盖其中定义的主机组件样式。 另外， <code>:host</code>伪<code>:host</code>仅在影子根元素的上下文中起作用；您不能在影子DOM树之外使用它。 <br><br> 伪类的功能形式： <code>:host(&lt;selector&gt;)</code> ，如果与指定的<code>&lt;selector&gt;</code>元素匹配，则可以访问host元素。 这是允许组件封装响应用户操作或组件状态更改的行为的好方法，并允许您根据主机组件设置内部节点的样式： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0.4</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(</span></span></span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:hover)</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">1</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(</span></span></span><span class="hljs-selector-attr"><span class="css"><span class="hljs-selector-attr">[disabled]</span></span></span><span class="css">) { </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*      -  disabled. */</span></span></span><span class="css">   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background</span></span></span><span class="css">: grey;   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">pointer-events</span></span></span><span class="css">: none;   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0.4</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(.pink)</span></span></span><span class="css"> &gt; </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#tabs</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: pink; </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*     #tabs   -  class="pink". */</span></span></span><span class="css"> } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">with带有伪类的主题和元素：host-context（&lt;selector&gt;）</font> </h3><br> 如果<code>:host-context(&lt;selector&gt;)</code>伪<code>:host-context(&lt;selector&gt;)</code>与host元素或其任何祖先与指定的<code>&lt;selector&gt;</code>元素匹配，则与host元素匹配。 <br><br> 此功能的常见用例是使用主题设置元素样式。 例如，通常通过将适当的类分配给<code>&lt;html&gt;</code>或<code>&lt;body&gt;</code>标签来使用主题： <br><br><pre> <code class="hljs javascript">&lt;body <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"lightheme"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> … </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 如果此元素是<code>.lightteme</code>的后代， <code>.lightteme</code> ： <code>:host-context(.lightheme)</code>伪<code>:host-context(.lightheme)</code>将应用于<code>&lt;fancy-tabs&gt;</code> ： <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host-context(.lightheme)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: white; }</code> </pre> <br>  <code>:host-context()</code>构造对于应用主题可能有用，但是为此目的，最好使用带有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自定义CSS属性的</a>钩子。 <br><br><h3>  <font color="#3AC1EF">from从外部造型组件的主体元素</font> </h3><br> 可以使用其标签名称作为选择器在外部设置组件的宿主元素的样式： <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">custom-container</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre> <br> 外部样式优先于影子DOM中定义的样式。 <br> 假设用户创建以下选择器： <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">custom-container</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">500px</span></span>; }</code> </pre> <br> 它将覆盖组件本身中定义的规则： <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">300px</span></span>; }</code> </pre> <br> 使用这种方法，您只能样式化组件本身。 如何风格化组件的内部结构？ 自定义CSS属性用于此目的。 <br><br><h3>  <font color="#3AC1EF">using使用自定义CSS属性创建样式挂钩</font> </h3><br> 如果组件的作者使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自定义CSS属性</a>为它们提供样式挂钩，则用户可以自定义组件内部结构的样式。 <br><br> 这种方法基于一种类似于使用<code>&lt;slot&gt;</code>标记时使用的机制的机制，但是在这种情况下，它适用于样式。 <br><br> 考虑一个例子： <br><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- main page --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> custom-container {   margin-bottom: 60px;    - custom-container-bg: black; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">background</span></span></span><span class="hljs-tag">&gt;</span></span>…<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 这是影子DOM树中的内容： <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host(</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[background]</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">var</span></span>( - custom-container-bg, #CECECE); <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; }</code> </pre> <br> 在这种情况下，组件使用黑色作为背景色，因为是由用户指定的。 否则，背景色将为<code>#CECECE</code> 。 <br><br> 作为组件的作者，您有责任告诉其用户可以使用哪些特定的CSS属性。 考虑组件的开放接口的这一部分。 <br><br><h2>  <font color="#3AC1EF">用于插槽的JavaScript API</font> </h2><br>  Shadow DOM API提供了使用插槽的功能。 <br><br><h3>  <font color="#3AC1EF">▍活动时间变更</font> </h3><br> 当放置在插槽中的节点发生更改时，将引发<code>slotchange</code>事件。 例如，如果用户在Light DOM中添加或删除子节点： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shadowRoot.querySelector(<span class="hljs-string"><span class="hljs-string">'#some_slot'</span></span>); slot.addEventListener(<span class="hljs-string"><span class="hljs-string">'slotchange'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Light DOM change'</span></span>); });</code> </pre> <br> 要跟踪Light DOM中的其他类型的更改，可以在元素的构造函数中使用<code>MutationObserver</code> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关此内容的更多信息。 <br><br><h3>  <font color="#3AC1EF">▍方法AssignedNodes（）</font> </h3><br> 如果您需要知道哪些元素与该插槽关联，则<code>assignedNodes()</code>方法可能会很有用。 调用<code>slot.assignedNodes()</code>方法可让您确切地找到插槽显示的元素。 使用<code>{flatten: true}</code>选项可以获取插槽的标准内容（如果未连接任何节点，则显示该内容）。 <br><br> 考虑一个例子： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'slot1'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Default content<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 想象一下，该插槽位于<code>&lt;my-container&gt;</code>组件中。 <br><br> 让我们看一下该组件的各种用法，以及调用<code>assignedNodes()</code>方法时将返回的内容。 <br><br> 在第一种情况下，我们将自己的内容添加到广告位： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"slot1"</span></span></span><span class="hljs-tag">&gt;</span></span> container text <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 在这种情况下， <code>assignedNodes()</code>调用将返回<code>[ container text ]</code> 。 请注意，此值是节点数组。 <br><br> 在第二种情况下，我们不使用自己的内容填充广告位： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  <code>assignedNodes()</code>调用将返回一个空数组- <code>[]</code> 。 <br><br> 但是，如果将<code>{flatten: true}</code>参数传递给此方法，则对同一元素调用它会返回其默认内容： <code>[ Default content ]</code> <p> <code>[ Default content ]</code> </p>  <code>[ Default content ]</code> 。 <br><br> 另外，为了访问插槽中的元素，可以调用<code>assignedNodes()</code>以让您知道元素分配给哪个组件插槽。 <br><br><h2>  <font color="#3AC1EF">事件模型</font> </h2><br> 我们来谈谈在影子DOM树中弹出的事件弹出时会发生什么。 设置事件的目的时要考虑到Shadow DOM技术支持的封装。 当事件被重定向时，它看起来好像来自组件本身，而不是来自其内部元素，该内部元素位于影子DOM树中，并且是该组件的一部分。 <br><br> 这是从DOM阴影树传递的事件列表（此行为不是某些事件的特征）： <br><br><ul><li> 焦点事件： <code>blur</code> ， <code>focus</code> ， <code>focusin</code> ， <code>focusout</code> 。 </li><li> 鼠标事件： <code>click</code> ， <code>dblclick</code> ， <code>mousedown</code> ， <code>mouseenter</code> ， <code>mousemove</code>等。 </li><li> 车轮事件： <code>wheel</code> 。 </li><li> 输入事件： <code>beforeinput</code> ， <code>input</code> 。 </li><li> 键盘事件： <code>keydown</code> ， <code>keyup</code> 。 </li><li> 合成事件： <code>compositionstart</code> ， <code>compositionupdate</code> ， <code>compositionend</code> 。 </li><li> 拖动事件： <code>dragstart</code> ， <code>drag</code> ， <code>dragend</code> ， <code>drop</code>等等。 </li></ul><br><h2>  <font color="#3AC1EF">自定义事件</font> </h2><br> 默认情况下，用户事件不会离开DOM阴影树。 如果要触发事件，并希望它离开Shadow DOM，则需要为其提供参数<code>bubbles: true</code>和<code>composed: true</code> 。 这是此类事件的调用的外观： <br><br><pre> <code class="hljs axapta">var <span class="hljs-keyword"><span class="hljs-keyword">container</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shadowRoot.querySelector(<span class="hljs-string"><span class="hljs-string">'#container'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">container</span></span>.dispatchEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">'containerchanged'</span></span>, {bubbles: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, composed: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>}));</code> </pre> <br><h2>  <font color="#3AC1EF">支持Shadow DOM浏览器</font> </h2><br> 为了确定浏览器是否支持Shadow DOM技术，您可以检查<code>attachShadow</code>的存在： <br><br><pre> <code class="hljs erlang-repl">const supportsShadowDOMV1 = !!HTMLElement.prototype.attachShadow;</code> </pre> <br> 这是有关各种浏览器如何支持该技术的信息。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/d78/c47/bead78c47c464b5059576df077613803.png"></div><br>  <i><font color="#999999">在浏览器中支持Shadow DOM技术</font></i> <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 影子DOM树的行为不像常规DOM树。 特别地，根据该材料的作者，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SessionStack</a>库中，这是通过跟踪DOM更改的过程的复杂性来表达的，该信息需要有关哪个信息的信息才能再现页面所发生的情况。 即， <code>MutationObserver</code>用于跟踪更改。 在这种情况下，DOM影子树不会在全局范围内引发<code>MutationObserver</code>事件，这导致需要使用特殊方法来处理使用Shadow DOM的组件。 <br><br>  ,     -  Shadow DOM,     ,   , ,     . <br><br>  <b>亲爱的读者们！</b>    -,     Shadow DOM? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN415881/">https://habr.com/ru/post/zh-CN415881/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN415865/index.html">Markdown知识库（或博客或项目文档）</a></li>
<li><a href="../zh-CN415867/index.html">Y组合投资者学校：Ron Conway</a></li>
<li><a href="../zh-CN415871/index.html">上周第321天（2018年6月25日至7月1日）前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN415875/index.html">语言学家的话：如果计算机说得更好，该怎么办</a></li>
<li><a href="../zh-CN415879/index.html">7月2日至8日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN415887/index.html">什么样的蜘蛛机器人飞越体育场并射击足球。 采访Robycam的创造者</a></li>
<li><a href="../zh-CN415891/index.html">有哪些续集游戏很棒？</a></li>
<li><a href="../zh-CN415893/index.html">如何使在Linux / Docker上运行的Java流程简单明了</a></li>
<li><a href="../zh-CN415895/index.html">编程中最重要的模式</a></li>
<li><a href="../zh-CN415897/index.html">记录PostgreSQL数据库的功能。 第二部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>