<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ™ğŸ½ ğŸ™…ğŸ½ Node.js 10.5 Release: Multithreading sofort einsatzbereit ğŸ¤œğŸ» ğŸ‘©ğŸ½â€ğŸš€ ğŸ‘¨ğŸ¼â€âš–ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Letzte Woche wurde Node.js Version 10.5.0 verÃ¶ffentlicht, die eine Innovation enthÃ¤lt, deren Bedeutung kaum Ã¼berschÃ¤tzt werden kann - Multithreading-U...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js 10.5 Release: Multithreading sofort einsatzbereit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415165/"><p><img src="https://habrastorage.org/webt/kp/7y/65/kp7y659ir2whakhs1imc7bv973a.png"></p><br><p>  Letzte Woche wurde Node.js Version 10.5.0 verÃ¶ffentlicht, die eine Innovation enthÃ¤lt, deren Bedeutung kaum Ã¼berschÃ¤tzt werden kann - Multithreading-UnterstÃ¼tzung in Form des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Worker_Threads-</a> Moduls.  Ich werde sofort eine Reservierung vornehmen. Die API befindet sich im experimentellen Stadium und kann sich daher Ã¤ndern. Jetzt kÃ¶nnen Sie jedoch einen ersten Eindruck hinterlassen und sich ein Bild von den Prinzipien und Technologien machen, die in ihrer Grundlage festgelegt sind.  Und wenn Sie einen Wunsch haben, nehmen Sie an der Fertigstellung der BenutzeroberflÃ¤che, dem Schreiben von Code oder der Behebung von Fehlern teil (Liste der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Probleme</a> ). </p><a name="habracut"></a><br><h2 id="istoriya-poyavleniya">  Erscheinungsgeschichte </h2><br><p> WÃ¤hrend des gesamten Lebens von Node.j bestand die einzige MÃ¶glichkeit, das Computing zu parallelisieren, darin, einen neuen Prozess zu starten, beispielsweise mithilfe des Cluster-Moduls.  Aus vielen GrÃ¼nden eignet sich dieser Ansatz nicht fÃ¼r Entwickler, insbesondere weil er dazu fÃ¼hrt, dass der ausfÃ¼hrbare Code von Node.j mit allen integrierten Modulen wiederholt in den Arbeitsspeicher des Computers geladen wird. Dies ist eine ineffiziente Methode, um Ressourcen zu verbrauchen. </p><br><p>  Die Diskussion Ã¼ber die Implementierung von Multithreading in Node.js beruhte jedoch immer auf der KomplexitÃ¤t von V8 und einer Vielzahl von Unbekannten: wie man native Module verbindet, Speicher gemeinsam nutzt, zwischen Threads kommuniziert und vieles mehr.  Und wÃ¤hrend die Entwickler nach einer Seite suchten, um sich dem Thema im Web zu nÃ¤hern, wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Worker-API</a> erfolgreich implementiert, was in der Anfangsphase zu einer Richtlinie wurde.  Die Entwicklung begann mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Addaleax</a> und wurde von der Community Ã¼bernommen. </p><br><p>  Die aktive Arbeit wurde in dem Jahr ausgefÃ¼hrt, in dem die Entwurfsanforderungen festgelegt wurden und die API ihre eigenen Node.js-spezifischen Funktionen erwarb. Das Modul selbst hieÃŸ worker_threads.  Im Folgenden werde ich worker_threads kurz allgemein beschreiben. FÃ¼r eine detaillierte Studie empfehle ich Ihnen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Dokumentationsseite</a> zu besuchen. </p><br><h2 id="opisanie">  Beschreibung </h2><br><p>  Wie oben erwÃ¤hnt, besteht das Ziel dieser Entwicklung darin, die ProduktivitÃ¤t zu verbessern, indem die Last auf separate Threads innerhalb desselben Prozesses verteilt wird, anstatt mehrere Prozesse zu starten.  Daher unterstÃ¼tzen Threads die Verbindung aller verfÃ¼gbaren Module zum Hauptprozess (derzeit werden native Module nicht unterstÃ¼tzt). </p><br><p>  Wie in der Worker-API wird die Interaktion zwischen dem Haupt- und dem untergeordneten Stream durch Ãœbertragen Ã¼bertragbarer Objekte Ã¼ber postMessage ausgefÃ¼hrt, wodurch die Probleme des gleichzeitigen Zugriffs vermieden werden, obwohl zusÃ¤tzliche Speicherzugriffe zum Kopieren von Daten erforderlich sind.  In diesem Fall behalten Objekte wie SharedArrayBuffer ihr Verhalten bei und verursachen keine Neuzuweisung. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MessageChannel</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MessagePort</a> wurden aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAPI Ã¼bernommen</a> , mit der Sie isolierte Messaging-KanÃ¤le erstellen und zwischen Threads Ã¼bertragen kÃ¶nnen. </p><br><p>  Um worker_threads in Aktion zu testen, mÃ¼ssen Sie beim Starten des Prozesses ein spezielles Flag angeben: </p><br><pre><code class="bash hljs">node --experimental-worker main.js</code> </pre> <br><h2 id="primer">  Beispiel </h2><br><p>  Da sich die API mÃ¶glicherweise noch Ã¤ndert, werde ich sie nicht beschreiben, aber ich werde ein Beispiel fÃ¼r einen Nachrichtenaustausch zwischen dem Ã¼bergeordneten und dem untergeordneten Thread geben, in dem der untergeordnete Thread seine threadId Ã¼ber MessagePort meldet und beendet. </p><br><h3 id="glavnyy-potok">  Hauptstrom </h3><br><p>  Beispielcode fÃ¼r den Hauptthread: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// main.js const {Worker} = require('worker_threads'); const worker = new Worker(__dirname + '/worker.js'); worker.on('online', () =&gt; { console.log('Worker ready'); }); worker.on('message', (msg) =&gt; { console.log('Worker message:', msg); }); worker.on('error', (err) =&gt; { console.error('Worker error:', err); }); worker.on('exit', (code) =&gt; { console.log('Worker exit code:', code); });</span></span></code> </pre> <br><h3 id="docherniy-potok">  Untergeordneter Stream </h3><br><p>  Der untergeordnete Thread bleibt so lange bestehen, bis seine Ereignisschleife leer ist.  Daher <code>worker.js</code> Thread unmittelbar nach der <code>worker.js</code> des Codes aus <code>worker.js</code> automatisch geschlossen.  FÃ¼r die Kommunikation mit dem Ã¼bergeordneten Element wird parentPort verwendet: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// worker.js const {threadId, parentPort} = require('worker_threads'); parentPort.postMessage(`Hello from thread #${threadId}.`); // Exit happens here</span></span></code> </pre> <br><p>  Im untergeordneten Thread wird das Prozessobjekt Ã¼berschrieben, und sein Verhalten unterscheidet sich geringfÃ¼gig vom Prozessverhalten im Ã¼bergeordneten Thread.  Insbesondere gibt es keine MÃ¶glichkeit, auf SIGNINT-Signale zu reagieren, die Werte von process.env zu Ã¤ndern, und das Aufrufen von <code>process.exit</code> stoppt nur den Worker, aber nicht den gesamten Prozess. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Die Mitarbeiter werden die Erstellung von Anwendungen, die die Interaktion zwischen parallelen ausfÃ¼hrbaren Codeabschnitten erfordern, erheblich vereinfachen und, was besonders wichtig ist, die Kommunikation und Flusskontrolle am offensichtlichsten machen.  AuÃŸerdem kÃ¶nnen plattformspezifische EinschrÃ¤nkungen vermieden werden, die durch den Unterschied zwischen Windows und Unix verursacht werden.  Ich bin sicher, dass die sich bietenden MÃ¶glichkeiten neue Entwickler anziehen werden, die sich noch nicht fÃ¼r Node.js entschieden haben.  Ãœberwachen Sie in der Zwischenzeit weiterhin die Ã„nderungen und stellen Sie eine Verbindung zum API-Entwicklungsprozess <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Repository her</a> . </p><br><h2 id="ssylki">  Referenzen </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Worker_threads-Dokumentation</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Foto von</a> Paul Smith. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415165/">https://habr.com/ru/post/de415165/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415093/index.html">PVP: Warum Leim intravenÃ¶s injizieren?</a></li>
<li><a href="../de415153/index.html">Ideale Anforderungen kommen zurÃ¼ck</a></li>
<li><a href="../de415155/index.html">Leistung in iOS oder wie man den Hauptthread auslagert. Teil 1</a></li>
<li><a href="../de415159/index.html">AnkÃ¼ndigung der DevOps-Konferenz DevOops 2018</a></li>
<li><a href="../de415163/index.html">Drahtloses Netzwerk in einer speziell geschÃ¼tzten und speziell abgeschirmten pharmazeutischen Fabrik an einigen Orten in Russland</a></li>
<li><a href="../de415167/index.html">Offene Lektion â€Multithreading in Java. Grundlegende Synchronisationsprimitive Â»</a></li>
<li><a href="../de415169/index.html">Komprimierung und Deduplizierung: Reduzieren Sie die GrÃ¶ÃŸe des E-Mail-Archivs und der Sicherung mithilfe des ZxPowerstore-Winters</a></li>
<li><a href="../de415171/index.html">Reflexionsgesetze in Go</a></li>
<li><a href="../de415175/index.html">Interview mit Augmented World Expo Member</a></li>
<li><a href="../de415177/index.html">Willkommen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>