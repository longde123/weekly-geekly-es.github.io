<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍞 🙏🏽 🙅🏽 Node.js 10.5 Release: Multithreading sofort einsatzbereit 🤜🏻 👩🏽‍🚀 👨🏼‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Letzte Woche wurde Node.js Version 10.5.0 veröffentlicht, die eine Innovation enthält, deren Bedeutung kaum überschätzt werden kann - Multithreading-U...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js 10.5 Release: Multithreading sofort einsatzbereit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415165/"><p><img src="https://habrastorage.org/webt/kp/7y/65/kp7y659ir2whakhs1imc7bv973a.png"></p><br><p>  Letzte Woche wurde Node.js Version 10.5.0 veröffentlicht, die eine Innovation enthält, deren Bedeutung kaum überschätzt werden kann - Multithreading-Unterstützung in Form des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Worker_Threads-</a> Moduls.  Ich werde sofort eine Reservierung vornehmen. Die API befindet sich im experimentellen Stadium und kann sich daher ändern. Jetzt können Sie jedoch einen ersten Eindruck hinterlassen und sich ein Bild von den Prinzipien und Technologien machen, die in ihrer Grundlage festgelegt sind.  Und wenn Sie einen Wunsch haben, nehmen Sie an der Fertigstellung der Benutzeroberfläche, dem Schreiben von Code oder der Behebung von Fehlern teil (Liste der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Probleme</a> ). </p><a name="habracut"></a><br><h2 id="istoriya-poyavleniya">  Erscheinungsgeschichte </h2><br><p> Während des gesamten Lebens von Node.j bestand die einzige Möglichkeit, das Computing zu parallelisieren, darin, einen neuen Prozess zu starten, beispielsweise mithilfe des Cluster-Moduls.  Aus vielen Gründen eignet sich dieser Ansatz nicht für Entwickler, insbesondere weil er dazu führt, dass der ausführbare Code von Node.j mit allen integrierten Modulen wiederholt in den Arbeitsspeicher des Computers geladen wird. Dies ist eine ineffiziente Methode, um Ressourcen zu verbrauchen. </p><br><p>  Die Diskussion über die Implementierung von Multithreading in Node.js beruhte jedoch immer auf der Komplexität von V8 und einer Vielzahl von Unbekannten: wie man native Module verbindet, Speicher gemeinsam nutzt, zwischen Threads kommuniziert und vieles mehr.  Und während die Entwickler nach einer Seite suchten, um sich dem Thema im Web zu nähern, wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Worker-API</a> erfolgreich implementiert, was in der Anfangsphase zu einer Richtlinie wurde.  Die Entwicklung begann mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Addaleax</a> und wurde von der Community übernommen. </p><br><p>  Die aktive Arbeit wurde in dem Jahr ausgeführt, in dem die Entwurfsanforderungen festgelegt wurden und die API ihre eigenen Node.js-spezifischen Funktionen erwarb. Das Modul selbst hieß worker_threads.  Im Folgenden werde ich worker_threads kurz allgemein beschreiben. Für eine detaillierte Studie empfehle ich Ihnen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Dokumentationsseite</a> zu besuchen. </p><br><h2 id="opisanie">  Beschreibung </h2><br><p>  Wie oben erwähnt, besteht das Ziel dieser Entwicklung darin, die Produktivität zu verbessern, indem die Last auf separate Threads innerhalb desselben Prozesses verteilt wird, anstatt mehrere Prozesse zu starten.  Daher unterstützen Threads die Verbindung aller verfügbaren Module zum Hauptprozess (derzeit werden native Module nicht unterstützt). </p><br><p>  Wie in der Worker-API wird die Interaktion zwischen dem Haupt- und dem untergeordneten Stream durch Übertragen übertragbarer Objekte über postMessage ausgeführt, wodurch die Probleme des gleichzeitigen Zugriffs vermieden werden, obwohl zusätzliche Speicherzugriffe zum Kopieren von Daten erforderlich sind.  In diesem Fall behalten Objekte wie SharedArrayBuffer ihr Verhalten bei und verursachen keine Neuzuweisung. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MessageChannel</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MessagePort</a> wurden aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAPI übernommen</a> , mit der Sie isolierte Messaging-Kanäle erstellen und zwischen Threads übertragen können. </p><br><p>  Um worker_threads in Aktion zu testen, müssen Sie beim Starten des Prozesses ein spezielles Flag angeben: </p><br><pre><code class="bash hljs">node --experimental-worker main.js</code> </pre> <br><h2 id="primer">  Beispiel </h2><br><p>  Da sich die API möglicherweise noch ändert, werde ich sie nicht beschreiben, aber ich werde ein Beispiel für einen Nachrichtenaustausch zwischen dem übergeordneten und dem untergeordneten Thread geben, in dem der untergeordnete Thread seine threadId über MessagePort meldet und beendet. </p><br><h3 id="glavnyy-potok">  Hauptstrom </h3><br><p>  Beispielcode für den Hauptthread: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// main.js const {Worker} = require('worker_threads'); const worker = new Worker(__dirname + '/worker.js'); worker.on('online', () =&gt; { console.log('Worker ready'); }); worker.on('message', (msg) =&gt; { console.log('Worker message:', msg); }); worker.on('error', (err) =&gt; { console.error('Worker error:', err); }); worker.on('exit', (code) =&gt; { console.log('Worker exit code:', code); });</span></span></code> </pre> <br><h3 id="docherniy-potok">  Untergeordneter Stream </h3><br><p>  Der untergeordnete Thread bleibt so lange bestehen, bis seine Ereignisschleife leer ist.  Daher <code>worker.js</code> Thread unmittelbar nach der <code>worker.js</code> des Codes aus <code>worker.js</code> automatisch geschlossen.  Für die Kommunikation mit dem übergeordneten Element wird parentPort verwendet: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// worker.js const {threadId, parentPort} = require('worker_threads'); parentPort.postMessage(`Hello from thread #${threadId}.`); // Exit happens here</span></span></code> </pre> <br><p>  Im untergeordneten Thread wird das Prozessobjekt überschrieben, und sein Verhalten unterscheidet sich geringfügig vom Prozessverhalten im übergeordneten Thread.  Insbesondere gibt es keine Möglichkeit, auf SIGNINT-Signale zu reagieren, die Werte von process.env zu ändern, und das Aufrufen von <code>process.exit</code> stoppt nur den Worker, aber nicht den gesamten Prozess. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Die Mitarbeiter werden die Erstellung von Anwendungen, die die Interaktion zwischen parallelen ausführbaren Codeabschnitten erfordern, erheblich vereinfachen und, was besonders wichtig ist, die Kommunikation und Flusskontrolle am offensichtlichsten machen.  Außerdem können plattformspezifische Einschränkungen vermieden werden, die durch den Unterschied zwischen Windows und Unix verursacht werden.  Ich bin sicher, dass die sich bietenden Möglichkeiten neue Entwickler anziehen werden, die sich noch nicht für Node.js entschieden haben.  Überwachen Sie in der Zwischenzeit weiterhin die Änderungen und stellen Sie eine Verbindung zum API-Entwicklungsprozess <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Repository her</a> . </p><br><h2 id="ssylki">  Referenzen </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Worker_threads-Dokumentation</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Foto von</a> Paul Smith. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415165/">https://habr.com/ru/post/de415165/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415093/index.html">PVP: Warum Leim intravenös injizieren?</a></li>
<li><a href="../de415153/index.html">Ideale Anforderungen kommen zurück</a></li>
<li><a href="../de415155/index.html">Leistung in iOS oder wie man den Hauptthread auslagert. Teil 1</a></li>
<li><a href="../de415159/index.html">Ankündigung der DevOps-Konferenz DevOops 2018</a></li>
<li><a href="../de415163/index.html">Drahtloses Netzwerk in einer speziell geschützten und speziell abgeschirmten pharmazeutischen Fabrik an einigen Orten in Russland</a></li>
<li><a href="../de415167/index.html">Offene Lektion „Multithreading in Java. Grundlegende Synchronisationsprimitive »</a></li>
<li><a href="../de415169/index.html">Komprimierung und Deduplizierung: Reduzieren Sie die Größe des E-Mail-Archivs und der Sicherung mithilfe des ZxPowerstore-Winters</a></li>
<li><a href="../de415171/index.html">Reflexionsgesetze in Go</a></li>
<li><a href="../de415175/index.html">Interview mit Augmented World Expo Member</a></li>
<li><a href="../de415177/index.html">Willkommen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>