<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘  ğŸ° ğŸ’¯ Tireur de zombies simple sur Unity ğŸ¥ ğŸ‘©ğŸ½â€ğŸš€ ğŸ’ƒğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour Ã  tous! BientÃ´t, les cours commenceront dans le premier groupe du cours Unity Games Developer . En prÃ©vision du dÃ©but du cours, une leÃ§on ouve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tireur de zombies simple sur Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/485210/">  <i>Bonjour Ã  tous!</i>  <i>BientÃ´t, les cours commenceront dans le premier groupe du cours <a href="https://otus.pw/sW0V/">Unity Games Developer</a> .</i>  <i>En prÃ©vision du dÃ©but du cours, <a href="https://www.youtube.com/watch%3Fv%3D6OTvr4e9PRY">une leÃ§on ouverte</a> sur la crÃ©ation d'un jeu de tir zombie sur Unity a eu lieu.</i>  <i>Le webinaire a Ã©tÃ© organisÃ© par <a href="https://otus.pw/xfXx/">Nikolai Zapolnov</a> , dÃ©veloppeur de jeux senior de Rovio Entertainment Corporation.</i>  <i>Il a Ã©galement Ã©crit un article dÃ©taillÃ© que nous portons Ã  votre attention.</i> <br><br><img src="https://habrastorage.org/webt/z6/pk/iv/z6pkiv4cismrguzozecv51foouk.jpeg"><br><br>  Dans cet article, je voudrais montrer Ã  quel point il est facile de crÃ©er des jeux dans Unity.  Si vous avez des connaissances de base en programmation, vous pouvez rapidement commencer Ã  travailler avec ce moteur et crÃ©er votre premier jeu. <br><br><hr><br>  <i>Avertissement # 1: Cet article est destinÃ© aux dÃ©butants.</i>  <i>Si vous avez mangÃ© un chien dans Unity, cela peut vous sembler ennuyeux.</i> <br><br>  <i>Disclaimer # 2: Pour lire cet article, vous devez avoir au moins des connaissances de base en programmation.</i>  <i>Au minimum, les mots Â«classeÂ» et Â«mÃ©thodeÂ» ne devraient pas vous faire peur.</i> <br><br>  <b>Attention, le trafic sous la coupe!</b> <br><a name="habracut"></a><br><h2>  Introduction Ã  l'unitÃ© </h2><br>  <i>Si vous connaissez dÃ©jÃ  l'Ã©diteur Unity, vous pouvez ignorer l'introduction et passer directement Ã  la section Â«CrÃ©ation d'un monde de jeuÂ».</i> <br><br>  L'unitÃ© structurelle de base dans Unity est la Â«scÃ¨neÂ».  Une scÃ¨ne est gÃ©nÃ©ralement un niveau du jeu, bien que dans certains cas, il puisse y avoir plusieurs niveaux Ã  la fois dans une scÃ¨ne ou, inversement, un grand niveau puisse Ãªtre divisÃ© en plusieurs scÃ¨nes chargÃ©es dynamiquement.  Les scÃ¨nes sont remplies d'objets de jeu et, Ã  leur tour, sont remplis de composants.  Ce sont les composants qui mettent en Å“uvre diverses fonctions de jeu: dessin d'objets, animation, physique, etc.  Ce modÃ¨le vous permet d'assembler des fonctionnalitÃ©s Ã  partir de blocs simples, comme un jouet du constructeur Lego. <br><br>  Vous pouvez Ã©crire des composants vous-mÃªme, en utilisant le langage de programmation C # pour cela.  C'est ainsi que la logique du jeu est Ã©crite.  Ci-dessous, nous verrons comment cela se fait, mais pour l'instant, jetons un coup d'Å“il au moteur lui-mÃªme. <br><br>  Lorsque vous dÃ©marrez le moteur et crÃ©ez un nouveau projet, vous verrez une fenÃªtre devant vous oÃ¹ vous pouvez sÃ©lectionner quatre Ã©lÃ©ments principaux: <br><br><img src="https://habrastorage.org/webt/5m/0o/9j/5m0o9jxwps3qwz3pbmvlchxveau.png"><br><br>  Dans le coin supÃ©rieur gauche de la capture d'Ã©cran se trouve la fenÃªtre Â«HiÃ©rarchieÂ».  Ici, nous pouvons voir la hiÃ©rarchie des objets de jeu dans la scÃ¨ne ouverte actuelle.  Unity a crÃ©Ã© deux objets de jeu pour nous: une camÃ©ra (Â«camÃ©ra principaleÂ») Ã  travers laquelle le joueur verra notre monde de jeu et une Â«lumiÃ¨re directionnelleÂ» qui illuminera notre scÃ¨ne.  Sans cela, nous ne verrions qu'un carrÃ© noir. <br><br>  Au centre se trouve la fenÃªtre d'Ã©dition de scÃ¨ne (Â«SceneÂ»).  Ici, nous voyons notre niveau et nous pouvons le modifier visuellement - dÃ©placez et faites pivoter les objets avec la souris et voyez ce qui se passe.  Ã€ proximitÃ©, vous pouvez voir l'onglet Â«JeuÂ», qui est actuellement inactif;  si vous passez Ã  celui-ci, vous pouvez voir Ã  quoi ressemble le jeu depuis la camÃ©ra.  Et si vous dÃ©marrez le jeu (en utilisant le bouton avec l'icÃ´ne de lecture dans la barre d'outils), Unity passera Ã  cet onglet, oÃ¹ nous jouerons le jeu lancÃ©. <br><br>  Dans la partie supÃ©rieure droite se trouve la fenÃªtre Â«InspecteurÂ».  Dans cette fenÃªtre, Unity affiche les paramÃ¨tres de l'objet sÃ©lectionnÃ© et nous pouvons les modifier.  En particulier, nous pouvons voir que la camÃ©ra sÃ©lectionnÃ©e a deux composants - "Transform", qui dÃ©finit la position de la camÃ©ra dans le monde du jeu, et, en fait, "Camera", qui implÃ©mente les fonctionnalitÃ©s de la camÃ©ra. <br><br>  Soit dit en passant, le composant Transformer est sous une forme ou une autre dans tous les objets de jeu dans Unity. <br><br>  Et enfin, en bas, il y a l'onglet "Projet", oÃ¹ nous pouvons voir tous les soi-disant actifs qui sont dans notre projet.  Les actifs sont des fichiers de donnÃ©es tels que des textures, des sprites, des modÃ¨les 3D, des animations, des sons et de la musique, des fichiers de configuration.  Autrement dit, toutes les donnÃ©es que nous pouvons utiliser pour crÃ©er des niveaux ou l'interface utilisateur.  Unity comprend un grand nombre de formats standard (par exemple, png et jpg pour les images ou fbx pour les modÃ¨les 3D), il n'y aura donc aucun problÃ¨me de chargement des donnÃ©es dans un projet.  Et si vous, comme moi, ne savez pas comment dessiner, les actifs peuvent Ãªtre tÃ©lÃ©chargÃ©s Ã  partir de l'Unity Asset Store, qui contient une Ã©norme collection de toutes sortes de ressources: gratuites et vendues pour de l'argent. <br><br>  Ã€ droite de l'onglet Â«ProjetÂ», l'onglet Â«ConsoleÂ» inactif est visible.  Unity Ã©crit des avertissements et des messages d'erreur sur la console, assurez-vous donc de vÃ©rifier rÃ©guliÃ¨rement.  Surtout si quelque chose ne fonctionne pas - trÃ¨s probablement, la console fera allusion Ã  la cause du problÃ¨me.  De plus, la console peut afficher des messages du code du jeu, pour le dÃ©bogage. <br><br><h2>  CrÃ©ez un monde de jeu </h2><br>  Ã‰tant donnÃ© que je suis un programmeur et que je dessine pire que la patte de poulet, pour les graphismes, j'ai pris des actifs gratuits du Unity Asset Store.  Vous pouvez trouver des liens vers eux Ã  la fin de cet article. <br><br>  A partir de ces atouts, j'ai rassemblÃ© un niveau simple avec lequel nous travaillerons: <br><br><img src="https://habrastorage.org/webt/07/y-/cr/07y-crxk0zc6zywqh8vga90qg-s.jpeg"><br><br>  Pas de magie, je viens de faire glisser les objets que j'aimais depuis la fenÃªtre Projet et Ã  l'aide de la souris, je les ai arrangÃ©s comme j'aime: <br><br><img src="https://habrastorage.org/webt/ll/xb/ca/llxbca3cdunouswhcy2b4jgpgha.gif"><br><br>  Soit dit en passant, Unity vous permet d'ajouter des objets standard Ã  la scÃ¨ne en un seul clic, comme un cube, une sphÃ¨re ou un plan.  Pour ce faire, cliquez avec le bouton droit de la souris dans la fenÃªtre HiÃ©rarchie et sÃ©lectionnez, par exemple, 3D Objectâ‡¨Plane.  Donc, l'asphalte de mon niveau est simplement assemblÃ© Ã  partir d'un ensemble d'avions sur lesquels j'ai Â«tirÃ©Â» une texture d'un ensemble d'actifs. <br><br>  NB Si vous vous demandez pourquoi j'ai utilisÃ© beaucoup d'avions, et pas un avec des valeurs Ã  grande Ã©chelle, la rÃ©ponse est assez simple: un avion Ã  grande Ã©chelle aura une texture considÃ©rablement agrandie, qui ne semblera pas naturelle par rapport aux autres objets de la scÃ¨ne (cela peut Ãªtre corrigÃ© avec les paramÃ¨tres matÃ©riel, mais nous essayons de faire tout aussi simple que possible, non?) <br><br><h2>  Zombies Ã  la recherche d'un moyen </h2><br>  Donc, nous avons un niveau de jeu, mais rien ne s'y passe encore.  Dans notre jeu, les zombies chassent le joueur et l'attaquent, et pour cela, ils doivent Ãªtre capables de se dÃ©placer vers le joueur et de contourner les obstacles. <br><br>  Pour l'implÃ©menter, nous utiliserons l'outil Â«Navigation MeshÂ».  Sur la base des donnÃ©es de la scÃ¨ne, cet outil calcule les zones dans lesquelles vous pouvez vous dÃ©placer et gÃ©nÃ¨re un ensemble de donnÃ©es qui peuvent Ãªtre utilisÃ©es pour rechercher l'itinÃ©raire optimal de n'importe quel point du niveau Ã  n'importe quel autre pendant le jeu.  Ces donnÃ©es sont stockÃ©es dans l'actif et ne peuvent pas Ãªtre modifiÃ©es Ã  l'avenir - ce processus est appelÃ© Â«cuissonÂ».  Si vous avez besoin d'obstacles Ã  changement dynamique, vous pouvez utiliser le composant NavMeshObstacle, mais ce n'est pas nÃ©cessaire pour notre jeu. <br><br>  Un point important: pour qu'Unity sache quels objets doivent Ãªtre inclus dans le calcul, dans l'inspecteur de chaque objet (vous pouvez tout sÃ©lectionner en mÃªme temps dans la fenÃªtre HiÃ©rarchie), cliquez sur la flÃ¨che vers le bas Ã  cÃ´tÃ© de l'option Â«StatiqueÂ» et cochez Â«Navigation statiqueÂ»: <br><br><img src="https://habrastorage.org/webt/d9/us/wk/d9uswkd5hafxmqqxlr3ujr0ed_u.jpeg"><br><br>  En gÃ©nÃ©ral, les points restants sont Ã©galement utiles et aident Unity Ã  optimiser le rendu des scÃ¨nes.  Nous ne nous attarderons pas sur eux aujourd'hui, mais lorsque vous aurez fini d'apprendre les bases du moteur, je vous recommande vivement de traiter Ã©galement d'autres paramÃ¨tres.  Parfois, une seule coche peut augmenter considÃ©rablement la frÃ©quence d'images. <br><br>  Nous allons maintenant utiliser l'Ã©lÃ©ment de menu FenÃªtreâ‡¨AIâ‡¨Navigation et dans la fenÃªtre qui s'ouvre, sÃ©lectionnez l'onglet Â«BakeÂ».  Ici, Unity nous proposera de dÃ©finir des paramÃ¨tres tels que la hauteur et le rayon du personnage, l'angle d'inclinaison maximum de la terre sur laquelle vous pouvez toujours marcher, la hauteur maximale des marches, etc.  Nous ne changerons rien encore et appuyez simplement sur le bouton "Bake". <br><br><img src="https://habrastorage.org/webt/zs/my/uo/zsmyuoqaopw11zon8bua6arf9aa.gif"><br><br>  Unity fera les calculs nÃ©cessaires et nous montrera le rÃ©sultat: <br><br><img src="https://habrastorage.org/webt/3q/lg/t6/3qlgt6ze2hkj5sv8npdlr6ohkk8.jpeg"><br><br>  Ici, le bleu indique la zone oÃ¹ vous pouvez marcher.  Comme vous pouvez le voir, Unity a laissÃ© un petit cÃ´tÃ© autour des obstacles - la largeur de ce cÃ´tÃ© dÃ©pend du rayon du personnage.  Ainsi, si le centre du personnage se trouve dans la zone bleue, il ne "passera" pas par les obstacles. <br><br>  Ayant une grille de navigation calculÃ©e, nous pouvons utiliser le composant NavMeshAgent pour rechercher l'itinÃ©raire de mouvement et contrÃ´ler le mouvement des objets de jeu Ã  notre niveau. <br><br>  CrÃ©ons un objet de jeu "Zombie", ajoutons-y un modÃ¨le 3D de zombies Ã  partir des ressources, ainsi que le composant NavMeshAgent: <br><br><img src="https://habrastorage.org/webt/ij/jy/cb/ijjycbpwk8kjyyhkhter8jrbu7g.gif"><br><br>  Si vous dÃ©marrez le jeu maintenant, rien ne se passera.  Nous devons indiquer au composant NavMeshAgent oÃ¹ aller.  Pour ce faire, nous allons crÃ©er notre premier composant en C #. <br><br>  Dans la fenÃªtre du projet, sÃ©lectionnez le rÃ©pertoire racine (il s'appelle Â«AssetsÂ») et dans la liste des fichiers, faites un clic droit pour crÃ©er le rÃ©pertoire Â«ScriptsÂ».  Nous y stockerons tous nos scripts afin que le projet soit en ordre.  Maintenant, Ã  l'intÃ©rieur des "Scripts", crÃ©ons un script "Zombie" et ajoutons-le Ã  l'objet du jeu zombie: <br><br><img src="https://habrastorage.org/webt/dz/_d/a1/dz_da1d0ybbvslw1g3tvkq8vgau.gif"><br><br>  Double-cliquez sur le script pour l'ouvrir dans l'Ã©diteur.  Voyons ce que Unity a crÃ©Ã© pour nous. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } }</span></span></code> </pre> <br>  Il s'agit d'un blanc de composant standard.  Comme nous pouvons le voir, Unity nous a connectÃ© les bibliothÃ¨ques System.Collections et System.Collections.Generic (maintenant elles ne sont pas nÃ©cessaires, mais elles sont souvent nÃ©cessaires dans le code des jeux Unity, elles sont donc incluses dans le modÃ¨le standard), ainsi que la bibliothÃ¨que UnityEngine, qui contient tous les API du moteur principal. <br><br>  De plus, Unity a crÃ©Ã© la classe Zombie pour nous (le nom correspond au nom du fichier; c'est important: s'ils ne correspondent pas, Unity ne pourra pas faire correspondre le script avec le composant de la scÃ¨ne).  La classe est hÃ©ritÃ©e de MonoBehaviour - il s'agit de la classe de base pour les composants crÃ©Ã©s par l'utilisateur. <br><br>  Dans la classe, Unity a crÃ©Ã© deux mÃ©thodes pour nous: DÃ©marrer et Mettre Ã  jour.  Le moteur appellera ces mÃ©thodes lui-mÃªme: DÃ©marrer - immÃ©diatement aprÃ¨s le chargement de la scÃ¨ne, et Mettre Ã  jour - chaque image.  En fait, il y a beaucoup de ces fonctions appelÃ©es par le moteur, mais la plupart d'entre elles ne seront pas nÃ©cessaires aujourd'hui.  La liste complÃ¨te, ainsi que la sÃ©quence de leur appel, se trouvent toujours dans la documentation: <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">https://docs.unity3d.com/Manual/ExecutionOrder.html</a> <br><br>  Faisons bouger les zombies sur la carte! <br><br>  Tout d'abord, nous devons connecter la bibliothÃ¨que UnityEngine.AI.  Il contient la classe NavMeshAgent et d'autres classes liÃ©es Ã  la grille de navigation.  Pour ce faire, ajoutez la directive using UnityEngine.AI au dÃ©but du fichier. <br><br>  Ensuite, nous devons accÃ©der au composant NavMeshAgent.  Pour ce faire, nous pouvons utiliser la mÃ©thode standard GetComponent.  Il vous permet d'obtenir un lien vers n'importe quel composant du mÃªme objet de jeu dans lequel se trouve le composant Ã  partir duquel nous appelons cette mÃ©thode (dans notre cas, c'est l'objet de jeu Â«ZombieÂ»).  Nous allons crÃ©er le champ NavMeshAgent navMeshAgent dans la classe, dans la mÃ©thode Start, nous obtiendrons un lien vers NavMeshAgent et lui demanderons de se dÃ©placer vers le point (0, 0, 0).  Nous devrions obtenir ce script: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); navMeshAgent.SetDestination(Vector3.zero); } // Update is called once per frame void Update() { } }</span></span></code> </pre> <br>  En commenÃ§ant le jeu, nous verrons comment le zombie se dÃ©place au centre de la carte: <br><br><img src="https://habrastorage.org/webt/dx/uz/u1/dxuzu157nhtqaj85o0afxbm_s7k.gif"><br><br><h2>  Zombies pourchassant une victime </h2><br>  Super  Mais nos zombies s'ennuient et se sentent seuls, ajoutons la <s>victime d'un</s> joueur au jeu pour lui. <br><br>  Par analogie avec les zombies, nous allons crÃ©er un objet de jeu "Player" (cette fois nous sÃ©lectionnerons un modÃ¨le 3D d'un officier de police), nous y ajouterons Ã©galement le composant NavMeshAgent et le script Player fraÃ®chement crÃ©Ã©.  Nous ne toucherons pas encore au contenu du script Player, mais nous devrons apporter des modifications au script Zombie.  En outre, je recommande de dÃ©finir la valeur de la propriÃ©tÃ© Priority du lecteur sur 10 dans le composant NavMeshAgent (ou toute autre valeur infÃ©rieure Ã  50 standard, c'est-Ã -dire en accordant au joueur une prioritÃ© plus Ã©levÃ©e).  Dans ce cas, si le joueur et les zombies se rencontrent sur la carte, les zombies ne pourront pas dÃ©placer le joueur, tandis que le joueur pourra repousser les zombies. <br><br>  Pour chasser un joueur, un zombie a besoin de connaÃ®tre sa position.  Et pour cela, nous devons obtenir un lien vers celui-ci dans notre classe Zombie en utilisant la mÃ©thode standard FindObjectOfType.  AprÃ¨s avoir mÃ©morisÃ© le lien, nous pouvons nous tourner vers le composant de transformation du joueur et lui demander la valeur de position.  Et pour que le zombie poursuive toujours le joueur, et pas seulement au dÃ©but du jeu, nous fixerons un objectif pour NavMeshAgent dans la mÃ©thode de mise Ã  jour.  Vous obtenez le script suivant: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; Player player; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); player = FindObjectOfType&lt;Player&gt;(); } // Update is called once per frame void Update() { navMeshAgent.SetDestination(player.transform.position); } }</span></span></code> </pre> <br>  ExÃ©cutez le jeu et assurez-vous que le zombie a trouvÃ© sa victime: <br><br><img src="https://habrastorage.org/webt/j3/lv/vc/j3lvvcaltksjiu44tzh-rijewi4.gif"><br><br><h2>  Ã‰chapper Ã©chapper </h2><br>  Notre joueur se tient comme une idole.  Cela ne l'aidera clairement pas Ã  survivre dans un monde aussi agressif, vous devez donc lui apprendre Ã  se dÃ©placer sur la carte. <br><br>  Pour ce faire, nous devons obtenir des informations sur les touches enfoncÃ©es dans Unity.  La mÃ©thode GetKey de la classe Input standard fournit simplement ces informations! <br><br>  NB En gÃ©nÃ©ral, cette faÃ§on d'obtenir des entrÃ©es n'est pas entiÃ¨rement canonique.  Il est prÃ©fÃ©rable d'utiliser Input.GetAxis et la liaison via les paramÃ¨tres du projet â‡¨ Input Manager.  Mieux encore, <a href="https://blogs.unity3d.com/ru/2019/10/14/introducing-the-new-input-system/">nouveau systÃ¨me d'entrÃ©e</a> .  Mais cet article s'est avÃ©rÃ© trop long, et donc, faisons-le plus simplement. <br><br>  Ouvrez le script Player et modifiez-le comme suit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Player</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moveSpeed; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); } // Update is called once per frame void Update() { Vector3 dir = Vector3.zero; if (Input.GetKey(KeyCode.LeftArrow)) dir.z = -1.0f; if (Input.GetKey(KeyCode.RightArrow)) dir.z = 1.0f; if (Input.GetKey(KeyCode.UpArrow)) dir.x = -1.0f; if (Input.GetKey(KeyCode.DownArrow)) dir.x = 1.0f; navMeshAgent.velocity = dir.normalized * moveSpeed; } }</span></span></code> </pre> <br>  Comme dans le cas des zombies, dans la mÃ©thode Start, nous obtenons un lien vers le composant NavMeshAgent du joueur et le stockons dans le champ de classe.  Mais maintenant, nous avons Ã©galement ajoutÃ© le champ moveSpeed. <br>  Ã‰tant donnÃ© que ce champ est public, sa valeur peut Ãªtre modifiÃ©e directement dans l'inspecteur dans Unity!  Si vous avez un game designer dans votre Ã©quipe, il sera trÃ¨s content de ne pas avoir Ã  entrer dans le code pour Ã©diter les paramÃ¨tres du joueur. <br><br>  DÃ©finissez 10 comme vitesse: <br><br><img src="https://habrastorage.org/webt/o9/ro/cx/o9rocx0w0v3djxjgdt35ca59aug.gif"><br><br>  Dans la mÃ©thode de mise Ã  jour, nous utiliserons Input.GetKey pour vÃ©rifier si l'une des flÃ¨ches du clavier est enfoncÃ©e et former un vecteur de direction pour le joueur.  Notez que nous utilisons les coordonnÃ©es X et Z. Cela est dÃ» au fait que dans Unity, l'axe Y regarde vers le ciel, et la terre est situÃ©e dans le plan XZ. <br><br>  AprÃ¨s avoir formÃ© un vecteur de direction pour la direction du mouvement dir, nous le normalisons (sinon, si le joueur veut se dÃ©placer en diagonale, le vecteur sera lÃ©gÃ¨rement plus long qu'un seul et ce mouvement sera plus rapide que de se dÃ©placer directement) et multiplier par la vitesse de mouvement donnÃ©e.  Le rÃ©sultat est transmis Ã  navMeshAgent.velocity et l'agent fera le reste. <br><br>  En lanÃ§ant le jeu, on peut enfin tenter de s'Ã©chapper des zombies vers un endroit sÃ»r: <br><br><img src="https://habrastorage.org/webt/mn/gv/7w/mngv7wimzjqsdlfja2ghro-ovn8.gif"><br><br>  Pour faire bouger la camÃ©ra avec le lecteur, Ã©crivons un autre script simple.  Appelons cela "PlayerCamera": <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlayerCamera</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Player player; Vector3 offset; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { player = FindObjectOfType&lt;Player&gt;(); offset = transform.position - player.transform.position; } // Update is called once per frame void LateUpdate() { transform.position = player.transform.position + offset; } }</span></span></code> </pre> <br>  La signification de ce script doit Ãªtre largement comprise.  Ã€ partir des fonctionnalitÃ©s - ici, au lieu de Update, nous utilisons LateUpdate.  Cette mÃ©thode est similaire Ã  Update, mais elle est toujours appelÃ©e strictement aprÃ¨s la fin de Update pour tous les scripts de la scÃ¨ne.  Dans ce cas, nous utilisons LateUpdate, car il est important pour nous que NavMeshAgent calcule la nouvelle position du lecteur avant de dÃ©placer la camÃ©ra.  Sinon, un effet de Â«secoussesÂ» dÃ©sagrÃ©able peut se produire. <br><br>  Si vous attachez maintenant ce composant Ã  l'objet de jeu "Appareil photo principal" et dÃ©marrez le jeu, le personnage du joueur sera toujours Ã  l'honneur! <br><br><h2>  Moment d'animation </h2><br>  Pendant un moment, nous nous Ã©loignons des problÃ¨mes de survie dans les conditions d'une apocalypse zombie et pensons Ã  l'Ã©ternel - Ã  l'art.  Nos personnages ressemblent maintenant Ã  des statues animÃ©es, mises en mouvement par une force inconnue (peut-Ãªtre des aimants sous l'asphalte).  Et je voudrais qu'ils ressemblent Ã  de vraies personnes vivantes (et pas trÃ¨s) - ils ont bougÃ© leurs bras et leurs jambes.  Le composant Animator et un outil appelÃ© ContrÃ´leur Animator nous aideront avec cela. <br><br>  Animator Controller est une machine Ã  Ã©tats finis (machine Ã  Ã©tats), oÃ¹ nous dÃ©finissons certains Ã©tats (le personnage est debout, le personnage est activÃ©, le personnage est mourant, etc.), nous leur attachons des animations et dÃ©finissons les rÃ¨gles de transition d'un Ã©tat Ã  un autre.  Unity passera automatiquement d'une animation Ã  une autre dÃ¨s que la rÃ¨gle correspondante fonctionnera. <br><br>  CrÃ©ons un contrÃ´leur d'animateur pour les zombies.  Pour ce faire, crÃ©ez le rÃ©pertoire Animations dans le projet (rappelez-vous l'ordre dans le projet), et dans celui-ci - Ã  l'aide du bouton droit - Animator Controller.  Et appelons-le "Zombie".  Double-cliquez - et l'Ã©diteur apparaÃ®tra devant nous: <br><br><img src="https://habrastorage.org/webt/t1/54/ak/t154aknnrk7f0lwdlcmvj69uxqo.png"><br><br>  Jusqu'Ã  prÃ©sent, il n'y a aucun Ã‰tat, mais il y a deux points d'entrÃ©e (Â«EntrÃ©eÂ» et Â«Tout Ã‰tatÂ») et un point de sortie (Â«SortieÂ»).  Faites glisser quelques animations depuis les ressources: <br><br><img src="https://habrastorage.org/webt/xg/cx/gw/xgcxgwkbtqsbqux7cj9y5qnwnk0.gif"><br><br>  Comme vous pouvez le voir, dÃ¨s que nous avons fait glisser la premiÃ¨re animation, Unity l'a automatiquement liÃ©e au point d'entrÃ©e Entry.  Il s'agit de la soi-disant animation par dÃ©faut.  Il sera jouÃ© immÃ©diatement aprÃ¨s le dÃ©but du niveau. <br><br>  Pour passer Ã  un Ã©tat diffÃ©rent (et lire une autre animation), nous devons crÃ©er des rÃ¨gles de transition.  Et pour cela, tout d'abord, nous devrons ajouter un paramÃ¨tre que nous allons dÃ©finir Ã  partir du code de gestion des animations. <br><br>  Il y a deux boutons dans le coin supÃ©rieur gauche de la fenÃªtre de l'Ã©diteur: Â«CalquesÂ» et Â«ParamÃ¨tresÂ».  Par dÃ©faut, l'onglet Â«CouchesÂ» est sÃ©lectionnÃ©, mais nous devons passer Ã  Â«ParamÃ¨tresÂ».  Maintenant, nous pouvons ajouter un nouveau paramÃ¨tre de type float en utilisant le bouton "+".  Appelons cela Â«vitesseÂ»: <br><br><img src="https://habrastorage.org/webt/po/is/nj/poisnjmj39qel2ofz_meiyginsw.gif"><br><br>  Maintenant, nous devons dire Ã  Unity que l'animation "Z_run" doit Ãªtre jouÃ©e lorsque la vitesse est supÃ©rieure Ã  0 et "Z_idle_A" lorsque la vitesse est nulle.  Pour ce faire, nous devons crÃ©er deux transitions: l'une de "Z_idle_A" Ã  "Z_run", et l'autre dans le sens opposÃ©. <br><br>  CommenÃ§ons par la transition de l'inactif Ã  l'exÃ©cution.  Faites un clic droit sur le rectangle "Z_idle_A" et sÃ©lectionnez "Effectuer la transition".  Une flÃ¨che apparaÃ®tra, en cliquant sur laquelle vous pourrez configurer ses paramÃ¨tres.  Tout d'abord, vous devez dÃ©cocher Â«A l'heure de sortieÂ».  Si cela n'est pas fait, l'animation ne changera pas selon notre condition, mais lorsque la prÃ©cÃ©dente aura fini de jouer.  Nous n'en avons pas du tout besoin, alors nous la dÃ©cochons.  DeuxiÃ¨mement, en bas, dans la liste des conditions (Â«ConditionsÂ»), vous devez cliquer sur Â«+Â» et Unity nous ajoutera une condition.  Les valeurs par dÃ©faut dans ce cas sont exactement ce dont nous avons besoin: le paramÃ¨tre Â«speedÂ» doit Ãªtre supÃ©rieur Ã  zÃ©ro pour passer du ralenti au run. <br><br><img src="https://habrastorage.org/webt/vt/rw/qy/vtrwqy-jyfhgrai9ruymphu_mwi.gif"><br><br>  Par analogie, nous crÃ©ons une transition dans la direction opposÃ©e, mais comme condition nous spÃ©cifions maintenant une Â«vitesseÂ» infÃ©rieure Ã  0,0001.  Il n'y a pas de contrÃ´le d'Ã©galitÃ© pour les paramÃ¨tres de type float, ils ne peuvent Ãªtre comparÃ©s que pour plus / moins: <br><br><img src="https://habrastorage.org/webt/vz/ki/bu/vzkibunzaoxqfdfysekucvcqepa.png"><br><br>  Vous devez maintenant lier le contrÃ´leur Ã  l'objet de jeu.  Nous allons sÃ©lectionner le modÃ¨le 3D du zombie dans la scÃ¨ne (il s'agit d'un enfant de l'objet "Zombie") et faire glisser le contrÃ´leur avec la souris dans le champ correspondant du composant Animator: <br><br><img src="https://habrastorage.org/webt/lr/pv/pq/lrpvpqbl__neecouj3uyxdepqka.gif"><br><br>  Il ne reste plus qu'Ã  Ã©crire un script qui contrÃ´lera le paramÃ¨tre de vitesse! <br><br>  CrÃ©ez le script MovementAnimator avec le contenu suivant: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementAnimator</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; Animator animator; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); animator = GetComponentInChildren&lt;Animator&gt;(); } // Update is called once per frame void Update() { animator.SetFloat("speed", navMeshAgent.velocity.magnitude); } }</span></span></code> </pre> <br>  Ici, comme dans d'autres scripts, dans la mÃ©thode Start, nous avons accÃ¨s Ã  NavMeshAgent.  Nous avons Ã©galement accÃ¨s au composant Animator, mais comme nous allons attacher le composant "MovementAnimator" Ã  l'objet de jeu "Zombie" et que l'animateur se trouve dans l'objet enfant, au lieu de GetComponent, nous devons utiliser la mÃ©thode standard GetComponentInChildren. <br><br>  Dans la mÃ©thode Update, nous demandons Ã  NavMeshAgent son vecteur de vitesse, calculons sa longueur et le transmettons Ã  l'animateur comme paramÃ¨tre de vitesse.  Pas de magie, tout en science! <br><br>  Ajoutez maintenant le composant MovementAnimator Ã  l'objet de jeu Zombie et, si le jeu dÃ©marre, nous voyons que les zombies sont maintenant animÃ©s: <br><br><img src="https://habrastorage.org/webt/uz/da/yt/uzdaytgsxzstqj8rnzx11rfa8ti.gif"><br><br>  Notez que puisque nous avons placÃ© le code de contrÃ´le de l'animateur dans un composant MovementAnimation sÃ©parÃ©, il peut Ãªtre facilement ajoutÃ© pour le joueur.  Nous n'avons mÃªme pas besoin de crÃ©er un contrÃ´leur Ã  partir de zÃ©ro - vous pouvez copier un contrÃ´leur zombie (cela peut Ãªtre fait en sÃ©lectionnant le fichier "Zombie" et en appuyant sur Ctrl + D) et remplacer les animations dans les rectangles d'Ã©tat par "m_idle_" et "m_run".  Tout le reste est comme un zombie.  Je vous laisse cela comme un exercice (enfin, ou tÃ©lÃ©chargez le code Ã  la fin de l'article). <br><br>  Un petit ajout utile Ã  faire consiste Ã  ajouter les lignes suivantes Ã  la classe Zombie: <br><br>  Dans la mÃ©thode Start: <br><br><pre> <code class="cs hljs">navMeshAgent.updateRotation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Dans la mÃ©thode Update: <br><br><pre> <code class="cs hljs">transform.rotation = Quaternion.LookRotation(navMeshAgent.velocity.normalized);</code> </pre> <br>  La premiÃ¨re ligne indique Ã  NavMeshAgent qu'il ne doit pas contrÃ´ler la rotation du personnage, nous le ferons nous-mÃªmes.  La deuxiÃ¨me ligne dÃ©finit le tour du personnage dans la mÃªme direction oÃ¹ son mouvement est dirigÃ©.  NavMeshAgent interpole par dÃ©faut l'angle de rotation du personnage et cela n'a pas l'air trÃ¨s joli (le zombie tourne plus lentement que change la direction du mouvement).  L'ajout de ces lignes supprime cet effet. <br><br>  NB Nous utilisons le quaternion pour spÃ©cifier la rotation.  Dans les graphiques tridimensionnels, les principaux moyens de spÃ©cifier la rotation d'un objet sont les angles d'Euler, les matrices de rotation et les quaternions.  Les deux premiers ne sont pas toujours pratiques Ã  utiliser et sont Ã©galement soumis Ã  un effet dÃ©sagrÃ©able tel que Â«Gimbal LockÂ».  Les quaternions sont privÃ©s de cet inconvÃ©nient et sont maintenant utilisÃ©s presque universellement.  Unity fournit des outils pratiques pour travailler avec des quaternions (ainsi qu'avec des matrices et des angles d'Euler), ce qui vous permet de ne pas entrer dans les dÃ©tails de l'appareil de cet appareil mathÃ©matique. <br><br><h2>  Je vois le but </h2><br>  GÃ©nial, maintenant nous pouvons Ã©chapper aux zombies.  Mais cela ne suffit pas, tÃ´t ou tard un deuxiÃ¨me zombie apparaÃ®tra, puis un troisiÃ¨me, cinquiÃ¨me, dixiÃ¨me ... mais vous ne pouvez pas simplement fuir la foule.  Pour survivre, vous devez tuer.  De plus, le joueur a dÃ©jÃ  un pistolet dans sa main. <br><br>  Pour que le joueur puisse tirer, vous devez lui donner la possibilitÃ© de choisir une cible.  Pour ce faire, placez le curseur contrÃ´lÃ© par la souris sur le sol. <br><br>  Sur l'Ã©cran, le curseur de la souris se dÃ©place dans un espace Ã  deux dimensions - la surface du moniteur.  En mÃªme temps, notre scÃ¨ne de jeu est tridimensionnelle.  L'observateur voit la scÃ¨ne Ã  travers son Å“il, oÃ¹ tous les rayons de lumiÃ¨re convergent en un point.  En combinant tous ces rayons, nous obtenons une pyramide de visibilitÃ©: <br><br><img src="https://habrastorage.org/webt/hl/bg/p5/hlbgp55snbpv2cxacycfmxbd_hw.png"><br><br>  L'Å“il de l'observateur ne voit que ce qui tombe dans cette pyramide.  De plus, le moteur tronque spÃ©cifiquement cette pyramide de deux cÃ´tÃ©s: premiÃ¨rement, du cÃ´tÃ© de l'observateur, il y a un Ã©cran de contrÃ´le, le soi-disant Â«plan procheÂ» (sur la figure, il est peint en jaune).  Le moniteur ne peut pas afficher physiquement des objets plus proches que l'Ã©cran, donc le moteur les coupe.  DeuxiÃ¨mement, Ã©tant donnÃ© que l'ordinateur a une quantitÃ© limitÃ©e de ressources, le moteur ne peut pas Ã©tendre les rayons Ã  l'infini (par exemple, une certaine plage de valeurs possibles doit Ãªtre dÃ©finie pour le tampon de profondeur; de plus, plus il est large, plus la prÃ©cision est faible), de sorte que la pyramide est coupÃ©e derriÃ¨re ce que l'on appelle Â«Avion lointainÂ». <br><br>  Puisque le curseur de la souris se dÃ©place le long du plan proche, nous pouvons libÃ©rer le rayon du point oÃ¹ il se trouve profondÃ©ment dans la scÃ¨ne.  Le premier objet avec lequel il se croise sera l'objet vers lequel pointe le curseur de la souris du point de vue de l'observateur. <br><br><img src="https://habrastorage.org/webt/rd/xf/kn/rdxfkn9vevlzr8qz5qtronl05vi.png"><br><br>  Pour construire un tel rayon et trouver son intersection avec des objets dans la scÃ¨ne, vous pouvez utiliser la mÃ©thode Raycast standard de la classe Physique.  Mais si nous utilisons cette mÃ©thode, elle trouvera l'intersection avec tous les objets de la scÃ¨ne - terre, murs, zombies ... Mais nous voulons que le curseur se dÃ©place uniquement sur le sol, nous devons donc expliquer Ã  Unity que la recherche d'intersection ne doit Ãªtre limitÃ©e que un ensemble donnÃ© d'objets (dans notre cas, uniquement les plans de la terre). <br><br>  Si vous sÃ©lectionnez un objet de jeu dans la scÃ¨ne, dans la partie supÃ©rieure de l'inspecteur, vous pouvez voir la liste dÃ©roulante "Couche".  Par dÃ©faut, il y aura une valeur de Â«DefaultÂ».  En ouvrant la liste dÃ©roulante, vous pouvez y trouver l'Ã©lÃ©ment Â«Ajouter un calque ...Â», ce qui ouvrira la fenÃªtre de l'Ã©diteur de calque.  Dans l'Ã©diteur, vous devez ajouter une nouvelle couche (appelons-la Â«GroundÂ»): <br><br><img src="https://habrastorage.org/webt/3w/5g/pc/3w5gpczarjjyhhtombqxbxq68wk.gif"><br><br>  Vous pouvez maintenant sÃ©lectionner tous les plans au sol de la scÃ¨ne et utiliser cette liste dÃ©roulante pour leur affecter la couche au sol.  Cela nous permettra d'indiquer dans le script Ã  la mÃ©thode Physics.Raycast qu'il est nÃ©cessaire de vÃ©rifier l'intersection du faisceau uniquement avec ces objets. <br><br>  Maintenant, glissons le sprite du curseur des actifs vers la scÃ¨ne (j'utilise Spags Assetsâ‡¨Texturesâ‡¨Demoâ‡¨white_hipâ‡¨white_hip_14): <br><br><img src="https://habrastorage.org/webt/ha/mw/aa/hamwaarhcaodn7q-y-e5qkps5kc.gif"><br><br>  J'ai ajoutÃ© une rotation de 90 degrÃ©s autour de l'axe X au curseur afin qu'il repose horizontalement sur le sol, je rÃ¨gle l'Ã©chelle Ã  0,25 pour qu'elle ne soit pas si grande et je rÃ¨gle la coordonnÃ©e Y Ã  0,01.  Ce dernier est important pour qu'il n'y ait aucun effet appelÃ© Â«combat ZÂ».  La carte vidÃ©o utilise des calculs en virgule flottante pour dÃ©terminer quels objets sont plus proches de la camÃ©ra.  Si vous placez le curseur sur 0 (c'est-Ã -dire le mÃªme que celui du plan de masse), puis en raison d'erreurs dans ces calculs, pour certains pixels, la carte vidÃ©o dÃ©cidera que le curseur est plus proche, et pour d'autres, que la terre.  De plus, dans diffÃ©rentes images, les ensembles de pixels seront diffÃ©rents, ce qui crÃ©era un effet dÃ©sagrÃ©able de faire briller des morceaux de curseur Ã  travers le sol et de "scintiller" lorsqu'il se dÃ©place.  La valeur de 0,01 est suffisamment grande pour compenser les erreurs de calcul de la carte vidÃ©o, mais pas si grande que l'Å“il a remarquÃ© que le curseur est suspendu dans les airs. <br><br>  Renommez maintenant l'objet jeu en Cursor et crÃ©ez un script avec le mÃªme nom et le contenu suivant: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Cursor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { SpriteRenderer spriteRenderer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> layerMask; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { spriteRenderer = GetComponent&lt;SpriteRenderer&gt;(); layerMask = LayerMask.GetMask("Ground"); } // Update is called once per frame void Update() { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; if (!Physics.Raycast(ray, out hit, 1000, layerMask)) spriteRenderer.enabled = false; else { transform.position = new Vector3(hit.point.x, transform.position.y, hit.point.z); spriteRenderer.enabled = true; } } }</span></span></code> </pre> <br>  Le curseur Ã©tant un sprite (dessin en deux dimensions), Unity utilise le composant SpriteRenderer pour le rendre.  Nous obtenons un lien vers ce composant dans la mÃ©thode Start afin de pouvoir l'activer / le dÃ©sactiver selon les besoins. <br><br>  Toujours dans la mÃ©thode Start, nous convertissons le nom de la couche Â«GroundÂ» que nous avons crÃ©Ã©e prÃ©cÃ©demment en masque de bits.  Unity utilise des opÃ©rations au niveau du bit pour filtrer les objets lors de la recherche d'intersections, et la mÃ©thode LayerMask.GetMask renvoie le masque de bits correspondant au calque spÃ©cifiÃ©. <br><br>  Dans la mÃ©thode Update, nous accÃ©dons Ã  la camÃ©ra principale de la scÃ¨ne Ã  l'aide de Camera.main et lui demandons de recalculer les coordonnÃ©es bidimensionnelles de la souris (obtenues Ã  l'aide de Input.mousePosition) en un rayon tridimensionnel.  Ensuite, nous transmettons ce rayon Ã  la mÃ©thode Physics.Raycast et vÃ©rifions s'il recoupe un objet de la scÃ¨ne.  Une valeur de 1000 est la distance maximale.  En mathÃ©matiques, les rayons sont infinis, mais pas les ressources informatiques et la mÃ©moire d'un ordinateur.  Par consÃ©quent, Unity nous demande de dÃ©terminer une distance maximale raisonnable. <br><br>  S'il n'y avait pas d'intersection, nous dÃ©sactivons SpriteRenderer et l'image du curseur disparaÃ®t de l'Ã©cran.  Si l'intersection a Ã©tÃ© trouvÃ©e, nous dÃ©plaÃ§ons le curseur sur le point d'intersection.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veuillez noter que nous ne modifions pas la coordonnÃ©e Y, car le point d'intersection du rayon avec le sol aura Y Ã©gal Ã  zÃ©ro et en l'affectant Ã  notre curseur, nous obtenons Ã  nouveau l'effet de combat Z, dont nous avons essayÃ© de nous dÃ©barrasser ci-dessus. </font><font style="vertical-align: inherit;">Par consÃ©quent, nous prenons uniquement les coordonnÃ©es X et Z du point d'intersection, et Y reste le mÃªme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez le composant Cursor Ã  l'objet de jeu Cursor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, finalisons le script Player: tout d'abord, ajoutez le champ curseur Curseur. </font><font style="vertical-align: inherit;">Ensuite, dans la mÃ©thode Start, ajoutez les lignes suivantes:</font></font><br><br><pre> <code class="cs hljs">cursor = FindObjectOfType&lt;Cursor&gt;(); navMeshAgent.updateRotation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et enfin, pour que le joueur se tourne toujours vers le curseur, dans la mÃ©thode Update, ajoutez: </font></font><br><br><pre> <code class="cs hljs">Vector3 forward = cursor.transform.position - transform.position; transform.rotation = Quaternion.LookRotation(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(forward.x, <span class="hljs-number"><span class="hljs-number">0</span></span>, forward.z));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici aussi, nous ne prenons pas en compte la coordonnÃ©e Y. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tirez pour survivre </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le simple fait de se tourner vers le curseur ne nous protÃ©gera pas des zombies, mais ne fera que soulager le personnage du joueur de l'effet de surprise - maintenant vous ne pouvez plus vous faufiler derriÃ¨re lui. Pour qu'il puisse vraiment survivre dans les dures rÃ©alitÃ©s de notre jeu, vous devez lui apprendre Ã  tirer. Et quel genre de clichÃ© est-ce s'il n'est pas visible? Tout le monde sait que tout tireur respectable tire toujours des balles traÃ§antes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CrÃ©ez un objet de jeu Shot et ajoutez-y le composant LineRenderer standard. En utilisant le champ Â«LargeurÂ» dans l'Ã©diteur, donnez-lui une petite largeur, par exemple 0,04. Comme nous pouvons le voir, Unity le peint avec une couleur violet vif - de cette faÃ§on, les objets sans matÃ©riau sont mis en Ã©vidence.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les matÃ©riaux sont un Ã©lÃ©ment important de tout moteur tridimensionnel. L'utilisation de matÃ©riaux dÃ©crit l'apparence de l'objet. Tous les paramÃ¨tres d'Ã©clairage, textures, shaders - tout cela est dÃ©crit par le matÃ©riau. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CrÃ©ons le rÃ©pertoire MatÃ©riaux dans le projet et Ã  l'intÃ©rieur, le matÃ©riau, appelons-le Jaune. En tant que shader, sÃ©lectionnez Non Ã©clairÃ© / Couleur. Ce shader standard n'inclut pas d'Ã©clairage, donc notre balle sera visible mÃªme dans l'obscuritÃ©. SÃ©lectionnez la couleur jaune: </font></font><br><br><img src="https://habrastorage.org/webt/en/pt/im/enptimmi5wn6-9f5ssbqzh2fxko.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que le matÃ©riau est crÃ©Ã©, vous pouvez l'affecter Ã  LineRenderer: </font></font><br><br><img src="https://habrastorage.org/webt/ow/qr/31/owqr314ai0hyyfx-hswunci5lzs.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CrÃ©er un script de prise de vue:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Shot</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { LineRenderer lineRenderer; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> visible; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { lineRenderer = GetComponent&lt;LineRenderer&gt;(); } // Update is called once per frame void FixedUpdate() { if (visible) visible = false; else gameObject.SetActive(false); } public void Show(Vector3 from, Vector3 to) { lineRenderer.SetPositions(new Vector3[]{ from, to }); visible = true; gameObject.SetActive(true); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce script, comme vous l'avez probablement dÃ©jÃ  devinÃ©, doit Ãªtre ajoutÃ© Ã  l'objet de jeu Shot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, j'ai utilisÃ© une petite astuce pour afficher une photo Ã  l'Ã©cran pour exactement une image avec un minimum de code. Tout d'abord, j'utilise FixedUpdate au lieu de Update. La mÃ©thode FixedUpdate est appelÃ©e Ã  la frÃ©quence spÃ©cifiÃ©e (par dÃ©faut - 60 images par seconde), mÃªme si la frÃ©quence d'images rÃ©elle est instable. DeuxiÃ¨mement, j'ai dÃ©fini la variable visible, que j'ai dÃ©finie sur true lorsque j'affiche la photo Ã  l'Ã©cran. Dans la prochaine mise Ã  jour fixe, je la rÃ©initialise sur false et ce n'est que dans la prochaine image que je dÃ©sactive l'objet de jeu du tir. Essentiellement, j'utilise une variable boolÃ©enne comme compteur de 1 Ã  0.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mÃ©thode gameObject.SetActive active ou dÃ©sactive tout l'objet de jeu sur lequel se trouve notre composant. Les objets de jeu dÃ©sactivÃ©s ne sont pas dessinÃ©s Ã  l'Ã©cran et leurs composants n'appellent pas les mÃ©thodes Update, FixedUpdate, etc. Cette mÃ©thode vous permet de rendre le plan invisible lorsque le joueur ne tire pas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe Ã©galement une mÃ©thode Show publique dans le script, que nous utiliserons dans le script Player pour afficher la balle lors du tir.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais vous devez d'abord Ãªtre en mesure d'obtenir les coordonnÃ©es du canon du pistolet afin que le tir provienne du bon trou. </font><font style="vertical-align: inherit;">Pour ce faire, recherchez l'objet Bip001â‡¨Bip001 Pelvisâ‡¨Bip001 Spineâ‡¨Bip001 R Clavicleâ‡¨Bip001 R UpperArmâ‡¨Bip001 R Forearmâ‡¨Bip001 R Handâ‡¨R_hand_containerâ‡¨w_handgun dans le modÃ¨le 3D du joueur et ajoutez-y l'objet enfant GunBarrel. </font><font style="vertical-align: inherit;">Placez-le de maniÃ¨re Ã  ce qu'il soit juste Ã  cÃ´tÃ© du canon: </font></font><br><br><img src="https://habrastorage.org/webt/kc/qc/ix/kcqcixwjeh_nf2qxqa6c7iriekk.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintenant dans le script Player, ajoutez les champs:</font></font><br><br><pre> <code class="cs hljs">Shot shot; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform gunBarrel;</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez Ã  la mÃ©thode Start du script Player: </font></font><br><br><pre> <code class="cs hljs">shot = FindObjectOfType&lt;Shot&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et dans la mÃ©thode Update: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> = gunBarrel.position; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = cursor.transform.position; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> to = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(target.x, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.y, target.z); shot.Show(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, to); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le deviner, le champ public gunBarrel ajoutÃ©, comme moveSpeed â€‹â€‹plus tÃ´t, sera disponible dans l'inspecteur. Attribuons-lui le vÃ©ritable objet de jeu que nous avons crÃ©Ã©: </font></font><br><br><img src="https://habrastorage.org/webt/r2/3p/6g/r23p6g9wgzes9qh_fg8l41txjqs.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si nous commenÃ§ons maintenant le jeu, nous pouvons enfin tirer sur les zombies! </font></font><br><br><img src="https://habrastorage.org/webt/gj/ek/sx/gjeksxqnsbieryc_qrv07cyqm44.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelque chose ne va pas ici! Il semble que les tirs ne tuent pas les zombies, mais volent simplement Ã  travers! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, bien sÃ»r, si vous regardez notre code de tir, nous ne suivons en aucune faÃ§on si notre tir a frappÃ© l'ennemi ou non. Tracez simplement une ligne jusqu'au curseur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est assez facile Ã  corriger. Dans le code de traitement des clics de souris dans la classe Player, aprÃ¨s la ligne var to = ... et avant la ligne shot.Show (...), ajoutez les lignes suivantes:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> direction = (to - <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>).normalized; RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, to - <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit, <span class="hljs-number"><span class="hljs-number">100</span></span>)) to = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(hit.point.x, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.y, hit.point.z); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> to = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> + direction * <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous utilisons le Physics.Raycast familier, pour laisser le faisceau sortir du canon d'un pistolet et dÃ©terminer s'il intersecte avec un objet de jeu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, cependant, il y a une mise en garde: la balle volera toujours Ã  travers les zombies. Le fait est que l'auteur de l'actif a ajoutÃ© un collisionneur aux objets du niveau (bÃ¢timents, boÃ®tes, etc.). Et l'auteur de l'actif avec les personnages ne l'a pas fait. Corrigeons ce malentendu ennuyeux.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un collisionneur est un composant avec lequel le moteur physique dÃ©termine les collisions entre les objets. </font><font style="vertical-align: inherit;">Des formes gÃ©omÃ©triques gÃ©nÃ©ralement simples sont utilisÃ©es comme collisionneurs - cubes, sphÃ¨res, etc. </font><font style="vertical-align: inherit;">Bien que cette approche fournisse des collisions moins prÃ©cises, les formules d'intersection entre de tels objets sont assez simples et ne nÃ©cessitent pas de grandes ressources de calcul. </font><font style="vertical-align: inherit;">Bien sÃ»r, si vous avez besoin d'une prÃ©cision maximale, vous pouvez toujours sacrifier les performances et utiliser le MeshCollider. </font><font style="vertical-align: inherit;">Mais nous n'avons pas besoin d'une grande prÃ©cision, nous allons donc utiliser le composant CapsuleCollider: </font></font><br><br><img src="https://habrastorage.org/webt/wp/t3/qo/wpt3qo9lebty_w7hlawpe11le9u.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintenant la balle ne volera pas Ã  travers les zombies. </font><font style="vertical-align: inherit;">Cependant, les zombies sont toujours immortels.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zombies - Zombie Death! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutons d'abord une animation de mort au contrÃ´leur d'animation zombie. </font><font style="vertical-align: inherit;">Pour ce faire, faites-y glisser l'animation AssetPacksâ‡¨ToonyTinyPeopleâ‡¨TT_demoâ‡¨animationâ‡¨zombieâ‡¨Z_death_A. </font><font style="vertical-align: inherit;">Pour l'activer, crÃ©ez un nouveau paramÃ¨tre mort avec le type de dÃ©clencheur. </font><font style="vertical-align: inherit;">Contrairement Ã  d'autres paramÃ¨tres (bool, float, etc.), les dÃ©clencheurs ne se souviennent pas de leur Ã©tat et ressemblent plus Ã  un appel de fonction: ils ont activÃ© un dÃ©clencheur - la transition a fonctionnÃ© et le dÃ©clencheur a Ã©tÃ© rÃ©initialisÃ©. </font><font style="vertical-align: inherit;">Et puisqu'un zombie peut mourir dans n'importe quel Ã©tat - et s'il reste immobile et s'il est en cours d'exÃ©cution, nous ajouterons la transition de l'Ã©tat Any State: </font></font><br><br><img src="https://habrastorage.org/webt/-a/je/6j/-aje6jc9oteg-glqdrtckbjhv1o.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez les champs suivants au script Zombie:</font></font><br><br><pre> <code class="cs hljs">CapsuleCollider capsuleCollider; Animator animator; MovementAnimator movementAnimator; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dead;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans la mÃ©thode Start de la classe Zombie, insÃ©rez: </font></font><br><br><pre> <code class="cs hljs">capsuleCollider = GetComponent&lt;CapsuleCollider&gt;(); animator = GetComponentInChildren&lt;Animator&gt;(); movementAnimator = GetComponent&lt;MovementAnimator&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au tout dÃ©but de la mÃ©thode Update, vous devez ajouter une vÃ©rification: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dead) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et enfin, ajoutez la mÃ©thode publique Kill Ã  la classe Zombie: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kill</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dead) { dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; Destroy(capsuleCollider); Destroy(movementAnimator); Destroy(navMeshAgent); animator.SetTrigger(<span class="hljs-string"><span class="hljs-string">"died"</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'attribution de nouveaux domaines, je pense, est assez Ã©vidente. Quant Ã  la mÃ©thode Kill - nous y dÃ©finissons (si nous ne sommes pas morts) le drapeau de mort zombie et supprimons les composants CapsuleCollider, MovementAnimator et NavMeshAgent de notre objet de jeu, aprÃ¨s quoi nous activons la lecture de l'animation de la mort Ã  partir du contrÃ´leur d'animation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi retirer des composants? De sorte que dÃ¨s qu'un zombie meurt, il cesse de se dÃ©placer sur la carte et n'est plus un obstacle aux balles. Pour de bon, vous devez toujours vous dÃ©barrasser du corps d'une maniÃ¨re ou d'une autre d'une maniÃ¨re magnifique aprÃ¨s la lecture de l'animation de la mort. Sinon, les zombies morts continueront de ronger les ressources et, s'il y a trop de cadavres, le jeu ralentira sensiblement. Le moyen le plus simple consiste Ã  ajouter ici l'appel Destroy (gameObject, 3). Cela entraÃ®nera la suppression de cet objet de jeu par Unity 3 secondes aprÃ¨s cet appel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que tout cela fonctionne finalement, la derniÃ¨re touche est restÃ©e. Dans la classe Player, dans la mÃ©thode Update, oÃ¹ nous appelons Physics.Raycast, dans la branche pour le cas oÃ¹ une intersection a Ã©tÃ© trouvÃ©e, nous ajoutons une vÃ©rification:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hit.transform != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zombie = hit.transform.GetComponent&lt;Zombie&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zombie != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) zombie.Kill(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Physics.Raycast appelle les informations d'intersection dans la variable de hit. En particulier, dans le champ de transformation, il y aura un lien vers le composant Transformer de l'objet de jeu avec lequel le rayon s'est croisÃ©. Si cet objet de jeu a un composant Zombie, alors c'est un zombie et nous le tuons. Ã‰lÃ©mentaire! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, pour que la mort de l'ennemi soit spectaculaire, nous ajoutons un systÃ¨me de particules simple aux zombies.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les systÃ¨mes de particules vous permettent de contrÃ´ler un grand nombre de petits objets (gÃ©nÃ©ralement des sprites) selon une sorte de loi physique ou de formule mathÃ©matique. </font><font style="vertical-align: inherit;">Par exemple, vous pouvez les faire voler Ã  part ou voler directement vers le bas Ã  une certaine vitesse. </font><font style="vertical-align: inherit;">Avec l'aide de systÃ¨mes de particules dans les jeux, toutes sortes d'effets sont faits: feu, fumÃ©e, Ã©tincelles, pluie, neige, saletÃ© sous les roues, etc. </font><font style="vertical-align: inherit;">Nous utiliserons un systÃ¨me de particules pour qu'au moment de la mort, du sang gicle d'un zombie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un systÃ¨me de particules Ã  l'objet de jeu Zombie (faites un clic droit dessus et sÃ©lectionnez Effets â‡¨ SystÃ¨me de particules): </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je suggÃ¨re les options suivantes: </font></font><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transformer:</font></font></u> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position: Y 0,5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rotation: X -90 </font></font></li></ul><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SystÃ¨me de particules</font></font></u> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DurÃ©e: 0,2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boucle: faux </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DurÃ©e de vie initiale: 0,8 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taille de dÃ©part: 0,5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Couleur de dÃ©part: vert </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modificateur de gravitÃ©: 1 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jouer sur Ã©veillÃ©: faux </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ã‰mission: </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taux au fil du temps: 100 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Forme: </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rayon: 0,25 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela devrait ressembler Ã  ceci: Il </font></font><br><br><img src="https://habrastorage.org/webt/nk/rz/mj/nkrzmjt9wu6gyqt6twhgfkldivo.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reste Ã  l'activer dans la mÃ©thode Kill de la classe Zombie:</font></font><br><br><pre> <code class="cs hljs">GetComponentInChildren&lt;ParticleSystem&gt;().Play();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant une toute autre affaire! </font></font><br><br><img src="https://habrastorage.org/webt/av/sl/mf/avslmfkniyguq6m4hxma0j4sqek.gif"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Des zombies attaquent en bande </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, combattre un seul zombie est ennuyeux. </font><font style="vertical-align: inherit;">Tu l'as tuÃ© et c'est tout. </font><font style="vertical-align: inherit;">OÃ¹ est le drame? </font><font style="vertical-align: inherit;">OÃ¹ est la peur de mourir jeune? </font><font style="vertical-align: inherit;">Pour crÃ©er une vÃ©ritable atmosphÃ¨re d'apocalypse et de dÃ©sespoir, il devrait y avoir beaucoup de zombies. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heureusement, c'est assez simple. </font><font style="vertical-align: inherit;">Comme vous l'avez peut-Ãªtre devinÃ©, nous avons besoin d'un autre script. </font><font style="vertical-align: inherit;">Appelez-le EnemySpawner et remplissez-le avec le contenu suivant:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawner</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Period; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject Enemy; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TimeUntilNextSpawn; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { TimeUntilNextSpawn = Random.Range(0, Period); } // Update is called once per frame void Update() { TimeUntilNextSpawn -= Time.deltaTime; if (TimeUntilNextSpawn &lt;= 0.0f) { TimeUntilNextSpawn = Period; Instantiate(Enemy, transform.position, transform.rotation); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ã€ l'aide du champ public PÃ©riode, le concepteur de jeu peut dÃ©finir dans l'inspecteur la frÃ©quence Ã  laquelle un nouvel ennemi doit Ãªtre crÃ©Ã©. Dans le champ Ennemi, nous indiquons quel ennemi crÃ©er (jusqu'Ã  prÃ©sent, nous n'avons qu'un seul ennemi, mais Ã  l'avenir, nous pourrons en ajouter d'autres). Eh bien, alors tout est simple - en utilisant TimeUntilNextSpawn, nous comptons combien de temps il reste jusqu'Ã  la prochaine apparition de l'ennemi et, dÃ¨s que le moment est venu, nous ajoutons un nouveau zombie Ã  la scÃ¨ne en utilisant la mÃ©thode standard Instantiate. Oh oui, dans la mÃ©thode Start, nous attribuons une valeur alÃ©atoire au champ TimeUntilNextSpawn, de sorte que si nous avons plusieurs gÃ©nÃ©rateurs avec le mÃªme retard dans le niveau, ils n'ajouteront pas de zombies en mÃªme temps.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une question demeure - comment demander Ã  l'ennemi dans le champ ennemi? Pour ce faire, nous utiliserons un outil Unity tel que Â«PrefabsÂ». En fait, un prÃ©fabriquÃ© est un morceau de la scÃ¨ne enregistrÃ© dans un fichier sÃ©parÃ©. Ensuite, nous pouvons insÃ©rer ce fichier dans d'autres scÃ¨nes (ou dans la mÃªme) et nous n'avons plus besoin de le collecter Ã  partir de morceaux Ã  chaque fois. Par exemple, nous avons collectÃ©, Ã  partir des objets des murs, du sol, du plafond, des fenÃªtres et des portes, une belle maison et l'avons sauvegardÃ©e comme prÃ©fabriquÃ©e. Vous pouvez maintenant insÃ©rer cette maison dans d'autres cartes d'un simple mouvement de poignet. Dans le mÃªme temps, si vous modifiez le fichier prÃ©fabriquÃ© (par exemple, ajoutez une porte dÃ©robÃ©e Ã  la maison), l'objet changera dans toutes les scÃ¨nes. Parfois, c'est trÃ¨s pratique. Nous pouvons Ã©galement utiliser des prÃ©fabriquÃ©s comme modÃ¨les pour Instantiate - et nous utiliserons cette opportunitÃ© dÃ¨s maintenant.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour crÃ©er un prÃ©fabriquÃ©, faites simplement glisser l'objet de jeu de la fenÃªtre de hiÃ©rarchie vers la fenÃªtre de projet, Unity fera le reste. CrÃ©ons un prÃ©fabriquÃ© Ã  partir de zombies, puis ajoutons un gÃ©nÃ©rateur ennemi Ã  la scÃ¨ne: </font></font><br><br><img src="https://habrastorage.org/webt/4i/ka/kx/4ikakx3ollmpndbgcqco8341e8y.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j'ai ajoutÃ© trois autres gÃ©nÃ©rateurs dans le projet pour un changement (donc, au final, j'en ai 4). Et alors, que s'est-il passÃ©: </font></font><br><br><img src="https://habrastorage.org/webt/6h/0p/_f/6h0p_fo52j6zqydyml6z9aqlcu0.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici! Cela ressemble dÃ©jÃ  Ã  une apocalypse zombie!</font></font></b> <br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sÃ»r, c'est loin d'Ãªtre un jeu complet. </font><font style="vertical-align: inherit;">Nous n'avons pas pris en compte de nombreux problÃ¨mes, tels que la crÃ©ation d'une interface utilisateur, les sons, la vie et la mort d'un joueur - tout cela est exclu du champ d'application de cet article. </font><font style="vertical-align: inherit;">Mais il me semble que cet article sera une bonne introduction Ã  Unity pour ceux qui ne connaissent pas cet outil. </font><font style="vertical-align: inherit;">Ou peut-Ãªtre qu'une personne expÃ©rimentÃ©e pourra en tirer quelque chose? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En gÃ©nÃ©ral, mes amis, j'espÃ¨re que vous avez apprÃ©ciÃ© mon article. </font><font style="vertical-align: inherit;">Ã‰crivez vos questions dans les commentaires, j'essaierai d'y rÃ©pondre. </font><font style="vertical-align: inherit;">Le code source du projet peut Ãªtre tÃ©lÃ©chargÃ© sur le github: </font></font><a href="https://github.com/zapolnov/otus_zombies"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/zapolnov/otus_zombies</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous aurez besoin d'Unity 2019.3.0f3 ou supÃ©rieur, il peut Ãªtre tÃ©lÃ©chargÃ© entiÃ¨rement gratuitement et sans SMS depuis le site officiel: </font></font><a href="https://store.unity.com/download"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://store.unity.com/download</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Liens vers les actifs utilisÃ©s dans l'article: </font></font><br><br><ul><li> <a href="https://assetstore.unity.com/packages/3d/environments/industrial/rpg-fps-game-assets-for-pc-mobile-industrial-set-v2-0-86679">https://assetstore.unity.com/packages/3d/environments/industrial/rpg-fps-game-assets-for-pc-mobile-industrial-set-v2-0-86679</a> </li><li> <a href="https://assetstore.unity.com/packages/3d/characters/toony-tiny-people-demo-113188">https://assetstore.unity.com/packages/3d/characters/toony-tiny-people-demo-113188</a> </li><li> <a href="https://assetstore.unity.com/packages/2d/gui/icons/crosshairs-plus-139902">https://assetstore.unity.com/packages/2d/gui/icons/crosshairs-plus-139902</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485210/">https://habr.com/ru/post/fr485210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485200/index.html">DÃ©sordre au dÃ©part: post-mortem sur la vitesse de lancement d'une application iOS</a></li>
<li><a href="../fr485202/index.html">SystÃ¨me de suppression</a></li>
<li><a href="../fr485204/index.html">Retour en haut: pourquoi la capitalisation d'Amazon dÃ©passera bientÃ´t encore 1 billion de dollars</a></li>
<li><a href="../fr485206/index.html">Comment Typescript m'a-t-il dÃ©Ã§u et cela en vaut-il la peine?</a></li>
<li><a href="../fr485208/index.html">CrÃ©ation d'une infrastructure informatique tolÃ©rante aux pannes. Partie 2. Installation et configuration du cluster oVirt 4.3</a></li>
<li><a href="../fr485214/index.html">CLRium # 7: Pratique. SÃ©minaire, devoirs avec vÃ©rification, mentorat</a></li>
<li><a href="../fr485218/index.html">RÃ©servation de constantes et de crochets Git en C #</a></li>
<li><a href="../fr485220/index.html">L'Ã©volution du pare-feu d'applications Web: des pare-feu aux systÃ¨mes de sÃ©curitÃ© basÃ©s sur le cloud d'apprentissage automatique</a></li>
<li><a href="../fr485222/index.html">Comment travailler avec des leaders d'opinion en Chine? Cinq conseils pratiques</a></li>
<li><a href="../fr485224/index.html">Comment la livraison des marchandises tombe-t-elle sous la limite douaniÃ¨re Ã  partir du 1er janvier 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>