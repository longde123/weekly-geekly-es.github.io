<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó≥Ô∏è üéÖüèΩ üî™ Criando um Plug-in para o Clang Static Analyzer para Procurar Estouros Inteiros üî∂ üë®‚Äçüë©‚Äçüë¶ üòì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Autor do artigo: 0x64rem 
 Entrada 


 H√° um ano e meio, tive a ideia de realizar meu phaser como parte da tese na universidade. Comecei a estudar mat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando um Plug-in para o Clang Static Analyzer para Procurar Estouros Inteiros</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/473412/"><p><img src="https://habrastorage.org/getpro/habr/post_images/e69/d01/efb/e69d01efbeff395f19dbb543055a5493.jpg" title="fig. 1"></p><br><p>  <em>Autor do artigo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">0x64rem</a></em> </p><br><h2 id="vstuplenie">  Entrada </h2><br><p>  H√° um ano e meio, tive a ideia de realizar meu phaser como parte da tese na universidade.  Comecei a estudar materiais sobre gr√°ficos de controle de fluxo, gr√°ficos de fluxo de dados, execu√ß√£o simb√≥lica etc.  A seguir, veio a busca por ferramentas, uma amostra de diferentes bibliotecas (Angr, Triton, Pin, Z3).  Nada concreto aconteceu no final, at√© este ver√£o, fui para o programa Summer of Hack 2019 da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Digital Security</a> , onde me ofereceram a extens√£o do Analisador est√°tico de Clang como tema para o projeto.  Pareceu-me que esse t√≥pico me ajudaria a colocar meu conhecimento te√≥rico nas prateleiras, a come√ßar a implementar algo substancial e a receber recomenda√ß√µes de mentores experientes.  A seguir, mostrarei como foi o processo de elabora√ß√£o do plug-in e descreverei o curso de meus pensamentos durante o m√™s do est√°gio. </p><a name="habracut"></a><br><h2 id="clang-static-analyzer">  Analisador est√°tico de clang </h2><br><p>  Para o desenvolvimento, o Clang fornece tr√™s op√ß√µes de interface para intera√ß√£o: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LibClang</a> √© uma interface C de alto n√≠vel que permite que voc√™ interaja com o AST, mas n√£o totalmente.  Uma boa op√ß√£o se voc√™ precisar de intera√ß√£o com outro idioma (por exemplo, a implementa√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">liga√ß√µes</a> ) ou uma interface est√°vel. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Clang Plugins</a> - bibliotecas din√¢micas chamadas em tempo de compila√ß√£o.  Permite manipular completamente o AST. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LibTooling</a> - uma biblioteca para criar ferramentas separadas com base no Clang.  Tamb√©m oferece acesso total √† intera√ß√£o com o AST.  O c√≥digo resultante pode ser executado fora do ambiente de constru√ß√£o do projeto verificado. </li></ul><br><p>  Como vamos expandir os recursos do Clang Static Analyzer, escolhemos a implementa√ß√£o do plug-in.  Voc√™ pode escrever o c√≥digo para o plug-in em C ++ ou Python. </p><br><p>  Para o √∫ltimo, existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ligantes</a> que permitem analisar o c√≥digo-fonte, iterar sobre os n√≥s da √°rvore de sintaxe abstrata resultante, tamb√©m t√™m acesso √†s propriedades dos n√≥s e podem mapear o n√≥ para a linha do c√≥digo-fonte.  Esse conjunto √© adequado para um simples verificador.  Veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o reposit√≥rio llvm para</a> mais detalhes. </p><br><p>  Como minha tarefa requer uma an√°lise detalhada do c√≥digo, o C ++ foi escolhido para desenvolvimento.  A seguir, √© apresentada uma introdu√ß√£o √† ferramenta. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Clang Staic Analyzer</a> (doravante CSA) √© uma ferramenta para an√°lise est√°tica do c√≥digo C / C ++ / Objective-C com base na execu√ß√£o simb√≥lica.  O analisador pode ser chamado pelo front-end do Clang adicionando os sinalizadores -cc1 e -analyze ao comando build ou por meio de um bin√°rio de scan-build separado.  Al√©m da an√°lise em si, o CSA possibilita a gera√ß√£o de relat√≥rios visuais de html. </p><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ,      clang' clang -cc1 --help #  CSA  ‚Ññ1 clang++ -cc1 -x c++ -load path/to/Checker.so -analyze -analyzer-checker=test.Me -analyzer-config $BUILD_OPTIONS Checker.cpp</span></span></code> </pre> <br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#  CSA  ‚Ññ2 scan-build -load-plugin path/to/Checker.so -enable-checker test.Me $BUILD_COMMAND</span></span></code> </pre> <br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#       DivideZero clang++ -cc1 -analyze -analyzer-checker=core.DivideZero -o reports div-by-zero-test.cpp</span></span></code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/6dd/b8e/302/6ddb8e302c62b6cc58c4533a894d49e9.jpg" alt=" " title="fig. 2"></p><br><p>  O CSA possui uma excelente biblioteca para analisar o c√≥digo-fonte usando AST (Abstract Syntax Tree), CFG (Control Flow Graph).  A partir das estruturas, √© poss√≠vel ver mais as declara√ß√µes de vari√°veis, seus tipos, o uso de operadores bin√°rios e un√°rios, voc√™ pode obter express√µes simb√≥licas etc.  Meu plug-in usar√° a funcionalidade das classes AST, essa op√ß√£o ser√° justificada ainda mais.  A seguir, √© apresentada uma lista de classes usadas na implementa√ß√£o do plug-in. A lista ajudar√° a obter um entendimento prim√°rio dos recursos do CSA: </p><br><ul><li><p>  Stmt - isso inclui opera√ß√µes bin√°rias. </p><br></li><li><p>  Decl - declara√ß√£o de vari√°veis. </p><br></li><li><p>  Expr - armazena as partes esquerda e direita das express√µes, seu tipo. </p><br></li><li><p>  ASTContext - informa√ß√µes sobre a √°rvore, o n√≥ atual. </p><br></li><li><p>  Gerenciador de origem - informa√ß√µes sobre o c√≥digo real que corresponde √† parte da √°rvore. </p><br></li><li><p>  RecursiveASTVisitor, ASTMatcher - classes para atravessar uma √°rvore. </p><br><p>  Repito que o CSA oferece ao desenvolvedor a oportunidade de examinar em detalhes a estrutura do c√≥digo, e as classes listadas acima s√£o apenas uma pequena parte do dispon√≠vel.  Definitivamente, recomendo consultar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o da</a> sua vers√£o do Clang se voc√™ n√£o souber extrair nenhum dado;  provavelmente, algo adequado j√° foi escrito. </p><br></li></ul><br><h2 id="poisk-celochislennyh-perepolneniy">  Pesquisa de estouro inteiro </h2><br><p>  Para come√ßar a implementar o plug-in, voc√™ precisa escolher a tarefa que ele resolver√°.  Nesse caso, o site llvm fornece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">listas de poss√≠veis verificadores</a> ; voc√™ tamb√©m pode modificar os verificadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">est√°veis</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alfa</a> existentes.  Durante a revis√£o do c√≥digo dos verificadores dispon√≠veis, ficou claro que, para um desenvolvimento mais bem-sucedido da libclang, √© melhor escrever seu verificador do zero, para que a escolha tenha sido feita a partir de uma lista de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">id√©ias n√£o realizadas</a> .  Como resultado, a op√ß√£o foi escolhida para criar um verificador para detec√ß√£o de estouro inteiro.  O Clang j√° possui funcionalidade para evitar essa vulnerabilidade (os sinalizadores -ftrapv, -fwrapv e similares s√£o indicados para seu uso), ele √© incorporado ao compilador e esse escape √© derramado em avisos, e geralmente n√£o √© procurado l√°.  Ainda existe o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UBSan</a> , mas esses s√£o desinfetantes, nem todos os usam, e esse m√©todo √© sobre a identifica√ß√£o de problemas em tempo de execu√ß√£o, e o plug-in CSA funciona em tempo de compila√ß√£o, analisando as fontes. </p><br><p>  A seguir, √© apresentada a cole√ß√£o de materiais sobre a vulnerabilidade selecionada.  O excesso de n√∫mero inteiro costumava ser algo simples e n√£o s√©rio.  De fato, a vulnerabilidade √© divertida e pode ter conseq√º√™ncias impressionantes. <br>  Estouros de n√∫mero inteiro s√£o um tipo de vulnerabilidade que pode resultar em dados do tipo n√∫mero inteiro no c√≥digo assumindo valores inesperados.  Estouro - se a vari√°vel se tornar maior do que o pretendido, Estouro insuficiente - menor que seu tipo original.  Esses erros podem aparecer por causa do programador e por causa do compilador. </p><br><p>  Em C ++, durante uma opera√ß√£o de compara√ß√£o aritm√©tica, os valores inteiros s√£o convertidos para o mesmo tipo, mais frequentemente para um maior em termos de profundidade de bits.  E esses fantasmas ocorrem em todos os lugares e constantemente, podem ser expl√≠citos ou impl√≠citos.  Existem v√°rias regras pelas quais fantasmas ocorrem [1]: </p><br><ul><li>  Convertendo de um assinado para um tipo com um bit assinado, mas maior: basta adicionar a ordem superior. </li><li>  Convertendo um n√∫mero inteiro assinado em um n√∫mero inteiro n√£o assinado da mesma capacidade: o negativo √© convertido em positivo e assume um novo significado.  Um exemplo de erro semelhante no DirectFB √© o <a href="">CVE-2014-2977</a> . </li><li>  Convertendo um n√∫mero inteiro assinado em um n√∫mero inteiro n√£o assinado com uma maior capacidade de bits: primeiro, a capacidade de bits ser√° expandida; se o n√∫mero for negativo, o valor ser√° alterado incorretamente.  Por exemplo: 0xff (-1) se torna 0xffffffff. </li><li>  Um n√∫mero inteiro n√£o assinado com um sinal da mesma capacidade de bits: um n√∫mero pode alterar o valor, dependendo do valor do bit alto. </li><li>  Um n√∫mero inteiro n√£o assinado com um n√∫mero inteiro com um sinal de maior capacidade: primeiro, a capacidade de um n√∫mero n√£o assinado aumenta, depois a convers√£o para um n√∫mero assinado. </li><li>  Convers√£o descendente: os bits s√£o truncados.  Isso pode tornar os valores n√£o assinados negativos e assim por diante.  Um exemplo dessa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vulnerabilidade no PHP</a> . </li></ul><br><p>  I.e.  o gatilho da vulnerabilidade pode ser entrada n√£o segura do usu√°rio, aritm√©tica incorreta, convers√£o incorreta de tipos causada por um programador ou compilador durante a otimiza√ß√£o.  A op√ß√£o de bomba-rel√≥gio tamb√©m √© poss√≠vel, quando um peda√ßo de c√≥digo √© inofensivo em uma vers√£o do compilador, mas com o lan√ßamento de um novo algoritmo de otimiza√ß√£o "explode" e causa comportamento inesperado.  Na hist√≥ria, j√° houve esse caso com a classe SafeInt (muito ir√¥nica) [5, 6.5.2]. </p><br><p>  Estouros de n√∫mero inteiro abrem um vetor amplo: √© poss√≠vel for√ßar a execu√ß√£o a seguir um caminho diferente (se o estouro afetar instru√ß√µes condicionais), causar um estouro de buffer.  Para maior clareza, voc√™ pode se familiarizar com CVEs espec√≠ficas, ver suas causas, conseq√º√™ncias.  √â natural procurar um melhor estouro de n√∫mero inteiro em produtos de c√≥digo aberto, para que voc√™ possa ler n√£o apenas a descri√ß√£o, mas tamb√©m o c√≥digo. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CVE-2019-3560</a> - O excesso de n√∫mero inteiro no Fizz (um projeto que implementa o TLS para Facebook) pode explorar uma vulnerabilidade de DoS usando um pacote de rede apertado. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CVE-2018-14618</a> - Estouro de buffer no Curl causado por estouro de n√∫mero inteiro devido ao tamanho da senha. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CVE-2018-6092</a> - Em sistemas de 32 bits, uma vulnerabilidade no WebAssembly for Chrome permitia que o RCE fosse implementado por meio de uma p√°gina HTML especial. </li></ul><br><p>  Para n√£o reinventar a roda, foi considerado o c√≥digo para detectar o excesso de n√∫mero inteiro no analisador est√°tico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CppCheck</a> .  Sua abordagem √© a seguinte: </p><br><ol><li>  Determine se uma express√£o √© um operador bin√°rio. </li><li>  Se sim, verifique se os dois argumentos s√£o do tipo inteiro. </li><li>  Determine o tamanho dos tipos. </li><li>  Verifique por meio de c√°lculos se o valor pode ir al√©m de seus limites m√°ximo ou m√≠nimo. <br>  Mas, nesta fase, n√£o deu clareza.  Acontece muitas hist√≥rias diferentes, e dessa sistematiza√ß√£o de informa√ß√µes se torna mais dif√≠cil.  Tudo em seu lugar coloca a lista da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE</a> .  No total, existem 9 tipos de estouro de n√∫mero inteiro alocados no site: <br><ul><li>  190 - fluxo inteiro de fluxo </li><li>  191 - underflow inteiro </li><li>  192 - erro de coer√ß√£o de n√∫mero inteiro </li><li>  193 - fora de um </li><li>  194 - Extens√£o inesperada de sinal </li><li>  195 - Erro de convers√£o assinado n√£o assinado </li><li>  196 - Erro de convers√£o n√£o assinado em assinado </li><li>  197 - Erro de truncamento num√©rico </li><li>  198 - Uso de pedidos de bytes incorretos </li></ul></li></ol><br><p>  Consideramos o motivo de cada op√ß√£o e entendemos que os estouros ocorrem com proje√ß√µes expl√≠citas / impl√≠citas incorretas.  E porque  Se qualquer convers√£o for exibida na estrutura da √°rvore de sintaxe abstrata, usaremos o AST para an√°lise.  Na figura abaixo (Fig. 3), pode-se ver que qualquer opera√ß√£o que cause uma convers√£o na √°rvore √© um n√≥ separado e, vagando pela √°rvore, podemos verificar todas as convers√µes de tipo com base em uma tabela com transforma√ß√µes que podem causar um erro. </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Assine g </th><th>  Assine l </th><th>  Assine e </th><th>  Cancelar assinatura g </th><th>  Cancelar assinatura l </th><th>  Cancelar assinatura e </th></tr></thead><tbody><tr><td>  Assinar </td><td>  + </td><td>  - </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td></tr><tr><td>  Cancelar assinatura </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  + </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e72/315/acb/e72315acbeaf57dcf7ea2f85670fe4e0.jpg" title="fig. 3"></p><br><p>  Mais especificamente, o algoritmo soa assim: damos uma olhada no Casts e olhamos para o IntegralCast (convers√µes de n√∫mero inteiro).  Se voc√™ encontrar um n√≥ adequado, observe os descendentes em busca de uma opera√ß√£o bin√°ria ou Decl (declara√ß√£o de vari√°vel).  No primeiro caso, voc√™ precisa verificar a profundidade do sinal e dos bits que a opera√ß√£o bin√°ria usa.  No segundo caso, compare apenas o tipo de declara√ß√£o. </p><br><h2 id="realizaciya-chekera">  Implementa√ß√£o do verificador </h2><br><p>  Vamos come√ßar a implementa√ß√£o.  Precisamos de um esqueleto para um verificador, que pode ser uma biblioteca independente ou pode ser montado como parte do Clang.  No c√≥digo, a diferen√ßa ser√° pequena.  Se voc√™ j√° planeja escrever seu pr√≥prio plug-in, recomendo que voc√™ leia imediatamente um pequeno pdf: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Clang Static Analyzer: A Checker Developer Guide"</a> , as coisas b√°sicas est√£o bem descritas l√°, embora algo possa n√£o ser mais relevante, a biblioteca √© atualizada regularmente, mas voc√™ agarre imediatamente. </p><br><p>  Se voc√™ deseja adicionar seu verificador ao conjunto de clang, √© necess√°rio: </p><br><ol><li><p>  Escreva o verificador em si com aproximadamente o seguinte conte√∫do: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperChecker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Checker&lt;check::PreStmt&lt;BinaryOperator&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">//       ,    .       struct CheckerOpts { //       string FlagOne; int FlagTwo; }; CheckerOpts Opts; //cool code }; } void ento::registerSuperChecker(CheckerManager &amp;mgr) { auto checker = mgr.registerChecker&lt;SuperChecker&gt;(); //       ,   4    //       ,  stand-alone    . AnalyzerOptions &amp;AnOpts = mgr.getAnalyzerOptions(); SuperChecker::CheckerOpts &amp;ChOpts = checker-&gt;Opts; ChOpts.FlagOne = AnOpts.getCheckerStringOption("Inp1", "", checker); ChOpts.FlagTwo = AnOpts.getCheckerIntegerOption("Inp2", 0, checker); // getCheckerIntegerOption:  ,  ,   }</span></span></code> </pre> <br></li><li><p>  Em seguida, no c√≥digo-fonte do Clang, voc√™ precisar√° alterar os arquivos <code>CMakeLists.txt</code> e <code>Checkers.td</code> .  Viva por aqui <code>${llvm-source-path}/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt</code> <br>  e aqui <code>${llvm-source-path}/clang/include/clang/StaticAnalyzer/Checkers/Checkers.td</code> . <br>  No primeiro, voc√™ s√≥ precisa adicionar o nome do arquivo com o c√≥digo; no segundo, voc√™ precisa adicionar uma descri√ß√£o estrutural: </p><br><pre> <code class="cpp hljs"> #Checkers.td def SuperChecker : Checker&lt;<span class="hljs-string"><span class="hljs-string">"SuperChecker"</span></span>&gt;, HelpText&lt;<span class="hljs-string"><span class="hljs-string">"test checker"</span></span>&gt;, Documentation&lt;HasDocumentation&gt;;</code> </pre> <br></li></ol><br><p>  Se n√£o estiver claro, no arquivo <code>Checkers.td</code> h√° exemplos suficientes de como e o que fazer. </p><br><p>  Provavelmente voc√™ n√£o desejar√° reconstruir o Clang e recorrer√° √† op√ß√£o com o assembly da biblioteca (so / dll).  Ent√£o, no c√≥digo do verificador, deve ser algo como isto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperChecker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Checker&lt;check::PreStmt&lt;BinaryOperator&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">//       ,    .       struct CheckerOpts { string FlagOne; int FlagTwo; }; CheckerOpts Opts; //cool code }; } void initializationFunction(CheckerManager &amp;mgr){ SuperChecker *checker = mgr.registerChecker&lt;SuperChecker&gt;(); //       ,   4    AnalyzerOptions &amp;AnOpts = mgr.getAnalyzerOptions(); TestChecker::CheckerOpts &amp;ChOpts = checker-&gt;Opts; ChOpts.FlagOne = AnOpts.getCheckerStringOption("Inp1", "", checker); ChOpts.FlagTwo = AnOpts.getCheckerIntegerOption("Inp2", 0, checker); // getCheckerIntegerOption:  ,  ,   } extern "C" void clang_registerCheckers (CheckerRegistry &amp;registry) { registry.addChecker(&amp;initializationFunction, "test.Me", "SuperChecker description", "doc_link"); } extern "C" const char clang_analyzerAPIVersionString [] = "8.0.1";</span></span></code> </pre> <br><p>  Em seguida, colete seu c√≥digo, voc√™ pode escrever seu pr√≥prio script para montagem, mas se tiver algum problema com isso (como o autor tinha :)), use o Makefile no c√≥digo-fonte do clang e fa√ßa o comando clangStaticAnalyzerCheckers de uma maneira estranha. </p><br><p>  Em seguida, ligue para o verificador: </p><br><ul><li><p>  para damas embutidas </p><br><pre> <code class="bash hljs">clang++ -cc1 -analyze -analyzer-checker=core.DivideZero test.cpp</code> </pre> <br></li><li><p>  para externo </p><br><pre> <code class="bash hljs">clang++ -cc1 -load <span class="hljs-variable"><span class="hljs-variable">${PATH_TO_CHECKER}</span></span>/SuperChecker.so -analyze -analyzer-checker=test.Me -analyzer-config test.Me:UsrInp1=<span class="hljs-string"><span class="hljs-string">"foo"</span></span> test.Me:Inp1=<span class="hljs-string"><span class="hljs-string">"bar"</span></span> -analyzer-config test.Me:Inp2=123 test.cpp</code> </pre> <br><p>  Nesta fase, j√° temos algum tipo de resultado (Fig. 4), mas o c√≥digo escrito pode detectar apenas poss√≠veis estouros.  E isso significa um grande n√∫mero de falsos positivos. </p><br></li></ul><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ac1/79d/29b/ac179d29b330efd513343fdd5f9a2ddd.jpg" title="fig. 4"></p><br><p>  Para corrigir isso, podemos: </p><br><ul><li>  Percorrendo o gr√°fico de um lado para o outro e verificando os valores espec√≠ficos das vari√°veis ‚Äã‚Äãpara os casos em que temos um potencial estouro. </li><li>  Durante o percurso AST, salve imediatamente valores espec√≠ficos para vari√°veis ‚Äã‚Äãe verifique-os quando necess√°rio. </li><li>  Use an√°lise de contamina√ß√£o. </li></ul><br><p>  Para fundamentar argumentos adicionais, vale ressaltar que, ao analisar o Clang, todos os arquivos especificados na diretiva <code>#include</code> tamb√©m analisam, como resultado, o tamanho do AST resultante aumenta.  Como resultado, das op√ß√µes propostas, apenas uma √© racional em rela√ß√£o a uma tarefa espec√≠fica: </p><br><ul><li>  Primeiro, leva muito tempo para ser conclu√≠do.  Andando em uma √°rvore, pesquisando e contando tudo o que voc√™ precisa levar√° muito tempo, pode ser dif√≠cil analisar um projeto grande com esse c√≥digo.  Para percorrer a √°rvore no c√≥digo, usaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a classe</a> <code>clang::RecursiveASTVisitor</code> , que realiza uma pesquisa de profundidade recursiva.  Uma estimativa do tempo dessa abordagem ser√° <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7cf317fbe3965ae3164f28c1f6858696adb23f4" title="classifica√ß√£o de dificuldade">  , onde V √© o conjunto de v√©rtices e E √© o conjunto de arestas do gr√°fico. </li><li>  O segundo - voc√™ certamente pode armazenar, mas n√£o sabemos do que precisamos e do que n√£o precisamos.  Al√©m disso, as pr√≥prias estruturas em √°rvore, que usamos na an√°lise, exigem muita mem√≥ria; portanto, gastar esses recursos em outra coisa √© uma m√° id√©ia. </li><li>  Terceiro, √© uma boa id√©ia: para esse m√©todo, voc√™ pode encontrar pesquisas e exemplos suficientes.  Mas na CSA n√£o h√° m√°cula pronta.  Existe um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">verificador</a> , que foi adicionado posteriormente √† lista de verificadores alfa (alpha.security.taint.TaintPropagation) nas fontes, descrito no arquivo <code>GenericTaintChecker.cpp</code> .  O verificador √© bom, mas adequado apenas para fun√ß√µes de E / S inseguras conhecidas de C, apenas "marca" vari√°veis ‚Äã‚Äãque eram argumentos ou resultados de fun√ß√µes perigosas.  Al√©m das op√ß√µes descritas, vale a pena considerar vari√°veis ‚Äã‚Äãglobais, campos de classe etc. para restaurar corretamente o modelo de "distribui√ß√£o". </li></ul><br><p>  O tempo restante para o est√°gio foi gasto lendo <code>GenericTaintChecker.cpp</code> e tentando refaz√™-lo para atender √†s suas necessidades.  N√£o deu certo at√© o final do per√≠odo, mas continuou sendo uma tarefa de aprimoramento que j√° estava al√©m do escopo do treinamento no DSec.  Tamb√©m durante o desenvolvimento, ficou claro que a identifica√ß√£o de fun√ß√µes perigosas √© uma tarefa separada, nem sempre os lugares perigosos do projeto v√™m de algumas fun√ß√µes padr√£o; portanto, um sinalizador foi adicionado ao verificador para indicar uma lista de fun√ß√µes que ser√£o consideradas "envenenadas" / "marcadas" durante a an√°lise de contamina√ß√£o. <br>  Al√©m disso, uma verifica√ß√£o foi adicionada para determinar se a vari√°vel √© um campo de bits.  Por ferramentas CSA padr√£o, o tamanho √© determinado pelo tipo e, se trabalharmos com um campo de bits, seu tamanho ter√° o valor do tipo de bit de todo o campo, e n√£o o n√∫mero de bits especificado na declara√ß√£o da vari√°vel. </p><br><h2 id="chto-v-itoge">  Qual √© o resultado? </h2><br><p>  No momento, um verificador simples foi implementado que pode avisar apenas sobre poss√≠veis estouros de n√∫mero inteiro.  Uma classe modificada para an√°lise de contamina√ß√£o, que ainda tem muito trabalho a fazer.  Depois disso, voc√™ precisa usar o SMT para determinar os estouros.  Para isso, o solver Z3 SMT √© adequado, que foi adicionado ao assembly Clang na vers√£o 5.0.0 (a julgar pelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">notas de vers√£o</a> ).  Para usar o solucionador, √© necess√°rio que o Clang seja constru√≠do com a op√ß√£o <code>CLANG_ANALYZER_BUILD_Z3=ON</code> e, quando o plug-in CSA for chamado diretamente, os <code>-Xanalyzer -analyzer-constraints=z3</code> ser√£o transmitidos. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reposit√≥rio de Resultados do GitHub</a> </p><br><h2 id="ssylki">  Refer√™ncias: </h2><br><ol><li><p>  Howard M., Leblanc D., Viega J. "Os 24 Pecados da Seguran√ßa do Computador" </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como escrever um verificador em 24 horas</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Clang Static Analyzer: Guia do desenvolvedor de um verificador</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manual de desenvolvimento do verificador CSA</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dietz W. et al.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">No√ß√µes b√°sicas sobre estouro de n√∫mero inteiro em C / C ++</a> </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt473412/">https://habr.com/ru/post/pt473412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt473394/index.html">Todos voc√™s est√£o mentindo! Sobre a publicidade em CRM</a></li>
<li><a href="../pt473396/index.html">Precisamos de outra bitrix</a></li>
<li><a href="../pt473400/index.html">Tecnologia Text-to-Speech de alta qualidade, leve e adapt√°vel usando LPCNet</a></li>
<li><a href="../pt473406/index.html">Maratona gr√°tis "Ci√™ncia de dados e IA: ensine a m√°quina a escrever o roteiro da s√©rie"</a></li>
<li><a href="../pt473408/index.html">Depurando vazamentos de mem√≥ria oculta no Ruby</a></li>
<li><a href="../pt473416/index.html">Programa da Confer√™ncia ZeroNights 2019</a></li>
<li><a href="../pt473418/index.html">OSCP - Seguran√ßa Ofensiva</a></li>
<li><a href="../pt473420/index.html">Abrimos a temporada de encontros com PHP em Nizhny Novgorod em 2 de novembro</a></li>
<li><a href="../pt473424/index.html">A ARM anunciou as solu√ß√µes gr√°ficas Mali-G57 Valhall e Mali-D37, neuroprocessadores Ethos-N57 e N37</a></li>
<li><a href="../pt473426/index.html">Automa√ß√£o de testes de ponta a ponta de um sistema de informa√ß√£o integrado. Parte 1. Organizacional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>