<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😁 🖊️ 👐 En bref sur les types d'architectures logicielles et celle que nous avons choisie pour le fournisseur IaaS 👵🏾 🀄️ 🦁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il existe de nombreux types d'architectures logicielles avec leurs avantages et leurs inconvénients. Ensuite, nous parlerons des fonctionnalités des p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>En bref sur les types d'architectures logicielles et celle que nous avons choisie pour le fournisseur IaaS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/1cloud/blog/424911/">  Il existe de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombreux types d'architectures logicielles</a> avec leurs avantages et leurs inconvénients.  Ensuite, nous parlerons des fonctionnalités des plus populaires et parlerons de notre transition vers les microservices. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/xy/c4/0n/xyc40n4lngvgriexbx9vviubxki.jpeg"></a> <a name="habracut"></a><br>  <font color="#A9A9A9"><i>/ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libreshot</a> / PD</i></font> <br><br><h2>  Types d'architectures logicielles </h2><br><h5>  Architecture en couches </h5><br>  Il s'agit de l'une des architectures les plus courantes.  Sur sa base, de nombreux grands frameworks sont construits - Java EE, Drupal, Express.  L'exemple le plus célèbre de cette architecture est peut-être le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèle de</a> réseau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OSI</a> . <br><br>  Le système est divisé en niveaux, dont chacun interagit avec seulement deux voisins.  Par conséquent, les requêtes vers la base de données, qui se trouve généralement à la toute fin de la chaîne d'interaction, passent séquentiellement à travers chaque «couche». <br><br>  L'architecture <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'implique</a> aucun nombre obligatoire de niveaux - il peut y en avoir trois, quatre, cinq ou plus.  Le plus souvent, des systèmes à trois niveaux sont utilisés: avec un niveau de présentation (client), un niveau logique et un niveau de données. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nn/qa/b8/nnqab847wdvsg0sbvwph-yumd3e.png" width="300"></div><br>  D'innombrables livres et articles ont été écrits sur l'architecture à plusieurs niveaux.  Et il y avait des opinions différentes sur ses avantages et ses inconvénients. <br><br>  <i>Avantages:</i> <br><br>  Chaque niveau de cette architecture exécute un ensemble strictement limité de fonctions (qui ne sont pas répétées d'une couche à l'autre) et ne sait pas comment les autres niveaux sont organisés.  Par conséquent, le «contenu» des niveaux peut être modifié sans risque de conflits globaux entre les couches. <br><br>  En général, les applications à plusieurs niveaux sont si répandues que des générateurs de modèles spéciaux sont créés pour leur développement.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LASG pour Visual Studio</a> propose plusieurs méthodes de génération de code qui automatisent les tâches de routine et aident à créer des niveaux d'application. <br><br>  <i>Inconvénients:</i> <br><br>  En programmation, on dit que tout problème peut être résolu en ajoutant un autre niveau d'abstraction.  Cependant, cette approche peut finalement conduire à une mauvaise organisation du code et dérouter les développeurs. <br><br>  Un autre problème vient de cela - la faible vitesse.  De nombreuses informations commencent à passer inutilement d'une couche à l'autre, sans utiliser de logique métier.  Ce problème <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est</a> parfois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appelé un</a> anti-modèle de gouffre, un modèle de conception lorsque le nombre d'opérations inutiles commence à prévaloir sur les opérations utiles. <br><br>  Trouver des bogues sur des systèmes à plusieurs niveaux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut</a> également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">être difficile</a> .  Avant d'entrer dans la base de données, les informations passent par tous les niveaux (car la base de données est le composant final).  Si, pour une raison quelconque, ces informations sont endommagées (ou perdues en cours de route), pour trouver une erreur, vous devez analyser chaque niveau séparément. <br><br>  <i>Bon ajustement:</i> <br><br><ul><li>  Pour créer de nouvelles applications qui doivent être déployées rapidement.  Il s'agit d'une sorte de "modèle à usage général". <br><br><blockquote>  Lorsque nous avons commencé à travailler sur les systèmes internes de notre fournisseur d'infrastructure virtuelle dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1cloud</a> , nous avons utilisé ce type particulier d'architecture.  Au départ, nous n'avions pas pour tâche de créer un service IaaS capable de traiter le trafic de dizaines ou de centaines de milliers d'utilisateurs.  Nous avons décidé de lancer rapidement le produit sur le marché et de commencer à développer une base de clients et à résoudre les problèmes de mise à l'échelle au fur et à mesure qu'ils deviennent disponibles (et maintenant nous transférons tous les systèmes vers une architecture de microservice, qui sera discutée plus tard). </blockquote><br>  Parmi les développeurs, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il y a une opinion</a> qu'il n'est pas nécessaire dès les premiers jours du projet de le préparer à des charges colossales (écrire un logiciel à l'épreuve du temps).  Les exigences réelles pour l'application ou le service peuvent différer des attentes et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les objectifs commerciaux peuvent changer</a> .  Par conséquent, un code écrit dans un avenir lointain risque de devenir une dette technique. </li><li>  Selon O'Reilly, l'architecture en couches est un choix naturel pour de nombreuses applications d'entreprise.  Comme les entreprises (surtout les grandes) partagent souvent des compétences: il y a une équipe responsable du front-end, il y a des gens qui sont responsables du back-end, etc.  Cela implique la division naturelle des applications en niveaux: certains développeurs travaillent sur le client, d'autres sur la logique. <br><br>  Une relation similaire entre la structure de l'organisation et les approches de développement d'applications est également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dictée par la loi de Conway</a> , formulée en 1967.  Il se lit comme suit: «Lors du développement d'un système, les organisations sont obligées d'adhérer à un schéma qui répète la structure des communications au sein de l'entreprise. </li></ul><br><h5>  Architecture orientée événement </h5><br>  Dans ce cas, le développeur prescrit le comportement (réactions) du programme lorsque des événements se produisent.  Un événement dans le système est considéré comme un changement significatif de son état. <br><br>  Vous pouvez faire une analogie avec l'achat d'une voiture en cabine.  Lorsqu'une voiture trouve un nouveau propriétaire, son état passe de «à vendre» à «vendu».  Cet événement lance le processus de préparation à la pré-vente - installation d'équipements supplémentaires, vérification de l'état technique, lavage, etc. <br><br>  Un système piloté par événements contient généralement deux composants: les sources d'événements (agents) et leurs consommateurs (récepteurs).  Il existe également généralement deux types d'événements: un événement initiateur et un événement auquel les consommateurs répondent. <br><br>  Un exemple de la mise en œuvre d'une telle architecture est la bibliothèque Java Swing.  Si la classe a besoin d'une alerte sur un événement, le développeur implémente le soi-disant écouteur - ActionListener (il "attrape" l'événement correspondant) et l'ajoute à l'objet que cet événement peut générer. <br><br>  Le code d'implémentation suivant pour ce mécanisme est fourni sur le Wiki: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooPanel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JPanel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooPanel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); JButton btn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JButton(<span class="hljs-string"><span class="hljs-string">"Click Me!"</span></span>); btn.addActionListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(btn); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionPerformed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ActionEvent ae)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Button has been clicked!"</span></span>); } }</code> </pre> <br>  <i>Avantages de l'architecture:</i> <br><br>  Étant donné que les applications se composent d'un grand nombre de modules asynchrones (qui n'ont pas d'informations sur la mise en œuvre de l'autre), elles sont faciles à mettre à l'échelle.  Ces systèmes sont assemblés comme un constructeur - vous n'avez pas besoin d'enregistrer les dépendances, implémentez simplement un nouveau module.  De plus, le modèle asynchrone permet des performances élevées des applications. <br><br>  <i>Inconvénients:</i> <br><br>  La nature asynchrone de ces applications complique le débogage.  Un événement peut déclencher plusieurs chaînes d'actions à la fois.  S'il existe de nombreuses chaînes de ce type, il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut être difficile de</a> comprendre la cause exacte de l'échec.  Pour résoudre le problème, nous devons trouver les conditions difficiles de la gestion des erreurs.  À partir de là, le problème de la journalisation suit - les journaux sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">difficiles à</a> structurer. <br><br>  <i>Convient pour:</i> <br><br><ul><li>  Création de systèmes asynchrones.  Cela est évident car l'architecture elle-même se compose d'un grand nombre de modules asynchrones. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Peut être utilisé</a> pour créer une interface utilisateur.  Une page Web agit comme un conteneur dans lequel chacun de ses composants est isolé et répond à certaines actions de l'utilisateur. </li><li>  Organiser la messagerie entre différents systèmes d'information. </li></ul><br><h5>  Architecture micro-noyau </h5><br>  Ce type d'architecture se compose de deux composants: le cœur du système et les plugins.  Les plugins sont responsables de la logique métier, et le noyau gère leur chargement et déchargement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5t/fm/sy/5tfmsyjhqdngpuld3y-8feeurxs.png" width="400"></div><br>  À titre d'exemple d'architecture micro-noyau, le livre O'Reilly <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fournit un</a> IDE Eclipse.  Il s'agit d'un simple éditeur qui ouvre des fichiers, leur permet d'être modifiés et exécute des processus d'arrière-plan.  Mais avec l'ajout de plugins (par exemple, le compilateur Java), ses fonctionnalités s'étendent. <br><br>  L'architecture du micro-noyau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisait</a> à une époque le système d'exploitation Symbian pour les appareils mobiles (le développement a été arrêté en 2012).  Dans son micro-noyau se trouvait un planificateur de tâches, des systèmes de gestion de la mémoire et des pilotes, et le système de fichiers et les composants responsables des communications téléphoniques faisaient office de plug-ins. <br><br>  <i>Avantages de l'architecture:</i> <br><br>  Il est facile de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">porter une</a> application d'un environnement à un autre, car seul le micro-noyau doit être modifié.  La séparation des politiques de haut niveau et des mécanismes de bas niveau simplifie la prise en charge du système et garantit son extensibilité. <br><br>  <i>Inconvénients:</i> <br><br>  Les performances des applications sont réduites si vous branchez trop de modules.  Cependant, il peut être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problématique de trouver un équilibre</a> entre le nombre de plugins et le nombre de tâches du micronoyau (généralement il ne contient que du code fréquemment utilisé). <br><br>  Il est également difficile de déterminer à l'avance (avant le développement de l'application) le degré optimal de fragmentation du code du micronoyau.  Et changer l'approche plus tard est presque impossible. <br><br>  <i>Bon pour:</i> <br><br><ul><li>  Créez des applications extensibles utilisées par un grand nombre de personnes.  Par exemple, l'iPhone OS a des racines de «micro-noyau» - ses développeurs se sont inspirés de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mach</a> (c'est l'un des tout premiers exemples de micro-noyau). </li><li>  Création d'applications avec une séparation claire des méthodes de base et des règles de haut niveau. </li><li>  Développement de systèmes avec un ensemble de règles en évolution dynamique qui doivent être mises à jour fréquemment. </li></ul><br><h5>  Microservices </h5><br>  Similaire à l'architecture événementielle et au micro-noyau.  Mais ils sont utilisés lorsque les tâches d'application individuelles peuvent être facilement divisées en petites fonctions - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des services indépendants</a> .  Ces services peuvent être écrits dans différents langages de programmation car ils communiquent entre eux à l'aide de l'API REST (par exemple, à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JSON</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Thrift</a> ). <br><br>  Dans quelles proportions le code est divisé, le développeur décide, mais Sam Newman, l'auteur du livre « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création de</a> microservices» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> vous recommande d'allouer autant de lignes de code au microservice que l'équipe peut reproduire en deux semaines.  Selon lui, cela permettra d'éviter des "ballonnements" excessifs de l'architecture. <br><br>  Le plus souvent, les microservices sont lancés dans des soi-disant conteneurs.  Ces conteneurs sont accessibles sur le réseau à d'autres microservices et applications, et le système d'orchestration les gère tous: Kubernetes, Docker Swarm, par exemple. <br><br>  <i>Avantages:</i> <br><br>  L'architecture de microservice simplifie la mise à l'échelle des applications.  Pour implémenter une nouvelle fonctionnalité, il suffit d'écrire un nouveau service.  Si la fonction n'est plus nécessaire, le microservice peut être désactivé.  Chaque microservice est un projet distinct, il est donc facile de répartir le travail sur eux entre les équipes de développement. <br><br>  En savoir plus sur les mécanismes de mise à l'échelle des systèmes de microservices dans le livre de Martin L. Abbott, The Art of Scalability. <br><br>  <i>Inconvénients:</i> <br><br>  Il est difficile de trouver des erreurs.  Contrairement aux systèmes monolithiques (lorsque toutes les fonctions sont dans le même noyau), il peut être difficile de déterminer pourquoi la demande a "chuté".  Pour plus de détails, vous devez vous rendre dans les journaux du processus «coupable» (s'il y en a plusieurs, le problème est aggravé). <br><br>  Cela crée une surcharge supplémentaire pour la transmission de messages entre microservices.  Selon nos estimations, la croissance des coûts de réseau peut atteindre 25%. <br><br>  Un autre inconvénient est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nécessité de s'accommoder</a> du concept de cohérence éventuelle ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cohérence à long terme</a> ).  Les microservices ont leurs propres entrepôts de données, auxquels d'autres microservices accèdent.  Les informations sur les modifications de ces données ne sont pas distribuées instantanément via le système.  Par conséquent, des situations surviennent lorsque certains microservices (quoique pour une période de temps extrêmement courte) contiennent des données obsolètes. <br><br>  <i>Où utiliser:</i> <br><br><ul><li>  Dans les grands projets avec une charge élevée.  Par exemple, les microservices sont utilisés par les plateformes de streaming.  Les systèmes de diffusion de contenu et autres services de support peuvent être mis à l'échelle indépendamment les uns des autres, en s'adaptant aux changements de charge. </li><li>  Dans les systèmes qui utilisent des ressources "mixtes".  Si une partie de l'application a besoin de plus de temps processeur, et la seconde - de la mémoire, alors il est logique de les diviser en microservices.  Ensuite, ils peuvent être hébergés sur différentes machines - avec un processeur puissant ou une grande quantité de mémoire, respectivement. </li><li>  Quand la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sécurité est nécessaire</a> .  Étant donné que les microservices sont isolés et communiquent par API, il peut être garanti que seules les informations dont un service particulier a besoin seront transmises.  Ceci est important lorsque vous travaillez avec des mots de passe ou des données de carte de paiement. </li></ul><br><h2>  Pourquoi passons-nous aux microservices dans 1cloud </h2><br>  Comme nous l'avons déjà dit, la base des services que nous proposons ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cloud privé</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">serveurs virtuels</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stockage en nuage d'objets</a> , etc.) est basée sur une architecture à plusieurs niveaux.  Elle s'est montrée du bon côté, mais maintenant sa capacité à évoluer a commencé à s'épuiser. <br><br>  Nous devenons de plus en plus de partenaires qui fournissent leurs solutions basées sur notre plateforme de franchise.  Il existe des sites et des services distants qui deviennent difficiles à gérer à partir d'un seul point (en particulier, nos équipements sont situés dans plusieurs centres de données <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en Russie, au Kazakhstan et en Biélorussie</a> ). <br><br>  Pour faciliter la mise à l'échelle des fonctions existantes et introduire de nouvelles fonctionnalités, nous transférons l'intégralité de notre infrastructure aux microservices dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1cloud</a> . <br><br><img src="https://habrastorage.org/webt/qc/en/nv/qcennvcdxbriz_2it7sf3jhtpv8.png"><br><br>  Nous voulons les séparer en modules séparés et au lieu d'une base de données complexe obtenir N simples.  Ainsi, dans la nouvelle architecture, chaque fonctionnalité aura une base de données distincte.  Il est beaucoup plus pratique et efficace en termes de support et de développement. <br><br>  Nous pourrons répartir le travail sur les services entre plusieurs développeurs (mettre en évidence les spécialisations de l'entreprise) et évoluer efficacement horizontalement - si nécessaire, nous connectons simplement de nouveaux microservices. <br><br>  Nos clients bénéficieront également d'un certain nombre d'avantages.  Étant donné que les microservices ne sont pas connectés les uns aux autres, alors lorsqu'un service particulier échoue, seul il sera indisponible, tout le reste continuera à fonctionner normalement.  De plus, même si une baisse globale de notre service se produit, le panneau de contrôle continuera de fonctionner. <br><br>  Les clients du Kazakhstan et de Biélorussie (et d'autres pays où nous ouvrirons des bureaux de représentation) remarqueront une augmentation significative de la vitesse et de la réactivité des interfaces, car les panneaux de contrôle seront situés localement. <br><br><h5>  Ce qui a déjà été fait </h5><br>  Jusqu'à présent, nous n'avons mis en œuvre que le premier pilote: «Monitoring Service».  Les services restants seront transférés sur une nouvelle piste fin 2018 - début 2019. <br><br>  Dans le même temps, la nouvelle architecture jette les bases technologiques de la prochaine étape - la migration vers les conteneurs.  Maintenant, nous utilisons l'infrastructure Windows et pour passer aux conteneurs, nous devons réécrire tout le code accumulé dans .NetCore et le transférer vers Linux. <br><br>  Nous prévoyons de commencer une nouvelle transition au début de 2019 et de la terminer à la fin de l'année prochaine. <br><br><div class="spoiler">  <b class="spoiler_title">En termes simples sur ce qu'il vaut la peine de retenir sur l'architecture</b> <div class="spoiler_text"><ul><li>  <b>Architecture</b> à plusieurs niveaux - l'application est divisée en niveaux, chacun exécutant un ensemble de fonctions strictement défini.  Chaque niveau peut être modifié individuellement.  Parmi les lacunes figurent la faible vitesse du code et la difficulté de trouver des bogues. <br><br>  Convient pour développer des applications qui doivent être rapidement commercialisées.  Souvent utilisé pour créer des services d'entreprise. </li><li>  <b>Architecture orientée événement</b> - le développeur prescrit ici la réaction du système à tout événement.  Par exemple, si des données sont reçues, écrivez-les dans un fichier.  Les applications basées sur une architecture orientée événement sont faciles à mettre à l'échelle, car tous les gestionnaires d'événements ne savent rien de la mise en œuvre de l'autre.  Cependant, le débogage de tels systèmes est difficile - une seule action peut provoquer plusieurs chaînes d'actions à la fois (il est difficile de comprendre laquelle a provoqué la panne). <br><br>  Utilisé pour créer des systèmes asynchrones, l'organisation des interfaces graphiques et des systèmes de messagerie. </li><li>  <b>Architecture du micro-</b> noyau - se compose de deux composants clés: les plug-ins et le noyau.  Les plugins sont responsables de la logique métier, et le noyau est responsable de leur chargement et déchargement.  Cette séparation des tâches simplifie le support du système.  Cependant, cela peut affecter les performances - cela dépend directement du nombre de modules connectés et actifs. <br><br>  Il convient au développement d'applications extensibles utilisées par un grand nombre de personnes et de systèmes avec un ensemble de règles qui doivent souvent être mises à jour (les plugins garantissent la facilité de mise à jour). </li><li>  <b>Architecture de</b> microservices - les applications sont divisées en fonctions - microservices.  Chaque microservice est un composant indépendant avec sa propre logique métier.  Ces composants communiquent entre eux à l'aide de l'API.  Ces applications sont faciles à développer (il est possible de répartir le travail entre les équipes de développement), mais il est difficile à déboguer. <br><br>  Utilisé dans les grands projets avec une charge élevée, qui nécessitent une sécurité accrue. </li></ul><br><br></div></div><br><h5>  Que écrivons-nous d'autre sur le blog 1cloud: </h5><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1cloud Cloud Architecture Evolution: défis de modulation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment IaaS aide les franchisés 1C: expérience 1cloud</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pourquoi la surveillance est-elle nécessaire?</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424911/">https://habr.com/ru/post/fr424911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424897/index.html">Une rencontre inattendue. Chapitre 18</a></li>
<li><a href="../fr424899/index.html">Ce qu'il faut écouter sur l'audio: 15 podcasts</a></li>
<li><a href="../fr424901/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 272 (24 septembre - 30 septembre)</a></li>
<li><a href="../fr424905/index.html">Développer un hexapode à partir de zéro (partie 2) - build</a></li>
<li><a href="../fr424907/index.html">Conférence DEFCON 22. GTVHacker Group. Hackez tout: 20 appareils en 45 minutes. Partie 1</a></li>
<li><a href="../fr424913/index.html">Agence internationale de l'énergie: l'énergie éolienne prévaudra en Europe d'ici 2027</a></li>
<li><a href="../fr424915/index.html">Conférence DEFCON 22. GTVHacker Group. Hackez tout: 20 appareils en 45 minutes. 2e partie</a></li>
<li><a href="../fr424917/index.html">Comment nous avons remodelé les mauvaises prévisions en un peu mieux</a></li>
<li><a href="../fr424919/index.html">Perle d'un marché aux puces ou ingénierie inverse de la caméra IP DCS-5220A1</a></li>
<li><a href="../fr424921/index.html">Comment les mathématiques du réseau peuvent vous aider à vous faire des amis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>