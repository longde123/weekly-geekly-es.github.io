<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”› ğŸ‘¨ğŸ¿â€ğŸ”¬ ğŸ§£ 9 tahun dalam monolit di Node.JS ğŸ‘·ğŸ¼ ğŸ‘‚ ğŸ„</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seminggu yang lalu, saya berbicara pada pertemuan Node.JS, dan saya berjanji banyak untuk memposting rekaman kinerja. Kemudian saya menyadari bahwa sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>9 tahun dalam monolit di Node.JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459206/"><p><img src="https://habrastorage.org/webt/p-/5g/we/p-5gweh68uzyj3_baevjuocr8xi.png" alt="monolith dari https://reneaigner.deviantart.com"></p><br><p>  Seminggu yang lalu, saya berbicara pada pertemuan Node.JS, dan saya berjanji banyak untuk memposting rekaman kinerja.  Kemudian saya menyadari bahwa saya tidak dapat mengakomodasi beberapa fakta menarik dalam waktu setengah jam yang diatur.  Ya, dan saya sendiri lebih suka membaca, daripada menonton dan mendengarkan, jadi saya memutuskan untuk memposting presentasi saya dalam format artikel.  Namun, video juga akan berada di akhir pos di bagian tautan. </p><br><p> Saya memutuskan untuk memberi tahu Anda tentang titik sakit - hidup dalam monolit.  Sudah ada ratusan artikel tentang ini di hub, ribuan salinan dipecah dalam komentar, kebenaran telah lama mati dalam kontroversi, tapi ... Faktanya adalah bahwa kita memiliki pengalaman yang sangat spesifik di OneTwoTrip, tidak seperti banyak orang yang menulis tentang pola arsitektur tertentu di kekosongan: </p><br><ul><li>  Pertama, monolit kita sudah berusia 9 tahun. </li><li>  Kedua, ia menghabiskan seluruh hidupnya di bawah beban tinggi (sekarang 23 juta permintaan per jam). </li><li>  Dan di NaN, kami menulis monolith kami di Node.JS, yang telah berubah tak bisa dikenali selama 9 tahun terakhir.  Ya, kami mulai menulis pada node pada 2010, kami menyanyikan lagu dengan hiruk pikuk pemberani! </li></ul><br><p>  Jadi kami memiliki banyak kekhususan dan pengalaman nyata.  Menarik?  Ayo pergi! </p><a name="habracut"></a><br><p>  <strong>Waktu penafian</strong> </p><br><blockquote>  Presentasi ini hanya mencerminkan pendapat pribadi penulisnya.  Itu mungkin bertepatan dengan posisi OneTwoTrip, atau mungkin tidak bertepatan.  Beruntung sekali.  Saya bekerja sebagai ahli teknis dari salah satu tim perusahaan dan tidak berpura-pura objektif atau mengungkapkan pendapat seseorang selain pendapat saya. </blockquote><p>  <strong>Penafian Dua</strong> </p><br><blockquote>  Artikel ini menjelaskan peristiwa sejarah, dan saat ini semuanya salah, jadi jangan khawatir. </blockquote><br><h2 id="0-kak-zhe-tak-vyshlo">  0. Bagaimana itu bisa terjadi </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tren permintaan</a> kata "microservice" di google: <br><img src="https://habrastorage.org/webt/i5/ss/lm/i5sslmpta1fldeztaxgmmnd50ag.png"><br>  Semuanya sangat sederhana - sembilan tahun yang lalu tidak ada yang tahu tentang layanan microser.  Jadi kami mulai menulis, seperti orang lain - dalam monolit. </p><br><h2 id="1-bol-v-monolite">  1. Nyeri pada monolit </h2><br><p>  Di sini saya akan menggambarkan situasi masalah yang kita miliki selama 9 tahun ini.  Beberapa dari mereka diselesaikan, beberapa dielakkan dengan retas, beberapa hanya kehilangan relevansi.  Tapi ingatan mereka, seperti bekas luka pertempuran, tidak akan pernah meninggalkanku. </p><br><h3 id="11-obnovlenie-svyaznyh-komponentov">  1.1 Memperbarui Komponen yang Terhubung </h3><br><p><img src="https://habrastorage.org/webt/0a/h-/8f/0ah-8f7ijb259t-blaohq1_dceg.png"><br>  Inilah yang terjadi ketika sinergi itu jahat.  Karena komponen apa pun digunakan kembali beberapa ratus kali, dan jika memungkinkan untuk menggunakannya secara bengkok, maka itu tidak hilang.  Tindakan apa pun dapat menyebabkan efek yang sama sekali tidak dapat diprediksi, dan tidak semuanya dilacak oleh unit dan tes integrasi.  Ingat cerita tentang pel, kipas angin, dan balon?  Jika tidak, google saja.  Dia adalah ilustrasi terbaik dari kode di monolith. </p><br><h3 id="12-migraciya-na-novye-tehnologii">  1.2 Migrasi ke teknologi baru </h3><br><p>  Apakah Anda ingin Express?  Linter?  Kerangka kerja lain untuk tes atau moks?  Perbarui validator atau setidaknya lodash?  Perbarui Node.js?  Maafkan aku  Untuk melakukan ini, Anda harus mengedit ribuan baris kode. </p><br><p>  Banyak yang berbicara tentang keuntungan monolit, yaitu <strong>setiap revisi adalah komitmen atom</strong> .  Orang-orang ini diam tentang satu <strong>hal</strong> - <strong>revisi ini tidak akan pernah dilakukan</strong> . </p><br><p>  Apakah Anda tahu lelucon lama tentang versi semantik? </p><br><blockquote>  semantik sesungguhnya dari versi semantik: <br><br>  major = perubahan besar <br>  minor = perubahan melanggar minor <br>  patch = perubahan kecil-kecilan </blockquote><p>  Sekarang bayangkan bahwa setiap perubahan kecil-kecilan hampir pasti akan muncul dalam kode Anda.  Tidak, itu mungkin untuk hidup dengannya, dan kami secara berkala mengumpulkan kekuatan dan bermigrasi, tetapi itu benar-benar sangat sulit.  Sangat </p><br><h3 id="13-relizy">  1.3 Rilis </h3><br><p>  Di sini saya harus mengatakan tentang beberapa spesifikasi produk kami.  Kami memiliki sejumlah besar integrasi eksternal, dan berbagai cabang logika bisnis yang muncul secara terpisah sangat jarang.  Saya sangat iri dengan produk yang benar-benar mengeksekusi semua cabang kode mereka dalam 10 menit dalam produksi, tetapi ini tidak terjadi di sini.  Melalui trial and error, kami menemukan sendiri siklus rilis optimal yang meminimalkan jumlah kesalahan yang menjangkau pengguna akhir: </p><br><ol><li>  rilis sedang berjalan dan tes integrasi lulus setengah hari </li><li>  maka itu di bawah pengawasan yang cermat di atas panggung selama sehari (untuk 10% pengguna) </li><li>  kemudian terletak satu hari lagi di produksi di bawah pengawasan yang lebih cermat. </li><li>  Dan hanya setelah itu kita memberinya lampu hijau di master. </li></ol><br><p>  Karena kami mencintai kolega kami dan tidak merilis pada hari Jumat, pada akhirnya ini berarti bahwa rilis pergi ke master sekitar 1,5-2 kali seminggu.  Yang mengarah pada fakta bahwa rilis dapat memiliki 60 tugas atau lebih.  jumlah seperti itu menyebabkan konflik gabungan, efek sinergis mendadak, beban kerja penuh QA pada analisis log, dan kesedihan lainnya.  Secara umum, sangat sulit bagi kami untuk melepaskan monolit. </p><br><h3 id="14-prosto-ochen-mnogo-koda">  1.4 Hanya banyak kode </h3><br><p>  Tampaknya jumlah kode seharusnya tidak terlalu penting.  Tapi ... Tidak juga.  Di dunia nyata itu adalah: </p><br><ul><li>  Ambang entri lebih tinggi </li><li>  Artefak membangun besar untuk setiap tugas </li><li>  Proses CI yang panjang, termasuk tes integrasi, tes unit, dan bahkan kode linting </li><li>  Pekerjaan IDE lambat (pada awal pengembangan Jetbrains, kami mengejutkan mereka dengan log kami lebih dari sekali) </li><li>  Pencarian kontekstual yang canggih (jangan lupa, kami tidak memiliki pengetikan statis) </li><li>  Kesulitan menemukan dan menghapus kode yang tidak digunakan </li></ul><br><h3 id="15-otsutstvuyut-vladelcy-koda">  1.5 Pemilik kode tidak ada </h3><br><p>  Seringkali tugas muncul dengan lingkup tanggung jawab yang tidak dapat dipahami - misalnya, di perpustakaan terkait.  Dan pengembang asli sudah bisa pindah ke tim lain, atau bahkan meninggalkan perusahaan.  Satu-satunya cara untuk menemukan pertanggungjawaban dalam kasus ini adalah kesewenang-wenangan administrasi - untuk mengambil dan menunjuk seseorang.  Yang tidak selalu menyenangkan bagi pengembang dan orang yang melakukannya. </p><br><h3 id="16-slozhnost-otladki">  1.6 Kesulitan debugging </h3><br><p>  Apakah ingatannya mengalir?  Peningkatan konsumsi CPU?  Ingin membuat grafik nyala?  Maafkan aku  Dalam sebuah monolit, begitu banyak hal terjadi pada saat yang sama sehingga menjadi sangat sulit untuk melokalisasi masalah.  Sebagai contoh, untuk memahami mana dari 60 tugas ketika memulai produksi menyebabkan peningkatan konsumsi sumber daya (meskipun ini tidak direproduksi secara lokal pada lingkungan pengujian dan pementasan) hampir tidak realistis. </p><br><h3 id="17-odin-stek">  1.7 Satu tumpukan </h3><br><p>  Di satu sisi, ada baiknya ketika semua pengembang "berbicara" dengan bahasa yang sama.  Dalam kasus JS, ternyata bahkan pengembang Backend dengan Frontend saling memahami.  Tapi ... </p><br><ul><li>  Tidak ada peluru perak, dan untuk beberapa tugas Anda terkadang ingin menggunakan sesuatu yang lain.  Tapi kami punya monolit, dan kami tidak punya tempat untuk menempel pengembang lain. </li><li>  Kami tidak bisa hanya mengambil tim yang bagus berdasarkan rekomendasi, yang datang kepada kami atas saran teman - kami tidak punya tempat untuk meletakkannya. </li><li>  Seiring waktu, kami bersandar pada kenyataan bahwa pasar tidak memiliki cukup pengembang di tumpukan yang tepat. </li></ul><br><h3 id="18-mnogo-komand-s-raznym-predstavleniem-o-schaste">  1.8 Banyak tim dengan ide berbeda tentang kebahagiaan </h3><br><p><img src="https://habrastorage.org/webt/1k/bc/k1/1kbck116yjf9-ozmoee08oeacxi.png"></p><br><p>  Jika Anda memiliki dua pengembang, maka Anda sudah memiliki dua gagasan berbeda tentang kerangka mana yang terbaik, standar mana yang harus dihormati, menggunakan perpustakaan, dan sebagainya. <br>  Jika Anda memiliki sepuluh tim, yang masing-masing memiliki beberapa pengembang, maka ini hanyalah bencana. <br>  Dan hanya ada dua cara untuk menyelesaikannya - baik "demokratis" (semua orang melakukan apa yang diinginkannya), atau totaliter (standar diberlakukan dari atas).  Dalam kasus pertama, kualitas dan standardisasi menderita, di kedua - orang yang tidak diizinkan untuk mewujudkan ide kebahagiaan mereka. </p><br><h2 id="2-plyusy-monolita">  2. Keuntungan dari monolit </h2><br><p>  Tentu saja, ada beberapa keuntungan dalam monolith yang dapat berbeda untuk tumpukan, produk, dan tim yang berbeda.  Tentu saja, ada lebih dari tiga, tetapi saya tidak akan bertanggung jawab atas segala yang mungkin terjadi, hanya untuk mereka yang relevan dengan kami. </p><br><h3 id="21-prostota-razvyortyvaniya">  2.1 Mudah digunakan </h3><br><p>  Ketika Anda memiliki satu layanan, maka meningkatkan dan menguji jauh lebih mudah daripada selusin layanan.  Benar, nilai tambah ini hanya relevan pada tahap awal - misalnya, Anda dapat meningkatkan lingkungan pengujian, dan menggunakan semua layanan, kecuali yang dikembangkan, darinya.  Atau dari wadah.  Atau yang lainnya. </p><br><h3 id="22-net-overheda-na-peredachu-dannyh">  2.2 Tidak ada overhead transfer data </h3><br><p>  Cukup plus meragukan, jika Anda tidak memiliki beban yang tinggi.  Tetapi kami memiliki kasus seperti itu - oleh karena itu, biaya transportasi antara layanan microser terlihat oleh kami.  Tidak peduli bagaimana Anda mencoba melakukan ini dengan cepat, simpan dan transfer semuanya dalam RAM lebih cepat dari yang lainnya - ini jelas. </p><br><h3 id="22-odna-sborka">  2.2 Satu unit </h3><br><p>  Jika Anda perlu memutar kembali suatu saat dalam sejarah, maka melakukannya dengan monolith benar-benar sederhana - ambil dan putar kembali.  Dalam hal layanan microser, perlu untuk memilih versi layanan yang kompatibel yang digunakan satu sama lain pada titik waktu tertentu, yang tidak selalu sederhana.  Benar, ini juga diselesaikan dengan bantuan infrastruktur. </p><br><h2 id="3-mnimye-plyusy-monolita">  3. Keuntungan imajiner monolit </h2><br><p>  Di sini saya mengambil semua hal yang biasanya dianggap plus, tetapi dari sudut pandang saya tidak. </p><br><h3 id="31-kod---eto-i-est-dokumentaciya">  3.1 Kode - ini adalah dokumentasi </h3><br><p>  Sering mendengar pendapat ini.  Tapi biasanya itu diikuti oleh pengembang pemula yang belum melihat file dalam puluhan ribu baris kode yang ditulis oleh orang-orang yang meninggalkan tahun lalu.  Nah, untuk beberapa alasan, paling sering titik ini dibawa oleh para pendukung monolit - mereka mengatakan kami tidak memerlukan dokumentasi apa pun, kami tidak memiliki transportasi atau api - semuanya ada dalam kode, mudah dan jelas.  Saya tidak akan berdebat dengan pernyataan ini, hanya mengatakan bahwa saya tidak percaya akan hal itu. </p><br><h3 id="32-net-raznyh-versiy-bibliotek-servisov-i-api-net-raznyh-repozitoriev">  3.2 Tidak ada versi perpustakaan, layanan, dan API yang berbeda.  Tidak ada repositori yang berbeda. </h3><br><p>  Ya  Tapi tidak.  Karena sekilas Anda mengerti bahwa layanan ini tidak ada dalam ruang hampa.  Dan di antara sejumlah besar kode dan produk lain yang diintegrasikan - mulai dari perpustakaan pihak ketiga, melanjutkan dengan versi perangkat lunak server, dan tidak berakhir dengan integrasi eksternal, versi IDE, alat CI, dan sebagainya.  Dan segera setelah Anda memahami berapa banyak hal berbeda yang dimasukkan dalam layanan Anda secara tidak langsung, segera menjadi jelas bahwa nilai tambah ini hanyalah demagogi. </p><br><h3 id="33-prosche-monitoring">  3.3 pemantauan lebih mudah </h3><br><p>  Lebih mudah.  Karena Anda memiliki, secara kasar, satu dasbor, bukan beberapa lusin.  Tetapi ini lebih rumit, dan kadang-kadang bahkan tidak mungkin, karena Anda tidak dapat menguraikan grafik Anda menjadi bagian kode yang berbeda, dan Anda hanya memiliki suhu rata-rata di rumah sakit.  Secara umum, saya sudah mengatakan semuanya dalam paragraf tentang kompleksitas debugging, saya hanya akan menjelaskan bahwa kompleksitas yang sama berlaku untuk pemantauan. </p><br><h3 id="34-prosche-soblyudat-edinye-standarty">  3.4 Lebih mudah untuk mematuhi standar umum </h3><br><p>  Ya  Tetapi, seperti yang sudah saya tulis dalam paragraf tentang banyak tim dengan gagasan kebahagiaan - standar-standar itu diberlakukan secara totaliter, atau melemah hampir karena ketiadaan. </p><br><h3 id="35-menshe-veroyatnost-dublirovaniya-koda">  3.5 Lebih sedikit peluang duplikasi kode </h3><br><p>  Pendapat aneh adalah bahwa kode tidak digandakan dalam monolit.  Tetapi cukup sering bertemu dengannya.  Dalam praktik saya, ternyata duplikasi kode hanya bergantung pada budaya pengembangan di perusahaan.  Jika ya, maka kode umum dialokasikan untuk semua jenis perpustakaan, modul, dan layanan mikro.  Jika tidak ada di sana, maka akan ada copy-paste dua puluh kali dalam monolit. </p><br><h2 id="4-plyusy-mikroservisov">  4. Pro dari layanan microser </h2><br><p>  Sekarang saya akan menulis tentang apa yang kami dapatkan setelah migrasi.  Sekali lagi, ini adalah kesimpulan nyata dari situasi nyata. </p><br><h3 id="41-mozhno-delat-geterogennuyu-infrastrukturu">  4.1 Anda dapat membuat infrastruktur yang heterogen </h3><br><p>  Sekarang kita dapat menulis kode pada tumpukan yang optimal untuk menyelesaikan masalah tertentu.  Dan itu rasional untuk menggunakan pengembang baik yang datang kepada kami.  Misalnya, berikut adalah daftar contoh teknologi yang saat ini kami miliki: <br><img src="https://habrastorage.org/webt/mt/oc/nr/mtocnrvjvhfhxxtsjfnjx3z8knc.png"></p><br><h3 id="42-mozhno-delat-mnogo-chastyh-relizov">  4.2 Anda dapat membuat banyak rilis sering </h3><br><p>  Sekarang kita dapat membuat banyak rilis independen kecil, dan mereka lebih sederhana, lebih cepat, dan tidak menyakitkan.  Dulu kami hanya punya satu tim, tapi sekarang sudah ada 18. Akan ada istirahat jika mereka semua tetap di monolith.  Atau orang-orang yang bertanggung jawab untuk itu ... </p><br><h3 id="43-prosche-delat-nezavisimye-testy">  4.3 Lebih mudah untuk melakukan tes independen </h3><br><p>  Kami telah mengurangi waktu untuk tes integrasi, yang sekarang menguji hanya apa yang benar-benar berubah, dan pada saat yang sama kami tidak takut dengan efek sinergi yang tiba-tiba.  Tentu saja, saya harus mulai berjalan menyapu - misalnya, belajar cara membuat API yang kompatibel ke belakang - tetapi seiring waktu, semuanya beres. </p><br><h3 id="44-legche-vnedryat-i-testirovat-novye-fichi">  4.4 Lebih mudah untuk mengimplementasikan dan menguji fitur-fitur baru </h3><br><p>  Sekarang kami terbuka untuk eksperimen.  Kerangka kerja, tumpukan, perpustakaan - Anda dapat mencoba semuanya, dan jika berhasil, lanjutkan. </p><br><h3 id="45-mozhno-obnovlyat-chto-ugodno">  4.5 Anda dapat memperbarui apa pun </h3><br><p>  Anda dapat memperbarui versi mesin, pustaka, tetapi apa saja!  Sebagai bagian dari layanan kecil, menemukan dan memperbaiki semua perubahan yang rusak hanya dalam hitungan menit.  Dan tidak berminggu-minggu, seperti sebelumnya. </p><br><h3 id="46--a-mozhno-ne-obnovlyat">  4.6 Dan Anda tidak dapat memperbarui </h3><br><p>  Anehnya, ini adalah salah satu fitur paling keren dari layanan microser.  Jika Anda memiliki kode kerja yang stabil, maka Anda dapat membekukannya dan melupakannya.  Dan Anda tidak perlu memperbaruinya, misalnya, untuk menjalankan kode produk pada mesin baru.  Produk itu sendiri bekerja pada mesin baru, dan layanan Microsoft terus hidup seperti semula.  Lalat dengan irisan daging akhirnya dapat dimakan secara terpisah. </p><br><h2 id="5-minusy-mikroservisov">  5 Kekurangan dari Layanan Mikro </h2><br><p>  Tentu saja, lalat di salep tidak lengkap, dan solusi sempurna untuk hanya duduk dan dibayar tidak berhasil.  Apa yang kami temui: </p><br><h3 id="51-nuzhna-shina-dlya-obmena-dannymi-i-vnyatnoe-logirovanie">  5.1 Perlu bus untuk pertukaran data dan penebangan yang jelas. </h3><br><p>  Interaksi layanan melalui HTTP adalah model klasik, dan secara umum bahkan yang berfungsi, asalkan ada lapisan logging dan menyeimbangkan di antara mereka.  Tetapi lebih baik memiliki ban yang lebih berbeda.  Selain itu, Anda harus memikirkan cara mengumpulkan dan menggabungkan kayu di antara mereka sendiri - jika tidak, Anda hanya akan memiliki bubur di tangan Anda. </p><br><h3 id="52-nuzhno-sledit-za-tem-chto-delayut-razrabotchiki">  5.2. Melacak apa yang dilakukan pengembang. </h3><br><p>  Secara umum, ini harus selalu dilakukan, tetapi dalam layanan mikro, pengembang jelas memiliki lebih banyak kebebasan, yang kadang-kadang dapat menimbulkan hal-hal yang membuat Stephen King merinding.  Bahkan jika secara lahiriah kelihatannya layanan tersebut berfungsi - jangan lupa bahwa harus ada orang yang memantau apa yang ada di dalam dirinya. </p><br><h3 id="53-nuzhna-horoshaya-komanda-devops-chtoby-vsem-etim-upravlyat">  5.3 Anda memerlukan tim DevOps yang baik untuk mengelola semuanya. </h3><br><p>  Hampir semua pengembang dapat menggunakan monolith dengan satu atau lain cara dan mengunggah rilisnya (misalnya, melalui FTP atau SSH, saya melihat ini).  Tetapi dengan layanan microser, ada segala macam layanan terpusat untuk mengumpulkan log, metrik, dasbor, koki untuk mengelola konfigurasi, volt, jenkins, dan hal-hal baik lainnya, yang tanpanya Anda dapat hidup secara umum - tetapi itu buruk dan tidak dapat dipahami alasannya.  Jadi untuk mengelola layanan microser, Anda harus memiliki tim DevOps yang baik. </p><br><h3 id="54-mozhno-popytatsya-slovit-hayp-i-vystrelit-sebe-v-nogu">  5.4 Anda dapat mencoba menangkap sensasi dan menembak diri sendiri. </h3><br><p>  Mungkin ini adalah minus utama dari arsitektur dan bahayanya.  Sangat sering orang secara membabi buta mengikuti tren dan mulai memperkenalkan arsitektur dan teknologi tanpa memahaminya.  Setelah semuanya jatuh, mereka menjadi bingung dalam kekacauan yang dihasilkan, dan menulis sebuah artikel tentang Habr "bagaimana kita pindah dari layanan microser ke monolith", misalnya.  Secara umum, pindah hanya jika Anda tahu mengapa Anda melakukan ini dan masalah apa yang akan Anda pecahkan.  Dan yang mana yang Anda dapatkan. </p><br><h2 id="6-haki-v-monolite">  6 Khaki di Monolith </h2><br><p>  Beberapa peretasan yang memungkinkan kita hidup di monolith sedikit lebih baik dan sedikit lebih lama. </p><br><h3 id="61-linting">  6.1 Linting </h3><br><p>  Pengenalan linter dalam monolith bukanlah tugas yang sederhana seperti yang terlihat pada pandangan pertama.  Tentu saja, Anda dapat membuat aturan ketat, menambahkan konfigurasi, dan ... Tidak ada yang akan berubah, semua orang hanya mematikan linter, karena setengah dari kode berubah menjadi merah. </p><br><p>  Untuk secara bertahap memperkenalkan linting, kami menulis add-on sederhana untuk eslint - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">slowlint</a> , yang memungkinkan Anda melakukan satu hal sederhana - berisi daftar file yang diabaikan sementara.  Sebagai hasilnya: </p><br><ul><li>  Semua kode yang salah disorot dalam IDE </li><li>  File baru dibuat sesuai dengan aturan linting, jika tidak CI tidak akan ketinggalan </li><li>  Yang lama secara bertahap memerintah dan menjauh dari pengecualian </li></ul><br><p>  Sepanjang tahun, dimungkinkan untuk membawa sekitar setengah dari kode monolith ke dalam satu gaya, yaitu hampir semua kode yang ditambahkan secara aktif. </p><br><h3 id="62-dorabotki-yunit-testov">  6.2 Peningkatan pengujian unit </h3><br><p>  Setelah unit test dilakukan bersama kami selama tiga menit.  Pengembang tidak ingin menunggu terlalu lama, jadi semuanya diperiksa hanya dalam CI di server.  Setelah beberapa waktu, pengembang menemukan bahwa tes jatuh, dikutuk, membuka cabang, kembali ke kode ... Secara umum, ia menderita.  Apa yang telah kami lakukan dengan ini: </p><br><ol><li>  Sebagai permulaan, kami mulai menjalankan tes di banyak utas.  Yandex memiliki varian mocha multi-threaded, tetapi dengan kami itu tidak lepas landas, jadi mereka sendiri menulis pembungkus sederhana.  Tes mulai dilakukan satu setengah kali lebih cepat. </li><li>  Kemudian kami pindah dari 0,12 node ke yang ke-8 (ya, proses itu sendiri menarik ke laporan terpisah).  Aneh seperti kelihatannya, itu tidak memberikan keuntungan mendasar dalam produktivitas pada produksi, tetapi tes mulai dilakukan 20% lebih cepat. </li><li>  Dan kemudian kami duduk untuk men-debug tes dan mengoptimalkan secara individual.  Yang memberi peningkatan terbesar dalam kecepatan. </li></ol><br><p>  Secara umum, saat ini, unit test berjalan di kait persiapan dan bekerja dalam 10 detik, yang cukup nyaman dan memungkinkan Anda untuk menjalankannya tanpa gangguan dari produksi. </p><br><h3 id="63--oblegchenie-vesa-artefakta">  6.3 Meringankan berat artefak </h3><br><p>  Artefak monolit akhirnya memakan waktu 400 megabita.  Mengingat fakta bahwa itu dibuat untuk setiap komit, total volume ternyata cukup besar.  Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diare</a> , garpu modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modclean</a> , membantu kami dalam hal ini.  Kami menghapus unit test dari artefak dan membersihkannya dari berbagai sampah seperti file readme, tes di dalam paket, dan sebagainya.  Kenaikan itu sekitar 30% dari berat! </p><br><h3 id="64--keshirovanie-zavisimostey">  6.4 Caching Ketergantungan </h3><br><p>  Sebelumnya, menginstal dependensi menggunakan npm membutuhkan banyak waktu sehingga Anda tidak hanya bisa minum kopi, tetapi juga, misalnya, membuat pizza.  Oleh karena itu, pada awalnya kami menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm-cache</a> , yang bercabang dua dan sedikit selesai.  Itu memungkinkan Anda untuk menyimpan dependensi pada drive jaringan bersama, yang darinya semua build lain akan mengambilnya. </p><br><p>  Kemudian kami memikirkan tentang kemampuan reproduksi majelis.  Ketika Anda memiliki monolit, maka perubahan ketergantungan transitif adalah momok Tuhan.  Mengingat fakta bahwa kami jauh di belakang versi mesin pada waktu itu, mengubah ketergantungan dari tingkat kelima dengan mudah menghancurkan seluruh perakitan kami.  Jadi kami mulai menggunakan npm-shrinkwrap.  Sudah lebih mudah baginya, meskipun menggabungkan perubahannya adalah kesenangan bagi yang kuat dalam roh. </p><br><p> Dan kemudian paket-kunci dan perintah <code>npm ci</code> sangat baik akhirnya muncul - yang berjalan pada kecepatan hanya sedikit lebih sedikit daripada menginstal dependensi dari cache file.  Karena itu, kami mulai menggunakannya saja, dan berhenti menyimpan perangkat dependensi.  Pada hari ini saya membawa beberapa kotak donat untuk bekerja. </p><br><h3 id="65--raspredelenie-ocheryodnosti-relizov">  6.5 Distribusi urutan rilis. </h3><br><p>  Dan ini lebih merupakan peretasan administratif, bukan peretnis.  Awalnya, saya menentangnya, tetapi waktu menunjukkan bahwa ahli teknis kedua benar dan umumnya dilakukan dengan baik.  Ketika rilis didistribusikan secara bergantian antara beberapa tim, menjadi jelas di mana kesalahan itu muncul, dan yang lebih penting, masing-masing tim merasakan tanggung jawabnya untuk kecepatan, dan mencoba untuk memecahkan masalah dan meluncurkan secepat mungkin. </p><br><h3 id="66-udalenie-myortvogo-koda">  6.6 Menghapus kode mati </h3><br><p>  Dalam sebuah monolith, sangat menakutkan untuk menghapus kode - Anda tidak pernah tahu di mana Anda bisa terjebak dengannya.  Karena itu, paling sering hanya tetap berbaring miring.  Selama bertahun-tahun.  Dan bahkan kode mati harus didukung, belum lagi kebingungan yang diperkenalkannya.  Oleh karena itu, seiring waktu, kami mulai menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analisis-kebutuhan</a> untuk pencarian kode mati yang dangkal, dan tes integrasi plus peluncuran dalam mode pemeriksaan cakupan untuk pencarian yang lebih dalam. </p><br><h2 id="7-raspil-monolita">  7 potong Monolith </h2><br><p>  Untuk beberapa alasan, banyak orang berpikir bahwa untuk beralih ke layanan microser, Anda perlu meninggalkan monolith Anda, menulis banyak layanan microser di dekat awal, menjalankan semuanya sekaligus - dan akan ada kebahagiaan.  Tapi model ini ... Hmm ... Itu penuh dengan fakta bahwa Anda tidak akan melakukan apa-apa, dan hanya menghabiskan banyak waktu dan uang untuk menulis kode yang harus Anda buang. </p><br><p>  Saya mengusulkan opsi lain, yang menurut saya lebih berfungsi, dan yang diterapkan bersama kami: </p><br><ol><li>  Kami mulai menulis layanan baru di microservices.  Kami menjalankan teknologinya, melompat menyapu, kami mengerti apakah kami ingin melakukannya sama sekali. </li><li>  Kami mengekstrak kode ke modul, perpustakaan, atau apa pun yang digunakan di sana. </li><li>  Kami membedakan layanan dari monolith. </li><li>  Kami membedakan microservices dari layanan.  Tanpa tergesa-gesa dan satu demi satu. </li></ol><br><h2 id="8-i-naposledok">  8 Dan akhirnya </h2><br><p><img src="https://habrastorage.org/webt/z8/tl/cv/z8tlcv6aibivr83m9q-fxzhusay.png" alt="gambar yang diambil dari https://fvl1-01.livejournal.com/"></p><br><p>  Pada akhirnya, saya memutuskan untuk meninggalkan hal yang paling penting. </p><br><p>  Ingat: </p><br><ul><li>  Anda bukan google </li><li>  Anda bukan microsoft </li><li>  Anda bukan facebook </li><li>  Anda bukan Yandex </li><li>  Anda bukan netflix </li><li>  Anda bukan OneTwoTrip </li></ul><br><p>  Jika sesuatu bekerja di perusahaan lain, sama sekali bukan fakta bahwa itu akan menguntungkan Anda.  Jika Anda mencoba menyalin secara membabi buta pengalaman perusahaan lain dengan kata-kata "itu bekerja untuk mereka," maka ini kemungkinan besar akan berakhir dengan buruk.  Setiap perusahaan, setiap produk, dan setiap tim adalah unik.  Apa yang berhasil untuk beberapa tidak akan bekerja untuk yang lain.  Saya tidak suka mengatakan hal-hal yang jelas, tetapi terlalu banyak orang mulai membangun kultus kargo di sekitar perusahaan lain, meniru pendekatan secara membabi buta, dan mengubur diri mereka di bawah dekorasi pohon Natal palsu.  Jangan lakukan itu.  Eksperimen, coba, kembangkan solusi yang optimal untuk Anda.  Dan hanya dengan begitu semuanya akan beres. </p><br><h2 id="poleznye-ssylki">  Tautan yang bermanfaat: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Laporan saya</a> dalam format video </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar putar lengkap</a> dari mitap oleh Node.JS </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459206/">https://habr.com/ru/post/id459206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459188/index.html">Debian 10 Buster dan Linux 5.2 Dirilis</a></li>
<li><a href="../id459194/index.html">Bagaimana kami berteman dengan SCSS dengan Variabel CSS menggunakan Tema UI Kit</a></li>
<li><a href="../id459196/index.html">Dari monolit ke tim modular</a></li>
<li><a href="../id459198/index.html">Analisis kinerja kueri di ClickHouse. Laporan Yandex</a></li>
<li><a href="../id459204/index.html">10 ++ cara untuk bekerja dengan register perangkat keras di C ++ (misalnya, IAR dan Cortex M)</a></li>
<li><a href="../id459208/index.html">Berjalan dengan prostesis: Simulasi Nekstgen tentang gerakan manusia menggunakan otot, tulang, dan jaringan saraf</a></li>
<li><a href="../id459212/index.html">Implementasi properti di C ++</a></li>
<li><a href="../id459214/index.html">Toleransi kesalahan dalam penyimpanan Qsan</a></li>
<li><a href="../id459216/index.html">Struktur data B-tree</a></li>
<li><a href="../id459220/index.html">Pengujian integrasi untuk memeriksa kebocoran memori</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>