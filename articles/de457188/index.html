<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèº üòá üßò Ruhiger, ruhiger Streit üí™üèæ ü§∞üèΩ üëÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor drei Jahren schrieb ich einen Artikel √ºber die DI-Bibliothek f√ºr die Swift-Sprache. Von diesem Moment an hat sich die Bibliothek stark ver√§ndert u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ruhiger, ruhiger Streit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457188/"><img src="https://habrastorage.org/files/c6d/c89/5d0/c6dc895d02324b96bc679f41228ab6bf.png" align="right" width="140" alt="Bibliothekssymbol">  Vor drei Jahren schrieb ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> √ºber die DI-Bibliothek f√ºr die Swift-Sprache.  Von diesem Moment an hat sich die Bibliothek stark ver√§ndert und ist der <s>beste seiner Art</s> , der Swinject w√ºrdig ist, und hat ihn in vielerlei Hinsicht √ºbertroffen.  Der Artikel widmet sich den F√§higkeiten der Bibliothek, enth√§lt aber auch theoretische √úberlegungen.  Wer sich also f√ºr die Themen DI, DIP, IoC interessiert oder zwischen Swinject und Swinject w√§hlt, bitte um einen Schnitt: <br clear="all"><a name="habracut"></a><br><br><h1>  Was ist DIP, IoC und womit isst es? </h1><br><h2>  Theorie von <abbr title="Prinzip der Abh√§ngigkeitsinversion">DIP</abbr> und <abbr title="Umkehrung der Kontrolle">IoC</abbr> </h2><br>  Die Theorie ist eine der wichtigsten Komponenten in der Programmierung.  Ja, Sie k√∂nnen Code ohne Schulung schreiben, aber trotzdem lesen Programmierer st√§ndig Artikel, interessieren sich f√ºr verschiedene Praktiken usw.  Das hei√üt, auf die eine oder andere Weise bekomme ich theoretisches Wissen, um es in die Praxis umzusetzen. <br><br>  Eines der Themen, die gerne nach Interviews <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gefragt werden,</a> ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SOLID</a> .  Kein Artikel handelt √ºberhaupt nicht von ihm, sei nicht beunruhigt.  Aber wir brauchen einen Brief, da er eng mit meiner Bibliothek verwandt ist.  Dies ist der Buchstabe "D" - Prinzip der Abh√§ngigkeitsinversion. <br><br>  Das Prinzip der Abh√§ngigkeitsinversion besagt: <br><br><ul><li>  Module der oberen Ebene sollten nicht von Modulen der unteren Ebene abh√§ngen.  Beide Modultypen sollten von Abstraktionen abh√§ngen. </li><li>  Abstraktionen sollten nicht von den Details abh√§ngen.  Details sollten von Abstraktionen abh√§ngen. </li></ul><br>  Viele Menschen gehen f√§lschlicherweise davon aus, dass sie sich automatisch an dieses Prinzip halten, wenn sie Protokolle / Schnittstellen verwenden, aber dies ist nicht ganz richtig. <br><br>  <abbr title="Module der oberen Ebene sollten nicht von Modulen der unteren Ebene abh√§ngen. Beide Modultypen m√ºssen von Abstraktionen abh√§ngen.">Die erste Aussage</abbr> sagt etwas √ºber Abh√§ngigkeiten zwischen Modulen aus - Module m√ºssen von Abstraktionen abh√§ngen.  Warten Sie, was ist Abstraktion?  - Es ist besser, sich nicht zu fragen, was Abstraktion ist, sondern was Abstraktion ist.  Das hei√üt, Sie m√ºssen verstehen, was der Prozess ist, und das Ergebnis dieses Prozesses wird eine Abstraktion sein.  <b>Abstraktion</b> ist eine Ablenkung des Erkenntnisprozesses von nicht wesentlichen Parteien, Eigenschaften und Beziehungen, um wesentliche, regelm√§√üige Zeichen hervorzuheben. <br><br>  Das gleiche Objekt kann je nach Ziel unterschiedliche Abstraktionen haben.  Beispielsweise hat die Maschine aus Sicht des Eigent√ºmers die folgenden wichtigen Eigenschaften: Farbe, Eleganz, Bequemlichkeit.  Aber aus Sicht des Mechanikers ist alles etwas anders: Marke, Modell, Modifikation, Kilometerstand, Unfallbeteiligung.  Es wurden gerade zwei verschiedene Abstraktionen f√ºr ein Objekt benannt - die Maschine. <br><br>  Beachten Sie, dass es in Swift √ºblich ist, Protokolle f√ºr Abstraktionen zu verwenden, dies ist jedoch keine Voraussetzung.  Niemand macht sich die M√ºhe, eine Klasse zu erstellen, eine Reihe √∂ffentlicher Methoden daraus zuzuweisen und Implementierungsdetails privat zu lassen.  In Bezug auf die Abstraktion ist nichts kaputt.  Wir m√ºssen uns an die wichtige These erinnern: ‚ÄûAbstraktion ist nicht an die Sprache gebunden‚Äú - dies ist ein Prozess, der st√§ndig in unserem Kopf stattfindet, und wie dies auf den Code √ºbertragen wird, ist nicht so wichtig.  Hier k√∂nnen wir auch die <abbr title="Daten zusammenf√ºhren und verstecken">Kapselung</abbr> als Beispiel daf√ºr erw√§hnen, was mit der Sprache verbunden ist.  Jede Sprache hat ihre eigenen Mittel, um sie bereitzustellen.  In Swift sind dies Klassen, Zugriffsfelder und Protokolle.  auf Obj-C-Schnittstellen, Protokollen und Trennung von h- und m-Dateien. <br><br>  <abbr title="Abstraktionen sollten nicht von den Details abh√§ngen. Details m√ºssen von Abstraktionen abh√§ngen.">Die zweite Aussage ist</abbr> interessanter, da sie ignoriert oder missverstanden wird.  Es geht um die Interaktion von Abstraktionen mit Details, und was sind Details?  Es gibt ein Missverst√§ndnis, dass die Details Klassen sind, die Protokolle implementieren - ja, das ist wahr, aber nicht vollst√§ndig.  Sie m√ºssen verstehen, dass die Details nicht an Programmiersprachen gebunden sind - die C-Sprache hat weder Protokolle noch Klassen, aber dieses Prinzip wirkt auch darauf ein.  Es f√§llt mir schwer, theoretisch zu erkl√§ren, was der Haken ist, deshalb werde ich zwei Beispiele nennen und dann versuchen zu beweisen, warum das zweite Beispiel korrekter ist. <br><br>  Angenommen, es gibt ein Klassenauto und einen Klassenmotor.  Es ist so passiert, dass wir sie anschlie√üen m√ºssen - die Maschine enth√§lt einen Motor.  Als kompetente Programmierer w√§hlen wir die Protokoll-Engine aus, implementieren das Protokoll und √ºbergeben die Implementierung des Protokolls an die Maschinenklasse.  Alles scheint gut und richtig zu sein - jetzt k√∂nnen Sie die Motorimplementierung einfach ersetzen und nicht glauben, dass etwas kaputt geht.  Als n√§chstes wird der Schaltung ein Motormechaniker hinzugef√ºgt.  Er interessiert sich f√ºr den Motor ganz andere Eigenschaften als das Auto.  Wir erweitern das Protokoll und jetzt enth√§lt es eine gr√∂√üere Anzahl von Funktionen als urspr√ºnglich.  Die Geschichte wird f√ºr den Besitzer des Autos, f√ºr die Fabrik, die Motoren usw. produziert, wiederholt. <br><br><img src="https://habrastorage.org/webt/yh/hh/v1/yhhhv1kv5yvffc1hcoqu489pfqi.png" alt="Keine Umkehrung"><br><br>  Aber wo ist der Fehler in der Argumentation?  Das Problem ist, dass die beschriebene Verbindung trotz der Verf√ºgbarkeit von Protokollen tats√§chlich ein "Detail" ist - ein "Detail".  Genauer gesagt, in welchem ‚Äã‚ÄãNamen und wo sich das Protokoll befindet, befindet sich die Engine. <br><br>  Betrachten Sie nun die <s>richtige</s> andere Option. <br><br>  Nach wie vor gibt es zwei Klassen - Motor und Auto.  Nach wie vor m√ºssen sie verbunden sein.  Aber jetzt k√ºndigen wir das Protokoll "Car Engine" oder "Heart of a Car" an.  Wir setzen nur die Eigenschaften ein, die das Auto vom Motor ben√∂tigt.  Und wir platzieren das Protokoll nicht neben seiner "Engine" -Implementierung, sondern neben der Maschine.  Wenn wir einen Mechaniker ben√∂tigen, m√ºssen wir ein anderes Protokoll erstellen und es in der Engine implementieren.  Es scheint, dass sich nichts ge√§ndert hat, aber der Ansatz ist radikal anders - die Frage ist nicht so sehr in den Namen, sondern darin, wem die Protokolle geh√∂ren und was das Protokoll ist - eine ‚ÄûAbstraktion‚Äú oder ein ‚ÄûDetail‚Äú. <br><br><img src="https://habrastorage.org/webt/wb/xl/qw/wbxlqwjb7ltz4pqvek-gybtxc00.png" alt="Inversion ist"><br><br>  Lassen Sie uns nun eine Analogie zu einem anderen Fall ziehen, da diese Argumente m√∂glicherweise nicht offensichtlich sind. <br><br>  Es gibt ein Backend und einige Funktionen werden ben√∂tigt.  Das Backend bietet uns eine gro√üe Methode, die eine Reihe von Daten enth√§lt, und sagt: "Sie ben√∂tigen diese 3 Felder von 1000". <br><br><div class="spoiler">  <b class="spoiler_title">Kleine Geschichte</b> <div class="spoiler_text">  Viele k√∂nnen sagen, dass dies nicht geschieht.  Und sie werden relativ richtig sein - es kommt vor, dass das Backend separat f√ºr die mobile Anwendung geschrieben wird.  So kam es, dass ich f√ºr ein Unternehmen arbeitete, bei dem Backend ein Service mit einer 10-j√§hrigen Geschichte ist, der unter anderem an die staatliche API gebunden ist.  Aus vielen Gr√ºnden war es f√ºr das Unternehmen nicht √ºblich, eine separate Methode f√ºr das Handy zu schreiben, und ich musste das verwenden, was war.  Und es gab eine wunderbare Methode mit ungef√§hr hundert Parametern in der Wurzel, und einige von ihnen waren verschachtelte W√∂rterb√ºcher.  Stellen Sie sich nun 100 Parameter vor, von denen 20% verschachtelte Parameter haben, und in jedem verschachtelten gibt es weitere 20-30 Parameter, die alle dieselbe Verschachtelung haben.  Ich erinnere mich nicht genau, aber die Anzahl der Parameter √ºberschritt 800 f√ºr einfache Objekte und f√ºr komplexe Objekte k√∂nnte sie h√∂her als 1000 sein. </div></div><br>  Klingt nicht sehr gut, oder?  Normalerweise schreibt das Backend eine Methode f√ºr bestimmte Aufgaben f√ºr das Frontend, und das Frontend ist der Kunde / Benutzer dieser Methoden.  Hmm ... Aber wenn Sie dar√ºber nachdenken, ist das Backend der Motor und das Frontend das Auto - die Maschine ben√∂tigt einige Motoreigenschaften, und nicht dem Motor m√ºssen die Eigenschaften f√ºr das Auto gegeben werden.  Warum schreiben wir die Protokoll-Engine trotzdem weiter und platzieren sie n√§her an der Implementierung der Engine und nicht der Maschine?  Es geht nur um die Skalierung - in den meisten iOS-Programmen ist es sehr selten, dass die Funktionalit√§t so stark erweitert werden muss, dass eine solche L√∂sung zum Problem wird. <br><br><h2>  Und was ist dann <abbr title="Abh√§ngigkeitsinjektion">DI</abbr> </h2><br>  Es gibt eine Substitution von Konzepten - DI ist keine Abk√ºrzung f√ºr DIP, sondern eine v√∂llig andere Abk√ºrzung, obwohl sie sich sehr eng mit DIP √ºberschneidet.  DI ist eine Abh√§ngigkeitsinjektion oder Abh√§ngigkeitsinjektion, keine Inversion.  Inversion spricht dar√ºber, wie Klassen und Protokolle miteinander interagieren sollen, und die Implementierung zeigt Ihnen, woher Sie sie beziehen k√∂nnen.  Im Allgemeinen k√∂nnen Sie es auf verschiedene Arten implementieren - beginnend dort, wo die Abh√§ngigkeiten auftreten: Konstruktor, Eigenschaft, Methode;  endet mit denen, die sie erstellen und wie automatisiert dieser Prozess ist.  Die Ans√§tze sind unterschiedlich, aber meiner Meinung nach sind Container f√ºr die Abh√§ngigkeitsinjektion am bequemsten.  Kurz gesagt, ihre ganze Bedeutung l√§uft auf eine einfache Regel hinaus: Wir sagen dem Container, wo und wie er implementiert werden soll, und danach wird alles unabh√§ngig implementiert.  Dieser Ansatz entspricht der ‚Äûrealen Implementierung von Abh√§ngigkeiten‚Äú. In diesem Fall wissen die Klassen, in die die Abh√§ngigkeiten eingebettet sind, nichts dar√ºber, wie dies geschieht, dh sie sind passiv. <br><br>  In vielen Sprachen wird f√ºr diese Implementierung der folgende Ansatz verwendet: In einzelnen Klassen / Dateien werden Implementierungsregeln mithilfe der Sprachsyntax beschrieben, wonach sie kompiliert und automatisch implementiert werden.  Es gibt keine Magie - nichts passiert automatisch, nur die Bibliotheken sind eng in die grundlegenden Mittel der Sprache integriert und √ºberlasten die Erstellungsmethoden.  F√ºr Swift / Obj-C wird daher allgemein angenommen, dass der Ausgangspunkt der UIViewController ist und Bibliotheken sich problemlos √ºber das Storyboard in den erstellten ViewController integrieren k√∂nnen.  Wenn Sie das Storyboard nicht verwenden, m√ºssen Sie einen Teil der Arbeit mit Stiften erledigen. <br><br>  Oh ja, ich h√§tte fast vergessen - die Antwort auf die Hauptfrage: "Warum brauchen wir das?"  Zweifellos k√∂nnen Sie sich selbst um die Abh√§ngigkeitsinjektion k√ºmmern und alles mit Stiften verschreiben.  Probleme treten jedoch auf, wenn die Diagramme gro√ü werden - Sie m√ºssen viele Verbindungen zwischen Klassen erw√§hnen, der Code w√§chst sehr stark.  Daher nehmen Bibliotheken, die automatisch rekursiv (und sogar zyklisch) Abh√§ngigkeiten implementieren, diese Sorgfalt auf sich und steuern als Bonus ihre Lebensdauer.  Das hei√üt, die Bibliothek tut nichts anderes als das Nat√ºrliche - sie vereinfacht einfach das Leben des Entwicklers.  Denken Sie nicht, dass Sie eine solche Bibliothek an einem Tag schreiben k√∂nnen - es ist eine Sache, alle Abh√§ngigkeiten f√ºr einen bestimmten Fall mit einem Stift zu schreiben, es ist eine andere Sache, einem Computer beizubringen, universell und korrekt zu implementieren. <br><br><h1>  Bibliotheksgeschichte </h1><br>  Die Geschichte w√§re nicht vollst√§ndig, wenn ich die Geschichte nicht kurz erz√§hlen w√ºrde.  Wenn Sie der Bibliothek aus der Beta-Version folgen, wird sie f√ºr Sie nicht so interessant sein, aber f√ºr diejenigen, die sie zum ersten Mal sehen, lohnt es sich zu verstehen, wie sie aussah und welche Ziele der Autor verfolgt hat (dh ich). <br>  Die Bibliothek war mein zweites Projekt, f√ºr das ich mich aus Gr√ºnden der Selbstbildung entschied, in Swift zu schreiben.  Vorher habe ich es geschafft, einen Logger zu schreiben, ihn aber nicht √∂ffentlich zug√§nglich zu machen - es ist immer besser. <br><br>  Aber mit DI ist die Geschichte interessanter.  Als ich damit anfing, konnte ich auf Swift nur eine Bibliothek finden - Swinject.  Zu dieser Zeit hatte sie 500 Sterne und Fehler, dass die Zyklen normalerweise nicht verarbeitet werden.  Ich habe mir das alles angesehen und ... Mein Verhalten l√§sst sich am besten mit meinem Lieblingssatz ‚ÄûUnd dann hat Ostap gelitten‚Äú beschreiben. Ich habe 5-6 Sprachen durchgesehen, mir angesehen, was in diesen Sprachen vorkommt, Artikel zu diesem Thema gelesen und festgestellt, dass es besser geht.  Und jetzt, nach fast drei Jahren, kann ich mit Zuversicht sagen, dass das Ziel erreicht wurde. Im Moment ist DITranquillity das Beste in meiner Weltanschauung. <br><br>  Lassen Sie uns verstehen, was eine gute DI-Bibliothek ist: <br><br><ul><li>  Es sollte alle grundlegenden Implementierungen bereitstellen: Konstruktor, Eigenschaften, Methoden </li><li>  Es sollte keinen Einfluss auf den Gesch√§ftscode haben. </li><li>  Sie sollte klar beschreiben, was schief gelaufen ist. </li><li>  Sie muss im Voraus verstehen, wo Fehler vorliegen, nicht zur Laufzeit. </li><li>  Es muss in grundlegende Tools (Storyboard) integriert sein. </li><li>  Es sollte eine pr√§gnante, pr√§gnante Syntax haben. </li><li>  Sie muss alles schnell und effizient erledigen. </li><li>  (Optional) Es sollte hierarchisch sein </li></ul><br>  Diese Grunds√§tze versuche ich w√§hrend der gesamten Entwicklung der Bibliothek einzuhalten. <br><br><h1>  Funktionen und Vorteile der Bibliothek </h1><br>  Zun√§chst ein Link zum Repository: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/ivlevAstef/DITranquillity</a> <br><br>  Der Hauptwettbewerbsvorteil, der f√ºr mich sehr wichtig ist, ist, dass die Bibliothek √ºber Startfehler spricht.  Nach dem Starten der Anwendung und dem Aufrufen der gew√ºnschten Funktion werden alle vorhandenen und potenziellen Probleme gemeldet.  Dies ist genau die Bedeutung des Namens der Bibliothek "ruhig" - tats√§chlich garantiert die Bibliothek nach dem Start des Programms, dass alle erforderlichen Abh√§ngigkeiten bestehen und es keine unl√∂sbaren Zyklen gibt.  An Stellen, an denen Unklarheiten bestehen, warnt die Bibliothek vor m√∂glichen Problemen. <br><br>  Es klingt gut f√ºr mich.  W√§hrend der Ausf√ºhrung des Programms treten keine Abst√ºrze auf. Wenn der Programmierer etwas vergessen hat, wird dies sofort gemeldet. <br><br>  Eine Protokollfunktion wird verwendet, um die Probleme zu beschreiben, die ich sehr empfehlen kann.  Die Protokollierung hat 4 Ebenen: Fehler, Warnung, Info, ausf√ºhrlich.  Die ersten drei sind sehr wichtig.  Letzteres ist nicht so wichtig - er schreibt alles, was passiert - welches Objekt registriert wurde, welches Objekt eingef√ºhrt wurde, welches Objekt erstellt wurde usw. <br><br>  Dies ist jedoch nicht alles, was die Bibliothek zu bieten hat: <br><br><ul><li>  Volle Thread-Sicherheit - jede Operation kann von jedem Thread aus ausgef√ºhrt werden und alles wird funktionieren.  Die meisten Leute brauchen dies nicht, daher wurde im Hinblick auf die Thread-Sicherheit daran gearbeitet, die Ausf√ºhrungsgeschwindigkeit zu optimieren.  Die Konkurrenzbibliothek f√§llt jedoch trotz der Versprechungen, wenn Sie sich gleichzeitig registrieren und ein Objekt erhalten </li><li>  Schnelle Ausf√ºhrungsgeschwindigkeit.  Auf einem realen Ger√§t ist DITranquillity doppelt so schnell wie sein Konkurrent.  Auf dem Simulator ist die Ausf√ºhrungsgeschwindigkeit nahezu gleich.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Test Link</a> </li><li>  Geringe Gr√∂√üe - Die Bibliothek wiegt weniger als Swinject + SwinjectStoryboad + SwinjectAutoregistration, √ºbertrifft jedoch dieses Paket an Funktionen </li><li>  Eine pr√§gnante, pr√§gnante Notiz, obwohl sie s√ºchtig macht </li><li>  Hierarchie.  F√ºr gro√üe Projekte, die aus vielen Modulen bestehen, ist dies ein sehr gro√ües Plus, da die Bibliothek die erforderlichen Klassen anhand der Entfernung vom aktuellen Modul finden kann.  Das hei√üt, wenn Sie in jedem Modul eine eigene Implementierung eines Protokolls haben, erhalten Sie in jedem Modul ohne Aufwand die gew√ºnschte Implementierung </li></ul><br><h1>  Demonstration </h1><br>  Und so fangen wir an.  Als letztes Mal wird das Projekt ber√ºcksichtigt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SampleHabr</a> .  Ich habe speziell nicht begonnen, das Beispiel zu √§ndern - Sie k√∂nnen also vergleichen, wie sich alles ge√§ndert hat.  Das Beispiel zeigt viele Funktionen der Bibliothek. <br><br>  Nur f√ºr den Fall, dass es kein Missverst√§ndnis gibt, da das Projekt angezeigt wird, verwendet es viele Funktionen.  Aber niemand st√∂rt sich daran, die Bibliothek auf vereinfachte Weise zu nutzen - heruntergeladen, einen Container erstellt, einige Klassen registriert, den Container verwenden. <br><br>  Zuerst m√ºssen wir ein Framework erstellen (optional): <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppFramework</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DIFramework</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   public static func load(container: DIContainer) { //     } }</span></span></code> </pre> <br>  Erstellen Sie zu Beginn des Programms Ihren eigenen Container mit diesem Framework: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-type"><span class="hljs-type">DIContainer</span></span>() <span class="hljs-comment"><span class="hljs-comment">//   container.append(framework: AppFramework.self) //     . //          ifdef DEBUG      ,         ,     . if !container.validate() { fatalError() }</span></span></code> </pre><br><h3>  Storyboard </h3><br>  Als n√§chstes m√ºssen Sie einen Basisbildschirm erstellen.  Normalerweise werden daf√ºr Storyboards verwendet, und in diesem Beispiel werde ich es verwenden, aber niemand st√∂rt sich daran, UIViewController zu verwenden. <br><br>  Zun√§chst m√ºssen wir ein Storyboard registrieren.  Erstellen Sie dazu ein ‚ÄûTeil‚Äú (optional - Sie k√∂nnen den gesamten Code in das Framework schreiben) mit dem darin registrierten Storyboard: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DITranquillity class AppPart: DIPart { static func load(container: DIContainer) { container.registerStoryboard(name: "Main", bundle: nil) .lifetime(.single) <span class="hljs-comment"><span class="hljs-comment">//   -    . } }</span></span></code> </pre><br><br>  Und f√ºgen Sie AppFramework einen Teil hinzu: <br><pre> <code class="swift hljs">container.append(part: <span class="hljs-type"><span class="hljs-type">AppPart</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre><br>  Wie Sie sehen k√∂nnen, verf√ºgt die Bibliothek √ºber eine praktische Syntax zum Registrieren von Storyboard, und ich empfehle dringend, sie zu verwenden.  Im Prinzip k√∂nnen Sie √§quivalenten Code ohne diese Methode schreiben, dieser ist jedoch gr√∂√üer und kann StoryboardReferences nicht unterst√ºtzen.  Das hei√üt, dieses Storyboard funktioniert nicht von einem anderen. <br><br>  Jetzt m√ºssen Sie nur noch ein Storyboard erstellen und den Startbildschirm anzeigen.  Dies erfolgt in AppDelegate nach √úberpr√ºfung des Containers: <br><br><pre> <code class="swift hljs">window = <span class="hljs-type"><span class="hljs-type">UIWindow</span></span>(frame: <span class="hljs-type"><span class="hljs-type">UIScreen</span></span>.main.bounds) <span class="hljs-comment"><span class="hljs-comment">///  Storyboard let storyboard: UIStoryboard = container.resolve(name: "Main") window!.rootViewController = storyboard.instantiateInitialViewController() window!.makeKeyAndVisible()</span></span></code> </pre><br>  Das Erstellen eines Storyboards mithilfe einer Bibliothek ist nicht viel komplizierter als gew√∂hnlich.  In diesem Beispiel k√∂nnte der Name √ºbersehen werden, da wir nur ein Storyboard haben - die Bibliothek h√§tte vermutet, dass Sie daran gedacht haben.  In einigen Projekten gibt es jedoch viele Storyboards. Verpassen Sie den Namen also nicht noch einmal. <br><br><h3>  Presenter und ViewController </h3><br>  Gehen Sie zum Bildschirm selbst.  Wir werden das Projekt nicht mit komplexen Architekturen laden, sondern das √ºbliche MVP verwenden.  Au√üerdem bin ich so faul, dass ich kein Protokoll f√ºr einen Moderator erstellen werde.  Das Protokoll wird etwas sp√§ter f√ºr eine andere Klasse erstellt. Hier ist es wichtig zu zeigen, wie Presenter und ViewController registriert und verkn√ºpft werden. <br><br>  F√ºgen Sie dazu AppPart den folgenden Code hinzu: <br><br><pre> <code class="swift hljs">container.register(<span class="hljs-type"><span class="hljs-type">YourPresenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) container.register(<span class="hljs-type"><span class="hljs-type">YourViewController</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .injection(\.presenter) <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  Mit diesen drei Zeilen k√∂nnen wir zwei Klassen registrieren und eine Verbindung zwischen ihnen herstellen. <br><br>  Neugierige m√∂gen sich fragen - warum ist die Syntax, die Swinject in einer separaten Bibliothek hat, die wichtigste im Projekt?  Die Antwort liegt in den Zielen - dank dieser Syntax speichert die Bibliothek alle Links im Voraus, anstatt sie zur Laufzeit zu berechnen.  Mit dieser Syntax k√∂nnen Sie auf viele Funktionen zugreifen, die anderen Bibliotheken nicht zur Verf√ºgung stehen. <br><br>  Wir starten die Anwendung und alles funktioniert, alle Klassen werden erstellt. <br><br><h3>  Daten </h3><br>  Nun m√ºssen wir eine Klasse und ein Protokoll hinzuf√ºgen, um Daten vom Server zu empfangen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Data?</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerImpl</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(domain: <span class="hljs-type"><span class="hljs-type">String</span></span>) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Data?</span></span> { ... } }</code> </pre><br>  Aus Gr√ºnden der Sch√∂nheit erstellen wir eine separate ServerPart DI-Klasse f√ºr den Server, in der wir sie registrieren.  Ich m√∂chte Sie daran erinnern, dass dies nicht erforderlich ist und direkt im Container registriert werden kann, aber wir suchen nicht nach einfachen Wegen :) <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DITranquillity class ServerPart: DIPart { static func load(container: DIContainer) { container.register{ ServerImpl(domain: "https:<span class="hljs-comment"><span class="hljs-comment">//github.com/") } .as(check: Server.self){$0} .lifetime(.single) } }</span></span></code> </pre><br>  In diesem Code ist nicht alles so transparent wie in den vorherigen und muss gekl√§rt werden.  Zun√§chst wird im Funktionsregister eine Klasse mit einem √ºbergebenen Parameter erstellt. <br><br>  Zweitens gibt es die Funktion "as" - sie besagt, dass auf die Klasse ein anderer Typ zugreifen kann - das Protokoll.  Das seltsame Ende dieser Operation in Form von "{$ 0}" ist Teil des Namens "check:".  Das hei√üt, dieser Code stellt sicher, dass ServerImpl ein Nachfolger von Server ist.  Es gibt jedoch eine andere Syntax: `as (Server.self)`, die dasselbe tut, jedoch ohne √úberpr√ºfung.  Um zu sehen, was der Compiler in beiden F√§llen ausgibt, k√∂nnen Sie die Protokollimplementierung entfernen. <br><br>  Es kann mehrere "as" -Funktionen geben - dies bedeutet, dass der Typ unter einem dieser Namen verf√ºgbar ist.  Bitte beachten Sie, dass dies eine einzelne Registrierung ist. Wenn die Klasse ein Singleton ist, ist dieselbe Instanz f√ºr jeden angegebenen Typ verf√ºgbar. <br><br>  Wenn Sie sich vor der M√∂glichkeit sch√ºtzen m√∂chten, eine Klasse nach Implementierungstyp zu erstellen, oder sich noch nicht an diese Syntax gew√∂hnt haben, k√∂nnen Sie im Prinzip schreiben: <br><br><pre> <code class="swift hljs">container.register{ <span class="hljs-type"><span class="hljs-type">ServerImpl</span></span>(domain: <span class="hljs-string"><span class="hljs-string">"https://github.com/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> }</code> </pre><br>  Dies ist ein √Ñquivalent, jedoch ohne die M√∂glichkeit, mehrere separate Typen anzugeben. <br><br>  Jetzt k√∂nnen Sie den Server in Presenter implementieren. Dazu reparieren wir Presenter so, dass er Server akzeptiert: <br><br><pre> <code class="swift hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourPresenter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(server: <span class="hljs-type"><span class="hljs-type">Server</span></span>) { ... } }</code> </pre><br>  Wir starten das Programm und es f√§llt auf die "validate" -Funktionen in AppDelegate mit der Meldung, dass der Typ "Server" nicht gefunden wurde, aber von "YourPresenter" ben√∂tigt wird.  Was ist los?  Bitte beachten Sie, dass der Fehler zu Beginn der Programmausf√ºhrung und nicht nachtr√§glich aufgetreten ist.  Und der Grund ist ganz einfach: Sie haben vergessen, "ServerPart" zum "AppFramework" hinzuzuf√ºgen: <br><br><pre> <code class="swift hljs">container.append(part: <span class="hljs-type"><span class="hljs-type">ServerPart</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre><br>  Wir fangen an - alles funktioniert. <br><br><h3>  Logger </h3><br>  Zuvor gab es eine Bekanntschaft mit M√∂glichkeiten, die nicht sehr beeindruckend sind und die viele haben.  Jetzt wird demonstriert, dass andere Bibliotheken auf Swift nicht wissen, wie. <br><br>  Unter dem Logger wurde ein separates <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> erstellt. <br><br>  Lassen Sie uns zun√§chst verstehen, was ein Logger sein wird.  Zu Bildungszwecken werden wir kein ausgetrickstes System erstellen, daher ist der Logger ein Protokoll mit einer Methode und mehreren Implementierungen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConsoleLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(file: <span class="hljs-type"><span class="hljs-type">String</span></span>) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(server: <span class="hljs-type"><span class="hljs-type">String</span></span>) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(loggers: [<span class="hljs-type"><span class="hljs-type">Logger</span></span>]) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } }</code> </pre><br>  Insgesamt haben wir: <br><br><ul><li>  √ñffentliches Protokoll </li><li>  3 verschiedene Logger-Implementierungen, von denen jede an einen anderen Ort schreibt </li><li>  Ein zentraler Logger, der die Protokollierungsfunktion f√ºr alle anderen aufruft </li></ul><br>  Das Projekt hat "LoggerFramework" und "LoggerPart" erstellt.  Ich werde ihren Code nicht ausschreiben, aber ich werde nur die Interna von `LoggerPart` ausschreiben: <br><br><pre> <code class="swift hljs">container.register{ <span class="hljs-type"><span class="hljs-type">ConsoleLogger</span></span>() } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .lifetime(.single) container.register{ <span class="hljs-type"><span class="hljs-type">FileLogger</span></span>(file: <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>) } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .lifetime(.single) container.register{ <span class="hljs-type"><span class="hljs-type">ServerLogger</span></span>(server: <span class="hljs-string"><span class="hljs-string">"http://server.com/"</span></span>) } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .lifetime(.single) container.register{ <span class="hljs-type"><span class="hljs-type">MainLogger</span></span>(loggers: many($<span class="hljs-number"><span class="hljs-number">0</span></span>)) } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>() .lifetime(.single)</code> </pre><br>  Wir haben bereits die ersten 3 Registrierungen gesehen und die letzte wirft Fragen auf. <br><br>  Ein Parameter wird an den Eingang √ºbergeben.  Eine √§hnliche wurde bereits bei der Erstellung des Pr√§sentators gezeigt, obwohl es einen abgek√ºrzten Datensatz gab - die "init" -Methode wurde nur verwendet, aber niemand st√∂rt sich daran, so zu schreiben: <br><br><pre> <code class="swift hljs">container.register { <span class="hljs-type"><span class="hljs-type">YourPresenter</span></span>(server: $<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  Wenn es mehrere Parameter g√§be, k√∂nnte man "$ 1", "$ 2", "$ 3" usw. verwenden.  bis 16. <br><br>  Dieser Parameter ruft jedoch die Funktion "many" auf.  Und hier beginnt der Spa√ü.  Es gibt zwei Modifikatoren "many" und "tag" in der Bibliothek. <div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text">  Es gibt einen dritten "arg" -Modifikator, der jedoch nicht sicher ist </div></div>  Der Modifikator "viele" besagt, dass Sie alle Objekte abrufen m√ºssen, die dem gew√ºnschten Typ entsprechen.  In diesem Fall wird das Logger-Protokoll erwartet, sodass alle Klassen, die von diesem Protokoll erben, gefunden und erstellt werden, mit einer Ausnahme - selbst, dh rekursiv.  Es wird sich w√§hrend der Initialisierung nicht selbst erstellen, obwohl es dies sicher tun kann, wenn es √ºber eine Eigenschaft implementiert wird. <br><br>  Das Tag ist wiederum ein separater Typ, der sowohl w√§hrend der Verwendung als auch w√§hrend der Registrierung angegeben werden muss.  Das hei√üt, Tags sind zus√§tzliche Kriterien, wenn nicht gen√ºgend Grundtypen vorhanden sind. <br><br>  Sie k√∂nnen mehr dar√ºber lesen: <a href="">Modifikatoren</a> <br><br>  Das Vorhandensein von Modifikatoren, insbesondere von "vielen", macht die Bibliothek besser als andere.  Beispielsweise k√∂nnen Sie das Observer-Muster auf einer v√∂llig anderen Ebene implementieren.  Aufgrund dieser 4 Buchstaben war es im Projekt m√∂glich, 30-50 Codezeilen von jedem Beobachter im Projekt zu entfernen und das Problem mit der Frage zu l√∂sen - wo und wann Objekte zum Observable hinzugef√ºgt werden sollten.  Klares Gesch√§ft ist nicht die einzige Anwendung, aber von Bedeutung. <br><br>  Nun, wir beenden die Pr√§sentation der Funktionen mit der Einf√ºhrung eines Loggers in YourPresenter: <br><br><pre> <code class="swift hljs">container.register(<span class="hljs-type"><span class="hljs-type">YourPresenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) .injection { $<span class="hljs-number"><span class="hljs-number">0</span></span>.logger = $<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  Hier ist es zum Beispiel etwas anders geschrieben als zuvor - dies geschieht f√ºr ein Beispiel einer anderen Syntax. <br><br>  Bitte beachten Sie, dass die Logger-Eigenschaft optional ist: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger: <span class="hljs-type"><span class="hljs-type">Logger?</span></span></code> </pre><br>  Und dies erscheint nicht in der Syntax der Bibliothek.  Im Gegensatz zur ersten Version sehen jetzt alle Operationen f√ºr den √ºblichen Typ, optional und erzwungen optional, gleich aus.  Dar√ºber hinaus ist die Logik im Inneren anders - wenn der Typ optional ist und nicht im Container registriert ist, st√ºrzt das Programm nicht ab, sondern setzt die Ausf√ºhrung fort. <br><br><h2>  Zusammenfassung </h2><br>  Die Ergebnisse sind √§hnlich wie beim letzten Mal, nur die Syntax ist k√ºrzer und funktionaler geworden. <br><br><h4>  Was wurde √ºberpr√ºft: </h4><br><ul><li>  <a href="">Registrieren Sie sich kurz</a> </li><li>  <a href="">Arbeiten Sie mit Storyboard, aber die Bibliothek kann mit StoryboardReferences arbeiten</a> </li><li>  <a href="">Registrierung √ºber eine Initialisierungsmethode oder -eigenschaft</a> </li><li>  <a href="">Mehrfachimplementierung</a> </li><li>  <a href="">Arbeiten Sie mit Frameworks und Teilen</a> </li><li>  <a href="">Ein bisschen Validierung</a> </li></ul><br><h4>  Was kann die Bibliothek noch tun: </h4><br><ul><li>  <a href="">5 Lebensdauern: Single, PerRun (.weak / .strong), PerContainer (.weak / .strong), objectGraph, Prototyp</a> </li><li>  <a href="">Tags Name</a> </li><li>  <a href="">Protokollierung</a> </li><li>  <a href="">Arbeiten Sie mit zyklischen Abh√§ngigkeiten</a> </li><li>  <a href="">Wurzeln schlagen in den Ansichten</a> </li><li>  <a href="">Aufgeschobene Implementierung</a> </li><li>  Die Einf√ºhrung von Argumenten, aber die Funktionalit√§t ist aufgrund ihrer Nicht-Sicherheit nicht dokumentiert </li></ul><br><h2>  Pl√§ne </h2><br>  Zun√§chst ist geplant, das Diagramm in der Kompilierungsphase zu √ºberpr√ºfen, dh enger in den Compiler zu integrieren.  Es gibt eine vorl√§ufige Implementierung mit SourceKitten, aber eine solche Implementierung hat ernsthafte Schwierigkeiten mit der Typinferenz. Daher ist geplant, auf Ast-Dump umzusteigen - in Swift5 wurde sie an gro√üen Projekten arbeiten.  An dieser Stelle m√∂chte ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mich</a> bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nekitosss</a> f√ºr den gro√üen Beitrag in diese Richtung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bedanken</a> . <br><br>  Zweitens m√∂chte ich mich in Visualisierungsdienste integrieren.  Dies wird ein etwas anderes Projekt sein, das jedoch eng mit der Bibliothek verbunden ist.  Was ist der Punkt?  Jetzt speichert die Bibliothek das gesamte Diagramm der Verbindungen, dh theoretisch kann alles, was in der Bibliothek registriert ist, als UML-Klassen- / Komponentendiagramm angezeigt werden.  Und es w√§re sch√∂n, dieses Diagramm manchmal zu sehen. <br><br>  Diese Funktionalit√§t ist in zwei Teilen geplant: Im ersten Teil k√∂nnen Sie eine API hinzuf√ºgen, um alle Informationen abzurufen, und im zweiten Teil sind bereits verschiedene Dienste integriert. <br><br>  Die einfachste Option besteht darin, ein Diagramm mit Links in Form von Text anzuzeigen. Ich habe jedoch keine lesbaren Optionen gesehen. Wenn ja, schlagen Sie Optionen in den Kommentaren vor. <br><br>  WatchOS - Ich selbst schreibe keine Projekte f√ºr sie.  F√ºr sein Leben schrieb er nur einmal und dann klein.  Aber ich w√ºrde gerne eine enge Integration machen, wie beim Storyboard. <br><br>  Das ist alles, danke f√ºr Ihre Aufmerksamkeit.  Ich hoffe sehr auf Kommentare und Antworten auf die Umfrage. <br><br><div class="spoiler">  <b class="spoiler_title">√úber mich</b> <div class="spoiler_text">  Ivlev Alexander Evgenievich - Senior / Teamleiter im iOS-Team.  Ich arbeite seit 7 Jahren im Handel, unter iOS 4,5 Jahre - davor war ich C ++ - Entwickler.  Aber die gesamte Programmiererfahrung betr√§gt mehr als 15 Jahre - in der Schule habe ich diese erstaunliche Welt kennengelernt und war so begeistert, dass es eine Zeit gab, in der ich Spiele <s>, Essen, eine Toilette und einen Traum</s> zum Schreiben von Code austauschte.  Nach einem meiner Artikel kann man vermuten, dass ich eine ehemalige Olympiade bin - dementsprechend war es f√ºr mich nicht schwierig, kompetente Arbeit mit Grafiken zu schreiben.  Spezialit√§t - Informationsmesssysteme, und fr√ºher war ich von Multithreading und Parallelit√§t besessen - ja, ich schreibe Code, in dem ich Annahmen und Fehler zu √§hnlichen Themen mache, aber ich verstehe die Problembereiche und verstehe perfekt, wo und wo Sie den Mutex vernachl√§ssigen k√∂nnen nicht wert. <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457188/">https://habr.com/ru/post/de457188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457178/index.html">Wie Prozessoren entworfen und hergestellt werden: CPU-Design</a></li>
<li><a href="../de457180/index.html">Die offizielle Seite Node.js ist jetzt in russischer Sprache</a></li>
<li><a href="../de457182/index.html">REXX Language, 40. Jahrestag</a></li>
<li><a href="../de457184/index.html">Erstellen Sie dynamisch robots.txt f√ºr ASP.NET Core-Sites</a></li>
<li><a href="../de457186/index.html">Python in Visual Studio Code - Ver√∂ffentlichung im Juni</a></li>
<li><a href="../de457190/index.html">Wir behandeln das Gesch√§ft durch die Implementierung von CRM-Systemen</a></li>
<li><a href="../de457192/index.html">Airbus erreicht mit der gemischten Realit√§t von Microsoft neue H√∂hen</a></li>
<li><a href="../de457194/index.html">Airbus erreicht mit Hilfe der Microsoft Mixed Reality-Technologie neue H√∂hen</a></li>
<li><a href="../de457196/index.html">Kleine Freude # 5: Dynaconf - Verwalten der Einstellungen im Projekt</a></li>
<li><a href="../de457198/index.html">Das neuronale Netzwerk hat gelernt, komplexe Szenen aus einer Textbeschreibung zu zeichnen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>