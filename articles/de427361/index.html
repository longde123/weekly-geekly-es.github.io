<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôåÔ∏è üë©üèø‚Äçüè≠ üìá Funktionen der Fensterfilterung auf FPGA üé§ ‚óªÔ∏è üï†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Dieser Artikel konzentriert sich auf einen wichtigen Teil der digitalen Signalverarbeitung - die Fenstersignalfilterung, insbesonder...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionen der Fensterfilterung auf FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427361/"> Hallo allerseits!  Dieser Artikel konzentriert sich auf einen wichtigen Teil der digitalen Signalverarbeitung - die Fenstersignalfilterung, insbesondere auf FPGAs.  Der Artikel zeigt, wie klassische Fenster mit Standardl√§nge und "langen" Fenstern von 64K bis 16M + entworfen werden.  Die Hauptentwicklungssprache ist VHDL, die Elementbasis sind die neuesten Xilinx FPGA-Kristalle der neuesten Familien: Ultrascale, Ultrascale +, 7-Serie.  Der Artikel zeigt die Implementierung von CORDIC - dem grundlegenden Kernel zum Konfigurieren von Fensterfunktionen beliebiger Dauer sowie grundlegenden Fensterfunktionen.  Der Artikel beschreibt die Entwurfsmethode unter Verwendung der Hochsprachen C / C ++ in Vivado HLS.  Wie √ºblich finden Sie am Ende des Artikels einen Link zu den Quellcodes des Projekts. <br><br>  KDPV: Ein typisches Schema der Signal√ºbertragung durch DSP-Knoten f√ºr Spektrumanalyseaufgaben. <br><br><img src="https://habrastorage.org/webt/hq/5j/_l/hq5j_lnsfr_k8oaex-cesewdeyi.png"><br><a name="habracut"></a><br><h3>  Einf√ºhrung </h3><br>  Aus dem Kurs ‚ÄûDigitale Signalverarbeitung‚Äú wissen viele Menschen, dass f√ºr eine sinusf√∂rmige Wellenform, die zeitlich unendlich ist, ihr Spektrum eine Delta-Funktion bei der Signalfrequenz ist.  In der Praxis entspricht das Spektrum eines zeitlich begrenzten harmonischen Signals der Funktion <b>~ sin (x) / x</b> , und die Breite der Hauptkeule h√§ngt von der Dauer des Signalanalyseintervalls <b>T ab.</b>  Das Zeitlimit ist nichts anderes als das Multiplizieren des Signals mit einer rechteckigen H√ºllkurve.  Aus dem DSP-Kurs ist bekannt, dass die Multiplikation von Signalen im Zeitbereich eine Faltung ihrer Spektren im Frequenzbereich ist (und umgekehrt), daher ist das Spektrum der begrenzten rechteckigen H√ºllkurve des harmonischen Signals √§quivalent zu ~ sinc (x).  Dies liegt auch daran, dass wir das Signal nicht √ºber ein unendliches Zeitintervall integrieren k√∂nnen und die Fourier-Transformation in diskreter Form, ausgedr√ºckt durch eine endliche Summe, durch die Anzahl der Abtastwerte begrenzt ist.  In der Regel nimmt die L√§nge der FFT in modernen digitalen FPGA-Verarbeitungsger√§ten <b>NFFT-</b> Werte von 8 bis zu mehreren Millionen Punkten an.  Mit anderen Worten wird das Spektrum des Eingangssignals auf dem Intervall <b>T</b> berechnet, das in vielen F√§llen gleich <b>NFFT ist</b> .  Indem wir das Signal auf das Intervall <b>T</b> begrenzen, legen wir dadurch ein rechteckiges "Fenster" mit einer Dauer von <b>T</b> Abtastwerten fest.  Daher ist das resultierende Spektrum das Spektrum des multiplizierten harmonischen Signals und der rechteckigen H√ºllkurve.  Bei DSP-Aufgaben wurden lange Zeit Fenster verschiedener Formen erfunden, die, wenn sie einem Signal im Zeitbereich √ºberlagert werden, dessen spektrale Eigenschaften verbessern k√∂nnen.  Eine gro√üe Anzahl verschiedener Fenster ist haupts√§chlich auf eines der Hauptmerkmale einer Fenster√ºberlagerung zur√ºckzuf√ºhren.  Dieses Merkmal dr√ºckt sich in der Beziehung zwischen der H√∂he der Nebenkeulen und der Breite der Mittellappen aus.  Ein bekanntes Muster: Je st√§rker die Unterdr√ºckung der Nebenkeulen ist, desto breiter ist die Hauptkeule und umgekehrt. <br><br>  Eine der Anwendungen von Fensterfunktionen: Erkennung schwacher Signale vor dem Hintergrund st√§rkerer Signale durch Unterdr√ºckung des Niveaus von Nebenkeulen.  Die Hauptfensterfunktionen in DSP-Aufgaben sind ein dreieckiges, sinusf√∂rmiges Fenster, Lanczos, Hann, Hamming, Blackman, Harris, Blackman-Harris-Fenster, Flat-Top-Fenster, Natall, Gauss, Kaiser-Fenster und viele andere.  Die meisten von ihnen werden durch eine endliche Reihe ausgedr√ºckt, indem harmonische Signale mit bestimmten Gewichten summiert werden.  Fenster mit komplexer Form werden mit einem Exponenten (Gau√üsches Fenster) oder einer modifizierten Bessel-Funktion (Kaiser-Fenster) berechnet und in diesem Artikel nicht ber√ºcksichtigt.  Sie k√∂nnen mehr √ºber Fensterfunktionen in der Literatur lesen, die ich traditionell am Ende des Artikels geben werde. <br><br>  Die folgende Abbildung zeigt typische Fensterfunktionen und ihre spektralen Eigenschaften, die mit Matlab CAD-Werkzeugen erstellt wurden. <br><br><img src="https://habrastorage.org/webt/nf/dw/pm/nfdwpmdfjlxbkjx4thfjo3d3wrq.png"><br><br><h3>  Implementierung </h3><br>  Zu Beginn des Artikels habe ich KDPV eingef√ºgt, das allgemein ein Strukturdiagramm der Multiplikation von Eingabedaten mit einer Fensterfunktion zeigt.  Der einfachste Weg, die Speicherung einer Fensterfunktion im FPGA zu implementieren, besteht offensichtlich darin, sie in den Speicher zu schreiben ( <i>RAMB</i> blockieren oder verteilt <i>verteilen</i> - das spielt keine Rolle) und dann die Daten zum Zeitpunkt der Eingangssignalabtastungen zyklisch abzurufen.  In modernen FPGAs erm√∂glicht die Gr√∂√üe des internen Speichers in der Regel das Speichern von Fensterfunktionen relativ kleiner Gr√∂√üe, die dann mit den eingehenden Eingangssignalen multipliziert werden.  Mit klein meine ich Fensterfunktionen mit einer L√§nge von bis zu 64 KB. <br><br>  Was aber, wenn die Fensterfunktion zu lang ist?  Zum Beispiel 1M Messwerte.  Es ist leicht zu berechnen, dass f√ºr eine solche Fensterfunktion, die in einem 32-Bit-Bitgitter dargestellt wird, NRAMB = 1024 * 1024 * 32/32768 = 1024 Blockspeicherzellen der FPGA-Xilinx-Kristalle vom Typ RAMB36K erforderlich sind.  Und f√ºr 16M Proben?  16 Tausend Speicherzellen!  Kein einziges modernes FPGA hat so viel Speicher.  F√ºr viele FPGAs ist dies zu viel, und in anderen F√§llen ist es eine verschwenderische Verwendung von FPGA-Ressourcen (und nat√ºrlich des Geldes des Kunden). <br><br>  In diesem Zusammenhang m√ºssen Sie eine Methode zum Generieren von Fensterfunktionsbeispielen direkt auf dem FPGA im laufenden Betrieb entwickeln, ohne Koeffizienten vom Remote-Ger√§t in den Blockspeicher schreiben zu m√ºssen.  Gl√ºcklicherweise sind die grundlegenden Dinge f√ºr uns schon lange erfunden.  Mit einem Algorithmus wie <b>CORDIC</b> ( <i>Ziffernweise</i> ) k√∂nnen viele Fensterfunktionen entworfen werden, deren Formeln in harmonischen Signalen ausgedr√ºckt werden (Blackman-Harris, Hann, Hamming, Nattal usw.). <br><br><h3>  CORDIC </h3><br>  CORDIC ist eine einfache und bequeme iterative Methode zur Berechnung der Drehung eines Koordinatensystems, mit der Sie komplexe Funktionen berechnen k√∂nnen, indem Sie primitive Additions- und Verschiebungsoperationen ausf√ºhren.  Mit dem CORDIC-Algorithmus kann man die Werte der harmonischen Signale sin (x), cos (x) berechnen, die Phasenatan (x) und atan2 (x, y) finden, hyperbolische trigonometrische Funktionen, den Vektor drehen, die Wurzel der Zahl extrahieren usw. <br><br>  Zuerst wollte ich den fertigen CORDIC-Kernel nehmen und den Arbeitsaufwand reduzieren, aber ich habe eine lange Abneigung gegen die Xilinx-Kernel.  Nachdem ich die Repositories auf dem Github studiert hatte, stellte ich fest, dass alle vorgestellten Kernel aus einer Reihe von Gr√ºnden nicht geeignet sind (schlecht dokumentiert und unlesbar, nicht universell, f√ºr eine bestimmte Aufgabe oder Elementbasis erstellt, <s>in Verilog geschrieben</s> usw.).  Dann bat ich Genosse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Lazifo</a> , diese Arbeit f√ºr mich zu erledigen.  Nat√ºrlich hat er damit fertig geworden, denn die Implementierung von CORDIC ist eine der einfachsten Aufgaben im Bereich DSP.  Aber da ich ungeduldig bin, habe ich parallel zu seiner Arbeit <s>mein Fahrrad mit</s> meinem <s>eigenen</s> parametrisierten Kern geschrieben.  Die Hauptmerkmale sind die konfigurierbare Bittiefe der Ausgangssignale <b>DATA_WIDTH</b> und der normalisierten Eingangsphase <b>PHASE_WIDTH</b> von -1 bis 1 sowie die Genauigkeit der <b>PRECISION-</b> Berechnungen.  Der CORDIC-Kern wird gem√§√ü der Pipeline-Parallelschaltung ausgef√ºhrt - bei jedem Taktzyklus ist der Kern bereit, Berechnungen durchzuf√ºhren und Eingangsabtastwerte zu empfangen.  Der Kernel verwendet N Zyklen, um das Ausgabesample zu berechnen, dessen Anzahl von der Kapazit√§t der Ausgabesamples abh√§ngt (je gr√∂√üer die Kapazit√§t, desto mehr Iterationen zur Berechnung des Ausgabewerts).  Alle Berechnungen erfolgen parallel.  Somit ist CORDIC der Basiskern zum Erstellen von Fensterfunktionen. <br><br><h3>  Fensterfunktionen </h3><br>  Im Rahmen dieses Artikels realisiere ich nur jene Fensterfunktionen, die durch harmonische Signale ausgedr√ºckt werden (Hann, Hamming, Blackman-Harris verschiedener Ordnung usw.).  Was wird daf√ºr ben√∂tigt?  Im Allgemeinen sieht die Formel zum Erstellen eines Fensters wie eine Reihe endlicher L√§ngen aus. <br><br><img src="https://habrastorage.org/webt/it/ih/tg/itihtgetk0lxnpoavnivrrot0ou.png"><br><br>  Ein bestimmter Satz von Koeffizienten <b>a <sub>k</sub></b> und Mitgliedern der Reihe bestimmt den Namen des Fensters.  Das beliebteste und am h√§ufigsten verwendete ist das Blackman-Harris-Fenster: unterschiedlicher Reihenfolge (von 3 bis 11).  Das Folgende ist eine Koeffiziententabelle f√ºr Blackman-Harris-Fenster: <br><br><img src="https://habrastorage.org/webt/fy/ss/_4/fyss_4cniul5oacholwxdvxfhli.jpeg"><br><br>  Im Prinzip ist der Blackman-Harris-Fenstersatz bei vielen Spektralanalyseproblemen anwendbar, und es besteht keine Notwendigkeit, komplexe Fenster wie Gau√ü oder Kaiser zu verwenden.  Nattal- oder Flat-Top-Fenster sind nur eine Vielzahl von Fenstern mit unterschiedlichen Gewichten, aber denselben Grundprinzipien wie Blackman-Harris.  Es ist bekannt, dass je mehr Mitglieder der Reihe, desto st√§rker die Unterdr√ºckung des Pegels der Nebenkeulen ist (vorbehaltlich einer vern√ºnftigen Wahl der Bittiefe der Fensterfunktion).  Basierend auf der Aufgabe muss der Entwickler nur den verwendeten Fenstertyp ausw√§hlen. <br><br><h3>  FPGA-Implementierung - traditioneller Ansatz </h3><br>  Alle Kernel von Fensterfunktionen werden unter Verwendung des klassischen Ansatzes zur Beschreibung digitaler Schaltungen in FPGAs entworfen und in der VHDL-Sprache geschrieben.  Unten finden Sie eine Liste der hergestellten Komponenten: <br><br><ul><li>  <i>bh_win_7term</i> - Blackman-Harris 7-Reihenfolge, ein Fenster mit maximaler Unterdr√ºckung von Seitenger√ºsten. </li><li>  <i>bh_win_5term</i> - Blackman-Harris 5-Bestellung, enth√§lt ein Fenster mit einer flachen Oberseite. </li><li>  <i>bh_win_4term</i> - Blackman-Harris 4-Bestellungen, einschlie√ülich der Fenster Nattal und Blackman-Nattal. </li><li>  <i>bh_win_3term</i> - Blackman-Harris 3 Bestellungen, </li><li>  <i>hamming_win</i> - Hamming und Hann Fenster. </li></ul><br>  Der Quellcode f√ºr die Blackman-Harris-Fensterkomponente betr√§gt 3 Gr√∂√üenordnungen: <br><br><pre><code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">entity</span></span> bh_win_3term <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span> ( TD : <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>:=<span class="hljs-number"><span class="hljs-number">0.5</span></span>ns; <span class="hljs-comment"><span class="hljs-comment">--! Time delay PHI_WIDTH : integer:=10; --! Signal period = 2^PHI_WIDTH DAT_WIDTH : integer:=16; --! Output data width XSERIES : string:="ULTRA" --! for 6/7 series: "7SERIES"; for ULTRASCALE: "ULTRA"; ); port ( RESET : in std_logic; --! Global reset CLK : in std_logic; --! System clock AA0 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A0 AA1 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A1 AA2 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A2 ENABLE : in std_logic; --! Clock enable DT_WIN : out std_logic_vector(DAT_WIDTH-1 downto 0); --! Output DT_VLD : out std_logic --! Output data valid ); end bh_win_3term;</span></span></code> </pre> <br>  In einigen F√§llen habe ich die <i>UNISIM-</i> Bibliothek verwendet, um die <b>DSP48E1- und DSP48E2-Knoten</b> in das Projekt einzubetten, wodurch <b>ich</b> letztendlich die Berechnungsgeschwindigkeit aufgrund des Pipelining in diesen Bl√∂cken erh√∂hen kann. Wie die Praxis gezeigt hat, ist es jedoch schneller und einfacher, freie Hand zu lassen und so etwas wie <b>P = zu</b> schreiben <b>A * B + C</b> und geben Sie die folgenden Anweisungen im Code an: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> USE_DSP <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> &lt;signal_name&gt;: <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-string"><span class="hljs-string">"YES"</span></span>;</code> </pre> <br>  Dies funktioniert gut und legt den Elementtyp fest, auf dem die mathematische Funktion f√ºr den Synthesizer implementiert ist. <br><br><h3>  Vivado hls </h3><br>  Au√üerdem habe ich alle Kerne mit den <b>Vivado HLS-</b> Tools implementiert.  Ich werde die <b>Hauptvorteile von</b> Vivado HLS auflisten: hohe Entwurfsgeschwindigkeit ( <i>Time-to-Market</i> ) in Hochsprachen C oder C ++, schnelle Modellierung entwickelter Knoten aufgrund des Fehlens eines Taktfrequenzkonzepts, flexible Konfiguration von L√∂sungen (in Bezug auf Ressourcen und Leistung) durch Einf√ºhrung Pragmas und Richtlinien im Projekt sowie eine niedrige Einstiegsschwelle f√ºr Entwickler in Hochsprachen.  Der Hauptnachteil sind die suboptimalen Kosten der FPGA-Ressourcen im Vergleich zum klassischen Ansatz.  Es ist auch nicht m√∂glich, die Geschwindigkeiten zu erreichen, die durch die klassischen alten RTL-Methoden (VHDL, Verilog, SV) bereitgestellt werden.  Nun, der gr√∂√üte <b>Nachteil</b> ist das Tanzen mit einem Tamburin, aber dies ist charakteristisch f√ºr alle CAD von Xilinx.  (Hinweis: Im Vivado HLS-Debugger und im tats√§chlichen C ++ - Modell wurden h√§ufig unterschiedliche Ergebnisse erzielt, da Vivado HLS die Vorteile der <i>willk√ºrlichen Genauigkeit</i> schief nutzt.) <br><br>  Das folgende Bild zeigt das Protokoll des synthetisierten CORDIC-Kernels in Vivado HLS.  Es ist sehr informativ und zeigt viele n√ºtzliche Informationen: die Menge der verwendeten Ressourcen, die Kernel-Benutzeroberfl√§che, Schleifen und ihre Eigenschaften, die Verz√∂gerung bei der Berechnung, das Intervall f√ºr die Berechnung des Ausgabewerts (wichtig beim Entwurf von seriellen und parallelen Schaltungen): <br><br><img src="https://habrastorage.org/webt/oe/e3/zh/oee3zhonsadxnqugfhd8geg7hca.png"><br><br>  Sie k√∂nnen auch sehen, wie Daten in verschiedenen Komponenten (Funktionen) berechnet werden.  Es ist ersichtlich, dass in Phase Null Phasendaten gelesen werden und in den Schritten 7 und 8 das Ergebnis des CORDIC-Knotens angezeigt wird. <br><img src="https://habrastorage.org/webt/kw/nf/j7/kwnfj7uftmtnnv6iaxoecjvji1g.png"><br><br>  Das Ergebnis von Vivado HLS: Ein synthetisierter RTL-Kernel, der aus C-Code erstellt wurde.  Das Protokoll zeigt, dass der Kernel in der Zeitanalyse alle Einschr√§nkungen erfolgreich erf√ºllt: <br><br><img src="https://habrastorage.org/webt/83/tb/hw/83tbhwy9j5jqkgn2tdz697dz-na.png"><br><br>  Ein weiteres gro√ües Plus von Vivado HLS ist, dass sie selbst zur √úberpr√ºfung des Ergebnisses eine Testbench des synthetisierten RTL-Codes erstellt, die auf dem Modell basiert, mit dem der C-Code √ºberpr√ºft wurde.  Dies mag ein primitiver Test sein, aber ich glaube, dass er sehr cool und praktisch genug ist, um die Funktionsweise des Algorithmus in C und auf HDL zu vergleichen.  Unten sehen Sie einen Screenshot von Vivado, der eine Simulation des Kernelfunktionsmodells einer von Vivado HLS erhaltenen Fensterfunktion zeigt: <br><br><img src="https://habrastorage.org/webt/6q/zw/3m/6qzw3mcmm6xixm-wh9kpumqpzx8.png"><br><br>  Somit wurden f√ºr alle Fensterfunktionen unabh√§ngig von der Entwurfsmethode √§hnliche Ergebnisse erzielt - in VHDL oder in C ++.  Im ersten Fall werden jedoch eine gr√∂√üere Betriebsfrequenz und eine geringere Anzahl von Ressourcen erreicht, und im zweiten Fall wird die maximale Entwurfsgeschwindigkeit erreicht.  Beide Ans√§tze haben das Recht auf Leben. <br><br>  Ich habe speziell berechnet, wie viel Zeit ich mit verschiedenen Methoden f√ºr die Entwicklung aufwenden w√ºrde.  Ich habe ein C ++ - Projekt in Vivado HLS ~ 12-mal schneller als in VHDL implementiert. <br><br><h3>  Vergleich der Ans√§tze </h3><br>  Vergleichen Sie den Quellcode f√ºr HDL und C ++ f√ºr den CORDIC-Kern.  Der Algorithmus basiert, wie bereits gesagt, auf den Operationen Addition, Subtraktion und Verschiebung.  Auf VHDL sieht es so aus: Es gibt drei Datenvektoren - einer ist f√ºr die Drehung des Winkels verantwortlich, und die anderen beiden bestimmen die L√§nge des Vektors entlang der X- und Y-Achse, was sin und cos entspricht (siehe Bild aus dem Wiki): <br><br><img src="https://habrastorage.org/webt/ab/3w/hv/ab3whvtkvcgl-ycqnkz3mjzr0lk.png"><br><br>  Durch iteratives Berechnen des Z-Werts werden die X- und Y-Werte parallel berechnet. Der Prozess der zyklischen Suche nach Ausgabewerten in HDL: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">constant</span></span> ROM_LUT : rom_array := ( x<span class="hljs-string"><span class="hljs-string">"400000000000"</span></span>, x<span class="hljs-string"><span class="hljs-string">"25C80A3B3BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"13F670B6BDC7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0A2223A83BBB"</span></span>, x<span class="hljs-string"><span class="hljs-string">"05161A861CB1"</span></span>, x<span class="hljs-string"><span class="hljs-string">"028BAFC2B209"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0145EC3CB850"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00A2F8AA23A9"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00517CA68DA2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0028BE5D7661"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00145F300123"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000A2F982950"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000517CC19C0"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00028BE60D83"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000145F306D6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000A2F9836D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000517CC1B7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000028BE60DC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000145F306E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000A2F9837"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000517CC1B"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000028BE60E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000145F307"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000A2F983"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000517CC2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000028BE61"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000145F30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000A2F98"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000517CC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000028BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000145F3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000A2FA"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000517D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000028BE"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000145F"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000A30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000518"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000028C"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000146"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000000A3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000051"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000029"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000014"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000000A"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000005"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000003"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000001"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000000"</span></span> ); pr_crd: <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(clk, reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reset = <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">---- Reset sine / cosine / angle vector ---- sigX &lt;= (others =&gt; (others =&gt; '0')); sigY &lt;= (others =&gt; (others =&gt; '0')); sigZ &lt;= (others =&gt; (others =&gt; '0')); elsif rising_edge(clk) then sigX(0) &lt;= init_x; sigY(0) &lt;= init_y; sigZ(0) &lt;= init_z; ---- calculate sine &amp; cosine ---- lpXY: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigX(ii+1) &lt;= sigX(ii) + sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) - sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); else sigX(ii+1) &lt;= sigX(ii) - sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) + sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); end if; end loop; ---- calculate phase ---- lpZ: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigZ(ii+1) &lt;= sigZ(ii) + ROM_TABLE(ii); else sigZ(ii+1) &lt;= sigZ(ii) - ROM_TABLE(ii); end if; end loop; end if; end process;</span></span></code> </pre><br>  In C ++, in Vivado HLS, sieht der Code fast gleich aus, aber der Datensatz ist um ein Vielfaches k√ºrzer: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Unrolled loop // int k; stg: for (k = 0; k &lt; NWIDTH; k++) { #pragma HLS UNROLL if (z[k] &lt; 0) { x[k+1] = x[k] + (y[k] &gt;&gt; k); y[k+1] = y[k] - (x[k] &gt;&gt; k); z[k+1] = z[k] + lut_angle[k]; } else { x[k+1] = x[k] - (y[k] &gt;&gt; k); y[k+1] = y[k] + (x[k] &gt;&gt; k); z[k+1] = z[k] - lut_angle[k]; } }</span></span></code> </pre><br><br>  Anscheinend wird der gleiche Zyklus mit Verschiebung und Hinzuf√ºgung verwendet.  Standardm√§√üig werden jedoch alle Schleifen in Vivado HLS "reduziert" und nacheinander ausgef√ºhrt, wie f√ºr die C ++ - Sprache vorgesehen.  Die Einf√ºhrung des <b>Pragmas HLS UNROLL</b> oder <b>HLS PIPELINE</b> konvertiert serielle in parallele Berechnungen.  Dies f√ºhrt zu einer Erh√∂hung der FPGA-Ressourcen. Sie k√∂nnen jedoch bei jedem Taktzyklus neue Werte berechnen und an den Kern senden. <br><br>  Die Ergebnisse der Synthese des Projekts in VHDL und C ++ sind in der folgenden Abbildung dargestellt.  Wie Sie logischerweise sehen k√∂nnen, ist der Unterschied zweimal zugunsten des traditionellen Ansatzes.  Bei anderen FPGA-Ressourcen ist die Diskrepanz unbedeutend.  Ich habe mich nicht eingehend mit der Optimierung des Projekts in C ++ befasst, aber durch das Festlegen verschiedener Anweisungen oder das teilweise √Ñndern des Codes kann die Anzahl der verwendeten Ressourcen reduziert werden.  In beiden F√§llen konvergierten die Timings f√ºr eine gegebene Kernfrequenz von ~ 350 MHz. <br><img src="https://habrastorage.org/webt/lp/id/ic/lpidicvwz-edguptklqfahlo0ya.png"><br><br><h3>  Implementierungsfunktionen </h3><br>  Da Berechnungen in einem Festkommaformat durchgef√ºhrt werden, weisen Fensterfunktionen eine Reihe von Merkmalen auf, die beim Entwurf von DSP-Systemen auf FPGAs ber√ºcksichtigt werden m√ºssen.  Je gr√∂√üer beispielsweise die Bittiefe der Fensterfunktionsdaten ist, desto besser ist die Genauigkeit der Fenstermischung.  Andererseits werden bei unzureichender Bittiefe der Fensterfunktion Verzerrungen in die resultierende Wellenform eingef√ºhrt, die die Qualit√§t der spektralen Eigenschaften beeinflussen.  Beispielsweise muss eine Fensterfunktion mindestens 20 Bits haben, wenn sie mit einem Signal mit einer Dauer von 2 ^ 20 = 1 M Abtastwerten multipliziert wird. <br><br><h3>  Fazit </h3><br>  Dieser Artikel zeigt eine M√∂glichkeit zum Entwerfen von Fensterfunktionen ohne Verwendung eines externen Speichers oder eines FPGA-Blockspeichers.  Die Methode zur Verwendung ausschlie√ülich logischer Ressourcen von FPGAs (und in einigen F√§llen von DSP-Bl√∂cken) wird angegeben.  Mit dem CORDIC-Algorithmus ist es m√∂glich, Fensterfunktionen mit beliebiger Bittiefe (innerhalb eines angemessenen Rahmens), beliebiger L√§nge und Reihenfolge zu erhalten und daher praktisch alle spektralen Eigenschaften des Fensters zu erhalten. <br><br>  Im Rahmen einer der Studien gelang es mir, einen stabil funktionierenden Kern der Blackman-Harris-Fensterfunktion von 5 und 7 Gr√∂√üenordnungen f√ºr 1M-Proben mit einer Frequenz von ~ 375 MHz zu erhalten und einen Generator f√ºr Rotationskoeffizienten f√ºr eine auf CORDIC basierende FFT mit einer Frequenz von ~ 400 MHz zu erstellen.  Verwendeter FPGA-Kristall: Kintex Ultrascale + (xcku11p-ffva1156-2-e). <br><br>  Link zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Github-</b> Projekt hier</a> .  Das Projekt enth√§lt ein mathematisches Modell in Matlab, Quellcodes f√ºr Fensterfunktionen und CORDIC in VHDL sowie Modelle der aufgelisteten Fensterfunktionen in C ++ f√ºr Vivado HLS. <br><br><h3>  N√ºtzliche Artikel </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DSPLib-Fensterfunktionen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einige DSPlib-Fensterfunktionen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweitertes Fensterfilter-Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki-Artikel √ºber CORDIC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vivado HLS Userguide</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Artikel √ºber die Spektralanalyse am Habr</a> </li></ul><br>  Ich empfehle auch ein sehr beliebtes Buch √ºber DSP - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ayficher E., Jervis B. Digitale Signalverarbeitung.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Praktischer Ansatz</a> <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427361/">https://habr.com/ru/post/de427361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427351/index.html">Sicherheitswoche 40: Sicherheitsl√ºcken in CMS Drupal und mehr</a></li>
<li><a href="../de427353/index.html">Drohnen zeigen: wie wir einen Schwarm tanzender Hubschrauber koordiniert haben</a></li>
<li><a href="../de427355/index.html">CJM-Zusammenstellung, wichtige Art Director-F√§higkeiten und Benutzerverst√§ndnis</a></li>
<li><a href="../de427357/index.html">Shader in Unity schreiben. GrabPass, PerRendererData</a></li>
<li><a href="../de427359/index.html">Wie ECS, C # Job System und SRP die Architektur √§ndern</a></li>
<li><a href="../de427363/index.html">Implementierung von LoRaWAN in einem landwirtschaftlichen Unternehmen. Alles √ºber Konstruktion, Einf√ºhrung und L√∂sungen</a></li>
<li><a href="../de427365/index.html">Bericht von RedSlerm √ºber die √úberwachung (Monit, Zabbix)</a></li>
<li><a href="../de427367/index.html">BLACK HAT USA Konferenz. Wie ein Hollywood-Hacker √úberwachungskameras einsetzt. Teil 1</a></li>
<li><a href="../de427369/index.html">BLACK HAT USA Konferenz. Wie ein Hollywood-Hacker √úberwachungskameras einsetzt. Teil 2</a></li>
<li><a href="../de427371/index.html">Videokurs "Grundlagen der Arbeit mit BPMN-Notationen." Kostenlos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>