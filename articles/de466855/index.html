<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🤝‍👨🏼 🍆 👨‍👧 Turmverteidigung in Einheit schaffen: Szenarien und Wellen der Feinde 🐰 💠 👩🏼‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Der erste , zweite , dritte und vierte Teil des Tutorials] 



- Unterstützung für Feinde kleiner, mittlerer und großer Größe. 
- Erstellen Sie Spie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Turmverteidigung in Einheit schaffen: Szenarien und Wellen der Feinde</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466855/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweite</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritte</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vierte</a> Teil des Tutorials] <br><br><ul><li>  Unterstützung für Feinde kleiner, mittlerer und großer Größe. </li><li>  Erstellen Sie Spielszenarien mit mehreren Wellen von Feinden. </li><li>  Trennung von Asset-Konfiguration und Gameplay-Status. </li><li>  Starten, pausieren, gewinnen, besiegen und beschleunigen Sie das Spiel. </li><li>  Erstellen Sie sich endlos wiederholende Szenarien. </li></ul><br>  Dies ist der fünfte Teil einer Reihe von Tutorials zum Erstellen eines einfachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tower Defense-</a> Spiels.  Darin lernen wir, wie man Spielszenarien erstellt, die Wellen verschiedener Feinde erzeugen. <br><br>  Das Tutorial wurde in Unity 2018.4.6f1 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/6aa/945/b126aa94582cc44651853c3ee69be82b.jpg" width="512" height="256"></div><br>  <i>Es wird ziemlich bequem.</i> <br><a name="habracut"></a><br><h2>  Noch mehr Feinde </h2><br>  Es ist nicht sehr interessant, jedes Mal denselben blauen Würfel zu erstellen.  Der erste Schritt zur Unterstützung interessanterer Spielszenarien besteht darin, verschiedene Arten von Feinden zu unterstützen. <br><br><h3>  Feindliche Konfigurationen </h3><br>  Es gibt viele Möglichkeiten, Feinde einzigartig zu machen, aber wir werden es nicht komplizieren: Wir klassifizieren sie als klein, mittel und groß.  Erstellen Sie eine <code>EnemyType</code> Aufzählung, um sie zu <code>EnemyType</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnemyType { Small, Medium, Large }</code> </pre> <br>  Ändern Sie <code>EnemyFactory</code> so, dass alle drei Arten von Feinden anstelle von einem unterstützt werden.  Für alle drei Feinde werden dieselben Konfigurationsfelder benötigt, daher fügen wir eine verschachtelte <code>EnemyConfig</code> Klasse hinzu, die alle enthält, und fügen dann der Fabrik drei Konfigurationsfelder dieses Typs hinzu.  Da diese Klasse nur für die Konfiguration verwendet wird und wir sie nirgendwo anders verwenden, können Sie ihre Felder einfach öffentlich machen, damit die Factory darauf zugreifen kann.  <code>EnemyConfig</code> selbst muss nicht öffentlich sein. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyConfig</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy prefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">2f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange scale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">5f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange speed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">-0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); } [SerializeField] EnemyConfig small = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, medium = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, large = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; … }</code> </pre> <br>  Lassen Sie uns auch die Gesundheit für jeden Feind anpassbar machen, da es logisch ist, dass große Feinde mehr als kleine haben. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">FloatRangeSlider(10f, 1000f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange health = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">100f</span></span>);</code> </pre> <br>  Fügen Sie <code>Get</code> einen Typparameter hinzu, damit Sie einen bestimmten Feindtyp erhalten können. Der Standardtyp ist mittel.  Wir werden den Typ verwenden, um die richtige Konfiguration zu erhalten, für die eine separate Methode nützlich ist, und dann den Feind wie zuvor erstellen und initialisieren, nur mit dem hinzugefügten Gesundheitsargument. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">EnemyConfig </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConfig</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Small: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> small; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Medium: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> medium; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Large: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> large; } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported enemy type!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type = EnemyType.Medium</span></span></span><span class="hljs-function">)</span></span> { EnemyConfig config = GetConfig(type); Enemy instance = CreateGameObjectInstance(config.prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( config.scale.RandomValueInRange, config.speed.RandomValueInRange, config.pathOffset.RandomValueInRange, config.health.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br>  Fügen Sie <code>Enemy.Initialize</code> den erforderlichen Parameter health <code>Enemy.Initialize</code> und verwenden Sie ihn, um den <code>Enemy.Initialize</code> anstatt ihn anhand der Größe des Feindes zu bestimmen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> health </span></span></span><span class="hljs-function">)</span></span> { … Health = health; }</code> </pre> <br><h3>  Wir erstellen das Design verschiedener Feinde </h3><br>  Sie können wählen, wie die drei Feinde aussehen sollen, aber im Tutorial werde ich mich um maximale Einfachheit bemühen.  Ich habe das ursprüngliche Fertighaus des Feindes dupliziert und es für alle drei Größen verwendet, wobei nur das Material geändert wurde: Gelb für Klein, Blau für Mittel und Rot für Groß.  Ich habe den Maßstab des Fertigwürfels nicht geändert, sondern die werkseitige Maßstabskonfiguration verwendet, um die Abmessungen festzulegen.  Außerdem habe ich je nach Größe ihre Gesundheit erhöht und die Geschwindigkeit verringert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/070/231/bd707023151022e921c5b6956bb20c02.png" width="320" height="348"></div><br>  <i>Fabrik für feindliche Würfel in drei Größen.</i> <br><br>  Der schnellste Weg ist, alle drei Typen im Spiel erscheinen zu lassen, indem Sie <code>Game.SpawnEnemy</code> so <code>Game.SpawnEnemy</code> , dass er einen zufälligen <code>Game.SpawnEnemy</code> anstelle des mittleren erhält. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile spawnPoint = board.GetSpawnPoint(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, board.SpawnPointCount)); Enemy enemy = enemyFactory.Get((EnemyType)(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))); enemy.SpawnOn(spawnPoint); enemies.Add(enemy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/537/73b/b92/53773bb9299a8ec9c56b485718049e5b.png" width="230" height="230"></div><br>  <i>Feinde verschiedener Art.</i> <br><br><h3>  Mehrere Fabriken </h3><br>  Jetzt setzt die Fabrik der Feinde viele drei Feinde.  Die bestehende Fabrik schafft Würfel in drei Größen, aber nichts hindert uns daran, eine andere Fabrik zu bauen, die etwas anderes schafft, zum Beispiel Kugeln in drei Größen.  Wir können die erstellten Feinde ändern, indem wir eine andere Fabrik im Spiel ernennen und so zu einem anderen Thema wechseln. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65f/7e5/330/65f7e5330945ea654f1caef579fe567f.png" width="230" height="230"></div><br>  <i>Sphärische Feinde.</i> <br><br><h2>  Wellen von Feinden </h2><br>  Der zweite Schritt bei der Erstellung von Spielszenarien ist die Ablehnung von Laichfeinden mit konstanter Häufigkeit.  Gegner müssen in aufeinanderfolgenden Wellen erstellt werden, bis das Skript endet oder der Spieler verliert. <br><br><h3>  Erstellungssequenzen </h3><br>  Eine Welle von Feinden besteht aus einer Gruppe von Feinden, die nacheinander erstellt werden, bis die Welle abgeschlossen ist.  Eine Welle kann verschiedene Arten von Feinden enthalten, und die Verzögerung zwischen ihrer Entstehung kann variieren.  Um die Implementierung nicht zu verkomplizieren, beginnen wir mit einer einfachen Laichsequenz, die dieselbe Art von Feinden mit einer konstanten Häufigkeit erzeugt.  Dann ist die Welle nur eine Liste solcher Sequenzen. <br><br>  Erstellen <code>EnemySpawnSequence</code> zum Konfigurieren jeder Sequenz eine <code>EnemySpawnSequence</code> Klasse.  Da es ziemlich kompliziert ist, legen Sie es in eine separate Datei.  Die Sequenz muss wissen, welche Fabrik verwendet werden soll, welche Art von Feind erstellt werden soll, wie viele und wie häufig sie sind.  Um die Konfiguration zu vereinfachen, machen wir den letzten Parameter zu einer Pause, die bestimmt, wie viel Zeit vergehen soll, bevor der nächste Feind erstellt wird.  Beachten Sie, dass Sie mit diesem Ansatz mehrere feindliche Fabriken in der Welle verwenden können. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { [SerializeField] EnemyFactory factory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] EnemyType type = EnemyType.Medium; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">1</span></span>; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown = <span class="hljs-number"><span class="hljs-number">1f</span></span>; }</code> </pre> <br><h3>  Die Wellen </h3><br>  Eine Welle ist eine einfache Anordnung feindlicher Erstellungssequenzen.  Erstellen Sie einen EnemyWave- <code>EnemyWave</code> Typ, der mit einer Standardsequenz beginnt. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; }</code> </pre> <br>  Jetzt können wir Wellen von Feinden erzeugen.  Zum Beispiel habe ich eine Welle erstellt, die eine Gruppe kubischer Feinde erzeugt, beginnend mit zehn kleinen, mit einer Frequenz von zwei pro Sekunde.  Es folgen fünf Durchschnittswerte, die einmal pro Sekunde erstellt werden, und schließlich ein großer Feind mit einer Pause von fünf Sekunden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/af3/47f/b16af347f057760db35703515642db89.png" width="320" height="376"></div><br>  <i>Eine Welle zunehmender Würfel.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Kann ich eine Verzögerung zwischen Sequenzen hinzufügen?</b> <div class="spoiler_text">  Sie können es indirekt implementieren.  Fügen Sie beispielsweise eine Verzögerung von vier Sekunden zwischen kleinen und mittleren Würfeln ein, reduzieren Sie die Anzahl der kleinen Würfel um eins und fügen Sie eine Folge eines kleinen Würfels mit einer Pause von vier Sekunden ein. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59b/ff4/3f9/59bff43f9a71002c0bd562f270b755ea.png" width="320" height="272"></div><br>  <i>Vier Sekunden Verzögerung zwischen kleinen und mittleren Würfeln.</i> </div></div><br><h3>  Szenarien </h3><br>  Das Gameplay-Szenario wird aus einer Folge von Wellen erstellt.  Erstellen Sie dazu einen <code>GameScenario</code> Asset- <code>GameScenario</code> mit einem einzelnen Array von Wellen und erstellen Sie daraus das Szenario. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; }</code> </pre> <br>  Zum Beispiel habe ich ein Szenario mit zwei Wellen kleiner, mittlerer und großer Feinde (MSC) erstellt, zuerst mit Würfeln, dann mit Kugeln. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/df0/73b/796df073b24d092d35093b6e56b8be79.png" width="320" height="142"></div><br>  <i>Szenario mit zwei MSC-Wellen.</i> <br><br><h3>  Sequenzbewegung </h3><br>  Asset-Typen werden zum Erstellen von Skripten verwendet. Da es sich jedoch um Assets handelt, müssen sie Daten enthalten, die sich während des Spiels nicht ändern.  Um das Szenario voranzutreiben, müssen wir jedoch irgendwie ihren Status verfolgen.  Eine Möglichkeit besteht darin, das im Spiel verwendete Asset zu duplizieren, damit das Duplikat seinen Zustand verfolgt.  Wir müssen jedoch nicht das gesamte Asset duplizieren, sondern nur den Status und die Links zum Asset.  Erstellen wir also zunächst eine separate <code>EnemySpawnSequence</code> für <code>EnemySpawnSequence</code> .  Da es nur für eine Sequenz gilt, machen wir es verschachtelt.  Es ist nur gültig, wenn es einen Verweis auf eine Sequenz enthält, daher geben wir ihm eine Konstruktormethode mit einem Sequenzparameter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18c/752/4fd/18c7524fdac87c062a6c683bbdee1866.png" width="315" height="50"></div><br>  <i>Ein verschachtelter Zustandstyp, der sich auf seine Sequenz bezieht.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { EnemySpawnSequence sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; } } }</code> </pre> <br>  Wenn wir in einer Sequenz vorwärts gehen wollen, brauchen wir dafür eine neue Instanz des Zustands.  Fügen Sie der <code>Begin</code> Methode Sequenzen hinzu, die den Status erstellt und zurückgibt.  Dank dessen ist jeder, der <code>Begin</code> anruft, dafür verantwortlich, den Status abzugleichen, und die Sequenz selbst bleibt zustandslos.  Es wird sogar möglich sein, mehrmals in derselben Reihenfolge parallel vorzurücken. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { … } }</code> </pre> <br>  Damit der Status nach einem heißen Neustart überlebt, müssen Sie ihn serialisierbar machen. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { … }</code> </pre> <br>  Der Nachteil dieses Ansatzes besteht darin, dass jedes Mal, wenn wir eine Sequenz ausführen, ein neues Statusobjekt erstellt werden muss.  Wir können die Speicherzuweisung vermeiden, indem wir sie zu einer Struktur anstelle einer Klasse machen.  Dies ist normal, solange der Zustand klein bleibt.  Denken Sie daran, dass state ein Werttyp ist.  Wenn es übertragen wird, wird es kopiert, also verfolgen Sie es an einer Stelle. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { … }</code> </pre> <br>  Der Zustand der Sequenz besteht nur aus zwei Aspekten: der Anzahl der erzeugten Feinde und dem Verlauf der Pausenzeit.  Wir fügen die <code>Progress</code> Methode hinzu, die den Wert der Pause um das <code>Game.Update</code> erhöht und sie dann zurücksetzt, wenn der konfigurierte Wert erreicht ist, ähnlich wie bei der Generierungszeit in <code>Game.Update</code> .  Wir werden die Anzahl der Feinde jedes Mal erhöhen, wenn dies geschieht.  Außerdem muss der Pausenwert mit dem Maximalwert beginnen, damit die Sequenz zu Beginn Feinde ohne Pause erzeugt. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; count = <span class="hljs-number"><span class="hljs-number">0</span></span>; cooldown = sequence.cooldown; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cooldown += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/aba/5e5/50caba5e50d89e05a6cb9a631feb1c6d.png" width="315" height="74"></div><br>  <i>Der Zustand enthält nur die notwendigen Daten.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Kann ich von State aus auf EnemySpawnSequence.cooldown zugreifen?</b> <div class="spoiler_text">  Ja, da der Status im selben Bereich festgelegt ist.  Daher kennen verschachtelte Typen die privaten Mitglieder der Typen, die sie enthalten. </div></div><br>  Der Fortschritt muss fortgesetzt werden, bis die gewünschte Anzahl von Feinden erreicht ist und die Pause endet.  Zu diesem Zeitpunkt sollte <code>Progress</code> Abschluss melden, aber höchstwahrscheinlich werden wir ein wenig über den Wert springen.  Daher müssen wir in diesem Moment die zusätzliche Zeit zurückgeben, um sie in der folgenden Reihenfolge für den Fortschritt zu verwenden.  Damit dies funktioniert, müssen Sie das Zeitdelta in einen Parameter umwandeln.  Wir müssen auch angeben, dass wir noch nicht fertig sind, und dies kann durch Rückgabe eines negativen Wertes realisiert werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt;= sequence.amount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cooldown; } count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Erschaffe überall Feinde </h3><br>  Damit Sequenzen Feinde <code>Game.SpawnEnemy</code> können, müssen wir <code>Game.SpawnEnemy</code> in eine andere öffentliche statische Methode konvertieren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyFactory factory, EnemyType type</span></span></span><span class="hljs-function">)</span></span> { GameTile spawnPoint = instance.board.GetSpawnPoint( Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, instance.board.SpawnPointCount) ); Enemy enemy = factory.Get(type); enemy.SpawnOn(spawnPoint); instance.enemies.Add(enemy); }</code> </pre> <br>  Da das <code>Game</code> selbst keine Feinde mehr erzeugt, können wir die feindliche Fabrik, die Erstellungsgeschwindigkeit, den Erstellungsförderungsprozess und den Erstellungscode des Feindes aus <code>Update</code> entfernen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Wir werden <code>Game.SpawnEnemy</code> in <code>EnemySpawnSequence.State.Progress</code> nachdem wir die Anzahl der Feinde erhöht haben. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { … count += <span class="hljs-number"><span class="hljs-number">1</span></span>; Game.SpawnEnemy(sequence.factory, sequence.type); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Wellenfortschritt </h3><br>  Gehen wir bei der Bewegung entlang einer Sequenz genauso vor wie bei der Bewegung entlang einer ganzen Welle.  Geben <code>EnemyWave</code> eine eigene <code>Begin</code> Methode, die eine neue Instanz der verschachtelten <code>EnemyWave</code> zurückgibt.  In diesem Fall enthält der Zustand den Wellenindex und den Zustand der aktiven Sequenz, die wir mit dem Beginn der ersten Sequenz initialisieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9eb/9f8/bc7/9eb9f8bc7769dd0c65624802ac2a97b8.png" width="315" height="128"></div><br>  <i>Ein Wellenzustand, der den Zustand einer Sequenz enthält.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { EnemyWave wave; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemySpawnSequence.State sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyWave wave</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wave = wave; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(wave.spawnSequences.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty wave!"</span></span>); sequence = wave.spawnSequences[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Wir fügen auch die <code>EnemyWave.State</code> Methode <code>Progress</code> , die mit geringfügigen Änderungen denselben Ansatz wie zuvor verwendet.  Wir beginnen mit der aktiven Sequenz und ersetzen das Zeitdelta durch das Ergebnis dieses Aufrufs.  Solange noch Zeit ist, fahren wir mit der nächsten Sequenz fort, wenn darauf zugegriffen wird, und führen den Fortschritt durch.  Wenn keine Sequenzen mehr vorhanden sind, geben wir die verbleibende Zeit zurück.  Andernfalls wird ein negativer Wert zurückgegeben. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { deltaTime = sequence.Progress(deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= wave.spawnSequences.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deltaTime; } sequence = wave.spawnSequences[index].Begin(); deltaTime = sequence.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Skript-Promotion </h3><br>  Fügen Sie <code>GameScenario</code> die gleiche Verarbeitung hinzu.  In diesem Fall enthält der Zustand den Wellenindex und den Zustand der aktiven Welle. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { GameScenario scenario; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(scenario.waves.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty scenario!"</span></span>); wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Da wir uns auf der obersten Ebene befinden, benötigt die <code>Progress</code> Methode keinen Parameter und Sie können <code>Time.deltaTime</code> direkt verwenden.  Wir müssen die verbleibende Zeit nicht zurückgeben, aber wir müssen zeigen, ob das Skript abgeschlossen ist.  Wir werden nach dem Ende der letzten Welle <code>false</code> und <code>true</code> zu zeigen, dass das Skript noch aktiv ist. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Skript ausführen </h3><br>  Um ein <code>Game</code> zu spielen, benötigen Sie ein Skriptkonfigurationsfeld und die Verfolgung seines Status.  Wir werden das Skript einfach in Awake ausführen und <code>Update</code> ausführen, bis der Status des restlichen Spiels aktualisiert ist. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameScenario scenario = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; GameScenario.State activeScenario; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; activeScenario = scenario.Begin(); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … activeScenario.Progress(); enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); nonEnemies.GameUpdate(); }</code> </pre> <br>  Jetzt wird das konfigurierte Skript zu Beginn des Spiels gestartet.  Die Promotion wird bis zur Fertigstellung durchgeführt, und danach passiert nichts mehr. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mk/x0/uf/mkx0ufxshpgvy29wjr_nxdmneu4.gif"></div><br>  <i>Zwei Wellen beschleunigten sich zehnmal.</i> <br><br><h2>  Spiele starten und beenden </h2><br>  Wir können ein Szenario reproduzieren, aber nach seiner Fertigstellung werden keine neuen Feinde erscheinen.  Damit das Spiel fortgesetzt werden kann, müssen wir es ermöglichen, ein neues Szenario entweder manuell oder weil der Spieler verloren / gewonnen hat, zu starten.  Sie können auch eine Auswahl mehrerer Szenarien implementieren. In diesem Lernprogramm wird dies jedoch nicht berücksichtigt. <br><br><h3>  Der Beginn eines neuen Spiels </h3><br>  Idealerweise brauchen wir die Möglichkeit, jederzeit ein neues Spiel zu starten.  Dazu müssen Sie den aktuellen Status des gesamten Spiels zurücksetzen, dh wir müssen viele Objekte zurücksetzen.  <code>GameBehaviorCollection</code> der <code>GameBehaviorCollection</code> eine <code>Clear</code> Methode <code>GameBehaviorCollection</code> , die alle ihre Verhaltensweisen nutzt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; behaviors.Count; i++) { behaviors[i].Recycle(); } behaviors.Clear(); }</code> </pre> <br>  Dies deutet darauf hin, dass alle Verhaltensweisen beseitigt werden können, dies ist jedoch bisher nicht der Fall.  <code>GameBehavior</code> abstrakte <code>Recycle</code> Methode hinzu, damit dies <code>GameBehavior</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>;</code> </pre> <br>  Die <code>Recycle</code> Methode der <code>WarEntity</code> Klasse muss sie explizit überschreiben. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>Enemy</code> verfügt noch nicht über eine <code>Recycle</code> Methode. Fügen Sie sie hinzu.  Alles was er tun muss, ist die Fabrik zu zwingen, es zurückzugeben.  Dann rufen wir <code>Recycle</code> wo immer wir direkt auf die Fabrik zugreifen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … } … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>GameBoard</code> ebenfalls zurückgesetzt werden. Geben Sie ihm also die <code>Clear</code> Methode, mit der alle Kacheln geleert, alle Erstellungspunkte zurückgesetzt und der Inhalt aktualisiert sowie die Standardstart- und -endpunkte festgelegt werden.  Anstatt den Code zu wiederholen, können wir am Ende von <code>Initialize</code> <code>Clear</code> aufrufen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … } } Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.Content = contentFactory.Get(GameTileContentType.Empty); } spawnPoints.Clear(); updatingContent.Clear(); ToggleDestination(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]); ToggleSpawnPoint(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Jetzt können wir dem <code>Game</code> die <code>BeginNewGame</code> Methode hinzufügen, Feinde, andere Objekte und das Feld <code>BeginNewGame</code> und dann ein neues Skript starten. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { enemies.Clear(); nonEnemies.Clear(); board.Clear(); activeScenario = scenario.Begin(); }</code> </pre> <br>  Wir werden diese Methode in <code>Update</code> aufrufen, wenn Sie B drücken, bevor Sie mit dem Skript fortfahren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } activeScenario.Progress(); … }</code> </pre> <br><h3>  Verlieren </h3><br>  Das Ziel des Spiels ist es, alle Feinde zu besiegen, bevor eine bestimmte Anzahl von ihnen den Endpunkt erreicht.  Die Anzahl der Gegner, die benötigt werden, um die Niederlage auszulösen, hängt von der anfänglichen Gesundheit des Spielers ab, für die wir dem <code>Game</code> ein Konfigurationsfeld hinzufügen.  Da wir Feinde zählen, verwenden wir eine Ganzzahl, nicht Float. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startingPlayerHealth = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/9c5/11a/4f39c511ab9d362b1cc7e55610a317aa.png" width="320" height="38"></div><br>  <i>Anfangs hat ein Spieler 10 Gesundheit.</i> <br><br>  Im Falle von Awake oder dem Start eines neuen Spiels weisen wir den Anfangswert der aktuellen Gesundheit des Spielers zu. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> playerHealth; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; … }</code> </pre> <br>  Fügen Sie eine öffentliche statische <code>EnemyReachedDestination</code> Methode hinzu, <code>EnemyReachedDestination</code> Gegner <code>Game</code> mitteilen können, dass sie den Endpunkt erreicht haben.  Verringern Sie in diesem Fall die Gesundheit des Spielers. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyReachedDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.playerHealth -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Rufen Sie diese Methode zum richtigen Zeitpunkt in <code>Enemy.GameUpdate</code> auf. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Game.EnemyReachedDestination(); Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Jetzt können wir den Zustand der Niederlage in <code>Game.Update</code> .  Wenn die Gesundheit des Spielers gleich oder kleiner als Null ist, wird die Niederlage ausgelöst.  Wir protokollieren diese Informationen einfach und starten sofort ein neues Spiel, bevor wir fortfahren.  Aber wir werden dies nur mit einer positiven Anfangsgesundheit tun.  Dies ermöglicht es uns, 0 als anfängliche Gesundheit zu verwenden, was es unmöglich macht, zu verlieren.  Daher ist es für uns bequem, die Skripte zu testen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; startingPlayerHealth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } activeScenario.Progress();</code> </pre> <br><h3>  Sieg </h3><br>  Eine Alternative zur Niederlage ist der Sieg, der am Ende des Szenarios erreicht wird, wenn der Spieler noch am Leben ist.  Das heißt, wenn das Ergebnis von <code>GameScenario.Progess</code> <code>false</code> , zeigen wir eine Siegesmeldung im Protokoll an, starten ein neues Spiel und fahren sofort damit fort. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  Der Sieg wird jedoch nach dem Ende der letzten Pause kommen, auch wenn sich noch Feinde auf dem Spielfeld befinden.  Wir müssen den Sieg verschieben, bis alle Feinde verschwunden sind. Dies kann erreicht werden, indem überprüft wird, ob die Sammlung der Feinde leer ist.  Wir gehen davon aus, dass es die <code>IsEmpty</code> Eigenschaft hat. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress() &amp;&amp; enemies.IsEmpty) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  Fügen Sie der <code>GameBehaviorCollection</code> die gewünschte Eigenschaft <code>GameBehaviorCollection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsEmpty =&gt; behaviors.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><h3>  Zeitsteuerung </h3><br>  Lassen Sie uns auch die Zeitverwaltungsfunktion implementieren. Dies hilft beim Testen und ist häufig eine Gameplay-Funktion.  Lassen Sie <code>Game.Update</code> nach einer Leertaste <code>Game.Update</code> und verwenden Sie dieses Ereignis, um Pausen im Spiel zu aktivieren / deaktivieren.  Dies kann durch Umschalten der <code>Time.timeScale</code> Werte zwischen Null und Eins erfolgen.  Dadurch wird die Spiellogik nicht geändert, aber alle Objekte frieren ein.  Oder Sie können einen sehr kleinen Wert anstelle von 0 verwenden, z. B. 0,01, um eine extrem langsame Bewegung zu erstellen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pausedTimeScale = <span class="hljs-number"><span class="hljs-number">0f</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } … }</code> </pre> <br> -,   <code>Game</code>    ,     . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 10f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> playSpeed = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5d/641/4e9/b5d6414e9cd53d7ac89c5c1b3699b806.png" width="320" height="38"></div><br> <i> .</i> <br><br>           ,     .         . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : playSpeed; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.timeScale &gt; pausedTimeScale) { Time.timeScale = playSpeed; }</code> </pre> <br><h2>   </h2><br>          .     ,           .      , ,      ,          . <br><br><h3>     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie dem </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurationsregler hinzu, um die Anzahl der Zyklen festzulegen. Weisen Sie ihm standardmäßig den Wert 1 zu. Machen Sie mindestens Null, und das Skript wird endlos wiederholt. </font><font style="vertical-align: inherit;">Wir werden also ein Überlebensszenario erstellen, das nicht besiegt werden kann, und es geht darum zu überprüfen, wie viel der Spieler aushalten kann.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycles = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/5d0/9df/d0c5d09dfd50e0e088c1848aaa32d531.png" width="320" height="38"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitaktszenario. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte </font><font style="vertical-align: inherit;">es die </font><font style="vertical-align: inherit;">Zyklusnummer verfolgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle, index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In werden </font></font><code>Progress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir nach Abschluss des Inkrements des Zyklus ausführen und </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur zurückkehren, wenn eine ausreichende Anzahl von Zyklen vergangen ist. </font><font style="vertical-align: inherit;">Andernfalls setzen wir den Wellenindex auf Null zurück und bewegen uns weiter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beschleunigung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es dem Spieler gelungen ist, den Zyklus einmal zu besiegen, kann er ihn problemlos wieder besiegen. Um das Szenario komplex zu halten, müssen wir die Komplexität erhöhen. Der einfachste Weg, dies zu tun, besteht darin, in nachfolgenden Zyklen alle Pausen zwischen der Schaffung von Feinden zu reduzieren. Dann erscheinen die Feinde schneller und besiegen den Spieler im Überlebensszenario unweigerlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie einen </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurationsregler hinzu, um die Beschleunigung pro Zyklus zu steuern. Dieser Wert wird nach jedem Zyklus nur zur Reduzierung der Pausen zur Zeitskala hinzugefügt. Beispielsweise hat bei einer Beschleunigung von 0,5 der erste Zyklus eine Pausengeschwindigkeit von × 1, der zweite Zyklus eine Geschwindigkeit von × 1,5, der dritte × 2, der vierte × 2,5 und so weiter.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cycleSpeedUp = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen Sie die Zeitskala und zu hinzufügen </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie ist anfangs immer gleich 1 und erhöht sich nach jedem Zyklus um einen bestimmten Beschleunigungswert. </font><font style="vertical-align: inherit;">Verwenden Sie es zum Skalieren, </font></font><code>Time.deltaTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bevor Sie sich entlang der Welle bewegen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeScale; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale = <span class="hljs-number"><span class="hljs-number">1f</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(timeScale * Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale += scenario.cycleSpeedUp; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/-d/3s/qv-d3srpikyuiorxx9vjk06wir8.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Zyklen mit zunehmender Geschwindigkeit der feindlichen Schöpfung; </font><font style="vertical-align: inherit;">zehnmal beschleunigt. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Möchten Sie Informationen zu neuen Tutorials erhalten? </font><font style="vertical-align: inherit;">Folgen Sie meiner Seite auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDF-Artikel</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466855/">https://habr.com/ru/post/de466855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466839/index.html">Geschichte von Norton Commander. Teil 1/3</a></li>
<li><a href="../de466841/index.html">Warum ein Heizkissen, wenn es einen Laptop gibt: die Untersuchung des Wärmewiderstands auf atomarer Ebene</a></li>
<li><a href="../de466845/index.html">Umgekehrtes Interview: Welche Fragen sollten Sie dem Unternehmen stellen?</a></li>
<li><a href="../de466849/index.html">noexcept-ctcheck oder ein paar einfache Makros, die dem Compiler helfen, noexcept-Code zu schreiben</a></li>
<li><a href="../de466851/index.html">Agilex-Linie - 10 nm Intel FPGA</a></li>
<li><a href="../de466857/index.html">Ausführung der Hintergrundanwendung in iOS 13</a></li>
<li><a href="../de466859/index.html">Verwenden des AD Federation Service zum Autorisieren von AWS-Benutzern mit Verteilung von Rechten</a></li>
<li><a href="../de466861/index.html">Wie man mit einem Hackathon der Realität entkommt</a></li>
<li><a href="../de466863/index.html">Asymptote einrichten</a></li>
<li><a href="../de466865/index.html">Warten auf den ersten November: Verbot oder Legalisierung von Kryptowährungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>