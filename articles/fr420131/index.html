<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíæ üì∂ üê£ M√©thode d'exploration de Bitcoin probabiliste üë©üèº‚Äçüéì üò£ ü•ã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je pense qu'un petit non-sens mardi ne fera pas de mal √† la semaine de travail. J'ai un passe-temps, dans mon temps libre, j'essaie de comprendre comm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©thode d'exploration de Bitcoin probabiliste</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420131/"><img src="https://habrastorage.org/webt/oi/lh/dt/oilhdtkhhgrgz2gpjy00mjrxhaq.jpeg"><br><br>  Je pense qu'un petit non-sens mardi ne fera pas de mal √† la semaine de travail.  J'ai un passe-temps, dans mon temps libre, j'essaie de comprendre comment pirater l'algorithme de minage de bitcoin, √©viter la force brute nonse stupide et trouver une solution au probl√®me de correspondance de hachage avec une consommation d'√©nergie minimale.  Je dois dire tout de suite le r√©sultat, bien s√ªr, je ne l'ai pas encore atteint, mais n√©anmoins, pourquoi ne pas exposer par √©crit les id√©es qui naissent dans la t√™te?  Quelque part, ils doivent √™tre plac√©s ... <br><br>  Malgr√© le d√©lire des id√©es ci-dessous, je pense que cet article peut √™tre utile √† quelqu'un qui √©tudie <br><br><ol><li>  Langage C ++ et ses mod√®les </li><li>  certains circuits num√©riques </li><li>  un peu de th√©orie des probabilit√©s et d'arithm√©tique probabiliste </li><li>  algorithme de hachage bitcoin en d√©tail </li></ol><a name="habracut"></a><br>  Par o√π commencer? <br><br>  Peut-√™tre du dernier √©l√©ment et le plus ennuyeux de cette liste?  Patience, alors ce sera plus amusant. <br>  Examinons en d√©tail l'algorithme de calcul de la fonction de hachage du bitcoin.  C'est simple F (x) = sha256 (sha256 (x)), o√π x est les donn√©es d'entr√©e de 80 octets, l'en-t√™te du bloc avec le num√©ro de version du bloc, le hachage du bloc pr√©c√©dent, la racine de fusion, l'horodatage, les bits et le nonce.  Voici des exemples d'en-t√™tes de bloc assez r√©cents qui sont pass√©s √† la fonction de hachage: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//blk=533522 0x00,0x00,0x00,0x20, 0x6d,0xa5,0xdd,0xb5,0x78,0x04,0x08,0x80,0xae,0x3d,0xed,0xc5,0x8e,0xe9,0x74,0x93,0x93,0x6d,0x6a,0xf4,0x0e,0x80,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xdf,0x3e,0xb0,0xf4,0x92,0xbf,0xe9,0xb8,0xc8,0x12,0x1f,0x84,0xdd,0x35,0xe1,0x38,0x09,0xcc,0x28,0xc2,0x33,0x53,0x90,0x4e,0x15,0x49,0x5e,0xc7,0xb0,0x78,0x35,0x91, 0x82,0xDB,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0xAA,0x02,0x44,0x22, //blk=533523 0x00,0x00,0x00,0x20, 0x6a,0x27,0x37,0xc3,0x1f,0x68,0xf8,0xe3,0x03,0xa3,0x5d,0xff,0x2d,0x97,0x39,0xaf,0x81,0xa2,0xf5,0xf0,0x7c,0xdb,0x34,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xa1,0xb8,0x4f,0x75,0x66,0xf3,0xf3,0x8e,0x78,0xf7,0xa2,0xa2,0xa2,0x19,0xa1,0x18,0x45,0xfa,0x58,0x53,0xe4,0x05,0x50,0x12,0x57,0xa1,0xab,0x2c,0x39,0xe6,0x1f,0x63, 0xA0,0xDB,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0x84,0x7B,0x86,0xE7, //blk=533524 0x00,0x00,0x00,0x20, 0xb3,0xc7,0xaa,0x07,0x26,0xdb,0xe8,0x58,0x19,0xa8,0xb9,0x53,0x08,0x62,0x8b,0xca,0x58,0x00,0x69,0x64,0x58,0x69,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x4e,0xfc,0xf4,0x5c,0xad,0x31,0x44,0x5b,0xb1,0x13,0x80,0x03,0xe0,0xfd,0x04,0x24,0x86,0xcc,0x7a,0x8c,0xa7,0x7c,0x30,0x60,0x05,0x6f,0x43,0xcf,0x25,0x45,0x8f,0xd8, 0x80,0xDE,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0xF7,0x2B,0x3B,0x42,</span></span></code> </pre> <br>  Cet ensemble d'octets est un mat√©riau tr√®s pr√©cieux, car il n'est souvent pas facile pour les mineurs de comprendre dans quel ordre les octets doivent suivre lors de la formation de l'en-t√™te, inversant souvent les emplacements des octets bas et hauts (endians). <br><br>  Ainsi, √† partir de l'en-t√™te du bloc, 80 octets sont consid√©r√©s comme le hachage sha256, puis √† partir du r√©sultat un autre sha256. <br>  L'algorithme sha256 lui-m√™me, si vous regardez diff√©rentes sources, se compose g√©n√©ralement de quatre fonctions: <br><br><ol><li>  void sha256_init (SHA256_CTX * ctx); </li><li>  void sha256_transform (SHA256_CTX * ctx, const BYTE data []); </li><li>  void sha256_update (SHA256_CTX * ctx, const BYTE data [], size_t len); </li><li>  void sha256_final (SHA256_CTX * ctx, hachage BYTE []); </li></ol><br>  La premi√®re fonction appel√©e lors du calcul du hachage est sha256_init (), qui restaure la structure SHA256_CTX.  Il n'y a rien de sp√©cial √† part huit mots d'√©tat 32 bits, qui sont initialement remplis de mots sp√©ciaux: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha256_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SHA256_CTX *ctx)</span></span></span><span class="hljs-function"> </span></span>{ ctx-&gt;datalen = <span class="hljs-number"><span class="hljs-number">0</span></span>; ctx-&gt;bitlen = <span class="hljs-number"><span class="hljs-number">0</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x6a09e667</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xbb67ae85</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0x3c6ef372</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">0xa54ff53a</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">0x510e527f</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-number"><span class="hljs-number">0x9b05688c</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">0x1f83d9ab</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">7</span></span>] = <span class="hljs-number"><span class="hljs-number">0x5be0cd19</span></span>; }</code> </pre><br>  Supposons que nous ayons un fichier dont le hachage doit √™tre calcul√©.  Nous lisons le fichier avec des blocs de taille arbitraire et appelons la fonction sha256_update () o√π nous passons le pointeur sur les donn√©es du bloc et la longueur du bloc.  La fonction accumule le hachage dans la structure SHA256_CTX dans le tableau d'√©tat: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha256_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SHA256_CTX *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BYTE data[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) { ctx-&gt;data[ctx-&gt;datalen] = data[i]; ctx-&gt;datalen++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx-&gt;datalen == <span class="hljs-number"><span class="hljs-number">64</span></span>) { sha256_transform(ctx, ctx-&gt;data); ctx-&gt;bitlen += <span class="hljs-number"><span class="hljs-number">512</span></span>; ctx-&gt;datalen = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre><br>  En soi, sha256_update () appelle la fonction cheval de bataille sha256_transform (), qui accepte d√©j√† des blocs d'une longueur fixe de 64 octets seulement: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/****************************** MACROS ******************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ROTLEFT(a,b) (((a) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; (b)) | ((a) &gt;&gt; (32-(b)))) #define ROTRIGHT(a,b) (((a) &gt;&gt; (b)) | ((a) &lt;&lt; (32-(b)))) #define CH(x,y,z) (((x) &amp; (y)) ^ (~(x) &amp; (z))) #define MAJ(x,y,z) (((x) &amp; (y)) ^ ((x) &amp; (z)) ^ ((y) &amp; (z))) #define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22)) #define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25)) #define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) &gt;&gt; 3)) #define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) &gt;&gt; 10)) /**************************** VARIABLES *****************************/ static const uint32_t k[64] = { 0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5, 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174, 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da, 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967, 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85, 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070, 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3, 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2 }; /*********************** FUNCTION DEFINITIONS ***********************/ void sha256_transform(SHA256_CTX *ctx, const BYTE data[]) { uint32_t a, b, c, d, e, f, g, h, i, j, t1, t2, m[64]; for (i = 0, j = 0; i &lt; 16; ++i, j += 4) m[i] = (data[j] &lt;&lt; 24) | (data[j + 1] &lt;&lt; 16) | (data[j + 2] &lt;&lt; 8) | (data[j + 3]); for (; i &lt; 64; ++i) m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16]; a = ctx-&gt;state[0]; b = ctx-&gt;state[1]; c = ctx-&gt;state[2]; d = ctx-&gt;state[3]; e = ctx-&gt;state[4]; f = ctx-&gt;state[5]; g = ctx-&gt;state[6]; h = ctx-&gt;state[7]; for (i = 0; i &lt; 64; ++i) { t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i]; t2 = EP0(a) + MAJ(a, b, c); h = g; g = f; f = e; e = d + t1; d = c; c = b; b = a; a = t1 + t2; } ctx-&gt;state[0] += a; ctx-&gt;state[1] += b; ctx-&gt;state[2] += c; ctx-&gt;state[3] += d; ctx-&gt;state[4] += e; ctx-&gt;state[5] += f; ctx-&gt;state[6] += g; ctx-&gt;state[7] += h; }</span></span></span></span></code> </pre><br>  Lorsque tout le fichier de hachage a √©t√© lu et d√©j√† transf√©r√© vers la fonction sha256_update (), il ne reste plus qu'√† appeler la fonction finale sha256_final (), qui, si la taille du fichier n'√©tait pas un multiple de 64 octets, ajoutera des octets de remplissage suppl√©mentaires, √©crit la longueur totale des donn√©es √† la fin du dernier bloc de donn√©es et fera la finale sha256_transform (). <br>  Le r√©sultat du hachage reste dans le tableau d'√©tat. <br><br>  C'est pour ainsi dire le ¬´haut niveau¬ª. <br><br>  En ce qui concerne le mineur Bitcoin, bien s√ªr, les d√©veloppeurs pensent comment consid√©rer plus petit et plus efficace. <br><br>  C'est simple: l'en-t√™te ne contient que 80 octets, ce qui n'est pas un multiple de 64 octets.  Ainsi, il serait n√©cessaire que le premier sha256 fasse d√©j√† deux sha256_transform ().  Cependant, heureusement pour les mineurs, le nonce du bloc est √† la fin de l'en-t√™te, donc le premier sha256_transform () ne peut √™tre ex√©cut√© qu'une seule fois - ce sera ce qu'on appelle le midstate.  Ensuite, le mineur passe par toutes les options nonse, qui sont 4 milliards, 2 ^ 32 et les substitue dans le champ correspondant √† la deuxi√®me sha256_transform ().  Cette transformation termine la premi√®re fonction sha256.  Son r√©sultat est huit mots de 32 bits, soit 32 octets.  Il est facile de trouver sha256 √† partir d'eux - le dernier sha256_transform () est appel√©, et tout est pr√™t.  Notez que les donn√©es d'entr√©e sont inf√©rieures de 32 octets aux 64 octets n√©cessaires pour sha256_transform ().  Encore une fois, le bloc sera rempli de z√©ros et la longueur du bloc sera entr√©e √† la fin. <br><br>  Au total, il n'y a que trois appels √† sha256_transform () dont le premier doit √™tre lu une seule fois pour calculer le midstate. <br><br>  J'ai essay√© d'√©tendre toutes les manipulations de donn√©es qui se produisent lors du calcul du hachage de l'en-t√™te d'un bloc bitcoin en une seule fonction, afin qu'il soit clair comment tout le calcul se produit sp√©cifiquement pour bitcoin et c'est ce qui s'est pass√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//get bitcoin header via ptr to 80 bytes and calc hash template &lt;typename T&gt; void full_btc_hash(const uint8_t* ptr80, T nonce, T* presult) { //-1------------------------------------------ //init sha256 state s[7:0] T s[16]; for (int i = 0; i &lt; 8; i++) { s[i] = sha256_init_state[i]; presult[i] = sha256_init_state[i]; } uint8_t tail2[] = { 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00, }; uint32_t* p = (uint32_t*)tail2; for (int i = 0; i &lt; 8; i++) { s[i + 8] = ntohl(p[i]); } //get first block for sha256 uint8_t tail[] = { /* 2nd sha256 block padding */ 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x80 }; T blk1[32]; p = (uint32_t*)ptr80; for (int i = 0; i &lt; 19; i++) { blk1[i] = ntohl(p[i]); } //put nonce here blk1[19] = nonce; p = (uint32_t*)tail; for (int i = 0; i &lt; 12; i++) { blk1[i + 20] = ntohl(p[i]); } sha256_transform(s, &amp;blk1[0]); //warning! this can be called only once and produce MIDSTATE sha256_transform(s, &amp;blk1[16]); sha256_transform(presult, s); }</span></span></code> </pre><br>  J'ai impl√©ment√© cette fonction en tant que mod√®le c ++, elle peut fonctionner non seulement sur des mots 32 bits, par exemple uint32_t, mais √©galement sur des mots d'un type diff√©rent "T" de la m√™me mani√®re.  J'ai ici et l'√©tat sha256 est stock√© comme un tableau de type "T" et sha256_transform () est appel√© avec un pointeur de param√®tre vers un tableau de type "T" et le r√©sultat est retourn√© le m√™me.  La fonction de transformation est d√©sormais √©galement sous la forme d'un mod√®le c ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ror32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T word, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shift)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (word &gt;&gt; shift) | (word &lt;&lt; (<span class="hljs-number"><span class="hljs-number">32</span></span> - shift)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x, T y, T z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z ^ (x &amp; (y ^ z)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Maj</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x, T y, T z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &amp; y) | (z &amp; (x | y)); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> e0(x) (ror32(x, 2) ^ ror32(x,13) ^ ror32(x,22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> e1(x) (ror32(x, 6) ^ ror32(x,11) ^ ror32(x,25)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> s0(x) (ror32(x, 7) ^ ror32(x,18) ^ (x &gt;&gt; 3)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> s1(x) (ror32(x,17) ^ ror32(x,19) ^ (x &gt;&gt; 10)) unsigned int ntohl(unsigned int in) { return ((in &amp; 0xff) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 24) | ((in &amp; 0xff00) &lt;&lt; 8) | ((in &amp; 0xff0000) &gt;&gt; 8) | ((in &amp; 0xff000000) &gt;&gt; 24); } template &lt;typename T&gt; void LOAD_OP(int I, T *W, const u8 *input) { //W[I] = /*ntohl*/ (((u32*)(input))[I]); W[I] = ntohl(((u32*)(input))[I]); //W[I] = (input[3] &lt;&lt; 24) | (input[2] &lt;&lt; 16) | (input[1] &lt;&lt; 8) | (input[0]); } template &lt;typename T&gt; void BLEND_OP(int I, T *W) { W[I] = s1(W[I - 2]) + W[I - 7] + s0(W[I - 15]) + W[I - 16]; } template &lt;typename T&gt; void sha256_transform(T *state, const T *input) { T a, b, c, d, e, f, g, h, t1, t2; TW[64]; int i; /* load the input */ for (i = 0; i &lt; 16; i++) // MJ input is cast to u32* so this processes 16 DWORDS = 64 bytes W[i] = input[i]; /* now blend */ for (i = 16; i &lt; 64; i++) BLEND_OP(i, W); /* load the state into our registers */ a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4]; f = state[5]; g = state[6]; h = state[7]; // t1 = h + e1(e) + Ch(e, f, g) + 0x428a2f98 + W[0]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x71374491 + W[1]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xb5c0fbcf + W[2]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xe9b5dba5 + W[3]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x3956c25b + W[4]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x59f111f1 + W[5]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x923f82a4 + W[6]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xab1c5ed5 + W[7]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xd807aa98 + W[8]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x12835b01 + W[9]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x243185be + W[10]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x550c7dc3 + W[11]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x72be5d74 + W[12]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x80deb1fe + W[13]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x9bdc06a7 + W[14]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xc19bf174 + W[15]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xe49b69c1 + W[16]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xefbe4786 + W[17]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x0fc19dc6 + W[18]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x240ca1cc + W[19]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x2de92c6f + W[20]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x4a7484aa + W[21]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x5cb0a9dc + W[22]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x76f988da + W[23]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x983e5152 + W[24]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xa831c66d + W[25]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xb00327c8 + W[26]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xbf597fc7 + W[27]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0xc6e00bf3 + W[28]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xd5a79147 + W[29]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x06ca6351 + W[30]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x14292967 + W[31]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x27b70a85 + W[32]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x2e1b2138 + W[33]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x4d2c6dfc + W[34]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x53380d13 + W[35]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x650a7354 + W[36]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x766a0abb + W[37]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x81c2c92e + W[38]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x92722c85 + W[39]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xa2bfe8a1 + W[40]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xa81a664b + W[41]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xc24b8b70 + W[42]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xc76c51a3 + W[43]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0xd192e819 + W[44]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xd6990624 + W[45]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0xf40e3585 + W[46]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x106aa070 + W[47]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x19a4c116 + W[48]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x1e376c08 + W[49]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x2748774c + W[50]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x34b0bcb5 + W[51]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x391c0cb3 + W[52]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x4ed8aa4a + W[53]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x5b9cca4f + W[54]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x682e6ff3 + W[55]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x748f82ee + W[56]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x78a5636f + W[57]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x84c87814 + W[58]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x8cc70208 + W[59]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x90befffa + W[60]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xa4506ceb + W[61]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0xbef9a3f7 + W[62]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xc67178f2 + W[63]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e; state[5] += f; state[6] += g; state[7] += h; }</span></span></span></span></code> </pre><br>  L'utilisation des fonctions de mod√®le C ++ est pratique dans la mesure o√π je peux calculer le hachage dont j'ai besoin √† partir de donn√©es r√©guli√®res et obtenir le r√©sultat habituel: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> header[] = { <span class="hljs-number"><span class="hljs-number">0x02</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x17</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x5b</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0xc1</span></span>,<span class="hljs-number"><span class="hljs-number">0x8e</span></span>,<span class="hljs-number"><span class="hljs-number">0xd1</span></span>,<span class="hljs-number"><span class="hljs-number">0xf7</span></span>, <span class="hljs-number"><span class="hljs-number">0xe2</span></span>,<span class="hljs-number"><span class="hljs-number">0x55</span></span>,<span class="hljs-number"><span class="hljs-number">0xad</span></span>,<span class="hljs-number"><span class="hljs-number">0xf2</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x59</span></span>,<span class="hljs-number"><span class="hljs-number">0x9b</span></span>,<span class="hljs-number"><span class="hljs-number">0x55</span></span>, <span class="hljs-number"><span class="hljs-number">0x33</span></span>,<span class="hljs-number"><span class="hljs-number">0x0e</span></span>,<span class="hljs-number"><span class="hljs-number">0xda</span></span>,<span class="hljs-number"><span class="hljs-number">0xb8</span></span>,<span class="hljs-number"><span class="hljs-number">0x78</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0xc8</span></span>,<span class="hljs-number"><span class="hljs-number">0x17</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x8a</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x29</span></span>,<span class="hljs-number"><span class="hljs-number">0x5a</span></span>,<span class="hljs-number"><span class="hljs-number">0x27</span></span>,<span class="hljs-number"><span class="hljs-number">0x47</span></span>,<span class="hljs-number"><span class="hljs-number">0xb4</span></span>,<span class="hljs-number"><span class="hljs-number">0xf1</span></span>, <span class="hljs-number"><span class="hljs-number">0xa0</span></span>,<span class="hljs-number"><span class="hljs-number">0xb3</span></span>,<span class="hljs-number"><span class="hljs-number">0x94</span></span>,<span class="hljs-number"><span class="hljs-number">0x8d</span></span>,<span class="hljs-number"><span class="hljs-number">0xf3</span></span>,<span class="hljs-number"><span class="hljs-number">0x99</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0x44</span></span>, <span class="hljs-number"><span class="hljs-number">0xc0</span></span>,<span class="hljs-number"><span class="hljs-number">0xe1</span></span>,<span class="hljs-number"><span class="hljs-number">0x9f</span></span>,<span class="hljs-number"><span class="hljs-number">0xa6</span></span>,<span class="hljs-number"><span class="hljs-number">0xb2</span></span>,<span class="hljs-number"><span class="hljs-number">0xb9</span></span>,<span class="hljs-number"><span class="hljs-number">0x2b</span></span>,<span class="hljs-number"><span class="hljs-number">0x3a</span></span>, <span class="hljs-number"><span class="hljs-number">0x19</span></span>,<span class="hljs-number"><span class="hljs-number">0xc8</span></span>,<span class="hljs-number"><span class="hljs-number">0xe6</span></span>,<span class="hljs-number"><span class="hljs-number">0xba</span></span>, <span class="hljs-number"><span class="hljs-number">0xdc</span></span>,<span class="hljs-number"><span class="hljs-number">0x14</span></span>,<span class="hljs-number"><span class="hljs-number">0x17</span></span>,<span class="hljs-number"><span class="hljs-number">0x87</span></span>, <span class="hljs-number"><span class="hljs-number">0x35</span></span>,<span class="hljs-number"><span class="hljs-number">0x8b</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>,<span class="hljs-number"><span class="hljs-number">0x53</span></span>, <span class="hljs-number"><span class="hljs-number">0x53</span></span>,<span class="hljs-number"><span class="hljs-number">0x5f</span></span>,<span class="hljs-number"><span class="hljs-number">0x01</span></span>,<span class="hljs-number"><span class="hljs-number">0x19</span></span>, <span class="hljs-number"><span class="hljs-number">0x48</span></span>,<span class="hljs-number"><span class="hljs-number">0x75</span></span>,<span class="hljs-number"><span class="hljs-number">0x08</span></span>,<span class="hljs-number"><span class="hljs-number">0x33</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> test_nonce = <span class="hljs-number"><span class="hljs-number">0x48750833</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> result[<span class="hljs-number"><span class="hljs-number">8</span></span>]; full_btc_hash(header, test_nonce, result); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* presult = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * )result; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; i++) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%02X "</span></span>, presult[i]);</code> </pre><br>  Il s'av√®re: <br><br>  92 98 2A 50 91 FA BD 42 97 8A A5 2D CD C9 36 28 02 4A DD FE E0 67 A4 78 00 00 00 00 00 00 00 00 00 <br><br>  √Ä la fin du hachage, il y a beaucoup de z√©ros, un beau hachage, un bingo, etc. <br><br>  Et maintenant, je peux transmettre non pas des donn√©es uint32_t ordinaires √† cette fonction de hachage, mais ma classe C ++ sp√©ciale, qui red√©finira toute l'arithm√©tique. <br><br>  Oui oui  Je vais appliquer des math√©matiques probabilistes ¬´alternatives¬ª. <br>  Je l'ai invent√© moi-m√™me, je l'ai r√©alis√©, je l'ai v√©cu moi-m√™me.  Cela ne semble pas tr√®s bien fonctionner.  Une plaisanterie.  √áa devrait marcher.  Peut-√™tre que je ne suis pas le premier que j'essaie de lancer. <br><br>  Passons maintenant au plus int√©ressant. <br>  Toute l'arithm√©tique en √©lectronique num√©rique est ex√©cut√©e comme des op√©rations sur des bits, et elle est strictement d√©finie par les op√©rations ET, OU, NON, OU EXCLUSIF.  Eh bien, nous savons tous ce que sont les tables de v√©rit√© en alg√®bre bool√©enne. <br><br>  Je sugg√®re d'ajouter un peu d'incertitude aux calculs, les rendant probabilistes. <br>  Laissez chaque bit du mot avoir non seulement les valeurs ZERO et ONE possibles, mais aussi toutes les valeurs interm√©diaires!  Je propose de consid√©rer la valeur d'un bit comme la probabilit√© d'un √©v√©nement qui peut ou non se produire.  Si toutes les donn√©es initiales sont connues de mani√®re fiable, le r√©sultat est fiable.  Et si certaines donn√©es manquent un peu, le r√©sultat se r√©v√©lera avec une certaine probabilit√©. <br><br>  En fait, supposons qu'il existe deux √©v√©nements ind√©pendants ¬´a¬ª et ¬´b¬ª, dont la probabilit√© d'occurrence est naturellement de z√©ro √† un, respectivement, Pa et Pb.  Quelle est la probabilit√© que des √©v√©nements se produisent simultan√©ment?  Je suis s√ªr que chacun de nous n'h√©sitera pas √† r√©pondre P = Pa * Pb et c'est la bonne r√©ponse! <br><br>  Le graphique 3D d'une telle fonction ressemblera √† ceci (de deux points de vue diff√©rents): <br><br><img src="https://habrastorage.org/webt/-e/ll/pw/-ellpwuzq9bxl8fi_b3l1drhutc.png"><br><br>  Et quelle est la probabilit√© que l'√©v√©nement Pa ou l'√©v√©nement Pb se produise? <br>  Probabilit√© P = Pa + Pb-Pa * Pb.  Le graphe de fonction est comme ceci: <br><br><img src="https://habrastorage.org/webt/vs/sd/wk/vssdwknevb1dijfbqcy3lsnib0w.png"><br><br>  Et si nous connaissons la probabilit√© que l'√©v√©nement Pa se produise, quelle est la probabilit√© que l'√©v√©nement ne se produise pas? <br>  P = 1 - Pa. <br><br>  Faisons maintenant une hypoth√®se.  Imaginez que nous ayons des √©l√©ments logiques qui calculent la probabilit√© d'un √©v√©nement de sortie, connaissant la probabilit√© d'√©v√©nements d'entr√©e: <br><br><img src="https://habrastorage.org/webt/tn/qk/-v/tnqk-v5-dce15dkr0-zsb1wmiww.gif"><br><br>  Avoir de tels √©l√©ments logiques peut facilement les rendre plus complexes, par exemple, exclusifs ou XOR: <br><br><img src="https://habrastorage.org/webt/l0/e8/ju/l0e8judlmw-uh6plwsuj5sjnutq.png"><br><br>  Maintenant, en regardant le diagramme de cet √©l√©ment logique XOR, nous pouvons comprendre quelle sera la probabilit√© de l'√©v√©nement √† la sortie du XOR probabiliste: <br><br><img src="https://habrastorage.org/webt/oj/xy/re/ojxyrexx8xkmcrmoyfohfl6bqyw.png"><br><br>  Mais ce n'est pas tout.  Nous connaissons la logique typique d'un additionneur complet et d√©couvrons comment un additionneur multi-bits est fabriqu√© √† partir d'un additionneur complet: <br><br><img src="https://habrastorage.org/webt/_s/fh/qs/_sfhqsmrhygqasjfv6inengna38.png"><br><br>  Alors maintenant, selon son sch√©ma, nous pouvons maintenant calculer les probabilit√©s de signaux √† sa sortie, avec des probabilit√©s connues de signaux √† l'entr√©e. <br><br>  Ainsi, je peux impl√©menter en c ++ ma propre classe "32 bits" (je l'appellerai x32) avec une arithm√©tique probabiliste, red√©finir toutes les op√©rations n√©cessaires pour sha256 comme AND, OR, XOR, ADD et les d√©calages dans cette classe.  La classe stockera 32 bits √† l'int√©rieur, mais chaque bit est un nombre √† virgule flottante.  Chaque op√©ration logique ou arithm√©tique sur un tel nombre de 32 bits calculera la probabilit√© de la valeur de chaque bit avec des param√®tres d'entr√©e connus ou peu connus d'une op√©ration logique ou arithm√©tique. <br><br>  Prenons un exemple tr√®s simple qui utilise mes math√©matiques probabilistes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> &gt; dbl; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>.precision(dbl::max_digits10); x32 a = <span class="hljs-number"><span class="hljs-number">0xaabbccdd</span></span>; x32 b = <span class="hljs-number"><span class="hljs-number">0x12345678</span></span>; &lt;b&gt;<span class="hljs-comment"><span class="hljs-comment">//b.setBit( 4, 0.75 );&lt;/b&gt; x32 c = a + b; cout &lt;&lt; std::hex &lt;&lt; "result = 0x" &lt;&lt; c.get32() &lt;&lt; "\n" &lt;&lt; std::dec; for (int i = 0; i &lt; 32; i++) cout &lt;&lt; "bit" &lt;&lt; i &lt;&lt; " = " &lt;&lt; c.get_bvi(i) &lt;&lt; "\n"; cout &lt;&lt; "ok\n"; }</span></span></code> </pre><br>  Dans cet exemple, deux nombres 32 bits sont ajout√©s. <br>  Alors que la cha√Æne est b.setBit (4, 0,75);  Le r√©sultat de l'addition est comment√© exactement pr√©visible et pr√©d√©termin√©, car toutes les donn√©es d'entr√©e pour l'addition sont connues.  Le programme imprime ceci sur la console: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">result</span></span> = 0xbcf02355 bit0 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit1 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit2 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit3 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit4 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit5 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit6 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit7 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit8 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit9 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit10 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit11 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit12 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit13 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit14 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit15 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit16 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit17 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit18 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit19 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit20 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit21 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit22 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit23 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit24 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit25 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit26 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit27 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit28 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit29 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit30 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit31 = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Si je d√©commente la ligne b.setBit (4, 0,75); alors en faisant cela, je dis au programme: "ajoutez-moi ces deux nombres, mais je ne connais pas vraiment la valeur du bit 4 du deuxi√®me argument, je pense que c'est un avec une probabilit√© de 0,75". <br><br>  Ensuite, l'addition se produit, comme il se doit, avec un calcul complet des probabilit√©s des signaux de sortie, c'est-√†-dire des bits: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> result = <span class="hljs-number"><span class="hljs-number">0xbcf02305</span></span> bit0 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit1 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit2 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit3 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit4 = <span class="hljs-number"><span class="hljs-number">0.75</span></span> bit5 = <span class="hljs-number"><span class="hljs-number">0.1875</span></span> bit6 = <span class="hljs-number"><span class="hljs-number">0.8125</span></span> bit7 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit8 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit9 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit10 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit11 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit12 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit13 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit14 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit15 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit16 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit17 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit18 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit19 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit20 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit21 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit22 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit23 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit24 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit25 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit26 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit27 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit28 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit29 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit30 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit31 = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  √âtant donn√© que les donn√©es d'entr√©e n'√©taient pas tr√®s connues, le r√©sultat n'est pas tr√®s connu.  De plus, ce qui peut √™tre calcul√© de mani√®re fiable est consid√©r√© comme fiable.  Ce qui ne peut pas √™tre compt√© est consid√©r√© avec probabilit√©. <br><br>  Maintenant que j'ai une merveilleuse classe c ++ 32 bits pour l'arithm√©tique floue, je peux passer des tableaux de variables de type x32 √† la fonction full_btc_hash () dans le mod√®le et obtenir un r√©sultat de hachage estim√© probabiliste. <br><br><div class="spoiler">  <b class="spoiler_title">Certaines des impl√©mentations de classe x32 sont:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;utility&gt; #include &lt;stdint.h&gt; #include &lt;vector&gt; #include &lt;limits&gt; using namespace std; #include &lt;boost/math/constants/constants.hpp&gt; #include &lt;boost/multiprecision/cpp_dec_float.hpp&gt; using boost::multiprecision::cpp_dec_float_50; //typedef double MY_FP; typedef cpp_dec_float_50 MY_FP; class x32 { public: x32(); x32(uint32_t n); void init(MY_FP val); void init(double* pval); void setBit(int i, MY_FP val) { bvi[i] = val; }; ~x32() {}; x32 operator|(const x32&amp; right); x32 operator&amp;(const x32&amp; right); x32 operator^(const x32&amp; right); x32 operator+(const x32&amp; right); x32&amp; x32::operator+=(const x32&amp; right); x32 operator~(); x32 operator&lt;&lt;(const unsigned int&amp; right); x32 operator&gt;&gt;(const unsigned int&amp; right); void print(); uint32_t get32(); MY_FP get_bvi(uint32_t idx) { return bvi[idx]; }; private: MY_FP not(MY_FP a); MY_FP and(MY_FP a, MY_FP b); MY_FP or (MY_FP a, MY_FP b); MY_FP xor(MY_FP a, MY_FP b); MY_FP bvi[32]; //bit values }; #include "stdafx.h" #include "x32.h" x32::x32() { for (int i = 0; i &lt; 32; i++) { bvi[i] = 0.0; } } x32::x32(uint32_t n) { for (int i = 0; i &lt; 32; i++) { bvi[i] = (n&amp;(1 &lt;&lt; i)) ? 1.0 : 0.0; } } void x32::init(MY_FP val) { for (int i = 0; i &lt; 32; i++) { bvi[i] = val; } } void x32::init(double* pval) { for (int i = 0; i &lt; 32; i++) { bvi[i] = pval[i]; } } x32 x32::operator&lt;&lt;(const unsigned int&amp; right) { x32 t; for (int i = 31; i &gt;= 0; i--) { if (i &lt; right) { t.bvi[i] = 0.0; } else { t.bvi[i] = bvi[i - right]; } } return t; } x32 x32::operator&gt;&gt;(const unsigned int&amp; right) { x32 t; for (unsigned int i = 0; i &lt; 32; i++) { if (i &gt;= (32 - right)) { t.bvi[i] = 0; } else { t.bvi[i] = bvi[i + right]; } } return t; } MY_FP x32::not(MY_FP a) { return 1.0 - a; } MY_FP x32::and(MY_FP a, MY_FP b) { return a * b; } MY_FP x32::or(MY_FP a, MY_FP b) { return a + b - a * b; } MY_FP x32::xor (MY_FP a, MY_FP b) { //(~(A &amp; B)) &amp; (A | B) return and( not( and(a,b) ) , or(a,b) ); } x32 x32::operator|(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = or ( bvi[i], right.bvi[i] ); } return t; } x32 x32::operator&amp;(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = and (bvi[i], right.bvi[i]); } return t; } x32 x32::operator~() { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = not(bvi[i]); } return t; } x32 x32::operator^(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = xor (bvi[i], right.bvi[i]); } return t; } x32 x32::operator+(const x32&amp; right) { x32 r; r.bvi[0] = xor (bvi[0], right.bvi[0]); MY_FP cout = and (bvi[0], right.bvi[0]); for (unsigned int i = 1; i &lt; 32; i++) { MY_FP xor_a_b = xor (bvi[i], right.bvi[i]); r.bvi[i] = xor( xor_a_b, cout ); MY_FP and1 = and (bvi[i], right.bvi[i]); MY_FP and2 = and (xor_a_b, cout); cout = or (and1,and2); } return r; } x32&amp; x32::operator+=(const x32&amp; right) { MY_FP cout = and (bvi[0], right.bvi[0]); bvi[0] = xor (bvi[0], right.bvi[0]); for (unsigned int i = 1; i &lt; 32; i++) { MY_FP xor_a_b = xor (bvi[i], right.bvi[i]); MY_FP and1 = and (bvi[i], right.bvi[i]); MY_FP and2 = and (xor_a_b, cout); bvi[i] = xor (xor_a_b, cout); cout = or (and1, and2); } return *this; } void x32::print() { for (int i = 0; i &lt; 32; i++) { cout &lt;&lt; bvi[i] &lt;&lt; "\n"; } } uint32_t x32::get32() { uint32_t r = 0; for (int i = 0; i &lt; 32; i++) { if (bvi[i] == 1.0) r = r | (1 &lt;&lt; i); else if (bvi[i] == 0.0) { //ok } else { //oops.. cout &lt;&lt; "bit not stable\n"; } } return r; }</span></span></span></span></code> </pre><br></div></div><br>  √Ä quoi tout cela sert-il? <br><br>  Le mineur Bitcoin ne sait pas √† l'avance quelle valeur s√©lectionner 32x nonce.  Le mineur est oblig√© d'it√©rer sur les 4 milliards d'entre eux afin de compter le hachage jusqu'√† ce qu'il devienne ¬´beau¬ª, jusqu'√† ce que la valeur du hachage devienne inf√©rieure √† l'objectif. <br><br>  L'arithm√©tique probabiliste floue vous permet th√©oriquement de vous d√©barrasser de la recherche exhaustive. <br><br>  Oui, je ne connais pas initialement la signification de tous les bits nonse requis.  Si je ne les connais pas, qu'il n'y ait pas de merde - la probabilit√© initiale de non-bits est de 0,5.  M√™me dans ce sc√©nario, je peux calculer la probabilit√© de bits de hachage de sortie.  Quelque part quelque chose, ils se r√©v√®lent √©galement environ 0,5 plus ou moins un demi-sou. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, je peux maintenant changer un seul bit nonse de 0,5 √† 0,9 ou √† 0,1 ou √† 1,0 et voir comment la valeur de probabilit√© de la valeur du signal de chaque bit de la fonction de hachage sur la sortie change. Maintenant, j'ai beaucoup plus d'informations sur l'√©valuation. Je peux maintenant sentir chaque bit nonse d'entr√©e individuellement et voir o√π la probabilit√© du signal se d√©cale sur chacun des bits de sortie de la fonction de hachage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, voici un fragment qui consid√®re une fonction de hachage avec des bits nonse compl√®tement inconnus, lorsque la probabilit√© de sa valeur de bit est 0,5 et le deuxi√®me calcul, lorsque nous supposons que la valeur du bit nonce [0] = 0,9:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> &gt; dbl; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>.precision(dbl::max_digits10); <span class="hljs-comment"><span class="hljs-comment">//--------------------------------- //hash: 502A989242BDFA912DA58A972836C9CDFEDD4A0278A467E00000000000000000 const u8 strxx[] = { 0x02,0x00,0x00,0x00, 0x17,0x97,0x5b,0x97,0xc1,0x8e,0xd1,0xf7, 0xe2,0x55,0xad,0xf2,0x97,0x59,0x9b,0x55, 0x33,0x0e,0xda,0xb8,0x78,0x03,0xc8,0x17, 0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x8a,0x97,0x29,0x5a,0x27,0x47,0xb4,0xf1, 0xa0,0xb3,0x94,0x8d,0xf3,0x99,0x03,0x44, 0xc0,0xe1,0x9f,0xa6,0xb2,0xb9,0x2b,0x3a, 0x19,0xc8,0xe6,0xba, 0xdc,0x14,0x17,0x87, 0x35,0x8b,0x05,0x53, 0x53,0x5f,0x01,0x19, 0x48,0x75,0x08,0x33 }; double nonce_bits[32]; for (int i = 0; i &lt; 32; i++) nonce_bits[i] = 0.5; x32 nonce_x32_a; x32 nonce_x32_b; nonce_x32_a.init(nonce_bits); nonce_bits[0] = 0.9; nonce_x32_b.init(nonce_bits); x32 result_x32_a[8]; x32 result_x32_b[8]; full_btc_hash(strxx, nonce_x32_a, result_x32_a); full_btc_hash(strxx, nonce_x32_b, result_x32_b); for (int i = 0; i &lt; 32; i++) cout &lt;&lt; result_x32_a[7].get_bvi(i) &lt;&lt; " " &lt;&lt; result_x32_b[7].get_bvi(i) &lt;&lt; "\n";</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction de classe x32 :: get_bvi () renvoie la probabilit√© de la valeur binaire de ce nombre. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous calculons et voyons que si vous modifiez la valeur du bit nonce [0] de 0,5 √† 0,9, alors certains bits du hachage de sortie se sont √† peine inclin√©s vers le haut et d'autres √† peine inclin√©s:</font></font><br><br><pre> <code class="hljs css">0<span class="hljs-selector-class"><span class="hljs-selector-class">.44525679540883948</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.44525679540840074</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.55268174813167364</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5526817481315932</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57758654725359399</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57758654725360606</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.49595026978928474</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.49595026978930477</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57118578561406703</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57118578561407746</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53237003739057907</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5323700373905661</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57269859374138096</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57269859374138162</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57631236396381141</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5763123639638157</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.47943176373960149</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.47943176373960219</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54955992675177704</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5495599267517755</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53321116270879686</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53321116270879733</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57294025883744952</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57294025883744984</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53131857821387693</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53131857821387655</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57253530821899101</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57253530821899102</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.50661432403287194</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.50661432403287198</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57149419848354913</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57149419848354916</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53220327148366491</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53220327148366487</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57268927270412251</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57268927270412251</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57632130426913003</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57632130426913005</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57233970084776142</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57233970084776143</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56824728628552812</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56824728628552813</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.45247155441889921</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.45247155441889922</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56875940568326509</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56875940568326509</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57524323439326321</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57524323439326321</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57587726902392535</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57587726902392535</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57597043124557292</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57597043124557292</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.52847748894672118</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.52847748894672118</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54512141953055808</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54512141953055808</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57362254577539695</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57362254577539695</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53082194129771177</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53082194129771177</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54404489702929382</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54404489702929382</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54065386336136847</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54065386336136847</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une sorte de souffle, un changement √† peine perceptible dans la probabilit√© d'une sortie √† 10m apr√®s la virgule. </font><font style="vertical-align: inherit;">Eh bien, n√©anmoins ... vous pouvez essayer de construire quelques hypoth√®ses √† ce sujet. </font><font style="vertical-align: inherit;">Cela se passe magnifiquement, non? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par ailleurs, si les bits d'entr√©e du nonse d'entr√©e sont initialis√©s avec les valeurs de probabilit√© n√©cessaires et correctes, comme ceci:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nonce_bits[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; i++) nonce_bits[i] = (real_nonce32&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>; x32 nonce_x32; nonce_x32.init(nonce_bits); full_btc_hash(strxx, nonce_x32, result_x32);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puis en calculant le hachage probabiliste, nous obtenons le r√©sultat logique correct - un ¬´beau¬ª hachage en sortie, bingo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, avec les math√©matiques, tout est l√†. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reste √† apprendre √† analyser le souffle de la brise ... et le hash est cass√©. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela ressemble √† un non-sens, mais c'est un non-sens - et j'ai pr√©venu au tout d√©but. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autres mat√©riaux utiles:</font></font><br><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minim Bitcoin avec papier et stylo.</font></font></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Est-il possible de calculer des bitcoins plus rapidement, plus facilement ou plus facilement?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment ai-je fait un mineur blakecoin</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mineur FPGA Bitcoin sur Mars Rover Board 3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPGA Miner avec algorithme Blake</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420131/">https://habr.com/ru/post/fr420131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420119/index.html">10 frameworks Web Python √† travailler en 2018</a></li>
<li><a href="../fr420121/index.html">Test de r√©sistance: Termite LT450, LXI</a></li>
<li><a href="../fr420123/index.html">Qu'est-ce que Node.js vraiment?</a></li>
<li><a href="../fr420125/index.html">Automatisation de la finance: les employ√©s des banques peuvent se retrouver sans travail en raison de robots</a></li>
<li><a href="../fr420129/index.html">Mod√®les de coroutine Asyncio: l'ext√©rieur attend</a></li>
<li><a href="../fr420133/index.html">Mod√©lisation des syst√®mes dynamiques: comment se d√©place la lune?</a></li>
<li><a href="../fr420135/index.html">C'est aussi Toshiba: des produits inattendus de la soci√©t√© japonaise</a></li>
<li><a href="../fr420139/index.html">Livre ¬´Site Reliability Engineering. Fiabilit√© et fiabilit√© comme dans Google ¬ª</a></li>
<li><a href="../fr420141/index.html">Depuis le SGBD MPP charg√© - Data Lake dynamique avec des outils d'analyse: partagez les d√©tails de la cr√©ation</a></li>
<li><a href="../fr420143/index.html">Performances de Kotlin sur Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>