<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏿 ☝🏿 👨🏾‍🏭 Zeiger in C sind abstrakter als Sie vielleicht denken 🈳 👩🏻‍🚀 ⛔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Zeiger bezieht sich auf eine Speicherzelle, und das Dereferenzieren eines Zeigers bedeutet das Lesen des Werts der angegebenen Zelle. Der Wert des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zeiger in C sind abstrakter als Sie vielleicht denken</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418023/">  Der Zeiger <i>bezieht sich</i> auf eine Speicherzelle, und das <i>Dereferenzieren eines</i> Zeigers bedeutet das Lesen des Werts der angegebenen Zelle.  Der Wert des Zeigers selbst ist die Adresse der Speicherzelle.  Der C-Sprachstandard spezifiziert nicht das Formular zur Darstellung von Speicheradressen.  Dies ist ein sehr wichtiger Punkt, da unterschiedliche Architekturen unterschiedliche Adressierungsmodelle verwenden können.  Die meisten modernen Architekturen verwenden einen linearen Adressraum oder ähnliches.  Selbst diese Frage ist jedoch nicht streng spezifiziert, da Adressen physisch oder virtuell sein können.  Einige Architekturen verwenden überhaupt eine nicht numerische Darstellung.  Symbolics Lisp Machine arbeitet also mit Tupeln der Form <i>(Objekt, Versatz)</i> als Adressen. <br><a name="habracut"></a><table><tbody><tr><td>  Einige Zeit später, nach der Veröffentlichung der Übersetzung über Habré, nahm der Autor große Änderungen am Text des Artikels vor.  Das Aktualisieren einer Übersetzung auf Habré ist keine gute Idee, da einige Kommentare ihre Bedeutung verlieren oder fehl am Platz aussehen.  Ich möchte den Text nicht als neuen Artikel veröffentlichen.  Deshalb haben wir gerade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Übersetzung des Artikels</a> auf viva64.com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktualisiert</a> und hier alles so gelassen, wie es ist.  Wenn Sie ein neuer Leser sind, empfehle ich Ihnen, eine neuere Übersetzung auf unserer Website zu lesen, indem Sie auf den obigen Link klicken. </td></tr></tbody></table><br>  Der Standard schreibt nicht die Form der Darstellung von Zeigern vor, sondern legt mehr oder weniger Operationen mit ihnen fest.  Nachfolgend betrachten wir diese Operationen und die Merkmale ihrer Definition im Standard.  Beginnen wir mit dem folgenden Beispiel: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main(void) { int a, b; int *p = &amp;a; int *q = &amp;b + 1; printf("%p %p %d\n", (void *)p, (void *)q, p == q); return 0; }</span></span></span></span></code> </pre> <br>  Wenn wir diesen GCC-Code mit Optimierungsstufe 1 kompilieren und das Programm unter Linux x86-64 ausführen, wird Folgendes gedruckt: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Beachten Sie, dass sich die Zeiger <i>p</i> und <i>q</i> auf dieselbe Adresse beziehen.  Das Ergebnis des Ausdrucks <i>p == q</i> ist jedoch <i>falsch</i> , und dies erscheint auf den ersten Blick seltsam.  Sollten nicht zwei Zeiger auf dieselbe Adresse gleich sein? <br><br>  So definiert der C-Standard das Ergebnis der Überprüfung von zwei Zeigern auf Gleichheit: <br><table><tbody><tr><td>  <b>C11 § 6.5.9 Absatz 6</b> <br><br>  Zwei Zeiger sind genau dann gleich, wenn beide Null sind. Entweder zeigen sie auf dasselbe Objekt (einschließlich eines Zeigers auf das Objekt und das erste Unterobjekt in der Struktur des Objekts) oder auf eine Funktion oder geben die Position nach dem letzten Element des Arrays oder einen Zeiger an bezieht sich auf die Position nach dem letzten Element des Arrays, und das andere bezieht sich auf den Beginn eines anderen Arrays unmittelbar nach dem ersten im selben Adressraum. </td></tr></tbody></table><br>  Zunächst stellt sich die Frage: Was ist ein „Objekt <i>“</i> ?  Da es sich um die C-Sprache handelt, ist es offensichtlich, dass Objekte hier nichts mit Objekten in OOP-Sprachen wie C ++ zu tun haben.  Im C-Standard ist dieses Konzept nicht vollständig definiert: <br><table><tbody><tr><td>  <b>C11 § 3.15</b> <br><br>  Ein Objekt ist ein Laufzeitspeicherbereich, dessen Inhalt zur Darstellung von Werten verwendet werden kann <br><br>  HINWEIS Wenn erwähnt, kann davon ausgegangen werden, dass ein Objekt einen bestimmten Typ hat.  siehe 6.3.2.1. </td></tr></tbody></table><br>  Lass es uns richtig machen.  Eine 16-Bit-Ganzzahlvariable ist ein Datensatz im Speicher, der 16-Bit-Ganzzahlwerte darstellen kann.  Daher ist eine solche Variable ein Objekt.  Sind zwei Zeiger gleich, wenn sich einer auf das erste Byte einer bestimmten Ganzzahl und der zweite auf das zweite Byte derselben Zahl bezieht?  Das Sprachstandardisierungskomitee meinte das natürlich überhaupt nicht.  Aber hier sollte angemerkt werden, dass er in dieser Hinsicht keine klaren Erklärungen hat und wir gezwungen sind zu erraten, was wirklich gemeint war. <br><br><h3>  Wenn der Compiler im Weg ist </h3><br>  Kehren wir zu unserem ersten Beispiel zurück.  Der Zeiger <i>p wird</i> von Objekt <i>a erhalten</i> , und der Zeiger <i>q</i> wird von Objekt <i>b erhalten</i> .  Im zweiten Fall wird die Adressarithmetik verwendet, die für die Plus- und Minusoperatoren wie folgt definiert ist: <br><table><tbody><tr><td>  <b>C11 § 6.5.6 Ziffer 7</b> <br><br>  Bei Verwendung mit diesen Operatoren verhält sich ein Zeiger auf ein Objekt, das kein Element des Arrays ist, wie ein Zeiger auf den Anfang eines Arrays mit einer Länge von einem Element, dessen Typ dem Typ des ursprünglichen Objekts entspricht. </td></tr></tbody></table><br>  Da jeder Zeiger auf ein Objekt, das kein Array ist, <i>tatsächlich</i> ein Zeiger auf ein Array mit einer Länge von einem Element wird, definiert der Standard die Adressarithmetik nur für Zeiger auf Arrays - dies ist Punkt 8. Der folgende Teil interessiert uns: <br><table><tbody><tr><td>  <b>C11 § 6.5.6 Ziffer 8</b> <br><br>  Wenn dem Zeiger ein ganzzahliger Ausdruck hinzugefügt oder von diesem subtrahiert wird, ist der resultierende Zeiger vom gleichen Typ wie der ursprüngliche Zeiger.  Wenn sich der Quellzeiger auf ein Array-Element bezieht und das Array eine ausreichende Länge hat, werden die Quelle und die resultierenden Elemente voneinander getrennt, sodass die Differenz zwischen ihren Indizes gleich dem Wert des ganzzahligen Ausdrucks ist.  Mit anderen Worten, wenn der Ausdruck <i>P</i> auf das i-te Element des Arrays zeigt, geben die Ausdrücke <i>(P) + N</i> (oder sein Äquivalent <i>N + (P)</i> ) und <i>(P) -N</i> (wobei <i>N</i> den Wert n hat) jeweils (i + n) an. th und (i - n) th Elemente des Arrays, sofern sie existieren.  Wenn der Ausdruck <i>P</i> auf das letzte Element des Arrays zeigt, gibt der Ausdruck <i>(P) +1</i> die Position nach dem letzten Element des Arrays an, und wenn der Ausdruck <i>Q</i> die Position nach dem letzten Element des Arrays angibt, gibt der Ausdruck <i>(Q) -1</i> das letzte Element an Array.  Wenn sich sowohl die Quelle als auch die resultierenden Zeiger auf Elemente desselben Arrays oder auf die Position nach dem letzten Element des Arrays beziehen, wird ein Überlauf ausgeschlossen.  Andernfalls ist das Verhalten undefiniert.  Wenn sich der resultierende Zeiger auf die Position nach dem letzten Element des Arrays bezieht, kann der unäre <i>*</i> -Operator nicht darauf angewendet werden. </td></tr></tbody></table><br>  Daraus folgt, dass das Ergebnis des Ausdrucks <i>&amp; b + 1</i> definitiv eine Adresse sein sollte und daher <i>p</i> und <i>q</i> gültige Zeiger sind.  Ich möchte Sie daran erinnern, wie die Gleichheit zweier Zeiger im Standard definiert ist: " <i>Zwei Zeiger sind genau dann gleich, wenn [...] ein Zeiger auf die Position nach dem letzten Element des Arrays und der andere auf den Anfang eines anderen Arrays unmittelbar nach dem ersten im selben verweist Adressraum "</i> (C11 § 6.5.9 Ziffer 6).  Genau das beobachten wir in unserem Beispiel.  Der Zeiger q bezieht sich auf die Position nach dem Objekt b, unmittelbar gefolgt von dem Objekt a, auf das sich der Zeiger p bezieht.  Gibt es einen Fehler in GCC?  Dieser Widerspruch wurde 2014 als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler Nr. 61502 beschrieben</a> , aber GCC-Entwickler betrachten ihn nicht als Fehler und werden ihn daher nicht beheben. <br><br>  Ein ähnliches Problem wurde 2016 von Linux-Programmierern festgestellt.  Betrachten Sie den folgenden Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _end[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = _start; i != _end; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br>  Die Symbole <i>_start</i> und <i>_end</i> geben die Grenzen des Speicherbereichs an.  Da sie in eine externe Datei übertragen werden, weiß der Compiler nicht, wie sich die Arrays tatsächlich im Speicher befinden.  Aus diesem Grund sollte er hier vorsichtig sein und davon ausgehen, dass sie im Adressraum aufeinander folgen.  GCC kompiliert jedoch die Schleifenbedingung so, dass sie immer wahr ist, wodurch die Schleife unendlich wird.  Dieses Problem wird hier in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag zu LKML beschrieben</a> - dort wird ein ähnliches Codefragment verwendet.  In diesem Fall haben die Autoren von GCC die Kommentare dennoch berücksichtigt und das Verhalten des Compilers geändert.  Zumindest konnte ich diesen Fehler in GCC Version 7.3.1 unter Linux x86_64 nicht reproduzieren. <br><br><h3>  Lösung - im Fehlerbericht # 260? </h3><br>  Unser Fall kann den Fehlerbericht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 260</a> klarstellen.  Es geht mehr um unsichere Werte, aber Sie können einen merkwürdigen Kommentar des Komitees darin finden: <br><br>  <i>Compiler-Implementierungen [...] können auch Zeiger unterscheiden, die von verschiedenen Objekten erhalten wurden, selbst wenn diese Zeiger den gleichen Satz von Bits haben.</i> <br><br>  Wenn wir diesen Kommentar wörtlich nehmen, ist es logisch, dass das Ergebnis des Ausdrucks <i>p == q</i> "falsch" ist, da <i>p</i> und <i>q</i> von verschiedenen Objekten erhalten werden, die in keiner Weise verbunden sind.  Es scheint, dass wir der Wahrheit näher kommen - oder nicht?  Bisher haben wir uns mit Gleichheitsoperatoren befasst, aber was ist mit Beziehungsoperatoren? <br><br><h3>  Der letzte Hinweis ist in Relation Operatoren? </h3><br>  Die Definition der Beziehungsoperatoren <i>&lt;</i> , <i>&lt;=</i> , <i>&gt;</i> und <i>&gt; =</i> im Kontext von Zeigervergleichen enthält einen merkwürdigen Gedanken: <br><table><tbody><tr><td>  <b>C11 § 6.5.8 Absatz 5</b> <br><br>  Das Ergebnis des Vergleichs zweier Zeiger hängt von der relativen Position der angegebenen Objekte im Adressraum ab.  Wenn sich zwei Zeiger auf Objekttypen auf dasselbe Objekt beziehen oder beide auf die Position nach dem letzten Element desselben Arrays verweisen, sind diese Zeiger gleich.  Wenn die angegebenen Objekte Mitglieder desselben zusammengesetzten Objekts sind, sind Zeiger auf Mitglieder der später deklarierten Struktur mehr als Zeiger auf zuvor deklarierte Mitglieder, und Zeiger auf Elemente eines Arrays mit höheren Indizes sind mehr als Zeiger auf Elemente desselben Arrays mit niedrigeren Indizes.  Alle Zeiger auf Mitglieder derselben Vereinigung sind gleich.  Wenn der Ausdruck <i>P</i> auf ein Element des Arrays zeigt und der Ausdruck <i>Q</i> auf das letzte Element desselben Arrays zeigt, ist der Wert des Zeigerausdrucks <i>Q + 1</i> größer als der Wert des Ausdrucks <i>P.</i>  In allen anderen Fällen ist das Verhalten nicht definiert. </td></tr></tbody></table><br>  Gemäß dieser Definition wird das Ergebnis des Vergleichens von Zeigern nur bestimmt, wenn die Zeiger von <i>demselben</i> Objekt erhalten werden.  Wir zeigen dies anhand von zwei Beispielen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) <span class="hljs-comment"><span class="hljs-comment">//   foo();</span></span></code> </pre> <br>  Hier beziehen sich die Zeiger <i>p</i> und <i>q</i> auf zwei verschiedene Objekte, die nicht miteinander verbunden sind.  Daher ist das Ergebnis ihres Vergleichs nicht definiert.  Aber im folgenden Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = p + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) foo();</code> </pre> <br>  Die Zeiger <i>p</i> und <i>q</i> beziehen sich auf dasselbe Objekt und sind daher miteinander verbunden.  Sie können also verglichen werden - es sei denn, <i>malloc</i> gibt einen Nullwert zurück. <br><br><h3>  Zusammenfassung </h3><br>  Der C11-Standard beschreibt Zeigervergleiche nicht angemessen.  Der problematischste Punkt, auf den wir gestoßen sind, war Absatz 6 § 6.5.9, wo es ausdrücklich erlaubt ist, zwei Zeiger zu vergleichen, die auf zwei verschiedene Arrays verweisen.  Dies widerspricht dem Kommentar aus dem Fehlerbericht Nr. 260.  Dort sprechen wir jedoch über unbestimmte Bedeutungen, und ich möchte meine Argumentation nicht allein auf der Grundlage dieses Kommentars aufbauen und in einem anderen Kontext interpretieren.  Beim Vergleichen von Zeigern werden Beziehungsoperatoren geringfügig anders definiert als Gleichheitsoperatoren - Beziehungsoperatoren werden nur definiert, wenn beide Zeiger von <i>demselben</i> Objekt erhalten werden. <br><br>  Wenn wir den Text des Standards ignorieren und fragen, ob es möglich ist, zwei Zeiger zu vergleichen, die von zwei verschiedenen Objekten erhalten wurden, lautet die Antwort auf jeden Fall höchstwahrscheinlich "Nein".  Das Beispiel am Anfang des Artikels zeigt ein theoretisches Problem.  Da die Variablen <i>a</i> und <i>b</i> eine automatische Speicherdauer haben, sind unsere Annahmen über ihre Speicherung im Speicher unzuverlässig.  In einigen Fällen können wir raten, aber es ist offensichtlich, dass ein solcher Code nicht sicher portiert werden kann, und Sie können die Bedeutung des Programms nur durch Kompilieren und Ausführen oder Zerlegen des Codes herausfinden, was jedem ernsthaften Programmierparadigma widerspricht. <br><br>  Im Allgemeinen bin ich jedoch mit dem Wortlaut der C11-Norm nicht zufrieden, und da bereits mehrere Personen auf dieses Problem gestoßen sind, bleibt die Frage: Warum nicht die Regeln klarer formulieren? <br><br><h3>  Ergänzung <br>  Zeiger auf die Position nach dem letzten Element des Arrays </h3><br>  In Bezug auf die Regel zum Vergleichen und Adressieren der Arithmetik von Zeigern auf die Position nach dem letzten Element des Arrays finden Sie häufig Ausnahmen.  Angenommen, der Standard erlaubt nicht den Vergleich von zwei Zeigern, die von <i>demselben</i> Array erhalten wurden, obwohl sich mindestens einer von ihnen auf die Position hinter dem Ende des Arrays bezieht.  Dann würde der folgende Code nicht funktionieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt; &amp;x[num]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Unter Verwendung einer Schleife gehen wir um das gesamte <i>x-</i> Array herum, das aus 64 Elementen besteht, d.h.  Der Schleifenkörper sollte genau 64 Mal ausgeführt werden.  Tatsächlich wird die Bedingung jedoch 65 Mal überprüft - einmal mehr als die Anzahl der Elemente im Array.  In den ersten 64 Iterationen bezieht sich der Zeiger <i>i</i> immer auf das Innere des Arrays <i>x</i> , während der Ausdruck <i>&amp; x [num]</i> immer die Position nach dem letzten Element des Arrays angibt.  Bei der 65. Iteration bezieht sich der Zeiger <i>i</i> auch auf die Position hinter dem Ende des Arrays <i>x</i> , wodurch die Schleifenbedingung falsch wird.  Dies ist eine bequeme Möglichkeit, das gesamte Array zu umgehen, und beruht auf einer Ausnahme von der Regel der Unsicherheit des Verhaltens beim Vergleich solcher Zeiger.  Beachten Sie, dass der Standard nur das Verhalten beim Vergleichen von Zeigern beschreibt.  Dereferenzierung ist ein separates Thema. <br><br>  Ist es möglich, unser Beispiel so zu ändern, dass sich kein einziger Zeiger auf die Position nach dem letzten Element des Arrays <i>x</i> bezieht?  Es ist möglich, aber es wird schwieriger.  Wir müssen die Schleifenbedingung ändern und das Inkrementieren der Variablen <i>i</i> bei der letzten Iteration verhindern. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt;= &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Dieser Code steckt voller technischer Feinheiten, mit denen sich die Hauptaufgabe ablenkt.  Zusätzlich erschien ein zusätzlicher Zweig im Körper der Schleife.  Daher finde ich es vernünftig, dass der Standard Ausnahmen beim Vergleichen von Positionszeigern nach dem letzten Element eines Arrays zulässt. <br><br>  <b><i>PVS-Studio Team Hinweis</i></b> <br><br>  <i>Bei der Entwicklung des PVS-Studio-Code-Analysators müssen wir uns manchmal mit subtilen Problemen befassen, um die Diagnose genauer zu gestalten oder unseren Kunden detaillierte Konsultationen zu geben.</i>  <i>Dieser Artikel erschien uns interessant, da er Themen berührt, bei denen wir uns nicht ganz sicher fühlen.</i>  <i>Deshalb haben wir die Autorin gebeten, ihre Übersetzung zu veröffentlichen.</i>  <i>Wir hoffen, dass mehr C- und C ++ - Programmierer sie kennenlernen und verstehen, dass dies nicht so einfach ist und dass Sie sich nicht beeilen sollten, wenn der Analysator plötzlich eine seltsame Meldung anzeigt, diese als falsch positiv zu betrachten :).</i> <br><br>  <i>Der Artikel wurde erstmals in englischer Sprache bei stefansf.de veröffentlicht.</i>  <i>Übersetzungen werden mit Genehmigung des Autors veröffentlicht.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418023/">https://habr.com/ru/post/de418023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418009/index.html">Node.js und Server-Rendering in Airbnb</a></li>
<li><a href="../de418011/index.html">Einzelseiten und SEO. Optimierungsgeheimnisse</a></li>
<li><a href="../de418013/index.html">Der Intel Core i7-8086K (Teil 3)</a></li>
<li><a href="../de418015/index.html">Neuer Vasyuki. Innovative Entwicklung Moskaus bis 2100</a></li>
<li><a href="../de418017/index.html">Analyse des Verhaltens des Pegasus-Trojaners im Netzwerk</a></li>
<li><a href="../de418025/index.html">Das Buch „Java EE lernen. Moderne Programmierung für große Unternehmen “</a></li>
<li><a href="../de418027/index.html">Microservice Blitz</a></li>
<li><a href="../de418029/index.html">ReactOS 0.4.9: Hasser müssen nach neuen Argumenten suchen</a></li>
<li><a href="../de418031/index.html">Massenstapelung von ML-Modellen in der Produktion: echt oder nicht?</a></li>
<li><a href="../de418035/index.html">Einführung in Timeline bei Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>