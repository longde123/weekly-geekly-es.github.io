<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ–ğŸ¿ â˜ğŸ¿ ğŸ‘¨ğŸ¾â€ğŸ­ Zeiger in C sind abstrakter als Sie vielleicht denken ğŸˆ³ ğŸ‘©ğŸ»â€ğŸš€ â›”ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Zeiger bezieht sich auf eine Speicherzelle, und das Dereferenzieren eines Zeigers bedeutet das Lesen des Werts der angegebenen Zelle. Der Wert des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zeiger in C sind abstrakter als Sie vielleicht denken</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418023/">  Der Zeiger <i>bezieht sich</i> auf eine Speicherzelle, und das <i>Dereferenzieren eines</i> Zeigers bedeutet das Lesen des Werts der angegebenen Zelle.  Der Wert des Zeigers selbst ist die Adresse der Speicherzelle.  Der C-Sprachstandard spezifiziert nicht das Formular zur Darstellung von Speicheradressen.  Dies ist ein sehr wichtiger Punkt, da unterschiedliche Architekturen unterschiedliche Adressierungsmodelle verwenden kÃ¶nnen.  Die meisten modernen Architekturen verwenden einen linearen Adressraum oder Ã¤hnliches.  Selbst diese Frage ist jedoch nicht streng spezifiziert, da Adressen physisch oder virtuell sein kÃ¶nnen.  Einige Architekturen verwenden Ã¼berhaupt eine nicht numerische Darstellung.  Symbolics Lisp Machine arbeitet also mit Tupeln der Form <i>(Objekt, Versatz)</i> als Adressen. <br><a name="habracut"></a><table><tbody><tr><td>  Einige Zeit spÃ¤ter, nach der VerÃ¶ffentlichung der Ãœbersetzung Ã¼ber HabrÃ©, nahm der Autor groÃŸe Ã„nderungen am Text des Artikels vor.  Das Aktualisieren einer Ãœbersetzung auf HabrÃ© ist keine gute Idee, da einige Kommentare ihre Bedeutung verlieren oder fehl am Platz aussehen.  Ich mÃ¶chte den Text nicht als neuen Artikel verÃ¶ffentlichen.  Deshalb haben wir gerade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Ãœbersetzung des Artikels</a> auf viva64.com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktualisiert</a> und hier alles so gelassen, wie es ist.  Wenn Sie ein neuer Leser sind, empfehle ich Ihnen, eine neuere Ãœbersetzung auf unserer Website zu lesen, indem Sie auf den obigen Link klicken. </td></tr></tbody></table><br>  Der Standard schreibt nicht die Form der Darstellung von Zeigern vor, sondern legt mehr oder weniger Operationen mit ihnen fest.  Nachfolgend betrachten wir diese Operationen und die Merkmale ihrer Definition im Standard.  Beginnen wir mit dem folgenden Beispiel: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main(void) { int a, b; int *p = &amp;a; int *q = &amp;b + 1; printf("%p %p %d\n", (void *)p, (void *)q, p == q); return 0; }</span></span></span></span></code> </pre> <br>  Wenn wir diesen GCC-Code mit Optimierungsstufe 1 kompilieren und das Programm unter Linux x86-64 ausfÃ¼hren, wird Folgendes gedruckt: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Beachten Sie, dass sich die Zeiger <i>p</i> und <i>q</i> auf dieselbe Adresse beziehen.  Das Ergebnis des Ausdrucks <i>p == q</i> ist jedoch <i>falsch</i> , und dies erscheint auf den ersten Blick seltsam.  Sollten nicht zwei Zeiger auf dieselbe Adresse gleich sein? <br><br>  So definiert der C-Standard das Ergebnis der ÃœberprÃ¼fung von zwei Zeigern auf Gleichheit: <br><table><tbody><tr><td>  <b>C11 Â§ 6.5.9 Absatz 6</b> <br><br>  Zwei Zeiger sind genau dann gleich, wenn beide Null sind. Entweder zeigen sie auf dasselbe Objekt (einschlieÃŸlich eines Zeigers auf das Objekt und das erste Unterobjekt in der Struktur des Objekts) oder auf eine Funktion oder geben die Position nach dem letzten Element des Arrays oder einen Zeiger an bezieht sich auf die Position nach dem letzten Element des Arrays, und das andere bezieht sich auf den Beginn eines anderen Arrays unmittelbar nach dem ersten im selben Adressraum. </td></tr></tbody></table><br>  ZunÃ¤chst stellt sich die Frage: Was ist ein â€Objekt <i>â€œ</i> ?  Da es sich um die C-Sprache handelt, ist es offensichtlich, dass Objekte hier nichts mit Objekten in OOP-Sprachen wie C ++ zu tun haben.  Im C-Standard ist dieses Konzept nicht vollstÃ¤ndig definiert: <br><table><tbody><tr><td>  <b>C11 Â§ 3.15</b> <br><br>  Ein Objekt ist ein Laufzeitspeicherbereich, dessen Inhalt zur Darstellung von Werten verwendet werden kann <br><br>  HINWEIS Wenn erwÃ¤hnt, kann davon ausgegangen werden, dass ein Objekt einen bestimmten Typ hat.  siehe 6.3.2.1. </td></tr></tbody></table><br>  Lass es uns richtig machen.  Eine 16-Bit-Ganzzahlvariable ist ein Datensatz im Speicher, der 16-Bit-Ganzzahlwerte darstellen kann.  Daher ist eine solche Variable ein Objekt.  Sind zwei Zeiger gleich, wenn sich einer auf das erste Byte einer bestimmten Ganzzahl und der zweite auf das zweite Byte derselben Zahl bezieht?  Das Sprachstandardisierungskomitee meinte das natÃ¼rlich Ã¼berhaupt nicht.  Aber hier sollte angemerkt werden, dass er in dieser Hinsicht keine klaren ErklÃ¤rungen hat und wir gezwungen sind zu erraten, was wirklich gemeint war. <br><br><h3>  Wenn der Compiler im Weg ist </h3><br>  Kehren wir zu unserem ersten Beispiel zurÃ¼ck.  Der Zeiger <i>p wird</i> von Objekt <i>a erhalten</i> , und der Zeiger <i>q</i> wird von Objekt <i>b erhalten</i> .  Im zweiten Fall wird die Adressarithmetik verwendet, die fÃ¼r die Plus- und Minusoperatoren wie folgt definiert ist: <br><table><tbody><tr><td>  <b>C11 Â§ 6.5.6 Ziffer 7</b> <br><br>  Bei Verwendung mit diesen Operatoren verhÃ¤lt sich ein Zeiger auf ein Objekt, das kein Element des Arrays ist, wie ein Zeiger auf den Anfang eines Arrays mit einer LÃ¤nge von einem Element, dessen Typ dem Typ des ursprÃ¼nglichen Objekts entspricht. </td></tr></tbody></table><br>  Da jeder Zeiger auf ein Objekt, das kein Array ist, <i>tatsÃ¤chlich</i> ein Zeiger auf ein Array mit einer LÃ¤nge von einem Element wird, definiert der Standard die Adressarithmetik nur fÃ¼r Zeiger auf Arrays - dies ist Punkt 8. Der folgende Teil interessiert uns: <br><table><tbody><tr><td>  <b>C11 Â§ 6.5.6 Ziffer 8</b> <br><br>  Wenn dem Zeiger ein ganzzahliger Ausdruck hinzugefÃ¼gt oder von diesem subtrahiert wird, ist der resultierende Zeiger vom gleichen Typ wie der ursprÃ¼ngliche Zeiger.  Wenn sich der Quellzeiger auf ein Array-Element bezieht und das Array eine ausreichende LÃ¤nge hat, werden die Quelle und die resultierenden Elemente voneinander getrennt, sodass die Differenz zwischen ihren Indizes gleich dem Wert des ganzzahligen Ausdrucks ist.  Mit anderen Worten, wenn der Ausdruck <i>P</i> auf das i-te Element des Arrays zeigt, geben die AusdrÃ¼cke <i>(P) + N</i> (oder sein Ã„quivalent <i>N + (P)</i> ) und <i>(P) -N</i> (wobei <i>N</i> den Wert n hat) jeweils (i + n) an. th und (i - n) th Elemente des Arrays, sofern sie existieren.  Wenn der Ausdruck <i>P</i> auf das letzte Element des Arrays zeigt, gibt der Ausdruck <i>(P) +1</i> die Position nach dem letzten Element des Arrays an, und wenn der Ausdruck <i>Q</i> die Position nach dem letzten Element des Arrays angibt, gibt der Ausdruck <i>(Q) -1</i> das letzte Element an Array.  Wenn sich sowohl die Quelle als auch die resultierenden Zeiger auf Elemente desselben Arrays oder auf die Position nach dem letzten Element des Arrays beziehen, wird ein Ãœberlauf ausgeschlossen.  Andernfalls ist das Verhalten undefiniert.  Wenn sich der resultierende Zeiger auf die Position nach dem letzten Element des Arrays bezieht, kann der unÃ¤re <i>*</i> -Operator nicht darauf angewendet werden. </td></tr></tbody></table><br>  Daraus folgt, dass das Ergebnis des Ausdrucks <i>&amp; b + 1</i> definitiv eine Adresse sein sollte und daher <i>p</i> und <i>q</i> gÃ¼ltige Zeiger sind.  Ich mÃ¶chte Sie daran erinnern, wie die Gleichheit zweier Zeiger im Standard definiert ist: " <i>Zwei Zeiger sind genau dann gleich, wenn [...] ein Zeiger auf die Position nach dem letzten Element des Arrays und der andere auf den Anfang eines anderen Arrays unmittelbar nach dem ersten im selben verweist Adressraum "</i> (C11 Â§ 6.5.9 Ziffer 6).  Genau das beobachten wir in unserem Beispiel.  Der Zeiger q bezieht sich auf die Position nach dem Objekt b, unmittelbar gefolgt von dem Objekt a, auf das sich der Zeiger p bezieht.  Gibt es einen Fehler in GCC?  Dieser Widerspruch wurde 2014 als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler Nr. 61502 beschrieben</a> , aber GCC-Entwickler betrachten ihn nicht als Fehler und werden ihn daher nicht beheben. <br><br>  Ein Ã¤hnliches Problem wurde 2016 von Linux-Programmierern festgestellt.  Betrachten Sie den folgenden Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _end[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = _start; i != _end; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br>  Die Symbole <i>_start</i> und <i>_end</i> geben die Grenzen des Speicherbereichs an.  Da sie in eine externe Datei Ã¼bertragen werden, weiÃŸ der Compiler nicht, wie sich die Arrays tatsÃ¤chlich im Speicher befinden.  Aus diesem Grund sollte er hier vorsichtig sein und davon ausgehen, dass sie im Adressraum aufeinander folgen.  GCC kompiliert jedoch die Schleifenbedingung so, dass sie immer wahr ist, wodurch die Schleife unendlich wird.  Dieses Problem wird hier in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag zu LKML beschrieben</a> - dort wird ein Ã¤hnliches Codefragment verwendet.  In diesem Fall haben die Autoren von GCC die Kommentare dennoch berÃ¼cksichtigt und das Verhalten des Compilers geÃ¤ndert.  Zumindest konnte ich diesen Fehler in GCC Version 7.3.1 unter Linux x86_64 nicht reproduzieren. <br><br><h3>  LÃ¶sung - im Fehlerbericht # 260? </h3><br>  Unser Fall kann den Fehlerbericht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 260</a> klarstellen.  Es geht mehr um unsichere Werte, aber Sie kÃ¶nnen einen merkwÃ¼rdigen Kommentar des Komitees darin finden: <br><br>  <i>Compiler-Implementierungen [...] kÃ¶nnen auch Zeiger unterscheiden, die von verschiedenen Objekten erhalten wurden, selbst wenn diese Zeiger den gleichen Satz von Bits haben.</i> <br><br>  Wenn wir diesen Kommentar wÃ¶rtlich nehmen, ist es logisch, dass das Ergebnis des Ausdrucks <i>p == q</i> "falsch" ist, da <i>p</i> und <i>q</i> von verschiedenen Objekten erhalten werden, die in keiner Weise verbunden sind.  Es scheint, dass wir der Wahrheit nÃ¤her kommen - oder nicht?  Bisher haben wir uns mit Gleichheitsoperatoren befasst, aber was ist mit Beziehungsoperatoren? <br><br><h3>  Der letzte Hinweis ist in Relation Operatoren? </h3><br>  Die Definition der Beziehungsoperatoren <i>&lt;</i> , <i>&lt;=</i> , <i>&gt;</i> und <i>&gt; =</i> im Kontext von Zeigervergleichen enthÃ¤lt einen merkwÃ¼rdigen Gedanken: <br><table><tbody><tr><td>  <b>C11 Â§ 6.5.8 Absatz 5</b> <br><br>  Das Ergebnis des Vergleichs zweier Zeiger hÃ¤ngt von der relativen Position der angegebenen Objekte im Adressraum ab.  Wenn sich zwei Zeiger auf Objekttypen auf dasselbe Objekt beziehen oder beide auf die Position nach dem letzten Element desselben Arrays verweisen, sind diese Zeiger gleich.  Wenn die angegebenen Objekte Mitglieder desselben zusammengesetzten Objekts sind, sind Zeiger auf Mitglieder der spÃ¤ter deklarierten Struktur mehr als Zeiger auf zuvor deklarierte Mitglieder, und Zeiger auf Elemente eines Arrays mit hÃ¶heren Indizes sind mehr als Zeiger auf Elemente desselben Arrays mit niedrigeren Indizes.  Alle Zeiger auf Mitglieder derselben Vereinigung sind gleich.  Wenn der Ausdruck <i>P</i> auf ein Element des Arrays zeigt und der Ausdruck <i>Q</i> auf das letzte Element desselben Arrays zeigt, ist der Wert des Zeigerausdrucks <i>Q + 1</i> grÃ¶ÃŸer als der Wert des Ausdrucks <i>P.</i>  In allen anderen FÃ¤llen ist das Verhalten nicht definiert. </td></tr></tbody></table><br>  GemÃ¤ÃŸ dieser Definition wird das Ergebnis des Vergleichens von Zeigern nur bestimmt, wenn die Zeiger von <i>demselben</i> Objekt erhalten werden.  Wir zeigen dies anhand von zwei Beispielen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) <span class="hljs-comment"><span class="hljs-comment">//   foo();</span></span></code> </pre> <br>  Hier beziehen sich die Zeiger <i>p</i> und <i>q</i> auf zwei verschiedene Objekte, die nicht miteinander verbunden sind.  Daher ist das Ergebnis ihres Vergleichs nicht definiert.  Aber im folgenden Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = p + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) foo();</code> </pre> <br>  Die Zeiger <i>p</i> und <i>q</i> beziehen sich auf dasselbe Objekt und sind daher miteinander verbunden.  Sie kÃ¶nnen also verglichen werden - es sei denn, <i>malloc</i> gibt einen Nullwert zurÃ¼ck. <br><br><h3>  Zusammenfassung </h3><br>  Der C11-Standard beschreibt Zeigervergleiche nicht angemessen.  Der problematischste Punkt, auf den wir gestoÃŸen sind, war Absatz 6 Â§ 6.5.9, wo es ausdrÃ¼cklich erlaubt ist, zwei Zeiger zu vergleichen, die auf zwei verschiedene Arrays verweisen.  Dies widerspricht dem Kommentar aus dem Fehlerbericht Nr. 260.  Dort sprechen wir jedoch Ã¼ber unbestimmte Bedeutungen, und ich mÃ¶chte meine Argumentation nicht allein auf der Grundlage dieses Kommentars aufbauen und in einem anderen Kontext interpretieren.  Beim Vergleichen von Zeigern werden Beziehungsoperatoren geringfÃ¼gig anders definiert als Gleichheitsoperatoren - Beziehungsoperatoren werden nur definiert, wenn beide Zeiger von <i>demselben</i> Objekt erhalten werden. <br><br>  Wenn wir den Text des Standards ignorieren und fragen, ob es mÃ¶glich ist, zwei Zeiger zu vergleichen, die von zwei verschiedenen Objekten erhalten wurden, lautet die Antwort auf jeden Fall hÃ¶chstwahrscheinlich "Nein".  Das Beispiel am Anfang des Artikels zeigt ein theoretisches Problem.  Da die Variablen <i>a</i> und <i>b</i> eine automatische Speicherdauer haben, sind unsere Annahmen Ã¼ber ihre Speicherung im Speicher unzuverlÃ¤ssig.  In einigen FÃ¤llen kÃ¶nnen wir raten, aber es ist offensichtlich, dass ein solcher Code nicht sicher portiert werden kann, und Sie kÃ¶nnen die Bedeutung des Programms nur durch Kompilieren und AusfÃ¼hren oder Zerlegen des Codes herausfinden, was jedem ernsthaften Programmierparadigma widerspricht. <br><br>  Im Allgemeinen bin ich jedoch mit dem Wortlaut der C11-Norm nicht zufrieden, und da bereits mehrere Personen auf dieses Problem gestoÃŸen sind, bleibt die Frage: Warum nicht die Regeln klarer formulieren? <br><br><h3>  ErgÃ¤nzung <br>  Zeiger auf die Position nach dem letzten Element des Arrays </h3><br>  In Bezug auf die Regel zum Vergleichen und Adressieren der Arithmetik von Zeigern auf die Position nach dem letzten Element des Arrays finden Sie hÃ¤ufig Ausnahmen.  Angenommen, der Standard erlaubt nicht den Vergleich von zwei Zeigern, die von <i>demselben</i> Array erhalten wurden, obwohl sich mindestens einer von ihnen auf die Position hinter dem Ende des Arrays bezieht.  Dann wÃ¼rde der folgende Code nicht funktionieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt; &amp;x[num]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Unter Verwendung einer Schleife gehen wir um das gesamte <i>x-</i> Array herum, das aus 64 Elementen besteht, d.h.  Der SchleifenkÃ¶rper sollte genau 64 Mal ausgefÃ¼hrt werden.  TatsÃ¤chlich wird die Bedingung jedoch 65 Mal Ã¼berprÃ¼ft - einmal mehr als die Anzahl der Elemente im Array.  In den ersten 64 Iterationen bezieht sich der Zeiger <i>i</i> immer auf das Innere des Arrays <i>x</i> , wÃ¤hrend der Ausdruck <i>&amp; x [num]</i> immer die Position nach dem letzten Element des Arrays angibt.  Bei der 65. Iteration bezieht sich der Zeiger <i>i</i> auch auf die Position hinter dem Ende des Arrays <i>x</i> , wodurch die Schleifenbedingung falsch wird.  Dies ist eine bequeme MÃ¶glichkeit, das gesamte Array zu umgehen, und beruht auf einer Ausnahme von der Regel der Unsicherheit des Verhaltens beim Vergleich solcher Zeiger.  Beachten Sie, dass der Standard nur das Verhalten beim Vergleichen von Zeigern beschreibt.  Dereferenzierung ist ein separates Thema. <br><br>  Ist es mÃ¶glich, unser Beispiel so zu Ã¤ndern, dass sich kein einziger Zeiger auf die Position nach dem letzten Element des Arrays <i>x</i> bezieht?  Es ist mÃ¶glich, aber es wird schwieriger.  Wir mÃ¼ssen die Schleifenbedingung Ã¤ndern und das Inkrementieren der Variablen <i>i</i> bei der letzten Iteration verhindern. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt;= &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Dieser Code steckt voller technischer Feinheiten, mit denen sich die Hauptaufgabe ablenkt.  ZusÃ¤tzlich erschien ein zusÃ¤tzlicher Zweig im KÃ¶rper der Schleife.  Daher finde ich es vernÃ¼nftig, dass der Standard Ausnahmen beim Vergleichen von Positionszeigern nach dem letzten Element eines Arrays zulÃ¤sst. <br><br>  <b><i>PVS-Studio Team Hinweis</i></b> <br><br>  <i>Bei der Entwicklung des PVS-Studio-Code-Analysators mÃ¼ssen wir uns manchmal mit subtilen Problemen befassen, um die Diagnose genauer zu gestalten oder unseren Kunden detaillierte Konsultationen zu geben.</i>  <i>Dieser Artikel erschien uns interessant, da er Themen berÃ¼hrt, bei denen wir uns nicht ganz sicher fÃ¼hlen.</i>  <i>Deshalb haben wir die Autorin gebeten, ihre Ãœbersetzung zu verÃ¶ffentlichen.</i>  <i>Wir hoffen, dass mehr C- und C ++ - Programmierer sie kennenlernen und verstehen, dass dies nicht so einfach ist und dass Sie sich nicht beeilen sollten, wenn der Analysator plÃ¶tzlich eine seltsame Meldung anzeigt, diese als falsch positiv zu betrachten :).</i> <br><br>  <i>Der Artikel wurde erstmals in englischer Sprache bei stefansf.de verÃ¶ffentlicht.</i>  <i>Ãœbersetzungen werden mit Genehmigung des Autors verÃ¶ffentlicht.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418023/">https://habr.com/ru/post/de418023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418009/index.html">Node.js und Server-Rendering in Airbnb</a></li>
<li><a href="../de418011/index.html">Einzelseiten und SEO. Optimierungsgeheimnisse</a></li>
<li><a href="../de418013/index.html">Der Intel Core i7-8086K (Teil 3)</a></li>
<li><a href="../de418015/index.html">Neuer Vasyuki. Innovative Entwicklung Moskaus bis 2100</a></li>
<li><a href="../de418017/index.html">Analyse des Verhaltens des Pegasus-Trojaners im Netzwerk</a></li>
<li><a href="../de418025/index.html">Das Buch â€Java EE lernen. Moderne Programmierung fÃ¼r groÃŸe Unternehmen â€œ</a></li>
<li><a href="../de418027/index.html">Microservice Blitz</a></li>
<li><a href="../de418029/index.html">ReactOS 0.4.9: Hasser mÃ¼ssen nach neuen Argumenten suchen</a></li>
<li><a href="../de418031/index.html">Massenstapelung von ML-Modellen in der Produktion: echt oder nicht?</a></li>
<li><a href="../de418035/index.html">EinfÃ¼hrung in Timeline bei Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>