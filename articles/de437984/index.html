<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèæ üö¥üèΩ üè¨ Threading in Node.js: Modul worker_threads üßòüèΩ üßë ü§æüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am 18. Januar wurde die Node.js-Plattform Version 11.7.0 angek√ºndigt . Unter den bemerkenswerten √Ñnderungen in dieser Version kann man die Schlussfolg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Threading in Node.js: Modul worker_threads</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/437984/">  Am 18. Januar wurde die Node.js-Plattform Version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">11.7.0 angek√ºndigt</a> .  Unter den bemerkenswerten √Ñnderungen in dieser Version kann man die Schlussfolgerung aus der Kategorie des experimentellen Moduls worker_threads beachten, die in Node.js <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">10.5.0 ver√∂ffentlicht wurde</a> .  Jetzt wird die Flagge --experimental-worker nicht mehr ben√∂tigt, um sie zu verwenden.  Dieses Modul ist seit seiner Einf√ºhrung ziemlich stabil geblieben, und daher wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entscheidung</a> getroffen, die sich in Node.js 11.7.0 widerspiegelt. <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/jp/qj/fk/jpqjfkjewyfpm1cbr5yxaubxt-w.png"></a> <br>  Der Autor des Materials, dessen √úbersetzung wir ver√∂ffentlichen, bietet an, die Funktionen des Worker_Threads-Moduls zu diskutieren. Er m√∂chte insbesondere dar√ºber sprechen, warum dieses Modul ben√∂tigt wird und wie Multithreading aus historischen Gr√ºnden in JavaScript und Node.js implementiert wird.  Hier werden wir dar√ºber sprechen, welche Probleme mit dem Schreiben von JS-Anwendungen mit mehreren Threads verbunden sind, √ºber die vorhandenen L√∂sungsm√∂glichkeiten und √ºber die Zukunft der parallelen Datenverarbeitung unter Verwendung der sogenannten "Arbeitsthreads", die manchmal als "Arbeitsthreads" bezeichnet werden. oder einfach "Arbeiter". <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Leben in einer Welt mit einem einzigen Faden</font> </h2><br>  JavaScript wurde als Single-Threaded-Programmiersprache konzipiert, die in einem Browser ausgef√ºhrt wird.  "Single-Threaded" bedeutet, dass im selben Prozess (in modernen Browsern sprechen wir von separaten Browser-Registerkarten) jeweils nur ein Befehlssatz ausgef√ºhrt werden kann. <br><br>  Dies vereinfacht die Anwendungsentwicklung und erleichtert die Arbeit der Programmierer.  Urspr√ºnglich war JavaScript eine Sprache, die nur zum Hinzuf√ºgen einiger interaktiver Funktionen zu Webseiten geeignet war, beispielsweise zur Formular√ºberpr√ºfung.  Unter den Aufgaben, f√ºr die JS entwickelt wurde, gab es nichts besonders Kompliziertes, das Multithreading erforderte. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ryan Dahl</a> , Sch√∂pfer von Node.js, sah eine interessante Gelegenheit in dieser Sprachbeschr√§nkung.  Er wollte eine Serverplattform implementieren, die auf einem asynchronen E / A-Subsystem basiert.  Dies bedeutete, dass der Programmierer nicht mit Threads arbeiten musste, was die Entwicklung f√ºr eine √§hnliche Plattform erheblich vereinfacht.  Bei der Entwicklung von Programmen f√ºr die parallele Codeausf√ºhrung k√∂nnen Probleme auftreten, die sehr schwer zu l√∂sen sind.  Wenn beispielsweise mehrere Threads versuchen, auf denselben Speicherbereich zuzugreifen, kann dies zu einem sogenannten "Process Race State" f√ºhren, der das Programm st√∂rt.  Solche Fehler sind schwer zu reproduzieren und zu korrigieren. <br><br><h2>  <font color="#3AC1EF">Ist die Node.js-Plattform Single-Threaded?</font> </h2><br>  Sind Node.js Apps Single-Threaded?  Ja, in gewisser Weise ist es so.  In Node.js k√∂nnen Sie zwar bestimmte Aktionen parallel ausf√ºhren, der Programmierer muss jedoch keine Threads erstellen oder synchronisieren.  Die Node.js-Plattform und das Betriebssystem f√ºhren parallele Eingabe- / Ausgabeoperationen auf eigene Faust aus. Wenn die Zeit f√ºr die Datenverarbeitung mit unserem JavaScript-Code gekommen ist, funktioniert dies im Single-Threaded-Modus. <br><br>  Mit anderen Worten, alles au√üer unserem JS-Code funktioniert parallel.  In synchronen Bl√∂cken von JavaScript-Code werden Befehle immer einzeln in der Reihenfolge ausgef√ºhrt, in der sie im Quellcode dargestellt werden: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>  <span class="hljs-comment"><span class="hljs-comment">//    -  (     flag)...  //      ,     flag   true.  // -       ,  //      . }</span></span></code> </pre> <br>  All dies ist gro√üartig - wenn unser gesamter Code mit asynchroner E / A besch√§ftigt ist.  Das Programm besteht aus kleinen Bl√∂cken synchronen Codes, die schnell mit Daten arbeiten, die beispielsweise an Dateien und Streams gesendet werden.  Der Code von Programmfragmenten ist so schnell, dass er die Ausf√ºhrung des Codes seiner anderen Fragmente nicht blockiert.  Das Warten auf die Ergebnisse der asynchronen E / A dauert viel l√§nger als die Codeausf√ºhrung.  Betrachten Sie ein kleines Beispiel: <br><br><pre> <code class="javascript hljs">db.findOne(<span class="hljs-string"><span class="hljs-string">'SELECT ... LIMIT 1'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) }) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Running query'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hey there'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  Es ist m√∂glich, dass die Abfrage an die hier gezeigte Datenbank ungef√§hr eine Minute dauert, aber die Nachricht " <code>Running query</code> wird sofort nach dem Initiieren dieser Abfrage an die Konsole gesendet.  In diesem Fall wird die Meldung " <code>Hey there</code> eine Sekunde nach Ausf√ºhrung der Anforderung angezeigt, unabh√§ngig davon, ob die Ausf√ºhrung abgeschlossen wurde oder nicht.  Unsere Node.js-Anwendung ruft einfach die Funktion auf, die die Anforderung initiiert, w√§hrend die Ausf√ºhrung des anderen Codes nicht blockiert wird.  Nachdem die Anforderung abgeschlossen ist, wird die Anwendung mithilfe der R√ºckruffunktion dar√ºber informiert und erh√§lt dann eine Antwort auf diese Anforderung. <br><br><h2>  <font color="#3AC1EF">CPU-intensive Aufgaben</font> </h2><br>  Was passiert, wenn wir √ºber JavaScript Heavy Computing betreiben m√ºssen?  Zum Beispiel - um einen gro√üen Datensatz zu verarbeiten, der im Speicher gespeichert ist?  Dies kann dazu f√ºhren, dass das Programm ein Fragment von synchronem Code enth√§lt, dessen Ausf√ºhrung viel Zeit in Anspruch nimmt und die Ausf√ºhrung von anderem Code blockiert.  Stellen Sie sich vor, diese Berechnungen dauern 10 Sekunden.  Wenn es sich um einen Webserver handelt, der eine bestimmte Anforderung verarbeitet, bedeutet dies, dass er mindestens 10 Sekunden lang keine anderen Anforderungen verarbeiten kann.  Das ist ein gro√ües Problem.  Berechnungen, die l√§nger als 100 Millisekunden sind, k√∂nnen dieses Problem bereits verursachen. <br><br>  JavaScript und die Node.js-Plattform wurden urspr√ºnglich nicht entwickelt, um Aufgaben zu l√∂sen, bei denen Prozessorressourcen intensiv genutzt werden.  Wenn JS im Browser ausgef√ºhrt wird, bedeutet das Ausf√ºhren solcher Aufgaben "Bremsen" auf der Benutzeroberfl√§che.  In Node.js kann dies die M√∂glichkeit einschr√§nken, die Plattform zur Ausf√ºhrung neuer asynchroner E / A-Aufgaben aufzufordern und auf Ereignisse zu reagieren, die mit deren Abschluss verbunden sind. <br><br>  Kehren wir zu unserem vorherigen Beispiel zur√ºck.  Stellen Sie sich vor, als Antwort auf eine Anfrage an die Datenbank gingen mehrere tausend verschl√ºsselte Datens√§tze ein, die im synchronen JS-Code entschl√ºsselt werden m√ºssen: <br><br><pre> <code class="javascript hljs">db.findAll(<span class="hljs-string"><span class="hljs-string">'SELECT ...'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, results</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-comment"><span class="hljs-comment">//      ,    . for (const encrypted of results) {   const plainText = decrypt(encrypted)   console.log(plainText) } })</span></span></code> </pre> <br>  Die Ergebnisse befinden sich nach dem Empfang in der R√ºckruffunktion.  Danach kann bis zum Ende ihrer Verarbeitung kein anderer JS-Code ausgef√ºhrt werden.  Wie bereits erw√§hnt, ist die Belastung des durch diesen Code erzeugten Systems normalerweise minimal und f√ºhrt die ihm zugewiesenen Aufgaben schnell aus.  In diesem Fall hat das Programm jedoch die Abfrageergebnisse erhalten, die eine betr√§chtliche Menge haben, und wir m√ºssen sie noch verarbeiten.  So etwas kann einige Sekunden dauern.  Wenn es sich um einen Server handelt, mit dem viele Benutzer arbeiten, bedeutet dies, dass sie erst nach Abschluss eines ressourcenintensiven Vorgangs weiterarbeiten k√∂nnen. <br><br><h2>  <font color="#3AC1EF">Warum wird JavaScript niemals Threads haben?</font> </h2><br>  In Anbetracht des oben Gesagten scheint es, dass Sie zur L√∂sung schwerwiegender Computerprobleme in Node.js ein neues Modul hinzuf√ºgen m√ºssen, mit dem Sie Threads erstellen und verwalten k√∂nnen.  Wie kann man auf so etwas verzichten?  Es ist sehr traurig, dass diejenigen, die eine ausgereifte Serverplattform wie Node.js verwenden, nicht √ºber die Mittel verf√ºgen, um Probleme im Zusammenhang mit der Verarbeitung gro√üer Datenmengen auf wunderbare Weise zu l√∂sen. <br><br>  All dies ist wahr, aber wenn Sie die M√∂glichkeit hinzuf√ºgen, mit Streams in JavaScript zu arbeiten, f√ºhrt dies zu einer √Ñnderung der Natur dieser Sprache.  In JS k√∂nnen Sie nicht einfach die M√∂glichkeit hinzuf√ºgen, mit Threads zu arbeiten, z. B. in Form neuer Klassen oder Funktionen.  Dazu m√ºssen Sie die Sprache selbst √§ndern.  In Sprachen, die Multithreading unterst√ºtzen, ist das Konzept der Synchronisation weit verbreitet.  In Java sind beispielsweise sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige numerische Typen</a> nicht atomar.  Dies bedeutet, dass, wenn Synchronisationsmechanismen nicht verwendet werden, um mit ihnen von verschiedenen Threads aus zu arbeiten, dies beispielsweise dazu f√ºhren kann, dass mehrere Bytes einer solchen Variablen auf eins gesetzt werden, nachdem mehrere Threads gleichzeitig versucht haben, den Wert derselben Variablen zu √§ndern flie√üen und ein paar andere.  Infolgedessen enth√§lt eine solche Variable etwas, das mit dem normalen Betrieb des Programms nicht kompatibel ist. <br><br><h2>  <font color="#3AC1EF">Primitive L√∂sung des Problems: Iteration der Ereignisschleife</font> </h2><br>  Node.js f√ºhrt den n√§chsten Codeblock in der Ereigniswarteschlange erst aus, wenn der vorherige Block abgeschlossen ist.  Dies bedeutet, dass wir unser Problem zur L√∂sung in Teile <code>setImmediate(callback)</code> k√∂nnen, die durch synchrone Codefragmente dargestellt werden, und dann eine Konstruktion des Formulars <code>setImmediate(callback)</code> verwenden k√∂nnen, um die Ausf√ºhrung dieser Fragmente zu planen.  Der von der <code>callback</code> in diesem Konstrukt angegebene Code wird ausgef√ºhrt, nachdem die Aufgaben der aktuellen Iteration (Tick) der Ereignisschleife abgeschlossen sind.  Danach wird das gleiche Design verwendet, um den n√§chsten Stapel von Berechnungen in die Warteschlange zu stellen.  Dies erm√∂glicht es, den Zyklus von Ereignissen nicht zu blockieren und gleichzeitig volumetrische Probleme zu l√∂sen. <br><br>  Stellen Sie sich vor, wir haben ein gro√ües Array, das verarbeitet werden muss, w√§hrend die Verarbeitung jedes Elements eines solchen Arrays komplexe Berechnungen erfordert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-comment"><span class="hljs-comment">/*large array*/</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) { <span class="hljs-comment"><span class="hljs-comment">//         } // ,   ,      .</span></span></code> </pre> <br>  Wie bereits erw√§hnt, dauert es zu lange, bis das gesamte Array in einem Aufruf verarbeitet wird, und die Ausf√ºhrung eines anderen Anwendungscodes wird verhindert.  Daher werden wir diese gro√üe Aufgabe in Teile <code>setImmediate(callback)</code> und das <code>setImmediate(callback)</code> verwenden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crypto = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'crypto'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>).fill(<span class="hljs-string"><span class="hljs-string">'something'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processChunk</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) {   <span class="hljs-comment"><span class="hljs-comment">// ,      } else {   console.log('processing chunk');   //  10         const subarr = arr.splice(0, 10)   for (const item of subarr) {     //           doHeavyStuff(item)   }   //       setImmediate(processChunk) } } processChunk() function doHeavyStuff(item) { crypto.createHmac('sha256', 'secret').update(new Array(10000).fill(item).join('.')).digest('hex') } //       , ,   , //       . let interval = setInterval(() =&gt; { console.log('tick!') if (arr.length === 0) clearInterval(interval) }, 0)</span></span></code> </pre> <br>  Jetzt verarbeiten wir auf einmal zehn Elemente des Arrays. <code>setImmediate()</code> planen wir mit <code>setImmediate()</code> den n√§chsten Berechnungsstapel.  Dies bedeutet, dass, wenn Sie mehr Code im Programm ausf√ºhren m√ºssen, dieser zwischen Operationen zum Verarbeiten von Fragmenten des Arrays ausgef√ºhrt werden kann.  Daf√ºr gibt es hier am Ende des Beispiels Code, der <code>setInterval()</code> . <br><br>  Wie Sie sehen k√∂nnen, sieht ein solcher Code viel komplizierter aus als seine urspr√ºngliche Version.  Und oft kann der Algorithmus viel komplexer sein als der unsere, was bedeutet, dass es bei der Implementierung nicht einfach ist, die Berechnungen in Teile zu <code>setImmediate()</code> und zu verstehen, wo Sie <code>setImmediate()</code> setzen m√ºssen, um das richtige Gleichgewicht zu erreichen, um das richtige Gleichgewicht zu erreichen.  Au√üerdem stellte sich heraus, dass der Code jetzt asynchron ist. Wenn unser Projekt von Bibliotheken von Drittanbietern abh√§ngt, k√∂nnen wir den Prozess der L√∂sung einer schwierigen Aufgabe m√∂glicherweise nicht in Teile aufteilen. <br><br><h2>  <font color="#3AC1EF">Hintergrundprozesse</font> </h2><br>  Vielleicht <code>setImmediate()</code> der obige Ansatz mit <code>setImmediate()</code> in einfachen F√§llen gut, ist aber <code>setImmediate()</code> andere als ideal.  Au√üerdem werden hier (aus offensichtlichen Gr√ºnden) keine Threads verwendet, und wir beabsichtigen auch nicht, die Sprache daf√ºr zu √§ndern.  Ist es m√∂glich, parallele Datenverarbeitung ohne Threads durchzuf√ºhren?  Ja, das ist m√∂glich, und daf√ºr brauchen wir einen Mechanismus f√ºr die Hintergrunddatenverarbeitung.  Es geht darum, eine bestimmte Aufgabe zu starten, Daten an sie zu √ºbergeben, und dass diese Aufgabe, ohne den Hauptcode zu beeintr√§chtigen, alles verwendet, was sie ben√∂tigt, so viel Zeit f√ºr die Arbeit ben√∂tigt, wie sie ben√∂tigt, und dann die Ergebnisse an zur√ºckgibt Hauptcode.  Wir brauchen etwas √Ñhnliches wie das folgende Code-Snippet: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  script.js   ,    . const service = createService('script.js') //          service.compute(data, function(err, result) { //      })</span></span></code> </pre> <br>  Die Realit√§t ist, dass Sie in Node.js Hintergrundprozesse verwenden k√∂nnen.  Der Punkt ist, dass es m√∂glich ist, einen Zweig des Prozesses zu erstellen und das oben beschriebene Arbeitsschema unter Verwendung des Mechanismus des Messaging zwischen dem untergeordneten und dem √ºbergeordneten Prozess zu implementieren.  Der Hauptprozess kann mit dem untergeordneten Prozess interagieren, Ereignisse an ihn senden und von ihm empfangen.  Shared Memory wird bei diesem Ansatz nicht verwendet.  Alle von Prozessen ausgetauschten Daten werden ‚Äûgeklont‚Äú. Wenn also von einem Prozess √Ñnderungen an einer Instanz dieser Daten vorgenommen werden, sind diese √Ñnderungen f√ºr einen anderen Prozess nicht sichtbar.  Dies √§hnelt einer HTTP-Anforderung. Wenn ein Client sie an den Server sendet, erh√§lt der Server nur eine Kopie davon.  Wenn Prozesse keinen gemeinsamen Speicher verwenden, bedeutet dies, dass es bei gleichzeitigem Betrieb unm√∂glich ist, einen ‚ÄûRace-Status‚Äú zu erstellen, und dass wir uns nicht mit der Arbeit mit Threads belasten m√ºssen.  Es scheint, dass unser Problem gel√∂st wurde. <br><br>  In Wirklichkeit ist das nicht so.  Ja - vor uns liegt eine der L√∂sungen f√ºr die Aufgabe, intensive Berechnungen durchzuf√ºhren, aber es ist wiederum unvollkommen.  Das Erstellen einer Verzweigung eines Prozesses ist eine ressourcenintensive Operation.  Es braucht Zeit, um es abzuschlie√üen.  Tats√§chlich geht es darum, eine neue virtuelle Maschine von Grund auf neu zu erstellen und den vom Programm belegten Speicherplatz zu erh√∂hen, was darauf zur√ºckzuf√ºhren ist, dass Prozesse keinen gemeinsam genutzten Speicher verwenden.  In Anbetracht des Vorstehenden ist es angebracht zu fragen, ob es nach Abschluss einer Aufgabe m√∂glich ist, die Abzweigung des Prozesses wiederzuverwenden.  Sie k√∂nnen diese Frage positiv beantworten, aber hier m√ºssen Sie bedenken, dass geplant ist, den Zweig des Prozesses auf verschiedene ressourcenintensive Aufgaben zu √ºbertragen, die synchron ausgef√ºhrt werden.  Hier sind zwei Probleme zu sehen: <br><br><ul><li>  Obwohl bei diesem Ansatz der Hauptprozess nicht blockiert wird, kann der untergeordnete Prozess die an ihn √ºbertragenen Aufgaben nur nacheinander ausf√ºhren.  Wenn wir zwei Aufgaben haben, von denen eine 10 Sekunden und die zweite 1 Sekunde dauert und wir sie in dieser Reihenfolge erledigen, ist es unwahrscheinlich, dass wir warten m√ºssen, bis die erste vor der zweiten erledigt ist.  Da wir Prozessgabeln erstellen, m√∂chten wir die Funktionen des Betriebssystems nutzen, um Aufgaben zu planen und die Rechenressourcen aller Kerne unseres Prozessors zu nutzen.  Wir brauchen etwas, das der Arbeit an einem Computer √§hnelt, f√ºr eine Person, die Musik h√∂rt und durch Webseiten reist.  Dazu k√∂nnen Sie zwei Fork-Prozesse erstellen und mit deren Hilfe die parallele Ausf√ºhrung von Aufgaben organisieren. </li><li>  Wenn eine der Aufgaben mit einem Fehler zum Ende des Prozesses f√ºhrt, werden alle an einen solchen Prozess gesendeten Aufgaben nicht verarbeitet. </li></ul><br>  Um diese Probleme zu l√∂sen, ben√∂tigen wir mehrere Fork-Prozesse, nicht einen, aber wir m√ºssen ihre Anzahl begrenzen, da jeder von ihnen Systemressourcen ben√∂tigt und es Zeit braucht, um jeden von ihnen zu erstellen.  Daher ben√∂tigen wir nach dem Muster von Systemen, die Datenbankverbindungen unterst√ºtzen, so etwas wie einen Pool gebrauchsfertiger Prozesse.  Das Prozesspool-Managementsystem verwendet nach Erhalt neuer Aufgaben freie Prozesse, um diese auszuf√ºhren, und wenn ein bestimmter Prozess mit der Aufgabe fertig wird, kann es eine neue zuweisen.  Es besteht das Gef√ºhl, dass ein solches Arbeitsschema nicht einfach umzusetzen ist und tats√§chlich auch ist.  Wir werden das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Worker-Farm-</a> Paket verwenden, um dieses Schema zu implementieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const workerFarm = require('worker-farm') const service = workerFarm(require.resolve('./script')) service('hello', function (err, output) { console.log(output) }) // script.js //      - module.exports = (input, callback) =&gt; { callback(null, input + ' ' + world) }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Worker_threads-Modul</font> </h2><br>  Ist unser Problem gel√∂st?  Ja, wir k√∂nnen sagen, dass es gel√∂st ist, aber mit diesem Ansatz wird viel mehr Speicher ben√∂tigt, als erforderlich w√§re, wenn wir eine Multithread-L√∂sung zur Verf√ºgung h√§tten.  Threads verbrauchen im Vergleich zu Prozessgabeln weitaus weniger Ressourcen.  Aus diesem Grund wurde das Modul <code>worker_threads</code> in <code>worker_threads</code> <br><br>  Arbeitsthreads werden in einem isolierten Kontext ausgef√ºhrt.  Sie tauschen Informationen mit dem Hauptprozess √ºber Nachrichten aus.  Dies erspart uns das Problem der ‚ÄûRace Condition‚Äú, dem Multithread-Umgebungen ausgesetzt sind.  Gleichzeitig existieren Arbeitsabl√§ufe in demselben Prozess wie das Hauptprogramm, d. H. Bei diesem Ansatz wird im Vergleich zur Verwendung von Prozessgabeln viel weniger Speicher verwendet. <br><br>  Dar√ºber hinaus k√∂nnen Sie bei der Arbeit mit Arbeitern den gemeinsamen Speicher verwenden.  Speziell f√ºr diesen Zweck werden Objekte vom Typ <code>SharedArrayBuffer</code> .  Sie sollten nur in den F√§llen verwendet werden, in denen das Programm eine komplexe Verarbeitung gro√üer Datenmengen durchf√ºhren muss.  Mit ihnen k√∂nnen Sie die Ressourcen speichern, die zum Serialisieren und Deserialisieren von Daten erforderlich sind, wenn Sie den Datenaustausch zwischen Mitarbeitern und dem Hauptprogramm √ºber Nachrichten organisieren. <br><br><h2>  <font color="#3AC1EF">Arbeiter Arbeiter flie√üt</font> </h2><br>  Wenn Sie die Node.js-Plattform vor Version 11.7.0 verwenden, m√ºssen Sie zum Starten von <code>--experimental-worker</code> Flag <code>--experimental-worker</code> , um die Arbeit mit dem Modul worker_threads zu aktivieren. <br><br>  Dar√ºber hinaus ist zu beachten, dass das Erstellen eines Workers (wie das Erstellen eines Threads in einer beliebigen Sprache), obwohl es viel weniger Ressourcen erfordert als das Erstellen eines Abzweigs des Prozesses, auch eine gewisse Belastung des Systems verursacht.  Vielleicht ist in Ihrem Fall sogar diese Last zu hoch.  In solchen F√§llen wird in der Dokumentation empfohlen, einen Pool von Arbeitnehmern zu erstellen.  Wenn Sie dies ben√∂tigen, k√∂nnen Sie nat√ºrlich eine eigene Implementierung eines solchen Mechanismus erstellen, aber vielleicht sollten Sie in der NPM-Registrierung nach etwas Passendem suchen. <br><br>  Betrachten Sie ein Beispiel f√ºr die Arbeit mit Arbeitsthreads.  Wir werden eine Hauptdatei haben, <code>index.js</code> , in der wir einen <code>index.js</code> erstellen und ihm einige Daten zur Verarbeitung √ºbergeben.  Die entsprechende API ist ereignisbasiert, aber ich werde hier ein Versprechen verwenden, das aufgel√∂st wird, wenn die erste Nachricht vom Worker eintrifft: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// index.js //    Node.js   11.7.0,  //      node --experimental-worker index.js const { Worker } = require('worker_threads') function runService(workerData) { return new Promise((resolve, reject) =&gt; {   const worker = new Worker('./service.js', { workerData });   worker.on('message', resolve);   worker.on('error', reject);   worker.on('exit', (code) =&gt; {     if (code !== 0)       reject(new Error(`Worker stopped with exit code ${code}`));   }) }) } async function run() { const result = await runService('world') console.log(result); } run().catch(err =&gt; console.error(err))</span></span></code> </pre> <br>  Wie Sie sehen, ist die Verwendung des Workflow-Ablaufmechanismus recht einfach.  Wenn Sie einen Worker erstellen, m√ºssen Sie den Pfad zur Datei mit dem Worker-Code und den Daten an den <code>Worker</code> Designer √ºbergeben.  Denken Sie daran, dass diese Daten geklont und nicht im gemeinsamen Speicher gespeichert werden.  Nach dem Starten des Arbeiters erwarten wir eine Nachricht von ihm, die das <code>message</code> abh√∂rt. <br><br>  Oben haben wir beim Erstellen eines Objekts vom Typ <code>Worker</code> dem Konstruktor den Namen der Datei mit dem Worker-Code <code>service.js</code> .  Hier ist der Code f√ºr diese Datei: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// , ,    , //    . parentPort.postMessage({ hello: workerData })</span></span></code> </pre> <br>  Es gibt zwei Dinge, die uns am Worker Code interessieren.  Zun√§chst ben√∂tigen wir die von der Hauptanwendung √ºbertragenen Daten.  In unserem Fall werden sie durch die Variable <code>workerData</code> .  Zweitens ben√∂tigen wir einen Mechanismus zur √úbertragung von Informationen an die Hauptanwendung.  Dieser Mechanismus wird durch das <code>parentPort</code> Objekt dargestellt, das √ºber die <code>postMessage()</code> -Methode verf√ºgt, mit der wir die Ergebnisse der Datenverarbeitung an die Hauptanwendung √ºbergeben.  So funktioniert alles. <br><br>  Hier ist ein sehr einfaches Beispiel, aber mit denselben Mechanismen k√∂nnen Sie viel komplexere Strukturen erstellen.  Beispielsweise k√∂nnen Sie aus dem Worker-Stream viele Nachrichten an den Haupt-Stream senden, die Informationen zum Status der Datenverarbeitung enthalten, falls unsere Anwendung einen √§hnlichen Mechanismus ben√∂tigt.  Auch vom Mitarbeiter k√∂nnen die Datenverarbeitungsergebnisse in Teilen zur√ºckgegeben werden.  Zum Beispiel kann so etwas n√ºtzlich sein, wenn ein Mitarbeiter besch√§ftigt ist, beispielsweise Tausende von Bildern verarbeitet, und Sie, ohne auf die Verarbeitung aller Bilder zu warten, die Hauptanwendung √ºber den Abschluss der Verarbeitung jedes einzelnen Bilds informieren m√∂chten. <br><br>  Details zum Modul <code>worker_threads</code> finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  <font color="#3AC1EF">Web-Worker</font> </h2><br>  Sie haben vielleicht von Web-Workern geh√∂rt.  Sie sind f√ºr den Einsatz in einer Client-Umgebung vorgesehen. Diese Technologie existiert seit langem und wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> modernen Browsern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gut unterst√ºtzt</a> .  Die API f√ºr die Arbeit mit Web- <code>worker_threads</code> unterscheidet sich von der, die uns das Node.js-Modul <code>worker_threads</code> bietet. Es geht um die Unterschiede in den Umgebungen, in denen sie arbeiten.  Diese Technologien k√∂nnen jedoch √§hnliche Probleme l√∂sen.  Beispielsweise k√∂nnen Web-Worker in Client-Anwendungen verwendet werden, um die Ver- und Entschl√ºsselung von Daten sowie deren Komprimierung und Dekomprimierung durchzuf√ºhren.  Mit ihrer Hilfe k√∂nnen Sie Bilder verarbeiten, Computer-Vision-Systeme implementieren (wir sprechen beispielsweise von Gesichtserkennung) und andere √§hnliche Probleme in einem Browser l√∂sen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  <code>worker_threads</code> ‚Äî     Node.js.    ,    ,   .       , ,       ,         ¬´ ¬ª.   ,      ? ,    <code>worker_threads</code>      ,        Node.js      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">worker-farm</a> ,    <code>worker_threads</code>  ,   Node.js        . <br><br>  <b>Liebe Leser!</b>        Node.js-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437984/">https://habr.com/ru/post/de437984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437974/index.html">Wie gewinne ich digitale WorldSkills? An einem praktischen Beispiel</a></li>
<li><a href="../de437976/index.html">"Vkontakte" darf einzelne Unterlagen vor der Polizei verbergen</a></li>
<li><a href="../de437978/index.html">Willkommen beim SphinxSearch-Meetup SuperJob</a></li>
<li><a href="../de437980/index.html">Offenes Webinar ‚ÄûPaarweise Testmethode beim Black-Box-Testen‚Äú</a></li>
<li><a href="../de437982/index.html">Der neue Verschl√ºsselungsangriff von Shade richtet sich an russische Gesch√§ftsanwender</a></li>
<li><a href="../de437986/index.html">Warum ist TypeScript das Herzst√ºck jeder neuen PayPal-Webanwendung?</a></li>
<li><a href="../de437988/index.html">React Tutorial, Teil 12: Workshop, Phase 3 TODO-Anwendung</a></li>
<li><a href="../de437990/index.html">React Tutorial Teil 13: Klassenbasierte Komponenten</a></li>
<li><a href="../de437992/index.html">Microservices. Versionierung in kontinuierlichen Integrations- und Bereitstellungssystemen CI / CD-Fallstudie mit TFS</a></li>
<li><a href="../de437994/index.html">Automatisches Melken und automatische Gew√§chsh√§user: So funktioniert eine kleine Hightech-Farm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>