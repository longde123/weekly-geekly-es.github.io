<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏾 🚴🏽 🏬 Threading in Node.js: Modul worker_threads 🧘🏽 🧑 🤾🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am 18. Januar wurde die Node.js-Plattform Version 11.7.0 angekündigt . Unter den bemerkenswerten Änderungen in dieser Version kann man die Schlussfolg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Threading in Node.js: Modul worker_threads</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/437984/">  Am 18. Januar wurde die Node.js-Plattform Version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">11.7.0 angekündigt</a> .  Unter den bemerkenswerten Änderungen in dieser Version kann man die Schlussfolgerung aus der Kategorie des experimentellen Moduls worker_threads beachten, die in Node.js <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">10.5.0 veröffentlicht wurde</a> .  Jetzt wird die Flagge --experimental-worker nicht mehr benötigt, um sie zu verwenden.  Dieses Modul ist seit seiner Einführung ziemlich stabil geblieben, und daher wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entscheidung</a> getroffen, die sich in Node.js 11.7.0 widerspiegelt. <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/jp/qj/fk/jpqjfkjewyfpm1cbr5yxaubxt-w.png"></a> <br>  Der Autor des Materials, dessen Übersetzung wir veröffentlichen, bietet an, die Funktionen des Worker_Threads-Moduls zu diskutieren. Er möchte insbesondere darüber sprechen, warum dieses Modul benötigt wird und wie Multithreading aus historischen Gründen in JavaScript und Node.js implementiert wird.  Hier werden wir darüber sprechen, welche Probleme mit dem Schreiben von JS-Anwendungen mit mehreren Threads verbunden sind, über die vorhandenen Lösungsmöglichkeiten und über die Zukunft der parallelen Datenverarbeitung unter Verwendung der sogenannten "Arbeitsthreads", die manchmal als "Arbeitsthreads" bezeichnet werden. oder einfach "Arbeiter". <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Leben in einer Welt mit einem einzigen Faden</font> </h2><br>  JavaScript wurde als Single-Threaded-Programmiersprache konzipiert, die in einem Browser ausgeführt wird.  "Single-Threaded" bedeutet, dass im selben Prozess (in modernen Browsern sprechen wir von separaten Browser-Registerkarten) jeweils nur ein Befehlssatz ausgeführt werden kann. <br><br>  Dies vereinfacht die Anwendungsentwicklung und erleichtert die Arbeit der Programmierer.  Ursprünglich war JavaScript eine Sprache, die nur zum Hinzufügen einiger interaktiver Funktionen zu Webseiten geeignet war, beispielsweise zur Formularüberprüfung.  Unter den Aufgaben, für die JS entwickelt wurde, gab es nichts besonders Kompliziertes, das Multithreading erforderte. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ryan Dahl</a> , Schöpfer von Node.js, sah eine interessante Gelegenheit in dieser Sprachbeschränkung.  Er wollte eine Serverplattform implementieren, die auf einem asynchronen E / A-Subsystem basiert.  Dies bedeutete, dass der Programmierer nicht mit Threads arbeiten musste, was die Entwicklung für eine ähnliche Plattform erheblich vereinfacht.  Bei der Entwicklung von Programmen für die parallele Codeausführung können Probleme auftreten, die sehr schwer zu lösen sind.  Wenn beispielsweise mehrere Threads versuchen, auf denselben Speicherbereich zuzugreifen, kann dies zu einem sogenannten "Process Race State" führen, der das Programm stört.  Solche Fehler sind schwer zu reproduzieren und zu korrigieren. <br><br><h2>  <font color="#3AC1EF">Ist die Node.js-Plattform Single-Threaded?</font> </h2><br>  Sind Node.js Apps Single-Threaded?  Ja, in gewisser Weise ist es so.  In Node.js können Sie zwar bestimmte Aktionen parallel ausführen, der Programmierer muss jedoch keine Threads erstellen oder synchronisieren.  Die Node.js-Plattform und das Betriebssystem führen parallele Eingabe- / Ausgabeoperationen auf eigene Faust aus. Wenn die Zeit für die Datenverarbeitung mit unserem JavaScript-Code gekommen ist, funktioniert dies im Single-Threaded-Modus. <br><br>  Mit anderen Worten, alles außer unserem JS-Code funktioniert parallel.  In synchronen Blöcken von JavaScript-Code werden Befehle immer einzeln in der Reihenfolge ausgeführt, in der sie im Quellcode dargestellt werden: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>  <span class="hljs-comment"><span class="hljs-comment">//    -  (     flag)...  //      ,     flag   true.  // -       ,  //      . }</span></span></code> </pre> <br>  All dies ist großartig - wenn unser gesamter Code mit asynchroner E / A beschäftigt ist.  Das Programm besteht aus kleinen Blöcken synchronen Codes, die schnell mit Daten arbeiten, die beispielsweise an Dateien und Streams gesendet werden.  Der Code von Programmfragmenten ist so schnell, dass er die Ausführung des Codes seiner anderen Fragmente nicht blockiert.  Das Warten auf die Ergebnisse der asynchronen E / A dauert viel länger als die Codeausführung.  Betrachten Sie ein kleines Beispiel: <br><br><pre> <code class="javascript hljs">db.findOne(<span class="hljs-string"><span class="hljs-string">'SELECT ... LIMIT 1'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) }) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Running query'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hey there'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  Es ist möglich, dass die Abfrage an die hier gezeigte Datenbank ungefähr eine Minute dauert, aber die Nachricht " <code>Running query</code> wird sofort nach dem Initiieren dieser Abfrage an die Konsole gesendet.  In diesem Fall wird die Meldung " <code>Hey there</code> eine Sekunde nach Ausführung der Anforderung angezeigt, unabhängig davon, ob die Ausführung abgeschlossen wurde oder nicht.  Unsere Node.js-Anwendung ruft einfach die Funktion auf, die die Anforderung initiiert, während die Ausführung des anderen Codes nicht blockiert wird.  Nachdem die Anforderung abgeschlossen ist, wird die Anwendung mithilfe der Rückruffunktion darüber informiert und erhält dann eine Antwort auf diese Anforderung. <br><br><h2>  <font color="#3AC1EF">CPU-intensive Aufgaben</font> </h2><br>  Was passiert, wenn wir über JavaScript Heavy Computing betreiben müssen?  Zum Beispiel - um einen großen Datensatz zu verarbeiten, der im Speicher gespeichert ist?  Dies kann dazu führen, dass das Programm ein Fragment von synchronem Code enthält, dessen Ausführung viel Zeit in Anspruch nimmt und die Ausführung von anderem Code blockiert.  Stellen Sie sich vor, diese Berechnungen dauern 10 Sekunden.  Wenn es sich um einen Webserver handelt, der eine bestimmte Anforderung verarbeitet, bedeutet dies, dass er mindestens 10 Sekunden lang keine anderen Anforderungen verarbeiten kann.  Das ist ein großes Problem.  Berechnungen, die länger als 100 Millisekunden sind, können dieses Problem bereits verursachen. <br><br>  JavaScript und die Node.js-Plattform wurden ursprünglich nicht entwickelt, um Aufgaben zu lösen, bei denen Prozessorressourcen intensiv genutzt werden.  Wenn JS im Browser ausgeführt wird, bedeutet das Ausführen solcher Aufgaben "Bremsen" auf der Benutzeroberfläche.  In Node.js kann dies die Möglichkeit einschränken, die Plattform zur Ausführung neuer asynchroner E / A-Aufgaben aufzufordern und auf Ereignisse zu reagieren, die mit deren Abschluss verbunden sind. <br><br>  Kehren wir zu unserem vorherigen Beispiel zurück.  Stellen Sie sich vor, als Antwort auf eine Anfrage an die Datenbank gingen mehrere tausend verschlüsselte Datensätze ein, die im synchronen JS-Code entschlüsselt werden müssen: <br><br><pre> <code class="javascript hljs">db.findAll(<span class="hljs-string"><span class="hljs-string">'SELECT ...'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, results</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-comment"><span class="hljs-comment">//      ,    . for (const encrypted of results) {   const plainText = decrypt(encrypted)   console.log(plainText) } })</span></span></code> </pre> <br>  Die Ergebnisse befinden sich nach dem Empfang in der Rückruffunktion.  Danach kann bis zum Ende ihrer Verarbeitung kein anderer JS-Code ausgeführt werden.  Wie bereits erwähnt, ist die Belastung des durch diesen Code erzeugten Systems normalerweise minimal und führt die ihm zugewiesenen Aufgaben schnell aus.  In diesem Fall hat das Programm jedoch die Abfrageergebnisse erhalten, die eine beträchtliche Menge haben, und wir müssen sie noch verarbeiten.  So etwas kann einige Sekunden dauern.  Wenn es sich um einen Server handelt, mit dem viele Benutzer arbeiten, bedeutet dies, dass sie erst nach Abschluss eines ressourcenintensiven Vorgangs weiterarbeiten können. <br><br><h2>  <font color="#3AC1EF">Warum wird JavaScript niemals Threads haben?</font> </h2><br>  In Anbetracht des oben Gesagten scheint es, dass Sie zur Lösung schwerwiegender Computerprobleme in Node.js ein neues Modul hinzufügen müssen, mit dem Sie Threads erstellen und verwalten können.  Wie kann man auf so etwas verzichten?  Es ist sehr traurig, dass diejenigen, die eine ausgereifte Serverplattform wie Node.js verwenden, nicht über die Mittel verfügen, um Probleme im Zusammenhang mit der Verarbeitung großer Datenmengen auf wunderbare Weise zu lösen. <br><br>  All dies ist wahr, aber wenn Sie die Möglichkeit hinzufügen, mit Streams in JavaScript zu arbeiten, führt dies zu einer Änderung der Natur dieser Sprache.  In JS können Sie nicht einfach die Möglichkeit hinzufügen, mit Threads zu arbeiten, z. B. in Form neuer Klassen oder Funktionen.  Dazu müssen Sie die Sprache selbst ändern.  In Sprachen, die Multithreading unterstützen, ist das Konzept der Synchronisation weit verbreitet.  In Java sind beispielsweise sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige numerische Typen</a> nicht atomar.  Dies bedeutet, dass, wenn Synchronisationsmechanismen nicht verwendet werden, um mit ihnen von verschiedenen Threads aus zu arbeiten, dies beispielsweise dazu führen kann, dass mehrere Bytes einer solchen Variablen auf eins gesetzt werden, nachdem mehrere Threads gleichzeitig versucht haben, den Wert derselben Variablen zu ändern fließen und ein paar andere.  Infolgedessen enthält eine solche Variable etwas, das mit dem normalen Betrieb des Programms nicht kompatibel ist. <br><br><h2>  <font color="#3AC1EF">Primitive Lösung des Problems: Iteration der Ereignisschleife</font> </h2><br>  Node.js führt den nächsten Codeblock in der Ereigniswarteschlange erst aus, wenn der vorherige Block abgeschlossen ist.  Dies bedeutet, dass wir unser Problem zur Lösung in Teile <code>setImmediate(callback)</code> können, die durch synchrone Codefragmente dargestellt werden, und dann eine Konstruktion des Formulars <code>setImmediate(callback)</code> verwenden können, um die Ausführung dieser Fragmente zu planen.  Der von der <code>callback</code> in diesem Konstrukt angegebene Code wird ausgeführt, nachdem die Aufgaben der aktuellen Iteration (Tick) der Ereignisschleife abgeschlossen sind.  Danach wird das gleiche Design verwendet, um den nächsten Stapel von Berechnungen in die Warteschlange zu stellen.  Dies ermöglicht es, den Zyklus von Ereignissen nicht zu blockieren und gleichzeitig volumetrische Probleme zu lösen. <br><br>  Stellen Sie sich vor, wir haben ein großes Array, das verarbeitet werden muss, während die Verarbeitung jedes Elements eines solchen Arrays komplexe Berechnungen erfordert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-comment"><span class="hljs-comment">/*large array*/</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) { <span class="hljs-comment"><span class="hljs-comment">//         } // ,   ,      .</span></span></code> </pre> <br>  Wie bereits erwähnt, dauert es zu lange, bis das gesamte Array in einem Aufruf verarbeitet wird, und die Ausführung eines anderen Anwendungscodes wird verhindert.  Daher werden wir diese große Aufgabe in Teile <code>setImmediate(callback)</code> und das <code>setImmediate(callback)</code> verwenden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crypto = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'crypto'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>).fill(<span class="hljs-string"><span class="hljs-string">'something'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processChunk</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) {   <span class="hljs-comment"><span class="hljs-comment">// ,      } else {   console.log('processing chunk');   //  10         const subarr = arr.splice(0, 10)   for (const item of subarr) {     //           doHeavyStuff(item)   }   //       setImmediate(processChunk) } } processChunk() function doHeavyStuff(item) { crypto.createHmac('sha256', 'secret').update(new Array(10000).fill(item).join('.')).digest('hex') } //       , ,   , //       . let interval = setInterval(() =&gt; { console.log('tick!') if (arr.length === 0) clearInterval(interval) }, 0)</span></span></code> </pre> <br>  Jetzt verarbeiten wir auf einmal zehn Elemente des Arrays. <code>setImmediate()</code> planen wir mit <code>setImmediate()</code> den nächsten Berechnungsstapel.  Dies bedeutet, dass, wenn Sie mehr Code im Programm ausführen müssen, dieser zwischen Operationen zum Verarbeiten von Fragmenten des Arrays ausgeführt werden kann.  Dafür gibt es hier am Ende des Beispiels Code, der <code>setInterval()</code> . <br><br>  Wie Sie sehen können, sieht ein solcher Code viel komplizierter aus als seine ursprüngliche Version.  Und oft kann der Algorithmus viel komplexer sein als der unsere, was bedeutet, dass es bei der Implementierung nicht einfach ist, die Berechnungen in Teile zu <code>setImmediate()</code> und zu verstehen, wo Sie <code>setImmediate()</code> setzen müssen, um das richtige Gleichgewicht zu erreichen, um das richtige Gleichgewicht zu erreichen.  Außerdem stellte sich heraus, dass der Code jetzt asynchron ist. Wenn unser Projekt von Bibliotheken von Drittanbietern abhängt, können wir den Prozess der Lösung einer schwierigen Aufgabe möglicherweise nicht in Teile aufteilen. <br><br><h2>  <font color="#3AC1EF">Hintergrundprozesse</font> </h2><br>  Vielleicht <code>setImmediate()</code> der obige Ansatz mit <code>setImmediate()</code> in einfachen Fällen gut, ist aber <code>setImmediate()</code> andere als ideal.  Außerdem werden hier (aus offensichtlichen Gründen) keine Threads verwendet, und wir beabsichtigen auch nicht, die Sprache dafür zu ändern.  Ist es möglich, parallele Datenverarbeitung ohne Threads durchzuführen?  Ja, das ist möglich, und dafür brauchen wir einen Mechanismus für die Hintergrunddatenverarbeitung.  Es geht darum, eine bestimmte Aufgabe zu starten, Daten an sie zu übergeben, und dass diese Aufgabe, ohne den Hauptcode zu beeinträchtigen, alles verwendet, was sie benötigt, so viel Zeit für die Arbeit benötigt, wie sie benötigt, und dann die Ergebnisse an zurückgibt Hauptcode.  Wir brauchen etwas Ähnliches wie das folgende Code-Snippet: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  script.js   ,    . const service = createService('script.js') //          service.compute(data, function(err, result) { //      })</span></span></code> </pre> <br>  Die Realität ist, dass Sie in Node.js Hintergrundprozesse verwenden können.  Der Punkt ist, dass es möglich ist, einen Zweig des Prozesses zu erstellen und das oben beschriebene Arbeitsschema unter Verwendung des Mechanismus des Messaging zwischen dem untergeordneten und dem übergeordneten Prozess zu implementieren.  Der Hauptprozess kann mit dem untergeordneten Prozess interagieren, Ereignisse an ihn senden und von ihm empfangen.  Shared Memory wird bei diesem Ansatz nicht verwendet.  Alle von Prozessen ausgetauschten Daten werden „geklont“. Wenn also von einem Prozess Änderungen an einer Instanz dieser Daten vorgenommen werden, sind diese Änderungen für einen anderen Prozess nicht sichtbar.  Dies ähnelt einer HTTP-Anforderung. Wenn ein Client sie an den Server sendet, erhält der Server nur eine Kopie davon.  Wenn Prozesse keinen gemeinsamen Speicher verwenden, bedeutet dies, dass es bei gleichzeitigem Betrieb unmöglich ist, einen „Race-Status“ zu erstellen, und dass wir uns nicht mit der Arbeit mit Threads belasten müssen.  Es scheint, dass unser Problem gelöst wurde. <br><br>  In Wirklichkeit ist das nicht so.  Ja - vor uns liegt eine der Lösungen für die Aufgabe, intensive Berechnungen durchzuführen, aber es ist wiederum unvollkommen.  Das Erstellen einer Verzweigung eines Prozesses ist eine ressourcenintensive Operation.  Es braucht Zeit, um es abzuschließen.  Tatsächlich geht es darum, eine neue virtuelle Maschine von Grund auf neu zu erstellen und den vom Programm belegten Speicherplatz zu erhöhen, was darauf zurückzuführen ist, dass Prozesse keinen gemeinsam genutzten Speicher verwenden.  In Anbetracht des Vorstehenden ist es angebracht zu fragen, ob es nach Abschluss einer Aufgabe möglich ist, die Abzweigung des Prozesses wiederzuverwenden.  Sie können diese Frage positiv beantworten, aber hier müssen Sie bedenken, dass geplant ist, den Zweig des Prozesses auf verschiedene ressourcenintensive Aufgaben zu übertragen, die synchron ausgeführt werden.  Hier sind zwei Probleme zu sehen: <br><br><ul><li>  Obwohl bei diesem Ansatz der Hauptprozess nicht blockiert wird, kann der untergeordnete Prozess die an ihn übertragenen Aufgaben nur nacheinander ausführen.  Wenn wir zwei Aufgaben haben, von denen eine 10 Sekunden und die zweite 1 Sekunde dauert und wir sie in dieser Reihenfolge erledigen, ist es unwahrscheinlich, dass wir warten müssen, bis die erste vor der zweiten erledigt ist.  Da wir Prozessgabeln erstellen, möchten wir die Funktionen des Betriebssystems nutzen, um Aufgaben zu planen und die Rechenressourcen aller Kerne unseres Prozessors zu nutzen.  Wir brauchen etwas, das der Arbeit an einem Computer ähnelt, für eine Person, die Musik hört und durch Webseiten reist.  Dazu können Sie zwei Fork-Prozesse erstellen und mit deren Hilfe die parallele Ausführung von Aufgaben organisieren. </li><li>  Wenn eine der Aufgaben mit einem Fehler zum Ende des Prozesses führt, werden alle an einen solchen Prozess gesendeten Aufgaben nicht verarbeitet. </li></ul><br>  Um diese Probleme zu lösen, benötigen wir mehrere Fork-Prozesse, nicht einen, aber wir müssen ihre Anzahl begrenzen, da jeder von ihnen Systemressourcen benötigt und es Zeit braucht, um jeden von ihnen zu erstellen.  Daher benötigen wir nach dem Muster von Systemen, die Datenbankverbindungen unterstützen, so etwas wie einen Pool gebrauchsfertiger Prozesse.  Das Prozesspool-Managementsystem verwendet nach Erhalt neuer Aufgaben freie Prozesse, um diese auszuführen, und wenn ein bestimmter Prozess mit der Aufgabe fertig wird, kann es eine neue zuweisen.  Es besteht das Gefühl, dass ein solches Arbeitsschema nicht einfach umzusetzen ist und tatsächlich auch ist.  Wir werden das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Worker-Farm-</a> Paket verwenden, um dieses Schema zu implementieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const workerFarm = require('worker-farm') const service = workerFarm(require.resolve('./script')) service('hello', function (err, output) { console.log(output) }) // script.js //      - module.exports = (input, callback) =&gt; { callback(null, input + ' ' + world) }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Worker_threads-Modul</font> </h2><br>  Ist unser Problem gelöst?  Ja, wir können sagen, dass es gelöst ist, aber mit diesem Ansatz wird viel mehr Speicher benötigt, als erforderlich wäre, wenn wir eine Multithread-Lösung zur Verfügung hätten.  Threads verbrauchen im Vergleich zu Prozessgabeln weitaus weniger Ressourcen.  Aus diesem Grund wurde das Modul <code>worker_threads</code> in <code>worker_threads</code> <br><br>  Arbeitsthreads werden in einem isolierten Kontext ausgeführt.  Sie tauschen Informationen mit dem Hauptprozess über Nachrichten aus.  Dies erspart uns das Problem der „Race Condition“, dem Multithread-Umgebungen ausgesetzt sind.  Gleichzeitig existieren Arbeitsabläufe in demselben Prozess wie das Hauptprogramm, d. H. Bei diesem Ansatz wird im Vergleich zur Verwendung von Prozessgabeln viel weniger Speicher verwendet. <br><br>  Darüber hinaus können Sie bei der Arbeit mit Arbeitern den gemeinsamen Speicher verwenden.  Speziell für diesen Zweck werden Objekte vom Typ <code>SharedArrayBuffer</code> .  Sie sollten nur in den Fällen verwendet werden, in denen das Programm eine komplexe Verarbeitung großer Datenmengen durchführen muss.  Mit ihnen können Sie die Ressourcen speichern, die zum Serialisieren und Deserialisieren von Daten erforderlich sind, wenn Sie den Datenaustausch zwischen Mitarbeitern und dem Hauptprogramm über Nachrichten organisieren. <br><br><h2>  <font color="#3AC1EF">Arbeiter Arbeiter fließt</font> </h2><br>  Wenn Sie die Node.js-Plattform vor Version 11.7.0 verwenden, müssen Sie zum Starten von <code>--experimental-worker</code> Flag <code>--experimental-worker</code> , um die Arbeit mit dem Modul worker_threads zu aktivieren. <br><br>  Darüber hinaus ist zu beachten, dass das Erstellen eines Workers (wie das Erstellen eines Threads in einer beliebigen Sprache), obwohl es viel weniger Ressourcen erfordert als das Erstellen eines Abzweigs des Prozesses, auch eine gewisse Belastung des Systems verursacht.  Vielleicht ist in Ihrem Fall sogar diese Last zu hoch.  In solchen Fällen wird in der Dokumentation empfohlen, einen Pool von Arbeitnehmern zu erstellen.  Wenn Sie dies benötigen, können Sie natürlich eine eigene Implementierung eines solchen Mechanismus erstellen, aber vielleicht sollten Sie in der NPM-Registrierung nach etwas Passendem suchen. <br><br>  Betrachten Sie ein Beispiel für die Arbeit mit Arbeitsthreads.  Wir werden eine Hauptdatei haben, <code>index.js</code> , in der wir einen <code>index.js</code> erstellen und ihm einige Daten zur Verarbeitung übergeben.  Die entsprechende API ist ereignisbasiert, aber ich werde hier ein Versprechen verwenden, das aufgelöst wird, wenn die erste Nachricht vom Worker eintrifft: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// index.js //    Node.js   11.7.0,  //      node --experimental-worker index.js const { Worker } = require('worker_threads') function runService(workerData) { return new Promise((resolve, reject) =&gt; {   const worker = new Worker('./service.js', { workerData });   worker.on('message', resolve);   worker.on('error', reject);   worker.on('exit', (code) =&gt; {     if (code !== 0)       reject(new Error(`Worker stopped with exit code ${code}`));   }) }) } async function run() { const result = await runService('world') console.log(result); } run().catch(err =&gt; console.error(err))</span></span></code> </pre> <br>  Wie Sie sehen, ist die Verwendung des Workflow-Ablaufmechanismus recht einfach.  Wenn Sie einen Worker erstellen, müssen Sie den Pfad zur Datei mit dem Worker-Code und den Daten an den <code>Worker</code> Designer übergeben.  Denken Sie daran, dass diese Daten geklont und nicht im gemeinsamen Speicher gespeichert werden.  Nach dem Starten des Arbeiters erwarten wir eine Nachricht von ihm, die das <code>message</code> abhört. <br><br>  Oben haben wir beim Erstellen eines Objekts vom Typ <code>Worker</code> dem Konstruktor den Namen der Datei mit dem Worker-Code <code>service.js</code> .  Hier ist der Code für diese Datei: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// , ,    , //    . parentPort.postMessage({ hello: workerData })</span></span></code> </pre> <br>  Es gibt zwei Dinge, die uns am Worker Code interessieren.  Zunächst benötigen wir die von der Hauptanwendung übertragenen Daten.  In unserem Fall werden sie durch die Variable <code>workerData</code> .  Zweitens benötigen wir einen Mechanismus zur Übertragung von Informationen an die Hauptanwendung.  Dieser Mechanismus wird durch das <code>parentPort</code> Objekt dargestellt, das über die <code>postMessage()</code> -Methode verfügt, mit der wir die Ergebnisse der Datenverarbeitung an die Hauptanwendung übergeben.  So funktioniert alles. <br><br>  Hier ist ein sehr einfaches Beispiel, aber mit denselben Mechanismen können Sie viel komplexere Strukturen erstellen.  Beispielsweise können Sie aus dem Worker-Stream viele Nachrichten an den Haupt-Stream senden, die Informationen zum Status der Datenverarbeitung enthalten, falls unsere Anwendung einen ähnlichen Mechanismus benötigt.  Auch vom Mitarbeiter können die Datenverarbeitungsergebnisse in Teilen zurückgegeben werden.  Zum Beispiel kann so etwas nützlich sein, wenn ein Mitarbeiter beschäftigt ist, beispielsweise Tausende von Bildern verarbeitet, und Sie, ohne auf die Verarbeitung aller Bilder zu warten, die Hauptanwendung über den Abschluss der Verarbeitung jedes einzelnen Bilds informieren möchten. <br><br>  Details zum Modul <code>worker_threads</code> finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  <font color="#3AC1EF">Web-Worker</font> </h2><br>  Sie haben vielleicht von Web-Workern gehört.  Sie sind für den Einsatz in einer Client-Umgebung vorgesehen. Diese Technologie existiert seit langem und wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> modernen Browsern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gut unterstützt</a> .  Die API für die Arbeit mit Web- <code>worker_threads</code> unterscheidet sich von der, die uns das Node.js-Modul <code>worker_threads</code> bietet. Es geht um die Unterschiede in den Umgebungen, in denen sie arbeiten.  Diese Technologien können jedoch ähnliche Probleme lösen.  Beispielsweise können Web-Worker in Client-Anwendungen verwendet werden, um die Ver- und Entschlüsselung von Daten sowie deren Komprimierung und Dekomprimierung durchzuführen.  Mit ihrer Hilfe können Sie Bilder verarbeiten, Computer-Vision-Systeme implementieren (wir sprechen beispielsweise von Gesichtserkennung) und andere ähnliche Probleme in einem Browser lösen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  <code>worker_threads</code> —     Node.js.    ,    ,   .       , ,       ,         « ».   ,      ? ,    <code>worker_threads</code>      ,        Node.js      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">worker-farm</a> ,    <code>worker_threads</code>  ,   Node.js        . <br><br>  <b>Liebe Leser!</b>        Node.js-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437984/">https://habr.com/ru/post/de437984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437974/index.html">Wie gewinne ich digitale WorldSkills? An einem praktischen Beispiel</a></li>
<li><a href="../de437976/index.html">"Vkontakte" darf einzelne Unterlagen vor der Polizei verbergen</a></li>
<li><a href="../de437978/index.html">Willkommen beim SphinxSearch-Meetup SuperJob</a></li>
<li><a href="../de437980/index.html">Offenes Webinar „Paarweise Testmethode beim Black-Box-Testen“</a></li>
<li><a href="../de437982/index.html">Der neue Verschlüsselungsangriff von Shade richtet sich an russische Geschäftsanwender</a></li>
<li><a href="../de437986/index.html">Warum ist TypeScript das Herzstück jeder neuen PayPal-Webanwendung?</a></li>
<li><a href="../de437988/index.html">React Tutorial, Teil 12: Workshop, Phase 3 TODO-Anwendung</a></li>
<li><a href="../de437990/index.html">React Tutorial Teil 13: Klassenbasierte Komponenten</a></li>
<li><a href="../de437992/index.html">Microservices. Versionierung in kontinuierlichen Integrations- und Bereitstellungssystemen CI / CD-Fallstudie mit TFS</a></li>
<li><a href="../de437994/index.html">Automatisches Melken und automatische Gewächshäuser: So funktioniert eine kleine Hightech-Farm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>