<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🔧 🏒 📘 Pendengar Acara dan Pekerja Web 👨🏿‍🤝‍👨🏻 🍤 🤜🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini saya menemukan API Pekerja Web . Sangat disayangkan bahwa saya tidak meluangkan waktu untuk alat yang didukung ini sebelumnya. Aplikasi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pendengar Acara dan Pekerja Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/479268/">  Baru-baru ini saya menemukan <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">API Pekerja Web</a> .  Sangat disayangkan bahwa saya tidak meluangkan waktu untuk alat yang didukung ini sebelumnya.  Aplikasi web modern sangat menuntut kemampuan utas eksekusi JavaScript utama.  Ini memengaruhi produktivitas proyek dan kemampuan mereka untuk memastikan pengalaman pengguna yang nyaman.  Pekerja web adalah apa yang akhir-akhir ini dapat membantu pengembang untuk membuat proyek web yang cepat dan nyaman. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/479268/"><img src="https://habrastorage.org/webt/lz/ri/gh/lzrighg_057gfhx-kt26m-rr9eg.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Saat aku mengerti segalanya</font> </h2><br>  Pekerja web memiliki banyak kualitas positif.  Tetapi saya benar-benar menyadari kegunaannya ketika saya menemukan sebuah situasi di mana aplikasi tertentu menggunakan beberapa pendengar acara DOM.  Seperti acara pengiriman formulir, pengubahan ukuran jendela, klik tombol.  Semua pendengar ini harus bekerja di utas utama.  Jika utas utama kelebihan beban dengan operasi tertentu yang membutuhkan waktu lama untuk diselesaikan, ini berdampak buruk pada tingkat reaksi pendengar acara terhadap pengaruh pengguna.  Aplikasi "melambat", acara menunggu rilis utas. <br><br>  Saya harus mengakui bahwa alasan mengapa saya begitu tertarik pada acara pendengar adalah bahwa saya awalnya salah memahami tugas-tugas yang dirancang untuk diselesaikan oleh pekerja web.  Pada awalnya, saya pikir mereka dapat membantu meningkatkan kecepatan eksekusi kode.  Saya berpikir bahwa suatu aplikasi akan dapat melakukan lebih banyak dalam periode waktu tertentu jika beberapa fragmen kodenya akan dieksekusi secara paralel, dalam utas yang terpisah.  Tetapi selama pelaksanaan kode proyek web, suatu situasi cukup umum ketika, sebelum Anda mulai melakukan sesuatu, Anda perlu menunggu beberapa peristiwa.  Katakanlah DOM perlu diperbarui hanya setelah beberapa perhitungan selesai.  Mengetahui hal ini, saya secara naif percaya bahwa jika saya, dalam hal apa pun, harus menunggu, itu berarti tidak masuk akal untuk mentransfer eksekusi beberapa kode ke utas terpisah. <br><br>  Berikut adalah contoh kode yang dapat Anda ingat di sini: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calculateResultsButton = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'calculateResultsButton'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> openMenuButton = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'#openMenuButton'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resultBox = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'resultBox'</span></span>); calculateResultsButton.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, (e) =&gt; {     <span class="hljs-comment"><span class="hljs-comment">// "    -, ,   ,     //   DOM   ?"     const result = performLongRunningCalculation();     resultBox.innerText = result; }); openMenuButton.addEventListener('click', (e) =&gt; {     //      . });</span></span></code> </pre> <br>  Di sini saya memperbarui teks di lapangan setelah beberapa perhitungan selesai, mungkin panjang.  Tampaknya tidak ada gunanya menjalankan kode ini di utas terpisah, karena DOM tidak memperbarui sebelum kode ini selesai.  Akibatnya, tentu saja, saya memutuskan bahwa kode ini perlu dijalankan secara serempak.  Namun, melihat kode seperti itu, pada awalnya saya tidak mengerti bahwa selama utas utama diblokir, pendengar acara lainnya tidak memulai.  Ini berarti "rem" mulai muncul di halaman. <br><br><h2>  <font color="#3AC1EF">Cara "memperlambat" halaman</font> </h2><br>  <a href="https://codepen.io/alexmacarthur/pen/XWWKyGe">Berikut adalah</a> proyek CodePen yang menunjukkan hal di atas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bd/b78/158/3bdb781580ff39915b6b6ec1ea701c4c.png"></div><br>  <i><font color="#999999">Sebuah proyek yang menunjukkan situasi di mana halaman lambat</font></i> <br><br>  Menekan tombol <code>Freeze</code> menyebabkan aplikasi mulai menyelesaikan tugas sinkron.  Semua ini membutuhkan waktu 3 detik (ini mensimulasikan kinerja perhitungan yang panjang).  Jika Anda mengklik tombol <code>Increment</code> , kemudian sampai 3 detik berlalu, nilai dalam bidang <code>Click Count</code> tidak akan diperbarui.  Nilai baru yang sesuai dengan jumlah klik pada <code>Increment</code> akan ditulis ke bidang ini hanya setelah tiga detik berlalu.  Aliran utama diblokir selama jeda.  Akibatnya, semua yang ada di jendela aplikasi terlihat tidak beroperasi.  Antarmuka aplikasi dibekukan.  Peristiwa yang muncul dalam proses "pembekuan" sedang menunggu kesempatan untuk menggunakan sumber daya dari arus utama. <br><br>  Jika Anda mengeklik <code>Freeze</code> dan coba <code>resize me!</code>  , lalu, sekali lagi, hingga tiga detik berlalu, ukuran bidang tidak akan berubah.  Dan setelah itu, ukuran bidang, bagaimanapun, akan berubah, tetapi tidak perlu berbicara tentang "kelancaran" di antarmuka. <br><br><h2>  <font color="#3AC1EF">Pendengar acara adalah fenomena yang jauh lebih besar daripada yang terlihat pada pandangan pertama</font> </h2><br>  Setiap pengguna tidak akan suka bekerja dengan situs yang berperilaku seperti yang ditunjukkan pada contoh sebelumnya.  Tetapi di sini hanya beberapa acara pendengar digunakan di sini.  Di dunia nyata, kita berbicara tentang skala yang sama sekali berbeda.  Saya memutuskan untuk menggunakan metode <code>getEventListeners</code> di Chrome dan, menggunakan skrip berikut, cari tahu jumlah pendengar acara yang dilampirkan pada elemen DOM dari berbagai halaman.  Script ini dapat dijalankan langsung di konsol alat pengembang.  Ini dia: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>  .from([<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>, ...document.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'*'</span></span>)])  .reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">accumulator, node</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> listeners = getEventListeners(node);    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> property <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> listeners) {      accumulator = accumulator + listeners[property].length    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulator;  }, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Saya menjalankan skrip ini di halaman yang berbeda dan mengetahui tentang jumlah pendengar acara yang digunakan pada mereka.  Hasil percobaan saya ditunjukkan pada tabel berikut. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Aplikasi</b> <br></td><td>  <b>Jumlah Pendengar Acara</b> <br></td></tr><tr><td>  Dropbox <br></td><td>  602 <br></td></tr><tr><td>  Pesan Google <br></td><td>  581 <br></td></tr><tr><td>  Reddit <br></td><td>  692 <br></td></tr><tr><td>  YouTube <br></td><td>  6054 (!!!) <br></td></tr></tbody></table></div><br>  Anda tidak dapat memperhatikan nomor-nomor tertentu.  Hal utama di sini adalah bahwa kita berbicara tentang sejumlah besar pendengar acara.  Akibatnya, jika setidaknya satu operasi yang berjalan lama dalam aplikasi berjalan salah, semua pendengar ini akan berhenti merespons pengaruh pengguna.  Ini memberi pengembang banyak cara untuk membuat marah para pengguna aplikasi mereka. <br><br><h2>  <font color="#3AC1EF">Singkirkan "rem" dengan pekerja web</font> </h2><br>  Dengan semua hal di atas, mari kita tulis ulang contoh sebelumnya.  <a href="https://codepen.io/alexmacarthur/pen/qBEORdO">Ini</a> versi barunya.  Ini terlihat persis seperti yang lama, tetapi di dalamnya diatur secara berbeda.  Yaitu, sekarang operasi yang digunakan untuk memblokir utas telah dipindahkan ke utasnya sendiri.  Jika Anda melakukan hal yang sama dengan contoh ini seperti yang sebelumnya, Anda dapat melihat perbedaan positif yang serius.  Yaitu, jika setelah mengklik tombol <code>Freeze</code> klik pada <code>Increment</code> , bidang <code>Click Count</code> akan diperbarui (setelah pekerja web selesai, dalam hal apa pun, angka 1 akan ditambahkan ke nilai <code>Click Count</code> ).  Hal yang sama berlaku untuk <code>resize me!</code>  .  Kode yang berjalan di utas terpisah tidak memblokir pendengar acara.  Ini memungkinkan semua elemen halaman untuk tetap beroperasi bahkan selama pelaksanaan operasi yang sebelumnya hanya "membeku" halaman. <br><br>  Berikut adalah kode JS untuk contoh ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> button1 = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> button2 = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button2'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'count'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workerScript = <span class="hljs-string"><span class="hljs-string">`  function pause(ms) {    let time = new Date();    while ((new Date()) - time &lt;= ms) {}               }  self.onmessage = function(e) {    pause(e.data);    self.postMessage('Process complete!');  } `</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> blob = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob([  workerScript, ], {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"text/javascipt"</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.URL.createObjectURL(blob)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bumpCount = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {  count.innerText = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(count.innerText) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } worker.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.data);  bumpCount(); } button1.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  worker.postMessage(<span class="hljs-number"><span class="hljs-number">3000</span></span>); }); button2.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  bumpCount(); });</code> </pre> <br>  Jika Anda mempelajari sedikit kode ini, Anda akan memperhatikan bahwa, meskipun Web Workers API dapat diatur dan lebih nyaman, tidak ada yang sangat menakutkan dalam bekerja dengannya.  Kode ini mungkin terlihat menyeramkan karena fakta bahwa ini adalah demo sederhana yang ditulis dengan cepat.  Untuk meningkatkan kegunaan API dan membuatnya lebih mudah untuk bekerja dengan pekerja web, Anda dapat menggunakan beberapa alat tambahan.  Misalnya, berikut ini sepertinya menarik bagi saya: <br><br><ul><li>  <a href="https://github.com/developit/workerize">Workerize</a> - memungkinkan Anda menjalankan modul di pekerja web. </li><li>  <a href="https://github.com/developit/greenlet">Greenlet</a> - memungkinkan untuk mengeksekusi potongan kode asinkron yang sewenang-wenang pada pekerja web. </li><li>  <a href="https://github.com/GoogleChromeLabs/comlink">Comlink</a> - menyediakan lapisan abstraksi yang nyaman di atas API Pekerja Web. </li></ul><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Jika aplikasi web Anda adalah proyek modern yang khas, itu berarti sangat mungkin memiliki banyak pendengar acara.  Mungkin juga, di utas utama, melakukan banyak perhitungan, yang bisa dilakukan di utas lain.  Sebagai hasilnya, Anda dapat memberikan layanan yang baik untuk pengguna dan pendengar acara, mempercayakan perhitungan "berat" kepada pekerja web. <br><br>  Perlu dicatat bahwa antusiasme yang berlebihan untuk pekerja web dan penghapusan segala sesuatu yang tidak terkait langsung dengan antarmuka pengguna dengan pekerja web mungkin bukan ide terbaik.  Pemrosesan aplikasi semacam itu mungkin memerlukan banyak waktu dan usaha, kode proyek akan menjadi lebih rumit, dan manfaat dari konversi semacam itu akan sangat kecil.  Sebagai gantinya, mungkin layak memulai dengan mencari kode yang benar-benar “berat” dan membawanya ke pekerja web.  Seiring waktu, ide menggunakan pekerja web akan menjadi lebih akrab, dan Anda mungkin akan dipandu olehnya bahkan pada tahap desain antarmuka. <br><br>  Namun, saya sarankan Anda memahami API Pekerja Web.  Teknologi ini menikmati dukungan browser yang sangat luas, dan persyaratan kinerja aplikasi web modern semakin berkembang.  Karenanya, kami tidak punya alasan untuk menolak mempelajari alat seperti pekerja web. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan pekerja web dalam proyek Anda? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/getpro/habr/post_images/2fc/5b4/735/2fc5b473506e5be00e2b4274bb5e5da8.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479268/">https://habr.com/ru/post/id479268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479256/index.html">Di bangun dari Astrotracker di Two Evenings - My Experience</a></li>
<li><a href="../id479258/index.html">IGF 2019. Apakah Internet berantakan?</a></li>
<li><a href="../id479262/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 392 (2 - 8 Desember 2019)</a></li>
<li><a href="../id479264/index.html">Warna Bulan dan Matahari dari ruang angkasa dalam hal RGB dan suhu warna</a></li>
<li><a href="../id479266/index.html">Analisis beban CPU yang dihasilkan oleh masing-masing komponen JavaScript</a></li>
<li><a href="../id479270/index.html">Apa yang baru dapat Anda harapkan dari Node.js pada tahun 2020?</a></li>
<li><a href="../id479272/index.html">[bookmark] 9 alat yang meningkatkan produktivitas pengembang web</a></li>
<li><a href="../id479274/index.html">10 Trik Python untuk Diketahui</a></li>
<li><a href="../id479276/index.html">Tiga Metode Pandas yang Mungkin Tidak Anda Ketahui</a></li>
<li><a href="../id479278/index.html">Seratus hingga lima ratus digit angka pi di lutut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>