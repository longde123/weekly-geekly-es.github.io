<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✳️ 👧🏻 👆🏿 Ne tombez pas dans le piège de l'optimisation prématurée 👨🏽‍🤝‍👨🏻 🐄 😆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Donald Knuth a dit un jour les mots qui sont devenus célèbres par la suite: «Le vrai problème est que les programmeurs, pas là où ils doivent et pas q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ne tombez pas dans le piège de l'optimisation prématurée</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/465809/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Donald Knuth</a> a dit un jour les mots qui sont devenus célèbres par la suite: «Le vrai problème est que les programmeurs, pas là où ils doivent et pas quand ils en ont besoin, passent trop de temps à se soucier de l'efficacité.  L'optimisation prématurée est la racine de tous les maux (ou du moins la plupart d'entre eux) dans la programmation. » <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ps/qf/uj/psqfujg9tiki8nv85hrvqqwpyfy.jpeg"></a> <br><br>  L'auteur du document, dont nous publions aujourd'hui la traduction, souhaite expliquer comment il est tombé une fois dans le piège de l'optimisation prématurée et comment il a compris, par sa propre expérience amère, que l'optimisation prématurée est à l'origine de tous les maux. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Jeu GeoArena en ligne</font> </h2><br>  Il y a quelques années, j'ai travaillé sur le jeu Web GeoArena Online (puis je l'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vendu</a> , les nouveaux propriétaires l'ont posté sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">geoarena.io</a> ).  C'était un jeu multijoueur dans le style du «dernier survivant».  Là, le joueur contrôlait le navire, se battant face à face avec un autre joueur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/a9d/bcc/f49a9dbcc8d59ab914ce355de6231696.png"></div><br>  <i><font color="#999999">Jeu GeoArena en ligne</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/259/3b0/346/2593b03467d1c05d04b3b23022e131c6.png"></div><br>  <i><font color="#999999">Jeu GeoArena en ligne</font></i> <br><br>  Un jeu dynamique, dont le monde est plein de particules et d'effets, nécessite de sérieuses ressources informatiques.  En conséquence, le jeu sur certains vieux ordinateurs a "ralenti" dans des moments particulièrement tendus.  Moi, un homme qui n'est pas indifférent aux problèmes de productivité, j'ai pris la solution à ce problème avec intérêt.  «Comment accélérer la partie JavaScript côté client GeoArena», me suis-je demandé. <br><br><h2>  <font color="#3AC1EF">Bibliothèque Fast.js</font> </h2><br>  Après avoir cherché un peu sur Internet, j'ai découvert la bibliothèque <a href="">fast.js.</a>  Il s'agissait d'une "collection de micro-optimisations visant à simplifier le développement de programmes JavaScript très rapides".  Cette bibliothèque a été accélérée par la disponibilité d'implémentations plus rapides des méthodes standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intégrées</a> comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Array.prototype.forEach ()</a> . <br><br>  J'ai trouvé cela extrêmement intéressant.  GeoArena a utilisé de nombreux tableaux, effectué de nombreuses opérations avec des tableaux, donc l'utilisation de fast.js pourrait très bien m'aider à accélérer le jeu.  Les résultats suivants de l'étude de performance <code>forEach()</code> ont été inclus dans le <a href="">fichier README</a> de fast.js. <br><br><pre> <code class="javascript hljs">Native .forEach() vs fast.forEach() (<span class="hljs-number"><span class="hljs-number">10</span></span> items)  ✓ <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>::forEach() x <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">557</span></span>,<span class="hljs-number"><span class="hljs-number">082</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.37</span></span>% (<span class="hljs-number"><span class="hljs-number">97</span></span> runs sampled)  ✓ fast.forEach() x <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">799</span></span>,<span class="hljs-number"><span class="hljs-number">272</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.41</span></span>% (<span class="hljs-number"><span class="hljs-number">97</span></span> runs sampled)  Result: fast.js is <span class="hljs-number"><span class="hljs-number">2.83</span></span>% faster than <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>::forEach().</code> </pre> <br>  Comment une méthode implémentée dans une bibliothèque externe peut-elle être plus rapide que sa version standard?  Le truc, c'est qu'il y avait une astuce (elles, ces astuces, se trouvent partout où vous regardez).  La bibliothèque ne convenait que pour travailler avec des tableaux qui n'étaient pas rares. <br><br>  Voici quelques exemples simples de tels tableaux: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  -  :   1  . const sparse1 = [0, , 1]; console.log(sparse1.length); // 3 //  -   const sparse2 = []; // ...   - .   0 - 4    . sparse2[5] = 0; console.log(sparse2.length); // 6</span></span></code> </pre> <br>  Afin de comprendre pourquoi la bibliothèque ne peut pas fonctionner normalement avec des tableaux clairsemés, j'ai examiné son code source.  Il s'est avéré que l' <code>forEach()</code> dans fast.js est basée sur des boucles for.  Une implémentation rapide de la méthode <code>forEach()</code> ressemblerait à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     . function fastForEach(array, f) {  for (let i = 0; i &lt; array.length; i++) {    f(array[i], i, array);  } } const sparseArray = [1, , 2]; const print = x =&gt; console.log(x); fastForEach(sparseArray, print); //  print() 3 . sparseArray.forEach(print); //  print()  2 .</span></span></code> </pre> <br>  Un appel à la méthode <code>fastForEach()</code> trois valeurs: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  L'appel de <code>sparseArray.forEach()</code> ne mène qu'à la conclusion de deux valeurs: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Cette différence est due au fait que les spécifications JS concernant l'utilisation des fonctions de rappel indiquent que ces fonctions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne doivent pas être appelées sur des index de tableau distants ou non initialisés</a> (également appelés «trous»).  L' <code>fastForEach()</code> n'a pas vérifié la présence de trous dans le tableau.  Cela a conduit à une augmentation de la vitesse au détriment d'un travail correct avec des tableaux clairsemés.  C'était parfait pour moi, car les tableaux clairsemés n'étaient pas utilisés dans GeoArena. <br><br>  À ce stade, je devrais juste avoir un test rapide sur fast.js.  Je devrais installer la bibliothèque, changer les méthodes standard de l'objet <code>Array</code> en méthodes de fast.js et tester les performances du jeu.  Mais à la place, j'ai évolué dans une direction complètement différente. <br><br><h2>  <font color="#3AC1EF">Mon développement s'appelle plus rapide.js</font> </h2><br>  Le perfectionniste maniaque vivant en moi voulait absolument tout presser pour optimiser les performances du jeu.  La bibliothèque fast.js ne m'a tout simplement pas semblé être une assez bonne solution, car son utilisation impliquait d'appeler ses méthodes.  Puis j'ai pensé: «Et si je remplaçais les méthodes standard des tableaux en incorporant simplement de nouvelles implémentations plus rapides de ces méthodes dans le code?  Cela me sauverait du besoin d'appels de méthode de bibliothèque. » <br><br>  C'est cette idée qui m'a conduit à l'idée ingénieuse, qui était de créer un compilateur, que j'ai appelé effrontément plus <a href="">rapidement.js</a> .  J'avais prévu de l'utiliser au lieu de fast.js.  Par exemple, voici l'extrait de code source: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const arr = [1, 2, 3]; const results = arr.map(e =&gt; 2 * e);</span></span></code> </pre> <br>  Le compilateur fast.js convertirait ce code en ce qui suit - plus rapide, mais en pire: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      faster.js const arr = [1, 2, 3]; const results = new Array(arr.length); const _f = (e =&gt; 2 * e); for (let _i = 0; _i &lt; arr.length; _i++) {  results[_i] = _f(arr[_i], _i, arr); }</span></span></code> </pre> <br>  La création de fast.js a été provoquée par la même idée qui sous-tendait fast.js.  À savoir, nous parlons de micro-optimisations des performances en raison du rejet de la prise en charge des tableaux clairsemés. <br><br>  À première vue, plus rapide.js m'a semblé un développement extrêmement réussi.  Voici quelques résultats d'une étude de performance plus rapide.js: <br><br><pre> <code class="javascript hljs">  array-filter large    ✓ native x <span class="hljs-number"><span class="hljs-number">232</span></span>,<span class="hljs-number"><span class="hljs-number">063</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.36</span></span>% (<span class="hljs-number"><span class="hljs-number">58</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">083</span></span>,<span class="hljs-number"><span class="hljs-number">695</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.58</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">367.0</span></span>% faster (<span class="hljs-number"><span class="hljs-number">3.386</span></span>μs) than native  array-map large    ✓ native x <span class="hljs-number"><span class="hljs-number">223</span></span>,<span class="hljs-number"><span class="hljs-number">896</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">1.10</span></span>% (<span class="hljs-number"><span class="hljs-number">58</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">726</span></span>,<span class="hljs-number"><span class="hljs-number">376</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">1.13</span></span>% (<span class="hljs-number"><span class="hljs-number">60</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">671.1</span></span>% faster (<span class="hljs-number"><span class="hljs-number">3.887</span></span>μs) than native  array-reduce large    ✓ native x <span class="hljs-number"><span class="hljs-number">268</span></span>,<span class="hljs-number"><span class="hljs-number">919</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.41</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">621</span></span>,<span class="hljs-number"><span class="hljs-number">540</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.80</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">503.0</span></span>% faster (<span class="hljs-number"><span class="hljs-number">3.102</span></span>μs) than native  array-reduceRight large    ✓ native x <span class="hljs-number"><span class="hljs-number">68</span></span>,<span class="hljs-number"><span class="hljs-number">671</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.92</span></span>% (<span class="hljs-number"><span class="hljs-number">53</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">571</span></span>,<span class="hljs-number"><span class="hljs-number">918</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">1.16</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">2189.1</span></span>% faster (<span class="hljs-number"><span class="hljs-number">13.926</span></span>μs) than native</code> </pre> <br>  Les résultats complets des tests peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Ils ont eu lieu dans Node v8.16.1, sur le MacBook Pro 15 pouces 2018. <br><br>  Mon développement est-il 2000% plus rapide que l'implémentation standard?  Une augmentation si sérieuse de la productivité est, sans aucun doute, quelque chose qui peut avoir l'impact positif le plus fort sur n'importe quel programme.  Non? <br>  Non, pas vrai. <br><br>  Prenons un exemple simple. <br><br><ul><li>  Imaginez que le jeu GeoArena moyen nécessite 5 000 millisecondes (ms) de calcul. </li><li>  Le compilateur plus rapide.js accélère l'exécution des méthodes de tableau par une moyenne de 10 fois (c'est une estimation approximative, de plus, elle est surestimée; dans la plupart des applications réelles, il n'y a même pas de double accélération). </li></ul><br>  Et voici la question qui nous intéresse vraiment: "Quelle partie de ces 5000 ms est consacrée à l'implémentation des méthodes de tableau?". <br><br>  Supposons que la moitié.  Autrement dit, 2500 ms sont dépensés pour les méthodes de tableau, les 2500 ms restants pour tout le reste.  Si c'est le cas, l'utilisation de fast.js augmentera considérablement les performances. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd3/1fb/d74/cd31fbd7429d4ce60636a7031c657ac2.png"></div><br>  <i><font color="#999999">Exemple conditionnel: le temps d'exécution du programme est très réduit</font></i> <br><br>  En conséquence, il s'avère que le temps de calcul total a été réduit de 45%. <br><br>  Malheureusement, tous ces arguments sont très, très loin de la réalité.  GeoArena, bien sûr, utilise de nombreuses méthodes de tableau.  Mais la distribution réelle du temps d'exécution du code pour différentes tâches ressemble à ceci. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/7b8/2ff/2ae7b82ffd8c59c1632f7bab32d2b7fc.png"></div><br>  <i><font color="#999999">Une dure réalité</font></i> <br><br>  Malheureusement, que puis-je dire. <br><br>  C'est exactement l'erreur dont Donald Knuth a mis en garde.  Je n'ai pas mis mes efforts sur ce à quoi ils devaient s'appliquer, et je ne l'ai pas fait quand cela en valait la peine. <br><br>  Ici, les mathématiques simples entrent en jeu.  Si quelque chose ne prend que 1% du temps d'exécution du programme, son optimisation ne donnera, dans le meilleur des cas, qu'une augmentation de 1% de la productivité. <br><br>  C'est exactement ce que Donald Knuth avait en tête quand il a dit "pas là où c'est nécessaire".  Et si vous pensez à «où vous en avez besoin», il s'avère que ce sont les parties des programmes qui représentent les goulots d'étranglement des performances.  Ce sont les morceaux de code qui contribuent de manière significative à la performance globale du programme.  Ici, le concept de «productivité» est utilisé dans un sens très large.  Il peut inclure le temps d'exécution du programme, la taille de son code compilé et autre chose.  Une amélioration de 10% dans cette partie du programme qui affecte grandement les performances est meilleure qu'une amélioration de 100% dans une petite chose. <br><br>  Knut a également parlé de l'application des efforts "pas lorsque cela était nécessaire".  Le fait est que vous devez optimiser quelque chose uniquement lorsque cela est nécessaire.  Bien sûr, j'avais une bonne raison de penser à l'optimisation.  Mais rappelez-vous que j'ai commencé à développer fast.js et avant cela, je n'ai même pas essayé de tester la bibliothèque fast.js dans GeoArena?  Les minutes passées à tester fast.js dans mon jeu me feraient gagner des semaines de travail.  J'espère que vous ne tomberez pas dans le même piège dans lequel je suis tombé. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Si vous êtes intéressé à expérimenter avec fast.js, vous pouvez jeter un œil à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> démo.  Les résultats que vous obtenez dépendent de votre appareil et de votre navigateur.  Voici, par exemple, ce qui s'est passé dans Chrome 76 sur le MacBook Pro 15 pouces 2018. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08d/7f9/05c/08d7f905cc232d83c0b17a9107d2abd5.png"></div><br>  <i><font color="#999999">Résultats des tests Faster.js</font></i> <br><br>  Vous pourriez être intéressé à en savoir plus sur les résultats réels de l'utilisation de faster.js dans GeoArena.  Moi, quand le jeu était encore à moi (comme je l'ai dit, je l'ai vendu), j'ai effectué quelques recherches de base.  En conséquence, il s'est avéré ce qui suit: <br><br><ul><li>  L'utilisation de faster.js accélère l'exécution du cycle de jeu principal dans un jeu typique d'environ 1%. </li><li>  En raison de l'utilisation de fast.js, la taille de l'ensemble du jeu a augmenté de 0,3%.  Cela ralentit un peu le chargement de la page de jeu.  La taille du bundle a augmenté du fait que fast.js convertit le code court standard en code plus rapide, mais aussi plus long. </li></ul><br>  En général, fast.js a ses avantages et ses inconvénients, mais ce développement du mien n'a pas eu beaucoup d'impact sur les performances de GeoArena.  J'aurais compris cela bien plus tôt si j'avais pris la peine de tester d'abord le jeu en utilisant fast.js. <br><br>  Que mon histoire vous serve d'avertissement. <br><br>  <b>Chers lecteurs!</b>  Êtes-vous tombé dans le piège de l'optimisation prématurée? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465809/">https://habr.com/ru/post/fr465809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465797/index.html">Algorithmes génétiques (ou le client est toujours roi - et souvent un idiot)</a></li>
<li><a href="../fr465801/index.html">Food Design Digest, août 2019</a></li>
<li><a href="../fr465803/index.html">Maven-way pour construire des projets Go</a></li>
<li><a href="../fr465805/index.html">Gigatron - un micro-ordinateur fait maison sans processeur</a></li>
<li><a href="../fr465807/index.html">L'histoire de la façon dont la populaire bibliothèque JavaScript a commencé à afficher des annonces dans le terminal</a></li>
<li><a href="../fr465811/index.html">14 conseils pour écrire du code React propre. Partie 1</a></li>
<li><a href="../fr465813/index.html">14 conseils pour écrire du code React propre. 2e partie</a></li>
<li><a href="../fr465815/index.html">Les scientifiques ont développé des grappes de cellules nerveuses et les ont envoyées à l'ISS</a></li>
<li><a href="../fr465817/index.html">Comment l'inconfort nous aide à améliorer le processus de développement.</a></li>
<li><a href="../fr465819/index.html">LAN idéal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>