<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔴 😤 🧒🏼 优化JavaScript引擎中的原型工作 🏉 💹 👨‍👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="该材料由马蒂亚斯·比恩斯（Matthias Binens）和本尼迪克特·梅勒（Benedict Meirer）编写，我们今天将其翻译成本。 他们正在使用Google的V8 JS引擎。 本文专门介绍一些基本机制，这些机制不仅适用于V8，而且适用于其他引擎。 熟悉此类机制的内部结构，使那些参与JavaS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>优化JavaScript引擎中的原型工作</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422321/"> 该材料由马蒂亚斯·比恩斯（Matthias Binens）和本尼迪克特·梅勒（Benedict Meirer）编写，我们今天将其翻译成本。 他们正在使用Google的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V8</a> JS引擎。 本文专门介绍一些基本机制，这些机制不仅适用于V8，而且适用于其他引擎。 熟悉此类机制的内部结构，使那些参与JavaScript开发的人员可以更好地解决代码性能问题。 特别是，这里我们将讨论引擎优化管道的功能，以及如何加快对对象原型属性的访问。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/za/lq/gg/zalqgg3vwvoc-wprqwob9r0fosq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">代码优化级别和权衡</font> </h2><br> 在不同的引擎中，将用JavaScript编写的程序文本转换为合适的代码以执行的过程看起来几乎相同。 <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/534/0ab/f1e/5340abf1e4b0dfa64f1e2bb294765560.png"></div> <i><font color="#999999">将源JS代码转换为可执行代码的过程</font></i> <br><br> 详细信息可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 另外，应该注意的是，尽管在较高的层次上，不同引擎将源代码转换为可执行文件的流水线非常相似，但是它们的代码优化系统却常常不同。 为什么会这样呢？ 为什么某些引擎比其他引擎具有更高的优化级别？ 事实证明，引擎必须以一种或另一种方式进行折衷，这是因为引擎可以快速生成效率最高但适合执行的代码，也可以花费更多时间创建此类代码，实现最佳性能。 <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e35/973/c56e359735f983dae9b32294192bd26d.png"></div>  <i><font color="#999999">快速准备要执行的代码和优化的代码，所需的时间更长，但运行速度更快</font></i> <br><br> 解释器能够快速生成字节码，但是这种代码通常效率不高。 另一方面，优化的编译器需要更多时间来生成代码，但最终它得到了优化，更快的机器代码。 <br><br>  V8中使用的正是这种准备执行代码的模型。  V8解释器称为Ignition，它是现有解释器中最快的（就执行源字节码而言）。 经过优化的V8编译器称为TurboFan，它负责创建高度优化的机器代码。 <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2b/624/62a/e2b62462a5f2563b27a6c362d031b7f2.png"></div>  <i><font color="#999999">点火解释器和TurboFan优化编译器</font></i> <br><br> 在程序启动延迟和执行速度之间进行权衡是某些JS引擎具有其他优化级别的原因。 例如，在SpiderMonkey中，在解释器和优化编译器IonMonkey之间，存在一个由基本编译器表示的中间级别（在Mozilla <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>称为“基准编译器”，但“基准”不是专有名称）。 <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/212/702/0c821270298b4860ab99918d2dd575a3.png"></div>  <i><font color="#999999">SpiderMonkey代码优化级别</font></i> <br><br> 解释器快速生成字节码，但是这种代码的执行速度相对较慢。 基本编译器需要更长的时间来生成代码，但是该代码已经更快。 最后，优化的IonMonkey编译器会花费最多的时间来生成机器代码，但是可以非常高效地执行该代码。 <br><br> 让我们看一个特定的例子，看看各种引擎的管道如何处理代码。 在此处显示的示例中，有一个“热”循环，其中包含重复多次的代码。 <br><br><pre><code class="hljs matlab">let result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) {    result += <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(result);</code> </pre> <br>  V8开始在Ignition解释器中执行字节码。 在某个时间点，引擎发现代码“很热”，并启动TurboFan前端，该前端是TurboFan的一部分，用于分析数据并创建代码的基本机器表示。 然后将数据传递到TurboFan优化器，并在单独的流中进行操作以进行进一步的改进。 <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/20b/52a/db320b52a7d116d205dc13004852418c.png"></div>  <i><font color="#999999">V8中的热代码优化</font></i> <br><br> 在优化过程中，V8继续在点火中执行字节码。 优化器完成后，我们将提供可执行的机器代码，供将来使用。 <br><br>  SpiderMonkey引擎也开始在解释器中执行字节码。 但是它还有一个由基本编译器表示的附加级别，这导致“热”代码首先到达此编译器这一事实。 它在主线程中生成基本代码，准备就绪后，将转换为执行该代码。 <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef4/782/299/ef4782299d5b523414d85adc16f79d07.png"></div>  <i><font color="#999999">SpiderMonkey中的热代码优化</font></i> <br><br> 如果基本代码运行了足够长的时间，SpiderMonkey最终将启动IonMonkey前端和优化器，这与V8中的情况非常相似。 基本代码将继续运行，作为IonMonkey执行的代码优化过程的一部分。 结果，当优化完成时，将执行优化的代码而不是基本代码。 <br><br>  Chakra引擎的体系结构与SpiderMonkey的体系结构非常相似，但是Chakra努力争取更高级别的并发性，以避免阻塞主线程。  Chakra不会解决主线程中的任何编译任务，而是将编译器可能需要的字节码和配置文件数据复制并发送到一个单独的编译过程中。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/6f7/5e8/f446f75e844d7be0086fde0237f63b9d.png"></div>  <i><font color="#999999">Chakra中的热代码优化</font></i> <br><br> 当SimpleJIT准备的生成代码准备就绪时，引擎将执行它而不是字节码。 重复执行此过程以继续执行FullJIT准备的代码。 这种方法的优点是与复制数据相关的暂停通常比由成熟的编译器（前端）的操作引起的暂停要短得多。 但是，这种方法的缺点在于，启发式复制算法可能会丢失某些信息，这些信息可能对某种优化很有用。 在这里，我们看到一个在接收到的代码质量和延迟之间折衷的例子。 <br><br> 在JavaScriptCore中，所有优化编译任务均与负责执行JavaScript代码的主线程并行执行。 但是，没有复制阶段。 相反，主线程只是在另一个线程中调用编译任务。 然后，编译器使用复杂的锁定方案来访问主线程中的概要分析数据。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f7/0ab/101/2f70ab101c3ea308d1275a44bde4eecd.png"></div>  <i><font color="#999999">JavaScriptCore中“热”代码的优化</font></i> <br><br> 这种方法的优点是，它减少了由于执行代码优化任务而导致的主线程的强制阻塞。 该体系结构的缺点是其实现需要解决多线程数据处理的复杂任务，并且在工作过程中要执行各种操作，必须诉诸于锁。 <br><br> 我们刚刚讨论了引擎被迫做出的权衡，在使用解释器的快速代码生成与使用优化的编译器创建快速代码之间进行选择。 但是，这些远非发动机面临的所有问题。 使用内存时，内存是另一个系统资源，您必须诉诸于妥协解决方案。 为了说明这一点，请考虑一个简单的JS程序，该程序会加上数字。 <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br> 这是由V8中的Ignition解释器生成的<code>add</code>函数的字节码： <br><br><pre> <code class="hljs pgsql">StackCheck Ldar a1 <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span></code> </pre> <br> 您无法理解此字节码的含义，实际上，它对我们而言并不是特别有意义。 这里最主要的是它只有四个指令。 <br><br> 当这样的代码很“热”时，TurboFan被占用，它会生成以下高度优化的机器代码： <br><br><pre> <code class="hljs powershell">leaq rcx,[<span class="hljs-type"><span class="hljs-type">rip</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x0</span></span>] movq rcx,[<span class="hljs-type"><span class="hljs-type">rcx</span></span>-<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x37</span></span>] testb [<span class="hljs-type"><span class="hljs-type">rcx</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xf</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz CompileLazyDeoptimizedCode push rbp movq rbp,rsp push rsi push rdi cmpq rsp,[<span class="hljs-type"><span class="hljs-type">r13</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xe88</span></span>] jna StackOverflow movq rax,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x18</span></span>] test al,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rbx,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x10</span></span>] testb rbx,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rdx,rbx shrq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rcx,rax shrq rcx, <span class="hljs-number"><span class="hljs-number">32</span></span> addl rdx,rcx jo Deoptimize shlq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rax,rdx movq rsp,rbp pop rbp ret <span class="hljs-number"><span class="hljs-number">0</span></span>x18</code> </pre> <br> 如您所见，与上面的四个指令示例相比，代码量非常大。 通常，字节码比机器代码（尤其是优化的机器代码）紧凑得多。 另一方面，需要一个解释器来执行字节码，优化的代码可以直接在处理器上执行。 <br> 这是JavaScript引擎不能完全优化所有代码的主要原因之一。 正如我们前面所看到的，创建优化的机器代码需要花费很多时间，而且，正如我们刚刚发现的那样，它需要更多的内存来存储优化的机器代码。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/c84/e9a/f0bc84e9ac477b1e85eb19f306c99597.png"></div>  <i><font color="#999999">内存使用和优化级别</font></i> <br><br> 结果，我们可以说JS引擎具有不同的优化级别的原因在于以下基本问题：在快速代码生成（例如，使用解释器）和快速代码生成（通过优化编译器执行）之间进行选择。 如果我们讨论引擎中使用的代码优化级别，那么代码越多，代码可以进行的优化就越细微，但这是由于引擎的复杂性和系统上的额外负担而实现的。 另外，在这里我们不能忘记代码的优化级别会影响该代码占用的内存量。 这就是为什么JS引擎尝试仅优化“热”功能的原因。 <br><br><h2>  <font color="#3AC1EF">优化对对象原型属性的访问</font> </h2><br>  JavaScript引擎通过使用所谓的对象表单（Shape）和内联缓存（Inline Cache，IC）来优化对对象属性的访问。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本</a>材料中阅读有关此内容的详细信息，但简而言之，可以说引擎将对象的形状与对象的值分开存储。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c63/861/ba8/c63861ba87ef40cdeea866edefe8b000.png"></div>  <i><font color="#999999">具有相同形状的对象</font></i> <br><br> 使用对象形式可以执行称为内联缓存的优化。 对象形式和内联缓存的共同使用使您可以加快在代码的同一位置执行访问对象属性的重复操作。 <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/5n/cn/mr5ncnmioer4qo4o-aiwlqslo_q.png"></div>  <i><font color="#999999">加快对对象属性的访问</font></i> <br><br><h2>  <font color="#3AC1EF">类和原型</font> </h2><br> 现在，我们知道如何加快对JavaScript中对象属性的访问，让我们看一下最近的JavaScript创新之一-类。 这是类声明的样子： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x;   }   getX() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x;   } }</code> </pre> <br> 尽管看起来像是JS中一个全新概念的出现，但类实际上只是用于构造对象的原型系统的语法糖，JavaScript一直存在该类： <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br> 在这里，我们将函数写入<code>getX</code>对象的<code>getX</code>属性。 此操作与创建任何其他对象的属性时完全相同，因为JavaScript中的原型是对象。 在基于原型使用的语言（例如JavaScript）中，可以由某种类型的所有对象共享的方法存储在原型中，而各个对象的字段存储在其实例中。 <br><br> 让我们看一下在创建<code>Bar</code>对象的新实例并将其分配给常量<code>foo</code>时在后台发生的情况。 <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br> 执行此类代码后，此处创建的对象的实例将具有包含单个属性<code>x</code>的形式。  <code>foo</code>对象的原型是<code>Bar.prototype</code> ，它属于<code>Bar</code>类。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/52a/630/26b52a63051f760544368abc000ff13d.png"></div>  <i><font color="#999999">对象及其原型</font></i> <br><br>  <code>Bar.prototype</code>具有自己的形式，其中包含单个<code>getX</code>属性，该属性的值是一个函数，该函数在调用时将返回<code>this.x</code>的值。 原型<code>Bar.prototype</code>的原型是<code>Object.prototype</code> ，它是语言的一部分。  <code>Object.prototype</code>是原型树的根元素，因此其原型为<code>null</code> 。 <br><br> 现在让我们看看如果创建另一个<code>Bar</code>类型的对象会发生什么。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/972/b2f/7a0972b2f7e264f2e58e399d7f29f5c6.png"></div>  <i><font color="#999999">几个相同类型的对象</font></i> <br><br> 如您所见，正如我们已经说过的，作为<code>Bar</code>类的实例的<code>foo</code>对象和<code>qux</code>对象都使用相同形式的对象。 他们两个都使用相同的原型<code>Bar.prototype</code>对象。 <br><br><h2>  <font color="#3AC1EF">访问原型属性</font> </h2><br> 因此，现在我们知道了在声明一个新类并实例化它时会发生什么。 那么调用对象方法呢？ 考虑以下代码片段： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br> 方法调用可以理解为包含两个步骤的操作： <br><br><pre> <code class="hljs ruby">const x = foo.getX(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         : const $getX = foo.getX; const x = $getX.call(foo);</code> </pre> <br> 第一步，加载方法，这只是原型的属性（其值为函数）。 在第二步中，使用<code>this</code>集合调用一个函数。 考虑从<code>foo</code>对象加载<code>getX</code>方法的第一步： <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b94/46f/291/b9446f291449153c1de7b7f6fafcbb5b.png"></div>  <i><font color="#999999">从foo对象加载getX方法</font></i> <br><br> 引擎分析<code>foo</code>对象，并发现没有<code>foo</code>对象形式的<code>getX</code>属性。 这意味着引擎需要查看对象的原型链才能找到此方法。 引擎访问<code>Bar.prototype</code>原型并查看该原型的对象形状。 在这里，他在偏移量0处找到了所需的属性。接下来， <code>Bar.prototype</code>存储在<code>Bar.prototype</code>中此偏移量的值，在<code>Bar.prototype</code>检测到<code>JSFunction</code>这正是我们要寻找的。 这样就完成了对方法的搜索。 <br><br>  JavaScript的灵活性使更改原型链成为可能。 例如，像这样： <br><br><pre> <code class="hljs pgsql">const foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bar(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); foo.getX(); // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.setPrototypeOf(foo, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); foo.getX(); // Uncaught TypeError: foo.getX <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span></code> </pre> <br> 在此示例中，我们两次调用<code>foo.getX()</code>方法，但是这些调用中的每一个都有完全不同的含义和结果。 这就是为什么尽管JavaScript原型只是对象，但对于JS引擎而言，加速对原型属性的访问比加速对普通对象自身属性的访问更为困难。 <br><br> 如果我们看现实生活中的程序，事实证明加载原型属性是一种非常常见的操作。 每次调用方法时执行。 <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br> 之前，我们讨论了引擎如何通过使用对象表单和内联缓存来优化对象常规，自定义属性的加载。 如何优化具有相同形状的对象的重复原型属性加载？ 上面，我们看到了如何加载属性。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/020/076/65c/02007665c3b9d613e5ccb1daa53a55cd.png"></div>  <i><font color="#999999">从foo对象加载getX方法</font></i> <br><br> 为了通过重复调用该方法来加快对方法的访问，在我们的示例中，您需要了解以下内容： <br><br><ol><li>  <code>foo</code>对象的形状不包含<code>getX</code>方法，并且不会更改。 这意味着不能通过向其添加属性，删除它们或更改属性的属性来修改<code>foo</code>对象。 </li><li>  <code>foo</code>原型仍然是原始的<code>Bar.prototype</code> 。 这意味着原型<code>foo</code>不会使用<code>Object.setPrototypeOf()</code>方法或通过将新的原型分配给特殊的<code>_proto_</code>属性来<code>_proto_</code> 。 </li><li>  <code>Bar.prototype</code>表单包含<code>getX</code>并且不会更改。 也就是说，不会通过删除属性，添加属性或更改其属性来更改<code>Bar.prototype</code> 。 </li></ol><br> 在一般情况下，这意味着我们需要对对象本身进行1次检查，对每个原型进行2次检查，直到存储所需属性的原型为止。 也就是说，您需要进行1 + 2N次检查（其中N是经过测试的原型的数量），在这种情况下，看起来并不那么糟糕，因为原型链非常短。 但是，引擎通常必须使用更长的原型链。 例如，这是普通DOM元素的典型代表。 这是一个例子： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br> 在这里，我们有<code>HTMLAnchorElement</code> ，我们将其称为<code>getAttribute()</code>方法。 表示HTML链接的这个简单元素的原型链包括6个原型！ 最有趣的DOM方法不在其自己的原型<code>HTMLAnchorElement</code> 。 它们位于位于链下端的原型中。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/753/e76/10d/753e7610da32acbfd576fd0c61226bc7.png"></div>  <i><font color="#999999">原型链</font></i> <br><br>  <code>getAttribute()</code>方法可以在<code>Element.prototype</code>找到。 这意味着每次<code>anchor.getAttribute()</code>方法时，引擎都会被强制执行以下操作： <br><br><ol><li> 检查<code>anchor</code>对象本身是否有<code>getAttribute</code> 。 </li><li> 验证对象的直接原型是<code>HTMLAnchorElement.prototype</code> 。 </li><li> 发现<code>HTMLAnchorElement.prototype</code>没有<code>getAttribute</code>方法。 </li><li> 验证下一个原型是<code>HTMLElement.prototype</code> 。 </li><li> 发现这里没有必要的方法。 </li><li> 最后，发现下一个原型是<code>Element.prototype</code> 。 </li><li> 发现有一个<code>getAttribute</code>方法。 </li></ol><br> 如您所见，这里执行了7次检查。 由于此类代码在Web编程中非常常见，因此引擎使用优化来减少加载原型属性所需的检查次数。 <br><br> 如果我们回到前面的示例之一，我们可以回想一下，当我们调用<code>getX</code>对象的<code>getX</code>方法时，我们执行3次检查： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br> 对于原型链中的每个对象（直到包含所需属性的对象），我们只需要检查对象的形状即可发现是否缺少所需的内容。 如果我们可以通过减少原型检查来检查我们要查找的内容是否存在来减少检查的数量，那将是很好的。 这就是引擎通过一个简单的动作来完成的：引擎不是将原型链接存储在实例本身中，而是以对象的形式存储它。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/643/1d0/c33/6431d0c33d2d03bea86e6adfffed4569.png"></div>  <i><font color="#999999">原型参考存储</font></i> <br><br> 每个表格都有一个原型链接。 这也意味着，只要原型<code>foo</code>发生变化，引擎就会移动到对象的新形状。 现在，我们只需要检查对象的形状以了解其中是否存在属性，并注意保护原型链接。 <br><br> 通过这种方法，我们可以将检查次数从1 + 2N减少到1 + N，这将加快对原型属性的访问。 但是，由于此类操作的数量与原型链的长度之间存在线性关系，因此此类操作仍会占用大量资源。 引擎已经实现了各种机制，旨在确保检查次数不取决于原型链的长度（表示为常数）。 在多次加载同一属性的情况下尤其如此。 <br><br><h2>  <font color="#3AC1EF">ValidityCell属性</font> </h2><br>  V8是指专门用于上述目的的原型形式。 每个原型都具有不与其他对象（特别是与其他原型）共享的唯一形状，并且每个原型对象形式都有与之关联的<code>ValidityCell</code>属性。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fb/f9c/3f9/7fbf9c3f987b8def69855e849c71c01a.png"></div>  <i><font color="#999999">ValidityCell属性</font></i> <br><br> 更改与表单关联的原型或任何覆盖的原型时，此属性被声明为无效。 更详细地考虑此机制。 <br><br> 为了加快从原型加载属性的顺序操作，V8使用了一个内联缓存，其中包含四个字段： <code>ValidityCell</code> ， <code>Prototype</code> ， <code>Shape</code>和<code>Offset</code> 。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/a3b/04f/0baa3b04faebad191e769279c6eb1cd8.png"></div>  <i><font color="#999999">内联缓存字段</font></i> <br><br> 在第一次运行代码时， <code>Bar.prototype</code>联缓存“预热”期间，V8会记住在原型中找到属性的偏移量，在其中找到属性的原型（在此示例中为<code>Bar.prototype</code> ），对象的形状（在此情况下为<code>foo</code> ） ，此外，还有指向即时原型的当前<code>ValidityCell</code>参数的链接，该链接以对象的形式（在这种情况下，它也是<code>Bar.prototype</code> ）。 <br><br> 下次访问内联缓存时，引擎将需要检查对象和<code>ValidityCell</code>的形状。 如果<code>ValidityCell</code>仍然有效，则引擎可以直接利用原型中先前保存的偏移量，而无需执行其他搜索操作。 <br><br> 当原型发生更改时，将创建一个新表单，并将先前的<code>ValidityCell</code>属性声明为无效。 因此，下次尝试访问嵌入式缓存时，它不会带来任何好处，从而导致性能降低。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/c30/c97/c95c30c97ee0429bf1400163309c6354.png"></div>  <i><font color="#999999">改变原型的后果</font></i> <br><br> 如果我们返回带有DOM元素的示例，这意味着任何更改，例如<code>Object.prototype</code>的原型， <code>Object.prototype</code>会导致<code>Object.prototype</code>本身的内联缓存无效，还会使原型链中位于其下方的任何原型无效。包括<code>EventTarget.prototype</code> ， <code>Node.prototype</code> ， <code>Element.prototype</code>等，一直到<code>HTMLAnchorElement.prototype</code> 。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/5f7/ff7/4445f7ff7b11c00e40aeac4fd1945ae1.png"></div>  <i><font color="#999999">更改Object.prototype的含义</font></i> <br><br> 实际上，在代码执行期间修改<code>Object.prototype</code>意味着严重损害性能。 不要这样做。 <br><br> 我们以一个例子研究上述内容。 假设我们具有<code>Bar</code>类和<code>loadX</code>函数，该函数调用从<code>Bar</code>类创建的对象的方法。 我们多次调用<code>loadX</code>函数，并将相同类的实例传递给它。 <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); // IC  <span class="hljs-string"><span class="hljs-string">'getX'</span></span>   `Bar`. } loadX(new Bar(true)); loadX(new Bar(false)); // IC  `loadX`    `ValidityCell`  // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // `ValidityCell`  IC `loadX`   //    `Object.prototype`  .</code> </pre> <br> 现在， <code>loadX</code>的<code>loadX</code>缓存指向<code>Bar.prototype</code> 。  , ,  <code>Object.prototype</code> —    JavaScript,   <code>ValidityCell</code>  ,   -          ,     . <br><br>  <code>Object.prototype</code> —   ,        -      ,       .     ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//    : someObject.foo(); //     . delete Object.prototype.foo;</span></span></code> </pre> <br>   <code>Object.prototype</code> ,     - ,   .     ,    .      -   ,          .       , «  »,   ,  . <br><br> ,  ,  .             .    <code>Object.prototype</code> ,   ,   -            . <br><br>       ,    —   , JS-    -  ,       .        .       ,     ,      .  ,   ,       ,      . <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br>       ,  JS-    ,  ,   , -,  <code>ValidityCell</code>   ,     .            JavaScript,    ,       (       , ,  ,        ). <br><br>  <b>亲爱的读者们！</b>       ,    - ,   JS,          ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN422321/">https://habr.com/ru/post/zh-CN422321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN422309/index.html">如何在云神经网络中保护数据-提出了一种新的加密方法</a></li>
<li><a href="../zh-CN422311/index.html">python的有趣性和实用性。 第二部分</a></li>
<li><a href="../zh-CN422315/index.html">如何在Bug猎人中生存：每天为收入而挣扎</a></li>
<li><a href="../zh-CN422317/index.html">为什么TPU对深度学习如此好？</a></li>
<li><a href="../zh-CN422319/index.html">俄罗斯团队首次进入最大的科学加速器IndieBio</a></li>
<li><a href="../zh-CN422323/index.html">黑客：俄罗斯和中国</a></li>
<li><a href="../zh-CN422325/index.html">关于测试的DevDay：放松。 轻松测试</a></li>
<li><a href="../zh-CN422327/index.html">项目进度与未完成订单：没有机会的战斗</a></li>
<li><a href="../zh-CN422329/index.html">银行无现金支付的信息安全。 第8部分-典型威胁模型</a></li>
<li><a href="../zh-CN422331/index.html">混合自助结帐柜台如何提高商店效率</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>