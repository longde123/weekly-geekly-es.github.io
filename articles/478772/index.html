<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß‚Äçüëß ‚ôèÔ∏è üêÜ Textura convolucional üêå üïâÔ∏è üë¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Texturas de actualizaci√≥n autom√°tica 
 Cuando es posible paralelizar simulaciones o tareas de renderizado, generalmente es mejor ejecutarlas en la GPU...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Textura convolucional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478772/"><h2>  Texturas de actualizaci√≥n autom√°tica </h2><br>  Cuando es posible paralelizar simulaciones o tareas de renderizado, generalmente es mejor ejecutarlas en la GPU.  En este art√≠culo, explicar√© una t√©cnica que utiliza este hecho para crear trucos visuales impresionantes con una sobrecarga de bajo rendimiento.  Todos los efectos que demostrar√© se implementan utilizando texturas que, cuando se actualizan, "se <em>representan</em> ";  la textura se actualiza cuando se procesa un nuevo marco, y el siguiente estado de textura depende completamente del estado anterior.  En estas texturas, puede dibujar, causando ciertos cambios, y la textura en s√≠, directa o indirectamente, puede usarse para generar animaciones interesantes.  Los llamo <em>texturas convolucionales</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/756/a1a/005/756a1a0051471cbe895a8883d89efadd.jpg"></div><br>  <i>Figura 1: convoluci√≥n doble buffering</i> <br><br>  Antes de continuar, necesitamos resolver un problema: la textura no se puede leer y escribir al mismo tiempo, API gr√°ficas como OpenGL y DirectX no lo permiten.  Dado que el siguiente estado de la textura depende del anterior, debemos evitar esta limitaci√≥n de alguna manera.  Necesito leer desde una textura diferente, no desde la que estoy escribiendo. <br><br>  La soluci√≥n es el <em>doble buffering</em> .  La Figura 1 muestra c√≥mo funciona: de hecho, en lugar de una textura, hay dos, pero una est√° escrita y una se lee de la otra.  La textura en la que se est√° escribiendo se denomina <em>b√∫fer posterior</em> , y la textura renderizada se denomina <em>b√∫fer frontal</em> .  Dado que la prueba convolucional se "escribe a s√≠ misma", el b√∫fer secundario en cada cuadro escribe en el b√∫fer primario, y luego el primario se representa o se utiliza para la representaci√≥n.  En el siguiente marco, los roles cambian y el b√∫fer primario anterior se usa como la fuente del pr√≥ximo b√∫fer primario. <br><a name="habracut"></a><br>  Al representar el estado anterior a una nueva textura de convoluci√≥n utilizando el sombreador de fragmentos (o <em>sombreador de p√≠xeles</em> ), se obtienen interesantes efectos y animaciones.  El sombreador determina c√≥mo cambia el estado.  El c√≥digo fuente para todos los ejemplos del art√≠culo (as√≠ como otros) se puede encontrar en el <a href="https://github.com/jobtalle/ConvolutionalTextures">repositorio en GitHub</a> . <br><br><h2>  Ejemplos de aplicaciones simples </h2><br>  Para demostrar esta t√©cnica, eleg√≠ una simulaci√≥n bien conocida en la que, al actualizar, el estado depende completamente del estado anterior: el <em>juego de Conway "Life"</em> .  Esta simulaci√≥n se realiza en una cuadr√≠cula de cuadrados, cada una de las cuales est√° viva o muerta.  Las reglas para el siguiente estado de celda son simples: <br><br><ul><li>  Si una c√©lula viva tiene menos de dos vecinos, pero se convierte en muerta. </li><li>  Si una c√©lula viva tiene dos o tres vecinos vivos, permanece viva. </li><li>  Si una c√©lula viva tiene m√°s de tres vecinos vivos, se convierte en muerta. </li><li>  Si una celda muerta tiene tres vecinos vivos, se vuelve viva. </li></ul><br>  Para implementar este juego como una textura convolucional, interpreto la textura como la cuadr√≠cula del juego, y el sombreador se renderiza seg√∫n las reglas anteriores.  Un p√≠xel transparente es una c√©lula muerta, y un p√≠xel blanco opaco es una c√©lula viva.  Una implementaci√≥n interactiva se muestra a continuaci√≥n.  Para acceder a la GPU, uso <a href=""><em>myr.js</em></a> , que requiere <em>WebGL 2</em> .  La mayor√≠a de los navegadores modernos (por ejemplo, Chrome y Firefox) pueden funcionar con √©l, pero si la demostraci√≥n no funciona, lo m√°s probable es que el navegador no lo admita.  Use el mouse (o la pantalla t√°ctil) [en el art√≠culo original] para dibujar celdas vivas en la textura. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SQ3EKUPm8FY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  El c√≥digo del sombreador de fragmentos (en GLSL, porque uso WebGL para renderizar) se muestra a continuaci√≥n.  Primero, implemento la funci√≥n <code>get</code> , que me permite leer un p√≠xel de un desplazamiento espec√≠fico del actual.  La variable <code>pixelSize</code> es un vector 2D predefinido que contiene el desplazamiento UV de cada p√≠xel, y la funci√≥n <code>get</code> utiliza para leer la celda vecina.  Luego, la funci√≥n <code>main</code> determina el nuevo color de la celda en funci√≥n del estado actual ( <code>live</code> ) y el n√∫mero de vecinos vivos. <br><br><pre> <code class="cpp hljs">uniform sampler2D source; uniform lowp vec2 pixelSize; in mediump vec2 uv; layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out lowp vec4 color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(texture(source, uv + pixelSize * vec2(dx, dy)).r); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> live = get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbors = get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; (neighbors == <span class="hljs-number"><span class="hljs-number">2</span></span> || neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>)) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Otra textura convolucional simple es un <em>juego con arena que cae</em> , en el que el usuario puede arrojar arena colorida a la escena, que cae y forma monta√±as.  Aunque su implementaci√≥n es un poco m√°s complicada, las reglas son m√°s simples: <br><br><ul><li>  Si no hay arena debajo de un grano de arena, entonces cae un p√≠xel hacia abajo. </li><li>  Si hay arena debajo de un grano de arena, pero puede deslizarse 45 grados hacia la izquierda o hacia la derecha, entonces lo har√°. </li></ul><br>  La gesti√≥n en este ejemplo es la misma que en el juego "Vida".  Dado que bajo tales reglas, la arena puede caer a una velocidad de solo un p√≠xel por fotograma para acelerar ligeramente el proceso, la textura por fotograma se actualiza tres veces.  El c√≥digo fuente de la aplicaci√≥n est√° <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/sand.html">aqu√≠</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MV10ScILiAY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Un paso adelante </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Canal</b> </td><td>  <b>Solicitud</b> </td></tr><tr><td>  Rojo </td><td>  Altura de la ola </td></tr><tr><td>  Verde </td><td>  Velocidad de la ola </td></tr><tr><td>  Azul </td><td>  <i>No utilizado</i> </td></tr><tr><td>  Alfa </td><td>  <i>No utilizado</i> </td></tr></tbody></table></div><br>  <i>Figura 2: Pixel Waves.</i> <br><br>  Los ejemplos anteriores usan textura convolucional directamente;  su contenido se representa en la pantalla tal como est√°.  Si interpreta las im√°genes solo como p√≠xeles, los l√≠mites de uso de esta t√©cnica son muy limitados, pero gracias a los equipos modernos pueden ampliarse.  En lugar de contar los p√≠xeles como colores, los interpretar√© de manera un poco diferente, lo que se puede usar para crear animaciones de otra textura o modelo 3D. <br><br>  Primero, interpretar√© la textura convolucional como un mapa de altura.  La textura simular√° <em>ondas</em> y <em>vibraciones</em> en el plano del agua, y los resultados se utilizar√°n para generar reflejos y ondas sombreadas.  Ya no estamos obligados a leer la textura como una imagen, por lo que podemos usar sus p√≠xeles para almacenar cualquier informaci√≥n.  En el caso de un sombreador de agua, almacenar√© la altura de la ola en el canal rojo y el pulso de la ola en el canal verde, como se muestra en la Figura 2. Los canales azul y alfa a√∫n no se utilizan.  Las ondas se crean dibujando manchas rojas en una textura convolucional. <br><br>  No considerar√© la metodolog√≠a para actualizar el mapa de altura, que tom√© prestado del sitio web de <em>Hugo Elias</em> , que parece haber desaparecido de Internet.  Tambi√©n aprendi√≥ sobre este algoritmo de un autor desconocido y lo implement√≥ en C para su ejecuci√≥n en la CPU.  El c√≥digo fuente de la aplicaci√≥n a continuaci√≥n est√° <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/water.html">aqu√≠</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/h8GjEGMV8AE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Aqu√≠ utilic√© un mapa de altura solo para compensar la textura y agregar sombreado, pero en la tercera dimensi√≥n, se pueden implementar aplicaciones mucho m√°s interesantes.  Cuando un sombreador de v√©rtices interpreta una textura convolucional, un plano plano subdividido puede distorsionarse para crear ondas tridimensionales.  Puede aplicar el sombreado y la iluminaci√≥n habituales a la forma resultante. <br><br>  Vale la pena se√±alar que los p√≠xeles en la textura convolucional del ejemplo que se muestra arriba a veces almacenan valores muy peque√±os que no deber√≠an desaparecer debido a errores de redondeo.  Por lo tanto, los canales de color de esta textura deben tener una resoluci√≥n m√°s alta, y no los 8 bits est√°ndar.  En este ejemplo, aument√© el tama√±o de cada canal de color a 16 bits, lo que dio resultados bastante precisos.  Si no est√° almacenando p√≠xeles, a menudo necesita aumentar la precisi√≥n de la textura.  Afortunadamente, las API gr√°ficas modernas admiten esta funci√≥n. <br><br><h2>  Utilizamos todos los canales </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Canal</b> </td><td>  <b>Solicitud</b> </td></tr><tr><td>  Rojo </td><td>  Desplazamiento X </td></tr><tr><td>  Verde </td><td>  Desplazamiento Y </td></tr><tr><td>  Azul </td><td>  X velocidad </td></tr><tr><td>  Alfa </td><td>  Desplazamiento Y </td></tr></tbody></table></div><br>  <i>Figura 3: Pixel grass.</i> <br><br>  En el ejemplo del agua, solo se usan los canales rojo y verde, pero en el siguiente ejemplo, aplicaremos los cuatro.  Se simula un campo con c√©sped (o √°rboles), que se puede mover con el cursor.  La Figura 3 muestra qu√© datos se almacenan en un p√≠xel.  La compensaci√≥n se almacena en los canales rojo y verde, y la velocidad se almacena en los canales azul y alfa.  Esta velocidad se actualiza para cambiar hacia la posici√≥n de reposo con un movimiento de onda que se desvanece gradualmente. <br><br>  En el ejemplo con agua, crear ondas es bastante simple: se pueden dibujar manchas en la textura y la mezcla alfa proporciona formas suaves.  Puede crear f√°cilmente m√∫ltiples puntos superpuestos.  En este ejemplo, todo es m√°s complicado porque el canal alfa ya est√° en uso.  No podemos dibujar un punto con un valor alfa de 1 en el centro y 0 desde el borde, porque esto le dar√° a la hierba un impulso innecesario (ya que el impulso vertical se almacena en el canal alfa).  En este caso, se escribi√≥ un sombreador separado para dibujar el efecto en la textura convolucional.  Este sombreador asegura que la mezcla alfa no produzca efectos inesperados. <br><br>  El c√≥digo fuente de la aplicaci√≥n se puede encontrar <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/grass.html">aqu√≠</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oBqQL7HViLE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Grass se crea en 2D, pero el efecto funcionar√° en entornos 3D.  En lugar del desplazamiento de p√≠xeles, los v√©rtices se desplazan, lo que tambi√©n es m√°s r√°pido.  Adem√°s, con la ayuda de los picos, se puede lograr otro efecto: diferente fuerza de las ramas: la hierba se dobla con facilidad con el viento m√°s leve, y los √°rboles fuertes fluct√∫an solo durante las tormentas. <br><br>  Aunque existen muchos algoritmos y sombreadores para crear los efectos del viento y el desplazamiento de la vegetaci√≥n, este enfoque tiene una gran ventaja: dibujar efectos sobre una textura convolucional es un proceso de muy bajo costo.  Si el efecto se aplica en un juego, entonces el movimiento de la vegetaci√≥n puede ser determinado por cientos de influencias diferentes.  No solo el personaje principal, sino tambi√©n todos los objetos, animales y movimientos pueden influir en el mundo a expensas de costos insignificantes. <br><br><h2>  Otros casos de uso y defectos </h2><br>  Puede crear muchas otras aplicaciones de tecnolog√≠a, por ejemplo: <br><br><ul><li>  Usando una textura convolucional, puede simular la velocidad del viento.  En la textura, puede dibujar obst√°culos que hacen que el aire los rodee.  Las part√≠culas (lluvia, nieve y hojas) pueden usar esta textura para volar alrededor de obst√°culos. </li><li>  Puede simular la propagaci√≥n de humo o fuego. </li><li>  La textura puede codificar el grosor de una capa de nieve o arena.  Los rastros y otras interacciones con la capa pueden crear abolladuras e impresiones en la capa. </li></ul><br>  Al usar este m√©todo, existen dificultades y limitaciones: <br><br><ul><li>  Es dif√≠cil ajustar las animaciones a las velocidades de cuadro cambiantes.  Por ejemplo, en una aplicaci√≥n con arena que cae, los granos de arena caen a una velocidad constante: un p√≠xel por actualizaci√≥n.  Una posible soluci√≥n puede ser actualizar las texturas convolucionales con una frecuencia constante, similar a la forma en que funcionan la mayor√≠a de los motores f√≠sicos;  El motor de f√≠sica funciona a una frecuencia constante y sus resultados se interpolan. </li><li>  La transferencia de datos a la GPU es un proceso r√°pido y f√°cil, sin embargo, recuperar datos no es tan f√°cil.  Esto significa que la mayor√≠a de los efectos generados por esta t√©cnica son unidireccionales;  se transfieren a la GPU, y la GPU hace su trabajo sin m√°s intervenci√≥n y comentarios.  Si quisiera incorporar la longitud de onda del ejemplo del agua en los c√°lculos f√≠sicos (por ejemplo, para que los barcos oscilaran junto con las olas), necesitar√≠a valores de la textura convolucional.  Recuperar datos de textura de una GPU es un proceso extremadamente lento que no necesita hacerse en tiempo real.  La soluci√≥n a este problema puede ser la implementaci√≥n de dos simulaciones: una con una resoluci√≥n alta para gr√°ficos de agua como textura convolucional, la otra con una resoluci√≥n baja en la CPU para f√≠sica del agua.  Si los algoritmos son los mismos, entonces las discrepancias pueden ser bastante aceptables. </li></ul><br>  Las demostraciones en este art√≠culo pueden optimizarse a√∫n m√°s.  En el ejemplo del c√©sped, puede usar una textura con una resoluci√≥n mucho menor sin defectos notables;  Esto ayudar√° mucho en escenas grandes.  Otra optimizaci√≥n: puede usar una frecuencia de actualizaci√≥n m√°s baja, por ejemplo, en cada cuarto cuadro, o un cuarto por cuadro (ya que esta t√©cnica no causa problemas con las actualizaciones segmentadas).  Para mantener una velocidad de fotogramas uniforme, se puede interpolar el estado anterior y actual de la textura convolucional. <br><br>  Dado que las texturas convolucionales usan doble buffer interno, puede usar ambas texturas al mismo tiempo para renderizar.  El b√∫fer primario es el estado actual, y el secundario es el anterior.  Esto puede ser √∫til para interpolar la textura a lo largo del tiempo o para calcular derivados para valores de textura. <br><br><h2>  Conclusi√≥n </h2><br>  Las GPU, especialmente en programas 2D, a menudo est√°n inactivas.  Aunque parece que solo se puede usar para representar escenas 3D complejas, la t√©cnica demostrada en este art√≠culo muestra al menos otra forma de usar la potencia de la GPU.  Usando las capacidades para las cuales se desarroll√≥ la GPU, puede implementar efectos y animaciones interesantes que generalmente son demasiado costosos para la CPU. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/478772/">https://habr.com/ru/post/478772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../478750/index.html">Bibliotecas de visualizaci√≥n de datos reales para desarrolladores de reacci√≥n</a></li>
<li><a href="../478752/index.html">Historia de los sistemas de control de versiones</a></li>
<li><a href="../478758/index.html">Gran gu√≠a de etiquetas UTM: c√≥mo averiguar de d√≥nde vienen los usuarios</a></li>
<li><a href="../478760/index.html">Infierno "cero" y c√≥mo salir de √©l</a></li>
<li><a href="../478764/index.html">Errores de JavaScript: arreglar, procesar, reparar</a></li>
<li><a href="../478774/index.html">Humor de A√±o Nuevo de Arduino y palos</a></li>
<li><a href="../478778/index.html">Habra detective y humor festivo</a></li>
<li><a href="../478782/index.html">Obtenci√≥n de permiso para volar un avi√≥n no tripulado (BVS, UAV) en la Federaci√≥n de Rusia</a></li>
<li><a href="../478788/index.html">En un cierto reino, no en un estado "brusco". Informe Yandex</a></li>
<li><a href="../478790/index.html">Julia y sem√°ntica de distribuci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>