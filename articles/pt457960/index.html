<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÄ üëï üò± Sala de reuni√µes LÃ∂iÃ∂tÃ∂tÃ∂lÃ∂eÃ∂ Helper v 2 ‚ÄºÔ∏è üëó ‚úçüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo descreve em detalhes os est√°gios de desenvolvimento do aplicativo m√≥vel Meeting Room Helper: desde o in√≠cio da ideia at√© o lan√ßamento. O a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sala de reuni√µes LÃ∂iÃ∂tÃ∂tÃ∂lÃ∂eÃ∂ Helper v 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/457960/">  Este artigo descreve em detalhes os est√°gios de desenvolvimento do aplicativo m√≥vel Meeting Room Helper: desde o in√≠cio da ideia at√© o lan√ßamento.  O aplicativo √© escrito em Kotlin e constru√≠do em uma arquitetura MVVM simplificada, sem o uso de liga√ß√£o de dados.  A parte da interface do usu√°rio √© atualizada usando objetos LiveData.  As raz√µes para recusar a liga√ß√£o de dados s√£o detalhadas e explicadas.  A arquitetura utiliza v√°rias solu√ß√µes interessantes que permitem dividir logicamente o programa em arquivos pequenos, o que simplifica o suporte ao c√≥digo. <br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><img src="https://habrastorage.org/webt/ii/at/pf/iiatpf_m3syq_8mzu08bkaqiy4u.jpeg"><br><a name="habracut"></a><br><h2>  Descri√ß√£o do Projeto </h2><br>  H√° 3 anos, nossa empresa teve a id√©ia de desenvolver um pequeno projeto para reservas instant√¢neas de salas de reuni√£o.  A maioria dos gerentes de RH e Arcadia prefere usar o calend√°rio do Outlook para tais fins, mas e o resto? <br><br>  Vou dar 2 exemplos da vida do desenvolvedor <br><br><ol><li>  <i>Qualquer equipe periodicamente tem um desejo espont√¢neo de realizar um rali r√°pido por 5 a 10 minutos.</i>  <i>Esse desejo pode ultrapassar os desenvolvedores em qualquer canto do escrit√≥rio e, para n√£o distrair os colegas ao redor deles, eles (desenvolvedores e n√£o apenas) come√ßam a procurar uma conversa gratuita.</i>  <i>Ao migrar de uma sala para outra (em nosso escrit√≥rio, as salas de reuni√£o s√£o organizadas em sequ√™ncia), os colegas ‚Äúverificam cuidadosamente‚Äù qual das salas est√° atualmente livre.</i>  <i>Como resultado, eles distraem colegas de dentro.</i>  <i>Esses caras sempre foram e sempre ser√£o, mesmo que o tiroteio seja encerrado no estatuto da empresa pela interrup√ß√£o do rali.</i>  <i>Quem entendeu, ele vai entender.</i> </li><li>  <i>E aqui est√° outro caso.</i>  <i>Voc√™ acabou de sair da sala de jantar e est√° indo para si mesmo, mas aqui seu colega (ou gerente) de outro departamento o intercepta.</i>  <i>Ele quer lhe dizer algo urgente e, para esses fins, voc√™ precisa de uma sala de reuni√µes.</i>  <i>De acordo com os regulamentos, voc√™ deve primeiro reservar um quarto (pelo telefone ou computador) e s√≥ depois ocup√°-lo.</i>  <i>√â bom se voc√™ tiver um telefone celular com o Outlook m√≥vel.</i>  <i>E se n√£o?</i>  <i>Voltar ao computador e voltar para a sala de reuni√µes?</i>  <i>Para for√ßar cada funcion√°rio a colocar o Outlook Express no telefone e garantir que todos os carreguem com eles?</i>  <i>Estes n√£o s√£o nossos m√©todos.</i> </li></ol><br>  Por isso, h√° 2,5 anos, cada uma das salas de reuni√£o estava equipada com seu pr√≥prio tablet: <br><br><img src="https://habrastorage.org/webt/kp/2i/ao/kp2iao0nromcb1wa-iewgzxurw0.png"><br><br>  Para este projeto, meu colega desenvolveu a primeira vers√£o do aplicativo: Meeting Room Little Helper ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui voc√™ pode ler sobre isso</a> ).  MRLH permitiu fazer uma reserva, cancelar e renovar uma reserva, mostrou o status das conversas restantes.  O reconhecimento da identidade de um funcion√°rio (usando o servi√ßo de nuvem Microsoft Face API e nossos analisadores internos) tornou-se um "truque" inovador.  O aplicativo acabou sendo s√≥lido e serviu a empresa fielmente por 2,5 anos. <br><br>  Mas o tempo passou ... Novas id√©ias apareceram.  Eu queria algo novo e, por isso, decidimos reescrever o aplicativo. <br><br><h3>  Termos de Refer√™ncia </h3><br>  Como costuma acontecer - mas, infelizmente, nem sempre - o desenvolvimento come√ßou com a prepara√ß√£o de especifica√ß√µes t√©cnicas.  Primeiro, chamamos os caras que costumam usar tablets para reservas.  Aconteceu que, acima de tudo, eles eram viciados em RHs e gerentes que anteriormente usavam o Outlook exclusivamente.  Deles, recebemos o seguinte feedback (dos requisitos, fica imediatamente claro o que o RH solicitou e o que os gerentes pediram): <br><br><ul><li>  voc√™ deve adicionar a capacidade de reservar qualquer sala de reuni√£o a partir de qualquer tablet (anteriormente, cada tablet permitia reservar apenas sua sala); </li><li>  seria legal olhar para o cronograma de com√≠cios para uma reuni√£o o dia inteiro (idealmente, para qualquer dia); </li><li>  todo o ciclo de desenvolvimento deve ser realizado em um curto espa√ßo de tempo (por 6-7 semanas). </li></ul><br>  Tudo est√° claro com os desejos do cliente, mas e os requisitos t√©cnicos e o futuro?  Adicione alguns requisitos para o projeto da guilda de desenvolvedores: <br><br><ul><li>  O sistema deve funcionar tanto com os tablets existentes quanto com os novos; </li><li>  escalabilidade do sistema - a partir de 50 conversas ou mais (isso deve ser suficiente com uma margem para a maioria dos clientes se o sistema come√ßar a se replicar); </li><li>  manuten√ß√£o da funcionalidade anterior (a primeira vers√£o do aplicativo usava a API Java para se comunicar com os servi√ßos do Outlook, e planej√°vamos substitu√≠-la por uma API especializada do Microsoft Graph, por isso era importante n√£o perder a funcionalidade); </li><li>  minimiza√ß√£o do consumo de energia (os tablets s√£o alimentados por uma bateria externa, porque o centro de neg√≥cios n√£o permitiu perfurar suas paredes para colocar nossos fios); </li><li>  novo design UX / UI, refletindo ergonomicamente todas as inova√ß√µes. </li></ul><br>  Total de 8 pontos.  Os requisitos s√£o razoavelmente justos.  Al√©m disso, estipulamos as regras gerais de desenvolvimento: <br><br><ul><li>  use apenas tecnologias avan√ßadas (isso permitir√° que a equipe se desenvolva como especialista e n√£o fique estagnada em um s√≥ lugar, simplificando o suporte ao projeto em um futuro pr√≥ximo); </li><li>  seguir as melhores pr√°ticas, mas n√£o as tome cegamente como garantidas, pois  a regra principal de qualquer profissional (e um desenvolvedor que se esfor√ßa por isso) √© avaliar tudo criticamente; </li><li>  escrever c√≥digo limpo e organizado (talvez seja o mais dif√≠cil quando voc√™ estiver tentando combinar inova√ß√£o e tempo de desenvolvimento apertado). </li></ul><br>  Foi iniciado.  Como sempre, est√° entusiasmado!  Vamos ver o que acontece a seguir. <br><br><h3>  Desenho </h3><br>  Design de aplicativo desenvolvido pelo designer UX: <br><br><img src="https://habrastorage.org/webt/gm/n9/eo/gmn9eox4exzhczkq0zdbkiwrgt8.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Esta √© a tela principal.  Ser√° exibido na maioria das vezes.  Todas as informa√ß√µes necess√°rias est√£o localizadas ergonomicamente aqui: <br><br><ul><li>  o nome da sala e seu n√∫mero; </li><li>  status atual; </li><li>  tempo at√© a pr√≥xima reuni√£o (ou at√© o final); </li><li>  os status dos quartos restantes na parte inferior da tela. </li></ul><br>  Observe: o mostrador exibe apenas 12 horas, como  o sistema est√° configurado de acordo com as necessidades da empresa (os tablets Arcadia funcionam das 8 √†s 20 horas, ligam e desligam automaticamente) <br><br><img src="https://habrastorage.org/webt/cg/r_/92/cgr_9220jaeqzpjtu4godm1vojw.gif"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Para reservar um quarto, basta ligar para a janela de reservas e indicar a dura√ß√£o do rali.  As etapas para reservar os quartos restantes s√£o semelhantes; elas apenas come√ßam clicando no √≠cone do quarto. <br><br><img src="https://habrastorage.org/webt/d7/qr/wm/d7qrwmogkdzvjtdea0y80vjlti4.jpeg"><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Se voc√™ deseja agendar uma reuni√£o para um hor√°rio espec√≠fico, v√° para a pr√≥xima guia, para a lista de reuni√µes que ocorrer√£o hoje na sala de reuni√µes e clique em tempo livre.  Al√©m disso, tudo √© como no primeiro caso. <br><br>  A √°rvore de transi√ß√£o completa deve se parecer com isso: <br><br><img src="https://habrastorage.org/webt/p8/ex/lb/p8exlbbiuflfbasflet3vsepzdu.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Vamos tentar implement√°-lo com compet√™ncia. <br><br><h3>  Pilha de tecnologia </h3><br>  As t√©cnicas de desenvolvimento est√£o se desenvolvendo rapidamente e mudando.  Por mais 2 anos, Java foi a linguagem oficial de desenvolvimento Android.  Todo mundo escreveu em Java e usou a liga√ß√£o de dados.  Agora, parece-me, estamos caminhando em dire√ß√£o √† programa√ß√£o reativa e ao Kotlin.  Java √© uma √≥tima linguagem, mas tem algumas imperfei√ß√µes em compara√ß√£o com o que o Kotlin e o AndroidX t√™m a oferecer.  Kotlin e AndroidX podem reduzir ao m√≠nimo o uso da liga√ß√£o de dados, se n√£o a excluir completamente.  Abaixo tentarei explicar meu ponto de vista. <br><br><h4>  Kotlin </h4><br>  Acho que muitos desenvolvedores do Android j√° mudaram para o Kotlin e, portanto, concordam comigo que escrever um novo projeto Android em 2019 em qualquer idioma que n√£o seja o Kotlin √© como lutar contra o mar.  Claro que voc√™ pode argumentar, mas e Flutter e Dart?  E quanto a C ++, C # e at√© Cordova?  A que responderei: a escolha √© sempre sua. <br><br>  Em 480 aC  o rei persa Xerxes ordenou que seus soldados atravessassem o mar como um castigo por destruir parte de seu ex√©rcito durante uma tempestade e, cinco s√©culos depois, o imperador romano Cal√≠gula declarou guerra a Poseidon.  Uma quest√£o de gosto.  Para 9 em 10, Kotlin √© bom, mas para 10 pode ser ruim.  Tudo depende de voc√™, de seus desejos e aspira√ß√µes. <br><br>  Kotlin √© a minha escolha.  A linguagem √© simples e bonita.  Escrever sobre isso √© f√°cil e agrad√°vel e, o mais importante, n√£o √© necess√°rio escrever demais: classe de dados, objeto, setter e getter opcional, express√µes lambda simples e fun√ß√µes de extens√£o.  Esta √© apenas uma pequena parte do que esse idioma tem a oferecer.  Se voc√™ ainda n√£o mudou para o Kotlin - fique √† vontade!  Na se√ß√£o com pr√°tica, demonstrarei algumas das vantagens do idioma (n√£o √© uma oferta publicit√°ria). <br><br><h4>  Model-View-ViewModel </h4><br>  Atualmente, o MVVM √© a arquitetura de aplicativo recomendada do Google.  Durante o desenvolvimento, aderiremos a esse padr√£o espec√≠fico, no entanto, n√£o o observaremos completamente, pois o MVVM recomenda o uso de liga√ß√£o de dados, mas n√≥s o recusamos. <br><br>  <i><b>Profissionais da MVVM</b></i> <br><br><ul><li>  <i>Diferencia√ß√£o da l√≥gica de neg√≥cios e da interface do usu√°rio.</i>  Na implementa√ß√£o correta do MVVM, n√£o deve haver um √∫nico Android de importa√ß√£o no ViewModel, exceto os objetos LiveData dos pacotes AndroidX ou Jetpack.  O uso adequado deixa automaticamente todo o trabalho da interface do usu√°rio dentro de fragmentos e atividades.  Isso n√£o √© √≥timo? </li><li>  <i>O n√≠vel de encapsulamento √© bombeado.</i>  Ser√° mais f√°cil trabalhar em equipe: agora voc√™ pode trabalhar todos juntos em uma tela e n√£o interferir entre si.  Enquanto um desenvolvedor trabalha com a tela, outro pode criar um ViewModel e um terceiro pode escrever consultas no Reposit√≥rio. </li><li>  <i>O MVVM tem um efeito positivo na grava√ß√£o de testes de unidade.</i>  Este item segue o anterior.  Se todas as classes e m√©todos forem encapsulados pelo trabalho com a interface do usu√°rio, eles poder√£o ser facilmente testados. </li><li>  <i>Uma solu√ß√£o natural com rota√ß√£o da tela.</i>  N√£o importa o qu√£o estranho possa parecer, mas esse recurso √© adquirido automaticamente, com a transi√ß√£o para o MVVM (porque os dados s√£o armazenados no ViewModel).  Se voc√™ verificar aplicativos bastante populares (VK, Telegram, Sberbank-Online e Aviasales), verifica-se que exatamente metade deles n√£o consegue girar a tela.  O que me causa alguma surpresa e mal-entendido como usu√°rio desses aplicativos. </li></ul><br>  <i><b>Por que o MVVM √© perigoso?</b></i> <br><br><ul><li>  <i>Vazamento de mem√≥ria.</i>  Este erro perigoso acontece se voc√™ infringir as leis do uso do LiveData e do observador.  Examinaremos esse erro em detalhes na se√ß√£o pr√°tica. </li><li>  <i>Alastrando ViewModel.</i>  Se voc√™ tentar ajustar toda a l√≥gica de neg√≥cios ao ViewModel, receber√° um c√≥digo ileg√≠vel.  A sa√≠da dessa situa√ß√£o pode ser dividir o ViewModel em uma hierarquia ou usar Presenters.  Foi exatamente o que eu fiz. </li></ul><br>  <i><b>Regras para trabalhar com MVVM</b></i> <br><br>  Vamos come√ßar com o maior n√∫mero de erros e avan√ßar para os menos erros: <br><br><ul><li>  o corpo da solicita√ß√£o n√£o deve estar no ViewModel (apenas no Reposit√≥rio); </li><li>  Os objetos LiveData s√£o definidos no ViewModel, eles n√£o se lan√ßam dentro do Reposit√≥rio, porque  solicita√ß√µes no Reposit√≥rio s√£o processadas usando Rx-Java (ou coroutines); </li><li>  todas as fun√ß√µes de processamento devem ser movidas para classes e arquivos de terceiros ("Apresentadores"), para n√£o confundir o ViewModel e n√£o distrair a ess√™ncia. </li></ul><br><h4>  Livedata </h4><br><blockquote>  LiveData √© uma classe de suporte de dados observ√°vel.  Ao contr√°rio de um observ√°vel regular, o LiveData reconhece o ciclo de vida, o que significa que respeita o ciclo de vida de outros componentes do aplicativo, como atividades, fragmentos ou servi√ßos.  Essa conscientiza√ß√£o garante que o LiveData atualize apenas observadores de componentes de aplicativos que est√£o em um estado de ciclo de vida ativo. </blockquote>  <i>Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">developer.android.com/topic/libraries/architecture/livedata</a></i> <br><br>  Uma conclus√£o simples pode ser extra√≠da da defini√ß√£o: LiveData √© uma ferramenta de programa√ß√£o reativa confi√°vel.  Vamos us√°-lo para atualizar a parte da interface do usu√°rio sem liga√ß√£o de dados.  Porque <br><br>  A estrutura dos arquivos XML n√£o permite uma distribui√ß√£o concisa dos dados obtidos de &lt;data&gt; ... &lt;/data&gt;.  Se tudo estiver claro com arquivos pequenos, e os arquivos grandes?  O que fazer com telas complexas, m√∫ltiplas incluem e passam v√°rios campos?  Usa modelos em qualquer lugar?  Obter liga√ß√µes de campo r√≠gidas?  E se o campo deve ser formatado, chame m√©todos de pacotes Java?  Isso torna o c√≥digo irremediavelmente e completamente espaguete.  N√£o √© o que a MVVM prometeu. <br><br>  Rejeitar a liga√ß√£o de dados tornar√° transparentes as altera√ß√µes na parte da interface do usu√°rio.  Todas as atualiza√ß√µes ocorrer√£o diretamente dentro do observador.  Porque  Como o c√≥digo Kolin √© conciso e claro, n√£o teremos problemas com o observador inchado.  Escrever e manter o c√≥digo se tornar√° mais f√°cil.  Os arquivos XML ser√£o usados ‚Äã‚Äãapenas para design - nenhuma propriedade dentro. <br><br>  A liga√ß√£o de dados √© uma ferramenta poderosa.  √â √≥timo para resolver alguns problemas e se harmoniza bem com Java, mas com Kotlin ... Com Kotlin, na maioria dos casos, a liga√ß√£o de dados √© apenas rudimentar.  A liga√ß√£o de dados apenas complica o c√≥digo e n√£o oferece vantagens competitivas. <br><br>  Em Java, voc√™ tinha uma escolha: use a liga√ß√£o de dados ou escreva muitos c√≥digos feios.  No Kotlin, voc√™ pode acessar os elementos de exibi√ß√£o diretamente, ignorando findViewById (), bem como suas propriedades.  Por exemplo: <br><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Instead of TextView textView = findViewById&lt;TextView&gt;(R.id.textView) textView.text = "Hello, world!" textView.visibility = View.VISIBLE</span></span></code> </pre> <br>  Surge uma pergunta l√≥gica: por que se preocupar com modelos de jardinagem em arquivos XML, invocando m√©todos Java em arquivos XML, sobrecarregando a l√≥gica da parte XML se tudo isso pode ser evitado? <br><br><h4>  Corotinas em vez de Thread () e Rx-Java </h4><br>  As corotinas s√£o incrivelmente leves e f√°ceis de usar.  Eles s√£o ideais para a maioria das tarefas ass√≠ncronas simples: processamento de resultados de consultas, atualiza√ß√£o da interface do usu√°rio etc. <br><br>  As corotinas podem substituir efetivamente Thread () e Rx-Java nos casos em que n√£o √© necess√°rio alto desempenho, porque  eles pagam pela leveza com rapidez.  Rx-Java, sem d√∫vida, √© mais funcional, no entanto, para tarefas simples, todos os seus ativos n√£o s√£o necess√°rios. <br><br><h4>  Microsoft e o resto </h4><br>  Para trabalhar com os servi√ßos do Outlook, a API do Microsoft Graph ser√° usada.  Com as permiss√µes apropriadas, voc√™ pode obter todas as informa√ß√µes necess√°rias sobre funcion√°rios, salas e eventos (ahs).  Para o reconhecimento de rosto, ser√° usado o servi√ßo de nuvem Microsoft Face API. <br><br>  Olhando um pouco √† frente, direi que, para resolver o problema de escalabilidade, foi usado o armazenamento em nuvem Firebase.  Isso ser√° discutido abaixo. <br><br><h2>  Arquitetura </h2><br><h3>  Problemas de escalabilidade </h3><br>  √â muito dif√≠cil tornar o sistema total ou parcialmente escal√°vel.  Isso √© especialmente dif√≠cil de fazer se a primeira vers√£o do aplicativo n√£o for escal√°vel e a segunda se tornar.  O aplicativo v1 enviou solicita√ß√µes para todos os quartos de uma vez.  Cada um dos tablets enviava solicita√ß√µes regularmente ao servidor para atualizar todos os dados.  Ao mesmo tempo, os dispositivos n√£o se sincronizaram porque  o projeto simplesmente n√£o possui seu pr√≥prio servidor. <br><br>  Obviamente, se seguirmos o mesmo caminho e enviarmos solicita√ß√µes N de cada um dos N tablets, em algum momento derrubaremos a Microsoft Graph API ou congelaremos o sistema. <br><br>  Seria l√≥gico usar uma solu√ß√£o cliente-servidor na qual o servidor examina o gr√°fico, acumula dados e, mediante solicita√ß√£o, fornece informa√ß√µes aos tablets, mas aqui somos atingidos pela realidade.  A equipe do projeto √© composta por 2 pessoas (desenvolvedor e designer Android).  Eles precisam cumprir o prazo de 7 semanas e o back-end n√£o √© fornecido, porque  escalar √© um requisito do desenvolvedor.  Mas isso n√£o significa que a ideia deva ser abandonada? <br><br>  Provavelmente, a √∫nica solu√ß√£o certa nessa situa√ß√£o ser√° o uso de armazenamento em nuvem.  O Firebase substituir√° o servidor e atuar√° como um buffer.  Acontece o seguinte: <i>cada tablet pesquisa apenas seu endere√ßo na API do Microsoft Graph e, se necess√°rio, sincroniza os dados no armazenamento em nuvem, de onde podem ser lidos por outros dispositivos.</i> <br><br>  A vantagem desta implementa√ß√£o ser√° uma resposta r√°pida, porque  O Firebase funciona em tempo real.  Reduziremos o n√∫mero de solicita√ß√µes enviadas ao servidor N vezes, o que significa que o dispositivo funcionar√° com bateria um pouco mais.  Do ponto de vista financeiro, o projeto n√£o subiu de pre√ßo, porque  Para este projeto, a vers√£o gratuita do Firebase √© suficiente com v√°rias reservas: 1 GB de armazenamento, 10 mil autoriza√ß√µes por m√™s e 100 conex√µes por vez.  As desvantagens podem incluir depend√™ncia de uma estrutura de terceiros, mas o Firebase inspira confian√ßa em n√≥s, porque  √â um produto est√°vel, mantido e desenvolvido pelo Google. <br><br>  A ideia geral do novo sistema era a seguinte: N tablets e uma plataforma em nuvem para sincroniza√ß√£o de dados em tempo real.  Vamos come√ßar a projetar o pr√≥prio aplicativo. <br><br><h4>  LiveData no Reposit√≥rio </h4><br>  Parece que estabeleci recentemente as regras de boa forma e violei imediatamente uma delas.  Diferente do uso recomendado do LiveData dentro do ViewModel, neste projeto os objetos LiveData s√£o inicializados no reposit√≥rio e todos os reposit√≥rios s√£o declarados como singleton.  Porque <br><br>  Uma solu√ß√£o semelhante est√° associada ao modo de aplicativo.  Os comprimidos est√£o abertos das 8h √†s 20h.  Todo esse tempo, apenas o Auxiliar da sala de reuni√µes foi lan√ßado neles.  Como resultado, muitos objetos podem e devem ter vida longa (√© por isso que todos os reposit√≥rios s√£o projetados como singleton). <br><br>  No decorrer do trabalho, o conte√∫do da interface do usu√°rio √© alternado regularmente, o que implica a cria√ß√£o e recrea√ß√£o dos objetos ViewModel.  Acontece que, se voc√™ usar o LiveData dentro do ViewModel, para cada fragmento criado, seu pr√≥prio ViewModel ser√° criado com um conjunto de objetos LiveData especificados.  Se dois fragmentos semelhantes forem exibidos simultaneamente na tela, com ViewModel diferente e um Base-ViewModel comum, durante a inicializa√ß√£o haver√° uma duplica√ß√£o de objetos LiveData a partir do Base-ViewModel.  No futuro, essas duplicatas ocupar√£o espa√ßo na mem√≥ria at√© serem destru√≠das pelo "coletor de lixo".  Porque  Se j√° temos um reposit√≥rio na forma de um singleton e queremos minimizar o custo de recriar telas, seria sensato transferir objetos do LiveData dentro de um reposit√≥rio de singleton, facilitando assim os objetos do ViewModel e acelerando o aplicativo. <br><br>  Obviamente, isso n√£o significa que voc√™ precise transferir todos os LiveData do ViewModel para o reposit√≥rio, mas voc√™ deve abordar com mais cuidado esse problema e fazer sua escolha conscientemente.  A desvantagem dessa abordagem √© o aumento do n√∫mero de objetos de vida longa, porque  todos os reposit√≥rios s√£o definidos como singleton e cada um deles armazena objetos LiveData.  Mas, em um caso espec√≠fico, o Meeting Room Helper n√£o √© um sinal negativo, porque  o aplicativo √© executado sem parar o dia todo, sem alternar o contexto para outros aplicativos. <br><br><h4>  Arquitetura resultante </h4><br><img src="https://habrastorage.org/webt/yf/db/uo/yfdbuo8--ygtmrgxsybvuiuyeme.png"><br><br><ul><li>  Todas as solicita√ß√µes s√£o executadas em reposit√≥rios.  Todos os reposit√≥rios (no Meeting Room Helper existem 11 deles) s√£o projetados como singleton.  Eles s√£o divididos por tipo de objetos retornados e ocultos atr√°s das fachadas. </li><li>  A l√≥gica de neg√≥cios reside no ViewModel.  Gra√ßas ao uso de "Apresentadores", o tamanho total de todo o ViewModel (h√° 6 no projeto) √© inferior a 120 linhas. </li><li>  A atividade e o fragmento est√£o envolvidos apenas na altera√ß√£o da parte da interface do usu√°rio, usando o observador e o LiveData retornados do ViewModel. </li><li>  Fun√ß√µes para processar e gerar dados s√£o armazenadas no "apresentador".  Utilizou ativamente fun√ß√µes de permiss√£o da Kotlin para processamento de dados. </li></ul><br>  A l√≥gica de segundo plano foi movida para o Servi√ßo de Inten√ß√£o: <br><br><ul><li>  Servi√ßo de atualiza√ß√£o de eventos.  Servi√ßo respons√°vel por sincronizar os dados da sala atual nas Firebase e Graph API. </li><li>  Servi√ßo de reconhecimento de usu√°rio.  √â executado apenas no tablet principal.  Respons√°vel por adicionar novos funcion√°rios ao sistema.  Verifica uma lista de pessoas j√° treinadas com uma lista do Active Directory.  Se novas pessoas aparecerem, o servi√ßo as adiciona √† API do Face e treina novamente a rede neural.  Ap√≥s a conclus√£o da opera√ß√£o, ela √© desligada.  Inicia quando o aplicativo √© iniciado. </li><li>  O Servi√ßo de Notifica√ß√£o Online notifica outros tablets de que este tablet est√° funcionando, ou seja,  A bateria externa n√£o est√° esgotada.  Funciona atrav√©s do Firebase. </li></ul><br>  O resultado foi uma arquitetura bastante flex√≠vel e correta do ponto de vista da distribui√ß√£o de responsabilidades que atende a todos os requisitos do desenvolvimento moderno.  Se, no futuro, abandonarmos a API do Microsoft Graph, o Firebase ou qualquer outro m√≥dulo, eles poder√£o ser facilmente substitu√≠dos por novos sem interferir no restante do aplicativo.  A presen√ßa de um extenso sistema de "apresentadores" tornou poss√≠vel levar todas as fun√ß√µes de processamento de dados al√©m do n√∫cleo.  Como resultado, a arquitetura tornou-se clara, o que √© uma grande vantagem.  O problema de um ViewModel coberto de vegeta√ß√£o desapareceu completamente. <br><br>  Abaixo, darei um exemplo do pacote comum usado em um aplicativo desenvolvido. <br><br><h3>  Pr√°tica.  Assista Atualiza√ß√µes </h3><br>  Dependendo do estado da sala de reuni√µes, o mostrador mostra uma das seguintes condi√ß√µes: <br><br><img src="https://habrastorage.org/webt/sa/o2/to/sao2towzwxh0qqlp1gvxd_s2qjg.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Al√©m disso, arcos tempor√°rios de com√≠cios est√£o localizados ao longo do contorno do mostrador, e o centro faz uma contagem regressiva at√© o final da reuni√£o ou at√© o in√≠cio do pr√≥ximo com√≠cio.  Tudo isso √© feito pela biblioteca de telas que desenvolvemos.  Se a grade de reuni√µes mudou, precisamos atualizar os dados na biblioteca. <br><br>  Como o LiveData √© anunciado nos Reposit√≥rios, √© mais l√≥gico come√ßar com eles. <br><br><h4>  Reposit√≥rios </h4><br>  <i>FirebaseRoomRepository</i> - uma classe respons√°vel pelo envio e processamento de solicita√ß√µes no Firebase relacionadas ao modelo da sala. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. object FirebaseRoomRepository { private val database = FirebaseFactory.database val rooms: MutableList&lt;Room&gt; = ArrayList() // 2. var currentRoom: MutableLiveData&lt;Room?&gt; = MutableLiveData() val onlineStatus: MediatorLiveData&lt;HashMap&lt;String, Boolean&gt;&gt; = MediatorLiveData() var otherRooms: MutableLiveData&lt;List&lt;Room&gt;&gt; = MutableLiveData() var ownRoom: MutableLiveData&lt;Room&gt; = MutableLiveData() // 3. private val roomsListener = object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { updateRooms(dataSnapshot) } override fun onCancelled(error: DatabaseError) {} } init { // 4. database.getReference(ROOMS_CURRENT_STATES) .addValueEventListener(roomsListener) } // 5. private fun updateRooms(dataSnapshot: DataSnapshot) { rooms.updateRooms(dataSnapshot) otherRooms.updateOtherRooms(rooms) ownRoom.updateOwnRoom(rooms) currentRoom.updateCurrentRoom(rooms, ownRoom) } }</span></span></code> </pre><br>  Para demonstrar, o c√≥digo de inicializa√ß√£o do listener firebase foi ligeiramente simplificado (a fun√ß√£o reconectar foi removida).  Vamos dar uma olhada nos pontos do que est√° acontecendo aqui: <br><br><ol><li>  o reposit√≥rio foi projetado como um singleton (no Kotlin, basta substituir a palavra-chave da classe por objeto); </li><li>  inicializa√ß√£o de objetos LiveData; </li><li>  ValueEventListener √© declarado como uma vari√°vel para evitar recriar uma classe an√¥nima em caso de reconex√£o (lembre-se, simplifiquei a inicializa√ß√£o removendo a reconex√£o em caso de desconex√£o); </li><li>  inicializa√ß√£o do ValueEventListener (se os dados no Firebase mudarem, o ouvinte executar√° e atualizar√° imediatamente os dados nos objetos LiveData); </li><li>  Atualiza√ß√µes para objetos LiveData. </li></ol><br>  As pr√≥prias fun√ß√µes s√£o movidas para um arquivo FirebaseRoomRepositoryPresenter separado e decoradas como fun√ß√µes de extens√£o. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> MutableLiveData</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;List&lt;Room&gt;</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateOtherRooms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rooms: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MutableList</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Room</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.postValue(rooms.filter { !it.isOwnRoom() }) }</code> </pre><br>  <i>Exemplo de fun√ß√£o de extens√£o do FirebaseRoomRepositoryPresenter</i> <br><br>  Tamb√©m para uma compreens√£o geral da imagem, darei uma lista do objeto Room. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. data class Room(var number: String = "", var nickName: String = "", var email: String? = null, var imgSmall: String? = null, var imgOffline: String? = null, var imgFree: String? = null, var imgWait: String? = null, var imgBusy: String? = null, var events: List&lt;Event.Short&gt; = emptyList()) // 2.</span></span></code> </pre><br><ol><li>  Classe de dados.  Esse modificador gera e substitui automaticamente os m√©todos toString (), HashCode () e equal ().  N√£o h√° mais necessidade de redefinir voc√™ mesmo. </li><li>  A lista de eventos do objeto Room.  √â esta lista que √© necess√°ria para atualizar os dados na biblioteca de discagem. </li></ol><br>  Todas as classes de reposit√≥rios est√£o ocultas atr√°s da classe de fachada. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Repository { <span class="hljs-comment"><span class="hljs-comment">// 1. private val firebaseRoomRepository = FirebaseRoomRepository // ......... /** * Rooms queries */ fun getOtherRooms() = firebaseRoomRepository.otherRooms fun getOwnRoom() = firebaseRoomRepository.ownRoom fun getAllRooms() = firebaseRoomRepository.rooms // 2. fun getCurrentRoom() = firebaseRoomRepository.currentRoom //   // ....... }</span></span></code> </pre><br><ol><li>  Acima, voc√™ pode ver uma lista de todas as classes de reposit√≥rio usadas e fachadas de segundo n√≠vel.  Isso simplifica o entendimento geral do c√≥digo e demonstra uma lista de todas as classes de reposit√≥rio conectadas. </li><li>  Uma lista de m√©todos que retornam refer√™ncias a objetos LiveData do FirebaseRoomRepository.  Os setters e getters do Kotlin s√£o opcionais, portanto voc√™ n√£o precisa escrev√™-los desnecessariamente. </li></ol><br>  Essa organiza√ß√£o permite que voc√™ se ajuste confortavelmente de 20 a 30 solicita√ß√µes em um reposit√≥rio raiz.  Se o seu aplicativo tiver mais solicita√ß√µes, voc√™ precisar√° dividir a fachada raiz em 2 ou mais. <br><br><h4>  ViewModel </h4><br>  BaseViewModel √© o ViewModel base do qual todos os ViewModels s√£o herdados.  Ele inclui um √∫nico objeto currentRoom, usado universalmente. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. open class BaseViewModel : ViewModel() { // 2. fun getCurrentRoom() = Repository.getCurrentRoom() }</span></span></code> </pre><br><ol><li>  O marcador aberto significa que voc√™ pode herdar da classe.  Por padr√£o no Kotlin, todas as classes e m√©todos s√£o finais, ou seja,  classes n√£o podem ser herdadas e m√©todos n√£o podem ser redefinidos.  Isso √© para proteger contra altera√ß√µes de vers√£o incompat√≠veis acidentais.  Eu darei um exemplo <br><br>  <i>Voc√™ est√° desenvolvendo uma nova vers√£o da biblioteca.</i>  <i>Em algum momento, por um motivo ou outro, voc√™ decide renomear a classe ou alterar a assinatura de algum m√©todo.</i>  <i>Ao alter√°-lo, voc√™ criou acidentalmente incompatibilidade de vers√£o.</i>  <i>Opa ... Se voc√™ provavelmente soubesse que o m√©todo poderia ser substitu√≠do por algu√©m, e a classe fosse herdada, voc√™ provavelmente teria sido mais preciso e dificilmente teria atingido seu pr√≥prio p√©.</i>  <i>Para fazer isso, no Kotlin, por padr√£o, tudo √© declarado como final e, para cancelamento, existe um modificador "aberto".</i> <br></li><li>  O m√©todo getCurrentRoom () retorna um link para o objeto LiveData da sala atual do Repository, que, por sua vez, √© retirado do FirebaseRoomRepository.  Quando esse m√©todo √© chamado, o objeto Room retornar√° contendo todas as informa√ß√µes sobre a sala, incluindo uma lista de eventos. </li></ol><br>  Para converter dados de um formato para outro, usaremos a transforma√ß√£o.  Para fazer isso, crie um <i>MainFragmentViewModel</i> e herde-o de <i>BaseViewModel</i> . <br><br>  <i>MainFragmentViewModel</i> √© uma classe <i>derivada</i> de BaseViewModel.  Este ViewModel √© usado apenas no MainFragment. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. class MainFragmentViewModel: BaseViewModel () { // 2. var currentRoomEvents = Transformations.switchMap(getCurrentRoom()) { val events: MutableLiveData&lt;List&lt;Event.Short&gt;&gt; = MutableLiveData() // some business logic events.postValue(it?.eventsList) events } // 3. val currentRoomEvents2 = MediatorLiveData&lt;List&lt;Event.Short&gt;&gt;().apply { addSource(getCurrentRoom()) { room -&gt; // some business logic postValue(room?.eventsList) } } }</span></span></code> </pre><br><ol><li>  Observe a falta do modificador aberto.  Isso significa que ningu√©m herda da classe. </li><li>  currentRoomEvents - um objeto obtido usando a transforma√ß√£o.  Assim que o objeto da sala atual √© alterado, a transforma√ß√£o √© executada e o objeto currentRoomEvents √© atualizado. </li><li>  MediatorLiveData.  O resultado √© id√™ntico √† transforma√ß√£o (mostrada para refer√™ncia). </li></ol><br>  A primeira op√ß√£o √© usada para converter dados de um tipo para outro, que √© o que precis√°vamos, e a segunda op√ß√£o √© necess√°ria para executar alguma l√≥gica de neg√≥cios.  No entanto, a convers√£o de dados n√£o ocorre.  Lembre-se de que a importa√ß√£o do Android no ViewModel n√£o √© v√°lida.  Portanto, inicio solicita√ß√µes adicionais a partir daqui ou reinicio os servi√ßos conforme necess√°rio. <br><br>  <b>Aviso importante!</b>  Para que a transforma√ß√£o ou o mediador funcione, algu√©m deve assinar um fragmento ou atividade.  Caso contr√°rio, o c√≥digo n√£o ser√° executado, porque  ningu√©m esperar√° um resultado (esses s√£o objetos observadores). <br><br><h4>  Mainfragment </h4><br>  A etapa final na convers√£o de dados em resultado.  MainFragment inclui uma biblioteca de discagem e um View-Pager na parte inferior da tela. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseFragment</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// 1. private lateinit var viewModel: MainFragmentViewModel // 2. private val currentRoomObserver = Observer&lt;List&lt;Event.Short&gt;&gt; { clockView.updateArcs(it) } override fun onAttach(context: Context?) { super.onAttach(context) // 3. viewModel = ViewModelProviders.of(this).get(MainFragmentViewModel::class.java) } override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { return inflater.inflate(R.layout.fragment_main, container, false) } override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) // 4. viewModel.currentRoomEvents.observe(viewLifecycleOwner, currentRoomObserver) } }</span></span></code> </pre><br><ol><li>  Inicializa√ß√£o do MainFragmentViewModel.  O modificador lateinit indica que prometemos inicializar esse objeto posteriormente, antes de us√°-lo.  O Kotlin tenta proteger o programador da escrita incorreta do c√≥digo; portanto, devemos dizer imediatamente que o objeto pode ser nulo ou colocar lateinit.  Nesse caso, o ViewModel deve ser inicializado pelo objeto. </li><li>  Observador-ouvinte para atualizar o dial. </li><li>  Inicializando o ViewModel.  Observe que isso acontece imediatamente ap√≥s o fragmento ser anexado √† atividade. </li><li>  Ap√≥s a cria√ß√£o da atividade, assinamos as altera√ß√µes no objeto currentRoomEvents.  Observe que eu n√£o assino o ciclo de vida do fragmento (isto), mas o objeto viewLifecycleOwner.  O fato √© que na biblioteca de suporte 28.0.0 e AndroidX 1.0.0, um bug foi detectado quando o observador foi "cancelado".  Para resolver esse problema, foi lan√ßado um patch no formato viewLifecycleOwner, e o Google recomenda a assinatura.  Isso corrige o problema do observador zumbi quando o fragmento morreu e o observador continua funcionando.  Se voc√™ ainda estiver usando isso, substitua-o por viewLifecycleOwner. </li></ol><br>  Portanto, quero demonstrar a simplicidade e a beleza do MVVM e do LiveData sem usar a liga√ß√£o de dados.  Observe que neste projeto eu violei a regra geralmente aceita, colocando o LiveData no Reposit√≥rio devido √†s especificidades do projeto.  No entanto, se os movermos para o ViewModel, a imagem geral permanecer√° inalterada. <br><br>  Como uma cereja no bolo, preparei para voc√™ um pequeno v√≠deo com uma demonstra√ß√£o (os nomes s√£o manchados de acordo com os requisitos de seguran√ßa, pe√ßo desculpas): <br><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E9zUc0vaGck" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Sum√°rio </h3><br>  Como resultado da aplica√ß√£o no primeiro m√™s, alguns bugs foram revelados na exibi√ß√£o de com√≠cios cruzados (o Outlook permite criar v√°rios eventos ao mesmo tempo, enquanto o nosso sistema n√£o).  Agora, o sistema est√° funcionando h√° 3 meses.  Erros ou falhas n√£o s√£o observados. <br><br>  PS Obrigado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">jericho_code</a> pelo coment√°rio.  No Kotlin, voc√™ pode e deve inicializar a List &lt;&gt; no modelo usando emptyList (), para que um objeto extra n√£o seja criado. <br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> events: List&lt;Event.<span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>&gt; = emptyList() <span class="hljs-comment"><span class="hljs-comment">//      EmptyList var events: List&lt;Event.Short&gt; = ArrayList() //   </span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457960/">https://habr.com/ru/post/pt457960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457948/index.html">Jogos de tabuleiro nos quais voc√™ precisa esmagar sua cabe√ßa</a></li>
<li><a href="../pt457952/index.html">Como os processadores s√£o projetados e fabricados: fabrica√ß√£o de chips</a></li>
<li><a href="../pt457954/index.html">Por que a Swift pode se tornar um grande evento em Deep Learning</a></li>
<li><a href="../pt457956/index.html">Como escolher armazenamento sem dar um tiro no pr√≥prio p√©</a></li>
<li><a href="../pt457958/index.html">Cotidiano MT_FREE: v√°rias hist√≥rias sobre a influ√™ncia de servi√ßos de terceiros no trabalho de redes Wi-Fi p√∫blicas</a></li>
<li><a href="../pt457962/index.html">Assim como na arquitetura thrash e na falta de habilidades no Scrum, criamos equipes de v√°rios componentes</a></li>
<li><a href="../pt457964/index.html">Virtualidade real: esta√ß√µes de trabalho ++</a></li>
<li><a href="../pt457966/index.html">‚ÄúEu abriria uma zona de TI especial no sul da R√∫ssia‚Äù - 10 perguntas ao programador n¬∫ 11. Nova temporada</a></li>
<li><a href="../pt457968/index.html">Paralelos que se cruzam - o Minist√©rio das Comunica√ß√µes da noite para o dia queimava bilh√µes em or√ßamentos</a></li>
<li><a href="../pt457970/index.html">Linter em Go. Como cozinh√°-los. Denis Isaev</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>