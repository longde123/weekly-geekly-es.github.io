<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ñ´Ô∏è ü§£ üåä Ecrire UDR en Pascal üë®üèæ‚Äç‚öñÔ∏è üë®üèΩ‚ÄçüöÄ ‚úíÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Firebird a depuis longtemps √©t√© en mesure d'√©tendre les capacit√©s du langage PSQL en √©crivant des fonctions externes - UDF (User Defined Functions). U...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ecrire UDR en Pascal</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455375/"><p>  Firebird a depuis longtemps √©t√© en mesure d'√©tendre les capacit√©s du langage PSQL en √©crivant des fonctions externes - UDF (User Defined Functions).  UDF peut √™tre √©crit dans presque tous les langages de programmation compil√©s. </p><br><p>  Firebird 3.0 a introduit une architecture de plug-in pour √©tendre les capacit√©s de Firebird.  L'un de ces plugins est le moteur externe (moteurs externes).  Le m√©canisme UDR (User Defined Routines - User Defined Routines) ajoute une couche au-dessus de l'interface du moteur FirebirdExternal. </p><br><p>  Dans ce guide, nous vous expliquerons comment d√©clarer UDR, leurs m√©canismes internes, leurs capacit√©s et donnerons des exemples d'√©criture UDR en Pascal.  De plus, certains aspects de l'utilisation de la nouvelle API orient√©e objet seront abord√©s. </p><a name="habracut"></a><br><blockquote>  <strong>Remarque</strong> <br><br>  Cet article est destin√© √† vous apprendre √† √©crire UDR √† l'aide de l'API Firebird objet. <br>  Les fonctions et proc√©dures √©crites peuvent ne pas avoir d'application pratique. </blockquote><p>  Les UDR pr√©sentent les avantages suivants par rapport aux UDF h√©rit√©s: </p><br><ul><li>  vous pouvez √©crire non seulement des fonctions qui renvoient un r√©sultat scalaire, mais aussi des proc√©dures stock√©es (√† la fois ex√©cutables et s√©lectives), ainsi que des d√©clencheurs; </li><li>  contr√¥le am√©lior√© des param√®tres d'entr√©e et de sortie.  Dans certains cas (en passant par le descripteur), les types et autres propri√©t√©s des param√®tres d'entr√©e n'√©taient pas contr√¥l√©s du tout, cependant, vous pourriez obtenir ces propri√©t√©s dans UDF.  Les UDR fournissent un moyen plus unifi√© de d√©clarer les param√®tres d'entr√©e et de sortie, comme c'est le cas avec les fonctions et proc√©dures PSQL standard; </li><li>  UDR le contexte de la connexion ou transaction en cours est disponible, ce qui permet <br>  quelques manipulations avec la base de donn√©es actuelle dans ce contexte; </li><li>  La g√©n√©ration d'erreurs Firebird est disponible lorsque des exceptions se produisent, il n'est pas n√©cessaire de retourner une valeur sp√©ciale; </li><li>  Les proc√©dures et fonctions externes (UDR) peuvent √™tre regroup√©es dans des packages PSQL; </li><li>  L'UDR peut √™tre √©crit dans n'importe quel langage de programmation (√©ventuellement compil√© en codes objet), pour cela il est n√©cessaire que le plug-in External Engine correspondant soit √©crit.  Par exemple, il existe des plugins pour √©crire des modules externes en Java ou dans l'un des langages .NET. </li></ul><br><blockquote>  <strong>Remarque</strong> <br><br>  L'impl√©mentation UDR actuelle utilise un stub PSQL.  Par exemple, il est utilis√© pour <br>  v√©rification des param√®tres et des valeurs de retour pour v√©rifier la conformit√© aux restrictions.  Stub <br>  a √©t√© utilis√© en raison de la rigidit√© pour appeler directement les fonctions internes.  R√©sultats <br>  test comparant les performances des UDR et UDF montre que UDR est approximativement <br>  2,5 fois plus lent en utilisant la fonction la plus simple d'ajouter deux arguments comme exemple.  La vitesse <br>  UDR est approximativement √©gal √† la vitesse d'une fonction PSQL r√©guli√®re.  Peut-√™tre qu'√† l'avenir, <br>  moment sera optimis√©.  Dans les fonctions plus complexes, cette surcharge peut devenir <br>  imperceptible. </blockquote><p>  Plus loin dans diff√©rentes parties de ce manuel, lorsque vous utilisez les termes proc√©dure externe, <br>  fonction ou d√©clencheur, nous entendrons exactement UDR (et non UDF). </p><br><blockquote>  <strong>Remarque</strong> <br><br>  Tous nos exemples fonctionnent sur Delphi 2009 et versions ult√©rieures, ainsi que sur Free Pascal.  Tous <br>  des exemples peuvent √™tre compil√©s √† la fois en Delphi et en Free Pascal, si <br>  non sp√©cifi√© s√©par√©ment. </blockquote><br><h2 id="firebird-api">  API Firebird </h2><br><p> Pour √©crire des proc√©dures, des fonctions ou des d√©clencheurs externes dans des langages de programmation compil√©s, nous avons besoin de conna√Ætre la nouvelle API Firebird orient√©e objet.  Ce guide ne comprend pas une description compl√®te de l'API Firebird.  Vous pouvez le lire dans le r√©pertoire de documentation distribu√© avec Firebird ( <code>doc/Using_OO_API.html</code> ). </p><br><p>  Les plug-ins pour divers langages de programmation qui contiennent des API ne sont pas distribu√©s dans le cadre de la distribution Firebird pour Windows, mais vous pouvez les extraire des fichiers tarbar compress√©s distribu√©s par Linux (le chemin √† l'int√©rieur de l'archive <code>/opt/firebird/include/firebird/Firebird.pas</code> ). </p><br><h3 id="cloop">  CLOOP </h3><br><p>  CLOOP - Programmation orient√©e objet en langage crois√©.  Cet outil n'est pas inclus avec Firebird.  Il peut √™tre trouv√© dans le code source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/FirebirdSQL/firebird/tree/B3_0_Release/extern/cloop</a> .  Une fois l'outil assembl√©, vous pouvez g√©n√©rer une API pour votre langage de programmation ( <code>IdlFbInterfaces.h</code> ou <code>Firebird.pas</code> ) sur la base du fichier de description d'interface <code>include/firebird/FirebirdInterface.idl</code> . </p><br><p>  Pour Object pascal, cela se fait avec la commande suivante: </p><br><pre> <code class="plaintext hljs">cloop FirebirdInterface.idl pascal Firebird.pas Firebird --uses SysUtils \ --interfaceFile Pascal.interface.pas \ --implementationFile Pascal.implementation.pas \ --exceptionClass FbException --prefix I \ --functionsFile fb_get_master_interface.pas</code> </pre> <br><p>  Les <code>Pascal.interface.pas</code> , <code>Pascal.implementation.pas</code> et <code>fb_get_master_interface.pas</code> se trouvent sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/FirebirdSQL/firebird/tree/B3_0_Release/src/misc/pascal</a> . </p><br><blockquote>  <strong>Remarque</strong> <br><br>  Dans ce cas, le pr√©fixe I sera ajout√© pour les API Firebird, car cela est accept√© en Object Pascal. </blockquote><br><h4 id="konstanty">  Constantes </h4><br><p>  Il n'y a pas de constantes <code>isc_*</code> dans le fichier <code>Firebird.pas</code> r√©sultant.  Ces constantes pour les langages C / C ++ peuvent √™tre trouv√©es sur <a href="">https://github.com/FirebirdSQL/firebird/blob/B3_0_Release/src/include/consts_pub.h</a> .  Pour obtenir les constantes du langage Pascal, nous utiliserons le script AWK pour convertir la syntaxe.  Sous Windows, vous devrez installer Gawk pour Windows ou utiliser le sous-syst√®me Windows pour Linux (disponible sur Windows 10).  Cela se fait avec la commande suivante: </p><br><pre> <code class="plaintext hljs">awk -f Pascal.Constants.awk consts_pub.h &gt; const.pas</code> </pre> <br><p>  Le contenu du fichier r√©sultant doit √™tre copi√© dans la section const vide du fichier <code>Firebird.pas</code> imm√©diatement apr√®s l'impl√©mentation.  Le fichier <code>Pascal.Constants.awk</code> se trouve √† l' <code>Pascal.Constants.awk</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/FirebirdSQL/firebird/tree/B3_0_Release/src/misc/pascal</a> . </p><br><h3 id="upravlenie-vremenem-zhizni">  Gestion du temps de vie </h3><br><p>  Les interfaces Firebird ne sont pas bas√©es sur la sp√©cification COM, donc la gestion de leur dur√©e de vie est diff√©rente. </p><br><p>  Il existe deux interfaces dans Firebird qui traitent de la gestion du temps de vie: IDisposable et IReferenceCounted.  Ce dernier est particuli√®rement actif lors de la cr√©ation d'autres interfaces: IPlugin compte les liens, comme beaucoup d'autres interfaces utilis√©es par les plug-ins.  Il s'agit notamment des interfaces qui d√©crivent comment se connecter √† une base de donn√©es, la gestion des transactions et les instructions SQL. </p><br><p>  Une surcharge suppl√©mentaire de l'interface avec comptage de r√©f√©rences n'est pas toujours n√©cessaire.  Par exemple, IMaster, l'interface principale qui appelle les fonctions disponibles pour le reste de l'API, a une dur√©e de vie illimit√©e par d√©finition.  Pour les autres API, la dur√©e de vie est strictement d√©termin√©e par la dur√©e de vie de l'interface parent;  L'interface IStatus n'est pas <br>  multithread.  Pour les interfaces avec une dur√©e de vie limit√©e, il est utile d'avoir un moyen simple de les d√©truire, c'est-√†-dire la fonction dispose (). </p><br><blockquote>  <strong>Indice</strong> <br><br>  Si vous ne savez pas comment un objet est d√©truit, regardez sa hi√©rarchie, s'il a <br>  interface IReferenceCounted, puis le comptage des r√©f√©rences est utilis√©. <br>  Pour les interfaces avec comptage de r√©f√©rences, √† la fin du travail avec un objet, il est n√©cessaire <br>  diminuez le compteur de r√©f√©rence en appelant la m√©thode release (). </blockquote><br><h2 id="obyavlenie-udr">  Annonce UDR </h2><br><p>  Les UDR peuvent √™tre ajout√©s ou supprim√©s de la base de donn√©es √† l'aide des commandes DDL, tout comme vous ajoutez ou supprimez des proc√©dures, fonctions ou d√©clencheurs PSQL standard.  Dans ce cas, au lieu du corps du d√©clencheur, son emplacement dans le module externe est indiqu√© √† l'aide de la clause EXTERNAL NAME. </p><br><p>  Consid√©rez la syntaxe de cette phrase; elle sera commune aux proc√©dures, fonctions et d√©clencheurs externes. </p><br><p>  <strong>Syntaxe:</strong> </p><br><pre> <code class="plaintext hljs">EXTERNAL NAME '&lt;extname&gt;' ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt;[!&lt;misc info&gt;]'</code> </pre> <br><p>  L'argument de cette clause EXTERNAL NAME est une cha√Æne indiquant l'emplacement de la fonction dans le module externe.  Pour les modules externes utilisant le moteur UDR, cette ligne √† travers le s√©parateur indique le nom du module externe, le nom de la fonction √† l'int√©rieur du module et les informations d√©finies par l'utilisateur.  Un point d'exclamation (!) Est utilis√© comme s√©parateur. </p><br><p>  La clause ENGINE sp√©cifie le nom du moteur de traitement de la connexion des modules externes.  Firebird utilise le moteur UDR pour travailler avec des modules externes √©crits dans des langages compil√©s (C, C ++, Pascal).  Les fonctions externes √©crites en Java n√©cessitent le moteur Java. </p><br><p>  Apr√®s le mot cl√© AS, un litt√©ral de cha√Æne peut √™tre sp√©cifi√© - le ¬´corps¬ª du module externe (proc√©dure, fonction ou d√©clencheur), il peut √™tre utilis√© par le module externe √† diverses fins.  Par exemple, une requ√™te SQL peut √™tre sp√©cifi√©e pour acc√©der √† une base de donn√©es externe ou du texte dans une langue pour l'interpr√©tation par votre fonction. </p><br><h3 id="vneshnie-funkcii">  Fonctions externes </h3><br><div class="spoiler">  <b class="spoiler_title">Syntaxe</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{CREATE [OR ALTER] | RECREATE} FUNCTION funcname [(&lt;inparam&gt; [, &lt;inparam&gt; ...])] RETURNS &lt;type&gt; [COLLATE collation] [DETERMINISTIC] EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;inparam&gt; ::= &lt;param_decl&gt; [{= |DEFAULT} &lt;value&gt;] &lt;value&gt; ::= {literal | NULL | context_var} &lt;param_decl&gt; ::= paramname &lt;type&gt; [NOT NULL] [COLLATE collation] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt; [!&lt;misc info&gt;]' &lt;type&gt; ::= &lt;datatype&gt; | [TYPE OF] domain | TYPE OF COLUMN rel.col &lt;datatype&gt; ::= {SMALLINT | INT[EGER] | BIGINT} | BOOLEAN | {FLOAT | DOUBLE PRECISION} | {DATE | TIME | TIMESTAMP} | {DECIMAL | NUMERIC} [(precision [, scale])] | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)] [CHARACTER SET charset] | {NCHAR |NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(size)] | BLOB [SUB_TYPE {subtype_num | subtype_name}] [SEGMENT SIZE seglen] [CHARACTER SET charset] | BLOB [(seglen [, subtype_num])]</code> </pre> </div></div><br><p>  Tous les param√®tres d'une fonction externe peuvent √™tre modifi√©s √† l'aide de l'instruction ALTER FUNCTION. </p><br><p>  <strong>Syntaxe:</strong> </p><br><pre> <code class="plaintext hljs">ALTER FUNCTION funcname [(&lt;inparam&gt; [, &lt;inparam&gt; ...])] RETURNS &lt;type&gt; [COLLATE collation] [DETERMINISTIC] EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt;[!&lt;misc info&gt;]'</code> </pre> <br><p>  Vous pouvez supprimer une fonction externe √† l'aide de l'instruction DROP FUNCTION. </p><br><p>  <strong>Syntaxe:</strong> </p><br><pre> <code class="plaintext hljs">DROP FUNCTION funcname</code> </pre> <br><div class="scrollable-table"><table><caption>  Quelques param√®tres d'une fonction externe </caption><thead><tr><th>  Param√®tre </th><th>  La description </th></tr></thead><tbody><tr><td>  funcname </td><td>  Le nom de la fonction stock√©e.  Peut contenir jusqu'√† 31 octets. </td></tr><tr><td>  inparam </td><td>  Description du param√®tre d'entr√©e. </td></tr><tr><td>  nom du module </td><td>  Nom du module externe dans lequel se trouve la fonction. </td></tr><tr><td>  nom de routine </td><td>  Nom interne de la fonction √† l'int√©rieur du module externe. </td></tr><tr><td>  informations diverses </td><td>  Informations d√©finies par l'utilisateur √† transmettre √† <br>  fonction du module externe. </td></tr><tr><td>  moteur </td><td>  Nom du moteur d'utilisation des fonctions externes.  Habituellement, le nom est UDR. </td></tr><tr><td>  extbody </td><td>  Le corps est une fonction externe.  Litt√©ral de cha√Æne pouvant √™tre utilis√© par l'UDR √† diverses fins. </td></tr></tbody></table></div><br><p>  Ici, nous ne d√©crirons pas la syntaxe des param√®tres d'entr√©e et de sortie.  Il est enti√®rement conforme √† la syntaxe des fonctions PSQL standard, qui est d√©crite en d√©tail dans le Guide du langage SQL.  Au lieu de cela, nous donnons des exemples de d√©claration de fonctions externes avec des explications. </p><br><p>  <strong>La fonction d'ajouter trois arguments</strong> </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> sum_args ( n1 <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, n2 <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, n3 <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'udrcpp_example!sum_args'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p>  L'impl√©mentation de la fonction est dans le module udrcpp_example.  A l'int√©rieur de ce module, une fonction est enregistr√©e sous le nom sum_args.  Une fonction externe utilise le moteur UDR. </p><br><p>  <strong>Fonction Java</strong> </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> regex_replace ( regex <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>), replacement <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'org.firebirdsql.fbjava.examples.fbjava_example.FbRegex.replace( String, String, String)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> <span class="hljs-keyword"><span class="hljs-keyword">java</span></span>;</code> </pre> <br><p>  L'impl√©mentation de la fonction se trouve dans la fonction statique de remplacement de la classe <code>org.firebirdsql.fbjava.examples.fbjava_example.FbRegex</code> .  Une fonction externe utilise le moteur Java. </p><br><h3 id="vneshnie-procedury">  Proc√©dures externes </h3><br><div class="spoiler">  <b class="spoiler_title">Syntaxe</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{CREATE [OR ALTER] | RECREATE} PROCEDURE procname [(&lt;inparam&gt; [, &lt;inparam&gt; ...])] RETURNS (&lt;outparam&gt; [&lt;outparam&gt; ...]) EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;inparam&gt; ::= &lt;param_decl&gt; [{= | DEFAULT} &lt;value&gt;] &lt;outparam&gt; ::= &lt;param_decl&gt; &lt;value&gt; ::= {literal | NULL | context_var} &lt;param_decl&gt; ::= paramname &lt;type&gt; [NOT NULL] [COLLATE collation] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt;[!&lt;misc info&gt;]' &lt;type&gt; ::= &lt;datatype&gt; | [TYPE OF] domain | TYPE OF COLUMN rel.col &lt;datatype&gt; ::= {SMALLINT | INT[EGER] | BIGINT} | BOOLEAN | {FLOAT | DOUBLE PRECISION} | {DATE | TIME | TIMESTAMP} | {DECIMAL | NUMERIC} [(precision [,scale])] | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)] [CHARACTER SET charset] | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(size)] | BLOB [SUB_TYPE {subtype_num | subtype_name}] [SEGMENT SIZE seglen] [CHARACTER SET charset] | BLOB [(seglen [, subtype_num])]</code> </pre> </div></div><br><p>  Tous les param√®tres de la proc√©dure externe peuvent √™tre modifi√©s √† l'aide de l'instruction ALTER PROCEDURE. </p><br><p>  <strong>Syntaxe:</strong> </p><br><pre> <code class="plaintext hljs">ALTER PROCEDURE procname [(&lt;inparam&gt; [, &lt;inparam&gt; ...])] RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...]) EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;]</code> </pre> <br><p>  Vous pouvez supprimer une proc√©dure externe √† l'aide de l'instruction DROP PROCEDURE. </p><br><p>  <strong>Syntaxe:</strong> </p><br><pre> <code class="plaintext hljs">DROP PROCEDURE procname</code> </pre> <br><div class="scrollable-table"><table><caption>  Quelques param√®tres de la proc√©dure externe </caption><thead><tr><th>  Param√®tre </th><th>  La description </th></tr></thead><tbody><tr><td>  funcname </td><td>  Nom de la proc√©dure stock√©e.  Peut contenir jusqu'√† 31 octets. </td></tr><tr><td>  inparam </td><td>  Description du param√®tre d'entr√©e. </td></tr><tr><td>  outparam </td><td>  Description du param√®tre de sortie. </td></tr><tr><td>  nom du module </td><td>  Nom du module externe dans lequel se trouve la proc√©dure. </td></tr><tr><td>  nom de routine </td><td>  Nom interne de la proc√©dure √† l'int√©rieur du module externe. </td></tr><tr><td>  informations diverses </td><td>  Informations d√©finies par l'utilisateur √† transmettre √† <br>  proc√©dure de module externe. </td></tr><tr><td>  moteur </td><td>  Nom du moteur pour l'utilisation des proc√©dures externes.  Habituellement, le nom est UDR. </td></tr><tr><td>  extbody </td><td>  Le corps d'une proc√©dure externe.  Litt√©ral de cha√Æne pouvant √™tre utilis√© par l'UDR √† diverses fins. </td></tr></tbody></table></div><br><p>  Ici, nous ne d√©crirons pas la syntaxe des param√®tres d'entr√©e et de sortie.  Il est enti√®rement conforme √† la syntaxe des proc√©dures PSQL standard, qui est d√©crite en d√©tail dans le Guide du langage SQL.  Au lieu de cela, nous donnons des exemples de d√©claration de proc√©dures externes avec des explications. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> gen_rows_pascal ( start_n <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, end_n <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'pascaludr!gen_rows'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p>  L'impl√©mentation de la fonction est dans le module pascaludr.  A l'int√©rieur de ce module, la proc√©dure est enregistr√©e sous le nom gen_rows.  Une proc√©dure externe utilise le moteur UDR. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> write_log ( message <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'pascaludr!write_log'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p>  L'impl√©mentation de la fonction est dans le module pascaludr.  A l'int√©rieur de ce module, la proc√©dure est enregistr√©e sous le nom write_log.  Une proc√©dure externe utilise le moteur UDR. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> employee_pgsql ( <span class="hljs-comment"><span class="hljs-comment">-- Firebird 3.0.0 has a bug with external procedures without parameters dummy integer = 1 ) returns ( id type of column employee.id, name type of column employee.name ) external name 'org.firebirdsql.fbjava.examples.fbjava_example.FbJdbc .executeQuery()!jdbc:postgresql:employee|postgres|postgres' engine java as 'select * from employee';</span></span></code> </pre> <br><p>  L'impl√©mentation de la fonction est dans la fonction statique executeQuery de la classe <br>  <code>org.firebirdsql.fbjava.examples.fbjava_example.FbJdbc</code> .  Apr√®s le point d'exclamation (!), Les informations se trouvent pour la connexion √† une base de donn√©es externe via JDBC.  Une fonction externe utilise le moteur Java.  Ici, en tant que "corps" d'une proc√©dure externe, une requ√™te SQL est pass√©e pour r√©cup√©rer des donn√©es. </p><br><blockquote>  <strong>Remarque</strong> <br><br>  Cette proc√©dure utilise un stub dans lequel un param√®tre inutilis√© est transmis.  Cela est d√ª au fait que dans Firebird 3.0 il y a un bug avec le traitement des proc√©dures externes sans param√®tres. </blockquote><br><h3 id="razmeschenie-vneshnih-procedur-i-funkciy-vnutri-paketov">  Placement des proc√©dures et fonctions externes dans les packages </h3><br><p>  Il est pratique de placer un groupe de proc√©dures et de fonctions interd√©pendantes dans des packages PSQL.  Les packages peuvent contenir des proc√©dures et des fonctions PSQL externes et r√©guli√®res. </p><br><div class="spoiler">  <b class="spoiler_title">Syntaxe</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{CREATE [OR ALTER] | RECREATE} PACKAGE package_name AS BEGIN [&lt;package_item&gt; ...] END {CREATE | RECREATE} PACKAGE BODY package_name AS BEGIN [&lt;package_item&gt; ...] [&lt;package_body_item&gt; ...] END &lt;package_item&gt; ::= &lt;function_decl&gt;; | &lt;procedure_decl&gt;; &lt;function_decl&gt; ::= FUNCTION func_name [(&lt;in_params&gt;)] RETURNS &lt;type&gt; [COLLATE collation] [DETERMINISTIC] &lt;procedure_decl&gt; ::= PROCEDURE proc_name [(&lt;in_params&gt;)] [RETURNS (&lt;out_params&gt;)] &lt;package_body_item&gt; ::= &lt;function_impl&gt; | &lt;procedure_impl&gt; &lt;function_impl&gt; ::= FUNCTION func_name [(&lt;in_impl_params&gt;)] RETURNS &lt;type&gt; [COLLATE collation] [DETERMINISTIC] &lt;routine body&gt; &lt;procedure_impl&gt; ::= PROCEDURE proc_name [(&lt;in_impl_params&gt;)] [RETURNS (&lt;out_params&gt;)] &lt;routine body&gt; &lt;routine body&gt; ::= &lt;sql routine body&gt; | &lt;external body reference&gt; &lt;sql routine body&gt; ::= AS   [&lt;declarations&gt;] BEGIN [&lt;PSQL_statements&gt;]   END &lt;declarations&gt; ::= &lt;declare_item&gt; [&lt;declare_item&gt; ...] &lt;declare_item&gt; ::= &lt;declare_var&gt;; | &lt;declare_cursor&gt;; | &lt;subroutine declaration&gt;; | &lt;subroutine implimentation&gt; &lt;subroutine declaration&gt; ::= &lt;subfunc_decl&gt; | &lt;subproc_decl&gt; &lt;subroutine implimentation&gt; ::= &lt;subfunc_impl&gt; | &lt;subproc_impl&gt; &lt;external body reference&gt; ::= EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt;[!&lt;misc info&gt;]'</code> </pre> </div></div><br><p>  Pour les proc√©dures et fonctions externes, le nom du package, les param√®tres d'entr√©e, leurs types, les valeurs par d√©faut et les param√®tres de sortie sont indiqu√©s dans l'en-t√™te du package, et tout est identique dans le corps du package, √† l'exception des valeurs par d√©faut, ainsi que l'emplacement dans le module externe (clause EXTERNAL NAME) , le nom du moteur et √©ventuellement le "corps" de la proc√©dure / fonction. </p><br><p>  Supposons que vous ayez √©crit un UDR pour travailler avec des expressions r√©guli√®res, qui se trouve dans le module externe PCRE (biblioth√®que dynamique), et que vous disposez de plusieurs UDR suppl√©mentaires qui effectuent d'autres t√¢ches.  Si nous n'avions pas utilis√© de packages PSQL, toutes nos proc√©dures et fonctions externes seraient m√©lang√©es √† la fois entre elles et avec les proc√©dures et fonctions PSQL ordinaires.  Cela complique la recherche de d√©pendances et la modification de modules externes, et cr√©e en outre de la confusion et force au moins l'utilisation de pr√©fixes pour regrouper les proc√©dures et les fonctions.  Les packages PSQL nous facilitent la t√¢che. </p><br><div class="spoiler">  <b class="spoiler_title">Forfait RegExp</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> TERM ^; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> REGEXP <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> preg_match( APattern <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>), ASubject <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> (Matches <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>)); FUNCTION preg_is_match( APattern VARCHAR(8192), ASubject VARCHAR(8192)) RETURNS BOOLEAN; FUNCTION preg_replace( APattern VARCHAR(8192), AReplacement VARCHAR(8192), ASubject VARCHAR(8192)) RETURNS VARCHAR(8192); PROCEDURE preg_split( APattern VARCHAR(8192), ASubject VARCHAR(8192)) RETURNS (Lines VARCHAR(8192)); FUNCTION preg_quote( AStr VARCHAR(8192), ADelimiter CHAR(10) DEFAULT NULL) RETURNS VARCHAR(8192); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>^ RECREATE <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> REGEXP <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> preg_match( APattern <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>), ASubject <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> (Matches <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'PCRE!preg_match'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span> UDR; FUNCTION preg_is_match( APattern VARCHAR(8192), ASubject VARCHAR(8192)) RETURNS BOOLEAN AS <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> preg_match(:APattern, :ASubject)); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> preg_replace( APattern <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>), AReplacement <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>), ASubject <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">8192</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'PCRE!preg_replace'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span> UDR; PROCEDURE preg_split( APattern VARCHAR(8192), ASubject VARCHAR(8192)) RETURNS (Lines VARCHAR(8192)) EXTERNAL NAME 'PCRE!preg_split' ENGINE UDR; FUNCTION preg_quote( AStr VARCHAR(8192), ADelimiter CHAR(10)) RETURNS VARCHAR(8192) EXTERNAL NAME 'PCRE!preg_quote' ENGINE UDR; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>^ <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> TERM ;^</code> </pre> </div></div><br><h3 id="vneshnie-triggery">  D√©clencheurs externes </h3><br><div class="spoiler">  <b class="spoiler_title">Syntaxe</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{CREATE [OR ALTER] | RECREATE} TRIGGER trigname {&lt;relation_trigger_legacy&gt; | &lt;relation_trigger_sql2003&gt; | &lt;database_trigger&gt; | &lt;ddl_trigger&gt; } &lt;external-body&gt; &lt;external-body&gt; ::= EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;relation_trigger_legacy&gt; ::= FOR {tablename | viewname} [ACTIVE | INACTIVE] {BEFORE | AFTER} &lt;mutation_list&gt; [POSITION number] &lt;relation_trigger_sql2003&gt; ::= [ACTIVE | INACTIVE] {BEFORE | AFTER} &lt;mutation_list&gt; [POSITION number] ON {tablename | viewname} &lt;database_trigger&gt; ::= [ACTIVE | INACTIVE] ON db_event [POSITION number] &lt;ddl_trigger&gt; ::= [ACTIVE | INACTIVE] {BEFORE | AFTER} &lt;ddl_events&gt; [POSITION number] &lt;mutation_list&gt; ::= &lt;mutation&gt; [OR &lt;mutation&gt; [OR &lt;mutation&gt;]] &lt;mutation&gt; ::= INSERT | UPDATE | DELETE &lt;db_event&gt; ::= CONNECT | DISCONNECT | TRANSACTION START | TRANSACTION COMMIT | TRANSACTION ROLLBACK &lt;ddl_events&gt; ::= ANY DDL STATEMENT | &lt;ddl_event_item&gt; [{OR &lt;ddl_event_item&gt;} ...] &lt;ddl_event_item&gt; ::= CREATE TABLE | ALTER TABLE | DROP TABLE | CREATE PROCEDURE | ALTER PROCEDURE | DROP PROCEDURE | CREATE FUNCTION | ALTER FUNCTION | DROP FUNCTION | CREATE TRIGGER | ALTER TRIGGER | DROP TRIGGER | CREATE EXCEPTION | ALTER EXCEPTION | DROP EXCEPTION | CREATE VIEW | ALTER VIEW | DROP VIEW | CREATE DOMAIN | ALTER DOMAIN | DROP DOMAIN | CREATE ROLE | ALTER ROLE | DROP ROLE | CREATE SEQUENCE | ALTER SEQUENCE | DROP SEQUENCE | CREATE USER | ALTER USER | DROP USER | CREATE INDEX | ALTER INDEX | DROP INDEX | CREATE COLLATION | DROP COLLATION | ALTER CHARACTER SET | CREATE PACKAGE | ALTER PACKAGE | DROP PACKAGE | CREATE PACKAGE BODY | DROP PACKAGE BODY | CREATE MAPPING | ALTER MAPPING | DROP MAPPING</code> </pre> <br><p>  Un d√©clencheur externe peut √™tre modifi√© √† l'aide de l'instruction ALTER TRIGGER. </p><br><p>  <strong>Syntaxe:</strong> </p><br><pre> <code class="plaintext hljs">ALTER TRIGGER trigname { [ACTIVE | INACTIVE] [ {BEFORE | AFTER} {&lt;mutation_list&gt; | &lt;ddl_events&gt;} | ON db_event ] [POSITION number] [&lt;external-body&gt;] &lt;external-body&gt; ::= EXTERNAL NAME &lt;extname&gt; ENGINE &lt;engine&gt; [AS &lt;extbody&gt;] &lt;extname&gt; ::= '&lt;module name&gt;!&lt;routine name&gt;[!&lt;misc info&gt;]' &lt;mutation_list&gt; ::= &lt;mutation&gt; [OR &lt;mutation&gt; [OR &lt;mutation&gt;]] &lt;mutation&gt; ::= { INSERT | UPDATE | DELETE }</code> </pre> </div></div><br><p>  Vous pouvez supprimer un d√©clencheur externe √† l'aide de l'instruction DROP TRIGGER. </p><br><p>  <strong>Syntaxe:</strong> </p><br><pre> <code class="plaintext hljs">DROP TRIGGER trigname</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  Param√®tre </th><th>  La description </th></tr></thead><tbody><tr><td>  trigname </td><td>  Le nom du d√©clencheur.  Peut contenir jusqu'√† 31 octets. </td></tr><tr><td>  relation_trigger_legacy </td><td>  D√©claration de d√©clencheur de table (h√©rit√©). </td></tr><tr><td>  relation_trigger_sql2003 </td><td>  D√©claration d'un d√©clencheur de table selon la norme SQL-2003. </td></tr><tr><td>  base de donn√©es_trigger </td><td>  D√©claration de d√©clenchement de la base de donn√©es. </td></tr><tr><td>  ddl_trigger </td><td>  D√©claration de d√©clenchement DDL. </td></tr><tr><td>  nom de table </td><td>  Le nom de la table. </td></tr><tr><td>  nom_vue </td><td>  Le nom de la vue. </td></tr><tr><td>  mutation_list </td><td>  Liste des √©v√©nements de table. </td></tr><tr><td>  mutation </td><td>  Un des √©v√©nements de la table. </td></tr><tr><td>  db_event </td><td>  Un √©v√©nement de connexion ou de transaction. </td></tr><tr><td>  ddl_events </td><td>  Liste des √©v√©nements de changement de m√©tadonn√©es. </td></tr><tr><td>  ddl_event_item </td><td>  L'un des √©v√©nements de changement de m√©tadonn√©es. </td></tr><tr><td>  nombre </td><td>  L'ordre de d√©clenchement.  0 √† 32767 </td></tr><tr><td>  extbody </td><td>  Le corps d'un d√©clencheur externe.  Litt√©ral de cha√Æne pouvant √™tre utilis√© par l'UDR √† diverses fins. </td></tr><tr><td>  nom du module </td><td>  Nom du module externe dans lequel se trouve le d√©clencheur. </td></tr><tr><td>  nom de routine </td><td>  Nom interne du d√©clencheur √† l'int√©rieur du module externe. </td></tr><tr><td>  informations diverses </td><td>  Informations d√©finies par l'utilisateur pour le transfert vers le d√©clencheur d'un module externe. </td></tr><tr><td>  moteur </td><td>  Nom du moteur d'utilisation des d√©clencheurs externes.  Habituellement, le nom est UDR. </td></tr></tbody></table></div><br><p>  Voici des exemples de d√©claration de d√©clencheurs externes avec des explications. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> <span class="hljs-string"><span class="hljs-string">'c:\temp\slave.fdb'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> persons ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, address <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>), info <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span> sub_type <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> <span class="hljs-string"><span class="hljs-string">'c:\temp\master.fdb'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> persons ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, address <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">60</span></span>), info <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span> sub_type <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> replicate_config ( <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">31</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, data_source <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> replicate_config (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, data_source) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'ds1'</span></span>, <span class="hljs-string"><span class="hljs-string">'c:\temp\slave.fdb'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> persons_replicate <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> persons <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'udrcpp_example!replicate!ds1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p>  L'impl√©mentation du d√©clencheur se trouve dans le module udrcpp_example.  √Ä l'int√©rieur de ce module, un d√©clencheur est enregistr√© sous le nom r√©pliqu√©.  Un d√©clencheur externe utilise le moteur UDR. </p><br><p>  Dans le lien vers le module externe, un param√®tre suppl√©mentaire <code>ds1</code> , selon lequel la configuration est lue dans la table <em>replicate_config</em> √† l'int√©rieur du d√©clencheur externe pour la communication avec la base de donn√©es externe. </p><br><h2 id="struktura-udr">  Structure UDR </h2><br><p>  Il est maintenant temps d'√©crire le premier UDR.  Nous d√©crirons la structure de l'UDR en Pascal.  Pour expliquer la structure minimale de construction d'un UDR, nous utiliserons des exemples standard d' <code>examples/udr/</code> traduits en Pascal. </p><br><p>  Cr√©ez un nouveau projet pour la nouvelle biblioth√®que dynamique, que nous appellerons MyUdr.  Par cons√©quent, vous devriez obtenir le fichier <code>MyUdr.dpr</code> (si vous avez cr√©√© le projet dans Delphi) ou le fichier <code>MyUdr.lpr</code> (si vous avez cr√©√© le projet dans Lazarus).  Modifions maintenant le fichier de projet principal pour qu'il ressemble √† ceci: </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> MyUdr; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF unix}</span></span> cthreads, <span class="hljs-comment"><span class="hljs-comment">// the c memory manager is on some systems much faster for multi-threading cmem, {$ENDIF} UdrInit in 'UdrInit.pas', SumArgsFunc in 'SumArgsFunc.pas'; exports firebird_udr_plugin; end.</span></span></code> </pre> <br><p>  Dans ce cas, vous devez exporter une seule fonction <code>firebird_udr_plugin</code> , qui est le point d'entr√©e pour le plug-in des modules UDR externes.  L'impl√©mentation de cette fonction sera localis√©e dans le module UdrInit. </p><br><blockquote>  <strong>Remarque</strong> <br><br>  Si vous d√©veloppez votre UDR en Free Pascal, vous aurez besoin de directives suppl√©mentaires.  La <code>{$mode objfpc}</code> est requise pour activer le mode Object Pascal.  √Ä la place, vous pouvez utiliser la directive <code>{$mode delphi}</code> pour assurer la compatibilit√© avec Delphi.  Comme mes exemples devraient se compiler avec succ√®s dans FPC et Delphi, je choisis le <code>{$mode delphi}</code> . <br><br>  La directive <code>{$H+}</code> inclut la prise en charge des cha√Ænes longues.  Cela est n√©cessaire si vous utilisez les types cha√Æne, ansistring, et pas seulement les cha√Ænes termin√©es par null PChar, PAnsiChar, PWideChar. <br><br>  De plus, nous devrons connecter des modules s√©par√©s pour prendre en charge le multithreading sur Linux et d'autres syst√®mes d'exploitation de type Unix. </blockquote><br><h3 id="registraciya-procedur-funkciy-ili-triggerov">  Enregistrer des proc√©dures, des fonctions ou des d√©clencheurs </h3><br><p>  Ajoutez maintenant le module UdrInit, il devrait ressembler √† ceci: </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> UdrInit; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird; <span class="hljs-comment"><span class="hljs-comment">//    External Engine  UDR function firebird_udr_plugin(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin): BooleanPtr; cdecl; implementation uses SumArgsFunc; var myUnloadFlag: Boolean; theirUnloadFlag: BooleanPtr; function firebird_udr_plugin(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin): BooleanPtr; cdecl; begin //    AUdrPlugin.registerFunction(AStatus, 'sum_args', TSumArgsFunctionFactory.Create()); //    //AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc', // TSumArgsProcedureFactory.Create()); //AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create()); //    //AUdrPlugin.registerTrigger(AStatus, 'test_trigger', // TMyTriggerFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end; initialization myUnloadFlag := false; finalization if ((theirUnloadFlag &lt;&gt; nil) and not myUnloadFlag) then theirUnloadFlag^ := true; end.</span></span></code> </pre> <br><p>  Dans la fonction <code>firebird_udr_plugin</code> , <code>firebird_udr_plugin</code> n√©cessaire d'enregistrer les usines de nos proc√©dures, fonctions et d√©clencheurs externes.  Pour chaque fonction, proc√©dure ou d√©clencheur, vous devez √©crire votre propre usine.  Cela se fait √† l'aide des m√©thodes d'interface IUdrPlugin: </p><br><ul><li> registerFunction ‚Äî   ; </li><li> registerProcedure ‚Äî   ; </li><li> registerTrigger ‚Äî   . </li></ul><br><p>         ,      (  ).       //  SQL.         (  ). </p><br><h3 id="realizaciya-vneshney-funkcii">    </h3><br><p>       .      SumArgsFunc.         . </p><br><div class="spoiler"> <b class="spoiler_title">   SumArgsFunc</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> SumArgsFunc; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird; <span class="hljs-comment"><span class="hljs-comment">// ********************************************************* // create function sum_args ( // n1 integer, // n2 integer, // n3 integer // ) returns integer // external name 'myudr!sum_args' // engine udr; // ********************************************************* type //        TSumArgsInMsg = record n1: Integer; n1Null: WordBool; n2: Integer; n2Null: WordBool; n3: Integer; n3Null: WordBool; end; PSumArgsInMsg = ^TSumArgsInMsg; //        TSumArgsOutMsg = record result: Integer; resultNull: WordBool; end; PSumArgsOutMsg = ^TSumArgsOutMsg; //       TSumArgsFunction TSumArgsFunctionFactory = class(IUdrFunctionFactoryImpl) //     procedure dispose(); override; {          .        . @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @param(AInBuilder     ) @param(AOutBuilder     ) } procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; {      TSumArgsFunction @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @returns(  ) } function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; override; end; //   TSumArgsFunction. TSumArgsFunction = class(IExternalFunctionImpl) //      procedure dispose(); override; {      execute             .        ,   ExternalEngine::getCharSet. @param(AStatus  ) @param(AContext    ) @param(AName   ) @param(AName    ) } procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {    @param(AStatus  ) @param(AContext    ) @param(AInMsg    ) @param(AOutMsg    ) } procedure execute(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer); override; end; implementation { TSumArgsFunctionFactory } procedure TSumArgsFunctionFactory.dispose; begin Destroy; end; function TSumArgsFunctionFactory.newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; begin Result := TSumArgsFunction.Create(); end; procedure TSumArgsFunctionFactory.setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder); begin end; { TSumArgsFunction } procedure TSumArgsFunction.dispose; begin Destroy; end; procedure TSumArgsFunction.execute(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer); var xInput: PSumArgsInMsg; xOutput: PSumArgsOutMsg; begin //         xInput := PSumArgsInMsg(AInMsg); xOutput := PSumArgsOutMsg(AOutMsg); //     NULL    NULL xOutput^.resultNull := xInput^.n1Null or xInput^.n2Null or xInput^.n3Null; xOutput^.result := xInput^.n1 + xInput^.n2 + xInput^.n3; end; procedure TSumArgsFunction.getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); begin end; end.</span></span></code> </pre> </div></div><br><p>       IUdrFunctionFactory.      IUdrFunctionFactoryImpl.       . ,         ,        .       . </p><br><p>  dispose    ,        .      . </p><br><p>  setup          .            ,        .      . </p><br><p>  newItem      .        ,       .   IRoutineMetadata        ,      .                 PSQL.           .          <code>TSumArgsFunction</code> . </p><br><p>      IExternalFunction.      <code>IExternalFunctionImpl</code> . </p><br><p>  dispose     ,        .      . </p><br><p>      . </p><br><p>  getCharSet   ,             .       ,               . </p><br><p>  execute     .        ,     ,      . </p><br><p>             .             ,        ,      BLOB.     BLOB,          . </p><br><p>       ,            .         ,      .   ,          ,    ,      NULL ( Null ).          ,             ,       IMessageMetadata.        ,         execute. </p><br><p>         .  Pour <br>    Null     Null  <br>    ,         NULL,   <br>       </p><br><h3 id="realizaciya-vneshney-procedury">    </h3><br><p>      UDR   .       :         .     , ..           EXECUTE PROCEDURE       . </p><br><p>    UdrInit    <code>firebird_udr_plugin</code>      . </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerFunction(AStatus, 'sum_args', TSumArgsFunctionFactory.Create()); //    AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc', TSumArgsProcedureFactory.Create()); //AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create()); //    //AUdrPlugin.registerTrigger(AStatus, 'test_trigger', // TMyTriggerFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><blockquote>  <strong>Remarque</strong> <br><br>      uses  SumArgsProc,       . </blockquote><p>       IUdrProcedureFactory.      IUdrProcedureFactoryImpl.       . ,         ,        .       . </p><br><p>  dispose    ,        .      . </p><br><p>  setup          .            ,        .      . </p><br><p>  newItem      .        ,       .   IRoutineMetadata        ,      .                 PSQL.           .          <code>TSumArgsProcedure</code> . </p><br><p>          SumArgsProc. </p><br><div class="spoiler"> <b class="spoiler_title">   SumArgsProc</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> SumArgsProc; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird; <span class="hljs-comment"><span class="hljs-comment">{ ********************************************************** create procedure sp_sum_args ( n1 integer, n2 integer, n3 integer ) returns (result integer) external name 'myudr!sum_args_proc' engine udr; ********************************************************* }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//        TSumArgsInMsg = record n1: Integer; n1Null: WordBool; n2: Integer; n2Null: WordBool; n3: Integer; n3Null: WordBool; end; PSumArgsInMsg = ^TSumArgsInMsg; //        TSumArgsOutMsg = record result: Integer; resultNull: WordBool; end; PSumArgsOutMsg = ^TSumArgsOutMsg; //       TSumArgsProcedure TSumArgsProcedureFactory = class(IUdrProcedureFactoryImpl) //     procedure dispose(); override; {                  . @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @param(AInBuilder     ) @param(AOutBuilder     ) } procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; {      TSumArgsProcedure @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @returns(  ) } function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; override; end; TSumArgsProcedure = class(IExternalProcedureImpl) public //      procedure dispose(); override; {      open             .        ,   ExternalEngine::getCharSet. @param(AStatus  ) @param(AContext    ) @param(AName   ) @param(AName    ) } procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {    @param(AStatus  ) @param(AContext    ) @param(AInMsg    ) @param(AOutMsg    ) @returns(      nil   ) } function open(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer): IExternalResultSet; override; end; implementation { TSumArgsProcedureFactory } procedure TSumArgsProcedureFactory.dispose; begin Destroy; end; function TSumArgsProcedureFactory.newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; begin Result := TSumArgsProcedure.create; end; procedure TSumArgsProcedureFactory.setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder); begin end; { TSumArgsProcedure } procedure TSumArgsProcedure.dispose; begin Destroy; end; procedure TSumArgsProcedure.getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); begin end; function TSumArgsProcedure.open(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer): IExternalResultSet; var xInput: PSumArgsInMsg; xOutput: PSumArgsOutMsg; begin Result := nil; //         xInput := PSumArgsInMsg(AInMsg); xOutput := PSumArgsOutMsg(AOutMsg); //     NULL    NULL xOutput^.resultNull := xInput^.n1Null or xInput^.n2Null or xInput^.n3Null; xOutput^.result := xInput^.n1 + xInput^.n2 + xInput^.n3; end; end.</span></span></code> </pre> </div></div><br><p>      IExternalProcedure.      <code>IExternalProcedureImpl</code> . </p><br><p>  dispose     ,        .      . </p><br><p>  getCharSet                .       ,               . </p><br><p>  open     .        ,     ,      .     ,      nil,           .          .      TSumArgsFunction.execute. </p><br><h3 id="hranimaya-procedura-vybora">    </h3><br><p>     UDR    .      <code>firebird_udr_plugin</code> . </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerFunction(AStatus, 'sum_args', TSumArgsFunctionFactory.Create()); //    AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc', TSumArgsProcedureFactory.Create()); AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create()); //    //AUdrPlugin.registerTrigger(AStatus, 'test_trigger', // TMyTriggerFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><blockquote>  <strong>Remarque</strong> <br><br>      uses  GenRowsProc,       . </blockquote><p>           .     ,    open,    . </p><br><div class="spoiler"> <b class="spoiler_title">   GenRowsProc</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> GenRowsProc; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">{ ********************************************************** create procedure gen_rows ( start integer, finish integer ) returns (n integer) external name 'myudr!gen_rows' engine udr; ********************************************************* }</span></span> TInput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> start: Integer; startNull: WordBool; finish: Integer; finishNull: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PInput = ^TInput; TOutput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> n: Integer; nNull: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; POutput = ^TOutput; <span class="hljs-comment"><span class="hljs-comment">//       TGenRowsProcedure TGenRowsFactory = class(IUdrProcedureFactoryImpl) //     procedure dispose(); override; {          .        . @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @param(AInBuilder     ) @param(AOutBuilder     ) } procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; {      TGenRowsProcedure @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @returns(  ) } function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; override; end; //   TGenRowsProcedure. TGenRowsProcedure = class(IExternalProcedureImpl) public //      procedure dispose(); override; {      open             .        ,   ExternalEngine::getCharSet. @param(AStatus  ) @param(AContext    ) @param(AName   ) @param(AName    ) } procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {    @param(AStatus  ) @param(AContext    ) @param(AInMsg    ) @param(AOutMsg    ) @returns(      nil   ) } function open(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer): IExternalResultSet; override; end; //      TGenRowsProcedure TGenRowsResultSet = class(IExternalResultSetImpl) Input: PInput; Output: POutput; //       procedure dispose(); override; {      .     SUSPEND.          . @param(AStatus  ) @returns(True        , False   ) } function fetch(AStatus: IStatus): Boolean; override; end; implementation { TGenRowsFactory } procedure TGenRowsFactory.dispose; begin Destroy; end; function TGenRowsFactory.newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; begin Result := TGenRowsProcedure.create; end; procedure TGenRowsFactory.setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder); begin end; { TGenRowsProcedure } procedure TGenRowsProcedure.dispose; begin Destroy; end; procedure TGenRowsProcedure.getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); begin end; function TGenRowsProcedure.open(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer): IExternalResultSet; begin //      NULL    if PInput(AInMsg).startNull or PInput(AInMsg).finishNull then begin POutput(AOutMsg).nNull := True; Result := nil; exit; end; //  if PInput(AInMsg).start &gt; PInput(AInMsg).finish then raise Exception.Create('First parameter greater then second parameter.'); Result := TGenRowsResultSet.create; with TGenRowsResultSet(Result) do begin Input := AInMsg; Output := AOutMsg; //   Output.nNull := False; Output.n := Input.start - 1; end; end; { TGenRowsResultSet } procedure TGenRowsResultSet.dispose; begin Destroy; end; //   True       . //   False       //         //     function TGenRowsResultSet.fetch(AStatus: IStatus): Boolean; begin Inc(Output.n); Result := (Output.n &lt;= Input.finish); end; end.</span></span></code> </pre> </div></div><br><p>   open   <code>TGenRowsProcedure</code>         NULL,      NULL,      NULL,              SELECT,      nil. </p><br><p>    ,       ,     .         UDR     Firebird.      UDR  Legacy UDF. </p><br><p>     ,   open     ,    IExternalResultSet.         <code>IExternalResultSetImpl</code> . </p><br><p>  dispose     .      . </p><br><p>  fetch       SELECT.        SUSPEND    PSQL  .     ,        .   true,       ,  <code>false</code> ,      .             ,      . </p><br><blockquote>  <strong>Remarque</strong> <br><br>  Delphi    yeild,          <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { ... yield result; }</code> </pre> <br><br>      ,     open,  ,          fetch.            (   SELECT   FIRST/ROWS/FETCH FIRST   SELECT.) </blockquote><br><h3 id="realizaciya-vneshnego-triggera">    </h3><br><p>     UDR   . </p><br><blockquote> <strong>Note</strong> <br><br>     C++        .  ,           .          . </blockquote><p>    UdrInit    <code>firebird_udr_plugin</code>      . </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerFunction(AStatus, 'sum_args', TSumArgsFunctionFactory.Create()); //    AUdrPlugin.registerProcedure(AStatus, 'sum_args_proc', TSumArgsProcedureFactory.Create()); AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create()); //    AUdrPlugin.registerTrigger(AStatus, 'test_trigger', TMyTriggerFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><blockquote>  <strong>Remarque</strong> <br><br>      uses  TestTrigger,       . </blockquote><p>       IUdrTriggerFactory.      IUdrTriggerFactoryImpl.       <br> . </p><br><p>  dispose    ,        .      . </p><br><p>  setup          .            ,        .      . </p><br><p>  newItem      .        ,       .   IRoutineMetadata           ,      .                 PSQL.           .          <code>TMyTrigger</code> . </p><br><p>          TestTrigger. </p><br><div class="spoiler"> <b class="spoiler_title">   TestTrigger</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> TestTrigger; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">{ ********************************************************** create table test ( id int generated by default as identity, a int, b int, name varchar(100), constraint pk_test primary key(id) ); create or alter trigger tr_test_biu for test active before insert or update position 0 external name 'myudr!test_trigger' engine udr; }</span></span> <span class="hljs-comment"><span class="hljs-comment">//     NEW.*  OLD.* //      test TFieldsMessage = record Id: Integer; IdNull: WordBool; A: Integer; ANull: WordBool; B: Integer; BNull: WordBool; Name: record Length: Word; Value: array [0 .. 399] of AnsiChar; end; NameNull: WordBool; end; PFieldsMessage = ^TFieldsMessage; //       TMyTrigger TMyTriggerFactory = class(IUdrTriggerFactoryImpl) //     procedure dispose(); override; {          .       . @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @param(AFieldsBuilder     ) } procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder); override; {      TMyTrigger @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @returns(  ) } function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalTrigger; override; end; TMyTrigger = class(IExternalTriggerImpl) //     procedure dispose(); override; {      execute             .        ,   ExternalEngine::getCharSet. @param(AStatus  ) @param(AContext    ) @param(AName   ) @param(AName    ) } procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {   TMyTrigger @param(AStatus  ) @param(AContext    ) @param(AAction  ( ) ) @param(AOldMsg      :OLD.*) @param(ANewMsg      :NEW.*) } procedure execute(AStatus: IStatus; AContext: IExternalContext; AAction: Cardinal; AOldMsg: Pointer; ANewMsg: Pointer); override; end; implementation { TMyTriggerFactory } procedure TMyTriggerFactory.dispose; begin Destroy; end; function TMyTriggerFactory.newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalTrigger; begin Result := TMyTrigger.create; end; procedure TMyTriggerFactory.setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder); begin end; { TMyTrigger } procedure TMyTrigger.dispose; begin Destroy; end; procedure TMyTrigger.execute(AStatus: IStatus; AContext: IExternalContext; AAction: Cardinal; AOldMsg, ANewMsg: Pointer); var xOld, xNew: PFieldsMessage; begin // xOld := PFieldsMessage(AOldMsg); xNew := PFieldsMessage(ANewMsg); case AAction of IExternalTrigger.ACTION_INSERT: begin if xNew.BNull and not xNew.ANull then begin xNew.B := xNew.A + 1; xNew.BNull := False; end; end; IExternalTrigger.ACTION_UPDATE: begin if xNew.BNull and not xNew.ANull then begin xNew.B := xNew.A + 1; xNew.BNull := False; end; end; IExternalTrigger.ACTION_DELETE: begin end; end; end; procedure TMyTrigger.getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); begin end; end.</span></span></code> </pre> </div></div><br><p>      IExternalTrigger.      <code>IExternalTriggerImpl</code> . </p><br><p>  dispose     ,        .      . </p><br><p>  getCharSet                .       ,           . </p><br><p>  execute            .        ,     ,  ()              .   ()      IExternalTrigger.      <code>ACTION_</code> .     ,   Firebird       .        ,  DDL ,      ,         ,           nil.                 .          ,          ,      . </p><br><blockquote>  <strong>Remarque</strong> <br><br>  ,        ,             .             IMessageMetadata.        ,          .       ,      ,      /. </blockquote><p>        ,       PSQL  </p><br><pre> <code class="sql hljs"> if (:new.B IS NULL) THEN :new.B = :new.A + 1;</code> </pre> <br><h2 id="soobscheniya">  Des messages </h2><br><p>    UDR             ,    .                NEW  OLD. </p><br><p>        ,       ,      . <br>         : </p><br><ul><li><p>           ( Delphi  , .. record); </p><br></li><li><p>         IMessageMetadata,  /   ,      . </p><br></li></ul><br><p>     ,  ‚Äî  ,                        UDR. </p><br><h3 id="rabota-s-buferom-soobscheniya-s-ispolzovaniem-struktury">        </h3><br><p>             .     : </p><br><pre> <code class="plaintext hljs">TMyStruct = record &lt;var_1&gt;: &lt;type_1&gt;; &lt;nullIndicator_1&gt;: WordBool; &lt;var_2&gt;: &lt;type_1&gt;; &lt;nullIndicator_2&gt;: WordBool; ... &lt;var_N&gt;: &lt;type_1&gt;; &lt;nullIndicator_N&gt;: WordBool; end; PMyStruct = ^TMyStruct;</code> </pre> <br><p>       /    ( ). Null-     /,       NOT NULL. Null-  2 .  -1   <br> /   NULL.      NULL-    NULL,      2-   .   SQL     : </p><br><div class="scrollable-table"><table><tbody><tr><th> SQL  </th><th> Delphi  </th><th>  </th></tr><tr><td> BOOLEAN </td><td> Boolean, ByteBool </td><td></td></tr><tr><td> SMALLINT </td><td> Smallint </td><td></td></tr><tr><td> INTEGER </td><td> Integer </td><td></td></tr><tr><td> BIGINT </td><td> Int64 </td><td></td></tr><tr><td> FLOAT </td><td> Single </td><td></td></tr><tr><td> DOUBLE PRECISION </td><td> Double </td><td></td></tr><tr><td> NUMERIC(N, M) </td><td>       : <br><ul><li> 1-4 ‚Äî Smallint; </li><li> 5-9 ‚Äî Integer; </li><li> 10-18 (3 ) ‚Äî Int64; </li><li> 10-15 (1 ) ‚Äî Double. </li></ul><br></td><td>           <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.284ex" height="2.419ex" viewBox="0 -935.7 1844.5 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-4D" x="1415" y="557"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1">10^M</script>  . </td></tr><tr><td> DECIMAL(N, M) </td><td>       : <br><ul><li> 1-4 ‚Äî Integer; </li><li> 5-9 ‚Äî Integer; </li><li> 10-18 (3 ) ‚Äî Int64; </li><li> 10-15 (1 ) ‚Äî Double. </li></ul><br></td><td>           <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.284ex" height="2.419ex" viewBox="0 -935.7 1844.5 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-4D" x="1415" y="557"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2">10^M</script>  . </td></tr><tr><td> CHAR(N) </td><td> array[0‚Ä¶ M] of AnsiChar </td><td> M    <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="28.996ex" height="2.419ex" viewBox="0 -780.1 12484.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-4D" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-3D" x="1329" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-4E" x="2385" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-2217" x="3496" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-42" x="4219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-79" x="4978" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-74" x="5476" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-65" x="5837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-73" x="6304" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-50" x="6773" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-65" x="7525" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-72" x="7991" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-43" x="8443" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-68" x="9203" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-61" x="9780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-72" x="10309" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-2212" x="10983" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-31" x="11983" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3">M = N * BytesPerChar - 1</script>  , <br>  BytesPerChar ‚Äî    ,    /.   UTF-8 ‚Äî  4 /,  WIN1251 ‚Äî 1 /. </td></tr><tr><td> VARCHAR(N) </td><td> FbVarChar&lt;N&gt; </td><td> M    <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="28.996ex" height="2.419ex" viewBox="0 -780.1 12484.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-4D" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-3D" x="1329" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-4E" x="2385" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-2217" x="3496" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-42" x="4219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-79" x="4978" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-74" x="5476" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-65" x="5837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-73" x="6304" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-50" x="6773" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-65" x="7525" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-72" x="7991" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-43" x="8443" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-68" x="9203" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-61" x="9780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMATHI-72" x="10309" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-2212" x="10983" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/455375/&amp;usg=ALkJrhi-m2N8tGx6_3cM14LPTt1R_Q4t6Q#MJMAIN-31" x="11983" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4">M = N * BytesPerChar - 1</script>  , <br>  BytesPerChar ‚Äî    ,    /.   UTF-8 ‚Äî  4 /,  WIN1251 ‚Äî 1 /.  Length      .  Delphi        C++, <br>     FbVarChar&lt;N&gt; ,  <br>        .   . </td></tr><tr><td> DATE </td><td> ISC_DATE </td><td></td></tr><tr><td> TIME </td><td> ISC_TIME </td><td></td></tr><tr><td> TIMESTAMP </td><td> ISC_TIMESTAMP </td><td>  ISC_TIMESTAMP    Firebird.pas,     .      . </td></tr><tr><td> BLOB </td><td> ISC_QUAD </td><td>  BLOB    ,    BlobId.     BLOB   . </td></tr></tbody></table></div><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//      VARCHAR(N) // M = N * BytesPerChar - 1 record Length: Smallint; Data: array[0 .. M] of AnsiChar; end; //      TIMESTAMP ISC_TIMESTAMP = record date: ISC_DATE; time: ISC_TIME; end;</span></span></code> </pre> <br><p>         <br>    ,   . </p><br><p>         : </p><br><pre> <code class="plaintext hljs">function SUM_ARGS(A SMALLINT, B INTEGER) RETURNS BIGINT ....</code> </pre> <br><p>            <br> : </p><br><pre> <code class="plaintext hljs">TInput = record A: Smallint; ANull: WordBool; B: Integer; BNull: WordBool; end; PInput = ^TInput; TOutput = record Value: Int64; Null: WordBool; end; POutput = ^TOutput;</code> </pre> <br><p>          ( 3 ): </p><br><pre> <code class="sql hljs">function SUM_ARGS(A NUMERIC(4, 2), B NUMERIC(9, 3)) RETURNS NUMERIC(18, 6) ....</code> </pre> <br><p>            <br> : </p><br><pre> <code class="delphi hljs">TInput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> A: Smallint; ANull: WordBool; B: Integer; BNull: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PInput = ^TInput; TOutput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Value: Int64; Null: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; POutput = ^TOutput;</code> </pre> <br><p>         : </p><br><pre> <code class="sql hljs">procedure SOME_PROC(A CHAR(3) CHARACTER <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> WIN1251, B <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8) ....</code> </pre> <br><p>          : </p><br><pre> <code class="delphi hljs">TInput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> A: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AnsiChar; ANull: WordBool; B: <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Length: Smallint; Value: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">39</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AnsiChar; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; BNull: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PInput = ^TInput;</code> </pre> <br><h3 id="rabota-s-buferom-soobscheniy-s-pomoschyu-imessagemetadata">       IMessageMetadata </h3><br><p>           <br>      <br> IMessageMetadata.      / <br>  : </p><br><ul><li>  /; </li><li>  ; </li><li>     ; </li><li>     BLOB; </li><li>      /; </li><li>   /   NULL; </li><li>      ; </li><li>      NULL-. </li></ul><br><h4 id="metody-interfeysa-imessagemetadata">   IMessageMetadata </h4><br><ol><li><p> getCount </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status)</span></span></span></span></code> </pre> <br><p>   /  .   ,   ,    : 0 &lt;= index &lt; getCount(). </p><br></li><li><p> getField </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>   . </p><br></li><li><p> getRelation </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRelation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>    (    ). </p><br></li><li><p> getOwner </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>    . </p><br></li><li><p> getAlias </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAlias</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>   . </p><br></li><li><p> getType </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>  SQL  . </p><br></li><li><p> isNullable </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FB_BOOLEAN </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isNullable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>  true,      NULL. </p><br></li><li><p> getSubType </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSubType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>    BLOB (0 ‚Äî , 1 ‚Äî   . .). </p><br></li><li><p> getLength </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>      . </p><br></li><li><p> getScale </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getScale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>     . </p><br></li><li><p> getCharSet </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCharSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>         BLOB. </p><br></li><li><p> getOffset </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>        (        ). </p><br></li><li><p> getNullOffset </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNullOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span></code> </pre> <br><p>   NULL      . </p><br></li><li><p> getBuilder </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">IMetadataBuilder* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBuilder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status)</span></span></span></span></code> </pre> <br><p>   IMetadataBuilder,    . </p><br></li><li><p> getMessageLength </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMessageLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatusType* status)</span></span></span></span></code> </pre> <br><p>     (      ). </p><br></li></ol><br><h4 id="poluchenie-i-ispolzovanie-imessagemetadata">    IMessageMetadata </h4><br><p>     IMessageMetadata          IRoutineMetadata.       ,   .        .  Par exemple: </p><br><div class="spoiler"> <b class="spoiler_title">   RoutineMetadata</b> <div class="spoiler_text"><pre> <code class="delphi hljs"> <span class="hljs-comment"><span class="hljs-comment">//       TSumArgsFunction TSumArgsFunctionFactory = class(IUdrFunctionFactoryImpl) //     procedure dispose(); override; {           @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @param(AInBuilder     ) @param(AOutBuilder     ) } procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; {      TSumArgsFunction @param(AStatus  ) @param(AContext    ) @param(AMetadata   ) @returns(  ) } function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; override; end; //   TSumArgsFunction. TSumArgsFunction = class(IExternalFunctionImpl) private FMetadata: IRoutineMetadata; public property Metadata: IRoutineMetadata read FMetadata write FMetadata; public //      procedure dispose(); override; {      execute             .        ,   ExternalEngine::getCharSet. @param(AStatus  ) @param(AContext    ) @param(AName   ) @param(AName    ) } procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {    @param(AStatus  ) @param(AContext    ) @param(AInMsg    ) @param(AOutMsg    ) } procedure execute(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer); override; end; ........................ { TSumArgsFunctionFactory } procedure TSumArgsFunctionFactory.dispose; begin Destroy; end; function TSumArgsFunctionFactory.newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; begin Result := TSumArgsFunction.Create(); with Result as TSumArgsFunction do begin Metadata := AMetadata; end; end; procedure TSumArgsFunctionFactory.setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder); begin end;</span></span></code> </pre> </div></div><br><p>  IMessageMetadata           getInputMetadata  getOutputMetadata  IRoutineMetadata.    ,    ,      getTriggerMetadata. </p><br><blockquote> <strong></strong> <br><br>  ,     IMessageMetadata     .    IReferenceCounted.  getInputMetadata  getOutputMetadata     1   ,             <code>xInputMetadata</code>  <code>xOutputMetadata</code>   release. </blockquote><p>           .      IMessageMetadata    getOffset        .         .    <br>     null  ,       getNullOffset. </p><br><div class="spoiler"> <b class="spoiler_title">     IMessageMetadata</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// ........................ procedure TSumArgsFunction.execute(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer); var n1, n2, n3: Integer; n1Null, n2Null, n3Null: WordBool; Result: Integer; resultNull: WordBool; xInputMetadata, xOutputMetadata: IMessageMetadata; begin xInputMetadata := FMetadata.getInputMetadata(AStatus); xOutputMetadata := FMetadata.getOutputMetadata(AStatus); try //        n1 := PInteger(PByte(AInMsg) + xInputMetadata.getOffset(AStatus, 0))^; n2 := PInteger(PByte(AInMsg) + xInputMetadata.getOffset(AStatus, 1))^; n3 := PInteger(PByte(AInMsg) + xInputMetadata.getOffset(AStatus, 2))^; //   null-      n1Null := PWordBool(PByte(AInMsg) + xInputMetadata.getNullOffset(AStatus, 0))^; n2Null := PWordBool(PByte(AInMsg) + xInputMetadata.getNullOffset(AStatus, 1))^; n3Null := PWordBool(PByte(AInMsg) + xInputMetadata.getNullOffset(AStatus, 2))^; //     = NULL,     nullFlag resultNull := True; Result := 0; //     NULL    NULL //       if not(n1Null or n2Null or n3Null) then begin Result := n1 + n2 + n3; //   ,   NULL  resultNull := False; end; PWordBool(PByte(AInMsg) + xOutputMetadata.getNullOffset(AStatus, 0))^ := resultNull; PInteger(PByte(AInMsg) + xOutputMetadata.getOffset(AStatus, 0))^ := Result; finally xInputMetadata.release; xOutputMetadata.release; end; end;</span></span></code> </pre> </div></div><br><h2 id="fabriki">  </h2><br><p>      .      . </p><br><p>      ,   .         IUdrProcedureFactory, IUdrFunctionFactory  IUdrTriggerFactory     UDR.          UDR   <code>firebird_udr_plugin</code> . </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerFunction(AStatus, 'sum_args', TSumArgsFunctionFactory.Create()); //    AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TGenRowsFactory.Create()); //    AUdrPlugin.registerTrigger(AStatus, 'test_trigger', TMyTriggerFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><p>     <code>TSumArgsFunctionFactory</code>   IUdrFunctionFactory, <code>TGenRowsFactory</code>   IUdrProcedureFactory,  <code>TMyTriggerFactory</code>   IUdrTriggerFactory. </p><br><p>              ,   .         Firebird.  ,   SuperServer             ,  Classic   <br>      . </p><br><p>         setup  newItem   IUdrProcedureFactory, IUdrFunctionFactory  IUdrTriggerFactory. </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="delphi hljs"> <span class="hljs-title"><span class="hljs-title">IUdrFunctionFactory</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(IDisposable) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VERSION = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalFunction; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-title"><span class="hljs-title">IUdrProcedureFactory</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(IDisposable) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VERSION = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; inBuilder: IMetadataBuilder; outBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalProcedure; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-title"><span class="hljs-title">IUdrTriggerFactory</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(IDisposable) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VERSION = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata; fieldsBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status: IStatus; context: IExternalContext; metadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalTrigger; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br><p>  ,      IDisposable,       dispose.    Firebird   ,    .   dispose   ,   ,    .       <br>   <code>IUdrProcedureFactoryImpl</code> , <code>IUdrFunctionFactoryImpl</code> , <code>IUdrTriggerFactoryImpl</code> .      . </p><br><h3 id="metod-newitem">  newItem </h3><br><p>  newItem      ,   .   UDR        , ..    ,   .             . </p><br><p>            . ,      ,    ,    <code>IUdrFunctionFactory</code> .             .      . </p><br><p>   newItem     ,  <br>  UDR   UDR. </p><br><p>        </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSumArgsFunctionFactory</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalFunction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     Result := TSumArgsFunction.Create(); end;</span></span></code> </pre> <br><p>   IRoutineMetadata        ,  UDR   .       UDR.         UDR      . </p><br><pre> <code class="delphi hljs"> <span class="hljs-comment"><span class="hljs-comment">//   TSumArgsFunction. TSumArgsFunction = class(IExternalFunctionImpl) private FMetadata: IRoutineMetadata; public property Metadata: IRoutineMetadata read FMetadata write FMetadata; public ... end;</span></span></code> </pre> <br><h3 id="metod-setup">  setup </h3><br><p>  setup                 .     IMetadataBuilder,          ,    .       <br>    setup,         setup      DLL ,   .         . </p><br><p>                    .        ,          SumArgs. </p><br><p>      ,     </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//        TSumArgsInMsg = record n1: Integer; n1Null: WordBool; n2: Integer; n2Null: WordBool; n3: Integer; n3Null: WordBool; end; PSumArgsInMsg = ^TSumArgsInMsg; //        TSumArgsOutMsg = record result: Integer; resultNull: WordBool; end; PSumArgsOutMsg = ^TSumArgsOutMsg;</span></span></code> </pre> <br><p>    ,   setup    ,     . </p><br><div class="spoiler"> <b class="spoiler_title">SumArgsFunctionFactory</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TSumArgsFunctionFactory }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSumArgsFunctionFactory</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSumArgsFunctionFactory</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalFunction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TSumArgsFunction.Create(); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSumArgsFunctionFactory</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//      AInBuilder.setType(AStatus, 0, Cardinal(SQL_LONG) + 1); AInBuilder.setLength(AStatus, 0, sizeof(Int32)); AInBuilder.setType(AStatus, 1, Cardinal(SQL_LONG) + 1); AInBuilder.setLength(AStatus, 1, sizeof(Int32)); AInBuilder.setType(AStatus, 2, Cardinal(SQL_LONG) + 1); AInBuilder.setLength(AStatus, 2, sizeof(Int32)); //      AOutBuilder.setType(AStatus, 0, Cardinal(SQL_LONG) + 1); AOutBuilder.setLength(AStatus, 0, sizeof(Int32)); end;</span></span></code> </pre> </div></div><br><blockquote> <strong> </strong> <br><br>    SQL  Firebird .   ,     SQL       NULL.          XSQLDA. </blockquote><p>    </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSumArgsFunction</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xInput: PSumArgsInMsg; xOutput: PSumArgsOutMsg; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//         xInput := PSumArgsInMsg(AInMsg); xOutput := PSumArgsOutMsg(AOutMsg); //     = NULL,     nullFlag xOutput^.resultNull := True; //     NULL    NULL //       xOutput^.resultNull := xInput^.n1Null or xInput^.n2Null or xInput^.n3Null; xOutput^.result := xInput^.n1 + xInput^.n2 + xInput^.n3; end;</span></span></code> </pre> <br><p>        ,      ,          ,      setup. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> FN_SUM_ARGS ( N1 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>), N2 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>), N3 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'MyUdrSetup!sum_args'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span> UDR;</code> </pre> <br><p>         </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> FN_SUM_ARGS(<span class="hljs-string"><span class="hljs-string">'15'</span></span>, <span class="hljs-string"><span class="hljs-string">'21'</span></span>, <span class="hljs-string"><span class="hljs-string">'35'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rdb$<span class="hljs-keyword"><span class="hljs-keyword">database</span></span></code> </pre> <br><h2 id="obobschyonnye-fabriki">   </h2><br><p>    UDR     ,          UDR.            .     Delphi 2009,  Free Pascal    FPC 2.2. </p><br><blockquote>  <strong>Remarque</strong> <br><br>  Free Pascal       <br> Delphi.    FPC 2.6.0    Delphi <br> . </blockquote><p>          <br> : </p><br><ul><li><p>   ,          ,         UDR,       ; </p><br></li><li><p>   ,       ,         UDR,        IMessageMetadata. </p><br></li></ul><br><p>            newItem   .          <code>IUdrFunctionFactoryImpl</code> , <code>IUdrProcedureFactoryImpl</code> , <code>IUdrTriggerFactoryImpl</code> .      : </p><br><div class="spoiler"> <b class="spoiler_title">SimpleFactories</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> UdrFactories; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, Firebird; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//     TFunctionSimpleFactory&lt;T: IExternalFunctionImpl, constructor&gt; = class (IUdrFunctionFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; override; end; //     TProcedureSimpleFactory&lt;T: IExternalProcedureImpl, constructor&gt; = class (IUdrProcedureFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; override; end; //     TTriggerSimpleFactory&lt;T: IExternalTriggerImpl, constructor&gt; = class (IUdrTriggerFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalTrigger; override; end;</span></span></code> </pre> </div></div><br><p>      setup   ,     ,    dispose   .     newItem          <code>T</code> . </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-comment"><span class="hljs-comment">{ TProcedureSimpleFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalProcedure; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TFunctionFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalFunction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TTriggerSimpleFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalTrigger; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerSimpleFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br><p>    1       ,   .          : </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerFunction(AStatus, 'sum_args', TFunctionSimpleFactory&lt;TSumArgsFunction&gt;.Create()); //    AUdrPlugin.registerProcedure(AStatus, 'gen_rows', TProcedureSimpleFactory&lt;TGenRowsProcedure&gt;.Create()); //    AUdrPlugin.registerTrigger(AStatus, 'test_trigger', TTriggerSimpleFactory&lt;TMyTrigger&gt;.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><p>    .          ,   .         <code>newItem</code> .  UDR   <code>IRoutineMetadata</code> ,       Firebird,        UDR.           ,    ,  UDR, ,    <br>  UDR.      ,         ,      . </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> UdrFactories; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, Firebird; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//     TExternalFunction = class(IExternalFunctionImpl) Metadata: IRoutineMetadata; end; //     TExternalProcedure = class(IExternalProcedureImpl) Metadata: IRoutineMetadata; end; //     TExternalTrigger = class(IExternalTriggerImpl) Metadata: IRoutineMetadata; end;</span></span></code> </pre> <br><p>       ,           . </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> UdrFactories; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, Firebird; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//     TExternalFunction = class(IExternalFunctionImpl) Metadata: IRoutineMetadata; end; //     TExternalProcedure = class(IExternalProcedureImpl) Metadata: IRoutineMetadata; end; //     TExternalTrigger = class(IExternalTriggerImpl) Metadata: IRoutineMetadata; end;</span></span></code> </pre> <br><p>       ,           . </p><br><p>       UDR   . </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> UdrFactories; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE DELPHI}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, Firebird; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//      TFunctionFactory&lt;T: TExternalFunction, constructor&gt; = class (IUdrFunctionFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; override; end; //      TProcedureFactory&lt;T: TExternalProcedure, constructor&gt; = class (IUdrProcedureFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalProcedure; override; end; //      TTriggerFactory&lt;T: TExternalTrigger, constructor&gt; = class (IUdrTriggerFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalTrigger; override; end;</span></span></code> </pre> </div></div><br><p>   newItem      ,  <br>  ,      . </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> ... <span class="hljs-comment"><span class="hljs-comment">{ TFunctionFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalFunction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; (Result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T).Metadata := AMetadata; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFunctionFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TProcedureFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalProcedure; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; (Result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T).Metadata := AMetadata; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TProcedureFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder, AOutBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TTriggerFactory&lt;T&gt; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata)</span></span></span><span class="hljs-function">:</span></span> IExternalTrigger; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := T.Create; (Result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T).Metadata := AMetadata; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TTriggerFactory</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AFieldsBuilder: IMetadataBuilder)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br><p>          <a href="">https://github.com/sim1984/udr-book/blob/master/examples/Common/UdrFactories.pas</a> . </p><br><h1 id="rabota-s-tipom-blob">    BLOB </h1><br><p>       BLOB    ( BLOB),    .  , BLOB    ,         .         BLOB .      BLOB   <br>  <code>IBlob</code> . </p><br><p>      BLOB  ,  BLOB    ,      BLOB   ,     BLOB     . </p><br><p>     BLOB    ,   BLOB     (),     64 .     <code>getSegment</code>  <code>IBlob</code> .     <code>putSegment</code>  <code>IBlob</code> . </p><br><h2 id="chtenie-dannyh-iz-blob">    BLOB </h2><br><p>     BLOB     <br>    (     <br>  LIST).     </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> ( txt <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span> sub_type <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> utf8, delimiter <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> utf8 = <span class="hljs-string"><span class="hljs-string">','</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'myudr!split'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p>    : </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    AUdrPlugin.registerProcedure(AStatus, 'split', TProcedureSimpleFactory&lt;TSplitProcedure&gt;.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><p>         ,         .      . </p><br><p>     .        . </p><br><pre> <code class="delphi hljs"> TInput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> txt: ISC_QUAD; txtNull: WordBool; delimiter: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AnsiChar; delimiterNull: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TInputPtr = ^TInput; TOutput = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Id: Integer; Null: WordBool; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TOutputPtr = ^TOutput;</code> </pre> <br><p>     BLOB   BLOB,    <code>ISC_QUAD</code> . </p><br><p>        : </p><br><div class="spoiler"> <b class="spoiler_title">   Split    </b> <div class="spoiler_text"><pre> <code class="delphi hljs"> <span class="hljs-title"><span class="hljs-title">TSplitProcedure</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(IExternalProcedureImpl) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveBlobToStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; ABlobId: ISC_QUADPtr; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readBlob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; ABlobId: ISC_QUADPtr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-comment"><span class="hljs-comment">//      procedure dispose(); override; procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; function open(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer): IExternalResultSet; override; end; TSplitResultSet = class(IExternalResultSetImpl) {$IFDEF FPC} OutputArray: TStringArray; {$ELSE} OutputArray: TArray&lt;string&gt;; {$ENDIF} Counter: Integer; Output: TOutputPtr; procedure dispose(); override; function fetch(AStatus: IStatus): Boolean; override; end;</span></span></code> </pre> </div></div><br><p>   <code>SaveBlobToStream</code>  <code>readBlob</code>    BLOB.   BLOB  ,  ‚Äî           Delphi.       OutputArray     Counter. </p><br><p>   open  BLOB    .          <code>Split</code>    .        . </p><br><div class="spoiler"> <b class="spoiler_title">TSplitProcedure.open</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSplitProcedure</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer)</span></span></span><span class="hljs-function">:</span></span> IExternalResultSet; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xInput: TInputPtr; xText: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; xDelimiter: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xInput := AInMsg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> xInput.txtNull <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> xInput.delimiterNull <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; xText := readBlob(AStatus, AContext, @xInput.txt); xDelimiter := TFBCharSet.CS_UTF8.GetString(TBytes(@xInput.delimiter), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        //    //  - /4 SetLength(xDelimiter, 1); Result := TSplitResultSet.Create; with TSplitResultSet(Result) do begin Output := AOutMsg; OutputArray := xText.Split([xDelimiter], TStringSplitOptions.ExcludeEmpty); Counter := 0; end; end;</span></span></code> </pre> </div></div><br><blockquote>  <strong>Remarque</strong> <br><br>   <code>TFBCharSet</code>    Firebird.pas.    <br>      Firebird.     <br>        UTF-8. <br>     <a href="">FbCharsets.pas</a> </blockquote><p>       BLOB  .       BLOB   .      openBlob  <code>IAttachment</code> .    BLOB    ,        .              ,    <br> ( <code>IExternalContext</code> ). </p><br><p> BLOB   (),     64 .     <code>getSegment</code>  <code>IBlob</code> . </p><br><div class="spoiler"> <b class="spoiler_title">TSplitProcedure.SaveBlobToStream</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSplitProcedure</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveBlobToStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; ABlobId: ISC_QUADPtr; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> att: IAttachment; trx: ITransaction; blob: IBlob; buffer: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">32767</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AnsiChar; l: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> att := AContext.getAttachment(AStatus); trx := AContext.getTransaction(AStatus); blob := att.openBlob(AStatus, trx, ABlobId, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> True <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> blob.getSegment(AStatus, SizeOf(buffer), @buffer, @l) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> IStatus.RESULT_OK: AStream.WriteBuffer(buffer, l); IStatus.RESULT_SEGMENT: AStream.WriteBuffer(buffer, l); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; AStream.Position := <span class="hljs-number"><span class="hljs-number">0</span></span>; blob.close(AStatus); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(att) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> att.release; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(trx) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> trx.release; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(blob) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> blob.release; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br><blockquote>  <strong>Remarque</strong> <br><br>  ,  <code>IAttachment</code> , <code>ITransaction</code>  <code>IBlob</code> <br>   <code>IReferenceCounted</code> ,      <br>  .      <br>     1.      <br>         release. </blockquote><p>    <code>SaveBlobToStream</code>    BLOB  <br> : </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSplitProcedure</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readBlob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; ABlobId: ISC_QUADPtr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> xStream: TBytesStream; <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> xStream: TStringStream; <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> xStream := TBytesStream.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> xStream := TStringStream.Create(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">65001</span></span>); <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> SaveBlobToStream(AStatus, AContext, ABlobId, xStream); <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> Result := TEncoding.UTF8.GetString(xStream.Bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, xStream.Size); <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> Result := xStream.DataString; <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> xStream.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><blockquote>  <strong>Remarque</strong> <br><br>   Free Pascal      <br>  Delphi   <code>TStringStream</code> .    FPC   <br>      ,    <br>        . </blockquote><p>  <code>fetch</code>           Counter      ,       .      .           <code>isc_convert_error</code> . </p><br><div class="spoiler"> <b class="spoiler_title"> isc_convert_error</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSplitResultSet</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(OutputArray, <span class="hljs-number"><span class="hljs-number">0</span></span>); Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSplitResultSet</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> statusVector: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> NativeIntPtr; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Counter &lt;= High(OutputArray) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Output.Null := False; <span class="hljs-comment"><span class="hljs-comment">//         isc_random //        Firebird //  isc_convert_error try Output.Id := OutputArray[Counter].ToInteger(); except on e: EConvertError do begin statusVector[0] := NativeIntPtr(isc_arg_gds); statusVector[1] := NativeIntPtr(isc_convert_error); statusVector[2] := NativeIntPtr(isc_arg_string); statusVector[3] := NativeIntPtr(PAnsiChar('Cannot convert string to integer')); statusVector[4] := NativeIntPtr(isc_arg_end); AStatus.setErrors(@statusVector); end; end; inc(Counter); Result := True; end else Result := False; end;</span></span></code> </pre> </div></div><br><blockquote>  <strong>Remarque</strong> <br><br>        <code>isc_random</code>   <br> ,      . </blockquote><p>      : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ids.ID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SPLIT</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIST</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> MYTABLE), <span class="hljs-string"><span class="hljs-string">','</span></span>) ids</code> </pre> <br><blockquote>  <strong>Remarque</strong> <br><br>       ,  BLOB  <br>   ,       <br>    .       <br>   ,      <br>   .       <br>    <code>fetch</code>     . </blockquote><br><h2 id="zapis-dannyh-v-blob">    BLOB </h2><br><p>     BLOB     <br> BLOB  . </p><br><blockquote>  <strong>Remarque</strong> <br><br>      UDF     <br>  BLOB / .  UDF    <br> <a href="">blobsaveload.zip</a> </blockquote><p>      BLOB /      </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> BlobFileUtils <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> SaveBlobToFile(ABlob <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span>, AFileName <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8); FUNCTION LoadBlobFromFile(AFileName VARCHAR(255) CHARACTER <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>^ <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> BlobFileUtils <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> SaveBlobToFile(ABlob <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span>, AFileName <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8) <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'BlobFileUtils!SaveBlobToFile'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span> UDR; FUNCTION LoadBlobFromFile(AFileName VARCHAR(255) CHARACTER <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-string"><span class="hljs-string">'BlobFileUtils!LoadBlobFromFile'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span> UDR; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>^</code> </pre> <br><p>      : </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//  AUdrPlugin.registerProcedure(AStatus, 'SaveBlobToFile', TSaveBlobToFileProcFactory.Create()); AUdrPlugin.registerFunction(AStatus, 'LoadBlobFromFile', TLoadBlobFromFileFuncFactory.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><p>          BLOB  ,   UDR      <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">06.BlobSaveLoad</a> .       LoadBlobFromFile   : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird, Classes, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//    TInput = record filename: record len: Smallint; str: array [0 .. 1019] of AnsiChar; end; filenameNull: WordBool; end; TInputPtr = ^TInput; //    TOutput = record blobData: ISC_QUAD; blobDataNull: WordBool; end; TOutputPtr = ^TOutput; //   LoadBlobFromFile TLoadBlobFromFileFunc = class(IExternalFunctionImpl) public procedure dispose(); override; procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; procedure execute(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer); override; end; //       LoadBlobFromFile TLoadBlobFromFileFuncFactory = class(IUdrFunctionFactoryImpl) procedure dispose(); override; procedure setup(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata; AInBuilder: IMetadataBuilder; AOutBuilder: IMetadataBuilder); override; function newItem(AStatus: IStatus; AContext: IExternalContext; AMetadata: IRoutineMetadata): IExternalFunction; override; end;</span></span></code> </pre> </div></div><br><p>      <code>execute</code>  <code>TLoadBlobFromFile</code> ,    . </p><br><div class="spoiler"> <b class="spoiler_title">  execute</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TLoadBlobFromFileFunc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MaxBufSize = <span class="hljs-number"><span class="hljs-number">16384</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xInput: TInputPtr; xOutput: TOutputPtr; xFileName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; xStream: TFileStream; att: IAttachment; trx: ITransaction; blob: IBlob; buffer: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">32767</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; xStreamSize: Integer; xBufferSize: Integer; xReadLength: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xInput := AInMsg; xOutput := AOutMsg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> xInput.filenameNull <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xOutput.blobDataNull := True; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; xOutput.blobDataNull := False; <span class="hljs-comment"><span class="hljs-comment">//    xFileName := TEncoding.UTF8.GetString(TBytes(@xInput.filename.str), 0, xInput.filename.len * 4); SetLength(xFileName, xInput.filename.len); //     xStream := TFileStream.Create(xFileName, fmOpenRead or fmShareDenyNone); att := AContext.getAttachment(AStatus); trx := AContext.getTransaction(AStatus); blob := nil; try xStreamSize := xStream.Size; //     () if xStreamSize &gt; MaxBufSize then xBufferSize := MaxBufSize else xBufferSize := xStreamSize; //   blob blob := att.createBlob(AStatus, trx, @xOutput.blobData, 0, nil); //        BLOB   while xStreamSize &lt;&gt; 0 do begin if xStreamSize &gt; xBufferSize then xReadLength := xBufferSize else xReadLength := xStreamSize; xStream.ReadBuffer(buffer, xReadLength); blob.putSegment(AStatus, xReadLength, @buffer[0]); Dec(xStreamSize, xReadLength); end; //  BLOB blob.close(AStatus); finally if Assigned(blob) then blob.release; att.release; trx.release; xStream.Free; end; end;</span></span></code> </pre> </div></div><br><p>      BLOB     blobId     <code>createBlob</code>  <code>IAttachment</code> .       BLOB    ,        .              ,    ( <code>IExternalContext</code> ). </p><br><p>           BLOB,        <code>putSegment</code>  <code>IBlob</code>   ,       .             <code>close</code> . </p><br><h2 id="helper-dlya-raboty-s-tipom-blob">      BLOB </h2><br><p>         BLOB  <br> ,     BLOB  .    <br>      BLOB,      <br>       . </p><br><p>   Delphi  Free Pascal    <br>          . <br>     IBlob      <br>  / Blob. </p><br><p>    FbBlob,     . </p><br><div class="spoiler"> <b class="spoiler_title">BlobHelper</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> FbBlob; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Classes, SysUtils, Firebird; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_SEGMENT_SIZE = $<span class="hljs-number"><span class="hljs-number">7</span></span>FFF; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TFbBlobHelper = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">helper</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> IBlob <span class="hljs-comment"><span class="hljs-comment">{   BLOB   @param(AStatus  ) @param(AStream ) }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadFromStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">{     BLOB @param(AStatus  ) @param(AStream ) }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveToStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Math; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFbBlobHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadFromStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xStreamSize: Integer; xReadLength: Integer; xBuffer: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. MAX_SEGMENT_SIZE] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xStreamSize := AStream.Size; AStream.Position := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> xStreamSize &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xReadLength := Min(xStreamSize, MAX_SEGMENT_SIZE); AStream.ReadBuffer(xBuffer, xReadLength); Self.putSegment(AStatus, xReadLength, @xBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Dec(xStreamSize, xReadLength); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFbBlobHelper</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveToStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AStream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xInfo: TFbBlobInfo; Buffer: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. MAX_SEGMENT_SIZE] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Byte; xBytesRead: Cardinal; xBufferSize: Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> AStream.Position := <span class="hljs-number"><span class="hljs-number">0</span></span>; xBufferSize := Min(SizeOf(Buffer), MAX_SEGMENT_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> True <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Self.getSegment(AStatus, xBufferSize, @Buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>], @xBytesRead) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> IStatus.RESULT_OK: AStream.WriteBuffer(Buffer, xBytesRead); IStatus.RESULT_SEGMENT: AStream.WriteBuffer(Buffer, xBytesRead); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> </div></div><br><p>         BLOB,     BLOB      : </p><br><div class="spoiler"> <b class="spoiler_title">TLoadBlobFromFileFunc.execute</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TLoadBlobFromFileFunc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xInput: TInputPtr; xOutput: TOutputPtr; xFileName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; xStream: TFileStream; att: IAttachment; trx: ITransaction; blob: IBlob; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xInput := AInMsg; xOutput := AOutMsg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> xInput.filenameNull <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xOutput.blobDataNull := True; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; xOutput.blobDataNull := False; <span class="hljs-comment"><span class="hljs-comment">//    xFileName := TEncoding.UTF8.GetString(TBytes(@xInput.filename.str), 0, xInput.filename.len * 4); SetLength(xFileName, xInput.filename.len); //     xStream := TFileStream.Create(xFileName, fmOpenRead or fmShareDenyNone); att := AContext.getAttachment(AStatus); trx := AContext.getTransaction(AStatus); blob := nil; try //   blob blob := att.createBlob(AStatus, trx, @xOutput.blobData, 0, nil); //     BLOB blob.LoadFromStream(AStatus, xStream); //  BLOB blob.close(AStatus); finally if Assigned(blob) then blob.release; att.release; trx.release; xStream.Free; end; end;</span></span></code> </pre> </div></div><br><h1 id="kontekst-soedineniya-i-tranzakcii">     </h1><br><p>    ,              ,    ,        / .  ,            BLOB. </p><br><p>    ,          <code>IExternalContext</code>   execute   ,    open .  <code>IExternalContext</code>        <code>getAttachment</code> ,       <code>getTransaction</code> .      UDR,              ,        ,     <code>startTransaction</code>  <code>IExternalContext</code> .              .  ,               , ..     (2PC). </p><br><p>          ,      SELECT    JSON.    : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GetJson ( sql_text <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span> sub_type <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> utf8, sql_dialect <span class="hljs-built_in"><span class="hljs-built_in">smallint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">blob</span></span> sub_type <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> utf8 <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'JsonUtils!getJson'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> udr;</code> </pre> <br><p>      SQL ,        ,         .         <code>IMessageMetadata</code> .      ,          ,    <br>     Firebird. </p><br><blockquote>  <strong>Remarque</strong> <br><br>  JSON        . <br>    CHAR, VARCHAR  OCTETS NONE  BLOB SUB_TYPE BINARY <br>        base64, <br>      JSON. </blockquote><p>    : </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firebird_udr_plugin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AUnloadFlagLocal: BooleanPtr; AUdrPlugin: IUdrPlugin)</span></span></span><span class="hljs-function">:</span></span> BooleanPtr; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//   AUdrPlugin.registerFunction(AStatus, 'getJson', TFunctionSimpleFactory&lt;TJsonFunction&gt;.Create()); theirUnloadFlag := AUnloadFlagLocal; Result := @myUnloadFlag; end;</span></span></code> </pre> <br><p>        ,       : </p><br><div class="spoiler"> <b class="spoiler_title">   GetJson</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> JsonFunc; <span class="hljs-meta"><span class="hljs-meta">{$IFDEF FPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$MODE objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$DEFINE DEBUGFPC}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Firebird, UdrFactories, FbTypes, FbCharsets, SysUtils, System.NetEncoding, System.Json; <span class="hljs-comment"><span class="hljs-comment">// ********************************************************* // create function GetJson ( // sql_text blob sub_type text, // sql_dialect smallint not null default 3 // ) returns blob sub_type text character set utf8 // external name 'JsonUtils!getJson' // engine udr; // ********************************************************* type TInput = record SqlText: ISC_QUAD; SqlNull: WordBool; SqlDialect: Smallint; SqlDialectNull: WordBool; end; InputPtr = ^TInput; TOutput = record Json: ISC_QUAD; NullFlag: WordBool; end; OutputPtr = ^TOutput; //   TSumArgsFunction. TJsonFunction = class(IExternalFunctionImpl) public procedure dispose(); override; procedure getCharSet(AStatus: IStatus; AContext: IExternalContext; AName: PAnsiChar; ANameSize: Cardinal); override; {         @param(AValue ) @param(Scale ) @returns(   ) } function MakeScaleInteger(AValue: Int64; Scale: Smallint): string; {       Json @param(AStatus  ) @param(AContext    ) @param(AJson   Json) @param(ABuffer  ) @param(AMeta  ) @param(AFormatSetting     ) } procedure writeJson(AStatus: IStatus; AContext: IExternalContext; AJson: TJsonArray; ABuffer: PByte; AMeta: IMessageMetadata; AFormatSettings: TFormatSettings); {    @param(AStatus  ) @param(AContext    ) @param(AInMsg    ) @param(AOutMsg    ) } procedure execute(AStatus: IStatus; AContext: IExternalContext; AInMsg: Pointer; AOutMsg: Pointer); override; end;</span></span></code> </pre> </div></div><br><p>   <code>MakeScaleInteger</code>       ,  <code>writeJson</code>        Json        .     ,      <code>execute</code>    . </p><br><div class="spoiler"> <b class="spoiler_title">TJsonFunction.execute</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TJsonFunction</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AInMsg, AOutMsg: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xFormatSettings: TFormatSettings; xInput: InputPtr; xOutput: OutputPtr; att: IAttachment; tra: ITransaction; stmt: IStatement; inBlob, outBlob: IBlob; inStream: TBytesStream; outStream: TStringStream; cursorMetaData: IMessageMetadata; rs: IResultSet; msgLen: Cardinal; msg: Pointer; jsonArray: TJsonArray; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xInput := AInMsg; xOutput := AOutMsg; <span class="hljs-comment"><span class="hljs-comment">//      NULL,    NULL if xInput.SqlNull or xInput.SqlDialectNull then begin xOutput.NullFlag := True; Exit; end; xOutput.NullFlag := False; //      xFormatSettings := TFormatSettings.Create; xFormatSettings.DateSeparator := '-'; xFormatSettings.TimeSeparator := ':'; //      blob inStream := TBytesStream.Create(nil); outStream := TStringStream.Create('', 65001); jsonArray := TJsonArray.Create; //      att := AContext.getAttachment(AStatus); tra := AContext.getTransaction(AStatus); stmt := nil; inBlob := nil; outBlob := nil; try //  BLOB   inBlob := att.openBlob(AStatus, tra, @xInput.SqlText, 0, nil); inBlob.SaveToStream(AStatus, inStream); inBlob.close(AStatus); //   stmt := att.prepare(AStatus, tra, inStream.Size, @inStream.Bytes[0], xInput.SqlDialect, IStatement.PREPARE_PREFETCH_METADATA); //     cursorMetaData := stmt.getOutputMetadata(AStatus); //   rs := stmt.openCursor(AStatus, tra, nil, nil, nil, 0); //     msgLen := cursorMetaData.getMessageLength(AStatus); msg := AllocMem(msgLen); try //     while rs.fetchNext(AStatus, msg) = IStatus.RESULT_OK do begin //     JSON writeJson(AStatus, AContext, jsonArray, msg, cursorMetaData, xFormatSettings); end; finally //   FreeMem(msg); end; //   rs.close(AStatus); //  JSON   outStream.WriteString(jsonArray.ToJSON); //  json   blob outBlob := att.createBlob(AStatus, tra, @xOutput.Json, 0, nil); outBlob.LoadFromStream(AStatus, outStream); outBlob.close(AStatus); finally if Assigned(inBlob) then inBlob.release; if Assigned(stmt) then stmt.release; if Assigned(outBlob) then outBlob.release; tra.release; att.release; jsonArray.Free; inStream.Free; outStream.Free; end; end;</span></span></code> </pre> </div></div><br><p>                <code>getAttachment</code>  <code>getTransaction</code>  <code>IExternalContext</code> .    BLOB    SQL .      prepare  <code>IAttachment</code> .    SQL       .     <code>IStatement.PREPARE_PREFETCH_METADATA</code> ,             .         <code>getOutputMetadata</code>  <code>IStatement</code> . </p><br><blockquote>  <strong>Remarque</strong> <br><br>     getOutputMetadata      . <br>  <code>IStatement.PREPARE_PREFETCH_METADATA</code>     <br>        .     <br>         ,    . </blockquote><p>       openCursor     ( 2).           <code>getMessageLength</code>  <code>IMessageMetadata</code> .      ,         . </p><br><p>       <code>fetchNext</code>  <code>IResultSet</code> .     <code>msg</code>      <code>IStatus.RESULT_OK</code>   ,     .       <code>writeJson</code> ,     <code>TJsonObject</code>       <code>TJsonArray</code> . </p><br><p>     ,    <code>close</code> ,   Json   ,     ,     Blob. </p><br><p>    <code>writeJson</code> .  <code>IUtil</code>    ,        .               <code>IMessageMetadata</code> .      <code>TJsonObject</code>        .          .   NullFlag,    null       ,            Json. </p><br><div class="spoiler"> <b class="spoiler_title"> writeJson</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TJsonFunction</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeScaleInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AValue: Int64; Scale: Smallint)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> L: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := AValue.ToString; L := Result.Length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-Scale &gt;= L) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">'0.'</span></span> + Result.PadLeft(-Scale, <span class="hljs-string"><span class="hljs-string">'0'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Result := Result.Insert(Scale + L, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TJsonFunction</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStatus: IStatus; AContext: IExternalContext; AJson: TJsonArray; ABuffer: PByte; AMeta: IMessageMetadata; AFormatSettings: TFormatSettings)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonObject: TJsonObject; i: Integer; FieldName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; NullFlag: WordBool; pData: PByte; util: IUtil; metaLength: Integer; <span class="hljs-comment"><span class="hljs-comment">//  CharBuffer: array [0 .. 35766] of Byte; charLength: Smallint; charset: TFBCharSet; StringValue: string; SmallintValue: Smallint; IntegerValue: Integer; BigintValue: Int64; Scale: Smallint; SingleValue: Single; DoubleValue: Double; BooleanValue: Boolean; DateValue: ISC_DATE; TimeValue: ISC_TIME; TimestampValue: ISC_TIMESTAMP; DateTimeValue: TDateTime; year, month, day: Cardinal; hours, minutes, seconds, fractions: Cardinal; blobId: ISC_QUADPtr; BlobSubtype: Smallint; blob: IBlob; textStream: TStringStream; binaryStream: TBytesStream; att: IAttachment; tra: ITransaction; begin //  IUtil util := AContext.getMaster().getUtilInterface(); //   TJsonObject    //     jsonObject := TJsonObject.Create; for i := 0 to AMeta.getCount(AStatus) - 1 do begin //      FieldName := AMeta.getAlias(AStatus, i); NullFlag := PWordBool(ABuffer + AMeta.getNullOffset(AStatus, i))^; if NullFlag then begin //  NULL    JSON      jsonObject.AddPair(FieldName, TJsonNull.Create); continue; end; //      pData := ABuffer + AMeta.getOffset(AStatus, i); case TFBType(AMeta.getType(AStatus, i)) of // VARCHAR SQL_VARYING: begin //    VARCHAR metaLength := AMeta.getLength(AStatus, i); charset := TFBCharSet(AMeta.getCharSet(AStatus, i)); //  VARCHAR  2  -  charLength := PSmallint(pData)^; //     base64 if charset = CS_BINARY then StringValue := TNetEncoding.Base64.EncodeBytesToString((pData + 2), charLength) else begin //       3  Move((pData + 2)^, CharBuffer, metaLength - 2); StringValue := charset.GetString(TBytes(@CharBuffer), 0, charLength * charset.GetCharWidth) SetLength(StringValue, charLength); end; jsonObject.AddPair(FieldName, StringValue); end; // CHAR SQL_TEXT: begin //    CHAR metaLength := AMeta.getLength(AStatus, i); charset := TFBCharSet(AMeta.getCharSet(AStatus, i)); //     base64 if charset = CS_BINARY then StringValue := TNetEncoding.Base64.EncodeBytesToString((pData + 2), metaLength) else begin //     Move(pData^, CharBuffer, metaLength); StringValue := charset.GetString(TBytes(@CharBuffer), 0, metaLength); charLength := metaLength div charset.GetCharWidth; SetLength(StringValue, charLength); end; jsonObject.AddPair(FieldName, StringValue); end; // FLOAT SQL_FLOAT: begin SingleValue := PSingle(pData)^; jsonObject.AddPair(FieldName, TJSONNumber.Create(SingleValue)); end; // DOUBLE PRECISION // DECIMAL(p, s),  p = 10..15  1  SQL_DOUBLE, SQL_D_FLOAT: begin DoubleValue := PDouble(pData)^; jsonObject.AddPair(FieldName, TJSONNumber.Create(DoubleValue)); end; // INTEGER // NUMERIC(p, s),  p = 1..4 SQL_SHORT: begin Scale := AMeta.getScale(AStatus, i); SmallintValue := PSmallint(pData)^; if (Scale = 0) then begin jsonObject.AddPair(FieldName, TJSONNumber.Create(SmallintValue)); end else begin StringValue := MakeScaleInteger(SmallintValue, Scale); jsonObject.AddPair(FieldName, TJSONNumber.Create(StringValue)); end; end; // INTEGER // NUMERIC(p, s),  p = 5..9 // DECIMAL(p, s),  p = 1..9 SQL_LONG: begin Scale := AMeta.getScale(AStatus, i); IntegerValue := PInteger(pData)^; if (Scale = 0) then begin jsonObject.AddPair(FieldName, TJSONNumber.Create(IntegerValue)); end else begin StringValue := MakeScaleInteger(IntegerValue, Scale); jsonObject.AddPair(FieldName, TJSONNumber.Create(StringValue)); end; end; // BIGINT // NUMERIC(p, s),  p = 10..18  3  // DECIMAL(p, s),  p = 10..18  3  SQL_INT64: begin Scale := AMeta.getScale(AStatus, i); BigintValue := Pint64(pData)^; if (Scale = 0) then begin jsonObject.AddPair(FieldName, TJSONNumber.Create(BigintValue)); end else begin StringValue := MakeScaleInteger(BigintValue, Scale); jsonObject.AddPair(FieldName, TJSONNumber.Create(StringValue)); end; end; // TIMESTAMP SQL_TIMESTAMP: begin TimestampValue := PISC_TIMESTAMP(pData)^; //    - util.decodeDate(TimestampValue.date, @year, @month, @day); util.decodeTime(TimestampValue.time, @hours, @minutes, @seconds, @fractions); //  -    Delphi DateTimeValue := EncodeDate(year, month, day) + EncodeTime(hours, minutes, seconds, fractions div 10); //  -    StringValue := FormatDateTime('yyyy/mm/dd hh:nn:ss', DateTimeValue, AFormatSettings); jsonObject.AddPair(FieldName, StringValue); end; // DATE SQL_DATE: begin DateValue := PISC_DATE(pData)^; //     util.decodeDate(DateValue, @year, @month, @day); //      Delphi DateTimeValue := EncodeDate(year, month, day); //      StringValue := FormatDateTime('yyyy/mm/dd', DateTimeValue, AFormatSettings); jsonObject.AddPair(FieldName, StringValue); end; // TIME SQL_TIME: begin TimeValue := PISC_TIME(pData)^; //     util.decodeTime(TimeValue, @hours, @minutes, @seconds, @fractions); //      Delphi DateTimeValue := EncodeTime(hours, minutes, seconds, fractions div 10); //      StringValue := FormatDateTime('hh:nn:ss', DateTimeValue, AFormatSettings); jsonObject.AddPair(FieldName, StringValue); end; // BOOLEAN SQL_BOOLEAN: begin BooleanValue := PBoolean(pData)^; jsonObject.AddPair(FieldName, TJsonBool.Create(BooleanValue)); end; // BLOB SQL_BLOB, SQL_QUAD: begin BlobSubtype := AMeta.getSubType(AStatus, i); blobId := ISC_QUADPtr(pData); att := AContext.getAttachment(AStatus); tra := AContext.getTransaction(AStatus); blob := att.openBlob(AStatus, tra, blobId, 0, nil); if BlobSubtype = 1 then begin //  charset := TFBCharSet(AMeta.getCharSet(AStatus, i)); //      textStream := TStringStream.Create('', charset.GetCodePage); try blob.SaveToStream(AStatus, textStream); StringValue := textStream.DataString; finally textStream.Free; blob.release; tra.release; att.release end; end else begin //      binaryStream := TBytesStream.Create; try blob.SaveToStream(AStatus, binaryStream); //    base64 StringValue := TNetEncoding.Base64.EncodeBytesToString (binaryStream.Memory, binaryStream.Size); finally binaryStream.Free; blob.release; tra.release; att.release end; end; jsonObject.AddPair(FieldName, StringValue); end; end; end; //     Json   AJson.AddElement(jsonObject); end;</span></span></code> </pre> </div></div><br><blockquote>  <strong>Remarque</strong> <br><br>   TFbType     <code>Firebird.pas</code> . <br>      ,      <br> <a href="">FbTypes</a>        . <br><br>  TFBCharSet     <code>Firebird.pas</code> . <br>     <br> <a href="">FbCharsets</a>     .  ,     <br>  ,       <br>   ,  ,    , <br>   <code>TEncoding</code>   ,     <br>       Delphi. </blockquote><p>    CHAR  VARCHAR  ,    OCTETS,     base64,          Delphi.  ,    VARCHAR  2      . </p><br><p>  SMALLINT, INTEGER, BIGINT      ,  .      <code>getScale</code>  <code>IMessageMetadata</code> .     0,     ,    <code>MakeScaleInteger</code> . </p><br><p>  DATE, TIME  TIMESTAMP           <code>decodeDate</code>  <code>decodeTime</code>  <code>IUtil</code> .        -   Delphi  <code>TDateTime</code> . </p><br><p>   BLOB    Delphi.  BLOB ,     <code>TBytesStream</code> .        base64.  BLOB ,     <code>TStringStream</code>  ,     .       BLOB <br> . </p><br><p>  C‚Äôest tout.      UDR  Firebird,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455375/">https://habr.com/ru/post/fr455375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455359/index.html">Swift fonctionnel est facile</a></li>
<li><a href="../fr455361/index.html">Nous faisons une extension de navigateur qui v√©rifie les r√©sultats de l'examen</a></li>
<li><a href="../fr455369/index.html">Certification des administrateurs de bases de donn√©es et bien plus encore lors de l'anniversaire DevConfX (21-22 juin √† Moscou)</a></li>
<li><a href="../fr455371/index.html">Source de courant stable de 5 ŒºA √† 20 mA</a></li>
<li><a href="../fr455373/index.html">Comment ajuster la loi du printemps pour qu'elle devienne porteuse pour les petits prestataires? L'annuler</a></li>
<li><a href="../fr455377/index.html">Architecture IoT</a></li>
<li><a href="../fr455379/index.html">(Statique) S√©lection de conteneurs optimaux dans les programmes C ++</a></li>
<li><a href="../fr455381/index.html">Le support technique de 3CX r√©pond: capturez le trafic SIP sur le serveur PBX</a></li>
<li><a href="../fr455387/index.html">Comprendre l'apprentissage automatique dans Elastic Stack (aka Elasticsearch, aka ELK)</a></li>
<li><a href="../fr455389/index.html">Haxe 4: Quoi de neuf?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>