<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„Ä∞Ô∏è ü§¶üèø ü§≥üèª RESTinio est un serveur HTTP asynchrone. Un exemple simple de la pratique: renvoyer une grande quantit√© de donn√©es en r√©ponse ‚òÉÔ∏è üñ≤Ô∏è üë©üèΩ‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R√©cemment, il m'est arriv√© de travailler sur une application qui √©tait cens√©e contr√¥ler la vitesse de ses connexions sortantes. Par exemple, en se con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio est un serveur HTTP asynchrone. Un exemple simple de la pratique: renvoyer une grande quantit√© de donn√©es en r√©ponse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462349/"><p><img src="https://habrastorage.org/webt/a6/kc/zt/a6kcztqtbqzp5shvd5wcz-8zzl0.jpeg"></p><br><p>  R√©cemment, il m'est arriv√© de travailler sur une application qui √©tait cens√©e contr√¥ler la vitesse de ses connexions sortantes.  Par exemple, en se connectant √† une URL, l'application doit se limiter √†, disons, 200 Ko / s.  Et la connexion √† une autre URL - seulement 30 Ko / sec. </p><br><p>  Le point le plus int√©ressant ici √©tait de tester ces limites.  J'avais besoin d'un serveur HTTP qui donnerait du trafic √† une vitesse donn√©e, par exemple, 512 Ko / s.  Ensuite, je pouvais voir si l'application r√©siste vraiment √† la vitesse de 200 Ko / s ou si elle tombe √† des vitesses plus √©lev√©es. </p><br><p>  Mais o√π trouver un tel serveur HTTP? </p><br><p>  Puisque j'ai quelque chose √† voir avec le serveur HTTP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RESTinio</a> int√©gr√© aux applications C ++, je n'ai rien trouv√© de mieux que de lancer rapidement un simple serveur de test HTTP sur mon genou qui peut envoyer un long flux de donn√©es sortantes au client. </p><br><p>  √Ä quel point ce serait simple et je voudrais le dire dans l'article.  En m√™me temps, d√©couvrez dans les commentaires si c'est vraiment simple ou si je me trompe.  En principe, cet article peut √™tre consid√©r√© comme une continuation de l'article pr√©c√©dent sur RESTinio appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"RESTinio est un serveur HTTP asynchrone. Asynchrone"</a> .  Par cons√©quent, si quelqu'un est int√©ress√© √† lire sur l'application r√©elle, quoique pas tr√®s s√©rieuse, de RESTinio, alors vous √™tes le bienvenu au chat. </p><a name="habracut"></a><br><h1 id="obschaya-ideya">  Id√©e g√©n√©rale </h1><br><p>  L'id√©e g√©n√©rale du serveur de test mentionn√© ci-dessus est tr√®s simple: lorsqu'un client se connecte au serveur et effectue une requ√™te HTTP GET, un temporisateur est activ√© qui s'ex√©cute une fois par seconde.  Lorsque le temporisateur est d√©clench√©, le bloc de donn√©es suivant d'une taille donn√©e est envoy√© au client. </p><br><h2 id="no-vse-neskolko-slozhnee">  Mais tout est un peu plus compliqu√© </h2><br><p>  Si le client lit les donn√©es √† un rythme plus lent que celui envoy√© par le serveur, l'envoi de N kilo-octets par seconde n'est pas une bonne id√©e.  Puisque les donn√©es vont commencer √† s'accumuler dans le socket et cela ne m√®nera √† rien de bon. </p><br><p>  Par cons√©quent, lors de l'envoi de donn√©es, il est conseill√© de contr√¥ler l'√©tat de pr√©paration du socket pour l'√©criture c√¥t√© serveur HTTP.  Tant que le socket est pr√™t (c'est-√†-dire que trop de donn√©es ne s'y sont pas encore accumul√©es), vous pouvez envoyer une nouvelle portion.  Mais s'il n'est pas pr√™t, vous devez attendre jusqu'√† ce que la prise passe en √©tat de pr√©paration pour l'enregistrement. </p><br><p>  Cela semble raisonnable, mais les op√©rations d'E / S sont cach√©es dans les abats de RESTinio ... Comment puis-je savoir si la prochaine donn√©e peut √™tre √©crite ou non? </p><br><p>  Vous pouvez sortir de cette situation si vous utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des notificateurs apr√®s √©criture</a> , qui sont dans RESTinio.  Par exemple, nous pouvons √©crire ceci: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ req-&gt;create_response() <span class="hljs-comment"><span class="hljs-comment">//   . ... //   . .done([](const auto &amp; ec) { ... //         . }); }</span></span></code> </pre> <br><p>  Le lambda transmis √† la m√©thode <code>done()</code> sera appel√© lorsque RESTinio aura termin√© d'√©crire les donn√©es sortantes.  Par cons√©quent, si le socket n'√©tait pas pr√™t pour l'enregistrement pendant un certain temps, le lambda ne sera pas appel√© imm√©diatement, mais une fois que le socket aura atteint son √©tat correct et acceptera toutes les donn√©es sortantes. </p><br><p>  En raison de l'utilisation de notificateurs apr√®s √©criture, la logique du serveur de test sera la suivante: </p><br><ul><li>  envoyer le prochain lot de donn√©es, calculer le moment o√π nous aurions besoin d'envoyer le prochain lot dans le cours normal des √©v√©nements; </li><li>  nous accrochons apr√®s √©criture le notifiant sur la partie suivante des donn√©es; </li><li>  lorsque la notification apr√®s √©criture est appel√©e, nous v√©rifions si le prochain lot est arriv√©.  Si c'est le cas, lancez imm√©diatement l'envoi de la portion suivante.  Si ce n'est pas le cas, armer la minuterie. </li></ul><br><p>  En cons√©quence, il s'av√®re que d√®s que l'enregistrement commence √† ralentir, l'envoi de nouvelles donn√©es se met en pause.  Et reprenez lorsque le socket est pr√™t √† accepter de nouvelles donn√©es sortantes. </p><br><h2 id="i-esche-nemnogo-slozhnogo-chunked_output">  Et un peu plus compliqu√©: chunked_output </h2><br><p>  RESTinio prend en charge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trois fa√ßons de g√©n√©rer une r√©ponse √† une demande HTTP</a> .  La m√©thode la plus simple, utilis√©e par d√©faut, ne convient pas dans ce cas, car  J'ai besoin d'un flux presque infini de donn√©es sortantes.  Et un tel flux, bien s√ªr, ne peut pas √™tre <code>set_body</code> √† un seul appel √† la m√©thode <code>set_body</code> . </p><br><p>  Par cons√©quent, le serveur de test d√©crit utilise ce que l'on appelle  <em>chunked_output</em> .  C'est-√†-dire  lors de la cr√©ation d'une r√©ponse, j'indique √† RESTinio que la r√©ponse sera form√©e en plusieurs parties.  Ensuite, j'appelle p√©riodiquement les m√©thodes <code>append_chunk</code> pour ajouter la partie suivante √† la r√©ponse et <code>flush</code> pour √©crire les parties accumul√©es dans le socket. </p><br><h1 id="a-davayte-uzhe-posmotrim-v-kod">  Et regardons le code! </h1><br><p>  Il suffit peut-√™tre que les premiers mots soient suffisants et il est temps de passer au code lui-m√™me, qui se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans ce r√©f√©rentiel</a> .  Commen√ßons par la fonction <code>request_processor</code> , qui est appel√©e pour traiter chaque requ√™te HTTP valide.  En m√™me temps, explorons les fonctions appel√©es depuis <code>request_processor</code> .  Eh bien, nous verrons ensuite comment exactement <code>request_processor</code> est mapp√© sur l'une ou l'autre des requ√™tes HTTP entrantes. </p><br><h2 id="funkciya-request_processor-i-eyo-podruchnye">  Fonction Request_processor et ses assistants </h2><br><p>  La fonction <code>request_processor</code> est appel√©e pour traiter les requ√™tes HTTP GET dont j'ai besoin.  Il est pass√© en arguments: </p><br><ul><li>  Asio-shny io_context sur lequel tout le travail est effectu√© (il sera n√©cessaire, par exemple, pour armer les minuteries); </li><li>  la taille d'une partie de la r√©ponse.  C'est-√†-dire  si j'ai besoin de donner un flux sortant √† un d√©bit de 512 Ko / s, la valeur 512 Ko sera transmise comme param√®tre; </li><li>  nombre de pi√®ces en r√©ponse.  Dans le cas o√π le flux devrait avoir une longueur limit√©e.  Par exemple, si vous souhaitez donner un flux √† un d√©bit de 512 Ko / s pendant 5 minutes, la valeur 300 sera transmise comme param√®tre (60 blocs par minute pendant 5 minutes); </li><li>  Eh bien, la demande entrante elle-m√™me pour le traitement. </li></ul><br><p>  Dans <code>request_processor</code> , un objet est cr√©√© avec des informations sur la requ√™te et ses param√®tres de traitement, apr√®s quoi ce traitement commence: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( asio_ns::io_context &amp; ctx, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunk_size, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;response_data&gt;( ctx, chunk_size, req-&gt;create_response&lt;<span class="hljs-keyword"><span class="hljs-keyword">output_t</span></span>&gt;(), count); data-&gt;response_ .append_header(restinio::http_field::server, <span class="hljs-string"><span class="hljs-string">"RESTinio"</span></span>) .append_header_date_field() .append_header( restinio::http_field::content_type, <span class="hljs-string"><span class="hljs-string">"text/plain; charset=utf-8"</span></span>) .flush(); send_next_portion(data); }</code> </pre> <br><p>  Le type <code>response_data</code> , contenant tous les param√®tres li√©s √† la demande, ressemble √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">response_data</span></span></span><span class="hljs-class"> {</span></span> asio_ns::io_context &amp; io_ctx_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size_; <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter_; response_data( asio_ns::io_context &amp; io_ctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size, <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter) : io_ctx_{io_ctx} , chunk_size_{chunk_size} , response_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response)} , counter_{counter} {} };</code> </pre> <br><p>  Ici, il convient de noter que l'une des raisons de l'apparition de la structure <code>response_data</code> est qu'un objet de type <code>restinio::response_builder_t&lt;restinio::chunked_output_t&gt;</code> (√† savoir, ce type est masqu√© derri√®re l'alias court <code>response_t</code> ) est un type mobile, mais pas un type copiable (par analogies avec <code>std::unique_ptr</code> ).  Par cons√©quent, cet objet ne peut pas simplement √™tre captur√© dans une fonction lambda, qui s'enveloppe ensuite dans <code>std::function</code> .  Mais si vous placez l'objet de r√©ponse dans une instance cr√©√©e dynamiquement de <code>response_data</code> , un pointeur intelligent vers l'instance <code>reponse_data</code> d√©j√† √™tre captur√© dans les fonctions lambda sans probl√®me, puis enregistrez ce lambda dans <code>std::function</code> . </p><br><h3 id="funkciya-send_next_portion">  Fonction Send_next_portion </h3><br><p>  La fonction <code>send_next_portion</code> appel√©e √† chaque fois qu'il est n√©cessaire d'envoyer la partie suivante de la r√©ponse au client.  Il ne se passe rien de compliqu√©, donc √ßa a l'air assez simple et concis: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_next_portion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;response_.append_chunk(make_buffer(data-&gt;chunk_size_)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">1u</span></span> == data-&gt;counter_) { data-&gt;response_.flush(); data-&gt;response_.done(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { data-&gt;counter_ -= <span class="hljs-number"><span class="hljs-number">1u</span></span>; data-&gt;response_.flush(make_done_handler(data)); } }</code> </pre> <br><p>  C'est-√†-dire  envoyer la partie suivante.  Et, si cette partie √©tait la derni√®re, nous terminons le traitement de la demande.  Et si ce n'est pas le dernier, un <code>flush</code> est envoy√© √† la m√©thode <code>flush</code> , qui est peut-√™tre cr√©√©e par la fonction la plus complexe de cet exemple. </p><br><h3 id="funkciya-make_done_handler">  Fonction make_done_handler </h3><br><p>  La fonction <code>make_done_handler</code> responsable de la cr√©ation d'un lambda qui sera transmis √† RESTinio en tant que notificateur apr√®s √©criture.  Ce notifiant doit v√©rifier si l'enregistrement de la partie suivante de la r√©ponse s'est termin√© avec succ√®s.  Si oui, vous devez d√©terminer si la pi√®ce suivante doit √™tre envoy√©e imm√©diatement (c'est-√†-dire qu'il y avait des "freins" dans la prise et le taux d'envoi ne peut pas √™tre maintenu), ou apr√®s une pause.  Si vous avez besoin d'une pause, elle est fournie via une minuterie d'armement. </p><br><p>  En g√©n√©ral, des actions simples, mais dans le code, vous obtenez lambda √† l'int√©rieur de lambda, ce qui peut d√©router les gens qui ne sont pas habitu√©s au C ++ "moderne".  Ce qui n'est pas si peu d'ann√©es pour √™tre qualifi√© de moderne;) </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> next_timepoint = steady_clock::now() + <span class="hljs-number"><span class="hljs-number">1</span></span>s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> now = steady_clock::now(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(now &lt; next_timepoint) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;asio_ns::steady_timer&gt;(data-&gt;io_ctx_); timer-&gt;expires_after(next_timepoint - now); timer-&gt;async_wait([timer, data](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) send_next_portion(data); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> data-&gt;io_ctx_.post([data] { send_next_portion(data); }); } }; }</code> </pre> <br><p>  √Ä mon avis, la principale difficult√© de ce code provient des particularit√©s de la cr√©ation et du peloton de minuteries dans Asio.  √Ä mon avis, cela se r√©v√®le en quelque sorte trop verbeux.  Mais il y en a vraiment un.  Mais vous n'avez pas besoin d'attirer de biblioth√®ques suppl√©mentaires. </p><br><h2 id="podklyuchenie-express-like-routera">  Connexion d'un routeur de type express </h2><br><p>  Le <code>send_next_portion</code> , <code>send_next_portion</code> et <code>make_done_handler</code> montr√© ci-dessus ont <code>send_next_portion</code> fait constitu√© la toute premi√®re version de mon serveur de test, √©crite litt√©ralement en 15 ou 20 minutes. </p><br><p>  Mais apr√®s quelques jours d'utilisation de ce serveur de test, il s'est av√©r√© qu'il y avait un s√©rieux inconv√©nient: il renvoyait toujours le flux de r√©ponse √† la m√™me vitesse.  Compil√© √† une vitesse de 512 Ko / sec - donne tous les 512 Ko / sec.  Recompil√© √† une vitesse de 20 Ko / sec - donnera √† tout le monde 20 Ko / sec et rien d'autre.  Ce qui √©tait g√™nant, car  il devenait n√©cessaire de pouvoir recevoir des r√©ponses de diff√©rentes "√©paisseurs". </p><br><p>  Puis l'id√©e est venue: que se passe-t-il si la vitesse de retour est demand√©e directement dans l'URL?  Par exemple, ils ont fait une demande √† l' <code>localhost:8080/</code> et ont re√ßu une r√©ponse √† une vitesse pr√©d√©termin√©e.  Et si vous avez fait une demande √† <code>localhost:8080/128K</code> , alors ils ont commenc√© √† recevoir une r√©ponse √† une vitesse de 128KiB / sec. </p><br><p>  Ensuite, la pens√©e est all√©e encore plus loin: dans l'URL, vous pouvez √©galement sp√©cifier le nombre de parties individuelles dans la r√©ponse.  C'est-√†-dire  demande <code>localhost:8080/128K/3000</code> produira un flux de 3000 pi√®ces √† une vitesse de 128KiB / sec. </p><br><p>  Pas de probl√®me.  RESTinio a la possibilit√© d'utiliser un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">routeur de requ√™tes r√©alis√© sous l'influence d'ExpressJS</a> .  En cons√©quence, il y avait une telle fonction pour d√©crire les gestionnaires pour les requ√™tes HTTP entrantes: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_router</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(asio_ns::io_context &amp; ctx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>&gt;(); router-&gt;http_get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) { request_processor(ctx, <span class="hljs-number"><span class="hljs-number">100u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size) { request_processor(ctx, chunk_size, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?)/:count(\d+))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"count"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size &amp;&amp; <span class="hljs-number"><span class="hljs-number">0u</span></span> != count) { request_processor(ctx, chunk_size, count, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br><p>  Ici, les gestionnaires de requ√™tes HTTP GET sont form√©s pour trois types d'URL: </p><br><ul><li>  de la forme <code>http://localhost/</code> ; </li><li>  de la forme <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/</code> ; </li><li>  du formulaire <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/&lt;count&gt;/</code> </li></ul><br><p>  O√π la <code>speed</code> est un nombre qui d√©finit la vitesse et <code>U</code> est un multiplicateur facultatif qui indique dans quelles unit√©s la vitesse est d√©finie.  Ainsi, <code>128</code> ou <code>128b</code> signifie une vitesse de 128 octets par seconde.  Et <code>128k</code> est de 128 kilo-octets par seconde. </p><br><p>  Chaque URL a sa propre fonction lambda, qui comprend les param√®tres re√ßus, si tout va bien, elle appelle la fonction <code>request_processor</code> montr√©e ci-dessus. </p><br><p>  La fonction d'assistance <code>extract_chunk_size</code> la suivante: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> extract_chunk_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">route_params_t</span></span> &amp; params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> multiplier = [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sv) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sv.empty() || <span class="hljs-string"><span class="hljs-string">"B"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"b"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-string"><span class="hljs-string">"K"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"k"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"value"</span></span>]) * multiplier(params[<span class="hljs-string"><span class="hljs-string">"multiplier"</span></span>]); }</code> </pre> <br><p>  Ici, C ++ lambda est utilis√© pour √©muler des fonctions locales √† partir d'autres langages de programmation. </p><br><h2 id="funkciya-main">  Fonction principale </h2><br><p>  Reste √† voir comment tout cela fonctionne dans la fonction principale: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span> = restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">express_router_t</span></span>&lt;&gt;; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_single_thread_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">single_threaded_ostream_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>; }; asio_ns::io_context io_ctx; restinio::run( io_ctx, restinio::on_this_thread&lt;<span class="hljs-keyword"><span class="hljs-keyword">traits_t</span></span>&gt;() .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .write_http_response_timelimit(<span class="hljs-number"><span class="hljs-number">60</span></span>s) .request_handler(make_router(io_ctx))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Que se passe-t-il ici: </p><br><ol><li>  Comme je n'ai pas besoin d'un routeur de requ√™tes ordinaire ordinaire (qui ne peut rien faire du tout et met tout le travail sur les √©paules du programmeur), je d√©finis de nouvelles propri√©t√©s pour mon serveur HTTP.  Pour ce faire, je prends les propri√©t√©s standard d'un serveur HTTP <code>restinio::default_single_thread_traits_t</code> (type <code>restinio::default_single_thread_traits_t</code> ) et indique qu'une instance de routeur de type express sera utilis√©e comme gestionnaire de requ√™tes.  En m√™me temps, pour contr√¥ler ce qui se passe √† l'int√©rieur, j'indique que le serveur HTTP utilise un vrai logger (par d√©faut, <code>null_logger_t</code> utilis√© qui n'enregistre rien du tout). </li><li>  √âtant donn√© que je dois armer les minuteries √† l'int√©rieur des notificateurs apr√®s √©criture, j'ai besoin d'une instance io_context avec laquelle je pourrais travailler.  Par cons√©quent, je le cr√©e moi-m√™me.  Cela me donne l'opportunit√© de passer un lien vers mon io_context dans la fonction <code>make_router</code> . </li><li>  Il ne reste plus qu'√† d√©marrer le serveur HTTP dans une version monothread sur le io_context que j'ai cr√©√© pr√©c√©demment.  La fonction <code>restinio::run</code> ne retournera le contr√¥le que lorsque le serveur HTTP aura termin√© son travail. </li></ol><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  L'article n'a pas montr√© le code complet de mon serveur de test, seulement ses principaux points.  Le code complet, qui est l√©g√®rement plus grand en raison de typedefs suppl√©mentaires et de fonctions auxiliaires, est un peu plus authentique.  Vous pouvez le voir <a href="">ici</a> .  Au moment de la r√©daction du pr√©sent document, il s'agit de 185 lignes, y compris les lignes vides et les commentaires.  Eh bien, ces 185 lignes sont √©crites en quelques approches avec une dur√©e totale d'√† peine plus d'une heure. </p><br><p>  J'ai aim√© ce r√©sultat et la t√¢che √©tait int√©ressante.  Concr√®tement, l'outil auxiliaire dont j'avais besoin a √©t√© rapidement obtenu.  Et en ce qui concerne le d√©veloppement ult√©rieur de RESTinio, certaines r√©flexions sont apparues. </p><br><p>  En g√©n√©ral, si quelqu'un d'autre n'a pas essay√© RESTinio, je vous invite √† essayer.  Le projet lui-m√™me vit sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  Vous pouvez poser une question ou exprimer vos suggestions dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">groupe Google</a> ou ici dans les commentaires. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462349/">https://habr.com/ru/post/fr462349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462333/index.html">Cr√©ation d'un chatbot de conversation simple en python</a></li>
<li><a href="../fr462335/index.html">Ne pas lire, relire</a></li>
<li><a href="../fr462337/index.html">Statistiques du site et votre petit r√©f√©rentiel</a></li>
<li><a href="../fr462339/index.html">Comment la formation manuelle est-elle li√©e aux normes internes d'Amazon et comment a-t-elle affect√© la vision du monde de l'entreprise?</a></li>
<li><a href="../fr462347/index.html">Les dix premiers jours sur le chemin d'un hibou √† un l√®ve-t√¥t: sommeil, alimentation, r√©gime et exercice</a></li>
<li><a href="../fr462353/index.html">FAQ sur la s√©curit√© du protocole LoRaWAN</a></li>
<li><a href="../fr462355/index.html">Programmation JavaScript asynchrone (rappel, promesse, RxJs)</a></li>
<li><a href="../fr462357/index.html">Premier prototype: Unikernels comme √©tape de l'√©volution de Linux</a></li>
<li><a href="../fr462359/index.html">Dat - de quel protocole s'agit-il et qui l'utilise</a></li>
<li><a href="../fr462365/index.html">Limitations de l'apprentissage automatique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>