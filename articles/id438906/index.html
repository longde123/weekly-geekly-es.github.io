<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏾 🤟🏿 🌗 Memahami protokol paging POCSAG 👍🏼 📔 🛒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dahulu kala, ketika ponsel berharga sekitar $ 2.000 dan satu menit panggilan suara adalah 50 sen, pager benar-benar populer. Kemudian telepon seluler ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memahami protokol paging POCSAG</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438906/">  Dahulu kala, ketika ponsel berharga sekitar $ 2.000 dan satu menit panggilan suara adalah 50 sen, pager benar-benar populer.  Kemudian telepon seluler menjadi lebih murah, panggilan dan harga SMS menjadi lebih rendah, dan akhirnya pager kebanyakan menghilang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/7j/xw/8t7jxwauxqbonmzwmweakgmwpvw.jpeg"></div><br>  Bagi orang-orang, yang memiliki pager sebelumnya, dan ingin tahu cara kerjanya, artikel ini akan bermanfaat. <br><a name="habracut"></a><br><h2>  Info utama </h2><br>  Bagi orang-orang yang lupa prinsip-prinsip atau lahir setelah 2000x, saya akan segera mengingatkan ide-ide utama. <br><br>  Jaringan komunikasi paging memiliki beberapa keunggulan, yang terkadang penting bahkan sekarang: <br><br>  - Ini adalah komunikasi satu arah, tanpa konfirmasi apa pun, sehingga jaringan tidak dapat kelebihan beban - itu tidak tergantung dari sejumlah pengguna.  Pesan mentransmisikan terus menerus "sebagaimana adanya", satu demi satu, dan pager mendapatkan pesan jika nomornya (disebut Capcode) sama dengan nomor internal perangkat. <br><br>  - Penerima ini sangat ringan (baik secara harfiah dan elektronik), dan dapat bekerja hingga satu bulan dari 2 baterai AA. <br><br>  Ada dua standar dasar pengiriman pesan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">POCSAG</a> (Grup Penasihat Standardisasi Kode Kantor Pos) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FLEX</a> .  Kedua standar ini cukup tua, POCSAG dibuat pada tahun 1982, dapat mendukung kecepatan 512, 1200 dan 2400 bit / s.  Untuk mentransmisikan metode FSK (pengalihan frekuensi) digunakan dengan pemisahan frekuensi 4,5 KHz.  FLEX sedikit lebih baru (dibuat oleh Motorola di ke-90), dapat bekerja dengan kecepatan hingga 6400 bit / s dan dapat menggunakan FSK2 dan FSK4. <br><br>  Kedua protokol secara umum sangat mudah, dan sekitar 20 tahun yang lalu PC-decoder dibuat, yang dapat men-decode pesan dari port serial kartu suara (tidak ada enkripsi yang didukung, sehingga semua pesan dapat dibaca oleh siapa saja). <br><br>  Mari kita lihat, cara kerjanya. <br><br><h2>  Menerima sinyal </h2><br>  Pertama, kita membutuhkan sinyal untuk decoding.  Ayo ambil laptop, penerima rtl-sdr, dan dapatkan. <br><br><img src="https://habrastorage.org/webt/vj/ba/2g/vjba2gslgleejthwn_m8ccsvf00.jpeg"><br><br>  Keying shift frekuensi digunakan, jadi kami akan mengatur FM.  Dengan HDSDR kami akan menyimpan sinyal dalam format WAV. <br><br>  Mari kita periksa, apa yang kita dapatkan.  Memuat file wav sebagai array data Python: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"pocsag.wav"</span></span>) plt.plot(data) plt.show()</code> </pre> <br>  Output (bit ditambahkan secara manual): <br><br><img src="https://habrastorage.org/webt/pm/ss/y7/pmssy79glsbnfsgxogjd93ylqre.jpeg"><br><br>  Seperti yang dapat kita lihat, mudah, dan bahkan "dengan mata telanjang" kita dapat menggambar bit dalam Paint, mudah untuk membedakan mana "0" dan di mana "1".  Tetapi akan terlalu lama untuk melakukannya secara manual, saatnya untuk mengotomatiskan proses. <br><br>  Setelah memperbesar grafik, kita dapat melihat bahwa setiap bit memiliki lebar 20 sampel.  Kami memiliki 24000 sampel per file bitrate wav kedua, sehingga kecepatan penguncian adalah 1200bit / s.  Mari kita temukan posisi penyilangan nol - ini adalah awal dari urutan bit.  Mari kita juga menambahkan spidol untuk memverifikasi bahwa semua bit ada di tempat yang tepat. <br><br><pre> <code class="python hljs">speed = <span class="hljs-number"><span class="hljs-number">1200</span></span> fs = <span class="hljs-number"><span class="hljs-number">24000</span></span> cnt = int(fs/speed) start = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>*cnt): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[p] &lt; - <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[p+<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>: start = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment"># Bits frame bits = np.zeros(data.size) for p in range(0, data.size - cnt, cnt): bits[start + p] = 500 plt.plot(bits)</span></span></code> </pre><br>  Seperti yang dapat kita lihat, ini tidak sepenuhnya cocok (pemancar dan penerima memiliki frekuensi yang sedikit berbeda), tetapi cukup untuk decoding. <br><br><img src="https://habrastorage.org/webt/hc/s1/lf/hcs1lfxgchl-ngpkyeemhhsgrly.jpeg"><br><br>  Untuk sinyal yang panjang kita mungkin perlu algoritma koreksi frekuensi otomatis, tetapi untuk sinyal semacam ini tidak kritis. <br><br>  Langkah terakhir - kita perlu menerjemahkan file wav ke urutan bit.  Ini juga mudah, kita tahu panjang setiap bit, jika jumlah data positif, kita akan menambahkan "1", jika tidak "0" (akhirnya ditemukan bahwa sinyal perlu dikembalikan, sehingga 0 dan 1 diganti) . <br><br><pre> <code class="python hljs">bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, data.size - cnt, cnt): s = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(p, p+cnt): s += data[p] bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> print(<span class="hljs-string"><span class="hljs-string">"Bits"</span></span>) print(bits_str)</code> </pre><br>  Output - urutan bit yang tepat (dalam format string), yang berisi pesan kami. <br><br> <code>101010101010101010101010101010101010101010101010101010101010101010101010101 <br> 010101010101010101010101010101010101010101010100111110011010010000101001101 <br> 100001111010100010011100000110010111011110101000100111000001100101110111101 <br> 010001001110000011001011101111010100010011100000110010111011110101000100111 <br> 000001100101110111101010001001110000011001011101111010100010011100000110010 <br> 011011110101000100111000001100101110111101010001001110000011001011101111010 <br> 100010011100000110010111011110101000100111000001100101110111101010001001110 <br> ... <br> 111101111</code> <br> <br><h2>  Mengurai kode hanya-angka </h2><br>  Urutan bit jauh lebih nyaman daripada file-wav, kita dapat mengekstrak data darinya.  Pertama, mari kita pisahkan data menjadi blok 4 byte. <br><br> <code>10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> <br> 01111100110100100001010011011000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00001000011011110100010001101000 <br> 10000011010000010101010011010100 <br> <br> 01111100110100100001010111011000 <br> 11110101010001000001000000111000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00100101101001011010010100101111</code> <br> <br>  Kita pasti bisa melihat polanya.  Sekarang kita perlu menemukan, apa arti setiap bagian.  Manual POCSAG tersedia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam format PDF</a> , mari kita periksa deskripsi struktur data. <br><br><img src="https://habrastorage.org/webt/3k/yt/dc/3kytdccgmehfmqstxxli1nt3fpa.png"><br><br>  Sekarang jauh lebih jelas.  Header berisi blok panjang "10101010101", digunakan untuk "membangunkan" pager dari mode sleep.  Pesan itu sendiri berisi blok Batch-1 ... Batch-N, setiap blok dimulai dari urutan unik FSC.  Kemudian, seperti yang dapat kita lihat di manual, jika string dimulai dari "0", itu berisi alamat penerima.  Alamat itu sendiri (capcode) disimpan adalah pager, dan jika tidak cocok, pager akan mengabaikan pesan.  Jika sebuah string dimulai dari "1", itu berisi isi pesan.  Dalam contoh kita, kita memiliki 2 string tipe ini. <br><br>  Mari kita tidak memeriksa setiap blok.  Kita juga dapat melihat kode siaga - blok kosong 01111 ... 0111, mereka tidak memiliki informasi berguna.  Setelah menghapusnya, kami hanya mendapatkan ini: <br><br> <code>01111100110100100001010011011000 - Frame Sync <br> 00001000011011110100010001101000 - Address <br> 10000011010000010101010011010100 - Message <br> <br> 01111100110100100001010111011000 - Frame Sync <br> 11110101010001000001000000111000 - Message <br> 00100101101001011010010100101111 - Address</code> <br> <br>  Kita perlu menemukan, ada apa di dalam. <br><br>  Setelah memeriksa manual, jelas bahwa ada dua jenis pesan - <b>hanya numerik</b> dan <b>alfa-numerik</b> .  Pesan numerik saja disimpan sebagai kode BCD 4bit, sehingga 20 bit dapat berisi 5 simbol (ada juga bit CRC, kami tidak menggunakannya untuk saat ini).  Jika pesan tersebut alfanumerik, digunakan pengkodean ASCII 7-bit.  Pesan ini terlalu pendek sehingga hanya berupa pesan numerik saja. <br><br>  Dari string 10000011010000010101010011010100 dan 11110101010001000001000000111000 kita bisa mendapatkan urutan 4-bit ini: <br>  <i>1 0000 0110 1000 0010 10101 0011010100</i> - 0h <i>6j 8j</i> 2j Ah <br>  <i>1 1110 1010 1000 1000 00100 0000111000</i> - Eh Ah <i>8j 8j</i> 2j <br><br>  Langkah selanjutnya, adalah untuk mendapatkan tabel decoding dari manual: <br><br><img src="https://habrastorage.org/webt/vb/sj/zl/vbsjzluxbhaeuy_zrefccmqhogw.jpeg"><br><br>  Jelas bahwa pesan numerik saja dapat berisi digit 0-9, huruf U ("ugrent"), spasi, dan dua tanda kurung.  Mari kita menulis metode kecil untuk memecahkan kode itu: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 16 lines in a batch, each block has a length 32 bits for cw in range(16): cws = block[32 * cw:32 * (cw + 1)] if cws[0] == "0": addr = cws[1:19] print(" Addr:" + addr) else: msg = cws[1:21] print(" Msg: " + msg) size = 4 s = "" for ind in range(0, len(msg), size): bcd_s = msg[ind:ind + size] value = int(bcd_s, 2) symbols = "0123456789*U -)(" s += symbols[value] print(" ", s) print()</span></span></code> </pre><br>  Akhirnya, kami mendapatkan pesan "0682 *) * 882". <br><br>  Sulit untuk mengatakan apa maknanya, tetapi jika hanya pesan numerik yang digunakan, seseorang mungkin membutuhkannya. <br><br><h2>  Mengurai kode pesan alfa-numerik </h2><br>  Langkah selanjutnya, dan yang lebih menarik, adalah mendekode pesan alpha-numeric.  Ini lebih menarik, karena sebagai output, kita harus mendapatkan teks yang dapat dibaca manusia. <br><br>  Pertama, kita perlu merekam pesan lagi, kita akan menggunakan HDSDR.  Kami tidak tahu jenis pesan sebelum decoding, jadi kami hanya akan merekam pesan terpanjang, kami bisa dapatkan, dan akan berharap bahwa itu berisi beberapa teks. <br><br><img src="https://habrastorage.org/webt/lu/ue/sk/luuesk79iv_yalka_pchncpwzoi.jpeg"><br><br>  Setelah mengkonversi dari wav ke sedikit urutan (lihat kode Python di atas), kita mendapatkan ini: <br><br><img src="https://habrastorage.org/webt/qb/wt/ud/qbwtud3zptfcwxw3xs0pam7pkr4.jpeg"><br><br>  Beberapa hal menarik yang dapat kita lihat segera, dengan mata telanjang - sebagai contoh, urutan awal 01010101010101 berulang dua kali.  Dengan demikian, pesan ini tidak hanya lebih lama, secara harfiah mengandung dua pesan, digabung bersama (standar tidak menyangkal ini, btw). <br><br>  Seperti yang telah kami temukan sebelumnya, setiap blok data dimulai dari urutan, yang disebut Frame Sync Code (01111100 ...), setelah itu blok 32-bit dikirim.  Setiap blok dapat menyimpan alamat atau isi pesan. <br><br>  Sebelumnya kami mendapat pesan numerik saja, sekarang kami ingin membaca pesan ASCII.  Pertama, kita perlu membedakan mereka.  Data ini disimpan dalam bidang "Function Bits" (bit 20-21) - jika kedua bitnya 00, itu hanya pesan numerik, jika bitnya 11, itu adalah pesan teks. <br><br>  Menarik untuk disebutkan, bahwa bidang pesan memiliki panjang 20-bit, sehingga ideal untuk menempatkan lima blok 4-bit di sana dalam kasus pesan numerik saja.  Tetapi jika kita memiliki pesan ASCII 7bit, kita tidak dapat membagi 20 hingga 7. Kemungkinan untuk memprediksi bahwa versi protokol pertama hanya mendukung pesan numerik saja (jangan lupa bahwa itu dibuat pada tahun 1982 <s>dan mungkin pager nixie-tube pertama) tidak dapat menampilkan lebih banyak</s> ), dan hanya kemudian dukungan pesan ASCII ditambahkan.  Karena alasan warisan standar framing tidak berubah, dan pengembang menggunakan pendekatan yang mudah - mereka hanya menggabungkan bit "sebagaimana adanya", satu demi satu.  Dari setiap pesan kita perlu mengambil 20 bit dan menggabungkannya ke pesan berikutnya, akhirnya kita bisa mendekode isi pesan. <br><br>  Mari kita lihat satu blok pesan kita (spasi lebih mudah dibaca): <br><br> <code>0 0001010011100010111111110010010 <br> 1 00010100000110110011 11100111001 <br> 1 01011010011001110100 01111011100 <br> 1 11010001110110100100 11011000100 <br> 1 11000001101000110100 10011110111 <br> 1 11100000010100011011 11101110000 <br> 1 00110010111011001101 10011011010 <br> 1 00011001011100010110 10011000010 <br> 1 10101100000010010101 10110000101 <br> 1 00010110111011001101 00000011011 <br> 1 10100101000000101000 11001010100 <br> 1 00111101010101101100 11011111010</code> <br> <br>  "0" bit Pada string pertama menunjukkan kepada kita bahwa itu adalah bidang alamat, dan "11" dalam 20-21 bit menunjukkan kepada kita bahwa pesan tersebut benar-benar alfa-numerik.  Kemudian kita hanya mengambil 20 bit dari setiap string dan menggabungkannya. <br><br>  Ini adalah urutan bit kami: <br><br> <code>00010100000110110011010110100110011101001101000111011010010011000001101000 <br> 11010011100000010100011011001100101110110011010001100101110001011010101100 <br> 000010010101000101101110110011011010010100000010100000111101010101101</code> <br> <br>  Dalam POCSAG 7-bit kode ASCII digunakan, jadi kami akan membagi string menjadi 7 blok char: <br><br> <code>0001010 0000110 1100110 1011010 0110011 1010011 ...</code> <br> <br>  Setelah mencoba men-decode-nya (tabel ASCII dapat dengan mudah ditemukan di Internet), kita mendapatkan ... tidak ada apa-apa.  Memeriksa manual lagi, dan inilah frasa kecil "karakter ASCII ditempatkan dari kiri ke kanan (MSB ke LSB).  LSB mentransmisikan terlebih dahulu. "  Jadi, bit rendah mentransmisikan pertama - untuk decoding yang benar kita perlu membalik semua string. <br><br>  Terlalu membosankan untuk melakukannya secara manual, jadi mari kita menulis kode Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> msgs = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">16</span></span>): cws = block[<span class="hljs-number"><span class="hljs-number">32</span></span> * cw:<span class="hljs-number"><span class="hljs-number">32</span></span> * (cw + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-comment"><span class="hljs-comment"># Skip the idle word if cws.startswith("0111101010"): continue if cws[0] == "0": addr, type = cws[1:19], cws[19:21] print(" Addr:" + addr, type) else: msg = cws[1:21] print(" Msg: " + msg) msgs += msg # Split long string to 7 chars blocks bits = [msgs[i:i+7] for i in range(0, len(msgs), 7)] # Get the message msg = "" for b in bits: b1 = b[::-1] # Revert string value = int(b1, 2) msg += chr(value) print("Msg:", msg) print()</span></span></code> </pre><br>  Akhirnya, kita mendapatkan urutan ini (bit, kode simbol, dan simbol ASCII): <br><br><pre> <code class="plaintext hljs">0101000 40 ( 0110000 48 0 0110011 51 3 0101101 45 - 1100110 102 f 1100101 101 e 1100010 98 b 0101101 45 - 0110010 50 2 0110000 48 0 0110001 49 1 0111001 57 9 0100000 32 0110001 49 1 0110011 51 3 0111010 58 : 0110011 51 3 0110001 49 1 0111010 58 : 0110100 52 4 0110101 53 5 0100000 32 0101010 42 * 0110100 52 4 0110111 55 7 0110110 54 6 0101001 41 ) 0100000 32 1000001 65 A 1010111 87 W 1011010 90 Z</code> </pre><br>  Setelah penggabungan kita mendapatkan string: "(03-feb-2019 13:31:45 * 476) AWZ".  Seperti yang dijanjikan, itu cukup mudah dibaca manusia. <br><br>  By the way, menarik untuk disebutkan, bahwa kode ASCII 7-bit digunakan.  Simbol dari beberapa huruf (Jerman, Sirilik, dll) tidak dapat dikodekan dengan benar dalam 7 bit.  Kenapa 7 bit?  Mungkin para insinyur telah memutuskan bahwa "7 bit akan cukup untuk semua", siapa tahu ... <br><br><h2>  Kesimpulan </h2><br>  Sangat menarik untuk diselidiki, bagaimana POCSAG bekerja.  Ini adalah salah satu protokol yang jarang, yang digunakan sampai sekarang, yang secara harfiah dapat diuraikan pada lembaran kertas (dan saya pasti tidak akan mencoba ini dengan TETRA atau GSM). <br><br>  Yang pasti, protokol POCSAG tidak sepenuhnya dijelaskan di sini.  Bagian yang paling penting dan menarik dilakukan, hal-hal lain tidak begitu menarik.  Setidaknya, tidak ada decoding kode kode, dan tidak ada kode koreksi kesalahan (BCH Periksa Bit) - itu dapat memungkinkan untuk memperbaiki hingga 2 bit yang salah dalam pesan.  Tetapi tidak ada tujuan untuk menulis decoder POCSAG lain di sini, sudah ada cukup banyak dari mereka. <br><br>  Bagi mereka yang ingin menguji decoding nyata dengan rtl-sdr, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi PDW</a> freeware dapat digunakan.  Itu tidak memerlukan instalasi, hanya cukup untuk meneruskan suara dari HDSDR ke PDW melalui aplikasi Kabel Audio Virtual. <br><br>  Hasilnya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/-7/g-/ka/-7g-kalvhmaqlv79qju-wmgpglg.jpeg"><br><br>  (harap diingat bahwa decoding pesan layanan publik dapat ilegal di beberapa negara, dan tetap menghormati privasi penerima) <br><br>  Jika seseorang ingin mendapatkan lebih banyak informasi tentang topik ini, sumber decoder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">multimon-ng</a> tersedia, ia dapat mendekode banyak protokol, juga POCSAG dan FLEX. <br><br>  Terima kasih sudah membaca. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438906/">https://habr.com/ru/post/id438906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438894/index.html">Mengapa pengembangan web di Go lebih baik daripada di PHP</a></li>
<li><a href="../id438896/index.html">Jangan Menangis Bisnis</a></li>
<li><a href="../id438898/index.html">Chrome terbalik dan pemasangan ekstensi</a></li>
<li><a href="../id438900/index.html">Dalam perjalanan ke prinsip fisik evolusi biologis. Akhiri + teks lengkap terjemahan</a></li>
<li><a href="../id438902/index.html">Menggunakan DBREPLICATION saat meruntuhkan database di Microsoft SQL Server</a></li>
<li><a href="../id438908/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Hari 1. Dasar-Dasar Jaringan</a></li>
<li><a href="../id438910/index.html">Samba sebagai ADDC dalam Solaris 11.4</a></li>
<li><a href="../id438916/index.html">Catatan seorang phytochemist. Kentang. Bagian tiga. "Bullet Fugu" atau SOLANIN</a></li>
<li><a href="../id438920/index.html">Avalonia: pertemuan pertama</a></li>
<li><a href="../id438922/index.html">Enkripsi Lalu Lintas dalam Sambungan Langsung, Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>