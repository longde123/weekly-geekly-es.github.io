<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùì üéê üêÜ Arend: lenguaje de tipo dependiente basado en HoTT (parte 2) ‚úäüèæ üòê ü§∏üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la primera parte del art√≠culo sobre el lenguaje Arend, examinamos los tipos inductivos m√°s simples, funciones recursivas, clases y conjuntos. 

 2....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend: lenguaje de tipo dependiente basado en HoTT (parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/470632/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">En la primera parte del art√≠culo</a> sobre el lenguaje Arend, examinamos los tipos inductivos m√°s simples, funciones recursivas, clases y conjuntos. <br><br><h2>  2. Ordenar listas en Arend </h2><br><h3>  2.1 Listas ordenadas en Arend </h3><br>  Definimos el tipo de listas ordenadas como un par que consiste en una lista y prueba de su orden.  Como ya dijimos, en Arend, los pares dependientes se definen usando la palabra clave <code>\Sigma</code> .  Damos la definici√≥n del tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ordenado a</a> trav√©s de la comparaci√≥n con la muestra, inspirada en la definici√≥n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> ya mencionado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre listas ordenadas.</a> <br><br><pre> <code class="plaintext hljs">\func SortedList (O : LinearOrder.Dec) =&gt; \Sigma (l : List O) (Sorted l) \data Sorted {A : LinearOrder.Dec} (xs : List A) \elim xs | nil =&gt; nilSorted | :-: x nil =&gt; singletonSorted | :-: x1 (:-: x2 xs) =&gt; consSorted ((x1 = x2) || (x1 &lt; x2)) (Sorted (x2 :-: xs))</code> </pre> <br>  Nota: Arend pudo inferir autom√°ticamente que el tipo <code>Sorted</code> est√° contenido en el universo <code>\Prop</code> .  Esto sucedi√≥ porque los tres patrones en la definici√≥n <code>Sorted</code> son mutuamente excluyentes, y el constructor <code>consSorted</code> tiene dos par√°metros, los cuales pertenecen a <code>\Prop</code> . <br>  Probemos alguna propiedad obvia del predicado ordenado, digamos que la cola de una lista ordenada es en s√≠ misma una lista ordenada (esta propiedad nos ser√° √∫til en el futuro). <br><a name="habracut"></a><br><pre> <code class="plaintext hljs">\func tail-sorted {O : LinearOrder.Dec} (x : O) (xs : List O) (A : Sorted (x :-: xs)) : Sorted xs \elim xs, A | nil, _ =&gt; nilSorted | :-: _ _, consSorted _ xs-sorted =&gt; xs-sorted</code> </pre> <br>  En la <code>tail-sorted</code> utilizamos la coincidencia de patrones en la lista <code>xs</code> y el predicado <code>tail-sorted</code> al mismo tiempo, adem√°s, utilizamos el <i>car√°cter de omisi√≥n</i> "_", que puede sustituirse por variables no utilizadas. <br><br>  Uno puede preguntar si es posible en Arend probar la propiedad de las listas ordenadas, mencionadas en la secci√≥n 1.3 como un ejemplo de un hecho que no puede probarse en Agda sin anotaciones de inmaterialidad.  Recuerde que esta propiedad afirma que para probar la igualdad de las listas ordenadas definidas a trav√©s de pares dependientes, es suficiente verificar la igualdad de los primeros componentes de los pares. <br><br>  Se argumenta que en Arend esta propiedad se obtiene f√°cilmente como consecuencia de la construcci√≥n <code>inProp</code> mencionada anteriormente y la propiedad de extensionalidad para pares <code>SigmaExt</code> dependientes. <br><br><pre> <code class="plaintext hljs">\func sorted-equality {A : LinearOrder.Dec} (l1 l2 : SortedList A) (P : l1.1 = l2.1) : l1 = l2 =&gt; SigmaPropExt Sorted l1 l2 P</code> </pre> <br>  La propiedad <code>SigmaPropExt</code> prueba en el m√≥dulo <a href="">Paths</a> de la biblioteca est√°ndar, muchos otros hechos del segundo cap√≠tulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del libro HoTT</a> , incluida la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedad de extensibilidad funcional</a> , tambi√©n se prueban all√≠. <br><br>  El operador <code>.n</code> usa en Arend para acceder al proyector de tipo sigma con el n√∫mero n (en nuestro caso, el tipo sigma es <code>SortedList A</code> , y la expresi√≥n <code>l1.1</code> significa que el primer componente de este tipo es una expresi√≥n de tipo <code>List A</code> ). <br><br><h3>  2.2 Implementaci√≥n de la propiedad "be permutation" </h3><br>  Ahora intentemos implementar la funci√≥n de clasificaci√≥n de listas en Arend.  Naturalmente, no queremos tener una implementaci√≥n simple del algoritmo de clasificaci√≥n, sino una implementaci√≥n junto con una prueba de algunas propiedades. <br><br>  Claramente, este algoritmo debe tener al menos 2 propiedades: <br>  1. El resultado del algoritmo debe ser una lista ordenada. <br>  2. La lista resultante debe ser una permutaci√≥n de la lista original. <br><br>  Primero, intentemos implementar la propiedad "be permutation" de las listas en Arend.  Para hacer esto, adaptamos la definici√≥n tomada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de aqu√≠</a> para Arend. <br><br><pre> <code class="plaintext hljs">\truncated \data InsertSpec {A : \Set} (xs : List A) (a : A) (ys : List A) : \Prop \elim xs, ys | xs, :-: y ys =&gt; insertedHere (a = y) (xs = ys) | :-: x xs, :-: y ys =&gt; insertedThere (x = y) (InsertSpec xs a ys) \truncated \data Perm {A : \Set} (xs ys : List A) : \Prop | permInsert (xs' ys' : List A) (a : A) (Perm xs' ys') (InsertSpec xs' a xs) (InsertSpec ys' a ys) | permTrivial (xs = ys)</code> </pre> <br>  El predicado <code>InsertSpec</code> introducido por nosotros tiene el siguiente significado intuitivo: <code>InsertSpec xs a ys</code> significa exactamente que la lista <code>ys</code> es el resultado de insertar el elemento a dentro de la lista <code>xs</code> (en cualquier posici√≥n).  Por lo tanto, <code>InsertSpec</code> se puede tomar como una especificaci√≥n de la funci√≥n de inserci√≥n. <br><br>  Est√° claro que el tipo de datos <code>Perm</code> realmente define la relaci√≥n "ser permutaci√≥n": el constructor <code>permInsert</code> exactamente que <code>xs</code> e <code>ys</code> son mutuamente permutables si se obtienen <code>xs</code> e <code>ys</code> insertando el mismo elemento a en algunas listas <code>xs'</code> e <code>ys'</code> longitudes m√°s cortas, que ya son permutaciones entre s√≠. <br><br>  Para nuestra definici√≥n de la propiedad "ser permutaci√≥n", es f√°cil verificar la propiedad de simetr√≠a. <br><br><pre> <code class="plaintext hljs">\func Perm-symmetric {A : \Set} {xs ys : List A} (P : Perm xs ys) : Perm ys xs \elim P | permTrivial xs=ys =&gt; permTrivial (inv xs=ys) | permInsert perm-xs'-ys' xs-spec ys-spec =&gt; permInsert (Perm-symmetric perm-xs'-ys') ys-spec xs-spec</code> </pre> <br>  La propiedad de transitividad tambi√©n se satisface para <code>Perm</code> , pero su verificaci√≥n es mucho m√°s complicada.  Dado que esta propiedad no juega ning√∫n papel en la implementaci√≥n de nuestro algoritmo de clasificaci√≥n, lo dejamos al lector como un ejercicio. <br><br><pre> <code class="plaintext hljs">\func Perm-transitive {A : \Set} (xs ys zs : List A) (P1 : Perm xs ys) (P2 : Perm ys zs) : Perm xs zs =&gt; {?}</code> </pre> <br><h3>  2.3 Cambio en los niveles de homotop√≠a en comparaci√≥n con la muestra </h3><br>  Ahora intentemos implementar una funci√≥n que inserte un elemento en una lista ordenada para que la lista resultante permanezca ordenada.  Comencemos con la siguiente implementaci√≥n ingenua. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case LinearOrder.trichotomy xy \with {  | byLeft x=y =&gt; x :-: insert xs' y  | byRight (byLeft x&lt;y) =&gt; x :-: insert xs' y  | byRight (byRight y&lt;x) =&gt; y :-: x :-: xs' }</code> </pre> <br>  La construcci√≥n <code>\case</code> permite la coincidencia con una muestra de una expresi√≥n arbitraria ( <code>\elim</code> se puede usar en el nivel m√°s alto de una definici√≥n de funci√≥n y solo para sus par√°metros).  Si le pide a Arend que verifique el tipo de <code>insert</code> , se mostrar√° el siguiente mensaje de error. <br><br><pre> <code class="plaintext hljs">[ERROR] Data type '||' is truncated to the universe \Prop  which does not fit in the universe of the eliminator type: List OE In: | byLeft x-leq-y =&gt; x :-: insert xs' y While processing: insert</code> </pre> <br>  El problema es que en la clase <code>LinearOrder.Dec</code> , la <code>LinearOrder.Dec</code> define utilizando <code>||</code>  , que, a su vez, se determina utilizando el truncamiento proposicional.  Como ya se mencion√≥, para los tipos que pertenecen al universo <code>\Prop</code> , la coincidencia con un patr√≥n en Arend solo se permite si el tipo de la expresi√≥n resultante es en s√≠ misma una aserci√≥n (para la funci√≥n anterior, el resultado es de tipo <code>List OE</code> , y este tipo es un conjunto). <br><br>  ¬øHay alguna forma de evitar este problema?  La forma m√°s f√°cil de resolver esto es cambiar la definici√≥n de la propiedad de la tricotom√≠a.  Considere la siguiente definici√≥n de tricotom√≠a, utilizando el tipo no truncado <code>Or</code> lugar del truncado <code>||</code>  : <br><br><pre> <code class="plaintext hljs">\func set-trichotomy {A : StrictPoset} (xy : A) =&gt; ((x = y) `Or` (x &lt; y)) `Or` (y &lt; x)</code> </pre> <br>  ¬øEsta definici√≥n <code>trichotomy</code> en algo de la definici√≥n de <code>trichotomy</code> original a trav√©s de <code>||</code>  ?  ¬øPor qu√© incluso usamos un tipo truncado proposicionalmente si solo complica nuestra vida y nos impide usar la coincidencia de patrones? <br><br>  Intentemos responder la primera pregunta para empezar: para √≥rdenes estrictas de <code>StrictPoset</code> diferencia entre <code>trichotomy</code> y <code>trichotomy</code> <code>set-trichotomy</code> no es en absoluto.  Tenga en cuenta que el tipo <code>set-trichotomy</code> es una declaraci√≥n.  Este hecho se deduce del hecho de que las tres alternativas en la definici√≥n de tricotom√≠a son mutuamente excluyentes debido a los axiomas de orden, y cada uno de los tres tipos <code>x = y, x &lt; y, y &lt; x</code> es en s√≠ mismo una declaraci√≥n ( <code>x = y</code> es una declaraci√≥n, por lo que como en la definici√≥n de la clase <code>BaseSet</code> que los medios <code>E</code> un conjunto). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-isProp {A : StrictPoset} (xy : A) (l1 l2 : set-trichotomy xy): l1 = l2 \elim l1, l2 | inl (inl l1), inl (inl l2) =&gt; pmap (\lam z =&gt; inl (inl z)) (Path.inProp l1 l2) | inl (inr l1), inl (inr l2) =&gt; pmap (\lam z =&gt; inl (inr z)) (Path.inProp l1 l2) | inr l1, inr l2 =&gt; pmap inr (Path.inProp l1 l2) | inl (inl l1), inl (inr l2) =&gt; absurd (lt-eq-false l1 l2) | inl (inr l1), inl (inl l2) =&gt; absurd (lt-eq-false l2 l1) | inl (inl l1), inr l2 =&gt; absurd (lt-eq-false (inv l1) l2) | inr l1, inl (inl l2) =&gt; absurd (lt-eq-false (inv l2) l1) | inl (inr l1), inr l2 =&gt; absurd (lt-lt-false l1 l2) | inr l1, inl (inr l2) =&gt; absurd (lt-lt-false l2 l1) \where {  \func lt-eq-false {A : StrictPoset} {xy : A} (l1 : x = y) (l2 : x &lt; y) : Empty =&gt;    A.&lt;-irreflexive x (transport (x &lt;) (inv l1) l2)  \func lt-lt-false {A : StrictPoset} {xy : A} (l1 : x &lt; y) (l2 : y &lt; x) : Empty =&gt;   A.&lt;-irreflexive x (A.&lt;-transitive _ _ _ l1 l2) }</code> </pre> <br>  En la lista anterior, <code>absurd</code> es la designaci√≥n para el principio ex falso quodlibet, que se define en el m√≥dulo <a href="">L√≥gico</a> .  Dado que el tipo <code>Empty</code> no tiene constructores en la definici√≥n (ver secci√≥n 1.2), no es necesario pasar por los casos en la definici√≥n de <code>absurd</code> : <br><br><pre> <code class="plaintext hljs">\func absurd {A : \Type} (x : Empty) : A</code> </pre> <br>  Dado que ahora sabemos que <code>set-trichotomy</code> es una declaraci√≥n, podemos derivar la propiedad <code>set-trichotomy</code> propiedad habitual de <code>trichotomy</code> de √≥rdenes decidibles.  Para hacer esto, podemos usar la construcci√≥n <code>\return \level</code> , que le dice al temporizador Arend que en este punto la coincidencia de patrones es una operaci√≥n permitida (en este caso, tenemos que demostrar que el resultado de la funci√≥n <code>set-trichotomy-property</code> es una declaraci√≥n). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-property {A : LinearOrder.Dec} (xy : A) : set-trichotomy xy =&gt; \case A.trichotomy xy \return \level (set-trichotomy xy) (set-trichotomy-isProp xy) \with {  | byLeft x=y =&gt; inl (inl x=y)  | byRight (byLeft x&lt;y) =&gt; inl (inr x&lt;y)  | byRight (byRight y&lt;x) =&gt; inr (y&lt;x) }</code> </pre> <br>  Tratemos ahora de responder la segunda pregunta, a saber, por qu√©, al formular las propiedades de los objetos matem√°ticos, es preferible usar construcciones no ordinarias, sino truncadas proposicionalmente.  Considere para esto un fragmento de la definici√≥n de √≥rdenes lineales no lineales (las definiciones completas de <code>Lattice</code> y <code>TotalOrder</code> se pueden encontrar en el m√≥dulo <a href="">LinearOrder</a> ): <br><br><pre> <code class="plaintext hljs">\class TotalOrder \extends Lattice { | totality (xy : E) : x &lt;= y || y &lt;= x }</code> </pre> <br>  Tratemos de imaginar ahora c√≥mo <code>TotalOrder</code> el significado de la clase <code>TotalOrder</code> si <code>TotalOrder</code> la definici√≥n del campo de totalidad a trav√©s de la construcci√≥n <code>Or</code> truncada. <br><br><pre> <code class="plaintext hljs">\class BadTotalOrder \extends Lattice { | badTotality (xy : E) : (x &lt;= y) `Or` (y &lt;= x) }</code> </pre> <br>  En este caso, el tipo <code>(x &lt;= y) `Or` (y &lt;= x)</code> ya no es una declaraci√≥n, porque  en caso de valores iguales de <code>x</code> e <code>y</code> ambas alternativas en la definici√≥n de <code>badTotality</code> se pueden implementar, y la elecci√≥n de la rama izquierda o derecha en la prueba de <code>badTotality</code> absolutamente arbitraria y queda a discreci√≥n del usuario; no hay raz√≥n para preferir uno <code>Or</code> un constructor a otro. <br><br>  Ahora est√° claro cu√°l es la diferencia entre <code>TotalOrder</code> y <code>BadTotalOrder</code> .  Dos conjuntos ordenados <code>O1 O2</code> : <code>TotalOrder</code> siempre son iguales cuando es posible demostrar la igualdad de los conjuntos <code>O1.E, O2.E</code> y las √≥rdenes <code>O1.&lt;, O2.&lt;</code> Dado en ellos (esta es la propiedad deseada).  Por otro lado, para <code>O1 O2</code> : <code>BadTotalOrder</code> es <code>BadTotalOrder</code> probar la igualdad de <code>O1</code> y <code>O2</code> solo cuando, adem√°s de todos los elementos <code>x</code> de <code>E</code> <code>O1.badTotality xx</code> <code>E</code> igualdad <code>O1.badTotality xx</code> y <code>O2.badTotality xx</code> . <br><br>  Por lo tanto, resulta que la clase <code>BadTotalOrder</code> intuitivamente debe considerarse no como un "conjunto ordenado linealmente", sino como un "conjunto ordenado linealmente junto con la elecci√≥n para cada elemento <code>x</code> campo <code>E</code> rama izquierda o derecha <code>Or</code> en la implementaci√≥n de <code>badTotality xx</code> ". <br><br><h3>  2.4 Algoritmo de clasificaci√≥n </h3><br>  Ahora procedemos a implementar el algoritmo de clasificaci√≥n.  Tratemos de arreglar la implementaci√≥n ingenua de la funci√≥n de <code>insert</code> de la secci√≥n anterior utilizando la <code>set-trichotomy-property</code> probada <code>set-trichotomy-property</code> (en este caso, debido a la disposici√≥n m√°s exitosa de los corchetes en la definici√≥n de <code>set-trichotomy</code> , hemos reducido el n√∫mero de casos considerados). <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; y :-: x :-: xs'  | inl x&lt;=y =&gt; x :-: insert xs' y }</code> </pre> <br>  Ahora intentemos implementar un an√°logo de esta definici√≥n para las listas ordenadas.  Usaremos la construcci√≥n especial <code>\let ‚Ä¶ \in</code> , que nos permite agregar nuevas variables locales al contexto. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : SortedList O \elim xs | (nil, _) =&gt; (y :-: nil, singletonSorted) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; (y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted)  | inl x&lt;=y =&gt; \let (result, result-sorted) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y         \in (x :-: result, {?})</code> </pre> <br>  Dejamos en la prueba un fragmento incompleto (indicado por la expresi√≥n <code>{?}</code> ) En el lugar donde desea mostrar que la lista <code>x :-: result</code> ordenado.  Aunque en el contexto hay evidencia del orden de la lista de <code>result</code> , nos queda por verificar que <code>x</code> no exceda el valor del primer elemento de la lista de <code>result</code> , que no es tan f√°cil de seguir desde las premisas en el contexto (para ver todas las premisas en el objetivo actual - esto es lo que llamamos rama actual de los c√°lculos: debe solicitar la verificaci√≥n de tipo desde la funci√≥n de <code>insert</code> ). <br><br>  Resulta que la <code>insert</code> mucho m√°s f√°cil de implementar si probamos el orden de la lista resultante en paralelo con la prueba de la especificaci√≥n de <code>insert</code> .  Cambie la firma de <code>insert</code> y escriba la prueba de esta especificaci√≥n en los casos m√°s simples: <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)  | inl x&lt;=y =&gt;   \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y   \in ((x :-: result, {?}), insertedThere idp result-spec)</code> </pre> <br>  Para un solo fragmento que queda sin prueba, Arend generar√° el siguiente valor de contexto: <br><br><pre> <code class="plaintext hljs">Expected type: Sorted (x :-: (insert (\this, tail-sorted x \this \this) \this).1.1) Context:  result-sorted : Sorted (insert (\this, tail-sorted \this \this \this) \this).1.1  xs-sorted : Sorted (x :-: xs')  x : O  x&lt;=y : Or (x = y) (O.&lt; xy)  O : Dec  result : List O  y : O  xs' : List O  result-spec : InsertSpec xs' y (insert (xs', tail-sorted \this xs' \this) y).1.1</code> </pre> <br>  Para completar la prueba, tendremos que usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toda la potencia del</a> operador <code>\case</code> : utilizaremos la coincidencia de patrones con 5 variables diferentes, y dado que los tipos de algunas variables pueden depender de los valores de otras variables, utilizaremos la coincidencia de patrones dependientes. <br><br>  La construcci√≥n de dos puntos indica expl√≠citamente c√≥mo el tipo de algunas variables a comparar depende del valor de otras variables (por lo tanto, en el tipo de variables <code>xs-sorted, result-spec</code> y <code>result-sorted</code> en cada <code>\case</code> lugar de <code>xs'</code> y <code>result</code> coincidir√° con las muestras correspondientes). <br><br>  La construcci√≥n <code>\return</code> asocia las variables utilizadas para hacer coincidir el patr√≥n con el tipo de resultado esperado.  En otras palabras, en el objetivo actual, en cada una de las cl√°usulas <code>\case</code> , la muestra correspondiente se sustituir√° por la variable de <code>result</code> .  Sin esta construcci√≥n, dicho reemplazo no se llevar√≠a a cabo, y el objetivo de todas las cl√°usulas <code>\case</code> coincidir√≠a con el objetivo en lugar de la expresi√≥n <code>\case</code> misma. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs  | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp)  | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {   | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)   | inl x&lt;=y =&gt;     \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y     \in ((x :-: result,       \case result \as result, xs' \as xs', xs-sorted : Sorted (x :-: xs'), result-spec : InsertSpec xs' y result, result-sorted : Sorted result       \return Sorted (x :-: result) \with {        | nil, _, _, _, _ =&gt; singletonSorted        | :-: r rs, _, _, insertedHere y=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) y=r (Or-to-|| x&lt;=y)) result-sorted        | :-: r rs, :-: x' _, consSorted x&lt;=x' _, insertedThere x2=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) x2=r x&lt;=x') result-sorted }), insertedThere idp result-spec)</code> </pre> <br>  En el bloque de c√≥digo anterior, los primeros argumentos complejos del constructor <code>consSorted</code> en los √∫ltimos dos p√°rrafos de la comparaci√≥n de patrones merecen un comentario adicional.  Para entender qu√© significan ambas expresiones, las reemplazamos con la expresi√≥n <code>{?}</code> Y le pedimos al temporizador Arend que determine los objetivos en ambas posiciones. <br><br>  Puede ver que tanto all√≠ como all√≠ el objetivo actual es el tipo <code>(x = r) || O.&lt; xr</code>  <code>(x = r) || O.&lt; xr</code> .  Adem√°s, en el contexto del primer objetivo, hay premisas <br><br><pre> <code class="plaintext hljs">x&lt;=y : Or (x = y) (O.&lt; xy) y=r : y = r</code> </pre> <br>  y en el contexto del segundo - premisas <br><br><pre> <code class="plaintext hljs">x&lt;=x' : (x = x') || O.&lt; xx' x2=r : x' = r.</code> </pre> <br>  Intuitivamente claro: para probar el primer objetivo, es suficiente sustituir la variable <code>r</code> en el enunciado correcto <code>Or (x = y) (O.&lt; xy)</code> , y luego cambiar al tipo truncado proposicionalmente <code>||</code>  utilizando la funci√≥n <code>Or-to-||</code> definida en la Secci√≥n 1.3  .  Para probar el segundo objetivo, simplemente sustituya en <code>(x = x') || O.&lt; x x'</code>  <code>(x = x') || O.&lt; x x'</code> lugar de la variable <code>x'</code> variable <code>r</code> . <br><br>  Para formalizar la operaci√≥n de sustituci√≥n de expresi√≥n descrita, existe una funci√≥n de <code>transport</code> especial en la biblioteca est√°ndar de Arend.  Considere su firma: <br><br><pre> <code class="plaintext hljs">\func transport {A : \Type} (B : A -&gt; \Type) {aa' : A} (p : a = a') (b : B a) : B a'</code> </pre> <br>  En nuestro caso, el tipo <code>OE</code> debe ser sustituido por la variable <code>A</code> (puede omitirse expl√≠citamente si se especifican los otros argumentos de <code>transport</code> ), y la expresi√≥n <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code>  <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code> . <br><br>  La implementaci√≥n del algoritmo de clasificaci√≥n de inserci√≥n junto con la especificaci√≥n ya no causa dificultades particulares: para ordenar la lista <code>x :-: xs'</code> , primero ordenamos la cola de la lista <code>xs'</code> usando una llamada recursiva a <code>insertSort</code> , y luego insertamos el elemento <code>x</code> dentro de esta lista mientras conservamos el orden cuando Ayuda a acceder a la funci√≥n de <code>insert</code> ya implementada. <br><br><pre> <code class="plaintext hljs">\func insertSort {O : LinearOrder.Dec} (xs : List O) : \Sigma (result : SortedList O) (Perm xs result.1) \elim xs | nil =&gt; ((nil, nilSorted), permTrivial idp) | :-: x xs' =&gt; \let | (ys, perm-xs'-ys) =&gt; insertSort xs'                      | (zs, zs-spec) =&gt; insert ys x                  \in (zs, permInsert perm-xs'-ys (insertedHere idp idp) zs-spec)</code> </pre> <br>  Cumplimos el objetivo inicial e implementamos la clasificaci√≥n de las listas en Arend.  Todo el c√≥digo Arend que se proporciona en este p√°rrafo se puede descargar en un archivo <a href="">desde aqu√≠</a> . <br><br>  Uno podr√≠a preguntarse c√≥mo tendr√≠a que cambiar la implementaci√≥n de la funci√≥n de <code>insert</code> si en lugar de las √≥rdenes estrictas <code>LinearOrder.Dec</code> utilizamos las √≥rdenes no estrictas <code>TotalOrder</code> ?  Como recordamos, en la definici√≥n de la funci√≥n de totalidad, el uso de la operaci√≥n truncada <code>||</code>  fue bastante significativo, es decir, esta definici√≥n no es equivalente a una definici√≥n en la que en lugar de <code>||</code>  utilizado por <code>Or</code> . <br><br>  La respuesta a esta pregunta es la siguiente: todav√≠a es posible construir un an√°logo de <code>insert</code> para <code>TotalOrder</code> , sin embargo, para esto tendr√≠amos que demostrar que el tipo de la funci√≥n de <code>insert</code> es una declaraci√≥n (esto nos permitir√≠a en la definici√≥n de <code>insert</code> hacer una comparaci√≥n con la muestra de acuerdo con la declaraci√≥n de <code>totality xy</code> ). <br><br>  En otras palabras, tendr√≠amos que demostrar que solo hay una lista ordenada hasta la igualdad, que es el resultado de insertar el elemento <code>y</code> en la lista ordenada <code>xs</code> .  Es f√°cil ver que este es un hecho cierto, pero su prueba formal ya no es tan trivial.  Dejamos la verificaci√≥n de este hecho como un ejercicio para el lector interesado. <br><br><h2>  3. Observaciones finales </h2><br>  En esta introducci√≥n, nos familiarizamos con las construcciones principales del lenguaje Arend, y tambi√©n aprendimos c√≥mo usar el mecanismo de clase.  Logramos implementar el algoritmo m√°s simple junto con la prueba de su especificaci√≥n.  Por lo tanto, hemos demostrado que Arend es bastante adecuado para resolver problemas "cotidianos", como, por ejemplo, la verificaci√≥n de programas. <br><br>  Hemos mencionado lejos de todas las caracter√≠sticas y caracter√≠sticas de Arend.  Por ejemplo, no dijimos casi nada acerca de los <i>tipos con condiciones</i> que le permiten "pegar" varios constructores de tipos con algunos valores de par√°metros especiales para estos constructores.  Por ejemplo, se proporciona una implementaci√≥n del tipo entero en Arend usando tipos con las condiciones siguientes: <br><br><pre> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero }</code> </pre> <br>  Esta definici√≥n dice que los enteros consisten en dos copias del tipo de n√∫meros naturales, en los que se identifican ceros "positivos" y "negativos".  Dicha definici√≥n es mucho m√°s conveniente que la definici√≥n de la biblioteca est√°ndar de Coq, donde la "copia negativa" de los n√∫meros naturales debe ser "desplazada por uno" para que estas copias no se crucen (es mucho m√°s conveniente cuando la notaci√≥n <code>neg 1</code> significa el n√∫mero -1, no -2) . <br><br>  No dijimos nada sobre el algoritmo para derivar niveles predicativos y de homotop√≠a en las clases y sus instancias.  Tampoco mencionamos el tipo de intervalo <code>I</code> , aunque juega un papel clave en la teor√≠a de los tipos con intervalos, que son la base l√≥gica de Arend.  Para comprender lo importante que es este tipo, es suficiente mencionar que en Arend la igualdad de tipos se define a trav√©s del concepto de intervalo.     ,   ,     ,           (..    ). <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> HoTT   </a>  JetBrains Research. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470632/">https://habr.com/ru/post/470632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470616/index.html">Una nueva soluci√≥n a la paradoja de Fermi (por qu√© estamos solos en el universo)</a></li>
<li><a href="../470618/index.html">Modelado tem√°tico de noticias usando an√°lisis factorial</a></li>
<li><a href="../470620/index.html">Infraestructura como c√≥digo: c√≥mo superar problemas con XP</a></li>
<li><a href="../470622/index.html">Descripci√≥n general de los m√©todos de selecci√≥n de funciones</a></li>
<li><a href="../470628/index.html">Simulador de naves espaciales construcci√≥n naval</a></li>
<li><a href="../470634/index.html">Identifique la comunidad cruzada en Instagram para identificar los intereses de los usuarios.</a></li>
<li><a href="../470638/index.html">M√©todos cuasi-newtonianos, o cuando hay demasiadas segundas derivadas para Athos</a></li>
<li><a href="../470640/index.html">Dimensionar Elasticsearch</a></li>
<li><a href="../470642/index.html">Conoce a Yandex.Station Mini. Gran historia de un peque√±o dispositivo.</a></li>
<li><a href="../470644/index.html">Por qu√© los blogs corporativos a veces son amargos: algunas observaciones y consejos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>