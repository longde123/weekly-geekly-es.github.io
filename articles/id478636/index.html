<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘» ğŸ‘©â€ğŸ”¬ ğŸ—ï¸ Cara kerja penyandian teks. Dari mana "buaya" berasal. Prinsip-prinsip pengkodean. Generalisasi dan analisis terperinci ğŸ˜¶ ğŸˆ·ï¸ â˜ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini bertujuan untuk menyatukan dan membongkar prinsip-prinsip dan mekanisme kerja pengkodean teks, secara rinci mekanisme ini untuk membongkar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara kerja penyandian teks. Dari mana "buaya" berasal. Prinsip-prinsip pengkodean. Generalisasi dan analisis terperinci</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478636/">  Artikel ini bertujuan untuk menyatukan dan membongkar prinsip-prinsip dan mekanisme kerja pengkodean teks, secara rinci mekanisme ini untuk membongkar dan menjelaskan.  Ini akan bermanfaat bagi mereka yang hanya membayangkan kira-kira apa itu penyandian teks dan bagaimana mereka bekerja, bagaimana mereka berbeda satu sama lain, mengapa kadang-kadang karakter yang tidak dapat dibaca muncul, apa prinsip penyandian yang dimiliki oleh penyandian yang berbeda. <br><br>  Untuk mendapatkan pemahaman rinci tentang masalah ini, Anda harus membaca dan menyatukan lebih dari satu artikel dan menghabiskan banyak waktu untuk hal ini.  Dalam materi ini, ini semua disatukan dan, secara teori, harus menghemat waktu dan analisis menurut saya ternyata cukup rinci. <br><br>  Apa yang akan terjadi di bawah cut: prinsip operasi pengkodean byte tunggal (ASCII, Windows-1251, dll), prasyarat untuk penampilan Unicode, apa itu Unicode, pengkodean Unicode UTF-8, UTF-16, perbedaannya, fitur fundamental, kompatibilitas dan ketidakcocokan pengkodean yang berbeda, prinsip pengkodean karakter, analisis praktis pengkodean dan pengodean. <br><br>  Masalah dengan pengkodean sekarang tentu saja telah kehilangan relevansinya, tetapi tetap saya tidak berpikir itu akan berlebihan untuk mengetahui bagaimana mereka bekerja sekarang dan bagaimana mereka bekerja sebelumnya. <br><a name="habracut"></a><br><h2>  Prasyarat Unicode </h2><br>  Saya pikir ini layak dimulai sejak saat komputerisasi belum begitu berkembang dan hanya mendapatkan momentum.  Kemudian para pengembang dan standardisator tidak berpikir bahwa komputer dan Internet akan mendapatkan popularitas dan prevalensi yang begitu besar.  Sebenarnya kemudian muncul kebutuhan untuk menyandikan teks.  Dalam bentuk apa perlu menyimpan surat-surat di komputer, dan dia (komputer) hanya memahami satu dan nol.  Jadi pengkodean ASCII satu byte dikembangkan (kemungkinan besar itu bukan pengkodean pertama, tetapi itu adalah yang paling umum dan indikatif, oleh karena itu kami akan menganggapnya sebagai referensi).  Seperti apa dia?  Setiap karakter dalam pengkodean ini dikodekan dengan 8 bit.  Mudah untuk menghitung bahwa, berdasarkan ini, pengkodean dapat berisi 256 karakter (delapan bit, nol atau yang 2 <sup>8</sup> = 256). <br><br>  7 bit pertama (128 karakter 2 <sup>7</sup> = 128) dalam pengkodean ini diberikan kepada karakter Latin, karakter kontrol (seperti jeda baris, tab, dll.) Dan karakter tata bahasa.  Sisanya disediakan untuk bahasa nasional.  Artinya, ternyata 128 karakter pertama selalu sama, dan jika Anda ingin menyandikan bahasa ibu Anda, silakan gunakan kapasitas yang tersisa.  Sebenarnya, kebun binatang kode nasional besar muncul.  Dan sekarang Anda sendiri dapat membayangkan, misalnya, ketika saya berada di Rusia, saya mengambil dan membuat dokumen teks, secara default dokumen itu dibuat dalam penyandian Windows-1251 (penyandian Rusia yang digunakan di Windows) dan dikirim ke seseorang, misalnya, di AS.  Bahkan fakta bahwa teman bicara saya tahu bahasa Rusia tidak akan membantunya, karena ketika ia membuka dokumen saya di komputernya (dalam editor dengan penyandian default ASCII yang sama), ia tidak akan melihat huruf Rusia, tetapi krakozyabry.  Untuk lebih tepatnya, tempat-tempat dalam dokumen yang saya tulis dalam bahasa Inggris akan ditampilkan tanpa masalah, karena 128 karakter pertama dari pengkodean Windows-1251 dan ASCII adalah sama, tetapi di mana saya menulis teks Rusia, jika tidak menunjukkan pengodean yang benar dalam editornya, dalam bentuk buaya. <br><br>  Saya pikir masalah dengan pengkodean nasional dapat dimengerti.  Sebenarnya, ada banyak pengkodean nasional ini, dan Internet telah menjadi sangat luas, dan semua orang di dalamnya ingin menulis dalam bahasa mereka sendiri dan tidak ingin bahasa mereka terlihat seperti rambut bengkok.  Ada dua jalan keluar, untuk menunjukkan untuk setiap halaman pengkodean, atau untuk membuat satu tabel karakter yang umum untuk semua karakter di dunia.  Opsi kedua dimenangkan, jadi kami membuat tabel karakter Unicode. <br><br><h3>  Lokakarya kecil ASCII </h3><br>  Ini mungkin tampak dasar, tetapi karena saya memutuskan untuk menjelaskan semuanya secara terperinci, maka ini perlu. <br><br>  Berikut adalah tabel karakter ASCII: <br><br><img src="https://habrastorage.org/webt/az/bt/mw/azbtmwjfkdtsfbvqd_ju-fibbwe.png"><br><br>  Di sini kita memiliki 3 kolom: <br><br><ul><li>  nomor karakter desimal </li><li>  nomor karakter dalam format heksadesimal </li><li>  representasi simbol itu sendiri. </li></ul><br>  Jadi, enkode string "ok" (ASCII).  Karakter "o" (eng.) Memiliki posisi 111 dalam desimal dan <i>6F</i> dalam heksadesimal.  <code><b>01101111</b></code> terjemahkan ini ke sistem biner - <code><b>01101111</b></code> .  Simbol "k" (eng.) - posisi 107 dalam desimal dan <i>6B</i> dalam heksadesimal, diterjemahkan ke dalam biner - <code><b>01101011</b></code> .  Total string "ok" yang dikodekan dalam ASCII akan terlihat seperti ini - <code><b>01101111 01101011</b></code> .  Proses decoding akan terbalik.  Kami mengambil 8 bit, menerjemahkannya menjadi penyandian 10-desimal, mendapatkan nomor karakter, melihat tabel karakter seperti apa itu. <br><br><h2>  Unicode </h2><br>  Dengan prasyarat untuk membuat tabel bersama untuk semua di dunia karakter, beres.  Sekarang, sebenarnya, ke meja itu sendiri.  Unicode - ini adalah tabel yang ada (ini bukan penyandian, tetapi tabel simbol).  Ini terdiri dari 1.114.112 posisi.  Sebagian besar posisi ini belum diisi dengan simbol, jadi tidak mungkin ruang ini perlu diperluas. <br><br>  Total ruang ini dibagi menjadi 17 blok, masing-masing 65.536 karakter.  Setiap blok berisi kelompok karakternya sendiri.  Blok nol adalah yang dasar, ini berisi karakter yang paling banyak digunakan dari semua huruf modern.  Di blok kedua adalah karakter bahasa yang punah.  Ada dua blok yang disediakan untuk penggunaan pribadi.  Sebagian besar blok belum diisi. <br><br>  Total kapasitas karakter Unicode adalah dari <i>0</i> hingga <i>10FFFF</i> (dalam heksadesimal). <br><br>  Karakter heksadesimal ditulis dengan awalan "U +".  Sebagai contoh, blok dasar pertama termasuk karakter dari U + 0000 ke U + FFFF (dari 0 hingga 65.535), dan blok ketujuh belas terakhir dari U + 100.000 ke U + 10FFFF (dari 1.048.576 ke 1.114.111). <br><br>  Nah sekarang, alih-alih kebun binatang pengkodean nasional, kami memiliki tabel komprehensif di mana semua karakter yang mungkin berguna bagi kami dienkripsi.  Namun ada juga kekurangannya.  Jika sebelum setiap karakter dikodekan dengan satu byte, sekarang dapat dikodekan dengan jumlah byte yang berbeda.  Misalnya, untuk menyandikan semua karakter alfabet bahasa Inggris, satu byte masih cukup, misalnya, karakter "o" yang sama dalam bahasa Inggris adalah unicode U + 006F, yaitu, nomor yang sama dengan ASCII adalah <i>6F</i> dalam heksadesimal dan 111 dalam desimal.  Tetapi untuk mengkodekan karakter " <a href="https://unicode-table.com/ru/search/%3Fq%3DU%252B103D5" rel="nofollow">U + 103D5</a> " (ini adalah nomor Persia kuno seratus) - 103D5 dalam heksadesimal dan 66.517 dalam desimal, di sini kita membutuhkan tiga byte. <br><br>  Penyandian Unicode seperti UTF-8 dan UTF-16 seharusnya sudah menyelesaikan masalah ini.  Selanjutnya kita akan membicarakannya. <br><br><h2>  Utf-8 </h2><br>  UTF-8 adalah pengodean Unicode panjang variabel yang dapat digunakan untuk mewakili karakter Unicode apa pun. <br><br>  Mari kita bicara lebih banyak tentang panjang variabel, apa artinya?  Hal pertama yang saya katakan adalah bahwa unit struktural (atom) dari pengkodean ini adalah byte.  Fakta bahwa pengkodean variabel panjang berarti bahwa satu karakter dapat dikodekan dengan jumlah unit struktural yang berbeda dari pengkodean, yaitu, dengan jumlah byte yang berbeda.  Misalnya, bahasa Latin dikodekan dalam satu byte, dan Cyrillic dalam dua byte. <br><br><h4>  Sedikit menyimpang dari topik, perlu untuk menulis tentang kompatibilitas ASCII dan UTF </h4><br>  Fakta bahwa karakter Latin dan struktur kontrol dasar, seperti jeda baris, tab, dll.  dikodekan dengan satu byte membuat pengkodean utf kompatibel dengan pengkodean ASCII.  Faktanya, bahasa Latin dan struktur kontrol terletak di tempat yang sama di ASCII dan UTF, dan fakta bahwa mereka dikodekan di sana-sini dengan satu byte memastikan kompatibilitas ini. <br><br>  Mari kita ambil karakter "o" dari contoh ASCII di atas.  Ingat bahwa dalam tabel karakter ASCII berada di 111 posisi, dalam bentuk bit akan <code><b>01101111</b></code> .  Dalam tabel Unicode, karakter ini adalah U + 006F, yang juga akan menjadi <b><code>01101111</code></b> dalam bentuk bit.  Dan sekarang, karena UTF adalah pengodean panjang variabel, karakter ini akan dikodekan dalam satu byte di dalamnya.  Artinya, representasi simbol ini di kedua pengkodean akan sama.  Jadi untuk seluruh rentang karakter dari 0 hingga 128. Artinya, jika dokumen Anda terdiri dari teks bahasa Inggris, maka Anda tidak akan melihat perbedaannya jika Anda membukanya dalam pengkodean UTF-8 dan UTF-16 dan ASCII (misalnya, dalam UTF-16 karakter tersebut semuanya sama-sama akan dikodekan dalam dua byte, sehingga Anda tidak akan melihat perbedaannya jika editor Anda mengabaikan nol byte), dan seterusnya hingga Anda mulai bekerja dengan alfabet nasional. <br><br>  Mari kita bandingkan dalam praktiknya seperti apa ungkapan "Hello World" dalam tiga penyandian berbeda: Windows-1251 (penyandian Rusia), ISO-8859-1 (penyandian bahasa Eropa Barat), UTF-8 (penyandian kode tunggal).  Inti dari contoh ini adalah frasa tersebut ditulis dalam dua bahasa.  Mari kita lihat bagaimana tampilannya dalam pengkodean yang berbeda. <br><br><img src="https://habrastorage.org/webt/cf/qa/_x/cfqa_xgr7adcrjoxgqj7nfbfcak.png"><br>  <i>Dalam pengkodean ISO-8859-1 tidak ada karakter seperti "m", "dan" dan "p".</i> <br><br>  Sekarang mari kita bekerja dengan pengkodean dan melihat bagaimana mengkonversi string dari satu pengkodean ke yang lain dan apa yang akan terjadi jika konversi salah, atau itu tidak dapat dilakukan karena perbedaan dalam pengkodean. <br><br>  Kami berasumsi bahwa frasa awalnya disandikan di Windows-1251.  Berdasarkan tabel di atas, kami menulis frasa ini dalam bentuk biner, yang dikodekan dalam Windows-1251.  Untuk melakukan ini, kita hanya perlu menerjemahkan simbol dari biner ke desimal atau heksadesimal (dari tabel di atas). <br><br> <code><b>01001000 01100101 01101100 01101100 01101111 00100000 11101100 11101000 11110000</b></code> <br>  <i>Nah, ini adalah frasa "Hello World" yang disandikan di Windows-1251.</i> <br><br>  Sekarang bayangkan Anda memiliki file dengan teks, tetapi tidak tahu di mana penyandian teks ini.  Anda menganggap bahwa itu dikodekan dalam ISO-8859-1 dan membukanya di editor Anda dalam pengkodean itu.  Seperti dikatakan di atas, dengan bagian dari simbol-simbol semuanya teratur, mereka berada dalam pengkodean ini, dan bahkan berada di tempat yang sama, tetapi dengan simbol-simbol dari kata "dunia" semuanya menjadi lebih rumit.  Karakter-karakter ini tidak ada dalam pengkodean ini, dan di tempat mereka dalam pengkodean ISO-8859-1 adalah karakter yang sama sekali berbeda.  Secara khusus, "m" adalah posisi 236, "dan" adalah 232. "p" adalah 240. Dan pada posisi ini dalam pengkodean ISO-8859-1 adalah posisi karakter berikut 236 - karakter "Ã¬", 232 - "Ã¨", 240 - "Ã°" <br><br>  Jadi frasa â€œHello Worldâ€ yang dikodekan di Windows-1251 dan dibuka di pengkodean ISO-8859-1 akan terlihat seperti ini: â€œHello Ã¬Ã¨Ã°â€.  Jadi ternyata kedua penyandian ini hanya kompatibel sebagian, dan tidak akan berfungsi dengan benar untuk menyandikan string dari satu penyandian ke penyandian lainnya, karena tidak ada karakter seperti itu. <br><br>  Di sini pengkodean Unicode akan diperlukan, dan khususnya dalam kasus ini, pertimbangkan UTF-8.  Fakta bahwa karakter di dalamnya dapat dikodekan dengan jumlah byte yang berbeda dari 1 hingga 4 yang telah kami temukan.  Sekarang layak untuk mengatakan bahwa menggunakan UTF dapat dikodekan tidak hanya 256 karakter, seperti pada dua karakter sebelumnya, tetapi lakukan semua karakter Unicode <br><br>  Ini berfungsi sebagai berikut.  Bit pertama dari setiap byte karakter pengkodean tidak bertanggung jawab atas karakter itu sendiri, tetapi untuk menentukan byte.  Itu, misalnya, jika bit (pertama) pertama adalah nol, maka ini berarti bahwa hanya satu byte yang digunakan untuk menyandikan karakter.  Yang menyediakan kompatibilitas dengan ASCII.  Jika Anda hati-hati melihat tabel karakter ASCII, Anda akan melihat bahwa 128 karakter pertama (alfabet Inggris, karakter kontrol dan tanda baca) jika mereka dikonversi ke biner, semuanya dimulai dengan bit nol (hati-hati jika Anda menerjemahkan karakter ke dalam sistem biner menggunakan misalnya online konverter, maka bit nol terkemuka pertama dapat dibuang, yang dapat membingungkan). <br><br>  <b><code>01001000</code></b> - bit pertama adalah nol, lalu 1 byte mengkodekan 1 karakter -&gt; "H" <br><br>  <b><code>01100101</code></b> - bit pertama adalah nol, yang berarti 1 byte mengkodekan 1 karakter -&gt; "e" <br><br>  Jika bit pertama bukan nol, maka karakter dikodekan dalam beberapa byte. <br><br>  Untuk karakter byte ganda, tiga bit pertama harus - 110 <br><br>  <b><code><font color="#cc0000">110</font> 10000 <font color="#008000">10</font> 111100</code></b> - pada awal 110, lalu 2 byte mengkodekan 1 karakter.  Byte kedua dalam kasus ini selalu dimulai dengan 10. Secara total, buang bit kontrol (yang awal, yang disorot dalam warna merah dan hijau) dan ambil semua <b><code>10000111100</code></b> tersisa ( <b><code>10000111100</code></b> ), terjemahkan ke dalam heksadesimal (043) -&gt; U + 043C di Unicode, simbol â€œm ". <br><br>  untuk karakter tiga byte dalam byte pertama, bit-bit utama adalah 1110 <br><br>  <b><code><font color="#cc0000">1110</font> 1000 <font color="#008000">10</font> 000111 <font color="#008000">10</font> 1010101</code></b> - kami meringkas semuanya kecuali bit kontrol dan kami mendapatkan bahwa dalam heksadesimal itu adalah 103V5, U + 103D5 adalah digit Persia kuno seratus ( <b><code>10000001111010101</code></b> ) <br><br>  untuk karakter empat-byte dalam byte pertama, bit-bit utama adalah 11110 <br><br>  <b><code><font color="#cc0000">11110</font> 100 <font color="#008000">10</font> 001111 <font color="#008000">10</font> 111111 <font color="#008000">10</font> 111111</code></b> - U + 10FFFF adalah karakter valid terakhir dalam tabel unicode ( <b><code>100001111111111111111</code></b> ) <br><br>  Sekarang, jika diinginkan, kami dapat merekam frasa kami dalam pengkodean UTF-8. <br><br><h2>  Utf-16 </h2><br>  UTF-16 juga merupakan pengkodean panjang variabel.  Perbedaan utamanya dari UTF-8 adalah bahwa unit struktural di dalamnya bukan hanya satu tetapi dua byte.  Artinya, dalam pengkodean UTF-16, setiap karakter Unicode dapat dikodekan dengan dua atau empat byte.  Demi kejelasan, izinkan saya memanggil sepasang byte tersebut sebagai pasangan kode.  Berdasarkan ini, setiap karakter Unicode yang dikodekan dalam UTF-16 dapat dikodekan dengan satu atau dua pasangan kode. <br><br>  Mari kita mulai dengan karakter yang dikodekan oleh satu pasangan kode.  Sangat mudah untuk menghitung bahwa ada 65.535 karakter seperti itu (2v16), yang sepenuhnya bertepatan dengan blok Unicode dasar.  Semua karakter yang ada di blok Unicode ini dalam pengkodean UTF-16 akan dikodekan dengan satu pasangan kode (dua byte), semuanya sederhana di sini. <br><br>  simbol "o" (Latin) - <code><b>00000000 01101111</b></code> <br>  simbol "M" (Sirilik) - <code><b>00000100 00011100</b></code> <br><br>  Sekarang pertimbangkan karakter di luar jangkauan Unicode dasar.  Untuk penyandiannya, diperlukan dua pasangan kode (4 byte).  Dan mekanisme untuk mengkodekannya sedikit lebih rumit, mari kita mulai. <br><br>  Untuk mulai dengan, kami memperkenalkan konsep pasangan pengganti.  Pasangan pengganti adalah dua pasangan kode yang digunakan untuk menyandikan satu karakter (total 4 byte).  Untuk pasangan pengganti seperti itu, rentang khusus dari <i>D800</i> ke <i>DFFF</i> diberikan dalam tabel Unicode.  Ini berarti bahwa ketika mengkonversi pasangan kode dari bentuk byte ke heksadesimal, Anda mendapatkan angka dari rentang ini, maka ini bukan karakter independen, tetapi pasangan pengganti. <br><br>  Untuk menyandikan karakter dari rentang <i>10000</i> - <i>10FFFF</i> (yaitu, karakter yang Anda perlukan untuk menggunakan lebih dari satu pasangan kode) Anda perlu: <br><br><ol><li>  Kurangi <i>10.000</i> (heksadesimal) dari kode karakter (ini adalah angka terkecil dari rentang <i>10000</i> - <i>10FFFF</i> ) </li><li>  sebagai hasil dari poin pertama, angka yang tidak lebih besar dari <i>FFFFF</i> akan diperoleh, menempati hingga 20 bit </li><li>  10 bit terdepan dari angka yang diterima dijumlahkan dengan <i>D800</i> (awal kisaran pasangan pengganti dalam Unicode) </li><li>  10 bit berikutnya dijumlahkan dengan <i>DC00</i> (juga angka dari kisaran pasangan pengganti) </li><li>  setelah itu kita mendapatkan 2 pasang pengganti masing-masing 16 bit, 6 bit pertama dalam setiap pasangan bertanggung jawab untuk menentukan bahwa itu adalah pengganti, </li><li>  bit kesepuluh di setiap pengganti bertanggung jawab atas pesanannya; jika itu adalah 1, maka ini adalah pengganti pertama, jika 0, maka yang kedua </li></ol><br>  Kami akan menganalisis ini dalam praktiknya, saya pikir itu akan menjadi lebih jelas. <br><br>  Misalnya, kami mengenkripsi simbol, dan mendekripsi.  Ambil nomor Persia kuno seratus (U + 103D5): <br><br><ol><li>  <i>103D5</i> - <i>10.000</i> = <i>3D5</i> </li><li>  <i>3D5</i> = <b><code>0000000000 1111010101</code></b> (10 bit terkemuka ternyata menjadi nol, kami membawa ini ke angka heksadesimal, kami mendapatkan 0 (sepuluh pertama), <i>3D5</i> (sepuluh kedua)) </li><li>  <i>0</i> + <i>D800</i> = <i>D800</i> ( <b><code><font color="#cc0000">110110</font> <font color="#008000">0</font> 000000000</code></b> ) 6 bit pertama menentukan bahwa angka dari kisaran pasangan memasangkan bit kesepuluh (di sebelah kanan) adalah nol, maka ini adalah pengganti pertama </li><li>  <i>3D5</i> + <i>DC00</i> = <i>DFD5</i> ( <b><code><font color="#cc0000">110111</font> <font color="#008000">1</font> 111010101</code></b> ) 6 bit pertama menentukan bahwa angka dalam kisaran pasangan pengganti adalah bit kesepuluh (di sebelah kanan) adalah satu, maka ini adalah pengganti kedua </li><li>  Total karakter ini di UTF-16 adalah <b><code>1101100000000000 1101111111010101</code></b> </li></ol><br>  Sekarang decode sebaliknya.  Katakanlah kita memiliki kode seperti itu - 1101100000100010 1101111010001000: <br><br><ol><li>  diterjemahkan ke dalam bentuk heksadesimal = <i>D822</i> <i>DE88</i> (kedua nilai berasal dari kisaran pasangan pengganti, jadi kita miliki sebelum pasangan berpasangan) </li><li>  <b><code><font color="#cc0000">110110</font> <font color="#008000">0</font> 000100010</code></b> - bit kesepuluh (di sebelah kanan) adalah nol, kemudian pengganti pertama </li><li>  <b><code><font color="#cc0000">110111</font> <font color="#008000">1</font> 010001000</code></b> - bit kesepuluh (di sebelah kanan) adalah satu, kemudian pengganti kedua </li><li>  kita membuang 6 bit dari mereka yang bertanggung jawab untuk menentukan pengganti, kita mendapatkan <b><code>0000100010 1010001000</code></b> ( <i>8A88</i> ) </li><li>  tambahkan <i>10.000</i> (rentang pengganti lebih sedikit) <i>8A88</i> + <i>10000</i> = <i>18A88</i> </li><li>  lihat di tabel unicode karakter U + 18A88 = Tangut Component-649.  Komponen skrip Tangut. </li></ol><br>  Terima kasih kepada mereka yang mampu membaca sampai akhir, saya harap ini bermanfaat dan tidak terlalu membosankan. <br><br>  Berikut ini beberapa tautan menarik tentang topik ini: <br>  <a href="https://habr.com/ru/post/158895/">habr.com/en/post/158895</a> - informasi umum yang berguna tentang penyandian <br>  <a href="https://habr.com/ru/post/312642/">habr.com/en/post/312642</a> - tentang Unicode <br>  <a href="https://unicode-table.com/ru/" rel="nofollow">unicode-table.com/ru</a> - tabel karakter Unicode itu sendiri <br><br>  Sebenarnya di mana Anda akan tanpanya <br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25AE%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25B4" rel="nofollow">en.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4</a> - Unicode <br>  <a href="https://ru.wikipedia.org/wiki/ASCII" rel="nofollow">en.wikipedia.org/wiki/ASCII</a> - ASCII <br>  <a href="https://ru.wikipedia.org/wiki/UTF-8" rel="nofollow">en.wikipedia.org/wiki/UTF-8</a> - UTF-8 <br>  <a href="https://ru.wikipedia.org/wiki/UTF-16" rel="nofollow">en.wikipedia.org/wiki/UTF-16</a> - UTF-16 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478636/">https://habr.com/ru/post/id478636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478622/index.html">Pengujian A / B, saluran pipa dan ritel: kuartal bermerek untuk Big Data dari GeekBrains dan X5 Retail Group</a></li>
<li><a href="../id478626/index.html">Penerapan debug perangkat lunak dengan strace</a></li>
<li><a href="../id478628/index.html">CRI tinggi dalam bahasa Cina</a></li>
<li><a href="../id478630/index.html">Pascal memainkan Go. Implementasi metode dan antarmuka dalam kompiler amatir</a></li>
<li><a href="../id478634/index.html">Perangkap dalam Manajemen Proyek Pembelajaran Mesin</a></li>
<li><a href="../id478638/index.html">db-tree: cari dan navigasikan basis data</a></li>
<li><a href="../id478640/index.html">Mobil otonom pada sumber terbuka</a></li>
<li><a href="../id478642/index.html">MOXA Nport - Tampilan Dalam</a></li>
<li><a href="../id478646/index.html">JetQuad: Pesawat Jet dengan Lepas Landas dan Pendaratan Vertikal</a></li>
<li><a href="../id478650/index.html">Dawn 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>