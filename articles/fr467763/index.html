<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🤝‍👨🏼 🧘🏼 🐪 Toute la vérité sur RTOS. Article # 33. Utilisation du système d'exploitation en temps réel Nucleus SE 🤽🏾 👩🏻‍🔧 🥣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jusqu'à présent, dans cette série d'articles, nous avons examiné les fonctionnalités fournies par Nucleus SE. Il est maintenant temps de voir comment ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la vérité sur RTOS. Article # 33. Utilisation du système d'exploitation en temps réel Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467763/">  Jusqu'à présent, dans cette série d'articles, nous avons examiné les fonctionnalités fournies par Nucleus SE.  Il est maintenant temps de voir comment il peut être utilisé dans une véritable application de firmware. <br><br><img src="https://habrastorage.org/webt/8y/ch/3t/8ych3tyabi2vdvohugo65t3uekk.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Articles précédents de la série:</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 32.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Migration de Nucleus SE: fonctionnalités et compatibilité non réalisées</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 31.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Diagnostics et vérification des erreurs RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 30.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Procédures d'initialisation et de démarrage de Nucleus SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 29.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interruptions dans Nucleus SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Minuteries logicielles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Heure système</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Canaux: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Canaux de données: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boîtes aux lettres: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boîtes aux lettres: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sémaphores: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sémaphores: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes d'indicateurs d'événements: services d'assistance et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes de drapeaux d'événements: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signaux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partitions de mémoire: services et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sections de mémoire: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structures de données de tâche et appels d'API non pris en charge</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Services pour travailler avec des tâches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches: configuration et introduction à l'API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: fonctionnalités avancées et préservation du contexte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: implémentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: conception interne et déploiement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: Introduction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autres services RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des tâches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps réel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <br></div></div><br><h2>  Qu'est-ce que Nucleus SE? </h2><br>  Nous savons que Nucleus SE est le cœur d'un système d'exploitation en temps réel, mais vous devez comprendre comment il s'intègre dans le reste de l'application.  Et cela convient, car contrairement à un système d'exploitation de bureau (par exemple, Windows), l'application ne démarre pas sur Nucleus SE;  le noyau fait simplement partie d'un programme exécuté sur un périphérique intégré.  Il s'agit du cas d'utilisation le plus courant pour RTOS. <br><br>  D'un point de vue de haut niveau, une application intégrée est une sorte de code qui démarre au démarrage du CPU.  Dans ce cas, l'environnement matériel et logiciel est initialisé, puis la fonction <b>main ()</b> est appelée, ce qui lance le code d'application principal. <br><br>  Lors de l'utilisation de Nucleus SE (et de nombreux autres noyaux similaires), la différence est que la fonction <b>main ()</b> fait partie du code du noyau.  Cette fonction initialise simplement les structures de données du noyau, puis appelle l'ordonnanceur, ce qui conduit au lancement du code d'application (tâches).  L'utilisateur peut ajouter n'importe quel code d'initialisation natif à la fonction <b>main ()</b> . <br><br>  Nucleus SE comprend également un ensemble de fonctions - une interface de programmation d'application (API) qui fournit un ensemble de fonctions telles que la communication et la synchronisation des tâches, le travail avec des minuteries, l'allocation de mémoire, etc.  Toutes les fonctions API ont été décrites plus haut dans les articles de cette série. <br><br>  Tous les logiciels Nucleus SE sont fournis en tant que code source (principalement en C).  Pour configurer le code conformément aux exigences d'une application particulière, une compilation conditionnelle est utilisée.  Ceci est décrit en détail dans cet article dans la section Configuration. <br><br>  Une fois le code compilé, les modules d'objet Nucleus SE résultants sont associés aux modules de code d'application, résultant en une seule image binaire, qui est généralement placée dans la mémoire flash du périphérique intégré.  Le résultat de cette liaison statique est que toutes les informations symboliques restent disponibles à la fois dans le code d'application et dans le code du noyau.  Ceci est utile pour le débogage, mais il faut être prudent pour éviter une mauvaise utilisation des données Nucleus SE. <br><br><h2>  Prise en charge du processeur et des outils </h2><br>  Étant donné que Nucleus SE est fourni en tant que code source, il doit être portable.  Cependant, le code s'exécutant à un niveau aussi bas (lors de l'utilisation de planificateurs où un changement de contexte est requis, c'est-à-dire autre chose que Run to Completion), ne peut pas être complètement indépendant du langage d'assembly.  J'ai minimisé cette dépendance, et pour le portage vers une nouvelle programmation de bas niveau CPU n'est presque pas nécessaire.  L'utilisation d'un nouvel ensemble d'outils de développement (compilateur, assembleur, éditeur de liens, etc.) peut également entraîner des problèmes de portage. <br><br><h2>  Configuration de l'application Nucleus SE </h2><br>  La clé d'une utilisation efficace de Nucleus SE est une configuration correcte.  Cela peut sembler compliqué, mais en fait, tout est assez logique et ne nécessite qu'une approche systématique.  Presque toute la configuration se fait en éditant deux fichiers: <b>nuse_config.h</b> et <b>nuse_config.c</b> . <br><br><h3>  Paramètre Nuse_config.h </h3><br>  Ce fichier n'est qu'un jeu de caractères de la directive <b>#define</b> , auquel sont affectées les valeurs appropriées pour obtenir la configuration de noyau nécessaire.  Dans le fichier <b>nuse_config.h,</b> par défaut, tous les caractères sont présents, mais les paramètres minimaux leur sont attribués. <br><br>  <b><i>Compteurs d'objets</i></b> <br>  Le nombre d'objets noyau de chaque type est défini par des valeurs de symboles de la forme <b>NUSE_SEMAPHORE_NUMBER</b> .  Pour la plupart des objets, cette valeur peut varier de 0 à 15. Les tâches sont une exception, il doit y en avoir au moins une.  Les signaux, en fait, ne sont pas des objets indépendants, car ils sont associés à des tâches et sont <b>activés</b> en <b>définissant NUSE_SIGNAL_SUPPOR</b> T sur <b>TRUE</b> . <br><br>  <b><i>Activateurs de fonctions API</i></b> <br>  Chaque fonction d'API Nucleus SE peut être activée séparément en affectant un symbole dont le nom correspond au nom de la fonction (par exemple, <b>NUSE_PIPE_JAM</b> ) à <b>TRUE</b> .  Cela conduit à l'inclusion du code de fonction dans l'application. <br><br>  <b><i>Sélection et paramètres du planificateur</i></b> <br>  Nucleus SE prend en charge quatre types de planificateurs, comme décrit dans un article précédent.  Le planificateur utilisé est défini en affectant <b>NUSE_SCHEDULER_TYPE à l'</b> une des valeurs suivantes: <b>NUSE_RUN_TO_COMPLETION_SCHEDULER</b> , <b>NUSE_TIME_SLICE_SCHEDULER</b> , <b>NUSE_ROUND_ROBIN_SCHEDULER</b> ou <b>NUSE_PRIORITY_SCHEDULER</b> . <br><br>  Vous pouvez configurer d'autres paramètres du planificateur: <br>  <b>NUSE_TIME_SLICE_TICKS</b> indique le nombre de ticks par slot pour le planificateur de tranche de temps.  Si un autre ordonnanceur est utilisé, ce paramètre doit être défini sur 0. <br>  <b>NUSE_SCHEDULE_COUNT_SUPPORT</b> peut être défini sur <b>TRUE</b> ou <b>FALSE</b> pour activer / désactiver le mécanisme de compteur du planificateur. <br>  <b>NUSE_SUSPEND_ENABLE</b> active le verrouillage des tâches (suspension) pour de nombreuses fonctions API.  Cela signifie qu'un appel à une telle fonction peut entraîner une suspension de la tâche appelante jusqu'à ce que la ressource soit libérée.  Pour sélectionner cette option, <b>NUSE_SUSPEND_ENABLE doit</b> également être défini sur <b>TRUE</b> . <br><br>  <b><i>Autres options</i></b> <br>  Plusieurs autres paramètres peuvent également être affectés de valeurs <b>VRAI</b> ou <b>FAUX</b> pour activer / désactiver d'autres fonctions du noyau: <br>  <b>NUSE_API_PARAMETER_CHECKING</b> ajoute un code de vérification de paramètre d'appel d'appel de fonction API.  Couramment utilisé pour le débogage. <br>  <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> définit l'état initial de toutes les tâches comme <b>NUSE_READY</b> ou <b>NUSE_PURE_SUSPEND</b> .  Si ce paramètre est désactivé, toutes les tâches auront l'état initial <b>NUSE_READY</b> . <br>  <b>NUSE_SYSTEM_TIME_SUPPORT</b> - prise en charge de l'heure système. <br>  <b>NUSE_INCLUDE_EVERYTHING</b> - un paramètre qui ajoute le nombre maximal de fonctions à la configuration de Nucleus SE.  Il conduit à l'activation de toutes les fonctionnalités optionnelles et de chaque fonction API des objets configurés.  Utilisé pour créer rapidement une configuration Nucleus SE pour vérifier un nouveau portage du code du noyau. <br><br><h3>  Définition de nuse_config.c </h3><br>  Après avoir spécifié la configuration du noyau dans <b>nuse_config.h,</b> il est nécessaire d'initialiser les différentes structures de données stockées dans la ROM.  Cela se fait dans le fichier <b>nuse_config.c</b> .  La définition des structures de données est contrôlée par une compilation conditionnelle, donc toutes les structures sont contenues dans une copie du fichier <b>nuse_config.c</b> par défaut. <br><br>  <b><i>Données de tâche</i></b> <br>  Le <b>tableau NUSE_Task_Start_Address []</b> doit être initialisé avec la valeur des adresses de départ de chaque tâche.  Il s'agit généralement d'une liste de noms de fonction, sans parenthèses.  Les prototypes des fonctions de saisie des tâches doivent également être visibles.  Dans le fichier par défaut, la tâche est configurée avec le nom <b>NUSE_Idle_Task ()</b> , cela peut être changé en tâche d'application. <br><br>  Si vous utilisez n'importe quel planificateur sauf Run to Completion, chaque tâche nécessite sa propre pile.  Pour chaque pile de tâches, vous devez créer un tableau en RAM.  Ces tableaux doivent être de type <b>ADDR</b> et l'adresse de chacun d'eux doit être stockée dans <b>NUSE_Task_Stack_Base []</b> .  Il est difficile de prédire la taille du tableau, il est donc préférable d'utiliser des mesures (voir la section «Débogage» plus loin dans cet article).  La taille de chaque tableau (c'est-à-dire le nombre de mots sur la pile) doit être stockée dans <b>NUSE_Task_Stack_Size []</b> . <br><br>  Si une fonction a été activée pour indiquer l'état initial de la tâche (à l'aide du paramètre <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> ), le <b>tableau NUSE_Task_Initial_State []</b> doit être initialisé avec l'état <b>NUSE_READY ou NUSE_PURE_SUSPEND</b> . <br><br>  <b><i>Données du pool de partitions</i></b> <br>  Si au moins un pool de partitions est configuré, une baie (de type <b>U8</b> ) doit être créée pour chacun d'eux dans la ROM.  La taille de ces tableaux est calculée comme suit: (nombre de partitions * (taille de partition + 1)).  Les adresses de ces sections (c'est-à-dire leurs noms) doivent être affectées aux éléments <b>NUSE_Partition_Pool_Data_Address []</b> correspondants.  Pour chaque pool, le nombre de partitions et leur taille doivent être placés respectivement dans <b>NUSE_Partition_Pool_Partition_Number []</b> et <b>NUSE_Partition_Message_Size []</b> . <br><br>  <b><i>Données de file d'attente</i></b> <br>  Si au moins une file d'attente est configurée, un tableau (de type <b>ADDR</b> ) doit être créé pour chacun d'eux dans la RAM.  La taille de ces tableaux est le nombre d'éléments dans chaque file d'attente.  Les adresses de ces tableaux (c'est-à-dire leurs noms) doivent être affectées aux éléments <b>NUSE_Queue_Data []</b> correspondants.  La taille de chaque file d'attente doit être affectée à l'élément <b>NUSE_Queue_Size []</b> correspondant. <br><br>  <b><i>Données de liaison de données</i></b> <br>  Si au moins un canal de données est configuré, un tableau (de type <b>U8</b> ) doit être créé en RAM pour celui-ci (ou pour chacun d'eux).  La taille de ces tableaux est calculée comme suit: (taille du canal * taille du message dans le canal).  Les adresses de ces tableaux (c'est-à-dire leurs noms) doivent être attribuées aux éléments <b>NUSE_Pipe_Data []</b> correspondants.  Pour chaque canal, sa taille et sa taille de message doivent être attribuées aux éléments <b>NUSE_Pipe_Size []</b> et <b>NUSE_Pipe_Message_Size [] correspondants</b> , respectivement. <br><br>  <b><i>Données de sémaphore</i></b> <br>  Si au moins un sémaphore est configuré, le <b>tableau NUSE_Semaphore_Initial_Value []</b> doit être initialisé avec les valeurs initiales du compte à rebours. <br><br>  <b><i>Données du minuteur d'application</i></b> <br>  Si au moins un temporisateur est configuré, le <b>tableau NUSE_Timer_Initial_Time []</b> doit être initialisé avec les valeurs initiales des compteurs.  De plus, <b>NUSE_Timer_Reschedule_Time []</b> doit recevoir des valeurs de redémarrage.  Ces valeurs de minuterie seront utilisées après la fin du premier cycle de minuterie.  Si les valeurs de redémarrage sont définies sur 0, le compteur s'arrête après un cycle. <br><br>  Si la prise en charge des mécanismes d'achèvement de compte est configurée (en définissant le paramètre <b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b> sur <b>TRUE</b> ), deux autres tableaux doivent être créés.  Les adresses des mécanismes de complétion (juste une liste de noms de fonction, sans parenthèses) doivent être placées dans <b>NUSE_Timer_Expiration_Routine_Address []</b> .  Le tableau <b>NUSE_Timer_Expiration_Routine_Parameter []</b> doit être initialisé avec les valeurs des paramètres d'achèvement. <br><br><h2>  Quelle API? </h2><br>  Tous les systèmes d'exploitation sous une forme ou une autre ont une API (interface de programmation d'application).  Nucleus SE ne fait pas exception, et les fonctions qui composent l'API ont été décrites en détail dans cette série d'articles. <br><br>  Il peut sembler évident que lors de l'écriture d'une application à l'aide de Nucleus SE, vous devez utiliser l'API comme décrit dans les articles précédents.  Mais ce n'est pas toujours le cas. <br><br>  Pour la plupart des utilisateurs, l'API Nucleus SE sera quelque chose de nouveau, peut-être même leur première expérience d'utilisation de l'API du système d'exploitation.  Et comme il est assez simple, il peut servir de bonne introduction au sujet.  Dans ce cas, la procédure est claire. <br><br>  Pour certains utilisateurs, une autre API peut être une option plus attrayante.  Il y a trois situations évidentes où cela est possible. <br><ol><li>  Nucleus SE n'est qu'une partie d'un système qui utilise d'autres systèmes d'exploitation pour d'autres composants.  Par conséquent, la portabilité du code et, plus important encore, l'expérience de l'utilisation de divers systèmes d'exploitation semblent très tentantes. </li><li>  L'utilisateur possède une vaste expérience de l'utilisation de l'API d'un autre système d'exploitation.  L'utilisation de cette expérience est également très recommandée. </li><li>  L'utilisateur souhaite réutiliser du code écrit pour l'API d'un autre système d'exploitation.  La modification des appels API est possible, mais prend du temps. </li></ol><br><br>  Étant donné que le code source complet de Nucleus SE est disponible pour tout le monde, rien ne vous empêche de modifier chaque fonction API afin qu'elle ressemble à son équivalent d'un autre système d'exploitation.  Cependant, cela prendra beaucoup de temps et sera très improductif.  Une approche plus correcte serait d'écrire un «wrapper».  Il existe plusieurs façons de procéder, mais la plus simple consiste à créer un fichier d'en-tête ( <b>#include</b> ) contenant un ensemble de macros <b>#define</b> qui mapperont les fonctions d'API tierces aux fonctions d'API Nucleus SE. <br><br>  Un wrapper qui transfère (partiellement) les fonctions de l'API RTOS Nucleus à Nucleus SE est distribué avec Nucleus SE.  Il peut être utile aux développeurs ayant une expérience de l'utilisation de Nucleus RTOS, ou où à l'avenir il sera possible de passer à ce RTOS.  Ce wrapper peut également servir d'exemple lors du développement de choses similaires. <br><br><h2>  Débogage des applications Nucleus SE </h2><br>  L'écriture d'une application embarquée à l'aide d'un noyau multitâche est une tâche complexe.  S'assurer que le code fonctionne et détecter les erreurs peut être une tâche intimidante.  Malgré le fait qu'il ne s'agit que de code qui s'exécute sur un processeur, l'exécution simultanée de plusieurs tâches rend assez difficile de se concentrer sur un thread d'exécution spécifique.  Cela est encore plus compliqué lorsque plusieurs tâches partagent un code commun.  Pire encore, lorsque deux tâches ont exactement le même code (mais fonctionnent avec des données différentes).  La complication des structures de données utilisées pour implémenter les objets du noyau afin de voir des informations significatives est également compliquée. <br><br>  Pour déboguer des applications construites à l'aide de Nucleus SE, aucune bibliothèque ou autre service supplémentaire n'est requis.  Tout le code du noyau est lisible par le débogueur.  Par conséquent, toutes les informations symboliques sont disponibles pour étude.  Lorsque vous travaillez avec des applications Nucleus SE, tout outil de débogage moderne peut être utilisé. <br><br><h3>  Utiliser un débogueur </h3><br>  Les outils de débogage conçus spécifiquement pour les systèmes embarqués sont devenus très puissants au cours des 30 dernières années.  La principale caractéristique d'une application embarquée, par rapport à un programme de bureau, est que tous les systèmes embarqués sont différents (et tous les ordinateurs personnels sont assez similaires les uns aux autres).  Un bon débogueur intégré doit être flexible et avoir suffisamment de paramètres pour correspondre à la variété de systèmes intégrés et aux besoins des utilisateurs.  La personnalisation du débogueur s'exprime sous diverses formes, mais il existe généralement la possibilité de créer des scripts.  C'est cette fonctionnalité qui permet au débogueur de bien fonctionner avec une application au niveau du noyau.  Ci-dessous, je vais discuter de quelques cas d'utilisation du débogueur. <br><br>  Il convient de noter qu'en général, un débogueur est une famille d'outils, pas seulement un programme.  Le débogueur peut avoir différents modes de fonctionnement, grâce auxquels il aide lors du développement de code sur un système virtuel ou sur du matériel réel. <br><br><h3>  Points d'arrêt sensibles aux tâches </h3><br>  Si le programme a un code commun à plusieurs tâches, l'utilisation de points d'arrêt conventionnels lors du débogage est compliquée.  Il est fort probable que le code ne s'arrête que lorsqu'un point d'arrêt est atteint dans le contexte d'une tâche spécifique que vous déboguez actuellement.  Pour ce faire, vous avez besoin d'un point d'arrêt qui tiendra compte de la tâche. <br><br>  Heureusement, la possibilité de créer des scripts sur des débogueurs modernes et la disponibilité des données de caractères Nucleus SE rendent l'implémentation de points d'arrêt spécifiques à une tâche assez simple.  Il suffit d'écrire un script simple qui sera associé à un point d'arrêt que vous souhaitez enseigner pour distinguer les tâches.  Ce script prendra le paramètre: index (ID) de la tâche qui vous intéresse.  Le script compare simplement cette valeur avec l'index de la tâche en cours ( <i>NUSE_Task_Active</i> ).  Si les valeurs correspondent, le programme s'arrête.  S'ils sont différents, l'exécution continue.  Il est à noter que l'exécution de ce script affectera l'exécution de l'application en temps réel ( <i>note du traducteur: cela signifie que l'exécution du programme ralentira son fonctionnement normal</i> ).  Cependant, si le script n'est pas dans une boucle qui sera exécutée très souvent, cet effet sera minime. <br><br><h3>  Informations sur les objets du noyau </h3><br>  Le besoin évident de déboguer l'application Nucleus SE est la possibilité d'obtenir des informations sur les objets du noyau: quelles sont leurs caractéristiques et quel est leur statut actuel.  Cela vous permet d'obtenir des réponses à des questions telles que: "Quelle est la taille de cette file d'attente et combien de messages y figurent maintenant?" <br><br>  Cela peut être utilisé en ajoutant du code de débogage supplémentaire à votre application, qui utilisera les appels d'API "informatifs" (tels que <b>NUSE_Queue_Information</b> ).  Bien sûr, cela signifie que votre application contient maintenant du code supplémentaire, qui ne sera plus nécessaire après la mise en œuvre de l'application.  L'utilisation de <b>#define</b> pour activer et désactiver ce code à l'aide de la compilation conditionnelle serait une décision logique. <br><br>  Certains débogueurs peuvent effectuer un appel de fonction ciblé, c'est-à-dire appeler directement une fonction API pour récupérer des informations.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela élimine le besoin de code supplémentaire, mais cette fonction API doit être configurée pour que le débogueur puisse l'utiliser. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une approche alternative, plus flexible, mais moins «non vieillissante» est l'accès direct aux structures de données des objets du noyau. </font><font style="vertical-align: inherit;">Très probablement, il est préférable de le faire en utilisant des scripts de débogage. </font><font style="vertical-align: inherit;">Dans notre exemple, la taille de la file d'attente peut être obtenue à partir de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Size []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et son utilisation actuelle à partir de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Data []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De plus, les messages dans la file d'attente peuvent être affichés en utilisant l'adresse de la zone de données de la file d'attente (à partir de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Data []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Valeurs de retour d'appel API </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De nombreuses fonctions API renvoient une valeur d'état indiquant le succès de l'appel. Il serait utile de garder une trace de ces valeurs et de marquer les cas dans lesquels elles ne sont pas égales à </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_SUCCESS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (c'est-à-dire qu'elles ont une valeur de zéro). Étant donné que ce suivi est uniquement destiné au débogage, la compilation conditionnelle est tout à fait appropriée. La définition d'une variable globale (par exemple, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) peut être compilée conditionnellement (sous le contrôle du symbole de directive #define). Ensuite, une partie de la définition des appels d'API, à savoir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status =</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , peut également être compilée conditionnellement. Par exemple, à des fins de débogage, un appel qui ressemble généralement à ceci: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Mailbox_Send (mbox, msg, NUSE_SUSPSEND);</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prendra la forme suivante:</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status = NUSE_Mailbox_Send (mbox, msg, NUSE_SUSPEND); </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le verrouillage des tâches est activé, de nombreux appels de fonction API peuvent uniquement renvoyer des informations sur la réussite d'un appel ou sur la réinitialisation de l'objet. </font><font style="vertical-align: inherit;">Cependant, si la vérification des paramètres d'API est activée, les appels d'API pourront renvoyer de nombreuses autres valeurs.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Définition de la taille de la pile de tâches et du débordement de pile </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le sujet de la protection contre le débordement de pile a été abordé dans un article précédent (# 31). Il existe plusieurs autres possibilités lors du débogage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La zone mémoire de la pile peut être remplie d'une valeur caractéristique: autre chose que tous les uns ou tous les zéros. Après cela, le débogueur peut être utilisé pour surveiller les zones de mémoire et combien les valeurs seront modifiées, ce qui permettra de comprendre le degré de saturation de la pile. Si toutes les zones de mémoire ont été modifiées, cela ne signifie pas que la pile était pleine, mais cela peut signifier que sa taille est à peine suffisante, ce qui est dangereux. Elle devrait être augmentée et les tests poursuivis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme décrit dans l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article # 31</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lors de la mise en œuvre des diagnostics, des zones supplémentaires, des «mots de protection», peuvent être situées sur l'un des bords de la zone de mémoire de la pile. </font><font style="vertical-align: inherit;">Le débogueur peut être utilisé pour suivre l'accès à ces mots, car toute tentative de les écrire signifie un débordement ou un épuisement de la pile.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Liste de contrôle de configuration de Nucleus SE </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que Nucleus SE a été conçu comme un système hautement flexible et personnalisable pour répondre aux exigences des applications, il nécessite un nombre important de paramètres personnalisables. </font><font style="vertical-align: inherit;">C'est pourquoi l'intégralité de cet article est en fait consacrée à la configuration de Nucleus SE. </font><font style="vertical-align: inherit;">Pour vous assurer de ne rien manquer, voici une liste de contrôle de toutes les étapes clés que vous devez suivre pour créer l'application intégrée Nucleus SE.</font></font><br><ol><li> <b> Nucleus SE.</b>   ,     Nucleus SE       ,        Nucleus SE     . </li><li> <b>  CPU/.</b>             . </li><li> <b>  .</b>     ,       ,    . </li><li> <b>  .</b>        .       .  ,     .      16 . </li><li> <b> .</b>     -   <b>main()</b> ? </li><li> <b> .</b>     4 ,       . </li><li> <b>   </b> ,     . </li><li> <b>    .</b> </li><li> <b>.</b>   ,     . </li><li> <b> .</b>    ,    . </li><li> <b>  .</b> ,      .     .  —  16   . </li><li> <b>  .</b>        ,   . </li><li> <b>  .</b>        ,    (,      ). </li><li> <b> API.</b>    API,   . </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le prochain article (le dernier de cette série) résumera toute l'histoire avec Nucleus SE et fournira également des informations pour vous aider à créer et à utiliser des implémentations Nucleus SE. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À propos de l'auteur:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colin Walls travaille dans l'industrie électronique depuis plus de trente ans, consacrant la majeure partie de son temps au micrologiciel. </font><font style="vertical-align: inherit;">Il est maintenant ingénieur firmware chez Mentor Embedded (une division de Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls intervient souvent lors de conférences et séminaires, auteur de nombreux articles techniques et de deux livres sur le firmware. </font><font style="vertical-align: inherit;">Vit au Royaume-Uni. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> professionnel </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">de Colin</font></a><font style="vertical-align: inherit;"> , e-mail: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467763/">https://habr.com/ru/post/fr467763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467751/index.html">Comment fonctionne un messager décentralisé sur la blockchain</a></li>
<li><a href="../fr467753/index.html">Record du monde pour la transmission de données sans fil: 40 Gb / s par 11 kilomètres</a></li>
<li><a href="../fr467755/index.html">Prions, calcium, microbiote, hormones alimentaires et Alzheimer</a></li>
<li><a href="../fr467759/index.html">Conception de système d'exploitation de type Unix - Espace d'adressage virtuel (6)</a></li>
<li><a href="../fr467761/index.html">Énergie, chaleur et eau, troisième partie: allez à la radio</a></li>
<li><a href="../fr467765/index.html">Wi-Fi et de nombreuses autres abréviations. Comment obtenir des données sur des nœuds Wi-Fi dans une application Android et ne pas gonfler</a></li>
<li><a href="../fr467767/index.html">Plus d'équipements pour les abonnés JSON-RPC</a></li>
<li><a href="../fr467771/index.html">Comme un auto-rechargeur vert junior a écrit son <s> hot </s>. Partie 2. CSS</a></li>
<li><a href="../fr467775/index.html">5 mythes sur les affaires: pourquoi le client a tort et comment dépasser Apple</a></li>
<li><a href="../fr467779/index.html">À propos de Godot, GLSL et WebGL, shaders utilisés dans le mini-jeu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>