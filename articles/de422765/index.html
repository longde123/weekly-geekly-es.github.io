<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèΩ ‚úãüèª üë©üèª‚Äçüî¨ OpenID Connect 1.0 On Fingers üóÉÔ∏è ‚öõÔ∏è üö∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OpenID Connect hat eine Spezifikation , es gibt Tutorials, Artikel auf dem Hub und nicht auf dem Hub Es ist ziemlich sinnlos, eine weitere Schritt-f√ºr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenID Connect 1.0 On Fingers</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422765/"><p>  <strong>OpenID Connect</strong> hat eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> , es gibt Tutorials, Artikel auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hub</a> und nicht auf dem Hub  Es ist ziemlich sinnlos, eine weitere Schritt-f√ºr-Schritt-Anleitung zu erstellen, die von tiefer Verwirrung bis zur Bearbeitung von Autorisierung und Authentifizierung f√ºhrt.  Die Aufgabe des folgenden Textes ist anders, die Ideen zu beschreiben, die den Spezifikationen zugrunde liegen (es gibt mehr als eine). </p><br><p>  Ich werde nicht sofort auf das Thema des Artikels eingehen, aber ich werde mit einfachen und vielen offensichtlichen Dingen beginnen.  Ich werde mit der Art und Weise fortfahren, wie sie sich entwickelt haben und was sie gem√§√ü den Anforderungen der Kunden verpackt haben.  Ich werde mich ihm historisch n√§hern, das hei√üt genau so, wie er geboren wurde. </p><br><p><img src="https://habrastorage.org/webt/bh/5i/br/bh5ibr5bu0wxmial0gdp6uxy_bg.png"></p><a name="habracut"></a><br><p>  1. </p><br><p>  Die Mindestaufgabe besteht einfach darin, niemanden auf seine Ressourcen zugreifen zu lassen.  Wir schlie√üen es mit Benutzername / Passwort. Wer wei√ü, dass das richtige Paar von Benutzernamen und Passw√∂rtern an die Ressource gelangt, wer nicht - nein.  Diese Funktion wird als <strong>Authentifizierung bezeichnet</strong> . Sie k√∂nnen nicht nur Anmeldungen mit Kennw√∂rtern (z. B. SMS-Code oder Hardware-USB-Stick) verwenden, sondern diese Details sind f√ºr unser Thema nicht unbedingt erforderlich.  Ich werde auch den obligatorischen Absatz √ºber die Gefahr der √úbertragung von Passw√∂rtern √ºber das Internet in offener Form weglassen, f√ºr den wir alle die Standardzugriffsauthentifizierung nicht m√∂gen. </p><br><p>  Besser zu beachten: Keiner der Benutzer gibt gerne Anmeldungen mit Passw√∂rtern ein.  Codes in SMS sind nicht besser und USB-Sticks werden einfach √ºberhaupt gehasst.  Um den Benutzer nicht zu zwingen, f√ºr jede Anforderung ein Login mit einem Kennwort einzugeben, sendet der Server als Antwort darauf eine Kauderwelschzeile, die als <strong>Sitzungsschl√ºssel bezeichnet wird</strong> .  Und dann klammert sich dieser Schl√ºssel an jede Serveranforderung des Clients (normalerweise mit einem HTTP-Header, aber dies ist nicht unbedingt erforderlich), und der Server pr√ºft, ob er eine solche Sitzung hat. </p><br><p>  <em>Sitzung mit einem Schl√ºssel - Ph√§nomene sind per Definition vor√ºbergehend, der goldene Schnitt f√ºr die Lebensdauer einer Sitzung betr√§gt ungef√§hr "w√§hrend die Browser-Registerkarte ge√∂ffnet ist, aber nicht l√§nger als einen Tag".</em> </p><br><p>  2. </p><br><p>  Sie lassen jeden rein - das ist gut.  Jetzt m√ºssen Sie genau verstehen, wen wir loslassen.  Und nicht nur, um abzuleiten, was er als Namen in der oberen rechten Ecke eingegeben hat, sondern auch um zu entscheiden, was er hereinlassen soll und was nicht. </p><br><p>  Und das alles nennt man - <strong>Autorisierung</strong> .  Und ich bin mir nicht sicher, aber ich verwechsle es die ganze Zeit mit der Authentifizierung.  Um nicht - eine relativ mnemonische Regel, "Autorisierung" - von den W√∂rtern "Autor", "Autor" zu verwechseln, schreiben sie auf die Titelseiten von B√ºchern und schreiben dort niemals "ein g√ºltiges Mitglied der Writers 'Union".  Ein Autor ist immer eine ganz bestimmte Person.  Die Autorisierung ist also ein Prozess, bei dem wir anhand von Login und Passwort verstehen, wen wir genau gestartet haben. </p><br><p>  3. </p><br><p>  Ok  Wir haben eine Site, es gibt etwas Geheimnisvolles auf der Site, am Eingang zum geheimen Teil ben√∂tigen wir ein Passwort, jedem werden nur seine Geheimnisse gezeigt und wir zeigen keine Fremden.  Das Leben steht nicht still und wir haben eine andere Seite.  Und hier sto√üen wir wieder auf das Problem ab Punkt 1, niemand gibt gerne Benutzernamen und Passw√∂rter ein!  Sie k√∂nnen die Benutzerbasis kombinieren, damit sie sich nicht zweimal registrieren m√ºssen. Wie k√∂nnen Sie sie jedoch vor der erneuten Eingabe des Logins und des Passworts am Eingang bewahren?  Angesichts der Existenz einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Richtlinie</a> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">denselben Ursprung</a> (und unsere Websites befinden sich nat√ºrlich in verschiedenen Dom√§nen, sind Cookies mit einem Sitzungsschl√ºssel f√ºr einander nicht sichtbar)?  Um dem Moment Bedeutung zu verleihen, werde ich hier einen neuen Punkt beginnen. </p><br><p>  4. </p><br><p><img src="https://habrastorage.org/webt/yg/4j/7l/yg4j7l4kjiavq0v3jictaduihw4.jpeg"></p><br><p>  <strong>SSO</strong> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Single Sign On</a> - unabh√§ngig von der Implementierung, Microsoft Kerberos, SAML oder etwas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OAuth 2.0</a> , auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenID Connect</a> basiert, wor√ºber ich Ihnen hier schreibe, gibt es unter der Haube immer das Gleiche: Es gibt einen separaten <strong>Server Autorisierung</strong> , und jeder, der einen Benutzer autorisieren m√∂chte, leitet den Benutzer dorthin weiter.  Wenn der Benutzer bereits autorisiert ist, wird die Sitzung abgeholt und er fliegt sofort vom Autorisierungsserver zur√ºck und gelangt dorthin, wo er wollte.  Wenn es nicht autorisiert ist, l√∂st der Autorisierungsserver dieses Problem so gut wie m√∂glich, indem er in der Regel eine Anmeldung mit einem Kennwort anfordert. Wenn die L√∂sung erfolgreich ist, sendet er den Benutzer zur√ºck. </p><br><p>  Dar√ºber hinaus ist SAML im Moment sozusagen die L√∂sung veraltet.  Und Kerberos ist im Allgemeinen eine v√∂llig separate geschlossene Microsoft-Magie, die weit √ºber den Rahmen des HTTP-Protokolls hinausgeht.  Nun, wir werden uns darauf konzentrieren.  Und dann kommen wir zum n√§chsten Problem. </p><br><br><p>  Es gibt bereits ein verst√§ndliches Arbeitsszenario: Senden Sie den Benutzer in einer unverst√§ndlichen Situation an den Autorisierungsserver, lassen Sie ihn entscheiden, was mit ihm geschehen soll, und geben Sie eine fertige Antwort zur√ºck.  Aber wie genau teilt der Autorisierungsserver diesem anderen Server mit, dass der Benutzer autorisiert ist?  Hier kehren wir noch einmal zu den Ideen des ersten Absatzes zur√ºck, n√§mlich zum Sitzungsschl√ºssel.  Kehren wir zu den Grundlagen zur√ºck: Das Vorhandensein eines Sitzungsschl√ºssels ist ein Zeichen der Autorisierung, der Sitzungsschl√ºssel selbst √∂ffnet die T√ºr zu Benutzerinformationen und, Sie werden es nicht glauben, zu Sitzungsinformationen.  Der Autorisierungsserver autorisiert den Sitzungsschl√ºssel und gibt ihn an einen anderen Server weiter. </p><br><p>  Jetzt wird es jedoch nicht mehr als Sitzungsschl√ºssel, sondern als <strong>Token bezeichnet</strong> . <br>  Genauer gesagt (gem√§√ü dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OAuth 2.0-</a> Protokoll, auf das OpenID Connect geschrieben ist) sind dies zwei Token gleichzeitig - <strong>Access Token</strong> , um es mit allen Anforderungen zu verkn√ºpfen, wenn Gro√üv√§ter Sitzungsschl√ºssel abgeschnitten haben, und <strong>Refresh Token</strong> , um Access Token zu aktualisieren, wenn es ausgeht. </p><br><p>  Um die Zwischensumme zusammenzufassen.  Anstatt den Benutzer nach einem Benutzernamen und einem Kennwort zu fragen, sendet der Server diese an einen anderen Server, einen separaten Autorisierungsserver.  Er erledigt die ganze Arbeit und gibt dann die ersten Token.  Genau in diesem Szenario sind Anwendungen autorisiert, mobil und manchmal auf dem Desktop. Sie leiten nur nicht weiter, senden einfach den JSON-Autorisierungsserver mit einem Benutzernamen und einem Kennwort und er sendet ihnen als Antwort Token. </p><br><p>  Mobile und Desktop-Anwendungen k√∂nnen dies tun.  Aus irgendeinem Grund gelten sie als sicherer als das Web, aber das Web hat ein komplizierteres Leben. </p><br><p>  6. </p><br><p>  Einerseits ist es nicht komplizierter, andererseits einfacher.  Sie k√∂nnen eine Weiterleitung vornehmen und m√ºssen sich nicht mit dem Rendern eines Login-Passwort-Formulars besch√§ftigen.  Andererseits m√∂chte ich wirklich, wirklich keine Token im Klartext durch den Browser ziehen.  Dies ist fast so ekelhaft wie das unverschl√ºsselte Kennwort bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardzugriffsauthentifizierung</a> .  Aber niemand will diesen alten schrecklichen Fehler wiederholen. </p><br><p>  Es gab keine L√∂sung f√ºr das Problem, so dass es sehr elegant ist, aber funktioniert.  Zun√§chst l√§uft alles wie gewohnt, wechselt zur Autorisierung, Autorisierung selbst.  Wenn es dann Zeit ist, mit Token zur√ºckzukehren, erfolgt die umgekehrte Umleitung.  Anstelle von Token wird jedoch ein einmaliger Code an die Absenderadresse angeh√§ngt.  Der einmalige Code wurde gerade nur f√ºr diesen bestimmten Moment vom Autorisierungsserver generiert.  Er hat eine sehr kurze Lebenszeit.  Nachdem ein anderer Server kaum einen einmaligen Code erhalten hat, sollte er die R√∂cke hochklappen, die Augen ausbeulen und erneut zum Autorisierungsserver eilen, um die gew√ºnschten Token aus dem einmaligen Code zu erhalten. </p><br><p>  Auf dem Autorisierungsserver gibt es eine spezielle Ressource f√ºr eine Reise mit einem Code f√ºr Token.  Es akzeptiert laut Spezifikation nicht GET, sondern POST.  Das deutet irgendwie darauf hin, dass diese Anfrage nicht vom Browser, sondern von Server zu Server gestellt werden sollte. </p><br><p>  <em>Aus dem gleichen Grund sind POST-Anforderungen auf jedem CORS-Autorisierungsserver mit Selbstachtung verboten.</em> </p><br><p>  7. </p><br><p>  Erinnern Sie sich √ºbrigens noch an Authentifizierung und Autorisierung?  Authentifizierung ist, wenn jemand einfach per Login und Passwort eingeben darf oder nicht.  Und die Autorisierung ist, wenn sie bereits gestartet sind, beginnen sie zu verstehen, wer genau sie gestartet haben. </p><br><p>  Erinnerst du dich an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OAuth 2.0</a> ?  Ich habe es oben einige Male erw√§hnt, als eine Art Grundlage f√ºr OpenID Connect. </p><br><p>  Erinnerst du dich an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenID Connect</a> ?  Dieser Artikel ist nur er dumm. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OAuth 2.0</a> ist also Authentifizierung.  Bei der gesamten zuvor beschriebenen, etwas verwirrenden Prozedur mit drei Teilnehmern, einem Passwort, einem Code und einem Token geht es um die Authentifizierung, nur darum, jemanden irgendwo laufen zu lassen.  OAuth 2.0-Protokoll. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenID Connect</a> ist eine Autorisierung.  Das hei√üt, er f√ºgt OAuth jene Teile hinzu, in denen sich herausstellt, wen sie loslassen. </p><br><p>  Zu diesem Zweck wird der Liste der Token eine weitere hinzugef√ºgt, die als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ID-Token bezeichnet wird</a> .  Diejenigen, die dem Link folgen, sind wahrscheinlich √ºberrascht, nichts √ºber eine Token-ID darauf zu sehen.  Lassen Sie sich nicht √ºberraschen, <strong>ID Token</strong> ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JWT, das</a> als base64-codierte verschachtelte Puppe in demselben JSON wie Access Token und Refresh Token zur√ºckgegeben wird.  In jedem Fall ist alles, was Sie √ºber den Benutzer wissen wollten, in ihm. </p><br><p>  Au√üerdem gibt es auf dem Autorisierungsserver eine spezielle Ressource namens userinfo, in der Sie mit Access Token klopfen und als Antwort denselben JSON erhalten k√∂nnen wie in Token ID.  Aber warum wird es ben√∂tigt, wenn die Token-ID bereits vorhanden ist?  Frage an die Autoren der Spezifikation. </p><br><p>  OpenID Connect enth√§lt auch eine Beschreibung der verschiedenen Felder mit Benutzerinformationen.  Wie kann ich diese Informationen direkt w√§hrend der Autorisierung oder jederzeit danach erhalten?  Und eine Beschreibung, wie und wann der Benutzer Ihnen erlaubt, diese Informationen zu verwenden. <br>  Oder nicht zulassen.  Kurz gesagt, OpenID Connect 1.0 wurde entwickelt. </p><br><p>  8. </p><br><p>  Ein kleines Lametta im Protokoll.  Ich hoffe, dass Sie im Moment m√ºde genug sind, den Artikel zu lesen, um diesem Artikel nicht viel Aufmerksamkeit zu schenken, indem Sie ihn einfach durch die Augen laufen lassen.  Hier werde ich die Parameter erw√§hnen, die in der Spezifikation enthalten sind und eine gewisse semantische Last tragen, aber sie stehen nicht in direktem Zusammenhang mit der Umsetzung der Idee selbst.  Grunds√§tzlich erh√∂hen sie die Sicherheit, oder Sie k√∂nnen bei Bedarf einfach einige Informationen von einem der Teilnehmer des Prozesses auf einen anderen √ºbertragen. </p><br><p>  <strong>Kunden-ID und Kundengeheimnis</strong> .  Der Client in der Sprache des OpenID Connect-Protokolls ist √ºberhaupt kein Browser, sondern der ganz andere Server, der den Benutzer autorisieren muss.  Angenommen, Sie haben eine Website und m√∂chten dieser √ºber Facebook eine modische Autorisierung hinzuf√ºgen.  Und durch Googol.  Und nicht so modisch √ºber Twitter.  Die Implementierung des Protokolls im Code reicht nicht aus.  Sie m√ºssen sich auch auf Facebook, Google und Twitter registrieren, jedoch nicht als Benutzer, sondern als Kunde, der als Server seine Berechtigung verwenden kann.  Bei der Registrierung erhalten Sie eine Kunden-ID und ein Kundengeheimnis vom bedingten Facebook.  Wenn Sie unter anderem um Autorisierung bitten, senden Sie eine Client-ID.  Und wenn Sie einen einmaligen Code f√ºr ein Token verwenden, werden Sie von Client Secret ebenfalls ben√∂tigt. </p><br><p>  <strong>URI umleiten</strong> .  Hier ist alles einfach.  Wenn Sie einen Benutzer zur Anmeldung an ein bedingtes Facebook senden, m√ºssen Sie Facebook mitteilen, wo er nach der Autorisierung Codes und Token an ihn zur√ºcksenden soll.  Nat√ºrlich geben Sie ihm immer noch Ihre Kunden-ID.  Mit einem separaten Umleitungs-URI k√∂nnen Sie jedoch nach der Autorisierung verschiedene Benutzer auf verschiedene Seiten umleiten, z. B. Administratoren im Admin-Bereich und normale Benutzer auf ihre pers√∂nlichen Seiten.  Praktisch.  Dar√ºber hinaus ist die zul√§ssige Liste m√∂glicher Umleitungs-URIs, die in den Client-Einstellungen auf der bedingten Facebook-Seite angegeben sind, eine zus√§tzliche Sicherheit. </p><br><p>  <strong>Geltungsbereich</strong> .  Dies ist eine Liste dessen, was der Server vom Autorisierungsserver √ºber den Benutzer wissen m√∂chte.  Die Werte in der Liste sind durch Leerzeichen getrennt. Openid sollte unter ihnen obligatorisch sein, und dann lesen Sie die Spezifikation. </p><br><p>  <strong>Staat</strong> .  Erinnern Sie sich an den einmaligen Code, mit dem Token ausgegeben werden, wie ein Ticket in einer elektronischen Warteschlange?  Status ist also Code. Wenn der Autorisierungsserver einen Code an einen anderen Server ausgibt, damit er ihn bald zur√ºckgibt, gibt dieser Status diesem Server einen anderen Autorisierungsserver, der ihn bei der Umleitung zur√ºckgibt.  Er wird, wie ich es verstehe, ben√∂tigt, wenn es einem anderen Server bereits gelungen ist, eine eigene Sitzung zu erstellen, damit sie bei all diesen Weiterleitungen nicht verloren geht. </p><br><p>  Es gibt andere Parameter, wie die Art der Autorisierungsanforderung und die Token-Lebensdauer, aber um zu verstehen, warum Sie sie nicht ben√∂tigen. </p><br><br><p>  Abschlie√üend.  Ich hoffe wirklich, dass Ihnen das nicht zu nachdenkliche und gezielte Lesen des obigen Textes irgendwo geholfen hat, die Ideen zu verstehen, die einigen modernen Zugriffskontrollprotokollen zugrunde liegen.  Beginnen Sie jedoch mit der Implementierung oder konfigurieren Sie eines davon, √∂ffnen Sie die Spezifikationen, finden Sie ein gutes Tutorial und folgen Sie jedem Wort und jedem Buchstaben sorgf√§ltig.  Und lassen Sie das Verst√§ndnis von Ideen die Intuition in Ihnen wecken.  Und Intuition, lassen Sie sich jedes Mal von der Krone bei√üen, wenn Sie einen Parameter √ºbersehen, der auf den ersten Blick nicht so wichtig ist, oder eine Einstellung, und lassen Sie dies ein Loch f√ºr verschwitzte, verspielte kleine H√§nde. </p><br><p>  Denken Sie daran, dass dies alles die gleiche Sicherheit ist und dass die Regeln, egal wie dumm und bedeutungslos sie auch erscheinen m√∂gen, in Blut geschrieben sind.  Nun, vielleicht nicht mit Blut, es ist schlie√ülich keine Sicherheitsma√ünahme in der Gie√üerei, aber Geld und Ansehen sind sicher, und Geld und Ansehen sind auch nicht die Dinge, die man so leicht herumwerfen sollte. </p><br><p>  Vielen Dank an <strong>JM</strong> f√ºr die Tatsache, dass der Text, den Sie gelesen haben, viel besser war als der, den ich geschrieben habe. </p><br><p>  Viel Gl√ºck und vergessen Sie nicht, Ihre Zertifikate rechtzeitig zu erneuern. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422765/">https://habr.com/ru/post/de422765/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422755/index.html">Sch√ºtzt das Portfolio vor Krypto-Senkung?</a></li>
<li><a href="../de422757/index.html">Keine Politik. Wie kann man Stra√üenproteste mit einer mobilen Anwendung dauerhaft transformieren?</a></li>
<li><a href="../de422759/index.html">Interaktive Karte f√ºr eine Webanwendung in wenigen Stunden</a></li>
<li><a href="../de422761/index.html">Vier Wege von der Yandex Data Analysis School</a></li>
<li><a href="../de422763/index.html">Digitale Veranstaltungen in Moskau vom 10. bis 16. September</a></li>
<li><a href="../de422767/index.html">DEFCON-Konferenz 16. Fedor, InSecure.org Hacker. NMAP Scan Online</a></li>
<li><a href="../de422769/index.html">Gewinner des Startup Battlefield TechCrunch Disrupt San Francisco 2018</a></li>
<li><a href="../de422771/index.html">Die Regeln des Designs, das Erreichen einer neuen Ebene und das Designdenken</a></li>
<li><a href="../de422773/index.html">NVIDIA. Enth√ºllung der Geheimnisse der Turing-GPU-Architektur der n√§chsten Generation: Double Ray Tracing, GDDR6 und mehr</a></li>
<li><a href="../de422775/index.html">DEFCON-Konferenz 22. Andrew "Zoz" Brooks. Nicht vermasseln! Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>