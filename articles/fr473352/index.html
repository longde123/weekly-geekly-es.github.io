<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòµ üìÄ üöÑ Collections simultan√©es en 10 minutes ü•á üñêüèª ‚ò¢Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Photo de Robert V. Ruggiero 

 Le sujet n'est pas nouveau. Mais en posant la question ¬´que sont les collections simultan√©es et quand les utiliser?¬ª lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Collections simultan√©es en 10 minutes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473352/"><img src="https://habrastorage.org/webt/kb/ml/25/kbml25hqd_fuejwsjqee8tcczkc.jpeg" alt="image"><br>  <sup>Photo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Robert V. Ruggiero</a></sup> <br><br>  Le sujet n'est pas nouveau.  Mais en posant la question ¬´que sont les collections simultan√©es et quand les utiliser?¬ª  lors d'une interview ou d'une r√©vision de code, j'obtiens presque toujours une r√©ponse compos√©e d'une phrase: ¬´ils nous prot√®gent compl√®tement des conditions de course¬ª (ce qui est impossible m√™me en th√©orie).  Ou: ¬´c'est comme des collections ordinaires, mais tout √† l'int√©rieur est sur des serrures¬ª, ce qui ne correspond pas non plus tout √† fait √† la r√©alit√©. <br><br>  Le but de cet article est de faire ressortir le sujet en 10 minutes.  Il sera utile pour vous familiariser rapidement avec certaines subtilit√©s.  Ou pour vous rafra√Æchir la m√©moire avant l'entretien. <br><a name="habracut"></a><br>  Tout d'abord, nous allons jeter un coup d'≈ìil au contenu de l'espace de noms <i>System.Collections.Concurrent</i> .  Ensuite, nous discutons des principales diff√©rences entre les collections simultan√©es et classiques, notons quelques points non √©vidents.  En conclusion, nous discutons des pi√®ges possibles et des types de collections qui valent la peine d'√™tre utilis√©s. <br><br><h2>  Contenu de System.Collections.Concurrent </h2><br>  Intellisense vous en dit un peu: <br><br><img src="https://habrastorage.org/webt/sg/sz/ln/sgszlno_zqfuxizry5q5rll48m8.png" alt="image"><br><br>  Voyons bri√®vement le but de chaque classe. <br><br>  <b>ConcurrentDictionary</b> : collection polyvalente sans fil applicable √† un large √©ventail de sc√©narios. <br><br>  <b>ConcurrentBag, ConcurrentStack, ConcurrentQueue</b> : collections √† usage sp√©cial.  La ¬´sp√©cialit√©¬ª comprend les points suivants: <br><br><ul><li>  Manque d'API pour acc√©der √† un √©l√©ment arbitraire </li><li>  <i>La pile</i> et la <i>file d'attente</i> (comme nous le savons tous) ont un ordre donn√© d'ajout et d'extraction d'√©l√©ments </li><li>  <i>ConcurrentBag</i> pour chaque thread conserve sa propre collection pour ajouter des √©l√©ments.  Lors de la r√©cup√©ration, il ¬´vole¬ª les √©l√©ments d'un flux voisin si la collection est vide pour le flux actuel </li></ul><br>  <b>IProducerConsumerCollection</b> - contrat utilis√© par la classe <i>BlockingCollection</i> (voir ci-dessous).  Impl√©ment√© par les collections <i>ConcurrentStack</i> , <i>ConcurrentQueue</i> et <i>ConcurrentBag</i> . <br><br>  <b>BlockingCollection</b> - utilis√© dans les sc√©narios o√π certains flux remplissent une collection, tandis que d'autres en extraient des √©l√©ments.  Un exemple typique est une file d'attente de t√¢ches r√©approvisionn√©e.  Si la collection est vide au moment de la demande de l'√©l√©ment suivant, alors le lecteur passe √† l'√©tat d'attente du nouvel √©l√©ment (polling).  En appelant la m√©thode <i>CompleteAdding ()</i> , nous pouvons indiquer que la collection ne sera plus r√©approvisionn√©e, puis lors de la lecture, l'interrogation ne sera pas effectu√©e.  Vous pouvez v√©rifier l'√©tat de la collection √† l'aide des <i>propri√©t√©s IsAddingCompleted</i> ( <i>true</i> si les donn√©es ne seront plus ajout√©es) et <i>IsCompleted</i> ( <i>true</i> si les donn√©es ne seront plus ajout√©es et la collection est vide). <br><br>  <b>Partitioner, OrderablePartitioner, EnumerablePartitionerOptions</b> - constructions de base pour impl√©menter la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">segmentation des collections</a> .  Utilis√© par la m√©thode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parallel.ForEach</a> pour sp√©cifier comment r√©partir les √©l√©ments entre les threads de traitement. <br><br>  Plus loin dans l'article, nous nous concentrerons sur les collections: <i>ConcurrentDictionary</i> et <i>ConcurrentBag / Stack / Queue</i> . <br><br><h2>  Diff√©rences entre les collections simultan√©es et classiques </h2><br><h3>  Protection de l'√©tat interne </h3><br>  Les collections classiques sont con√ßues avec des performances maximales √† l'esprit, de sorte que leurs m√©thodes d'instance ne garantissent pas la s√©curit√© des threads. <br><br>  Par exemple, jetez un ≈ìil au code source de la m√©thode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dictionary.Add</a> . <br>  Nous pouvons voir les lignes suivantes (le code est simplifi√© pour plus de lisibilit√©): <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._buckets == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prime = HashHelpers.GetPrime(capacity); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[prime]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._entries = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;TKey, TValue&gt;.Entry[prime]; }</code> </pre> <br>  Comme nous pouvons le voir, l'√©tat interne du dictionnaire n'est pas prot√©g√©.  Lors de l'ajout d'√©l√©ments √† partir de plusieurs threads, le sc√©nario suivant est possible: <br><br><ol><li>  Thread 1 appel√© <i>Add</i> , l'ex√©cution s'est arr√™t√©e imm√©diatement apr√®s avoir entr√© la condition <i>if</i> </li><li>  Le thread 2 appel√© <i>Ajouter</i> , a initialis√© la collection, a ajout√© l'√©l√©ment </li><li>  Le flux 1 est retourn√© au travail, a r√©initialis√© la collection, d√©truisant ainsi les donn√©es ajout√©es par le flux 2. </li></ol><br>  Autrement dit, les collections classiques ne conviennent pas pour l'enregistrement √† partir de plusieurs flux. <br><br><h3>  L'API tol√®re l'√©tat actuel de la collection. </h3><br>  Comme nous le savons, les cl√©s en double ne peuvent pas √™tre ajout√©es au <i>dictionnaire</i> .  Si nous appelons deux fois <i>Add</i> avec la m√™me cl√©, le deuxi√®me appel l√®vera une <i>ArgumentException</i> . <br><br>  Cette protection est utile dans les sc√©narios √† thread unique.  Mais avec le multithreading, nous ne pouvons pas √™tre s√ªrs de l'√©tat actuel de la collection.  Naturellement, les v√©rifications comme celles-ci ne nous √©pargnent que lorsque nous nous enveloppons constamment dans une serrure: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dictionary.ContainsKey(key)) { dictionary.Add(key, ‚ÄúHello‚Äù); }</code> </pre><br>  L'API bas√©e sur les exceptions est une mauvaise option et ne permettra pas un comportement stable et pr√©visible dans les sc√©narios multithreads.  Au lieu de cela, vous avez besoin d'une API qui ne fait pas d'hypoth√®ses sur l'√©tat actuel de la collection, ne l√®ve pas d'exceptions et laisse √† l'appelant une d√©cision sur l'admissibilit√© d'un √©tat particulier. <br><br>  Dans les collections simultan√©es, les API sont construites sur le mod√®le <i>TryXXX</i> .  Au lieu des <i>m√©thodes</i> <i>Add</i> , <i>Get</i> et <i>Remove</i> habituelles <i>,</i> nous utilisons les <i>m√©thodes TryAdd</i> , <i>TryGetValue</i> et <i>TryRemove</i> .  Et, si ces m√©thodes retournent <i>fausses</i> , alors nous d√©cidons s'il s'agit d'une situation exceptionnelle ou non. <br><br>  Il convient de noter que les collections classiques disposent d√©sormais √©galement de m√©thodes tol√©rantes √† l'√©tat.  Mais dans les collections classiques, une telle API est un ajout int√©ressant, et dans les collections simultan√©es, c'est un must. <br><br><h3>  API minimisant les conditions de course </h3><br>  Consid√©rez l'op√©ration de mise √† jour d'√©l√©ment la plus simple: <br><br><pre> <code class="java hljs">dictionary[key] += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Pour toute sa simplicit√©, le code effectue trois actions: il obtient la valeur de la collection, ajoute 1, √©crit la nouvelle valeur.  Dans une ex√©cution multithread, il est possible que le code ait r√©cup√©r√© une valeur, effectu√© un incr√©ment, puis effac√© en toute s√©curit√© la valeur qui a √©t√© √©crite par un autre thread pendant que l'incr√©ment √©tait en cours d'ex√©cution. <br><br>  Pour r√©soudre ces probl√®mes, l'API des collections simultan√©es contient un certain nombre de m√©thodes d'assistance.  Par exemple, la m√©thode <i>TryUpdate</i> , qui prend trois param√®tres: la cl√©, la nouvelle valeur et la valeur actuelle attendue.  Si la valeur de la collection ne correspond pas √† ce qui √©tait attendu, la mise √† jour ne sera pas effectu√©e et la m√©thode renverra <i>false</i> . <br><br>  Prenons un autre exemple.  Litt√©ralement, chaque ligne du code suivant (y compris <i>Console.WriteLine</i> ) peut provoquer des probl√®mes avec l'ex√©cution multithread: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dictionary.ContainsKey(key)) { dictionary[key] += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dictionary.Add(key, <span class="hljs-number"><span class="hljs-number">1</span></span>); } Console.WriteLine(dictionary[key]);</code> </pre><br>  Ajouter ou mettre √† jour une valeur, puis effectuer une op√©ration avec le r√©sultat, est une t√¢che assez typique.  Par cons√©quent, le dictionnaire simultan√© a la m√©thode <i>AddOrUpdate</i> , qui effectue une s√©quence d'actions en un seul appel et est thread-safe: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = dictionary.AddOrUpdate(key, <span class="hljs-number"><span class="hljs-number">1</span></span>, (itemKey, itemValue) =&gt; itemValue + <span class="hljs-number"><span class="hljs-number">1</span></span>); Console.WriteLine(result);</code> </pre><br>  Il y a un point √† conna√Ætre. <br><br>  L'impl√©mentation de la m√©thode <i>AddOrUpdate</i> appelle la m√©thode <i>TryUpdate</i> d√©crite ci-dessus et lui transmet la valeur actuelle de la collection.  Si la mise √† jour a √©chou√© (le thread voisin a d√©j√† modifi√© la valeur), la tentative est r√©p√©t√©e et le d√©l√©gu√© de mise √† jour transmis est appel√© √† nouveau avec la valeur actuelle mise √† jour.  Autrement dit, le <i>d√©l√©gu√© de mise √† jour peut √™tre appel√© plusieurs fois</i> , il ne doit donc pas contenir d'effets secondaires. <br><br><h3>  Verrouillez les algorithmes et les verrous granulaires </h3><br>  Microsoft a fait un excellent travail sur les performances des collections simultan√©es et n'a pas simplement encapsul√© toutes les op√©rations avec des verrous.  En √©tudiant la source, vous pouvez voir de nombreux exemples d'utilisation de verrous granulaires, l'utilisation d'algorithmes comp√©tents au lieu de verrous, ainsi que l'utilisation d'instructions sp√©ciales et de primitives de synchronisation plus ¬´l√©g√®res¬ª que <i>Monitor</i> . <br><br><h2>  Ce que les collections simultan√©es ne donnent pas </h2><br>  D'apr√®s les exemples ci-dessus, il est √©vident que les collections simultan√©es n'offrent pas une protection compl√®te contre les conditions de concurrence, et nous devons concevoir notre code en cons√©quence.  Mais ce n‚Äôest pas tout, il y a deux ou trois points √† conna√Ætre. <br><br><h3>  Polymorphisme avec des collections classiques </h3><br>  Les collections simultan√©es, comme les classiques, impl√©mentent les interfaces <i>IDictionary</i> , <i>ICollection</i> et <i>IEnumerable</i> .  Mais une partie de l'API de ces interfaces ne peut pas √™tre thread-safe par d√©finition.  Par exemple, la m√©thode <i>Add</i> , dont nous avons discut√© ci-dessus. <br><br>  Les collections simultan√©es impl√©mentent de tels contrats sans s√©curit√© de thread.  Et pour ¬´cacher¬ª une API non s√©curis√©e, ils utilisent une impl√©mentation explicite des interfaces.  Cela vaut la peine de se rappeler lorsque nous transmettons des collections simultan√©es √† des m√©thodes qui prennent en entr√©e, par exemple, ICollection. <br><br>  De plus, les collections simultan√©es ne sont pas conformes au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principe de substitution Liskov</a> par rapport aux collections classiques. <br><br>  Par exemple, le contenu d'une collection classique ne peut pas √™tre modifi√© pendant l' <i>it√©ration</i> , le code suivant <i>l√®vera</i> une <i>InvalidOperationException</i> pour la classe <i>List</i> : <br><br><pre> <code class="java hljs">foreach (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element in list) { list.Remove(element); }</code> </pre><br>  Si nous parlons de collections simultan√©es, la modification au moment de l'√©num√©ration ne conduit pas √† une exception, de sorte que nous pouvons effectuer la lecture et l'√©criture simultan√©es √† partir de diff√©rents flux. <br><br>  De plus, les collections simultan√©es impl√©mentent diff√©remment la possibilit√© de modification pendant l'√©num√©ration.  <i>ConcurrentDictionary</i> n'effectue simplement aucune v√©rification et ne garantit pas le r√©sultat de l'it√©ration, et <i>ConcurrentStack / Queue / Bag se</i> verrouille et cr√©e une copie de l'√©tat actuel, √† travers lequel it√©rer. <br><br><h3>  Probl√®mes de performances possibles </h3><br>  Nous avons mentionn√© ci-dessus que <i>ConcurrentBag</i> peut ¬´voler¬ª des √©l√©ments des threads voisins.  Cela peut entra√Æner des probl√®mes de performances si vous √©crivez et lisez le <i>ConcurrentBag √†</i> partir de diff√©rents threads. <br><br>  En outre, les collections simultan√©es imposent des verrous complets lors de l'interrogation de l'√©tat de la collection enti√®re ( <i>Count</i> , <i>IsEmpty</i> , <i>GetEnumerator</i> , <i>ToArray</i> , etc.) et sont donc consid√©rablement plus lentes que leurs homologues classiques. <br><br>  Conclusion: l'utilisation de collections simultan√©es ne vaut que si elles sont vraiment n√©cessaires, car ce choix n'est pas ¬´gratuit¬ª. <br><br><h2>  Quand quels types de collections utiliser </h2><br><ul><li>  Scripts mono-thread: seules les collections classiques avec les meilleures performances. </li><li>  Enregistrement √† partir de plusieurs flux: uniquement des collections simultan√©es qui prot√®gent l'√©tat interne et disposent d'une API appropri√©e pour un enregistrement comp√©titif. </li><li>  Lecture √† partir de plusieurs threads: aucune recommandation d√©finitive.  Les collections simultan√©es peuvent cr√©er des probl√®mes de performances avec des demandes d'√©tat intensives pour l'ensemble de la collection.  Cependant, pour les collections classiques, Microsoft ne garantit pas les performances, m√™me pour les op√©rations de lecture.  Par exemple, une impl√©mentation interne d'une collection peut avoir des propri√©t√©s paresseuses qui sont lanc√©es lors de la lecture de donn√©es et, par cons√©quent, il est possible de d√©truire l'√©tat interne lors de la lecture √† partir de plusieurs threads.  Une bonne option moyenne consiste √† utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des collections immuables</a> . </li><li>  Et la lecture et l'√©criture √† partir de plusieurs threads: des collections uniquement simultan√©es, impl√©mentant √† la fois la protection de l'√©tat et une API s√©curis√©e. </li></ul><br><h2>  Conclusions </h2><br>  Dans cet article, nous avons bri√®vement √©tudi√© les collections simultan√©es, quand les utiliser et quelles sont leurs sp√©cificit√©s.  Bien s√ªr, l'article n'√©puise pas le sujet, et avec un travail s√©rieux avec des collections multithread, vous devriez creuser plus profond√©ment.  La fa√ßon la plus simple de le faire est de regarder le code source des collections utilis√©es.  C'est informatif et pas du tout compliqu√©, le code est tr√®s, tr√®s lisible. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473352/">https://habr.com/ru/post/fr473352/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473342/index.html">"La longue route vous attend ..." ou r√©soudre le probl√®me de pr√©vision en C # en utilisant Ml.NET (DataScience)</a></li>
<li><a href="../fr473344/index.html">Concerts et √©v√©nements KudaGo dans votre miroir</a></li>
<li><a href="../fr473346/index.html">Cr√©ation d'une API REST avec Node.js et une base de donn√©es Oracle. 2e partie</a></li>
<li><a href="../fr473348/index.html">L'id√©e d'inertie (SGDm), l'id√©e de mise √† l'√©chelle (Adagrad) et de r√©gularisation dans l'apprentissage automatique en utilisant le probl√®me de la classification comme exemple</a></li>
<li><a href="../fr473350/index.html">Cr√©ation d'une API REST avec Node.js et une base de donn√©es Oracle. 3e partie</a></li>
<li><a href="../fr473354/index.html">√Ä propos des bizarreries de la habrostatistique</a></li>
<li><a href="../fr473358/index.html">Installer et configurer Nexus Sonatype en utilisant l'infrastructure comme approche de code</a></li>
<li><a href="../fr473362/index.html">Exp√©rience GSoC: Comment deux (trois) √©tudiants ont vraiment am√©lior√© le code CRIU</a></li>
<li><a href="../fr473364/index.html">Il y a un gobie qui se balance: une liste de contr√¥le pour le commerce √©lectronique pendant la saison des ventes</a></li>
<li><a href="../fr473366/index.html">Qu'y a-t-il dans ma smart tv? Ou qu'est-ce qui peut √™tre entass√© dans le t√©l√©viseur?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>