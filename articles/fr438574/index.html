<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïí üëµüèø üíè Bases de l'architecture d'application Flutter: vanille, mod√®le de port√©e, BLoC üë≤üèø üì¥ üçπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(article original publi√© en anglais sur Medium ) 


 Flutter fournit un cadre r√©actif moderne, un large √©ventail de widgets et d'outils. Mais, malheur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bases de l'architecture d'application Flutter: vanille, mod√®le de port√©e, BLoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438574/"><p><img src="https://habrastorage.org/webt/2j/2p/yu/2j2pyudr-kde4fqeczqoic_9lpq.png"></p><br><p>  (article original publi√© en anglais sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Medium</a> ) </p><br><p>  Flutter fournit un cadre r√©actif moderne, un large √©ventail de widgets et d'outils.  Mais, malheureusement, la documentation ne ressemble en rien √† un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guide de l'architecture recommand√©e de l'application Android</a> . </p><br><p>  Il n'y a pas d'architecture universelle id√©ale qui pourrait r√©pondre √† toutes les exigences techniques imaginables, mais admettons que la plupart des applications mobiles sur lesquelles nous travaillons ont les fonctionnalit√©s suivantes: </p><br><ol><li>  Demander et t√©l√©charger des donn√©es. </li><li>  Transformation et pr√©paration des donn√©es pour l'utilisateur. </li><li>  √âcriture et lecture de donn√©es √† partir d'une base de donn√©es ou d'un syst√®me de fichiers. </li></ol><br><p> Compte tenu de tout cela, j'ai cr√©√© une application de d√©monstration qui r√©sout le m√™me probl√®me en utilisant diff√©rentes approches de l'architecture. <a name="habracut"></a></p><br><p>  Initialement, l'utilisateur affiche un √©cran avec un bouton ¬´Charger les donn√©es utilisateur¬ª situ√© au centre.  Lorsque l'utilisateur clique sur le bouton, un chargement de donn√©es asynchrone se produit et le bouton est remplac√© par un indicateur de chargement.  Une fois le t√©l√©chargement des donn√©es termin√©, l'indicateur de t√©l√©chargement est remplac√© par des donn√©es. </p><br><p>  Commen√ßons donc. </p><br><p><img src="https://habrastorage.org/webt/c5/by/8g/c5by8gjmz_oov-ukuy4_dwo4njs.gif"></p><br><h2 id="dannye">  Les donn√©es </h2><br><p> Pour simplifier la t√¢che, j'ai cr√©√© la classe <code>Repository</code> , qui contient la m√©thode <code>getUser()</code> .  Cette m√©thode simule le chargement asynchrone des donn√©es du r√©seau et renvoie <code>Future&lt;User&gt;</code> . </p><br><p>  Si vous n'√™tes pas familier avec Futures et la programmation asynchrone dans Dart, nous pouvons en savoir plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et lire la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation de la classe Future</a> . </p><br><pre> <code class="plaintext hljs">class Repository { Future&lt;User&gt; getUser() async { await Future.delayed(Duration(seconds: 2)); return User(name: 'John', surname: 'Smith'); } }</code> </pre> <br><pre> <code class="plaintext hljs">class User { User({ @required this.name, @required this.surname, }); final String name; final String surname; }</code> </pre> <br><h2 id="vanilla">  Vanille </h2><br><p>  D√©veloppons l'application, comme le ferait un d√©veloppeur s'il lisait la documentation Flutter sur le site officiel. </p><br><p>  Ouvrez l'√©cran <code>VanillaScreen</code> l'aide du <code>Navigator</code> </p><br><pre> <code class="plaintext hljs">Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; VanillaScreen(_repository), ), );</code> </pre> <br><p>  √âtant donn√© que l'√©tat d'un widget peut changer plusieurs fois au cours de son cycle de vie, nous devons h√©riter de <code>StatefulWidget</code> .  Pour impl√©menter votre widget avec √©tat, vous avez √©galement besoin de la classe <code>State</code> .  Les <code>bool _isLoading</code> et <code>User _user</code> de la classe <code>_VanillaScreenState</code> repr√©sentent l'√©tat du widget.  Les deux champs sont initialis√©s avant que la m√©thode <code>build(BuildContext context)</code> soit appel√©e pour la premi√®re fois. </p><br><pre> <code class="plaintext hljs">class VanillaScreen extends StatefulWidget { VanillaScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _VanillaScreenState(); } class _VanillaScreenState extends State&lt;VanillaScreen&gt; { bool _isLoading = false; User _user; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Vanilla'), ), body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), ), ); } Widget _buildBody() { if (_user != null) { return _buildContent(); } else { return _buildInit(); } } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { setState(() { _isLoading = true; }); widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); }); }, ), ); } Widget _buildContent() { return Center( child: Text('Hello ${_user.name} ${_user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Une fois l'objet d'√©tat du widget cr√©√©, la m√©thode <code>build(BuildContext context)</code> est appel√©e pour construire l'interface utilisateur.  Toutes les d√©cisions concernant le widget √† afficher √† l'√©cran sont prises directement dans le code de d√©claration de l'interface utilisateur. </p><br><pre> <code class="plaintext hljs">body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), )</code> </pre> <br><p>  Afin d'afficher un indicateur de progression, lorsque l'utilisateur clique sur le bouton ¬´Charger les d√©tails de l'utilisateur¬ª, nous proc√©dons comme suit. </p><br><pre> <code class="plaintext hljs">setState(() { _isLoading = true; });</code> </pre> <br><p>  De la documentation (traduction): </p><br><blockquote>  Un appel √† la m√©thode setState () informe le framework que l'√©tat interne de cet objet a chang√© et peut affecter l'interface utilisateur dans la sous-arborescence.  C'est la raison pour laquelle le framework appelle la m√©thode de g√©n√©ration sur cet objet d'√©tat. </blockquote><p>  Cela signifie qu'apr√®s avoir appel√© la m√©thode <code>setState()</code> , le framework appellera √† nouveau la m√©thode <code>build(BuildContext context)</code> , qui <strong>recr√©era l'arborescence enti√®re du widget</strong> .  √âtant donn√© que la valeur du champ <code>_isLoading</code> <code>true</code> , au lieu de la m√©thode <code>_buildBody()</code> , la m√©thode <code>_buildLoading()</code> sera appel√©e et un indicateur de progression s'affichera √† l'√©cran. <br>  Exactement la m√™me chose se produit lorsque nous recevons un rappel de <code>getUser()</code> et appelons la m√©thode <br>  <code>setState()</code> pour affecter de nouvelles valeurs aux champs <code>_isLoading</code> et <code>_user</code> . </p><br><pre> <code class="plaintext hljs">widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); });</code> </pre> <br><h3 id="plyusy">  Avantages </h3><br><ol><li>  Seuil d'entr√©e bas. </li><li>  Aucune biblioth√®que tierce partie requise. </li></ol><br><h3 id="minusy">  Inconv√©nients </h3><br><ol><li>  Lorsque l'√©tat du widget change, l'arborescence du widget est enti√®rement recr√©√©e √† chaque fois. </li><li>  Viole le principe de la responsabilit√© exclusive.  Le widget est responsable non seulement de la cr√©ation de l'interface utilisateur, mais √©galement du chargement des donn√©es, de la logique m√©tier et de la gestion des √©tats. </li><li>  Les d√©cisions sur la fa√ßon d'afficher l'√©tat actuel sont prises directement dans le code de l'interface utilisateur.  Si l'√©tat devient plus complexe, la lisibilit√© du code diminuera consid√©rablement. </li></ol><br><h2 id="scoped-model">  Mod√®le de port√©e </h2><br><p>  Scoped Model est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®que tierce</a> .  Voici comment les d√©veloppeurs le d√©crivent: </p><br><blockquote>  Un ensemble d'utilitaires qui vous permettent de transf√©rer le mod√®le de donn√©es du widget anc√™tre √† tous ses descendants.  De plus, lorsque les donn√©es du mod√®le changent, tous les descendants qui utilisent le mod√®le seront recr√©√©s.  Cette biblioth√®que a √©t√© initialement extraite du code du projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fuchsia</a> . </blockquote><p>  Cr√©ons le m√™me √©cran que dans l'exemple pr√©c√©dent, mais en utilisant le mod√®le Scoped.  Tout d'abord, nous devons ajouter la biblioth√®que Scoped Model au projet.  Ajoutez la d√©pendance <code>scoped_model</code> fichier <code>scoped_model</code> dans la section des <code>dependencies</code> . </p><br><pre> <code class="plaintext hljs">scoped_model: ^1.0.1</code> </pre> <br><p>  Regardons le code <code>UserModelScreen</code> et comparons-le avec l'exemple pr√©c√©dent, dans lequel nous n'avons pas utilis√© le mod√®le Scoped.  Pour rendre notre mod√®le accessible aux descendants du widget, nous devons envelopper le widget et le mod√®le dans <code>ScopedModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModelScreen extends StatefulWidget { UserModelScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserModelScreenState(); } class _UserModelScreenState extends State&lt;UserModelScreen&gt; { UserModel _userModel; @override void initState() { _userModel = UserModel(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return ScopedModel( model: _userModel, child: Scaffold( appBar: AppBar( title: const Text('Scoped model'), ), body: SafeArea( child: ScopedModelDescendant&lt;UserModel&gt;( builder: (context, child, model) { if (model.isLoading) { return _buildLoading(); } else { if (model.user != null) { return _buildContent(model); } else { return _buildInit(model); } } }, ), ), ), ); } Widget _buildInit(UserModel userModel) { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { userModel.loadUserData(); }, ), ); } Widget _buildContent(UserModel userModel) { return Center( child: Text('Hello ${userModel.user.name} ${userModel.user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Dans l'exemple pr√©c√©dent, chaque fois qu'un widget change d'√©tat, l'arborescence des widgets √©tait compl√®tement recr√©√©e.  Mais avons-nous vraiment besoin de recr√©er la totalit√© de l'arborescence des widgets (plein √©cran)?  Par exemple, l'AppBar ne change pas du tout et il est inutile de le recr√©er.  Id√©alement, vous ne devez recr√©er que les widgets qui doivent changer en fonction du changement d'√©tat.  Et le mod√®le de port√©e peut nous aider √† r√©soudre ce probl√®me. </p><br><p>  Le <code>ScopedModelDescendant&lt;UserModel&gt;</code> est utilis√© pour rechercher le <code>UserModel</code> dans l'arborescence des widgets.  Il sera automatiquement recr√©√© chaque fois que l' <code>UserModel</code> notifiera qu'il y a eu un changement. </p><br><p>  Une autre am√©lioration est que <code>UserModelScreen</code> n'est plus responsable de la gestion des √©tats, de la logique m√©tier et du chargement des donn√©es. </p><br><p>  Regardons le code de la classe <code>UserModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModel extends Model { UserModel(this._repository); final Repository _repository; bool _isLoading = false; User _user; User get user =&gt; _user; bool get isLoading =&gt; _isLoading; void loadUserData() { _isLoading = true; notifyListeners(); _repository.getUser().then((user) { _user = user; _isLoading = false; notifyListeners(); }); } static UserModel of(BuildContext context) =&gt; ScopedModel.of&lt;UserModel&gt;(context); }</code> </pre> <br><p>  <code>UserModel</code> contient et g√®re d√©sormais l'√©tat.  Afin d'avertir les √©couteurs (et recr√©er des descendants) qu'un changement s'est produit, vous devez appeler la m√©thode <code>notifyListeners()</code> . </p><br><h3 id="plyusy-1">  Avantages </h3><br><ol><li>  La gestion des √©tats, la logique m√©tier et le chargement des donn√©es sont distincts du code de l'interface utilisateur. </li><li>  Seuil d'entr√©e bas. </li></ol><br><h3 id="minusy-1">  Inconv√©nients </h3><br><ol><li>  D√©pendance de biblioth√®que tierce. </li><li>  Si le mod√®le devient suffisamment complexe, il sera difficile de savoir quand il est vraiment n√©cessaire d'appeler la m√©thode <code>notifyListeners()</code> pour √©viter des recr√©ations inutiles. </li></ol><br><h2 id="bloc">  BLoC </h2><br><p>  BLoC ( <strong>B</strong> usiness Logic <strong>C</strong> omponents) est un mod√®le recommand√© par les d√©veloppeurs de Google.  Les flux sont utilis√©s pour g√©rer l'√©tat et pour notifier un changement d'√©tat. </p><br><p>  <strong>Pour les d√©veloppeurs Android:</strong> vous pouvez imaginer que <code>Bloc</code> est un <code>ViewModel</code> et <code>StreamController</code> est un <code>LiveData</code> .  Cela rendra le code suivant facile √† comprendre, car vous connaissez d√©j√† les principes de base. </p><br><pre> <code class="plaintext hljs">class UserBloc { UserBloc(this._repository); final Repository _repository; final _userStreamController = StreamController&lt;UserState&gt;(); Stream&lt;UserState&gt; get user =&gt; _userStreamController.stream; void loadUserData() { _userStreamController.sink.add(UserState._userLoading()); _repository.getUser().then((user) { _userStreamController.sink.add(UserState._userData(user)); }); } void dispose() { _userStreamController.close(); } } class UserState { UserState(); factory UserState._userData(User user) = UserDataState; factory UserState._userLoading() = UserLoadingState; } class UserInitState extends UserState {} class UserLoadingState extends UserState {} class UserDataState extends UserState { UserDataState(this.user); final User user; }</code> </pre> <br><p>  Le code montre qu'il n'est plus n√©cessaire d'appeler des m√©thodes suppl√©mentaires pour notifier les changements d'√©tat. </p><br><p>  J'ai cr√©√© 3 classes pour repr√©senter les √©tats possibles: </p><br><p>  <code>UserInitState</code> pour l'√©tat lorsque l'utilisateur ouvre un √©cran avec un bouton au centre. </p><br><p>  <code>UserLoadingState</code> de l'√©tat lorsque l'indicateur de chargement est affich√© pendant le chargement des donn√©es. </p><br><p>  <code>UserDataState</code> pour l'√©tat lorsque les donn√©es sont d√©j√† charg√©es et affich√©es √† l'√©cran. </p><br><p>  Passer l'√©tat de cette mani√®re nous permet de nous d√©barrasser compl√®tement de la logique du code de l'interface utilisateur.  Dans l'exemple Scoped Model, nous avons toujours v√©rifi√© si la valeur du champ <code>_isLoading</code> <code>true</code> ou <code>false</code> pour d√©terminer le widget √† cr√©er.  Dans le cas de BLoC, nous transmettons le nouvel √©tat au flux, et la seule t√¢che du widget <code>UserBlocScreen</code> cr√©er une interface utilisateur pour l'√©tat actuel. </p><br><pre> <code class="plaintext hljs">class UserBlocScreen extends StatefulWidget { UserBlocScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserBlocScreenState(); } class _UserBlocScreenState extends State&lt;UserBlocScreen&gt; { UserBloc _userBloc; @override void initState() { _userBloc = UserBloc(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Bloc'), ), body: SafeArea( child: StreamBuilder&lt;UserState&gt;( stream: _userBloc.user, initialData: UserInitState(), builder: (context, snapshot) { if (snapshot.data is UserInitState) { return _buildInit(); } if (snapshot.data is UserDataState) { UserDataState state = snapshot.data; return _buildContent(state.user); } if (snapshot.data is UserLoadingState) { return _buildLoading(); } }, ), ), ); } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { _userBloc.loadUserData(); }, ), ); } Widget _buildContent(User user) { return Center( child: Text('Hello ${user.name} ${user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } @override void dispose() { _userBloc.dispose(); super.dispose(); } }</code> </pre> <br><p>  Le code du widget <code>UserBlocScreen</code> est encore plus simple que dans les exemples pr√©c√©dents.  Afin d'√©couter les changements d'√©tat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">StreamBuilder est</a> utilis√©.  <code>StreamBuilder</code> est un <code>StatefulWidget</code> qui se cr√©e conform√©ment √† la derni√®re valeur (Snapshot) du flux ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stream</a> ). </p><br><h3 id="plyusy-2">  Avantages </h3><br><ol><li>  Aucune biblioth√®que tierce partie requise. </li><li>  La logique m√©tier, la gestion des √©tats et le chargement des donn√©es sont distincts du code de l'interface utilisateur. </li><li>  R√©activit√©  Il n'est pas n√©cessaire d'appeler des m√©thodes suppl√©mentaires, comme dans l'exemple avec Scoped Model <code>notifyListeners()</code> . </li></ol><br><h3 id="minusy-2">  Inconv√©nients </h3><br><ol><li>  Le seuil d'entr√©e est l√©g√®rement sup√©rieur.  Besoin d'exp√©rience avec les flux ou rxdart. </li></ol><br><h2 id="linki">  Les liens </h2><br><p>  Vous pouvez lire le code complet en le t√©l√©chargeant depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon d√©p√¥t github</a> . </p><br><p>  Article original publi√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Medium</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438574/">https://habr.com/ru/post/fr438574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438560/index.html">√âcrire XGBoost √† partir de z√©ro - partie 1: arbres de d√©cision</a></li>
<li><a href="../fr438562/index.html">√âcrire XGBoost √† partir de z√©ro - partie 2: renforcement du gradient</a></li>
<li><a href="../fr438566/index.html">Bo√Ætier pour microprocesseur Apple Strange A12X</a></li>
<li><a href="../fr438568/index.html">√Ä propos des ordinateurs quantiques: comment diff√©rents pays d√©veloppent cette technologie</a></li>
<li><a href="../fr438570/index.html">Concours du Nouvel An du CS Center 2018</a></li>
<li><a href="../fr438576/index.html">Open source populaire - troisi√®me partie: 5 outils pour les d√©veloppeurs</a></li>
<li><a href="../fr438578/index.html">Comment le g√©ant de l'informatique a √©t√© ¬´contourn√©¬ª pour la deuxi√®me fois</a></li>
<li><a href="../fr438580/index.html">Mots de passe g√©n√©r√©s automatiquement dans iOS 12</a></li>
<li><a href="../fr438582/index.html">AntiRating 2018</a></li>
<li><a href="../fr438584/index.html">Frontend pour d√©veloppeur backend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>