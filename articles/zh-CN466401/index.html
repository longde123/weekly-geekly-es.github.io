<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💤 👦🏿 🦐 一点金融数学：计算通胀和利息 🏨 🏝️ 🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，我不得不检查我市的公用事业部门所做的计算。 存在一个有争议的问题，只有进行正确的计算才能解决。 展望未来，我会说公共事业认为错了。 因此，在这里，我们将根据乌克兰《民法典》考虑如何正确计算通货膨胀成本和每年3％的债务债务。 

 第一部分描述了通货膨胀成本的计算，这是乌克兰所特有的。 
 第二...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>一点金融数学：计算通胀和利息</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466401/">最近，我不得不检查我市的公用事业部门所做的计算。 存在一个有争议的问题，只有进行正确的计算才能解决。 展望未来，我会说公共事业认为错了。 因此，在这里，我们将根据乌克兰《民法典》考虑如何正确计算通货膨胀成本和每年3％的债务债务。 <br><br> 第一部分描述了通货膨胀成本的计算，这是乌克兰所特有的。 <br> 第二部分（较大的部分）将专门讨论每年计算3％的问题。 它也适用于俄罗斯联邦，白俄罗斯和哈萨克斯坦，但是在这些国家中，利率不是固定的，而是取决于中央银行的再融资利率。 这个国家的其他地方看起来都没有。 <br><br> 第二部分非常接近于计算普通信贷交易（贷款，贷款，借款等）的利息。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/2q/9l/di2q9lbdqyzqzcywadgdnny0bgo.png" alt="图片替代"></div><br> 首先是理论，最后是一些代码。 <br><br> 所有这一切都削减了。 <br><a name="habracut"></a><br> 因此，我从公用事业获得了一份文件“通货膨胀成本和每年3％的累积报表”。 我对其进行了检查，结果发现它是用错误的算法计算的，因此很有趣，因为它必须执行乌克兰民法典条款的要求。 <br><br> 应该考虑的是《乌克兰民法典》中写的： <br><blockquote> 乌克兰民法典第625条。  “违反金钱义务的责任” <br>  2.延迟履行货币义务的债务人应债权人的要求，有义务在考虑到整个延迟期间的既定通货膨胀指数的基础上，偿还债务金额，以及每年逾期金额的3％... </blockquote> 根据债务数字，公用事业公司计算了每年通货膨胀成本和3％。 <br><br><h2> 通货膨胀成本 </h2><br> 此外，我将讨论计算算法，而不是特定的数字。 <br><br> 通货膨胀是一个以货币贬值为特征的过程，即购买力下降和价格普遍上涨。 除通货膨胀外，现金流量计算的最终结果是非常随意的。 <br><br> 通货膨胀指数（II）或消费者物价指数（CPI），消费者物价指数（CPI）-一种用来衡量经济中特定时期内商品和服务（消费者篮子）平均价格水平的价格指数类型之一。 <br><br> 人工智能是表征人口为非生产性消费而获得的商品和服务的总体价格水平动态的指标。 这是增长指数，它显示了报告所述期间平均价格上涨的百分比。 <br><br> 在乌克兰，AI和CPI是同义词 <br><br> 由于价格指数是一个环比指数，因此对于一个接一个的时期，它是通过乘以指标来计算的，例如101％* 102％=（1.01 * 1.02）* 100％= 103.02％。 <br><br>  AI由乌克兰国家统计委员会计算，并在官方期刊中发布。 这些关键数据可用于重新计算现金金额。 <br> 社区工作者怎么看？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/5p/hv/ge5phvi9cjhbbz7kkx0jndzuyli.png" alt="水电费帐单文件的一部分"></div><br> 最后结算日期为2016年12月7日。 <br><br> 让我们看看公共工作者如何获得通货膨胀成本比率？ <br><br> 用肉眼可以看到，在第三（和第五列）中，应该是整数部分0，而不是整数部分1。它们是如何得到小数部分的？ <br><br>  <strong>2016年9月。</strong>小数部分0.028。  9月的付款期限为2016年10月20日。小数部分对应于国家统计委员会发布的2016年10月的通胀指数-102.8％ <br><br>  <strong>2016年8月。</strong>小数部分0.0465。  8月的付款期限为2016年9月20日。小数部分对应于9月份的通胀指数乘以10月份的II：101.8％* 102.8％= 104.65％，或以股票计算，为1.018 * 1.028 = 1.046504。 公用事业将四舍五入到1.0465并打印此数字，尽管应该删除该单位，因为在下一列中，它们仅打印通货膨胀成本的金额，而不打印累积的金额。 <br><br>  <strong>2016年7月或更早。</strong> 我执行了这些计算并恢复了算法。 从提供服务的月份起的下一个月（到期日）开始，到2016年10月，公用事业乘以通胀指数。 <br><br>  <strong>起点</strong>只是部分正确。 正如我将在稍后展示的那样，在一般情况下，确实需要从本月开始计算，但是在我们的特殊情况下，应该跳过第一个月（将AI等于100％）。 <br><br> 乘法<strong>的终点</strong> 。 由于计算的最后一天是12月，您需要完成12月，因此通常是这种情况。 正如我稍后将显示的那样，在这种特殊情况下，还需要跳过12月（也将AI等于100％）。 并且在12月7日，12月的AI没有时间发布。 <br><br> 为什么在任何地方都没有考虑到11月？ 我认为他们只是忘记将其输入系统。 <br><br> 现在让我们看看如何计算通胀指数。  <strong>必要时</strong> -于2012年7月17日乌克兰最高经济法院第01-06 / 928/2012号信息通报中描述[6]。 <br><br> 我将给出该段的一部分： <br><blockquote> 将在本月考虑从每月1日到15日偿还的债务金额，并且如果要从每月16日到31日偿还债务，则从下个月开始计算。 <br><br> 同样，如果已从一个月的1到15天还清债务，则不计入本月的价格计算通货膨胀成本；如果一个月的16至31天，则应将本月的通货膨胀成本计算在内。 </blockquote> 在我们的情况下，付款期限是提供服务的月份之后的下一个月的第20天，即 对于9月提供的服务，结算的开始日期是2016年10月21日，截止日期是2016年12月7日。 <br><br> 即 正确地说：对于2016年9月提供的服务，请考虑从10月到12月的三个月的通货膨胀（通过游标或周期），但在第一个月和上个月，请使AI等于1（100％），并仅考虑11月。 <br><br>  2016年11月，人工智能占101.8％，即 系数应为0.0180，而不是0.0280。 我之前写过有关牵头单位的文章。 <br><br><h2> 每年3％ </h2><br> 让我们看看公共服务每年如何获得3％的系数和应计金额？ 这是上表的第五列。 <br><br> 如我先前所写，不应有前导单位，而应有0。我们查看小数部分，请注意，它存在某种可疑的舍入方式-前一个月每个月比当月多0.0025。 <br><br> 通过简单的计算，可以确定公用事业不用再费力就将3％分成12个月，每月收取0.0025或0.25％，并且对于每个完整和不完整的延迟月份都应计入该百分比。 是的，如果您看一下2016年10月，付款截止日期是11月21日，计算是在12月7日进行的，那么对于一个不完整的月份，他们的计算是0.25％。 <br><br> 这种方法钦佩残酷的直率，但是，正如我稍后将要说明的那样，金融数学并不知道这种算法。 <br><br> 乌克兰的立法和金融数学并未对每年如何收取3％的费用给出明确的答案。 我搜索了几本与此主题相关的书，但是这些书都是古老的，可以追溯到2002年。 因此，这些书中的算法将得到补充，因为有可能从更现代和西方的文章中搜索到谷歌。  [1]已于2007年重印，但找不到最新的俄语书籍。 也许是因为金融数学作为一门科学起源于很久以前，而在计算机出现之前很久，“信用”和“信用利息”等概念就在几百年前出现了。 自2002年以来，算法没有太大变化。 <br><br> 但是西方对这个问题的看法与俄语书籍中所描述的不同。 我将首先从俄语书籍中引用信息，然后从西方文章中引用信息，以指出它们的重合之处。 <br><br> 下面的内容与特定的案例有关，即每年拖欠3％的利息，但是如果根据单利而非复利计息，则还可以归纳为计算其他信用关系的利息。 <br><br> 根据艺术。  625根据简单利率计划，乌克兰《民法典》每年需要累加3％。 要计算利息金额，必须将债务金额（一般情况下为贷款本金）乘以3％的标准化年利率，再乘以延误所占的年比例（年限）。 如果延迟时间超过一年，则此份额可能会超过1。 <br><br> 延迟的持续时间以天数表示。 在更一般的情况下，贷款期限<strong>可以</strong>以天表示（此处不考虑贷款期限以月和年表示的情况）。  3％的年利率是当年单利的标准化利率。  <strong>因此，您需要能够将以天为单位的延迟（信用）持续时间带入以年为单位的持续时间。</strong>  <strong>这不是一件容易的事，因为一年的长短取决于年份。</strong> <br><br> 以天为单位的持续时间是日历间隔持续时间的唯一定义度量，而不是以年为单位的持续时间。 后者的定义需要以将以天为单位的持续时间转换为以年为单位的持续时间的规则的形式进行说明。 用于将以天为单位的持续时间转换为以年为单位的持续时间的许多标准方法是基于将天数除以所谓的<strong>“年度除数”</strong> 。 年度除数的最典型值是360天和365天。 在最简单的情况下，除数是一个常数，与间隔无关。 期间中的天数始终充当红利（分数的分子）。 <br> 并且您需要确定以天为单位计算条件的过程。 让我们考虑两个牵强的示例： <br><br><ol><li> 从2018年12月6日至2018年12月7日，客户从银行获得短期贷款。 合同的期限是多少？我需要多少天才能产生利息？ 显然-1天。 </li><li> 订户从电信运营商处预订了服务，有效期为2018年12月6日至2018年12月7日。 服务的提供方式是什么？我必须在多少天内支付服务订阅费？ 显然是2天。 </li></ol><br> 有什么区别？ <br><br> 事实是，日期不是时间轴上的一点，而是可以用两种方式写的间隔（回想一下，间隔边界处的方括号表示该点在间隔中，括号是不在间隔中的点）： <br><br><ul><li>  [06.12.2018 00.00.00，12/07/2018 00.00.00）-此处间隔的右边界不包含在间隔中， </li><li>  [06/12/2018 00.00.00，12/06/2018 23.59.59]-此处间隔的右边界包含在间隔中。 </li></ul><br> 在第一种情况（1）中，当未明确给出时间间隔，而是以日期之间的间隔形式给出时，通常会计算出确切的天数，包括第一天或最后一天，但不能同时给出这两者。  [4]用同样的话说：“发放贷款的那天和还款日被认为是一天。” <br><br> 该方法确定所谓的精确时间。 还可以很容易地确定两个日期是否都指向同一年，并且可以使用日历显示该年中每一天的序列号。 然后，从延迟日期的序列号中减去早期日期的序列号就足够了，结果将给出该期间的持续时间。 在Oracle数据库中，您可以简单地减去截断到一天（舍弃时间）的日期（DATE类型），一个到另一个，差是整数天数。 <br><br> 在第二种情况（2）中，我们谈论的是天数，因此我们计算了两天。 <br><br> 此外，我从这样的事实出发，例如在公共服务的情况下，付款截止日期是9月20日（即这是最后一个可接受的付款日），并且已经在9月21日付款，即已经确定了您的天数。显然，延迟必须等于1天。 如果您面临间隔不包括左边界的指示，请向右移动左边界一天。 <br><br> 我们如何计算天数和分数分子？ 有一个精确的计算和一个近似的计算。 <br><br><h3> 准确计算天数 </h3><br><h4> 俄语练习 </h4><br> 本文进一步基于[1]。 <br><br> 选择周期中确切的天数作为除数，以及两个最常见的规则给出最常见的规则作为分母-360或365的年度除数： <br><br>  <strong>规则（R1）ACT / 365。</strong> 对于此规则，以天为单位的持续时间除以数字365。我注意到a年的长度将为366/365 = 1.00274，这不止一个。  ACT / 365规则错误在一个时期内越大，越多。 因此，此规则每年产生的3％的值将超过3％。 <br><br>  <strong>规则（R2）ACT / 360。</strong> 这就是所谓的“银行规则”，根据该规则，以天为单位的持续时间除以360。该规则进一步增加了缺口的年度长度。 对于非-年，其长度将为365/360 = 1.01389，对于a年，则为366/360 = 1.01667。 自然，时间越长，以年计的“延伸”程度就越大。 该规则最常用于与货币市场有关的计算中，即 市场短期债务，例如银行存款，票据，商业票据，存款证明等。每年3％的值将比使用以前的规则时更大。 <br><br> 如果接受的年度除数等于360天，则使用这种除数获得的利息称为<strong>普通</strong>利息或<strong>商业</strong>利息。 如果除数等于365，或者我将在后面显示366天，则该利息称为精确利息。 <br><br> 显然，普通百分数比精确百分数大得多。 <br><br> 尽管第一个规则比第二个规则更准确，但是两个规则都不够准确。 <br><br> 为了消除leap年对结果的影响，还有另外两个规则。 <br><br>  <strong>规则（R3）ACT / 365，日本。</strong> 以与ACT / 365规则相同的方式执行计算，但是在计算间隔持续时间（分数分子）时，不包括leap日。 年度除数保持不变。 <br><br> 根据Wiki： <br><blockquote> 在许多欧洲国家中，直到18世纪，人们都认为2月29日是不存在的日子，这一日期没有法律地位。 通常，由于问题的正式方面和在法院解决案件方面的困难，当天没有进行交易，没有付款，没有以债务支付等。 </blockquote><br><br> 另一种方式与除数的实际变化有关。 <br><br>  <strong>规则（R4）ACT / ACT基本。</strong> 我们将所需时间分为三个部分： <br><br><ul><li> 第一部分，从开始日期到开始日期所在的年末， </li><li> 第三部分-从结束日期所在的年份开始到结束日期， </li><li> 第二部分-第一部分和第三部分之间为0或几个完整的日历年。 </li></ul><br> 通过将天数除以年度除数365或366（取决于是否为leap年）来获得第一部分和第三部分的持续时间。 根据定义，第二个周期的持续时间由整数个完整日历年组成，无论它们是否跨越。 通过将三个部分的持续时间相加（以三个数字表示，其中第二个为整数，第一个和第三个为小数），可以得出整个周期的年数。 <br><br>  <strong>规则（R5）ACT / ACT的“简短”修改，期限少于一年。</strong> 在这种情况下，以天为单位的持续时间除以年度除数365或366，取决于搜索期间中是否有2月29日的日期？ 短ACT / ACT规则的一个特点是，如果间隔不适合日历年（其结束时间属于相邻年份），则应用基本规则和短规则将导致不同的结果。 <br><br><h4> 西方实践 </h4><br> 在西方实践中，对规则的描述有所不同。 通常，相同的俄语规则使用不同的名称，而且一次也不会使用一个。 <br><br> 该信息进一步基于[2]。 我是Vicki，我检查了所有来源并使用了其他Google信息：在天数确切的规则中，所有内容都是正确的，但是在天数近似的规则中，还有其他一些对规则的解释，因此它们经常会随着时间而变化，因此，将规则付诸实践，本文的大概天数不够。 <br><br>  <strong>规则（W1）实际/实际ISDA。</strong> 该规则的结果与（R4）“ ACT / ACT main”相同，但表述方式不同：该间隔分为leap年和非le年，无论它们是完整的还是不完整的，而且，天数总和years年除以365，非le年的天数总和除以366，两个数字相加。 <br><br> 西方惯例中该规则的其他名称：实际/实际，行为/行为，实际/ 365，行为/ 365。 是的，姓氏与规则（R1）相同，尽管规则的本质不同。 <br><br>  <strong>规则（W2）实际/ 365固定。</strong> 此规则完全重复规则（R1）ACT / 365-天数除以365。 <br><br> 西方惯例中该规则的其他名称：Act / 365 Fixed，A / 365 Fixed，A / 365F，英语。 <br><br>  <strong>规则（W3）实际/ 360。</strong> 此规则重复（R2）ACT / 360-确切的天数除以360。 <br><br>  <strong>规则（W4）实际/ 364。</strong> 天数除以364。在俄语国家中没有类似的天数。 <br><br>  <strong>规则（W5）实际/ 365L。</strong> 它包含两个调整： <br><ol><li> 每年付款。 如果日期是该时间段内的2月29日，则该时间段的天数除以年度除数366，如果不是，则除以365。在这种情况下，它与规则（R5）ACT / ACT“简短修改”相吻合。 </li><li> 如果付款频率与年度不同。 如果结束日期是a年（不一定等于2月29日），则年度除数为366，否则为365。在俄语国家中，没有类似的数字。 </li></ol><br> 另一个名称是ISMA-Year。 <br><br>  <strong>规则（W6）实际/实际AFB。</strong> 它包含两个调整： <br><ol><li> 少于一年的期间的主要日期：如果日期是该期间内的2月29日，则该期间的天数除以年度除数366，否则除以365。 。 </li><li> 延长，期限超过一年：从结束日期到开始日期，会计算一个整数整年。 如果余额少于一年，则适用主要规则。 总结了基本规则下的完整年份数和年度份额。 <br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果倒数是在2月28日进行的，那么在倒数年前存在细微差别，而整整整整一年之后，该年被证明是be年。</font><font style="vertical-align: inherit;">在这种情况下，应该采用n年前的日期为2月29日。</font><font style="vertical-align: inherit;">我补充说，如果倒计时是从2月29日开始进行的，那么整整年前的数字不是4的倍数，因此，前一年也不是a年，这也是一个问题。</font><font style="vertical-align: inherit;">我在这里没有详细介绍。</font><font style="vertical-align: inherit;">但是您可以参考[2]中的链接。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有“樱桃蛋糕” </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则（W7）1/1。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">天数除以年度除数365.25。</font><font style="vertical-align: inherit;">用于与通货膨胀有关的计算。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 预计天数 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面列出的规则是基于日历天数的确切持续时间。但是，有时会基于所谓的简化的或近似的天数计数方案。这些计划的目的是使所有月份的持续时间“平均”到30天。因此，一年将由30天的12个月组成，即在360天之内。因此，这些规则的年度除数（分数的分母）将始终为360，并且分子以特殊方式计算。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于在大多数情况下（但当然并非总是），贷款的确切天数不只是近似值（可以通过确定一年中一个月的平均天数来轻松看出，即30.44），因此通常使用贷款的确切天数来计算利息增长比估计要大。 [4]</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此规则的最简单版本，即所谓的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本规则30/360</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，描述如下（以下是有关书[1]-俄语实践的信息）：</font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本规则30/360。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日期之间的大概天数是</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 360 *（y2-y1）+ 30 *（m2-m1）+（d2-d1）， </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y，m，d-第二和第一个日期中的年，月和日。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该规则出现在创建第一个计算设备之前，并在财务实践中大大节省了计算操作的成本。</font><font style="vertical-align: inherit;">尽管现在对简化方法的需求已经消失，但是在实践中已经站稳了脚跟，根据传统，它们有时在当前使用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该规则适用于强制性的修改指示，该修改指示了如何处理月份的最后几天：</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 俄语练习 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由[1]给出。</font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则（R6）30/360 ISDA。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果d1 = 31，则d1'= 30，否则d1'= d1。</font><font style="vertical-align: inherit;">如果d2 = 31且d1'= 30，则d2'= 30，否则d2'= d2。</font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则（R7）30E / 360。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果d1 = 31，则d1'= 30，否则d1'= d1。</font><font style="vertical-align: inherit;">如果d2 = 31，则d2'= 30，否则d2'= d2。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此规则是ISDA规则30/360的变体，主要在欧洲使用，因此在该规则的名称中标有“ E”。</font><font style="vertical-align: inherit;">仅当第二个日期也是31日时，它才与ISDA规则30/360不同。</font><font style="vertical-align: inherit;">欧洲版本始终将其转换为第30个数字，而不管第一个日期如何。</font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则（R8）30/360 PSA。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果d1 = 31或d1是2月的最后一天，则d1'= 30，否则d1'= d1。</font><font style="vertical-align: inherit;">如果d2 = 31且d1'= 30，则d2'= 30，否则d2'= d2。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1]中对30/360 SIA规则的描述很可能是错误的，因此在此不再赘述。 </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 西方实践 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据[2]给出。</font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则（W8）30/360保证金基础。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与（R6）30/360 ISDA相同。其他名称：30A / 360。</font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则（W9）30E / 360。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与（R7）30E / 360相同。其他名称：30/360 ICMA，30S / 360，以欧洲债券为基础（ISDA 2006），特殊德语。</font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则（W10）30E / 360 ISDA。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果d1是该月的最后一天，则d1'= 30。如果d2是非二月的最后一天，则d2'= 30。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他名称：30E / 360 ISDA，基于欧洲债券的标准（ISDA 2000），德语。</font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则（W11）30/360 SIA。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果d1是2月的最后一天，而d2是2月的最后一天，则d2'= 30。如果d1 = 31或2月的最后一天，则d1'= 30，否则d1'= d1。如果d1'= 30且d2 = 31，则d2'= 30，否则d2'= d1。</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则（R4）ACT / ACT，（W1）实际/实际ISDA，（W2）实际/ 365固定规则也称为“英语练习”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则（R2）ACT / 360和（W3）实际/ 360也称为“法语练习”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则（R7）30E / 360，（W9）30E / 360和（W10）30E / 360 ISDA也称为“德国惯例”或“德国惯例”。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，考虑到确切的利息和普通的利息，以及计算利息的确切和近似的天数，我们得到了四种计算简单利息的方法（规则的名称在俄语中表示）：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 具有确切天数的正常利息（ACT / 360-银行业务规则）， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 确切的百分比以及确切的天数（ACT / 365，ACT / ACT）， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 正常的利息，大约为几天（30/360）， </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 大约有几天的确切百分比。 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最常用的第一种方法称为银行法则，第二种和第三种方法较少见，而第四种则几乎没有。 [4]说：“ ...具有确切利率和大约贷款天数的计算选项是没有意义的，并不适用。” </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以上对周期的近似持续时间（以一年的分数表示）的计算显示了所应用规则的简单性和多样性。它们的应用（以及原产地）取决于国家，货币，金融工具的类型，专业协会，协议。 [1] </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论：</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在乌克兰的公共事业中，我如何算上3％？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浅析艺术运用的司法实践。乌克兰《民法》第625条指出，通常使用（R1）ACT / 365 [3]方法，但方法尚不明确。我认为您仍然需要申请（R4）ACT / ACT，这就是为什么：如果您使用ACT / 365方法在整个leap年中应计3％，那么利息金额将等于3.008219％，这是债务（或贷款主体的规模）一百万个货币单位将产生CU 82.19的盈余法律规定的年度标准利率超过3％。随着利息的逐步积累，这将变得尤为重要。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我将不胜感激，尤其是银行员工的意见。</font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用的资料来源</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1）Bocharov，P.P.，Kasimov，Yu.F.金融数学。莫斯科：加尔达基，2002年</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2）日计数惯例，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zh.wikipedia.org/wiki/Day_count_convention</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3）艺术应用分析。乌克兰《民法典》第625条的民事诉讼程序，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zib.com.ua / ua / 74602-analiz_praktiki_zastosuvannya_st_625_civilnogo_kodeksu_ukrai.html</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4）Chetyrkin E.M.金融数学。莫斯科：案例，2005年</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5）日计数惯例和应计因素，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docs.fincad.com</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / support / developerfunc / mathref / Daycount.htm 6）乌克兰最高经济法院的通知信，日期为01-06 / 928/2012，日期为2012年7月17日，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zakon.rada.gov.ua/laws/show/v_928600-12</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在在Oracle数据库上有一些代码：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是我为我的特殊情况制作的一个软件包-它计算通货膨胀成本和乌克兰每年3％。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle数据库中没有聚合函数可乘以通货膨胀值。</font><font style="vertical-align: inherit;">因此，我使用对数的总和。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐藏文字</font></font></b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, OVERHEAD_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>), INF_RATE_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> , INF_COEF_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_MONTH <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_DAYS <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_DAY <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_BEGIN_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> , PCT_YEAR_END_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR_DAYS_CALC <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_AMOUNT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_OVERHEAD_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_PCT_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ret_value DEBT_WITH_INF_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.ID, a.DEBT_DATE, a.DEBT_AMOUNT, a.PAYMENT_DATE, b.INF_MONTH, c.AVAL <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> add_months (trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= months_between (trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>) b <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> INFLATION c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.ADATE = b.INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.TYP = <span class="hljs-string"><span class="hljs-string">'M'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE , <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SKIP_INFLATION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T is ret_value DEBT_WITH_INF_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION , <span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>)) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date))) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED , (INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_COEF_ACCUMULATED , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (((INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED, INF_COEF_ACCUMULATED, INF_AMOUNT_ACCUMULATED , INF_AMOUNT_ACCUMULATED - lag (INF_AMOUNT_ACCUMULATED, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> , DEBT_DATE , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>))) - <span class="hljs-number"><span class="hljs-number">1</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, INF_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T is ret_value DEBT_WITH_PCT_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) - <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) - <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) , T3 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS , <span class="hljs-number"><span class="hljs-number">0.03</span></span> / PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2) , T4 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY , <span class="hljs-keyword"><span class="hljs-keyword">greatest</span></span> (PAYMENT_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_BEGIN_DATE , <span class="hljs-keyword"><span class="hljs-keyword">least</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>), p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_END_DATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T3) , T5 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE , PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS_CALC , (PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_YEAR , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_AMOUNT_PER_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T4) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_PCT_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE, PCT_YEAR_DAYS_CALC, PCT_YEAR_PCT_PER_YEAR, PCT_AMOUNT_PER_YEAR) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T5; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (PCT_AMOUNT_PER_YEAR)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN466401/">https://habr.com/ru/post/zh-CN466401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN466379/index.html">在微控制器上运行“桌面”软件</a></li>
<li><a href="../zh-CN466381/index.html">时代LED灯泡在2019年如何变化</a></li>
<li><a href="../zh-CN466383/index.html">Cryptocurrency Ocean：使用CoinMarketCap审查前50个项目</a></li>
<li><a href="../zh-CN466385/index.html">了解消息代理。 通过ActiveMQ和Kafka学习消息传递的机制。 第一章</a></li>
<li><a href="../zh-CN466397/index.html">我们对收银员进行重新编程，并在其上打印基努·里夫斯。 第2部分。PC软件</a></li>
<li><a href="../zh-CN466403/index.html">培训Cisco 200-125 CCNA v3.0。 第35天。动态DTP中继协议</a></li>
<li><a href="../zh-CN466405/index.html">培训Cisco 200-125 CCNA v3.0。 第36天。频道协议STP</a></li>
<li><a href="../zh-CN466407/index.html">大型Glassdoor统计公司的招聘文化</a></li>
<li><a href="../zh-CN466409/index.html">培训Cisco 200-125 CCNA v3.0。 第37天。STP：选择根网桥，PortFast和BPDU保护功能。 第一部分</a></li>
<li><a href="../zh-CN466413/index.html">Bitrix和1C的站点交换：解决主要问题</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>