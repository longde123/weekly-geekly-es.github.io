<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐰 🏀 ㊗️ Prueba de la unidad de serialización Json en Spring Boot ㊙️ 👸🏼 🐠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Una de las tareas principales de cada servicio web es devolver el modelo al lado del cliente y, en este caso, Spring Boot proporciona u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prueba de la unidad de serialización Json en Spring Boot</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452188/"><img src="https://habrastorage.org/webt/wb/jv/d1/wbjvd1ajjlmxvobtph6_9p6sutk.png"><br><br><h2>  Introduccion </h2><br>  Una de las tareas principales de cada servicio web es devolver el modelo al lado del cliente y, en este caso, <i>Spring Boot</i> proporciona un nivel conveniente de abstracción, lo que permite al desarrollador permanecer en el nivel de trabajo con los modelos y dejar el proceso de serialización del modelo fuera del código fuente del programa.  Pero, ¿qué sucede si la serialización en sí se convierte en parte de la lógica comercial de la aplicación y, por lo tanto, requiere cobertura de caso de prueba? <br><br>  Este artículo examinará uno de los escenarios cuando tengamos que tener en cuenta las peculiaridades de la lógica empresarial de la aplicación durante la serialización (el escenario de redondeo de cantidades de dinero), en cuyo ejemplo encontraremos el mecanismo de serialización en Spring Boot, y también describiremos un posible método de prueba. <br><a name="habracut"></a><br><h2>  Declaración del problema. </h2><br>  Deje que nuestro servicio web sea responsable de proporcionar información sobre los gastos de los clientes, y debemos proporcionar datos con una precisión configurable.  Una solución lógica sería realizar todas las transformaciones del modelo en la periferia del servicio, mientras se conserva la visibilidad de aplicar la lógica de redondeo. <br><br><h2>  Considere una posible solución </h2><br>  Imagine el controlador de nuestra aplicación, que devolverá el modelo deseado. <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AccountController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        , //       . @Autowired private AccountService accountService; @RequestMapping(value = "/account/{clientId}", method = RequestMethod.GET, produces = "application/json") public Account getAccount(@PathVariable long clientId) throws Exception { Account result = accountService.getAccount(clientId); //  ,    - //      ,    json, //    . return result; } }</span></span></code> </pre> <br>  Ahora echemos un vistazo a nuestro modelo. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Account</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long clientId; <span class="hljs-comment"><span class="hljs-comment">//    Spring Boot   FasterXML/jackson, //    API  ,   . // ,       //     MoneySerializer @JsonSerialize(using = MoneySerializer.class) private BigDecimal value; //    getter'  setter'    }</span></span></code> </pre><br>  Es posible que ya haya tenido que lidiar con otras anotaciones para la personalización.  Una característica de esta anotación es la capacidad de determinar su servicio responsable de serializar el campo modelo anotado. <br><br>  Antes de ver de qué se trata un serializador, complicaremos la tarea: dejar que los parámetros de redondeo sean configurables a través de algún servicio interno que abstraiga cualquier manifestación de resolución dinámica de parámetros. <br><br>  Esta complicación es nuestro punto clave que queremos considerar.  Como podemos ver en la implementación del modelo, la API de nuestro marco toma una clase de serialización en el argumento, lo que significa que el ciclo de vida del serializador queda bajo el control del marco del serializador.  Esto plantea la pregunta, ¿qué hacer si queremos inyectar la dependencia del contexto de nuestra aplicación en el serializador?  Para hacer esto, considere la implementación del serializador anterior. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     , //  Jackson   Spring, // API    //    Spring DI @JsonComponent public class MoneySerializer extends JsonSerializer&lt;BigDecimal&gt; { //  ,   , //    Spring Boot    Bean'. private RoundingHolder roundingHolder; @Autowired public MoneySerializer(RoundingHolder roundingHolder) { this.roundingHolder = roundingHolder; } //       , // ,   ,      - //      . @Override public void serialize(BigDecimal value, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException { jsonGenerator.writeNumber(value.setScale(roundingHolder.getPrecision(), roundingHolder.getRoundingMode())); } }</span></span></code> </pre><br>  Nuestro servicio está listo, pero como desarrolladores responsables, queremos asegurarnos de que la cocina que ensamblamos funcione. <br><br><h2>  Pasemos a las pruebas. </h2><br>  Veamos qué nos ofrece la API de framework de prueba. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,   //    Spring,       . //     JsonTest,      //      , //    JSON-. @JsonTest @ContextConfiguration(classes = {AccountSerializationTest.Config.class}) @RunWith(SpringRunner.class) public class AccountSerializationTest { //  ,      //     ObjectMapper,    . //       . //    , //      . @Autowired private ObjectMapper objectMapper; @Test public void testAccountMoneyRounding() throws Exception { Account account = new Account(); account.setClientId(1L); account.setValue(BigDecimal.valueOf(1.123456789)); String expectedResult = "{\"clientId\":1,\"value\":\1.123\}"; // ,          JSON, //     -. assertEquals(expectedResult, objectMapper.writeValueAsString(account)); } //   MoneySerializer   API  //    ,       //    Jackson.   ,   , //   Spring , ,  //      . @TestConfiguration public static class Config { @Bean public static RoundingHolder roundingHolder() { RoundingHolder roundingHolder = Mockito.mock(RoundingHolder.class); //   ,         Mockito.when(roundingHolder.getMathContext()).thenReturn(new MathContext(3, RoundingMode.HALF_EVEN)); return roundingHolder; } } }</span></span></code> </pre><br>  Detengámonos en este momento con más detalle.  Jackson usa la clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ObjectMapper</a> para serializar y deserializar modelos.  Este es exactamente el objeto de contexto responsable de la transformación de los modelos, por lo tanto, para asegurarse de cómo se presentará el modelo, debe verificar cómo ObjectMapper lo procesa desde el contexto. <br><br>  Si desea crear su propio ObjectMapper personalizado, puede encontrar el siguiente ejemplo típico: <i>ObjectMapper mapper = new ObjectMapper</i> .  Sin embargo, observe cómo Spring Boot crea una instancia de esta clase de forma predeterminada.  Para hacer esto, pasamos al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">código</a> original de autoconfiguración <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JacksonAutoConfiguration</a> , que es responsable de crear el objeto: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ObjectMapper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jacksonObjectMapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Jackson2ObjectMapperBuilder builder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builder.createXmlMapper(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).build(); }</code> </pre><br>  Y si vamos más allá y miramos <i>build ()</i> , encontramos que para la serialización, a la que podríamos acostumbrarnos cuando trabajamos con el mapeador predeterminado (como inyectar servicios en un serializador personalizado), no es suficiente crear un mapeador Bean, debe recurrir al constructor proporcionado .  Por cierto, en la propia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación de</a> Spring Boot, esto se establece explícitamente. <br><br>  Por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">digresión,</a> me gustaría agregar una referencia a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JacksonTester</a> .  Como representante del shell para las pruebas de serialización de BDD en el contexto de Mockito. <br><br><h2>  Para resumir </h2><br><ul><li>  Spring Boot proporciona la capacidad de personalizar la serialización del modelo a través de anotaciones JsonSerializer </li><li>  Para probar la serialización, use el asignador en la misma configuración que en la aplicación </li><li>  Al anular un bean de la configuración automática de Spring Boot, preste atención a cómo este bean crea Spring Boot, para no perder las oportunidades que tenía el bean predeterminado </li><li>  Puede usar la anotación JsonTest para especificar el contexto limitado requerido para probar la serialización. </li></ul><br><h2>  Conclusión </h2><br>  Gracias por su atencion!  Este ejemplo será relevante para la versión actual de Spring Boot 2.1.x, así como para versiones anteriores hasta 1.4.x.  Además, la técnica es adecuada para situaciones con deserialización del modelo.  Mire bajo el capó de sus marcos centrales para una mejor comprensión del mecanismo de operación de la aplicación y adopte un enfoque responsable para las pruebas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452188/">https://habr.com/ru/post/452188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452178/index.html">Análisis: 23 errores populares en inglés escrito y cómo evitarlos</a></li>
<li><a href="../452180/index.html">Elevamos el rendimiento de SSD desde las rodillas, dónde hacer clic y por qué</a></li>
<li><a href="../452182/index.html">Encuesta de empleados. El principal error</a></li>
<li><a href="../452184/index.html">Sobre el anonimato en blockchains basados ​​en cuentas</a></li>
<li><a href="../452186/index.html">Los lenguajes de programación más raros y caros</a></li>
<li><a href="../452190/index.html">Uso de la aplicación web WebAssembly 20x acelerada</a></li>
<li><a href="../452192/index.html">¿Qué es esto aquí? Operación interna de objetos JavaScript</a></li>
<li><a href="../452198/index.html">¿Qué debe saber todo ingeniero de control de calidad sobre Selenium 4?</a></li>
<li><a href="../452200/index.html">GOSTIM: P2P F2F E2EE IM en una noche con criptografía GOST</a></li>
<li><a href="../452202/index.html">Revisión de Sprint: Inferior - Inferior</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>