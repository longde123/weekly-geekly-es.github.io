<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏻 🏩 👩🏾‍🤝‍👨🏻 6 pelajaran dari menemukan solusi untuk masalah besar di gitlab.com. Bagian 1 👩🏻‍🏭 ⛏️ 🍒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Materi, bagian pertama dari terjemahan yang kami terbitkan hari ini, dikhususkan untuk masalah skala besar yang muncul di gitlab.com. Di sini kita aka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>6 pelajaran dari menemukan solusi untuk masalah besar di gitlab.com. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/466555/">  Materi, bagian pertama dari terjemahan yang kami terbitkan hari ini, dikhususkan untuk masalah skala besar yang muncul di gitlab.com.  Di sini kita akan berbicara tentang bagaimana mereka menemukannya, bagaimana mereka bertarung dengannya, dan bagaimana, akhirnya, mereka menyelesaikannya.  Selain itu, dihadapkan dengan masalah ini, tim gitlab.com menemukan apa tirani jam tangan itu. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/qk/zt/9j/qkzt9jqmpe2gmprxe33pdce_3kq.jpeg"></a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedua</a> . <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Masalah</font> </h2><br>  Kami mulai menerima pesan dari klien bahwa, ketika bekerja dengan gitlab.com, mereka secara berkala mengalami kesalahan saat menjalankan permintaan tarik.  Kesalahan biasanya terjadi ketika melakukan tugas CI atau selama operasi sistem otomatis serupa lainnya.  Pesan kesalahan terlihat seperti ini: <br><br><pre><code class="plaintext hljs">ssh_exchange_identification: connection closed by remote host fatal: Could not read from remote repository</code> </pre> <br>  Situasi ini semakin rumit oleh fakta bahwa pesan kesalahan muncul tidak teratur dan, sepertinya, tidak dapat diprediksi.  Kami tidak dapat mereproduksi mereka sesuka hati, tidak bisa mengidentifikasi tanda-tanda yang jelas tentang apa yang terjadi di grafik atau di log.  Pesan kesalahan itu sendiri tidak membawa banyak manfaat juga.  Klien SSH diberitahu bahwa koneksi terputus, tetapi alasannya bisa apa saja: klien gagal atau mesin virtual tidak stabil, firewall yang tidak kami kontrol, tindakan penyedia aneh atau masalah dengan aplikasi kami. <br><br>  Kami, yang bekerja pada skema GIT-over-SSH, berurusan dengan sejumlah besar koneksi - sekitar 26 juta per hari.  Ini rata-rata 300 koneksi per detik.  Oleh karena itu, upaya untuk memilih sejumlah kecil koneksi gagal dari aliran data yang ada berjanji akan menjadi tugas yang sulit.  Hal yang baik tentang situasi ini adalah kami ingin menyelesaikan masalah yang rumit. <br><br><h2>  <font color="#3AC1EF">Petunjuk pertama</font> </h2><br>  Kami menghubungi salah satu klien kami (terima kasih kepada Hubert Holtz dari Atalanda), yang menemukan masalah beberapa kali sehari.  Ini memberi kami pijakan.  Hubert dapat memberi kami alamat IP publik yang sesuai.  Ini berarti bahwa kami dapat menangkap paket pada node front-end HAProxy kami untuk mencoba mengisolasi masalah dengan mengandalkan dataset yang lebih kecil dari apa yang disebut "semua lalu lintas SSH".  Bahkan lebih baik, perusahaan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">port ssh-alternatif</a> .  Ini berarti bahwa kami perlu menganalisis keadaan hanya pada dua server HAProxy, dan bukan pada enam belas. <br><br>  Analisis paket, bagaimanapun, tidak terlalu menyenangkan.  Meskipun ada pembatasan dalam waktu 6,5 jam, sekitar 500 paket MB dikumpulkan.  Kami menemukan senyawa berumur pendek.  Koneksi TCP dibuat, klien mengirim pengenal, setelah itu server HAProxy kami segera terputus menggunakan urutan TCP FIN yang benar.  Sebagai hasilnya, kami memiliki petunjuk bagus pertama.  Dia mengizinkan kami untuk menyimpulkan bahwa koneksi sudah pasti ditutup atas inisiatif gitlab.com, dan bukan karena sesuatu antara kami dan klien.  Ini berarti bahwa kami dihadapkan dengan masalah yang dapat kami selidiki dan perbaiki. <br><br>  <b>Pelajaran nomor 1.</b>  Menu Statistik alat Wireshark memiliki banyak alat yang berguna yang saya, sebelum kasus ini, belum terlalu memperhatikan. <br><br>  Secara khusus, kita berbicara tentang item menu <code>Conversations</code> , yang dapat menunjukkan informasi dasar tentang data yang diambil tentang koneksi TCP.  Ada informasi tentang waktu, paket, byte.  Data yang ditampilkan di jendela yang sesuai dapat diurutkan.  Saya harus menggunakan alat ini sejak awal alih-alih mengacak data yang diambil secara manual.  Kemudian saya menyadari bahwa saya perlu mencari koneksi dengan sejumlah kecil paket.  Jendela <code>Conversations</code> memungkinkan Anda untuk segera memperhatikannya.  Setelah itu, saya dapat menemukan senyawa serupa lainnya dan memastikan bahwa koneksi pertama itu bukan fenomena abnormal. <br><br><h2>  <font color="#3AC1EF">Perendaman log</font> </h2><br>  Apa yang menyebabkan HAProxy terputus dari klien?  Server, tentu saja, tidak melakukan ini dengan cara yang sewenang-wenang; apa yang terjadi seharusnya memiliki alasan yang lebih dalam;  jika Anda suka - "tingkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kura</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kura lain</a> ."  Ada perasaan bahwa objek penelitian selanjutnya adalah log HAProxy.  Log kami disimpan di GCP BigQuery.  Ini nyaman, karena kami memiliki banyak log, dan kami perlu menganalisisnya secara komprehensif.  Tetapi pertama-tama, kami dapat mengidentifikasi entri log untuk salah satu insiden, yang ditemukan dalam paket yang ditangkap.  Kami mengandalkan waktu dan port TCP, yang merupakan pencapaian utama dalam penelitian kami.  Detail paling menarik dalam catatan yang ditemukan adalah <code>t_state</code> (Termination State), yang memiliki nilai <code>SD</code> .  Berikut ini kutipan dari dokumentasi HAProxy: <br><br><pre> <code class="plaintext hljs">    S:  ,     .    D:     DATA.</code> </pre> <br>  Arti makna <code>D</code> dijelaskan dengan sangat sederhana.  Koneksi TCP dibuat dengan benar, data dikirim.  Ini bertepatan dengan bukti yang diperoleh dari paket yang ditangkap.  Nilai <code>S</code> berarti bahwa HAProxy menerima pesan kegagalan ICT, atau ICMP dari backend.  Tetapi kami tidak dapat segera menemukan petunjuk mengapa ini terjadi.  Alasan untuk ini bisa apa saja - dari jaringan yang tidak stabil (misalnya, kegagalan atau kemacetan) ke masalah tingkat aplikasi.  Menggunakan BigQuery untuk mengumpulkan data pada backend Git, kami menemukan bahwa masalahnya tidak terkait dengan mesin virtual tertentu.  Kami membutuhkan lebih banyak informasi. <br><br>  Saya ingin mencatat bahwa entri log dengan nilai <code>SD</code> bukanlah sesuatu yang istimewa, karakteristik hanya untuk masalah kita.  Pada port alternatif-ssh, kami menerima banyak permintaan terkait pemindaian HTTPS.  Ini mengarah pada fakta bahwa nilai <code>SD</code> jatuh ke log ketika server SSH melihat pesan <code>TLS ClientHello</code> sementara itu diharapkan untuk menerima salam SSH.  Ini secara singkat mengarahkan penyelidikan kami secara tidak langsung. <br><br>  Setelah menangkap beberapa lalu lintas antara HAProxy dan server Git dan lagi menggunakan alat Wireshark, kami dengan cepat menemukan bahwa SSHD pada server Git terputus dari TCP FIN-ACK segera setelah jabat tangan tiga arah TCP.  HAProxy masih tidak mengirim paket data pertama, tetapi akan melakukannya.  Ketika dia mengirim paket, server Git menjawabnya dengan TCP RST.  Akibatnya - sekarang kami telah menemukan alasan mengapa HAProxy menulis ke log tentang kegagalan koneksi dengan nilai <code>SD</code> .  SSH menutup koneksi, melakukannya dengan sengaja dan benar, dan RST hanyalah artefak dari fakta bahwa server SSH menerima paket setelah FIN-ACK.  Itu tidak berarti apa-apa lagi. <br><br><h2>  <font color="#3AC1EF">Jadwal fasih</font> </h2><br>  Melihat dan menganalisis log dengan nilai <code>SD</code> di BigQuery, kami menyadari bahwa kesalahan memiliki hubungan yang jelas dengan waktu.  Yaitu, kami menemukan puncak dalam jumlah koneksi yang gagal dalam 10 detik pertama setiap menit.  Mereka diamati selama 5-6 detik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/788/a83/19d/788a8319de4af6f082786f673f6bbb65.png"><br>  <i><font color="#999999">Kesalahan koneksi dikelompokkan dalam beberapa menit hingga detik</font></i> <br><br>  Bagan ini didasarkan pada data yang dikumpulkan selama berjam-jam.  Fakta bahwa pola distribusi kesalahan yang terdeteksi ternyata stabil menunjukkan bahwa penyebab kesalahan secara stabil memanifestasikan dirinya dalam menit dan jam individu, dan, bahkan mungkin lebih buruk, itu stabil muncul pada waktu yang berbeda dalam sehari.  Sangat menarik bahwa ukuran puncak rata-rata sekitar 3 kali lebih besar dari beban dasar.  Ini berarti bahwa kami dihadapkan pada masalah penskalaan yang tidak sepele.  Akibatnya, hanya menghubungkan "lebih banyak sumber daya" dalam bentuk mesin virtual tambahan, yang dirancang untuk membantu kami mengatasi beban puncak, secara teoritis bisa menjadi sangat mahal.  Ini juga menunjukkan bahwa kita sedang mencapai semacam batasan yang parah.  Sebagai hasilnya, kami menerima petunjuk pertama tentang masalah sistemik mendasar yang menyebabkan kesalahan.  Saya menyebutnya tirani jam. <br><br>  Cron atau sistem penjadwalan serupa seringkali tidak berbeda dalam kemampuan untuk menyesuaikan pelaksanaan tugas ke detik terdekat.  Jika sistem tersebut memiliki kemampuan seperti itu, mereka tidak sering digunakan karena fakta bahwa orang lebih suka mempertimbangkan waktu, dibagi menjadi beberapa interval, dinyatakan dengan angka bulat yang indah.  Akibatnya, tugas dimulai pada awal menit atau jam, atau pada saat-saat serupa lainnya.  Jika tugas tersebut memerlukan beberapa detik untuk menyiapkan perintah <code>git fetch</code> untuk mengunduh materi dari gitlab.com, ini dapat menjelaskan pola yang kami temukan ketika beban pada sistem meningkat tajam selama beberapa detik setiap menit.  Pada saat-saat seperti itu, jumlah kesalahan bertambah. <br><br>  <b>Pelajaran nomor 2.</b>  Banyak orang, tampaknya, menggunakan sinkronisasi waktu yang dikonfigurasi dengan benar (melalui NTP atau menggunakan mekanisme lain). <br><br>  Jika tidak ada yang menyinkronkan waktu, maka masalah kita tidak akan terwujud dengan jelas.  Selamat siang, NTP! <br><br>  Tapi apa yang menyebabkan SSH terputus? <br><br><h2>  <font color="#3AC1EF">Lebih dekat ke inti masalah</font> </h2><br>  Mempelajari dokumentasi <code>MaxStartups</code> , kami menemukan parameter <code>MaxStartups</code> .  Ini mengontrol jumlah maksimum koneksi yang tidak diautentikasi.  Tampaknya masuk akal bahwa batas koneksi habis ketika pada awal menit sistem mengalami beban yang dibuat oleh kesibukan panggilan tugas terjadwal dari seluruh Internet.  Parameter <code>MaxStartups</code> terdiri dari tiga angka.  Yang pertama adalah batas bawah (jumlah koneksi saat mencapai yang istirahat dalam koneksi dimulai).  Yang kedua adalah persentase senyawa yang melebihi batas bawah senyawa yang perlu dipecah secara acak.  Nilai ketiga adalah jumlah maksimum koneksi absolut, setelah semua koneksi baru ditolak.  Nilai default MaxStartups terlihat seperti 10: 30: 100, pengaturan kami kemudian terlihat seperti 100: 30: 200.  Ini menunjukkan bahwa di masa lalu kami telah meningkatkan batas koneksi standar.  Mungkin - saatnya untuk meningkatkannya lagi. <br><br>  Ternyata sedikit tidak menyenangkan karena OpenSSH 7.2 diinstal pada server kami, satu-satunya cara untuk mencapai batas yang ditentukan dalam <code>MaxStartups</code> adalah dengan beralih ke level debugging <code>Debug</code> .  Dengan pendekatan ini, longsoran data masuk ke dalam log.  Karena itu, kami secara singkat mengaktifkan mode ini di salah satu server.  Untungnya, setelah beberapa menit, menjadi jelas bahwa jumlah koneksi melebihi batas yang ditetapkan dalam <code>MaxStartups</code> , sebagai akibatnya terjadi pemutusan awal. <br><br>  Ternyata di OpenSSH 7.6 (versi ini hadir dengan Ubuntu 18.04) pendekatan yang lebih nyaman untuk mencatat apa yang terkait dengan <code>MaxStartups</code> .  Di sini Anda hanya perlu beralih ke mode logging <code>Verbose</code> .  Meskipun tidak ideal, itu masih lebih baik daripada beralih ke level <code>Debug</code> . <br><br>  <b>Pelajaran nomor 3.</b>  Ini dianggap sebagai bentuk yang baik untuk menulis informasi menarik ke log di tingkat logging standar, dan informasi tentang pemutusan yang disengaja untuk alasan apa pun tentu menarik bagi administrator sistem. <br><br>  Sekarang kami telah menemukan penyebab masalah, muncul pertanyaan tentang bagaimana menyelesaikannya.  Kita dapat meningkatkan nilai dalam parameter <code>MaxStartups</code> , tetapi berapa biayanya?  Tentu saja, ini akan membutuhkan sedikit memori tambahan, tetapi apakah itu akan menimbulkan konsekuensi yang merugikan di bagian-bagian sistem di mana permintaan diproses?  Kami hanya bisa memikirkannya, jadi kami memutuskan untuk mengambil dan hanya mencoba pengaturan <code>MaxStartups</code> baru.  Yaitu, kami menukar mereka dengan yang berikut: 150: 30: 300.  Sebelumnya, mereka terlihat seperti 100: 30: 200, yaitu - kami meningkatkan jumlah koneksi hingga 50%.  Ini memiliki efek positif yang kuat pada sistem.  Pada saat yang sama, beberapa efek negatif, seperti meningkatkan beban pada prosesor, tidak diamati. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/616/59e/d44/61659ed4470148fb4bc6d6f0115becb7.png"><br>  <i><font color="#999999">Jumlah kesalahan sebelum dan sesudah meningkatkan MaxStartups sebesar 50%</font></i> <br><br>  Perhatikan pengurangan kesalahan yang signifikan setelah stempel waktu 1:15.  Ini jelas menunjukkan bahwa kami dapat menyingkirkan sebagian besar kesalahan, meskipun beberapa dari mereka masih ada.  Sangat menarik untuk dicatat bahwa kesalahan dikelompokkan di sekitar cap waktu yang diwakili oleh angka bulat yang indah.  Ini adalah awal dari jam, setiap 30, 15 dan 10 menit.  Tidak diragukan lagi, tirani arloji terus berlanjut.  Pada awal setiap jam, puncak kesalahan tertinggi diamati.  Ini, mengingat apa yang sudah kita ketahui, terlihat cukup bisa dimengerti.  Banyak orang hanya berencana untuk menjalankan tugas setiap jam yang berjalan 0 menit setelah dimulainya jam.  Fakta ini mengkonfirmasi teori kami bahwa puncak kesalahan disebabkan oleh peluncuran tugas yang dijadwalkan.  Ini menunjukkan bahwa kami berada di jalur yang benar dalam menyelesaikan masalah dengan menyesuaikan batas sistem. <br><br>  Untuk kesenangan kami, mengubah batas <code>MaxStartups</code> tidak menyebabkan efek negatif yang nyata.  Penggunaan CPU pada server SSH tetap pada tingkat yang sama seperti sebelumnya, beban pada sistem kami juga tidak meningkat.  Itu sangat bagus, mengingat kami sekarang menerima lebih banyak koneksi, dari koneksi yang sebelumnya sudah rusak.  Selain itu, situasinya tidak diperburuk oleh fakta bahwa kami melakukan ini pada saat sistem kami sangat banyak dimuat.  Semuanya tampak menjanjikan. <br><br>  Dilanjutkan ... <br><br>  <b>Pembaca yang budiman!</b>  Alat apa yang Anda gunakan untuk menganalisis lalu lintas dan log? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466555/">https://habr.com/ru/post/id466555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466543/index.html">Pinjaman Habr Weekly # 17 / Sberbank akan disetujui oleh AI - menakutkan, beriklan di produk sumber terbuka - diragukan</a></li>
<li><a href="../id466547/index.html">Selamat Hari Programmer</a></li>
<li><a href="../id466549/index.html">Prinsip umum pengoperasian QEMU-KVM</a></li>
<li><a href="../id466551/index.html">Dalang dengan ES6 di node dan browser, atau mengapa Zora adalah kerangka uji terbaik di ceruknya</a></li>
<li><a href="../id466553/index.html">6 pelajaran dari menemukan solusi untuk masalah besar di gitlab.com. Bagian 2</a></li>
<li><a href="../id466559/index.html">Biarkan adalah Var baru</a></li>
<li><a href="../id466561/index.html">Butuh pilihan yang benar-benar transparan? - Saya memilikinya</a></li>
<li><a href="../id466563/index.html">KOST: apa yang termasuk dalam tumpukan teknologi baru untuk mengembangkan aplikasi cloud</a></li>
<li><a href="../id466565/index.html">Python + OpenCV + Keras: membuat pengenalan teks dalam setengah jam</a></li>
<li><a href="../id466567/index.html">Toolkit untuk penyedia: webinar tematik tentang sistem untuk bekerja dengan lalu lintas dan konfigurasi mereka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>