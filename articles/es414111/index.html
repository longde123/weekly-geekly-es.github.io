<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë©üèª ‚úäüèΩ üë®üèø Depuraci√≥n y soluci√≥n de problemas en PostgreSQL Streaming Replication üïì ‚ÜóÔ∏è üç™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La replicaci√≥n de secuencias, que apareci√≥ en 2010, se ha convertido en una de las caracter√≠sticas innovadoras de PostgreSQL y, en la actualidad, casi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Depuraci√≥n y soluci√≥n de problemas en PostgreSQL Streaming Replication</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/414111/">  La replicaci√≥n de secuencias, que apareci√≥ en 2010, se ha convertido en una de las caracter√≠sticas innovadoras de PostgreSQL y, en la actualidad, casi ninguna instalaci√≥n puede funcionar sin el uso de la replicaci√≥n de secuencias.  Es confiable, f√°cil de configurar, poco exigente con los recursos.  Sin embargo, a pesar de todas sus cualidades positivas, durante su funcionamiento pueden surgir varios problemas y situaciones desagradables. <br><br>  <strong>Alexey Lesovsky</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@lesovsky</a> ) en Highload ++ 2017 dijo c√≥mo <strong>diagnosticar varios tipos de problemas</strong> utilizando herramientas integradas y de terceros <strong>y c√≥mo solucionarlos</strong> .  Seg√∫n los recortes, la decodificaci√≥n de este informe, construida sobre la base de un principio espiral: primero, enumeramos todas las herramientas de diagn√≥stico posibles, luego pasamos a enumerar problemas comunes y diagnosticarlos, luego vemos qu√© medidas de emergencia se pueden tomar y finalmente c√≥mo abordar el problema radicalmente. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/on2yVvKejwc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador</strong> : Alexei Lesovsky, administrador de la base de datos en Data Egret.  Uno de los temas favoritos de Alexey en PostgreSQL es la replicaci√≥n de transmisi√≥n y el trabajo con estad√≠sticas, por lo que el informe en Highload ++ 2017 se dedic√≥ a c√≥mo encontrar problemas usando estad√≠sticas y qu√© m√©todos usar para resolverlos. <br><br><h2>  Plan <br></h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un poco de teor√≠a, o c√≥mo funciona la replicaci√≥n en PostgreSQL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Herramientas de soluci√≥n de problemas o lo que PostgreSQL y la comunidad tienen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soluci√≥n de problemas de casos:</a> <br><ul><li>  problemas: sus s√≠ntomas y diagn√≥stico </li><li>  decisiones </li><li>  medidas a tomar para que no surjan estos problemas. </li></ul></li></ol><br>  <strong>¬øPor qu√© todo esto?</strong>  Este art√≠culo lo ayudar√° a comprender mejor la replicaci√≥n de transmisi√≥n, aprender√° a encontrar y solucionar problemas r√°pidamente para reducir el tiempo de reacci√≥n ante incidentes desagradables. <br><a name="habracut"></a><a name="replicationSql"></a><br><h2>  Poco de teor√≠a <br></h2><br>  PostgreSQL tiene una entidad como Write-Ahead Log (XLOG), un registro de transacciones.  <em>Casi</em> todos <em>los</em> cambios que se producen con los datos y metadatos en la base de datos se registran en el registro.  Si ocurre un accidente repentinamente, PostgreSQL se inicia, lee el registro de transacciones y restaura los cambios registrados en los datos.  Esto garantiza la fiabilidad, una de las propiedades m√°s importantes de cualquier DBMS y PostgreSQL tambi√©n. <br><br>  El registro de transacciones se puede completar de dos maneras: <br><br><ol><li>  Por defecto, cuando los backends hacen algunos cambios en la base de datos (INSERT, UPDATE, DELETE, etc.), todos los cambios se registran en el registro de transacciones de forma <strong>s√≠ncrona</strong> : <br><ul><li>  El cliente envi√≥ un comando COMMIT para confirmar los datos. <br></li><li>  Los datos se registran en el registro de transacciones. <br></li><li>  Una vez que se ha producido la fijaci√≥n, se le da control al backend y puede continuar recibiendo comandos del cliente. <br></li></ul></li><li>  La segunda opci√≥n es la <strong>escritura as√≠ncrona</strong> en el registro de transacciones, cuando un proceso de escritor WAL dedicado separado escribe los cambios en el registro de transacciones con un cierto intervalo de tiempo.  Debido a esto, se logra un aumento en el rendimiento del backend, ya que no es necesario esperar hasta que se complete el comando COMMIT. <br></li></ol><br>  Lo m√°s importante, la replicaci√≥n de transmisi√≥n se basa en este registro de transacciones.  Tenemos varios miembros de replicaci√≥n de transmisi√≥n: <br><br><ul><li>  maestro donde tienen lugar todos los cambios; <br></li><li>  varias r√©plicas que aceptan el registro de transacciones del maestro y reproducen todos estos cambios en sus datos locales.  Esta es la replicaci√≥n de transmisi√≥n. <br></li></ul><br>  Vale la pena recordar que todos estos registros de transacciones se almacenan en el directorio pg_xlog en $ DATADIR, el directorio con los principales archivos de datos DBMS.  En la d√©cima versi√≥n de PostgreSQL, este directorio se renombr√≥ a pg_wal /, porque no es raro que pg_xlog / ocupe mucho espacio, y los desarrolladores o administradores que sin saberlo lo confunden con los registros, lo eliminan descuidadamente y todo se vuelve malo. <br><br>  PostgreSQL tiene varios servicios en segundo plano que participan en la replicaci√≥n de transmisi√≥n.  Echemos un vistazo desde el punto de vista del sistema operativo. <br><br><ul><li>  Del lado del maestro - Proceso WAL Sender.  Este es un proceso que env√≠a registros de transacciones a las r√©plicas, cada r√©plica tendr√° su propio WAL Sender. <br></li><li>  La r√©plica, a su vez, ejecuta el proceso del receptor WAL, que recibe registros de transacciones a trav√©s de la conexi√≥n de red del remitente WAL y los pasa al proceso de inicio. <br></li><li>  El proceso de inicio lee los registros y reproduce en el directorio de datos todos los cambios que se registran en el registro de transacciones. <br></li></ul><br><img src="https://habrastorage.org/webt/ek/g2/rd/ekg2rdtwkvfjw8hlpj0rhhzhogu.jpeg"><br>  Esquem√°ticamente, se parece a esto: <br><br><ul><li>  Los cambios se escriben en WAL Buffers, que luego se escribir√°n en el registro de transacciones; <br></li><li>  Los registros est√°n almacenados en el directorio pg_wal /; <br></li><li>  WAL Sender lee el registro de transacciones del repositorio y los transmite a trav√©s de la red; <br></li><li>  WAL Receiver recibe y almacena en su Almacenamiento - en el local pg_wal /; <br></li><li>  El proceso de inicio lee todo lo que se acepta y reproduce. <br></li></ul><br>  El esquema es simple.  La replicaci√≥n de flujo funciona de manera bastante confiable y ha sido excelentemente explotada por muchos a√±os. <br><a name="tools"></a><br><h2>  Herramientas de soluci√≥n de problemas <br></h2><br>  Veamos qu√© herramientas y utilidades ofrece la comunidad y PostgreSQL para investigar los problemas encontrados con la replicaci√≥n de transmisi√≥n. <br><br><h3>  Herramientas de terceros <br></h3><br>  Comencemos con herramientas de terceros.  Estas utilidades son de un <strong>plan</strong> bastante <strong>universal</strong> ; pueden usarse no solo para investigar incidentes relacionados con la replicaci√≥n de transmisi√≥n.  Generalmente son <strong>utilidades de cualquier administrador del sistema</strong> . <br><br><ul><li>  <strong>parte superior</strong> del paquete procps.  Como reemplazo de la parte superior, puede utilizar cualquier utilidad, como arriba, htop y similares.  Ofrecen una funcionalidad similar. </li></ul><br>  Con la ayuda de top buscamos: utilizaci√≥n de procesadores (CPU), carga promedio (carga promedio) y uso de memoria y espacio de intercambio. <br><br><ul><li>  iostat de sysstat e iotop.  Estas utilidades muestran la utilizaci√≥n de dispositivos de disco y qu√© E / S se crea mediante procesos en el sistema operativo. </li></ul><br>  Con la ayuda de iostat buscamos: utilizaci√≥n del almacenamiento, cu√°ntas iops en este momento, qu√© rendimiento en los dispositivos, qu√© demoras al procesar solicitudes de E / S (latencia).  Esta informaci√≥n bastante detallada se toma del sistema de archivos procfs y se proporciona al usuario en forma visual. <br><br><ul><li>  nicstat es un an√°logo de iostat, solo para interfaces de red.  En esta utilidad puede ver la utilizaci√≥n de interfaces. </li></ul><br>  Usando nicstat, buscamos: de manera similar, la utilizaci√≥n de la interfaz, algunos errores que ocurren en las interfaces, el rendimiento tambi√©n es una utilidad muy √∫til. <br><br><ul><li>  pgCenter es una utilidad para trabajar solo con PostgreSQL.  Muestra estad√≠sticas de PostgreSQL en una interfaz similar a la superior, y tambi√©n puede ver estad√≠sticas relacionadas con la replicaci√≥n de transmisi√≥n en ella. </li></ul><br>  Con la ayuda de pgCenter buscamos: estad√≠sticas sobre replicaci√≥n.  Puede ver el retraso de la replicaci√≥n, evaluarlo de alguna manera y predecir el trabajo futuro. <br><br><ul><li>  perf es una utilidad para una investigaci√≥n m√°s profunda de las causas del "golpeteo subterr√°neo", cuando en funcionamiento hay problemas extra√±os en el nivel de c√≥digo PostgreSQL. </li></ul><br>  Con la ayuda de perf buscamos: golpes subterr√°neos.  Para que perf funcione completamente con PostgreSQL, este √∫ltimo debe compilarse con caracteres de depuraci√≥n, para que pueda ver la pila de funciones en los procesos y qu√© funciones ocupan m√°s tiempo de CPU. <br><br>  Todas estas utilidades son necesarias para <strong>probar las hip√≥tesis</strong> que surgen al resolver problemas: d√≥nde y qu√© se ralentiza, d√≥nde y qu√© necesita corregir, verifique.  Estas utilidades ayudan a asegurarnos de que estamos en el camino correcto. <br><br><h3>  Herramientas integradas <br></h3><br>  ¬øQu√© ofrece el propio PostgreSQL? <br><br><h4>  Vistas del sistema <br></h4><br>  En general, hay muchas herramientas para trabajar con PostgreSQL.  Cada compa√±√≠a proveedora que brinda soporte PostgreSQL ofrece sus propias herramientas.  Pero, por regla general, estas herramientas se basan en estad√≠sticas internas de PostgreSQL.  A este respecto, PostgreSQL proporciona vistas del sistema en las que puede realizar varias selecciones y obtener la informaci√≥n que necesita.  Es decir, utilizando un cliente normal, generalmente psql, podemos hacer consultas y ver qu√© sucede en las estad√≠sticas. <br><br>  Hay bastantes vistas del sistema.  Para trabajar con la replicaci√≥n de transmisi√≥n e investigar problemas, solo necesitamos: pg_stat_replication, pg_stat_wal_receiver, pg_stat_databases, pg_stat_databases_conflicts y auxiliares pg_stat_activity y pg_stat_archiver. <br><br>  Hay pocos de ellos, pero este conjunto es suficiente para verificar si hay alg√∫n problema. <br><br><h4>  Funciones de ayuda <br></h4><br>  Usando funciones auxiliares, puede tomar datos de representaciones de sistemas estad√≠sticos y transformarlos en una forma m√°s conveniente para usted.  Las funciones auxiliares tambi√©n son solo unas pocas piezas. <br><br><ul><li>  pg_current_wal_lsn () (el antiguo an√°logo de pg_current_xlog_location ()) es la funci√≥n m√°s necesaria que le permite ver la posici√≥n actual en el registro de transacciones.  Un registro de transacciones es una secuencia continua de datos.  Usando esta funci√≥n, puede ver el √∫ltimo punto, obtener la posici√≥n donde el registro de transacciones se ha detenido ahora. <br></li><li>  pg_last_wal_receive_lsn (), pg_last_xlog_receive_location () es una funci√≥n similar a la anterior, solo para r√©plicas.  La r√©plica recibe el registro de transacciones y puede ver la √∫ltima posici√≥n del registro de transacciones recibido; <br></li><li>  pg_wal_lsn_diff (), pg_xlog_location_diff () es otra funci√≥n √∫til.  Le damos dos posiciones del registro de transacciones, y ella muestra diff: la distancia entre estos dos puntos en bytes.  Esta funci√≥n siempre es √∫til para determinar el retraso entre el maestro y las r√©plicas en bytes. <br></li></ul><br>  Se puede obtener una lista completa de funciones con el metacomando psql: \ df * (wal | xlog | lsn | location) *. <br><br>  Puede escribirlo en psql y ver todas las funciones que contiene wal, xlog, Isn, location.  Habr√° alrededor de 20-30 funciones de este tipo, y tambi√©n proporcionan informaci√≥n variada en el registro de transacciones.  Te recomiendo que te familiarices. <br><br><h4>  Utilidad Pg_waldump <br></h4><br>  Antes de la versi√≥n 10.0, se llamaba pg_xlogdump.  La utilidad pg_waldump es necesaria cuando queremos examinar los segmentos del registro de transacciones, averiguar qu√© registros de recursos llegaron all√≠ y qu√© escribi√≥ PostgreSQL all√≠, es decir, para un estudio m√°s detallado. <br><br><blockquote>  En la versi√≥n 10.0, todas las vistas, funciones y utilidades del sistema que inclu√≠an la palabra xlog fueron renombradas.  Todas las apariciones de las palabras xlog y location fueron reemplazadas por las palabras wal e lsn, respectivamente.  Lo mismo se hizo con el directorio pg_xlog que se convirti√≥ en el directorio pg_wal. <br></blockquote><br>  La utilidad pg_waldump simplemente decodifica el contenido de los segmentos XLOG en un formato legible para humanos.  Puede ver qu√© denominados registros de recursos caen en los registros de segmento durante el trabajo de PostgreSQL, qu√© √≠ndices y archivos de almacenamiento din√°mico se modificaron, qu√© informaci√≥n destinada para stand-by lleg√≥ all√≠.  Por lo tanto, se puede ver mucha informaci√≥n usando pg_waldump. <br><br><blockquote>  Pero hay un descargo de responsabilidad que est√° escrito en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n oficial</a> : pg_waldump puede mostrar datos ligeramente incorrectos cuando PostgreSQL se est√° ejecutando (puede dar resultados incorrectos cuando el servidor se est√° ejecutando, lo que sea que eso signifique) </blockquote><br>  Puedes usar el comando: <br><br><pre><code class="sql hljs">pg_waldump -f - /wal_10 \ $(psql -qAtX - "<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_walfile_name(pg_current_wal_lsn())<span class="hljs-string"><span class="hljs-string">")</span></span></code> </pre> <br>  Este es un an√°logo del comando tail -f solo para registros de transacciones.  Este comando muestra la cola del registro de transacciones que est√° sucediendo en este momento.  Puede ejecutar este comando, encontrar√° el √∫ltimo segmento con la entrada de registro de transacciones m√°s reciente, se conectar√° a √©l y comenzar√° a mostrar el contenido del registro de transacciones.  Un equipo un poco complicado, pero, sin embargo, funciona.  A menudo lo uso. <br><a name="cases"></a><br><h2>  Soluci√≥n de problemas de casos <br></h2><br>  Aqu√≠ observamos los problemas m√°s comunes que surgen en la pr√°ctica de los consultores, qu√© s√≠ntomas pueden ser y c√≥mo diagnosticarlos: <br><br>  <strong>Los retrasos de replicaci√≥n son el problema m√°s com√∫n</strong> .  M√°s recientemente, tuvimos correspondencia con el cliente: <br><br><blockquote>  - <em>Hemos roto la replicaci√≥n maestro-esclavo entre los dos servidores.</em> <br><br>  - Detectado retraso 2 horas, pg_dump comenz√≥. <br><br>  - <em>OK, veo.</em>  <em>¬øCu√°l es nuestro retraso permisible?</em> <br><br>  - 16 horas en max_standby_streaming_delay. <br><br>  <em>- ¬øQu√© pasar√° cuando se exceda este retraso?</em>  <em>Sirena aullando?</em> <br><br>  - No, las transacciones ser√°n superadas y se reanudar√° el rollo de WAL. <br></blockquote><br>  Tenemos problemas con los retrasos de replicaci√≥n todo el tiempo, y casi todas las semanas los resolvemos. <br><br>  <strong>La expansi√≥n del directorio pg_wal /</strong> donde se almacenan los segmentos del registro de transacciones es un problema que ocurre con menos frecuencia.  Pero en este caso es necesario tomar medidas inmediatas para que el problema no se convierta en una situaci√≥n de emergencia cuando las r√©plicas se caigan. <br><br>  <strong>Las consultas largas</strong> que se ejecutan en la r√©plica generan <strong>conflictos durante la recuperaci√≥n</strong> .  Esta es una situaci√≥n en la que iniciamos alg√∫n tipo de carga en la r√©plica, puede ejecutar consultas de lectura en las r√©plicas, y en este momento estas consultas interfieren con la reproducci√≥n del registro de transacciones.  Hay un conflicto, y PostgreSQL necesita decidir si esperar a que se complete la consulta o completarla y continuar reproduciendo el registro de transacciones.  Este es un conflicto de replicaci√≥n o un conflicto de recuperaci√≥n. <br><br>  <strong>Proceso de recuperaci√≥n: 100% de uso de la CPU: el</strong> proceso de recuperaci√≥n de un registro de transacciones en las r√©plicas toma el 100% del tiempo del procesador.  Esta tambi√©n es una situaci√≥n rara, pero es bastante desagradable, porque  conduce a un aumento en el retraso de la replicaci√≥n y generalmente es dif√≠cil de investigar. <br><br><h3>  Retrasos de replicaci√≥n <br></h3><br>  Los retrasos de replicaci√≥n se producen cuando la misma solicitud, ejecutada en el maestro y en la r√©plica, devuelve datos diferentes.  Esto significa que los datos son inconsistentes entre el maestro y las r√©plicas, y hay alg√∫n retraso.  La r√©plica necesita reproducir parte de los registros de transacciones para ponerse al d√≠a con el asistente.  El s√≠ntoma principal se ve exactamente as√≠: hay una consulta y devuelven resultados diferentes. <br><br>  <strong>¬øC√≥mo buscar tales problemas?</strong> <br><br><ul><li>  Hay una vista b√°sica sobre el asistente y las r√©plicas: <strong>pg_stat_replication</strong> .  Muestra informaci√≥n sobre todos los remitentes de WAL, es decir, sobre procesos que env√≠an registros de transacciones.  Cada r√©plica tendr√° una l√≠nea separada que muestra estad√≠sticas para esta r√©plica en particular. <br></li><li>  La funci√≥n auxiliar <strong>pg_wal_lsn_diff () le</strong> permite comparar diferentes posiciones en el registro de transacciones y calcular el mismo retraso.  Con su ayuda, podemos obtener n√∫meros espec√≠ficos y determinar d√≥nde tenemos un gran retraso, d√≥nde es peque√±o y de alguna manera ya responder al problema. <br></li><li>  La funci√≥n <strong>pg_last_xact_replay_timestamp ()</strong> funciona solo en la r√©plica y le permite ver la hora en que se realiz√≥ la √∫ltima transacci√≥n perdida.  Hay una conocida funci√≥n now () que muestra la hora actual, restamos el tiempo que nos muestra la funci√≥n pg_last_xact_replay_timestamp () de la funci√≥n now () y obtenemos el retraso de tiempo. <br></li></ul><br>  En la d√©cima versi√≥n de pg_stat_replication, aparecieron campos adicionales que muestran el retraso de tiempo ya en el asistente, por lo tanto, este m√©todo ya est√° desactualizado, pero, sin embargo, puede usarse. <br><br>  Hay una peque√±a trampa.  Si no hay transacciones en el asistente durante mucho tiempo y no genera registros de transacciones, la √∫ltima funci√≥n mostrar√° un retraso creciente.  De hecho, el sistema simplemente est√° inactivo, no hay actividad en √©l, pero al monitorear podemos ver que el retraso est√° creciendo.  Vale la pena recordar esta trampa. <br><br>  La vista es la siguiente. <br><br><img src="https://habrastorage.org/webt/sb/jg/6k/sbjg6kswtdtymuecundldk180r8.jpeg"><br><br>  Contiene informaci√≥n sobre cada remitente de WAL y varios campos que son importantes para nosotros.  Esto es principalmente <strong>client_addr</strong> : la direcci√≥n de red de la r√©plica conectada (generalmente una direcci√≥n IP) y un conjunto de campos <strong>lsn</strong> (en versiones anteriores se llama ubicaci√≥n), hablar√© un poco m√°s sobre ellos. <br><br>  En la d√©cima versi√≥n, aparecieron los campos de <strong>retraso</strong> : este es un retraso expresado en el tiempo, es decir, un formato m√°s legible para los humanos.  El retraso puede expresarse en bytes o en tiempo: puede elegir lo que m√°s le guste. <br><br>  Como regla, uso esta solicitud. <br><br><img src="https://habrastorage.org/webt/ff/8g/kv/ff8gkvz-kzdihuxabphcb0rfd4e.jpeg"><br><br>  Esta no es la consulta m√°s compleja que pg_stat_replication imprime en un formato m√°s conveniente y comprensible.  Aqu√≠ uso las siguientes funciones: <br><br><ul><li>  <strong>pg_wal_lsn_diff ()</strong> para leer diffs.  Pero entre lo que creo que son las diferencias?  Tenemos varios campos: sent_lsn, write_lsn, flush_lsn, replay_lsn.  Al calcular la diferencia entre el campo actual y el anterior, podemos comprender con precisi√≥n d√≥nde nos retrasamos, d√≥nde ocurre exactamente el retraso. <br></li><li>  <strong>pg_current_wal_lsn (),</strong> que muestra la posici√≥n actual de las transacciones de diario.  Aqu√≠ observamos la distancia entre la posici√≥n actual en el registro y la enviada: cu√°ntos registros de transacciones se generaron pero no se enviaron. <br></li><li>  <strong>sent_lsn</strong> , <strong>write_lsn</strong> : esto es cu√°nto se env√≠a a la r√©plica, pero no se registra.  Es decir, ahora se encuentra en alg√∫n lugar de la red, o fue recibido por una r√©plica, pero a√∫n no se ha escrito desde los b√∫feres de red al almacenamiento en disco. <br></li><li>  <strong>write_lsn, flush_lsn</strong> : esto est√° escrito, pero no fue emitido por el comando fsync, como si estuviera escrito, pero puede ubicarse en alg√∫n lugar de la RAM, en el cach√© de p√°ginas del sistema operativo.  Tan pronto como hacemos fsync, los datos se sincronizan con el disco, llegan al almacenamiento persistente y todo parece ser confiable. <br></li><li>  <strong>replay_lsn, flush_lsn</strong> : datos volcados, fsync ejecutado, pero no replicado. <br></li><li>  <strong>current_wal_lsn</strong> y <strong>replay_lsn</strong> es una especie de retraso total que incluye todas las posiciones anteriores. <br></li></ul><br><h4>  <strong>Algunos ejemplos</strong> <br></h4><br><img src="https://habrastorage.org/webt/7c/9n/tt/7c9nttg6yp-uyimrxa4ji3ll1ha.jpeg"><br><br>  La r√©plica 10.6.6.8 se destaca arriba.  Tiene un <strong>retraso pendiente</strong> , gener√≥ algunos registros de transacciones, pero a√∫n no se env√≠an y yacen en el maestro.  Lo m√°s probable es que haya alg√∫n tipo de problema con el rendimiento de la red.  Verificaremos esto usando la utilidad nicstat. <br><br>  Lanzaremos nicstat, veremos la utilizaci√≥n de la interfaz, si hay alg√∫n problema y error all√≠.  Entonces podemos probar esta hip√≥tesis. <br><br><img src="https://habrastorage.org/webt/co/-m/fj/co-mfjznunlrsuurikvz7xy9gh0.jpeg"><br><br>  El <strong>retraso de escritura est√°</strong> marcado arriba.  De hecho, este retraso es bastante raro, casi no veo que sea grande.  El problema puede estar en los discos, y usamos la utilidad iostat o iotop: observamos la utilizaci√≥n de los almacenes de discos, que es la E / S creada por los procesos, y luego descubrimos por qu√©. <br><br><img src="https://habrastorage.org/webt/to/xw/2j/toxw2jutr7yaof38fwbohph9lva.jpeg"><br><br>  <strong>Vaciar y reproducir retrasos</strong> : la mayor√≠a de las veces el retraso ocurre all√≠ cuando el dispositivo de disco en la r√©plica no tiene tiempo para simplemente perder todos los cambios que llegan del maestro. <br><br>  Tambi√©n con las utilidades iostat e iotop observamos qu√© sucede con la utilizaci√≥n del disco y por qu√© los frenos. <br><br>  Y el √∫ltimo <strong>total_lag</strong> es una m√©trica √∫til para monitorear sistemas.  Si se supera nuestro umbral total_lag, se activa una casilla de verificaci√≥n en la supervisi√≥n y comenzamos a investigar lo que est√° sucediendo all√≠. <br><br><h4>  <strong>Prueba de hip√≥tesis</strong> <br></h4><br>  Ahora necesita descubrir c√≥mo investigar m√°s a fondo un problema particular.  Ya dije que si esto es un retraso de la red, entonces debemos verificar si todo est√° en orden con la red. <br><br>  Ahora, casi todos los servidores proporcionan 1 Gb / so incluso 10 Gb / s, por lo que un <strong>ancho de banda obstruido es el escenario m√°s improbable</strong> .  Como regla general, debe mirar los errores.  nicstat contiene informaci√≥n sobre errores en las interfaces, puede darse cuenta de que hay problemas con los controladores, ya sea con la tarjeta de red o con los cables. <br><br>  <strong>En el problema de almacenamiento,</strong> se investiga con el iostat y iotop.  iostat es necesario para ver la imagen general del almacenamiento en disco: reciclaje del dispositivo, ancho de banda del dispositivo, latencia.  iotop: para una investigaci√≥n m√°s precisa, cuando necesitamos identificar qu√© proceso est√° cargando el subsistema de disco.  Si se trata de alg√∫n tipo de proceso de terceros, simplemente se puede detectar, completar y quiz√°s el problema desaparecer√°. <br><br>  En primer lugar, observamos <strong>los retrasos de recuperaci√≥n y los conflictos de replicaci√≥n a</strong> trav√©s de top o pg_stat_activity: qu√© procesos se est√°n ejecutando, qu√© solicitudes se est√°n ejecutando, su tiempo de ejecuci√≥n, cu√°nto tiempo se est√°n ejecutando.  Si se trata de consultas largas, analizamos por qu√© funcionan durante mucho tiempo, les disparamos, las entendemos y las <strong>optimizamos</strong> : examinaremos las consultas por s√≠ mismas. <br><br>  Si se trata de una <strong>gran cantidad de registros de transacciones</strong> generados por el asistente, podemos detectar esto mediante <strong>pg_stat_activity</strong> .  Tal vez algunos procesos de respaldo se inicien all√≠, se haya iniciado alg√∫n tipo de vac√≠o (pg_stat_progress_vacuum) o se est√© ejecutando el punto de control.  Es decir, si se generan demasiados registros de transacciones y la r√©plica simplemente no tiene tiempo para procesarla, en alg√∫n momento puede caerse y esto ser√° un problema para nosotros. <br><br>  Y, por supuesto, <strong>pg_wal_lsn_diff ()</strong> para determinar el retraso y determinar d√≥nde tenemos el retraso espec√≠ficamente: en la red, en los discos o en los procesadores. <br><br><h4>  <strong>Opciones de solucion</strong> <br></h4><br>  <strong>Problemas de red / almacenamiento</strong> <br><br>  Aqu√≠ todo es bastante simple, pero desde el punto de vista de la configuraci√≥n, esto generalmente no se resuelve.  Puede apretar algunas tuercas, pero en general hay 2 opciones: <br><br><ul><li>  Verificar carga de trabajo </li></ul><br>  Verifique qu√© solicitudes se est√°n ejecutando.  Tal vez se inicie alg√∫n tipo de migraci√≥n que genere muchos registros de transacciones, o puede ser transferencia de datos, eliminaci√≥n o inserci√≥n.  <strong>Cualquier proceso que genere registros de transacciones puede conducir al retraso de la transacci√≥n</strong> .  Todos los datos en el asistente se generan lo m√°s r√°pido posible, realizamos un cambio en los datos, los enviamos a la r√©plica y la r√©plica puede hacer frente o fallar; esto no afecta al asistente.  Aqu√≠ puede aparecer un retraso y debe hacer algo con √©l. <br><br><ul><li>  Actualizaci√≥n de hardware <br></li></ul><br>  La opci√≥n m√°s est√∫pida: tal vez nos hemos encontrado con el rendimiento del hierro y solo necesita cambiarlo.  Pueden ser discos viejos o SSD de baja calidad, o un complemento en el rendimiento de un controlador RAID.  Aqu√≠ ya no estamos explorando la base en s√≠, sino comprobando el rendimiento de nuestras gl√°ndulas. <br><br>  <strong>Retrasos de recuperaci√≥n</strong> <br><br>  Si tenemos alg√∫n tipo de conflicto de replicaci√≥n debido a solicitudes largas, lo que resulta en un aumento en el retraso de reproducci√≥n, lo <strong>primero</strong> que hacemos es <strong>disparar solicitudes largas</strong> que se ejecutan en la r√©plica, ya que retrasan la reproducci√≥n de los registros de transacciones. <br><br>  Si las consultas largas est√°n relacionadas con la falta de optimizaci√≥n de la consulta SQL en s√≠ misma (lo descubrimos utilizando EXPLAIN ANALYZE), solo necesita abordar esta consulta de manera diferente y reescribirla.  O hay una opci√≥n para configurar una <strong>r√©plica separada para informar consultas</strong> .  Si hacemos informes que funcionen durante mucho tiempo, deben enviarse a una r√©plica separada. <br><br>  Todav√≠a existe la opci√≥n de <strong>solo esperar</strong> .  Si tenemos alg√∫n tipo de retraso al nivel de unos pocos kilobytes o incluso decenas de megabytes, pero creemos que esto es aceptable, solo esperamos a que se complete la solicitud y el retraso se resolver√° por s√≠ solo.  Esta tambi√©n es una opci√≥n, y a menudo sucede que es aceptable. <br><br>  <strong>WAL de alto volumen</strong> <br><br>  Si generamos un gran volumen de registro de transacciones, necesitamos reducir este <strong>volumen por unidad de tiempo</strong> , para que la r√©plica necesite masticar menos registros de transacciones. <br><br>  T√≠picamente, esto se hace <strong>con la configuraci√≥n.</strong>  Soluci√≥n parcial en la configuraci√≥n del par√°metro full_page_writes = off.  Esta opci√≥n activa / desactiva la grabaci√≥n de im√°genes completas de p√°ginas cambiantes en el registro de transacciones.  Esto significa que cuando tuvimos la operaci√≥n de servicio de escribir un punto de control (CHECKPOINT), la pr√≥xima vez que cambiemos alg√∫n bloque de datos en el √°rea de buffers compartidos, la imagen completa de esta p√°gina ir√° al registro de transacciones, y no solo el cambio en s√≠.  Con todos los cambios posteriores en la misma p√°gina, solo los cambios se registrar√°n en el registro de transacciones.  Y as√≠ sucesivamente al siguiente punto de control. <br><br>  Despu√©s del punto de control, registramos la imagen completa de la p√°gina, y esto afecta el volumen del registro de transacciones registrado.  Si hay muchos puntos de control por unidad de tiempo, digamos que se realizan 4 puntos de control por hora, y habr√° muchas im√°genes de p√°gina completa, esto ser√° un problema.  Puede deshabilitar la grabaci√≥n de im√°genes completas y esto afectar√° el volumen del WAL.  Pero de nuevo, esta es una media medida. <br><br>  <i>Nota: La recomendaci√≥n de deshabilitar full_page_writes debe considerarse cuidadosamente, ya que el autor olvid√≥ aclarar durante el informe que deshabilitar un par√°metro puede, en algunas circunstancias, ocurrir en situaciones de emergencia (da√±o al sistema de archivos o su registro, escritura parcial en bloques, etc.) archivos de base de datos potencialmente corruptos.</i>  <i>Por lo tanto, tenga cuidado, deshabilitar el par√°metro puede aumentar el riesgo de corrupci√≥n de datos en situaciones de emergencia.</i> <br><br>  Otra media medida es <strong>aumentar el intervalo entre puntos de control</strong> .  Por defecto, el punto de control se realiza cada 5 minutos, y esto es bastante com√∫n.  Como regla general, este intervalo se incrementa a 30-60 minutos; este es un tiempo bastante aceptable para que todas las p√°ginas sucias se sincronicen con el disco. <br><br>  Pero la soluci√≥n principal es, por supuesto, <strong>observar nuestra carga de trabajo</strong> : qu√© tipo de operaciones pesadas est√°n ocurriendo all√≠, asociadas con el cambio de datos y, tal vez, intentar hacer estos cambios en lotes. <br><br>  Supongamos que tenemos una tabla, queremos eliminar varios millones de registros.  La mejor opci√≥n es no eliminar estos millones de una vez con una sola solicitud, sino dividirlos en paquetes de 100-200 mil para que, en primer lugar, se generen peque√±as cantidades de WAL, en segundo lugar, el vac√≠o tenga tiempo de pasar por los datos eliminados, y por lo tanto el retraso no fue tan Grande y cr√≠tico. <br><br><h3>  Hinchaz√≥n pg_wal / <br></h3><br>  Ahora, hablemos sobre c√≥mo puede encontrar que el directorio pg_wal / est√° hinchado. <br><br>  En teor√≠a, PostgreSQL siempre lo mantiene en un estado √≥ptimo para s√≠ mismo al nivel de ciertos archivos de configuraci√≥n y, por regla general, no deber√≠a crecer por encima de ciertos l√≠mites. <br><br>  Hay un par√°metro max_wal_size, que determina el valor m√°ximo.  Adem√°s, est√° el par√°metro wal_keep_segments, un n√∫mero adicional de segmentos que el maestro almacena para la r√©plica si la r√©plica no est√° disponible de repente durante mucho tiempo. <br><br>  Habiendo calculado la suma de max_wal_size y wal_keep_segments, podemos estimar aproximadamente cu√°nto espacio ocupar√° el directorio pg_wal /.  Si crece r√°pidamente y ocupa mucho m√°s espacio que el valor calculado, esto significa que hay alg√∫n problema y debe hacer algo al respecto. <br><br><h4>  ¬øC√≥mo detectar tales problemas? <br></h4><br>  En el sistema operativo Linux, existe el <strong>comando du -csh</strong> .  Simplemente podemos controlar el valor y controlar cu√°ntos registros de transacciones tenemos all√≠;  mantenga una etiqueta calculada, cu√°nto debe y cu√°nto toma realmente, y de alguna manera responde a los cambios en los n√∫meros. <br><br>  Otro lugar que vemos son las <strong>vistas</strong> <strong>pg_replication_slots</strong> y <strong>pg_stat_archiver</strong> .  Las razones m√°s comunes por las que pg_wal / ocupa mucho espacio son las ranuras de replicaci√≥n olvidadas o el archivado roto.  Otras razones tambi√©n tienen un lugar para estar, pero en mi pr√°ctica eran muy raras. <br><br>  Y, por supuesto, siempre hay errores en los registros de PostgreSQL que est√°n asociados con el comando de archivo.  Desafortunadamente, no habr√° otras razones relacionadas con pg_wal / overflow.  Solo podemos detectar errores de archivo all√≠. <br><br><h4>  Opciones para problemas: <br></h4><br>  <strong>CRUD</strong> pesado: operaciones de actualizaci√≥n de datos pesados: INSERT, BORRADO, ACTUALIZACI√ìN pesados, asociados con el cambio de varios millones de filas.  Si PostgreSQL necesita hacer tal operaci√≥n, est√° claro que se generar√° una gran cantidad de registro de transacciones.  Se almacenar√° en pg_wal /, y esto aumentar√° el espacio ocupado.  Es decir, nuevamente, como dije antes, es una buena pr√°ctica simplemente dividirlos en paquetes y actualizar no toda la matriz, sino 100, 200, 300 mil cada uno. <br><br>  <strong>Una ranura de replicaci√≥n olvidada o no utilizada</strong> es otro problema com√∫n.  Las personas a menudo usan la replicaci√≥n l√≥gica para algunas de sus tareas: configuran buses que env√≠an datos a Kafka, env√≠an datos a una aplicaci√≥n de terceros que decodifica la replicaci√≥n l√≥gica a otro formato y de alguna manera los procesa.  <strong>La replicaci√≥n l√≥gica generalmente funciona a trav√©s de ranuras</strong> .  Sucede que configuramos una ranura de replicaci√≥n, jugamos con la aplicaci√≥n, nos dimos cuenta de que esta aplicaci√≥n no nos conviene, la apagamos, la eliminamos <strong>y las ranuras de replicaci√≥n contin√∫an activas</strong> . <br><br>  PostgreSQL para cada ranura de replicaci√≥n guarda segmentos del registro de transacciones en caso de que una aplicaci√≥n remota o r√©plica se conecte a esta ranura nuevamente, y luego el asistente puede enviarles estos registros de transacciones. <br><br>  Pero el tiempo pasa, nadie se conecta a la ranura, los registros de transacciones se acumulan y, en alg√∫n momento, ocupan el 90% del espacio.  Necesitamos descubrir qu√© es, por qu√© se ocupa tanto espacio.  Como regla general, esta ranura olvidada y no utilizada solo debe eliminarse, y el problema se resolver√°.  Pero m√°s sobre eso m√°s tarde. <br><br>  Otra opci√≥n podr√≠a ser un <strong>archivo_comando roto</strong> .  Cuando tenemos alg√∫n tipo de repositorio de registro de transacciones externo que mantenemos para las tareas de recuperaci√≥n ante desastres, generalmente se configura un comando de archivo, con menos frecuencia se configura pg_receivexlog.  El comando registrado en archive_command es a menudo un comando separado o alg√∫n script que toma segmentos del registro de transacciones de pg_wal / y lo copia en el almacenamiento de archivos. <br><br>  Sucede que realizamos alg√∫n tipo de actualizaci√≥n de los paquetes del sistema, por ejemplo, en rsync la versi√≥n cambi√≥, los indicadores se actualizaron o cambiaron, o en alg√∫n otro comando que se utiliz√≥ en el comando de archivo, el formato tambi√©n cambi√≥, y el script o el programa en s√≠ que se especifica en archivado_comando se rompe.  En consecuencia, los archivos dejan de copiarse. <br><br>  Si el comando de archivado funcion√≥ con una salida que no es 0, se escribir√° un mensaje sobre esto en el registro y el segmento permanecer√° en el directorio pg_wal /.  <strong>Hasta que descubramos que nuestro equipo de archivo se ha roto, los segmentos se acumular√°n</strong> y el lugar tambi√©n finalizar√° en alg√∫n momento. <br><br>  <strong>Conjunto de medidas de emergencia (espacio 100% utilizado):</strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dispare todas las solicitudes CRUD largas</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que se ejecutan actualmente en el asistente: pg_terminate_backend (). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede ser alg√∫n tipo de copias de solicitudes, copias de seguridad, actualizaciones que actualizan un mill√≥n de l√≠neas, etc. </font><font style="vertical-align: inherit;">En primer lugar, tenemos que disparar estas solicitudes para evitar que el directorio pg_wal / siga creciendo, de modo que no se generen nuevos segmentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduzca el llamado espacio reservado</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para los archivos de usuario ra√≠z: relaci√≥n de espacio reservado (sistemas de archivos ext).</font></font><br>       ext      ext     5%.  ,         ,  5% ‚Äî  . ,   ,     1%  ,     tune2fs -m 1.       PostgreSQL     ,    .      100%     . <br><br> 3. <strong>  </strong> (LVM, ZFS,...). <br>    LVM  ZFS,        LVM  ZFS,            ,   ,           .       ,   . <br><br> 4.    ‚Äî <strong>, , HE    pg_wal/</strong> . <br>          ,     ,   ,   .     ! PostgreSQL     ,   .     ,  ,   ,    . <br><br> , pg_xlog/   pg_wal/     ‚Äî  log    ,   , , ,  -   ‚Äî  ! <br><br><h4>    <br></h4><br>  ,         100%  CPU,      . <br><br>   <strong> workload  </strong> .    ,       ?  ,     - ,      -.         :   ,   tablespace,    tablespace. <br><br>   <strong> </strong> .       ,  ,    ,    , ,  ,            . <strong>   ‚Äî      .</strong> <br><br>   <strong>  checkpoints_segments/max_wal_size, wal_keep_segments</strong> .  ,    ,      ‚Äî 10-20   wal_keep_segments,     max_wal_size.  ,        .  PostgreSQL       pg_wal/  . <br><br>  <strong>  </strong>   pg_replication_slots ‚Äî     .   ,   <strong> </strong> ,        ‚Äî      .   ,    ,    .    . <br><br>      WAL,       ,  <strong>    pg_stat_archiver</strong> ,    . ,  <strong>  </strong> , ,    ,    . <br><br>    <strong>   checkpoint</strong> .       ,        ,      . , PostgreSQL        . <strong>   ,    checkpoint</strong> . <br><br><h3>       <br></h3><br>    ,   ,   ‚Äî        .   -             ,       .      ,         . <br><br> <strong> </strong> ‚Äî    PostgreSQL  : <br><br><ul><li> User was holding shared bufer pin for too long. <br></li><li> User query might have needed to see row versions that must be removed. <br></li><li> User was holding a relation lock for too long. <br></li><li> User was or might have been using table space that must be dropped. <br></li><li> User transaction caused bufer deadlock with recovery. <br></li><li> User was connected to a database that must be dropped. <br></li></ul><br>  2  ‚Äî    ,       ,      .   :  ,   ,      .        (  30 ),  <strong>PostgreSQL       </strong> ‚Äî  . <br><br>    .  ,    ,             .    -    ,     timeout     .     ‚Äî    ALTER,    ,    . <br><br>     .     ,  tablespace     ,            tablespace.   ,    ,  -   ‚Äî   . <br><br><h4> <strong> ?</strong> <br></h4><br>       <strong>pg_stat_databases, pg_stat_databases_conflicts</strong> .         ,    .     ,    . <br><br>  <strong>  </strong> ,       <strong> </strong> .  ,      .   ,    . ,       ,    ,    . <br><br><h4> <strong> ?</strong> <br></h4><br>   ,    ‚Äî    : <br><br><ol><li> <strong> max_standby_streaming_delay</strong> (  ).     ,       .    <strong>   </strong> . <br></li><li> <strong> hot_stadby_feedback</strong> (  /).  ,  vacuum   - ,       .     <strong> bloat  </strong> .     ,    ,  ,   hot_stadby_feedback  . <br></li><li>     DBA     ‚Äî  <strong>  </strong> .   <strong> </strong> ,    .  ,    ,     ,   -    ,  . <br></li><li>  , ,  ,   ,  DBA ‚Äî  <strong>     </strong> , ,  .    max_standby_streaming_delay  .       ,   .      ,  ,    ,  .  <strong>   </strong> ‚Äî    ,     . <br></li></ol><br><h2> Recovery process: 100% CPU usage <br></h2><br>  ,  ,    , <strong> 100%   </strong> .  ,      ,      100%.  ,    pg_stat_replication,  ,     replay,       ,    . <br><br> <strong></strong>  : <br><br><ul><li> <strong>top</strong> ‚Äî       ‚Äî    100% CPU usage  recovery process; <br></li><li> <strong>pg_stat_replication</strong> ‚Äî  ,   ,     . <br></li></ul><br><h4> <strong>   </strong> <br></h4><br>      ,    .  ,     : <br><br><ul><li> perf top/record/report ( debug‚Äî); <br></li><li> GDB; <br></li><li>  pg_waldump. <br></li></ul><br>  ,   ,       .     workload,   <strong>        </strong> .  ,    , PostgreSQL     shared buffers       ( ).        . <br><br><h4>  <strong>Soluci√≥n</strong> <br></h4><br>    ,      <strong>   </strong> . -   workload, - , -    : ¬´      ,  -  ¬ª. <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pgsql-hackers</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pgsql-bugs</a> ,   ,   .  ,    . <br><br>     ‚Äî <strong>-   ,  , </strong> . <br><br><h2>  <br></h2><br> <strong>      </strong> .  ,             ,    ,      . <br><br> <strong>     </strong> .    , ,  ,    ,   ,   ‚Äî . <br><br>  , <strong>  </strong> ,   ‚Äî .   ,   ,  ,         . <br><br>  ,    ,  <strong>  </strong> ‚Äî  ,      ,   . <br><br><h3>  Enlaces utiles <br></h3><br><ul><li> PostgreSQL official documentation ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Statistics Collector</a> </li><li> PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mailing Lists</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">general</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">performance</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hackers</a> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PostgreSQL-Consulting company blog</a> </li></ul><br><blockquote>             , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Highload++ Siberia</a> ,   <strong>25  26   </strong> .   ,     ,  . <br><br><ul><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>     MySQL  ClickHouse. </li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,            Oracle. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nikolay Golov </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le dir√°</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√≥mo implementar transacciones si el dinero est√° en un servicio, los servicios en otro y cada servicio tiene su propia base aislada.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yuri Nasretdinov </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicar√°</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en detalle </font><font style="vertical-align: inherit;">por qu√© VK necesita ClickHouse, cu√°ntos datos se almacenan y mucho m√°s.</font></font></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414111/">https://habr.com/ru/post/es414111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414095/index.html">[Traducci√≥n] Elasticsearch 6.3.0 lanzado</a></li>
<li><a href="../es414097/index.html">Las computadoras Apple cierran la vulnerabilidad de firmware encontrada por los expertos de Positive Technologies</a></li>
<li><a href="../es414103/index.html">Seminario web abierto: "Redes neuronales para tareas farmac√©uticas"</a></li>
<li><a href="../es414105/index.html">Predecir los resultados de la Copa Mundial 2018 utilizando el algoritmo de bosques aleatorios</a></li>
<li><a href="../es414109/index.html">Uso de Docker para compilar y ejecutar un proyecto C ++</a></li>
<li><a href="../es414115/index.html">Qu√© es Lazy FP State Restore: una nueva vulnerabilidad descubierta en los procesadores Intel</a></li>
<li><a href="../es414117/index.html">Formato binario decimal mixto vs IEEE754</a></li>
<li><a href="../es414119/index.html">La oportunidad se durmi√≥ debido a una tormenta de arena en Marte. No est√° claro si el rover podr√° volver a funcionar</a></li>
<li><a href="../es414121/index.html">Dron aut√≥nomo de bricolaje con control de internet</a></li>
<li><a href="../es414123/index.html">Actualizamos los protocolos de texto a binario y luchamos contra el c√≥digo heredado en una reuni√≥n del Grupo de usuarios de C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>