<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖæÔ∏è üç∂ üíñ Utilisation des comptes intelligents et des actifs intelligents Waves dans les instruments financiers üéÑ üéà üóæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans un article pr√©c√©dent , nous avons examin√© plusieurs cas d'utilisation de comptes intelligents dans les entreprises, notamment des ench√®res et des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation des comptes intelligents et des actifs intelligents Waves dans les instruments financiers</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/443836/"><img src="https://habrastorage.org/webt/og/ub/mr/ogubmruoxy2myy1xvnnh64axnec.png" alt="image"><br><br>  <i>Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> pr√©c√©dent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> nous avons examin√© plusieurs cas d'utilisation de comptes intelligents dans les entreprises, notamment des ench√®res et des programmes de fid√©lit√©.</i> <i><br></i>  <i>Aujourd'hui, nous parlerons de la mani√®re dont les comptes intelligents et les actifs intelligents peuvent accro√Ætre la transparence et la fiabilit√© des instruments financiers tels que les options, les contrats √† terme et les factures.</i> <i><br></i> <a name="habracut"></a><br>  <b>Option</b> <br><br>  Une option est un contrat d'√©change donnant √† l'acheteur le droit d'acheter un actif √† un certain prix ou avant une certaine date, mais ne l'obligeant pas √† le faire. <br><br>  L'exercice de l'option peut √™tre le suivant: <br><br>  Nous utilisons un actif intelligent pour les options elles-m√™mes comme outil et un compte intelligent pour le participant qui agit comme √©change et √©met des options.  Le participant √† l'√©change promet qu'il vendra une certaine quantit√© d'un certain actif au prix sellPrice entre les hauteurs des blocs expirationStart et expirationEnd). <br><br>  Dans le code de l'actif intelligent, nous v√©rifions simplement qu'il n'est √©chang√© qu'entre les hauteurs indiqu√©es, et nous ne v√©rifierons rien d'autre, nous laisserons toute responsabilit√© d'observer les r√®gles au code du participant √† l'√©change. <br><br>  <b><i>Code d'actif intelligent:</i></b> <br><br><pre><code class="scala hljs">let expirationStart = <span class="hljs-number"><span class="hljs-number">100000</span></span> let expirationEnd = <span class="hljs-number"><span class="hljs-number">101440</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> some : <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> | <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; height &gt; expirationStart &amp;&amp; height &lt;= expirationEnd <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <i>Nous supposons que les actions sont les suivantes: le membre de l'√©change vend des options pour l'achat de certains actifs, et le reste des participants peuvent transf√©rer ces options ou les √©changer.</i>  <i>Pour exercer son droit d‚Äôachat, un acheteur potentiel doit transf√©rer le nombre d‚Äôoptions souhait√© sur le compte du vendeur, c‚Äôest-√†-dire le participant √† l‚Äô√©change.</i>  <i>Il note ensuite les informations sur le transfert termin√© dans l'√©tat du compte du membre d'√©change et ce n'est qu'alors qu'ExchangeTransaction pourra passer par les conditions sp√©cifi√©es d'achat et de vente.</i> <i><br><br></i>  <i>Dans le code du compte intelligent, nous devons nous assurer que toute ExchangeTransaction qui le traverse pour l'acte d'achat-vente final remplit les conditions sp√©cifi√©es, et le participant ach√®te exactement le nombre d'unit√©s qu'il a envoy√© sur le compte du participant √† l'√©change.</i>  <i>Un acheteur potentiel doit envoyer la DataTransaction correcte au sujet du transfert qui s'est produit, afin que le membre d'√©change puisse √©viter de doubler les d√©penses.</i>  <i>Dans cette DataTransaction, l'acheteur met sur une cl√© √©gale √† son adresse une valeur √©gale au nombre d'options transf√©r√©es sur le compte du participant √† l'√©change, c'est-√†-dire le nombre d'unit√©s d'actifs qu'il peut acheter.</i> <br><br>  <b><i>Code de compte intelligent:</i></b> <br><br><pre> <code class="scala hljs">#         #  sellPrice    expirationStart  expirationEnd let expirationStart = <span class="hljs-number"><span class="hljs-number">100000</span></span> let expirationEnd = <span class="hljs-number"><span class="hljs-number">101440</span></span> let sellPrice = <span class="hljs-number"><span class="hljs-number">10000</span></span> let amountAsset = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let priceAsset = base58<span class="hljs-symbol"><span class="hljs-symbol">'9jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #<span class="hljs-type"><span class="hljs-type">ID</span></span> - let optionsAsset = base58<span class="hljs-symbol"><span class="hljs-symbol">'7jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> dataTx : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #    -   (<span class="hljs-type"><span class="hljs-type">ID</span></span> ) let units = extract(getInteger(dataTx.data, dataTx.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) # -    let e = transactionById(dataTx.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>]) # <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> e { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> transferTx : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; #,       (transferTx.recipient == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) &amp;&amp; #,         <span class="hljs-type"><span class="hljs-type">ID</span></span> dataTx.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key == toBase58String(transferTx.sender.bytes) &amp;&amp; sigVerify(dataTx.bodyBytes, dataTx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], transferTx.senderPublicKey) &amp;&amp; #,         (units == transferTx.amount) &amp;&amp; #,     - (transferTx.assetId == optionsAsset) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } &amp;&amp; size(dataTx.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, dataTx.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) &amp;&amp; height &gt; expirationStart &amp;&amp; height &lt;= expirationEnd <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> order : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #,         let correctAssetPair = order.assetPair.amountAsset == amountAsset &amp;&amp; order.assetPair.priceAsset == priceAsset let correctPrice = order.price == sellPrice # -   let d = transactionById(order.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> d{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> dataTx : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let buyOrderSender = dataTx.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key toBase58String(order.sender.bytes) == buyOrderSender &amp;&amp; order.amount == extract(getInteger(dataTx.data, buyOrderSender)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } &amp;&amp; order.sender == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &amp;&amp; correctAssetPair &amp;&amp; correctPrice &amp;&amp; height &gt; expirationStart &amp;&amp; height &lt;= expirationEnd <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <b>Futures de compte intelligent</b> <br><br>  Contrairement √† une option, les futures (contrat √† terme) ne sont pas un droit, mais l'obligation de l'acheteur d'acheter un actif √† un prix fixe √† un certain moment dans le futur. <br><br>  En g√©n√©ral, l'impl√©mentation de futures est similaire √† l'impl√©mentation d'une option.  Ici, un actif intelligent agit comme un futur. <br><br>  Vous devez √©galement vous assurer que l'acheteur et le vendeur signent le bon de commande.  Le futur est une obligation qui doit √™tre remplie dans tous les cas.  Cela signifie que si un vendeur ou un participant refuse ses obligations, tout participant au r√©seau peut envoyer une transaction, ex√©cutant ainsi des contrats √† terme. <br><br>  Le script Smart Asset contr√¥le tous les contrats √† terme sur actifs TransferTransaction et ExchangeTransaction, les approuvant uniquement si le membre acheteur a cr√©√© une commande pour le futur achat d'actifs √† terme aupr√®s du membre Exchange. <br><br>  Cet ordre doit √™tre valide et satisfaire aux conditions d'√©mission des futures.  Pour v√©rifier une commande, vous pouvez entrer tous ses champs dans l'√©tat du compte de l'acheteur avec la repr√©sentation en octets de la commande sign√©e, puis valider de l'ext√©rieur. <br><br>  Pour le moment, RIDE ne contient pas de fonction native pour analyser les octets de transaction, mais inclut tous les outils n√©cessaires √† sa mise en ≈ìuvre.  Par cons√©quent, les d√©veloppeurs peuvent essayer d'impl√©menter cette fonctionnalit√© par eux-m√™mes. <br><br>  <b>Compte multi-sign√© / engagement</b> <br><br>  Un compte avec plusieurs signatures permet √† plusieurs utilisateurs de g√©rer conjointement des actifs (par exemple, les transactions avec des actifs ne peuvent √™tre possibles que si trois utilisateurs sur quatre ont des signatures).  Pour cr√©er des comptes avec plusieurs signatures dans le langage RIDE, nous pouvons utiliser des preuves de transaction. <br><br>  Un compte avec une multi-signature peut √©galement √™tre utilis√© pour un compte s√©questre, dans lequel l'argent est stock√© jusqu'√† ce que les parties √† l'accord remplissent leurs obligations. <br><br><pre> <code class="scala hljs">let alicePubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpM</span></span>M' let bobPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VD</span></span>F' let cooperPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5c</span></span>D' #,     let aliceSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], alicePubKey)) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let bobSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>], bobPubKey)) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let cooperSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>], cooperPubKey)) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> #        aliceSigned + bobSigned + cooperSigned &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  <b>Registre g√©r√© par jeton (TCR)</b> <br><br>  Sur de nombreuses plateformes de blockchain, il y a un probl√®me d'actifs toxiques.  Par exemple, toute adresse ayant pay√© une commission peut cr√©er un actif sur Waves. <br><br>  Le registre organis√© par jetons (TCR) g√©n√©r√© par les d√©tenteurs de jetons aide √† r√©soudre le probl√®me de la protection des utilisateurs et de la cha√Æne de blocs contre les actifs toxiques. <br><br>  Pour voter pour l'ajout d'un jeton sp√©cifique √† la liste, le d√©tenteur fait un pari √©gal √† sa part de jetons du nombre total de jetons √©mis.  Un jeton est inclus dans le registre si la plupart de ses d√©tenteurs ont vot√© pour. <br><br>  Dans notre exemple, nous autorisons l'utilisateur √† ajouter le jeton √† la liste pour examen (pendant la p√©riode de ¬´challenge¬ª) par la cl√© de l'√©tat key = nom_actif, uniquement si la valeur actuelle est count = 0. <br><br>  De plus, l'utilisateur dans le portefeuille doit avoir un solde non nul de ce jeton.  Vient ensuite la p√©riode de vote pendant laquelle l'utilisateur peut voter pour chaque actif de son portefeuille, mais une seule fois, donnant une note de 1 √† 10. Les votes des utilisateurs sont repr√©sent√©s par des cl√©s de la forme user_address + assetID. <br><br><pre> <code class="scala hljs">let asset = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let addingStartHeight = <span class="hljs-number"><span class="hljs-number">1000</span></span> let votingStartHeight = <span class="hljs-number"><span class="hljs-number">2000</span></span> let votingEndHeight = <span class="hljs-number"><span class="hljs-number">3000</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) #     let address = addressFromPublicKey(tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(height &gt; addingStartHeight) then( <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(height &lt; votingStartHeight) then( #adding #,        let hasTokens = assetBalance(address, asset) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> size(t.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> #,        &amp;&amp; !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(asset))) #,   -    <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; extract(getInteger(t.data, toBase58String(asset))) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; hasTokens ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(height &lt; votingEndHeight) then ( #voting #          let currentAmount = extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(asset))) let newAmount = extract(getInteger(t.data, toBase58String(asset))) let betString = toBase58String(address.bytes) + toBase58String(asset) #,          let noBetBefore = !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, betString)) let isBetCorrect = extract(getInteger(t.data, betString)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; extract(getInteger(t.data, betString)) &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span> #,       let hasTokens = assetBalance(address, asset) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> #    size(t.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(asset))) &amp;&amp; newAmount == currentAmount + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; noBetBefore &amp;&amp; isBetCorrect &amp;&amp; hasTokens ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> ) &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <b>Frais d'abonnement</b> <br><br>  Dans cet exemple, nous envisagerons l'utilisation de comptes intelligents pour effectuer des paiements r√©guliers pour un produit ou un service √† des intervalles pr√©d√©termin√©s - des ¬´frais mensuels¬ª. <br>  Si un utilisateur fournit un compte intelligent (via des preuves de transaction) avec un ID TransferTransaction avec le montant requis des fonds transf√©r√©s, il peut √©crire {key: address, value: <b>true</b> } dans l'√©tat du compte. <br><br>  Cela signifie que l'utilisateur confirme l'abonnement au produit ou au service.  Lorsque l'abonnement expire, tout utilisateur du r√©seau peut d√©finir la cl√© correspondante dans l'√©tat sur <b>false</b> . <br><br><pre> <code class="scala hljs">let subscriptionPeriod = <span class="hljs-number"><span class="hljs-number">44000</span></span> let signature = tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>] let pk = tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let requiredAmount = <span class="hljs-number"><span class="hljs-number">100000</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #    let lastPaymentHeight = extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key + <span class="hljs-string"><span class="hljs-string">"_lastPayment"</span></span>)) size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].value == <span class="hljs-string"><span class="hljs-string">"false"</span></span> &amp;&amp; lastPaymentHeight + subscriptionPeriod &lt; height || ( let address = d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key # -  <span class="hljs-type"><span class="hljs-type">ID</span></span>,    let ttx = transactionById(d.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>]) size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].value == <span class="hljs-string"><span class="hljs-string">"true"</span></span> &amp;&amp; d.data[<span class="hljs-number"><span class="hljs-number">1</span></span>].key == address + <span class="hljs-string"><span class="hljs-string">"_lastPayment"</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> ttx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; d.data[<span class="hljs-number"><span class="hljs-number">1</span></span>].value == transactionHeightById(purchase.id) &amp;&amp; toBase58String(purchase.sender.bytes) == address &amp;&amp; purchase.amount == requiredAmount &amp;&amp; purchase.recipient == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> #,   waves &amp;&amp; !isDefined(purchase.assetId) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <b>Vote</b> <br><br>  Les comptes intelligents peuvent √™tre utilis√©s pour impl√©menter le vote sur la blockchain.  Un exemple serait un vote pour le meilleur rapport d'ambassadeur dans le cadre du programme des ambassadeurs.  L'√©tat du compte est utilis√© comme plate-forme pour enregistrer les votes pour l'une ou l'autre option. <br><br>  Dans cet exemple, le vote n'est autoris√© qu'√† ceux qui ont achet√© des jetons ¬´vote¬ª sp√©ciaux.  Le participant envoie une DataTransaction √† l'avance avec une paire de (cl√©, valeur) = (PurchaseTransactionId, buyTransactionId).  Il est interdit de d√©finir une valeur diff√©rente pour cette cl√©.  En utilisant votre adresse et votre option de vote, vous ne pouvez installer DataEntry qu'une seule fois.  Le vote n'est possible que pendant la p√©riode √©tablie. <br><br><pre> <code class="scala hljs">let asset = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let address = addressFromPublicKey(tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) let votingStartHeight = <span class="hljs-number"><span class="hljs-number">2000</span></span> let votingEndHeight = <span class="hljs-number"><span class="hljs-number">3000</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; (height &gt; votingStartHeight &amp;&amp; height &lt; votingEndHeight) &amp;&amp; #,      sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &amp;&amp; #,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key == toBase58String(address.bytes)) then ( #       let purchaseTx = transactionById(t.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let correctSender = purchase.sender == t.sender let correctAsset = purchase.assetId == asset let correctPrice = purchase.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == t.id correctSender &amp;&amp; correctAsset &amp;&amp; correctPrice &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> size(t.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, t.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <b>Lettre de change</b> <br><br>  Une lettre de change est une obligation √©crite en vertu de laquelle une partie doit payer √† l'autre un montant fixe au moment de la demande ou √† une date pr√©d√©termin√©e. <br><br>  Dans notre exemple, un compte intelligent est utilis√©, dont la date d'expiration correspond √† la date de paiement de la facture. <br><br><pre> <code class="scala hljs">let expiration = <span class="hljs-number"><span class="hljs-number">100000</span></span> let amount = <span class="hljs-number"><span class="hljs-number">10</span></span> let asset = base58<span class="hljs-symbol"><span class="hljs-symbol">'9jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let <span class="hljs-type"><span class="hljs-type">Bob</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3NBVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8') let <span class="hljs-type"><span class="hljs-type">Alice</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3PNX6XwMeEXaaP1rf5MCk8weYeF7z2vJZB</span></span>g') <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; (t.assetId == asset)&amp;&amp; (t.amount == amount)&amp;&amp; (t.sender == <span class="hljs-type"><span class="hljs-type">Bob</span></span>)&amp;&amp; (t.recipient == <span class="hljs-type"><span class="hljs-type">Alice</span></span>)&amp;&amp; (sigVerify(t.bodyBytes, t.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], t.senderPublicKey))&amp;&amp; (height &gt;= expiration) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <b>Caution</b> <br><br>  D√©p√¥t - placement de fonds dans une banque √† certaines conditions (dur√©e, pourcentage). <br>  Dans notre exemple, un compte intelligent remplit la fonction d'une banque.  Apr√®s un certain nombre de blocs, ce qui correspond √† la dur√©e du d√©p√¥t, l'utilisateur peut restituer son argent avec un pourcentage.  Le script d√©finit la hauteur du bloc (finalHeight), apr√®s quoi l'utilisateur peut retirer de l'argent du compte. <br><br>  heightUnit - le nombre de blocs dans une unit√© de temps (par exemple, mois, ann√©e, etc.).  Tout d'abord, nous v√©rifions une entr√©e avec une paire (cl√©, valeur) = (initialTransferTransaction, futureDataTransaction).  Ensuite, l'utilisateur doit envoyer √† TransferTransaction les informations correctes sur le montant du d√©p√¥t et les int√©r√™ts courus pour la p√©riode du d√©p√¥t.  Ces informations sont v√©rifi√©es par rapport √† la TransferTransaction d'origine contenue dans la preuve de TransferTransaction actuelle.  depositDivisor est le nombre inverse de la part du d√©p√¥t (si le d√©p√¥t est accept√© √† 10%, la part du d√©p√¥t est de 0,1 et depositDevisor = 1 / 0,1 = 10). <br><br><pre> <code class="scala hljs">let depositDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> let heightUnit = <span class="hljs-number"><span class="hljs-number">1000</span></span> let finalHeight = <span class="hljs-number"><span class="hljs-number">100000</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; #    <span class="hljs-type"><span class="hljs-type">ID</span></span>     let depositHeight = extract(transactionHeightById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #   let purchaseTx = transactionById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> deposit : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let correctSender = deposit.sender == e.sender #,        +  let correctAmount = deposit.amount + deposit.amount / depositDivisor * (height - depositHeight) / heightUnit == e.amount let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(deposit.id))) == e.id correctSender &amp;&amp; correctProof &amp;&amp; correctAmount <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } &amp;&amp; finalHeight &lt;= height <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre><br>  Dans le troisi√®me et dernier article de cette s√©rie, nous examinerons plus d'options d'utilisation des actifs intelligents, y compris le gel et la restriction des transactions pour des adresses sp√©cifiques. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443836/">https://habr.com/ru/post/fr443836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443824/index.html">5 raisons de passer √† l'impression 3D de produits m√©talliques</a></li>
<li><a href="../fr443826/index.html">Emp√™cher l'obsolescence du mat√©riel p√©dagogique</a></li>
<li><a href="../fr443828/index.html">Les origines de la culture de d√©marrage: comment les premi√®res r√©ussites ont fa√ßonn√© l'√©tat moderne de l'industrie technologique</a></li>
<li><a href="../fr443830/index.html">Tesla a pr√©sent√© le nouveau mod√®le Y - d√©tails, photos de la pr√©sentation et impressions du parcours d'essai</a></li>
<li><a href="../fr443834/index.html">Runet au tournant du mill√©naire: qu'en retenez-vous?</a></li>
<li><a href="../fr443838/index.html">Cr√©ez automatiquement des comptes √† partir d'AD dans Zimbra Collaboration Suite</a></li>
<li><a href="../fr443840/index.html">Univention Corporate Server (UCS) - installation d'un serveur LDAP simple et pratique avec un panneau Web et sa connexion avec Nextcloud</a></li>
<li><a href="../fr443842/index.html">Sommes-nous agiles ou agiles nous?</a></li>
<li><a href="../fr443844/index.html">Architecture strat√©gique d'OpenSSL</a></li>
<li><a href="../fr443846/index.html">Acc√®s au serveur Linux √† l'aide du robot Python Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>