<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍩 🎤 👨‍👧‍👧 Tout ce que vous devez savoir sur Node.js 🎧 🧓 💽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article "Tout ce que vous devez savoir sur Node.js" de Jorge Ramón. 





 De nos jours, la plate-f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tout ce que vous devez savoir sur Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460661/"><p>  Bonjour, Habr!  Je vous présente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Tout ce que vous devez savoir sur Node.js"</a> de Jorge Ramón. </p><br><p><img src="https://habrastorage.org/webt/ua/qz/gr/uaqzgrarpig3cxhjdiuiutbxbms.jpeg"></p><br><p>  De nos jours, la plate-forme Node.js est l'une des plates-formes les plus populaires pour créer des API REST efficaces et évolutives.  Il convient également pour la création d'applications mobiles hybrides, de programmes de bureau et même pour l'IoT. </p><br><p>  Je travaille avec la plateforme Node.js depuis plus de 6 ans et j'adore ça.  Ce message essaie principalement d'être un guide sur le fonctionnement réel de Node.js. </p><a name="habracut"></a><br><p>  Commençons !! </p><br><p>  <strong>Ce qui sera discuté:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Monde avant Node.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Problème C10K</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Node.js et la boucle d'événements</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le problème des tâches gourmandes en CPU</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les travailleurs et leurs flux</a> </li></ul><br><a name="p1"></a><br><h3 id="mir-do-nodejs">  Monde avant Node.js </h3><br><p>  <strong>Serveur multithread</strong> </p><br><p>  Les applications Web écrites suivant l'architecture client / serveur fonctionnent comme suit - le client demande la ressource nécessaire au serveur et le serveur envoie la ressource en réponse.  Dans ce schéma, le serveur répond à la demande et met fin à la connexion. </p><br><p>  Ce modèle est efficace car chaque requête adressée au serveur consomme des ressources (mémoire, temps processeur, etc.).  Afin de traiter chaque demande ultérieure du client, le serveur doit terminer le traitement de la précédente. </p><br><p>  Est-ce à dire que le serveur ne peut traiter qu'une seule demande à la fois?  Pas vraiment!  Lorsque le serveur reçoit une nouvelle demande, il crée un <strong>thread</strong> distinct pour le traiter. </p><br><p>  <em>Le flux</em> , en termes simples, est le temps et les ressources que le CPU alloue pour exécuter un petit bloc d'instructions.  Cela dit, le serveur peut traiter plusieurs demandes à la fois, mais une seule par thread.  Un tel modèle est également appelé modèle de <strong>thread par demande</strong> . </p><br><p><img src="https://habrastorage.org/webt/mm/ns/gn/mmnsgnzvz7aptv62xrbo6zxju-w.jpeg"></p><br><p>  Pour traiter N requêtes, le serveur a besoin de N threads.  Si le serveur reçoit N + 1 requêtes, il doit attendre jusqu'à ce qu'un des threads soit disponible. </p><br><p>  Dans la figure ci-dessus, le serveur peut traiter jusqu'à 4 requêtes (threads) à la fois et lorsqu'il reçoit les 3 requêtes suivantes, ces requêtes doivent attendre jusqu'à ce que l'un de ces 4 threads devienne disponible. </p><br><p>  Une façon de se débarrasser des restrictions est d'ajouter plus de ressources (mémoire, cœurs de processeur, etc.) au serveur, mais ce n'est pas la meilleure solution .... </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/qz/zl/ybqzzljzkgej-kirqwza-43amcw.gif"></div><br><p>  Et, bien sûr, n'oubliez pas les limites technologiques. </p><br><p>  <strong>Blocage entrée / sortie</strong> </p><br><p>  Le nombre limité de threads sur le serveur n'est pas le seul problème.  Vous vous demandez peut-être pourquoi un seul thread ne peut pas traiter plusieurs demandes en même temps?  tout cela en raison du <strong>blocage des opérations d'E / S.</strong> </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/ao/02/eiao02s-dtpki8au6sybf8-dmbu.gif"></div><br><p>  Supposons que vous développez une boutique en ligne et que vous ayez besoin d'une page où l'utilisateur peut afficher une liste de tous les produits. </p><br><p>  L'utilisateur frappe sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://yourstore.com/products</a> et le serveur rend un fichier HTML avec tous les produits de la base de données en réponse.  Pas du tout compliqué, non? </p><br><p>  Mais que se passe-t-il en coulisses? </p><br><ul><li> Lorsqu'un utilisateur frappe sur <code>/products</code> méthode ou une fonction particulière doit être exécutée afin de traiter la demande.  Un petit morceau de code (le vôtre ou votre framework) analyse l'URL de la requête et recherche une méthode ou une fonction appropriée.  <strong>Le flux est en cours d'exécution</strong> . <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li>  Maintenant, la méthode ou la fonction souhaitée est exécutée, comme dans le premier paragraphe, le <strong>thread fonctionne.</strong> <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li>  Puisque vous êtes un bon développeur, vous enregistrez tous les journaux système dans un fichier, et bien sûr, pour être sûr que le routeur exécute la méthode / fonction souhaitée - vous enregistrez également la ligne "Méthode X en cours d'exécution !!". Mais tout cela bloque les opérations le <strong>flux d'</strong> entrée / sortie <strong>est en attente</strong> . <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li>  Tous les journaux sont enregistrés et les lignes de fonction suivantes sont exécutées.  <strong>Le fil fonctionne à nouveau</strong> . <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li>  Il est temps d'accéder à la base de données et d'obtenir tous les produits - une simple requête comme les <code>SELECT * FROM products</code> fait son travail, mais devinez quoi?  Oui, il s'agit d'une opération d'E / S bloquante.  <strong>Le flux attend</strong> . <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li>  Vous avez reçu un tableau ou une liste de tous les produits, mais assurez-vous d'avoir promis tout cela.  <strong>Le flux attend</strong> . <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li>  Vous avez maintenant tous les produits et il est temps de rendre le modèle pour la future page, mais avant cela, vous devez les lire.  <strong>Le flux attend</strong> . <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li>  Le moteur de rendu fait son travail et envoie une réponse au client.  <strong>Le fil fonctionne à nouveau</strong> . <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li>  Le flux est libre, comme un oiseau dans le ciel. <img width="20" src="https://habrastorage.org/webt/wr/vg/0_/wrvg0_hul5qltn9qpyg9fv6beua.png"></li></ul><br><p>  Les opérations d'E / S sont-elles lentes?  Eh bien, cela dépend du spécifique.  Regardons le tableau: </p><br><div class="scrollable-table"><table><tbody><tr><th>  <b>Fonctionnement</b> </th><th>  <b>Cycles CPU</b> </th></tr><tr><td>  Registres CPU </td><td>  3 mesures </td></tr><tr><td>  Cache L1 </td><td>  8 mesures </td></tr><tr><td>  Cache L2 </td><td>  12 mesures </td></tr><tr><td>  RAM </td><td>  150 mesures </td></tr><tr><td>  Disque </td><td>  30 000 000 mesures </td></tr><tr><td>  Réseau </td><td>  250 000 000 mesures </td></tr></tbody></table></div><br><p>  Les opérations de lecture du réseau et du disque sont trop lentes.  Imaginez le nombre de demandes ou d'appels vers des API externes que votre système pourrait gérer pendant cette période. </p><br><p>  Pour résumer: les opérations d'E / S font attendre le thread et gaspillent les ressources. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bg/qm/k1/bgqmk13cgzyfg7vmynzpkxdxbdc.gif"></div><br><a name="p2"></a><br><h3 id="problema-c10k">  Problème C10K </h3><br><p>  <strong>Le problème</strong> </p><br><p>  <b>C10k</b> (eng. <i>C10k; connexions 10k</i> - problème de 10 000 connexions) </p><br><p>  Au début des années 2000, les machines serveur et client étaient lentes.  Le problème est survenu lors du traitement de 10 000 connexions client à la même machine en parallèle. </p><br><p>  Mais pourquoi le modèle traditionnel de thread par demande (thread sur demande) ne pouvait-il pas résoudre ce problème?  Eh bien, utilisons un peu de mathématiques. </p><br><p>  L'implémentation native des threads alloue plus de 1 Mo de mémoire par flux, ce qui laisse - pour 10 mille threads, 10 Go de RAM sont requis et cela uniquement pour la pile de flux.  Oui, et n'oubliez pas, nous sommes au début des années 2000 !! </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/af/99/xc/af99xcxnykot0wq-zv20o-6cvps.jpeg"></div><br><p>  Aujourd'hui, les ordinateurs serveurs et clients fonctionnent plus rapidement et plus efficacement et presque tous les langages de programmation ou framework peuvent faire face à ce problème.  Mais en fait, le problème n'est pas réglé.  Pour 10 millions de connexions client à une machine, le problème revient à nouveau (mais maintenant c'est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problème C10M</a> ). </p><br><p>  <strong>Sauvetage JavaScript?</strong> </p><br><p>  Attention Spoilers <img width="70" src="https://habrastorage.org/webt/vl/iw/8n/vliw8nxrmg8paobiiyvuozjxpdc.png">  !!! <br>  Node.js résout réellement le problème C10K ... mais comment?! </p><br><p>  Le JavaScript côté serveur n'était pas quelque chose de nouveau et d'inhabituel au début des années 2000, à cette époque, il y avait déjà des implémentations au-dessus de la JVM (machine virtuelle java) - RingoJS et AppEngineJS, qui travaillaient sur le modèle de thread par demande. </p><br><p>  Mais s'ils ne pouvaient pas résoudre le problème, comment Node.js?!  Tout cela parce que JavaScript est <strong>monothread</strong> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lp/nx/vh/lpnxvhxjbmqmkzmblpqqmfcxq0s.gif"></div><br><a name="p3"></a><br><h3 id="nodejs-i-cikl-sobytiy">  Node.js et la boucle d'événements </h3><br><p>  <strong>Node.js</strong> </p><br><p>  Node.js est une plate-forme serveur qui fonctionne sur le moteur Google Chrome - V8, qui peut compiler du code JavaScript en code machine. </p><br><p>  Node.js utilise un modèle <strong>piloté par les événements</strong> et une architecture d' <strong>E / S non bloquante</strong> , ce qui le rend léger et efficace.  Ce n'est pas un framework, ni une bibliothèque, c'est un runtime JavaScript. </p><br><p>  Écrivons un petit exemple: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Importing native http module const http = require('http'); // Creating a server instance where every call // the message 'Hello World' is responded to the client const server = http.createServer(function(request, response) { response.write('Hello World'); response.end(); }); // Listening port 8080 server.listen(8080);</span></span></code> </pre> <br><p>  <strong>E / S non bloquantes</strong> </p><br><p>  Node.js utilise des opérations d'entrée / sortie non bloquantes, qu'est-ce que cela signifie: </p><br><ul><li>  Le thread principal ne sera pas bloqué par les opérations d'E / S. </li><li>  Le serveur continuera de traiter les demandes. </li><li>  Nous devrons travailler avec du <strong>code asynchrone</strong> . </li></ul><br><p>  Écrivons un exemple dans lequel le serveur envoie une page HTML en réponse à une demande à <code>/home</code> et pour toutes les autres demandes - «Hello World».  Pour envoyer une page HTML, vous devez d'abord la lire à partir d'un fichier. </p><br><p> <code>home.html</code> </p> <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>This is home page<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> <code>index.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.url === <span class="hljs-string"><span class="hljs-string">'/home'</span></span>) { fs.readFile(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ __dirname }</span></span></span><span class="hljs-string">/home.html`</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, content</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!err) { response.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'text/html'</span></span>); response.write(content); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.statusCode = <span class="hljs-number"><span class="hljs-number">500</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'An error has ocurred'</span></span>); } response.end(); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.write(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); response.end(); } }); server.listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>);</code> </pre> <br><p>  Si l'URL demandée est <code>/home</code> , le module natif <code>fs</code> est utilisé pour lire le fichier <code>home.html</code> . </p><br><p>  Les fonctions qui entrent dans <code>http.createServer</code> et <code>fs.readFile</code> comme arguments sont des <strong>rappels</strong> .  Ces fonctions seront exécutées à un moment donné dans le futur (la première dès que le serveur reçoit la demande, et la seconde lorsque le fichier est lu sur le disque et placé dans le tampon). </p><br><p>  Pendant que le fichier est lu depuis le disque, Node.js peut traiter d'autres requêtes et même relire le fichier et tout cela en un seul flux ... mais comment?! </p><br><p>  <strong>Boucle d'événement</strong> </p><br><p>  <strong>La boucle d'événements</strong> est la magie qui se produit à l'intérieur de Node.js.  C'est littéralement une boucle sans fin et en fait un thread. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/sc/go/f_scgo68j5gpf0xsnzklzdr9cjc.jpeg"></div><br><p>  <strong>Libuv</strong> est une bibliothèque C qui implémente ce modèle et fait partie du noyau Node.js.  Vous pouvez en savoir plus sur libuv <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Un cycle d'événements comporte 6 phases, chaque exécution des 6 phases est appelée un <strong>tick</strong> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2k/xy/eq/2kxyeqk7srzdocs9egzl5zlpwhm.png"></div><br><ul><li>  <strong>timers</strong> : dans cette phase, les rappels planifiés par les méthodes <code>setTimeout()</code> et <code>setInterval()</code> sont exécutés; </li><li>  <strong>rappels en attente</strong> : presque tous les <strong>rappels</strong> sont exécutés, à l'exception <code>close</code> événements de <code>close</code> , des temporisateurs et de <code>setImmediate()</code> ; </li><li>  <strong>inactif, préparer</strong> : utilisé uniquement à des fins internes; </li><li>  <strong>sondage</strong> : responsable de la réception de nouveaux événements d'E / S.  Node.js peut bloquer à ce stade; </li><li>  <strong>check</strong> : les rappels provoqués par la méthode <code>setImmediate()</code> sont exécutés à ce stade; </li><li>  <strong>fermer les rappels</strong> : par exemple <code>socket.on('close', ...)</code> ; </li></ul><br><p>  Eh bien, il n'y a qu'un seul thread, et ce thread est une boucle d'événements, mais alors qui effectue toutes les E / S? </p><br><p>  Faites attention <img width="60" src="https://habrastorage.org/webt/92/8i/lj/928iljyzpqhkbczypvvqgkx0zc0.png">  !!! <br>  Lorsqu'une boucle d'événement doit effectuer une opération d'E / S, elle utilise le thread OS du pool de threads et lorsque la tâche est terminée, le rappel est mis en file d'attente pendant la phase de <em>rappels en attente</em> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/z7/uw/lzz7uwcdvm1xd1yr6utj7cae36g.png"></div><br><p>  N'est-ce pas cool? </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/it/yo/bh/ityobhc10qgnkk5m9yk5xp94ble.gif"></div><br><a name="p4"></a><br><h3 id="problema-cpu-yomkih-zadach">  Le problème des tâches gourmandes en CPU </h3><br><p>  Node.js semble parfait!  Vous pouvez créer ce que vous voulez. </p><br><p>  Écrivons une API pour calculer les nombres premiers. </p><br><p>  Un nombre premier est un nombre entier (naturel) supérieur à un et divisible par seulement 1 et par lui-même. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nl/kn/7f/nlkn7fwr_kxhtktm-_gt0ci7ask.jpeg"></div><br><p>  Étant donné un nombre N, l'API doit calculer et renvoyer les premiers N premiers de la liste (ou du tableau). </p><br><p> <code>primes.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>, s = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(n); i &lt;= s; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n % i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nthPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = n; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterator = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(counter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--; iterator++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { isPrime, nthPrime };</code> </pre> <br><p> <code>index.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> primes = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./primes'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pathname, query } = url.parse(request.url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathname === <span class="hljs-string"><span class="hljs-string">'/primes'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = primes.nthPrime(query.n || <span class="hljs-number"><span class="hljs-number">0</span></span>); response.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>); response.write(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(result)); response.end(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.statusCode = <span class="hljs-number"><span class="hljs-number">404</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'Not Found'</span></span>); response.end(); } }); server.listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>);</code> </pre> <br><p>  <code>prime.js</code> est l'implémentation des calculs nécessaires: la fonction <code>isPrime</code> vérifie si le nombre est premier, et nthPrime renvoie N de tels nombres. </p><br><p>  Le fichier <code>index.js</code> est responsable de la création du serveur et utilise le module <code>prime.js</code> pour traiter chaque demande de <code>/primes</code> .  Le nombre N est jeté à travers la chaîne de requête dans l'URL. </p><br><p>  Pour obtenir les 20 premiers nombres premiers, nous devons faire une demande à <code>http://localhost:8080/primes?n=20</code> . </p><br><p>  Supposons que 3 clients nous frappent et tentent d'accéder à notre API d'E / S non bloquante: </p><br><ul><li>  La première interroge 5 nombres premiers toutes les secondes. </li><li>  Le second demande 1000 nombres premiers chaque seconde </li><li>  Le troisième demande 10 000 000 000 de nombres premiers, mais ... </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pz/rx/bl/pzrxblziplf06w7-kzbyojhafhg.gif"></div><br><p>  Lorsque le troisième client envoie une demande, le thread principal est bloqué et c'est le principal symptôme du problème des <strong>tâches gourmandes en CPU</strong> .  Lorsque le thread principal est occupé à effectuer une tâche «lourde», il devient inaccessible aux autres tâches. </p><br><p>  Mais qu'en est-il de libuv?  Si vous vous souvenez, cette bibliothèque aide Node.js à effectuer des opérations d'entrée / sortie à l'aide de threads du système d'exploitation en évitant de bloquer le thread principal et vous avez absolument raison, c'est la solution à notre problème, mais pour que cela soit possible, notre module doit être écrit dans la langue C ++ pour que libuv puisse fonctionner avec. </p><br><p>  Heureusement, à partir de la version 10.5, le module natif <strong>Worker Threads</strong> a été ajouté à Node.js. </p><br><a name="p5"></a><br><h3 id="vorkery-i-ih-potoki">  Les travailleurs et leurs flux </h3><br><p>  Comme nous l'indique la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> : </p><br><blockquote>  Les travailleurs sont utiles pour effectuer des opérations JavaScript gourmandes en CPU;  ne les utilisez pas pour les opérations d'entrée / sortie, les mécanismes déjà intégrés dans Node.js gèrent plus efficacement ces tâches que le thread de travail. </blockquote><p>  <strong>Correction du code</strong> </p><br><p>  Il est temps de réécrire notre code: </p><br><p> <code>primes-workerthreads.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>, s = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(n); i &lt;= s; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n % i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nthPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = n; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterator = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(counter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--; iterator++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } parentPort.postMessage(nthPrime(workerData.n));</code> </pre> <br><p> <code>index-workerthreads.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Worker } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pathname, query } = url.parse(request.url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathname === <span class="hljs-string"><span class="hljs-string">'/primes'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(<span class="hljs-string"><span class="hljs-string">'./primes-workerthreads.js'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">workerData</span></span>: { <span class="hljs-attr"><span class="hljs-attr">n</span></span>: query.n || <span class="hljs-number"><span class="hljs-number">0</span></span> } }); worker.on(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ response.statusCode = <span class="hljs-number"><span class="hljs-number">500</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'Oops there was an error...'</span></span>); response.end(); }); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; worker.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ result = message; }); worker.on(<span class="hljs-string"><span class="hljs-string">'exit'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ response.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>); response.write(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(result)); response.end(); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.statusCode = <span class="hljs-number"><span class="hljs-number">404</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'Not Found'</span></span>); response.end(); } }); server.listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>);</code> </pre> <br><p>  Dans le <code>index-workerthreads.js</code> , chaque demande à <code>/primes</code> crée une instance de la classe <code>Worker</code> (à partir du module natif <code>worker_threads</code> ) pour télécharger et exécuter le <code>primes-workerthreads.js</code> dans le thread de travail.  Lorsque la liste des nombres premiers est calculée et prête, l'événement de <code>message</code> est déclenché - le résultat tombe dans le flux principal car le travailleur n'a plus de travail, il déclenche également l'événement de <code>exit</code> , permettant au flux principal d'envoyer des données au client. </p><br><p>  <code>primes-workerthreads.js</code> a un peu changé.  Il importe <code>workerData</code> (il s'agit d'une copie des paramètres transmis depuis le thread principal) et <code>parentPort</code> via lequel le résultat du travail du travailleur est renvoyé au thread principal. </p><br><p>  Essayons maintenant à nouveau notre exemple et voyons ce qui se passe: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zu/vk/gh/zuvkghy8dnhjryfdf5b62ped8dw.gif"></div><br><p>  Le thread principal n'est plus bloqué <img width="115" src="https://habrastorage.org/webt/nn/hs/r3/nnhsr3jiw_4aed53jye8gokutpy.png">  !!!!! </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/ij/el/ttijelgt36k_vbengx3qjaaajlc.gif"></div><br><p>  Maintenant, tout fonctionne comme il se doit, mais produire des travailleurs sans raison n'est toujours pas une bonne pratique; créer des fils n'est pas un plaisir bon marché.  Assurez-vous de créer un pool de threads avant cela. </p><br><h4 id="zaklyuchenie">  Conclusion </h4><br><p>  Node.js est une technologie puissante qui doit être explorée autant que possible. <br>  Ma recommandation personnelle - soyez toujours curieux!  Si vous savez comment quelque chose fonctionne de l'intérieur, vous pouvez travailler plus efficacement avec. </p><br><p>  C'est tout pour les gars d'aujourd'hui.  J'espère que ce message vous a été utile et que vous avez appris quelque chose de nouveau sur Node.js. </p><br><p>  Merci d'avoir lu et à bientôt dans les prochains articles. <img width="20" src="https://habrastorage.org/webt/bd/lk/kd/bdlkkdf7adtljydvhxyw22y3cfi.png">  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460661/">https://habr.com/ru/post/fr460661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460645/index.html">Faire le bien faire le mal: écrire du code diabolique avec Go, partie 1</a></li>
<li><a href="../fr460647/index.html">Résoudre un travail avec pwnable.kr 05 - mot de passe. Réécrire la table des liens de procédure via la vulnérabilité de chaîne de format</a></li>
<li><a href="../fr460651/index.html">Réunion de la Society of Anonymous Testers: TMS, monitoring monitoring, search quality evaluation and native iOS tests</a></li>
<li><a href="../fr460655/index.html">Comment j'ai brisé Telegram</a></li>
<li><a href="../fr460659/index.html">Utilisation de tuyaux pour pivoter</a></li>
<li><a href="../fr460665/index.html">Projet de FAQ: Pourquoi les normes C ++ sont-elles publiées tous les trois ans?</a></li>
<li><a href="../fr460667/index.html">Automatisation des tests de services payants sur iOS</a></li>
<li><a href="../fr460669/index.html">Comment assurer la sécurité du développement, gagner du temps et des nerfs</a></li>
<li><a href="../fr460671/index.html">Propriété et emprunt en D</a></li>
<li><a href="../fr460673/index.html">Exposez la magie de DiffUtil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>