<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèº üïµüèº üî© C ++ zu komplizieren ist unvermeidlich. Und nicht nur C ++ üå°Ô∏è üö´ üåã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wollte schon lange einen √§hnlichen Text schreiben, aber meine H√§nde reichten nicht. Aber nach dem Ende des Sommertreffens des C ++ - Standardisier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ zu komplizieren ist unvermeidlich. Und nicht nur C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463745/"><p>  Ich wollte schon lange einen √§hnlichen Text schreiben, aber meine H√§nde reichten nicht.  Aber nach dem Ende des Sommertreffens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des C ++ - Standardisierungsausschusses</a> und dem Heulen, dass die Komplexit√§t der Sprache noch weiter zunahm, musste ich die Zeit finden und meine eigenen Gedanken zu diesem Thema festlegen. </p><br><p>  Es wird viel Text geben, also lade ich diejenigen, die ihre Zeit nicht bereuen, ein, unter die Katze zu schauen. </p><br><h1>  Programmiersprache ist ein technologisches Produkt, aber nicht so einfach </h1><br><p>  Vor einiger Zeit hatte ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Gelegenheit, ein interessantes Buch zu lesen, The Innovator‚Äôs Dilemma</a> .  Dort wird anhand von Beispielen f√ºr Hightech-Produkte gezeigt, wie neue Produkte entstehen, die zun√§chst gegen die derzeit marktbeherrschenden Entscheidungen verlieren und dann die Marktlage radikal ver√§ndern. </p><br><p>  Eines der auff√§lligsten Beispiele: Die digitale Fotografie, die in den 1990er Jahren v√∂llig fehlte, aber nur 20 Jahre sp√§ter zum Zusammenbruch eines Monsters des 20. Jahrhunderts wie Kodak f√ºhrte (das √ºbrigens als erstes einen Prototyp einer Digitalkamera herstellte). </p><br><img src="https://www.kodak.com/Kodak/uploadedImages/Corporate/About_Us/Heritage/Milestones/timeline_photo_first_digital_cameras_fullres.jpg" alt="Bild"><br><a name="habracut"></a><br><p>  Ein weiteres Beispiel in der N√§he von Entwicklern ist die Entwicklung von Festplatten.  Von den gewaltigen Monstern der Mainframe- und Mini-Computer-√Ñra √ºber die kleinen 3,5- und 2,5-Zoll-Modelle bis hin zu SSDs im M.2-Format, die direkt mit der eMMC-Karte verbunden sind. </p><br><img src="http://mirtayn.ru/wp-content/uploads/disk_ibm2.jpg" alt="Bild"><br><br><p>  Das Gleiche gilt f√ºr Disketten, die zuerst 3,5 Zoll erreichten und dann als Klasse unter dem Druck von USB-Sticks verschwanden. </p><br><img src="https://gallery.ykt.ru/galleries/old/comp/758583.jpg" alt="Bild"><br><br><p>  Ein weiteres Beispiel aus unserem Berufsfeld ist die Entwicklung von PCs.  Die anfangs nicht mit den "echten" Computern der Mitte der sp√§ten 1970er Jahre mithalten konnten.  Und dann haben sie einfach die Mini-Computer als Klasse zerst√∂rt.  Dann entstanden moderne Server, die etwas an die damaligen Mini-Computer erinnerten.  Und jetzt verschwinden die PCs selbst unter dem Einfluss von Laptops, Tablets und Smartphones aus dem Massenkonsum. </p><br><img src="https://tr3.cbsistatic.com/hub/i/r/2014/04/07/a0e20eb1-1ca5-4cd0-ae58-85444fa9a1b6/resize/770x/d2a4495ff19c02a50544523af4c406e7/system360model-75e.jpg" alt="Bild"><br><br><p>  Die Autoren des Buches erkl√§ren, dass sich Ereignisse in all diesen F√§llen nach demselben Szenario entwickeln: </p><br><ul><li>  Erstens besteht ein Bedarf an einem Produkt, das ein bestimmtes Problem l√∂st.  Nehmen wir eine flexible Magnetplatte an. </li><li>  Da in der Anfangsphase alle konkurrierenden L√∂sungen (von denen es im Prinzip nur wenige gibt) auf denselben Technologien basieren, wird der Markt zwischen mehr oder weniger √§hnlichen Produkten aufgeteilt. </li><li>  Hersteller erfolgreicher Produkte beginnen miteinander zu konkurrieren und bringen ihre Produkte in diesem Wettbewerb fast auf das g√ºnstigste Preis-Leistungs-Verh√§ltnis.  Und vor allem, w√§hrend vorhandene Produkte so konsistent wie m√∂glich mit den Ansichten dar√ºber sind, wie die Aufgaben, f√ºr die diese Produkte bestimmt sind, angegangen werden sollen.  Grob gesagt wei√ü jeder, dass 8-Zoll-Disketten hervorragend geeignet sind, um Informationen mithilfe von Disketten von einem Mini-Computer auf einen anderen zu √ºbertragen. Und niemand sonst kann sich im Mainstream einen anderen Weg vorstellen. </li><li>  Irgendwo am Rande, basierend auf einigen neuen Entdeckungen / Materialien / Technologien, erscheint ein neues Produkt, das bestehenden Produkten in fast jeder Hinsicht deutlich unterlegen ist.  Generell teurer.  In der Regel nicht vergleichbar in F√§higkeiten / Kapazit√§ten.  Aber es hat eine sehr wichtige Qualit√§t: Es kann dort eingesetzt werden, wo es unm√∂glich oder schwierig ist, Mainstream-L√∂sungen anzuwenden.  Sie k√∂nnen beispielsweise kein 8-Zoll-Laufwerk an einen PC anschlie√üen. PC-Besitzer sind jedoch nicht daran interessiert, 8-Zoll-Disketten mitzuf√ºhren.  Es ist einfach nicht praktisch.  W√§hrend eine 5,25 "-Diskette eine Selbstverst√§ndlichkeit ist. Und es ist egal, dass eine 5,25" -Diskette auf Kosten eines Kilobyte urspr√ºnglich teurer als 8 war. "Es gab immer noch keine Wahl. </li><li>  Um das neue Produkt herum bildete sich ein neuer Markt, der f√ºr die g√§ngigen Produkthersteller zun√§chst √ºberhaupt nicht interessant war.  Da es sich jedoch um einen neuen Markt handelte, str√∂mten neue Spieler dorthin, was zu einem ernsthaften Wettbewerb untereinander f√ºhrte.  Und dieser Wettbewerb setzte marginale und ineffektive Technologien schnell in √§u√üerst effektive um.  Was bald aufh√∂rte, marginal zu sein, denn sobald es die alten Mainstream-Produkte in seiner Gesamtheit √ºbertraf, ersetzte es sie schnell in ihrer eigenen Nische.  Grob gesagt, wenn es Hunderttausende von 5,25-Zoll-Laufwerken und Millionen von 5,25-Zoll-Disketten gibt, was bringt es dann im Moment, an den viel marginaleren 8-Zoll-Ger√§ten festzuhalten? </li></ul><br><h2>  Programmiersprachen als technologische Produkte </h2><br><p>  Auf den ersten Blick lassen sich √§hnliche Analogien in der Art und Weise erkennen, wie Programmiersprachen zum Mainstream kamen.  Und die vielleicht auff√§lligsten Beispiele hierf√ºr sind die Sprachen Java und Go. </p><br><p>  Die Java-Sprache entstand durch den Versuch, ‚Äûrichtiges C ++‚Äú zu erstellen.  Aber die resultierende Sprache w√ºrde kaum jemand brauchen, weil  Er war sehr elend und vor allem langsam und gefr√§√üig.  Auf dem damaligen Desktop hatte Java trotz des rasanten Wachstums der PC-Leistung zu dieser Zeit keine Chance. </p><br><p>  Java trat jedoch aus einer v√∂llig anderen Perspektive in den ‚ÄûMarkt‚Äú ein, und zwar durch eine Nische, in der damals niemand wirklich arbeiten konnte: √ºber das Internet und Browser-Applets (alles war etwas komplizierter und es gab immer noch einen Markt f√ºr JavaCard- und STK-Applets, aber wir werden nicht gehen in der Wildnis).  Das Internet war ein sehr hei√ües Thema, und dann gab es einfach nichts zu tun, um dynamische Websites / Seiten zu erstellen (JavaScript erschien nach der Ank√ºndigung von Java).  Und da au√üer Java nichts zu verwenden war, wurde Java verwendet.  Nun, und dann, als es Kinderkrankheiten entwickelte und √ºberwand, ging Java in andere Bereiche und verdr√§ngte von dort aus andere Technologien.  Obwohl sie sich auf demselben Desktop befand, konnte sie sich kein bedeutendes St√ºck vom Kuchen bei√üen. </p><br><p>  Die Go-Sprache konnte kaum jemanden f√ºr traditionelle Nischen interessieren, in denen C, C ++, Java, C #, Python, Ruby usw. bereits lebten.  Die Entwicklung von Produkten f√ºr das Internet hat jedoch eine weitere Nische hervorgebracht - RESTful Services.  F√ºr die Entwicklung, bei der Java ein Overkill war, ist C ++ zu kompliziert und gef√§hrlich, Python / Ruby und andere Dynamiken sind zu langsam.  Und jetzt wird eine der elendesten in den Ausdrucksformen der im 21. Jahrhundert entwickelten Sprachen fast zu einer Silberkugel f√ºr diese angewandte Nische.  Von wo aus wird es sich vielleicht im Laufe der Zeit anderswo ausbreiten (was mich angesichts des allgemeinen Qualifikationsniveaus der jungen Entwicklergeneration pers√∂nlich nicht √ºberrascht). </p><br><p>  Man hat also das Gef√ºhl, dass die Programmierung bei Sprachen die gleiche sein sollte wie bei anderen technologischen Produkten: Die Entstehung neuer Sprachen f√ºhrt entweder zu einem fast vollst√§ndigen Verschwinden oder dazu, dass fr√ºhere Sprachen in separate Randnischen verdr√§ngt werden.  Gleichzeitig werden alte Sprachen im Zuge ihrer Entwicklung im Rahmen des Wettbewerbsumfelds leistungsf√§higer und ausdrucksvoller f√ºr billigere L√∂sungen f√ºr ihre typischen Aufgaben.  Infolgedessen werden alte Sprachen immer umfangreicher und komplexer.  Und weniger attraktiv f√ºr den Einsatz au√üerhalb der Nischen, die sie bereits besetzt haben. </p><br><p>  Daher sollte sich der im Innovator's Dilemma beschriebene Lebenszyklus eines technologischen Produkts auch auf Programmiersprachen erstrecken. </p><br><h2>  Aber mit Programmiersprachen ist nicht alles so einfach </h2><br><p>  Bei dem im Innovator's Dilemma beschriebenen Schema der Marktdurchdringung neuer technologischer Produkte ist einer der wichtigsten Gr√ºnde f√ºr Benutzer, von alten Mainstream-Produkten zu neuen zu wechseln, entweder einfach eine signifikante Reduzierung der Betriebskosten oder der Erwerb zuvor verf√ºgbarer M√∂glichkeiten + eine Verringerung der Betriebskosten. </p><br><p>  Die Entwicklung von PCs und das Wachstum ihrer Leistung machen den Besitz einer PC-Flotte billiger als den Besitz eines oder mehrerer Mini-Computer.  Infolgedessen sind Drei-Zoll-Disketten pro Kapazit√§tseinheit billiger als 5,25 Zoll (unter Ber√ºcksichtigung einer h√∂heren Zuverl√§ssigkeit und anderer Faktoren). Die digitale Fotografie ist letztendlich pro Bild billiger als Filme. Und so weiter. </p><br><p>  Mit dem √úbergang von einem Produkt zu einem anderen sind jedoch zwei weitere wichtige Indikatoren verbunden: Dies sind die Kosten / Komplexit√§t des √úbergangs selbst sowie die Geschwindigkeit, mit der Sie zu einem neuen Produkt wechseln k√∂nnen.  Diese Indikatoren k√∂nnen in Geld gesch√§tzt werden.  Und wenn der Nutzen des √úbergangs zu einem neuen Produkt vorhanden ist, wird der √úbergang durchgef√ºhrt.  Vielleicht nicht schnell, aber durchgef√ºhrt. </p><br><p>  Und hier stellt sich heraus, dass die Kosten f√ºr den Wechsel von einer Programmiersprache zu einer anderen viel h√∂her sind als beim Wechsel von einem Mini-Computer zu einem PC, von 8 "Disketten auf 5,25" oder von HDD zu SSD.  Da das √Ñndern einer Programmiersprache normalerweise ein vollst√§ndiges Umschreiben eines Softwareprodukts ist.  Oft von Grund auf neu. </p><br><p>  Und was bedeutet Umschreiben?  Gehalt eines neuen Teams von Programmierern, die die bereits im Produkt verf√ºgbaren Funktionen wiederholen m√ºssen.  Und selbst wenn Sie mit dem neuen PL die Gr√∂√üe des Teams halbieren k√∂nnen, bedeutet dies dennoch erhebliche Kosten.  Wenn 10 Millionen US-Dollar f√ºr die Entwicklung der alten Version des Produkts ausgegeben wurden, sind f√ºr das Umschreiben mindestens 5 Millionen US-Dollar erforderlich. </p><br><p>  Noch wichtiger ist jedoch, dass das umgeschriebene Produkt nicht sofort angezeigt wird.  Es braucht Zeit.  Lange Zeit.  Unter der Annahme, dass Sie mit der neuen Sprache doppelt so schnell Arbeitscode schreiben k√∂nnen, dauert das Umschreiben eines Produkts, dessen Entwicklung einer alten Version 5 Jahre gedauert hat, nur 2,5 Jahre. </p><br><p>  Es stellt sich heraus, dass Sie jetzt anfangen m√ºssen, viel Geld zu investieren, um eine Kopie von etwas zu erhalten, das schon lange funktioniert und jetzt Geld bringt. </p><br><p>  Und noch eine Seite dieser Medaille muss erw√§hnt werden: Wenn ein Softwareprodukt unter sich √§ndernden Bedingungen betrieben wird, wird das Produkt zwangsl√§ufig finalisiert oder verarbeitet, um den modernen Anforderungen gerecht zu werden.  Gleichzeitig hat das Unternehmen nicht die M√∂glichkeit, anderthalb Jahre zu warten, bis eine neue Version des Produkts auf einem neuen PL erscheint. In absehbarer Zeit sind in der Regel neue Funktionen erforderlich.  Oft gestern. </p><br><p>  Daher steigen beim Umschreiben die Kosten: Sie m√ºssen gleichzeitig eine neue Version schreiben und die alte entwickeln. </p><br><p>  Meiner Meinung nach erkl√§rt genau dies, warum neue Sprachen "gefeuert" werden, vor allem bei der Entwicklung neuer Anwendungen f√ºr eine neue Anwendungsnische.  Aber alte Sprachen aus zuvor besetzten Gebieten zu verdr√§ngen ist schon viel langsamer.  Fortran und Cobol k√∂nnen wahrscheinlich als die auff√§lligsten Beispiele angesehen werden.  Die darauf geschriebene Software ist nicht nur noch in Betrieb, sondern sie schreiben auch weiterhin neuen Code in diesen Sprachen.  Und diese Sprachen selbst entwickeln sich weiter. </p><br><p>  Und es scheint mir, dass einer der schlimmsten Tr√§ume von Besitzern von Softwareprodukten in Cobol darin besteht, das Produkt in Java oder C # umzuschreiben;) </p><br><h2>  Und noch ein wichtiger Faktor: die Entwicklung der IT selbst </h2><br><p>  Ein weiterer Punkt, auf den ich aufmerksam machen m√∂chte, ist die Tatsache, dass die IT vor nicht allzu langer Zeit existiert und die Geschichte der Entwicklung der Hochsprachen noch k√ºrzer ist.  Es ist unwahrscheinlich, dass der erste Teil dieser Geschichte uns eine solide Unterst√ºtzung f√ºr unsere Diskussion dar√ºber bietet, wie einige Sprachen andere ersetzen.  Die 1950er und 1960er Jahre waren Jahre des Experimentierens.  Dar√ºber hinaus wurden die Jahre, in denen der Computermarkt selbst segmentiert und ein wesentlicher Teil der Software f√ºr bestimmte Computer und Betriebssysteme geschrieben wurde, ohne besondere Anforderungen an die Portabilit√§t geschrieben.  Die Anzahl der vorhandenen Softwareentwickler sowie die Bandbreite der Bereiche, in denen Computer weit verbreitet sind, k√∂nnen nicht mit dem aktuellen Stand der Dinge verglichen werden. </p><br><p>  Meiner Meinung nach haben sich die Dinge in den 1970er Jahren grundlegend ge√§ndert, und seit den 1980er Jahren haben wir das Auftreten von Atomwaffen gesehen, die bereits sowohl auf den praktischen Erfahrungen der vergangenen Jahre als auch auf den Ergebnissen theoretischer Studien beruhen.  F√ºr mich sind genau die 1980er (und m√∂glicherweise die sp√§ten 1970er) der Beginn der √Ñra der Programmiersprachen, die auf die Herstellung von Software im industriellen Ma√üstab abzielen.  Denn hier sehen wir Modula-2, SmallTalk, Ada, C ++, Eiffel, Objekterweiterungen von Pascal, Objective-C, Perl. </p><br><p>  Deshalb werde ich weiter von genau dem ausgehen, was in dieser √Ñra der industriellen Atomwaffen erschienen ist. </p><br><h3>  √úbrigens </h3><br><p>  Als ich die Sprachen auflistete, die in den 1980er Jahren erschienen, erinnerte ich mich an den von Niklaus Wirth entwickelten PL: zuerst Pascal, dann Modula / Modula-2, dann Oberon. </p><br><p>  Am Beispiel dieser Sprachen kann man sehen, wie die Erfahrung ihres Autors zum Erscheinen von Werkzeugen f√ºhrt, die die M√§ngel fr√ºherer Versuche ber√ºcksichtigen und die neuen Anforderungen ihrer Zeit erf√ºllen. </p><br><p>  Dieselben Sprachen zeigen aber auch, wie wichtig es f√ºr Benutzer von YaP ist, im Rahmen der einmal gew√§hlten Sprache zu bleiben.  Der √úbergang von Pascal zu Modula-2 war.  Aber keineswegs massiv.  Und trotz der Tatsache, dass Modula-2 mehr oder weniger aktiv eingesetzt wurde, wurde es nicht so popul√§r wie die Erben von Pascal, insbesondere Delphi.  Und soweit ich mich erinnere, war √ºberhaupt kein √úbergang nach Oberon zu beobachten. </p><br><h1>  Die beliebte Programmiersprache kann nicht einfach ersetzt werden.  Und was ist damit? </h1><br><p>  Die Hauptbotschaft in meiner vorherigen Diskussion ist also, dass diese Sprache nicht vollst√§ndig durch andere Programmiersprachen ersetzt werden kann, wenn eine Sprache mehr oder weniger weit verbreitet ist und mit ihrer Hilfe viele verschiedene Softwareprodukte erstellt wurden, die im t√§glichen Gebrauch sind.  Besonders in kurzer Zeit. </p><br><p>  Erfolgreiche Programmiersprachen sind dazu verdammt, jahrelang weiter verwendet zu werden.  Und am wahrscheinlichsten zu entwickeln. </p><br><p>  Und die Entwicklung einer Programmiersprache beinhaltet die Erweiterung der Sprache um neue Funktionen.  Welches ist unvermeidlich, weil  Fortschritt steht nicht still.  Die Leute finden bequemere Wege, um bekannte Probleme zu l√∂sen.  Konfrontiert mit neuen Aufgaben, die zus√§tzliche Ausdrucksf√§higkeiten von Programmiersprachen erfordern.  Und da die Programmiersprache nur ein Werkzeug ist, arbeiten die Leute daran, ihr Werkzeug zu verbessern. </p><br><p>  Dies bedeutet, dass weit verbreitete Programmiersprachen einfach dazu verdammt sind, im Laufe ihrer Entwicklung immer umfangreicher und komplexer zu werden und M√∂glichkeiten zu erhalten, die zun√§chst nicht einmal diskutiert wurden. </p><br><p>  Grunds√§tzlich hat Bjarn Straustrup vor langer Zeit dar√ºber gesprochen.  Und selbst das, was ich selbst seit fast drei√üig Jahren beobachte, best√§tigt die Worte von Straustrup.  Angenommen, modernes Java unterscheidet sich bereits stark von Java 1.0 von 1995.  Die C # -Sprache zeigt eine noch beeindruckendere Entwicklung von einem erfolgreichen Klon des ersten Java zu der vielleicht ausdrucksst√§rksten Mainstream-Sprache, die f√ºr hinduistische Programmierer geeignet ist (unabh√§ngig von ihrer Nationalit√§t). </p><br><p>  Aber das auff√§lligste Beispiel f√ºr mich ist immer noch die Go-Sprache.  Was sie bereits im 21. Jahrhundert begannen, indem sie absichtlich eine Reihe von Dingen wegwarfen, die sich in den Jahrzehnten der weit verbreiteten Verwendung in verschiedenen Kernmaterialien bew√§hrt haben.  Und welcher Dank, einschlie√ülich dieser, ist popul√§r geworden.  Trotzdem fordert das Leben seinen Tribut und Go ist gezwungen, etwas hinzuzuf√ºgen, das die Autoren urspr√ºnglich absichtlich abgelehnt haben - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tools f√ºr die allgemeine Programmierung (auch bekannt als Vorlagen / Generika)</a> . </p><br><p>  Daher entwickeln sich beliebte Programmiersprachen weiter, um ihre F√§higkeiten zu erweitern.  Und das bedeutet Komplikationen.  Da m√ºssen neue Funktionen hinzugef√ºgt werden, um den bereits geschriebenen Code nicht ernsthaft zu besch√§digen.  Denn die epische Geschichte mit Python der zweiten und dritten Version wurde ein gutes Beispiel, das nur wenige zu wiederholen wagen. </p><br><h2>  Ist es so schlimm </h2><br><p>  Die negative Seite der st√§ndig zunehmenden Komplexit√§t von Programmiersprachen (insbesondere einer Sprache wie C ++) scheint offensichtlich zu sein: Die Eingabeschwelle ist zu hoch.  Es muss zu viel Zeit f√ºr das Erlernen einer Sprache aufgewendet werden, um in einem akzeptablen Zeitrahmen einen Code von akzeptabler Qualit√§t herauszugeben.  Was macht die Entwicklung in einer komplexen Programmiersprache sowohl teuer als auch riskant?  Was passiert, wenn ein oder mehrere qualifizierte Entwickler das Projekt verlassen?  Wie schnell und einfach wird es sein, einen Ersatz zu finden?  Schwierige Fragen. </p><br><p>  Da andererseits eine Programmiersprache dasselbe Werkzeug zum Aufzeichnen der Absichten einer bestimmten Person ist, wie beispielsweise mathematische Ausdr√ºcke, ist es angebracht, eine Analogie zur Mathematik zu ziehen. </p><br><p>  In der Schule beginnen wir Mathematik zu studieren, beginnend mit den einfachsten arithmetischen Operationen.  Dann gehen wir zu komplexeren Dingen √ºber: Br√ºche, Grade und Wurzeln.  Dann gehen wir weiter in Richtung der Logarithmen.  Dann nehmen wir eine kleine Integralrechnung.  √Ñhnliches gilt f√ºr die Geometrie. </p><br><p>  Infolgedessen verf√ºgt ein Absolvent einer normalen High School √ºber einen bestimmten mathematischen Apparat, der f√ºr eine einzelne Person m√∂glicherweise √ºberfl√ºssig ist.  Ich werde mich nicht irren, wenn ich davon ausgehe, dass viele nach der Schule nie etwas mit Logarithmen berechnen oder Integrale nehmen mussten. </p><br><p>  Trotzdem kann der mathematische Apparat, der in der High School beherrscht wird, nicht mit der Tatsache verglichen werden, dass Universit√§tsstudenten dann Kurse in h√∂herer Mathematik erhalten.  Vor allem, wenn es sich um einen Studenten einer mathematischen oder physikalischen Fakult√§t handelt (und nicht nur ernsthaft h√∂here Mathematik in vielen Fachgebieten herunterl√§dt). </p><br><p>  Aber es f√§llt niemandem ein, die Mathematik daf√ºr verantwortlich zu machen, dass es umso schwieriger ist, je tiefer man in sie eintaucht.  Da eine Person mit einem T√§tigkeitsbereich konfrontiert ist, in dem sie TFKP ben√∂tigt, kann nichts unternommen werden, und TFKP muss studieren.  Wie schwierig es auch sein mag.  Nun ja, es ist normal, dass nicht jeder Erfolg hat. </p><br><p>  Eigentlich das gleiche mit Programmiersprachen. </p><br><p>  Wenn Sie relativ einfache Probleme l√∂sen m√ºssen, haben Sie die Wahl: Entweder verwenden Sie eine einfachere Programmiersprache oder Sie verwenden eine begrenzte Teilmenge einer komplexeren Sprache.  Wenn Sie jedoch vor einer schwierigen Aufgabe (oder bestimmten Bedingungen f√ºr deren L√∂sung) stehen, haben Sie m√∂glicherweise √ºberhaupt keine solche Wahl: Die Komplexit√§t der L√∂sung dieses Problems in einer ‚Äûeinfachen‚Äú Sprache ist m√∂glicherweise zu gro√ü. </p><br><h2>  Apropos Aufgaben </h2><br><p>      ,        (..  ,  ,        ,  ..,  ..),          ,         . </p><br><p>       .        , ..         ,        .  ,  ,     . ,  ,      ,        .  , ,     ,       . </p><br><p>  ,     ,  Go, Python, Ruby  PHP,  ,      ,      ,  .  ,  ,         ,  ,          .           . </p><br><p> ,        ,     ,    ,    .  ,  25           GUI     ,          .        ,   25      . </p><br><p>     ,          ,    ,        .    ,     /      ,        ,      . </p><br><p>  ,   , ,         ,       ,  C++, Scala  Haskell. ,   ,       .   ,  ,           Go   C. </p><br><p>             .   . ,    ,    :        ,    ,      . ,  -    C++,     . .., -,    C++   . , -,        C++   ,    ,   . </p><br><h1>  Insgesamt </h1><br><p> ,      ?  : </p><br><ul><li> -,  . ,    ,   ,    ¬´ ¬ª,      1960-1970- ,   .     ,       .      ,   .        (     ).   -       X,             ,   X   . ,        C.  ,      .     . ,    ‚Äî    .           ; </li><li> -,          ,     40 ,       .   ,  ,    .    , ..     ,     ,     ; </li><li> -,       . -   Ruby/Python, -  Go, -      Java.   -   Rust-, C++, Scala  Haskell-.          ,       .     - ,       ¬´  ¬ª,            .  Und das ist normal. </li></ul><br><p>  , , - :      ,      -     .       - .       ,    (  ,           ,   ).   ,       - ,   ,     :   ,   ,      -.      ;) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463745/">https://habr.com/ru/post/de463745/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463733/index.html">Mesh VS WiFi: Was soll man f√ºr Wireless w√§hlen?</a></li>
<li><a href="../de463735/index.html">Qrator Filtering Network Configuration Delivery System</a></li>
<li><a href="../de463737/index.html">Probleml√∂sung mit pwnable.kr 21 - horcuxes. R√ºckgabeorientierte Programmierung und ROP-Ketten</a></li>
<li><a href="../de463739/index.html">Qrator Filter Netzwerkkonfigurations-Managementsystem</a></li>
<li><a href="../de463741/index.html">Mit Firefox (bereits behoben) und Chrome k√∂nnen Sie den Alt-Svc-Header zum Scannen von Intranet-Ports verwenden</a></li>
<li><a href="../de463747/index.html">Greifen Sie auf Eigenschaften im Jsonb-Feld f√ºr Npgsql zu</a></li>
<li><a href="../de463749/index.html">Scrum vs Kanban: Bleib ruhig und w√§hle, was besser zu dir passt</a></li>
<li><a href="../de463751/index.html">iOS 13: Was Sie brauchen und was Sie bei der Entwicklung f√ºr ein neues Betriebssystem absolut nicht tun m√ºssen</a></li>
<li><a href="../de463753/index.html">PVS-Studio besucht Apache Hive</a></li>
<li><a href="../de463755/index.html">Der Unterschied zwischen "Juni", "Mitte" und "Senior". Und was tun, um eine Ebene h√∂her zu kommen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>