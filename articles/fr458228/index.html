<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêæ üçü üìç Pourquoi avons-nous besoin de fonctions virtuelles üçí üÜë üëø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Habr. Si vous connaissez la r√©ponse √† la question dans le titre, f√©licitations, vous n'avez pas besoin de cet article. Il s'adresse aux d√©butan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi avons-nous besoin de fonctions virtuelles</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458228/"> Salut, Habr.  Si vous connaissez la r√©ponse √† la question dans le titre, f√©licitations, vous n'avez pas besoin de cet article.  Il s'adresse aux d√©butants en programmation, comme moi, qui ne peuvent pas toujours comprendre ind√©pendamment toutes les subtilit√©s du C ++ et d'autres langages typ√©s, et s'ils le peuvent, il vaut mieux apprendre des erreurs des autres de toute fa√ßon. <br><br>  Dans cet article, je ne r√©pondrai pas seulement √† la question " <i>Pourquoi avons-nous besoin de fonctions virtuelles en C ++</i> ", mais je donnerai un exemple de ma pratique.  Pour une r√©ponse br√®ve, vous pouvez vous tourner vers les moteurs de recherche qui produisent quelque chose comme ceci: " <i>Les fonctions virtuelles sont n√©cessaires pour fournir le polymorphisme - l'une des trois baleines OOP. Gr√¢ce √† elles, la machine elle-m√™me peut d√©terminer le type d'objet par pointeur, sans charger le programmeur avec cette t√¢che.</i> "  D'accord, mais la question ¬´pourquoi¬ª demeure, bien que cela signifie maintenant un peu diff√©rent: ¬´ <i>Pourquoi compter sur la machine, consacrer plus de temps et de m√©moire, si vous pouvez podcoder le pointeur vous-m√™me, car le type d'objet auquel il se r√©f√®re est presque toujours connu?</i> ¬ª En effet, le casting √† premi√®re vue laisse les fonctions virtuelles sans travail, et c'est ce qui provoque des id√©es fausses et un mauvais code.  Dans les petits projets, la perte est invisible, mais, comme vous le verrez bient√¥t, avec la croissance du programme, les castes augmentent le r√©f√©rencement dans une progression presque g√©om√©trique. <br><a name="habracut"></a><br>  Tout d'abord, rappelons o√π les castes et les fonctions virtuelles peuvent √™tre n√©cessaires.  Un type est perdu lorsqu'un objet d√©clar√© avec le type A se voit allouer une nouvelle op√©ration pour allouer de la m√©moire √† un objet de type B compatible avec le type A, g√©n√©ralement h√©rit√© de A. Le plus souvent, l'objet n'est pas un, mais un tableau entier.  Un tableau de pointeurs du m√™me type, chacun attendant l'attribution d'une zone m√©moire avec des objets de types compl√®tement diff√©rents.  Voici un exemple que nous allons consid√©rer. <br><br>  Je ne vais pas tra√Æner longtemps, la t√¢che √©tait la suivante: sur la base d'un document balis√© avec le langage de balisage hypertexte Markedit (vous pouvez le lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ), construire un arbre d'analyse et cr√©er un fichier contenant le m√™me document en balisage HTML.  Ma solution consiste en trois routines s√©quentielles: analyser le texte source en jetons, construire une arborescence de syntaxe √† partir de jetons et construire un document HTML sur sa base.  Nous sommes int√©ress√©s par la deuxi√®me partie. <br>  Le fait est que les n≈ìuds de l'arborescence de destination ont diff√©rents types (section, paragraphe, n≈ìud de texte, lien, note de bas de page, etc.), mais pour les n≈ìuds parents, les pointeurs vers les n≈ìuds enfants sont stock√©s dans le tableau, et ont donc un type - Node. <br><br>  L'analyseur lui-m√™me, sous une forme simplifi√©e, fonctionne comme ceci: il cr√©e la ¬´racine¬ª de l'arbre de syntaxe d' <b>arbre</b> avec le type <b>racine</b> , d√©clare un pointeur <b>open_node</b> du type g√©n√©ral <b>Node</b> , auquel est imm√©diatement attribu√©e l'adresse d' <b>arbre</b> , et la variable <b>type</b> du <b>type</b> √©num√©r√© <b>Node_type</b> , puis la boucle d√©marre, <b>it√©rant</b> sur les jetons d√®s le premier au dernier.  √Ä chaque it√©ration, le type du n≈ìud ouvert <b>open_node</b> est d'abord entr√© dans la variable type (les types sous forme d'√©num√©ration sont stock√©s dans la structure du n≈ìud), suivi de l' <b>instruction switch</b> , qui v√©rifie le type du prochain jeton (les types de jetons sont d√©j√† soigneusement fournis par le lexeur).  Dans chaque branche du commutateur, une autre branche est pr√©sent√©e qui v√©rifie la variable de <b>type</b> , o√π, comme nous le rappelons, le type du n≈ìud ouvert est contenu.  En fonction de sa valeur, diff√©rentes actions sont effectu√©es, par exemple: ajouter une liste de n≈ìuds d'un certain type √† un n≈ìud ouvert, ouvrir un autre n≈ìud d'un certain type dans un n≈ìud ouvert et transmettre son adresse √† <b>open_node</b> , fermer le n≈ìud ouvert, <b>lever</b> une exception.  Applicable au sujet de l'article, nous nous int√©ressons au deuxi√®me exemple.  Chaque n≈ìud ouvert (et g√©n√©ralement chaque n≈ìud pouvant √™tre ouvert) contient d√©j√† un tableau de pointeurs vers des n≈ìuds de type <b>Node</b> .  Par cons√©quent, lorsque nous ouvrons un nouveau n≈ìud dans un n≈ìud ouvert (nous attribuons la zone de m√©moire pour un objet d'un autre type au pointeur de tableau suivant), pour un analyseur s√©mantique C ++, il reste une instance de type <b>Node</b> sans acqu√©rir de nouveaux champs et m√©thodes.  Un pointeur est d√©sormais affect√© √† la variable <b>open_node</b> , sans perdre le type de <b>Node</b> .  Mais comment travailler avec un pointeur d'un type <b>Node</b> g√©n√©ral lorsque vous devez appeler une m√©thode, par exemple un paragraphe?  Par exemple, <b>open_bold ()</b> , qui ouvre un n≈ìud de police en gras dedans?  Apr√®s tout, <b>open_bold () est</b> d√©clar√© et d√©fini comme une m√©thode de la classe <b>Paragraph</b> , et <b>Node</b> n'en <b>est</b> pas du tout conscient.  De plus, <b>open_node est</b> √©galement d√©clar√© comme un pointeur vers <b>Node</b> , et il doit accepter les m√©thodes de tous les types de n≈ìuds d'ouverture. <br><br>  Il y a deux solutions ici: l'√©vidente et la bonne.  Pour un d√©butant, il est <b>√©vident que static_cast</b> et les fonctions virtuelles ont raison.  Regardons d'abord une branche de l'analyseur de commutateur √©crit en utilisant la premi√®re m√©thode: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::BOLD_START: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::SECTION) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::TITLE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::QUOTE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Quote*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::LINK) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Link*&gt;(open_node)-&gt;open_bold(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_bold(); break; }</span></span></code> </pre> <br>  Pas mal.  Et maintenant, je ne vais pas le faire glisser pendant longtemps, je vais montrer la m√™me section de code √©crite √† l'aide de fonctions virtuelles: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::BOLD_START: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = open_node-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_bold(); break; }</span></span></code> </pre><br>  Le gain est √©vident, mais en avons-nous vraiment besoin?  Apr√®s tout, vous devez d√©clarer dans la classe <b>Node</b> toutes les m√©thodes de toutes les classes d√©riv√©es comme virtuelles et les impl√©menter d'une mani√®re ou d'une autre dans chaque classe d√©riv√©e.  La r√©ponse est oui, en effet.  Il n'y a pas tellement de m√©thodes sp√©cifiquement dans ce programme (29), et leur impl√©mentation dans des classes d√©riv√©es qui ne leur sont pas li√©es se compose d'une seule ligne: <b>throw string ("error!");</b>  .  Vous pouvez activer le mode cr√©atif et proposer une ligne unique pour chaque lev√©e d'exception.  Mais le plus important - en raison de la r√©duction du code, le nombre d'erreurs a diminu√©.  La diffusion est l'une des causes les plus importantes d'erreurs dans le code.  Parce qu'apr√®s avoir appliqu√© <b>static_cast, le</b> compilateur arr√™te de jurer si la classe appel√©e est contenue dans la classe donn√©e.  Pendant ce temps, diff√©rentes classes peuvent contenir diff√©rentes m√©thodes portant le m√™me nom.  Dans mon cas, 6 √©tait cach√© dans le code !!!  erreurs, tandis que l'un d'eux a √©t√© dupliqu√© dans plusieurs branches de commutateur.  Le voici: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node:: open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;open_italic();</code> </pre><br>  Ensuite, sous les spoilers, j'apporte la liste compl√®te des premi√®re et deuxi√®me versions de l'analyseur. <br><br><div class="spoiler">  <b class="spoiler_title">Analyseur avec casting</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Root * Parser::parse (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer &amp;lexer) { <span class="hljs-function"><span class="hljs-function">Node * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree)</span></span></span></span>; Node::Node_type type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i(<span class="hljs-number"><span class="hljs-number">0</span></span>), len(lexer.count()); i &lt; len; i++) { type = open_node-&gt;get_type(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::CITE || type == Node::TEXT || type == Node::NEWLINE || type == Node::NOTIFICATION || type == Node::IMAGE) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"error!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lexer[i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::NEWLINE: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT || type == Node::SECTION) ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::TITLE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Title*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::QUOTE) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Quote*&gt;(open_node)-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ORDERED_LIST) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Unordered_list*&gt;(open_node)-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Paragraph*&gt;(open_node)-&gt;close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::LINK) { open_node = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Link*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); break; } case Lexer::DOUBLE_NEWLINE: { if (type == Node::ROOT || type == Node::SECTION) ; else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } } else throw string("unexpected double newline!"); break; } case Lexer::UNDERLINE: { if (type == Node::ROOT) open_node = tree-&gt;add_line(); else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::TITLE) throw string("unexpected underline inside title!"); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;add_line(); } else // INLINE throw string("unexpected underline inside inline span!"); break; } case Lexer::TITLE_START: { if (lexer[i].lexeme.size() &gt; 7) throw string("invalid title: \"" + lexer[i].lexeme + "\"!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::TITLE) throw string("title can't contain another title!"); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::LINK) throw string("link can't contain a title!"); else // INLINE throw string("inline span can't contain a title!"); break; } case Lexer::BOLD_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_bold(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_bold(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_bold(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_bold(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_bold(); break; } case Lexer::ITALIC_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_italic(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_italic(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_italic(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_italic(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_italic(); break; } case Lexer::UNDERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_underlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_underlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_underlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_underlined(); break; } case Lexer::OVERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_overlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_overlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_overlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_overlined(); break; } case Lexer::THROWLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_throwlined(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_throwlined(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_throwlined(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_throwlined(); break; } case Lexer::SUBSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_subscript(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_subscript(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_subscript(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_subscript(); break; } case Lexer::SUPERSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_superscript(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_superscript(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_superscript(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_superscript(); break; } case Lexer::MARKED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_marked(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_marked(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_marked(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_marked(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_marked(); break; } case Lexer::MONOSPACE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_monospace(); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_monospace(); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_monospace(); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_monospace(); break; } case Lexer::SPAN_OR_IMAGE_FINISH: { if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); else if (type == Node::BOLD || type == Node::ITALIC || type == Node::UNDERLINED || type == Node::OVERLINED || type == Node::THROWLINED || type == Node::SUBSCRIPT || type == Node::SUPERSCRIPT || type == Node::MARKED || type == Node::MONOSPACE) open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); else if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text("]"); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("]"); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text("&gt;"); break; } case Lexer::LINK_START: { if (i &gt; len-3 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH) throw string("unclosed link!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;open_link(lexer[i-1].lexeme); break; } case Lexer::LINK_FINISH: { if (type == Node::LINK) open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); else if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section&gt;(open_node).open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text("&gt;"); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text("&gt;"); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text("&gt;"); break; } case Lexer::IMAGE_START: { if (i &gt; len-5 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH || (lexer[++i].type != Lexer::TEXT &amp;&amp; lexer[i].type != Lexer::SPAN_OR_IMAGE_FINISH) || (lexer[i].type == Lexer::TEXT &amp;&amp; lexer[i+1].type != Lexer::SPAN_OR_IMAGE_FINISH)) throw string("unclosed image defintion!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::TITLE) { if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::LINK) { if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } else { // INLINE if (lexer[i].type == Lexer::TEXT) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_image(lexer[i-2].lexeme, ""); } break; } case Lexer::CITE: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_image(lexer[i-3].lexeme, lexer[i-1].lexeme); else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::LINK) throw string("link can't contain a cite!"); else // INLINE throw string("inline span can't contain a cite!"); break; } case Lexer::QUOTE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::SECTION) open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::TITLE) { open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } else { // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_quote(); } break; } case Lexer::NOTIFICATION: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::TITLE) { open_node = static_cast&lt;Title*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } else { // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_notification(lexer[i].lexeme); } break; } case Lexer::TEXT: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::TITLE) open_node = static_cast&lt;Title*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::QUOTE) open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Ordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;open_paragraph(); open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else if (type == Node::LINK) { open_node = static_cast&lt;Link*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); } else // INLINE open_node = static_cast&lt;Inline*&gt;(open_node)-&gt;add_text(lexer[i].lexeme); break; } case Lexer::UNORDERED_LIST_ITEM_MARKER: { break; } case Lexer::ORDERED_LIST_ITEM_MARKER: { break; } case Lexer::END: { if (type == Node::ROOT) open_node = tree-&gt;close(); else if (type == Node::SECTION) { open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::PARAGRAPH) { open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::QUOTE) { open_node = static_cast&lt;Quote*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::UNORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::ORDERED_LIST) { open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) { if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::UNORDERED_LIST) open_node = static_cast&lt;Unordered_list*&gt;(open_node)-&gt;close(); else if (open_node-&gt;get_type() == Node::PARAGRAPH) open_node = static_cast&lt;Paragraph*&gt;(open_node)-&gt;close(); } open_node = static_cast&lt;Section*&gt;(open_node)-&gt;close(); open_node = tree-&gt;close(); } else // LINK || INLINE throw string("unexpected ending!"); /// ROOT, /// SECTION, /// PARAGRAPH, TITLE, QUOTE, UNORDERED_LIST, ORDERED_LIST, /// BOLD, ITALIC, UNDERLINED, OVERLINED, THROWLINED, SUBSCRIPT, SUPERSCRIPT, MARKED, MONOSPACE, /// LINK break; } } } concatenate(); return tree; }</span></span></code> </pre></div></div><br><div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text"><pre> <code class="cpp hljs">Root * Parser::parse (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer &amp;lexer) { <span class="hljs-function"><span class="hljs-function">Node * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree)</span></span></span></span>; Node::Node_type type; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i(<span class="hljs-number"><span class="hljs-number">0</span></span>), len(lexer.count()); i &lt; len; i++) { type = open_node-&gt;get_type(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::CITE || type == Node::TEXT || type == Node::NEWLINE || type == Node::NOTIFICATION || type == Node::IMAGE) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"error!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (lexer[i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Lexer::NEWLINE: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::ROOT || type == Node::SECTION) ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::PARAGRAPH || type == Node::TITLE || type == Node::QUOTE || type == Node::TITLE || type == Node::QUOTE) open_node = open_node-&gt;add_text(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// LINK, INLINE open_node = open_node-&gt;add_text(lexer[i].lexeme); break; } case Lexer::DOUBLE_NEWLINE: { if (type == Node::ROOT || type == Node::SECTION) ; else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); } else throw string("unexpected double newline!"); break; } case Lexer::UNDERLINE: { if (type == Node::ROOT) open_node = tree-&gt;add_line(); else if (type == Node::SECTION) { open_node = open_node-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;close(); open_node = tree-&gt;add_line(); } else if (type == Node::TITLE) throw string("unexpected underline inside title!"); else if (type == Node::LINK) throw string("unexpected underline inside link!"); else // INLINE throw string("unexpected underline inside inline span!"); break; } case Lexer::TITLE_START: { if (lexer[i].lexeme.size() &gt; 7) throw string("invalid title: \"" + lexer[i].lexeme + "\"!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::SECTION) open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_title(lexer[i].lexeme.size()-1); } else if (type == Node::TITLE) throw string("title can't contain another title!"); else if (type == Node::LINK) throw string("link can't contain a title!"); else // INLINE throw string("inline span can't contain a title!"); break; } case Lexer::BOLD_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else if (type == Node::UNORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_bold(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_bold(); break; } case Lexer::ITALIC_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_italic(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_italic(); break; } case Lexer::UNDERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_underlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_underlined(); break; } case Lexer::OVERLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else if (type == Node::PARAGRAPH) open_node = open_node-&gt;open_overlined(); else if (type == Node::TITLE) open_node = open_node-&gt;open_overlined(); else if (type == Node::QUOTE) open_node = open_node-&gt;open_overlined(); else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_overlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_overlined(); break; } case Lexer::THROWLINED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_throwlined(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_throwlined(); break; } case Lexer::SUBSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_subscript(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_subscript(); break; } case Lexer::SUPERSCRIPT_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_superscript(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_superscript(); break; } case Lexer::MARKED_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_marked(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_marked(); break; } case Lexer::MONOSPACE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_monospace(); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_monospace(); break; } case Lexer::SPAN_OR_IMAGE_FINISH: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::LINK) open_node = open_node-&gt;add_text("]"); else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("]"); } else // TITLE, INLINE open_node = open_node-&gt;close(); break; } case Lexer::LINK_START: { if (i &gt; len-3 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH) throw string("unclosed link!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;open_link(lexer[i-1].lexeme); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;open_link(lexer[i-1].lexeme); break; } case Lexer::LINK_FINISH: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text("&gt;"); } else if (type == Node::LINK) open_node = open_node-&gt;close(); else // PARAGRAPH, TITLE, QUOTE, INLINE open_node = open_node-&gt;add_text("&gt;"); break; } case Lexer::IMAGE_START: { if (i &gt; len-5 || lexer[++i].type != Lexer::TEXT || lexer[++i].type != Lexer::LINK_FINISH || (lexer[++i].type != Lexer::TEXT &amp;&amp; lexer[i].type != Lexer::SPAN_OR_IMAGE_FINISH) || (lexer[i].type == Lexer::TEXT &amp;&amp; lexer[i+1].type != Lexer::SPAN_OR_IMAGE_FINISH)) throw string("unclosed image defintion!"); if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } else { // TITLE, LINK, INLINE if (lexer[i].type == Lexer::TEXT) { open_node = open_node-&gt;add_image(lexer[i-2].lexeme, lexer[i].lexeme); i++; } else open_node = open_node-&gt;add_image(lexer[i-2].lexeme, ""); } break; } case Lexer::CITE: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::SECTION) open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;add_cite(atoi(lexer[i].lexeme.c_str())); } else if (type == Node::TITLE) throw string("title cant't contain a cite!"); else if (type == Node::LINK) throw string("link can't contain a cite!"); else // INLINE throw string("inline span can't contain a cite!"); break; } case Lexer::QUOTE_START: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_quote(); } else if (type == Node::SECTION) open_node = open_node-&gt;open_quote(); else { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_quote(); } break; } case Lexer::NOTIFICATION: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } else { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_notification(lexer[i].lexeme); } break; } case Lexer::TEXT: { if (type == Node::ROOT) { open_node = tree-&gt;open_section(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else if (type == Node::SECTION) { open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else if (type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;open_paragraph(); open_node = open_node-&gt;add_text(lexer[i].lexeme); } else // PARAGRAPH, TITLE, QUOTE, LINK, INLINE open_node = open_node-&gt;add_text(lexer[i].lexeme); break; } case Lexer::UNORDERED_LIST_ITEM_MARKER: { break; } case Lexer::ORDERED_LIST_ITEM_MARKER: { break; } case Lexer::END: { if (type == Node::ROOT) open_node = tree-&gt;close(); else if (type == Node::SECTION) { open_node = open_node-&gt;close(); open_node = tree-&gt;close(); } else if (type == Node::PARAGRAPH || type == Node::QUOTE || type == Node::UNORDERED_LIST || type == Node::ORDERED_LIST) { open_node = open_node-&gt;close(); while (open_node-&gt;get_type() != Node::SECTION) open_node = open_node-&gt;close(); open_node = open_node-&gt;close(); open_node = tree-&gt;close(); } else // LINK || INLINE throw string("unexpected ending!"); break; } } } concatenate(); return tree; }</span></span></code> </pre></div></div><br>  1357     487 ‚Äì    ,    ! <br><br>   :      ?       ,       ?    ‚Äì                     .  : <br><br>  ‚Äì 538 . <br>   ‚Äì 1174 . <br><br> , 636  ‚Äì       .  ? .     ,           ,               ,         .     ‚Äì ,     <b>static_cast</b>  <b>dynamic_cast</b> ,    .    ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458228/">https://habr.com/ru/post/fr458228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458206/index.html">Sublime Text 3 pour la mise en page du site. Personnalisez l'apparence et installez les plugins. Guide du d√©butant</a></li>
<li><a href="../fr458208/index.html">√âv√©nements num√©riques √† Moscou du 01 juillet au 07 juillet</a></li>
<li><a href="../fr458218/index.html">Chirurgie maxillo-faciale ou pas? Telle est la question</a></li>
<li><a href="../fr458222/index.html">Briser un jeu de m√©moire: toute une histoire de d√©tective</a></li>
<li><a href="../fr458224/index.html">Le logiciel du Boeing-737 Max a √©t√© √©crit par des sous-traitants gagnant 9 $ de l'heure</a></li>
<li><a href="../fr458230/index.html">Comment l'IA, les drones et les cam√©ras assurent la s√©curit√© de nos routes et de nos ponts</a></li>
<li><a href="../fr458240/index.html">Comment l'intelligence artificielle, les drones et les cam√©ras assurent la s√©curit√© des routes et des ponts</a></li>
<li><a href="../fr458242/index.html">Le nouvel op√©rateur de vaisseau spatial en C ++ 20</a></li>
<li><a href="../fr458244/index.html">Une liste interminable et ridicule de ce que vous devez savoir pour utiliser en toute s√©curit√© les r√©seaux Wi-Fi publics</a></li>
<li><a href="../fr458246/index.html">Co√Øncidences al√©atoires dans la vie, ou comment il s'est av√©r√© qu'on vous a pr√©sent√© un g√¢teau dans une usine de tracteurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>