<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏾 👩🏾‍🤝‍👩🏻 ♻️ PostgreSQL-Sperren: 2. String-Sperren 🛩️ 🏼 🌼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim letzten Mal haben wir über Sperren auf Objektebene gesprochen, insbesondere über Sperren für Beziehungen. Heute werden wir sehen, wie Zeilensperr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL-Sperren: 2. String-Sperren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/463819/">  Beim letzten Mal haben wir über Sperren auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektebene</a> gesprochen, insbesondere über Sperren für Beziehungen.  Heute werden wir sehen, wie Zeilensperren in PostgreSQL angeordnet sind und wie sie zusammen mit Objektsperren verwendet werden. Lassen Sie uns über wartende Warteschlangen und über diejenigen sprechen, die aus der Kurve klettern. <br><br><img src="https://habrastorage.org/webt/6x/u5/jj/6xu5jj3edymfhel21v9obwhsxai.png"><br><br><h1>  Zeilensperren </h1><br><h2>  Gerät </h2><br>  Ich möchte Sie an einige wichtige Schlussfolgerungen aus dem letzten Artikel erinnern. <br><br><ul><li>  Irgendwo im gemeinsam genutzten Speicher des Servers muss eine Sperre vorhanden sein. </li><li>  Je höher die Granularität von Sperren ist, desto weniger Konkurrenz (Konkurrenz) zwischen gleichzeitig ausgeführten Prozessen. </li><li>  Je höher die Granularität ist, desto mehr Speicherplatz wird von Sperren belegt. </li></ul><br>  Wir möchten sicher, dass durch die Änderung einer Zeile keine anderen Zeilen derselben Tabelle blockiert werden.  Wir können es uns jedoch nicht leisten, jede Zeile mit einem eigenen Schloss zu beginnen. <br><br>  Es gibt verschiedene Möglichkeiten, dieses Problem zu lösen.  In einigen DBMS steigt die Ebene der Sperren: Wenn zu viele Sperren auf Zeilenebene vorhanden sind, werden sie durch eine allgemeinere Sperre ersetzt (z. B. Seitenebene oder die gesamte Tabelle). <br><br>  Wie wir später sehen werden, verwendet PostgreSQL diesen Mechanismus ebenfalls, jedoch nur für Prädikatsperren.  Leitungssperren sind unterschiedlich. <br><a name="habracut"></a><br>  In PostgreSQL werden Informationen darüber, dass eine Zeile gesperrt ist, ausschließlich in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version der Zeile auf</a> der Datenseite (und nicht im RAM) gespeichert.  Das heißt, dies ist überhaupt kein Block im üblichen Sinne, sondern nur ein Zeichen.  Dieses Vorzeichen ist tatsächlich die xmax-Transaktionsnummer in Kombination mit zusätzlichen Informationsbits.  wenig später werden wir im Detail sehen, wie das funktioniert. <br><br>  <strong>Das Plus</strong> ist, dass wir so viele Zeilen blockieren können, wie wir möchten, ohne Ressourcen zu verbrauchen. <br><br>  Es gibt jedoch ein <strong>Minus</strong> : Da Informationen über die Sperre nicht im RAM angezeigt werden, können andere Prozesse nicht in einer Reihe stehen.  Und es gibt keine Überwachungsmöglichkeit (um die Sperren zu berechnen, müssen Sie die gesamte Tabelle lesen). <br><br>  Nun, die Überwachung ist in Ordnung, aber mit der Warteschlange muss etwas getan werden.  Dazu müssen Sie noch "normale" Sperren verwenden.  Wenn wir warten müssen, bis die Zeile freigegeben ist, müssen wir tatsächlich bis zum Ende der blockierenden Transaktion warten - alle Sperren werden beim Festschreiben oder Zurücksetzen freigegeben.  Und dafür können Sie eine Sperrnummer einer Sperrtransaktion anfordern (die, wie ich mich erinnere, von der Transaktion selbst im Ausnahmemodus gehalten wird).  Somit ist die Anzahl der verwendeten Sperren proportional zur Anzahl der gleichzeitig ausgeführten Prozesse und nicht zur Anzahl der zu ändernden Zeilen. <br><br><h2>  Außergewöhnliche Modi </h2><br>  Insgesamt gibt es 4 Modi, in denen Sie die Leitung sperren können.  Von diesen stellen zwei Modi <em>exklusive</em> Sperren dar, die jeweils nur eine Transaktion halten kann. <br><br><ul><li>  Der FOR UPDATE-Modus impliziert eine vollständige Änderung (oder Löschung) einer Zeile. </li><li>  FOR NO KEY UPDATE-Modus - Ändern Sie nur die Felder, die nicht in eindeutigen Indizes enthalten sind (mit anderen Worten, bei einer solchen Änderung bleiben alle Fremdschlüssel unverändert). </li></ul><br>  Der Befehl UPDATE selbst wählt den minimal geeigneten Sperrmodus aus.  Normalerweise werden Zeilen im FOR NO KEY UPDATE-Modus gesperrt. <br><br>  Wie Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erinnern</a> , wird beim Löschen oder Ändern einer Zeile die aktuelle Transaktionsversionsnummer in das Feld xmax der aktuellen aktuellen Version geschrieben.  Es zeigt, dass die Version der Zeile durch diese Transaktion gelöscht wurde.  Daher wird dieselbe xmax-Nummer als Zeichen der Blockierung verwendet.  Wenn xmax in der Version der Zeile einer aktiven (noch nicht abgeschlossenen) Transaktion entspricht und wir diese bestimmte Zeile aktualisieren möchten, müssen wir auf den Abschluss der Transaktion warten, sodass kein zusätzliches Vorzeichen erforderlich ist. <br><br>  Mal sehen.  Erstellen Sie eine Kontenübersicht wie im vorherigen Artikel. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">300.00</span></span>);</code> </pre> <br>  Zum Betrachten der Seiten benötigen wir natürlich die bereits bekannte pageinspect-Erweiterung. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Erstellen Sie der Einfachheit halber eine Ansicht, in der nur die Informationen angezeigt werden, an denen wir interessiert sind: xmax und einige Informationsbits. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">128</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lock_only, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">4096</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> is_multi, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask2 &amp; <span class="hljs-number"><span class="hljs-number">8192</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keys_upd, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keyshr_lock, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span>) = <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> shr_lock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> lp;</code> </pre><br>  Also starten wir die Transaktion und aktualisieren den Betrag des ersten Kontos (der Schlüssel ändert sich nicht) und die Nummer des zweiten Kontos (der Schlüssel ändert sich): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Wir schauen in die Ansicht: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530492 | | | | | (0,2) | 530492 | | | t | | (2 rows)</code> </pre><br>  Der Sperrmodus wird durch das Informationsbit keys_updated bestimmt. <br><br>  Das gleiche xmax-Feld wird auch beim Sperren einer Zeile mit dem Befehl SELECT FOR UPDATE verwendet. In diesem Fall wird jedoch ein zusätzliches Informationsbit (xmax_lock_only) abgelegt, das angibt, dass die Version der Zeile nur gesperrt, aber nicht gelöscht ist und weiterhin relevant ist. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR NO KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530493 | t | | | | (0,2) | 530493 | t | | t | | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><br><h2>  Gemeinsame Modi </h2><br>  Zwei weitere Modi stellen gemeinsam genutzte Sperren dar, die von mehreren Transaktionen gehalten werden können. <br><br><ul><li>  Der FOR SHARE-Modus wird verwendet, wenn Sie eine Zeichenfolge lesen müssen, aber nicht zulassen dürfen, dass sie durch eine andere Transaktion in irgendeiner Weise geändert wird. </li><li>  Der FOR KEY SHARE-Modus ermöglicht das Ändern der Zeichenfolge, jedoch nur von Nicht-Schlüsselfeldern.  Insbesondere dieser Modus wird von PostgreSQL beim Überprüfen von Fremdschlüsseln automatisch verwendet. </li></ul><br>  Mal sehen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><br>  In Zeilenversionen sehen wir: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530494 | t | | | t | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br>  In beiden Fällen wird das Bit keyshr_lock gesetzt, und der SHARE-Modus kann durch Betrachten eines weiteren Informationsbits erkannt werden. <br><br>  So sieht die Kompatibilitätsmatrix für den allgemeinen Modus aus. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Modus </th><th>  FÜR KEY SHARE </th><th>  FÜR TEILEN </th><th>  FÜR KEIN KEY UPDATE </th><th>  FÜR UPDATE </th></tr><tr><td>  FÜR KEY SHARE </td><td></td><td></td><td></td><td>  X. </td></tr><tr><td>  FÜR TEILEN </td><td></td><td></td><td>  X. </td><td>  X. </td></tr><tr><td>  FÜR KEIN KEY UPDATE </td><td></td><td>  X. </td><td>  X. </td><td>  X. </td></tr><tr><td>  FÜR UPDATE </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td></tr></tbody></table></div><br>  Es zeigt, dass: <br><br><ul><li>  außergewöhnliche Modi stehen in Konflikt miteinander; </li><li>  gemeinsame Modi sind miteinander kompatibel; </li><li>  Der gemeinsam genutzte FOR KEY SHARE-Modus ist mit dem exklusiven FOR NO KEY UPDATE-Modus kompatibel (dh Sie können Nicht-Schlüsselfelder gleichzeitig aktualisieren und sicherstellen, dass sich der Schlüssel nicht ändert). </li></ul><br><h2>  Multi-Transaktion </h2><br>  Bisher dachten wir, dass die Sperre durch die Nummer der blockierenden Transaktion im xmax-Feld dargestellt wird.  Gemeinsame Sperren können jedoch von mehreren Transaktionen gehalten werden, und mehrere Nummern können nicht in dasselbe xmax-Feld geschrieben werden.  Wie man ist <br><br>  Für gemeinsam genutzte Sperren werden die sogenannten Multi-Transaktionen (MultiXact) verwendet.  Dies ist eine Transaktionsgruppe, der eine separate Nummer zugewiesen ist.  Diese Nummer hat dieselbe Dimension wie eine reguläre Transaktionsnummer, die Nummern werden jedoch unabhängig voneinander zugewiesen (dh das System kann dieselbe Transaktions- und Mehrfachtransaktionsnummer haben).  Zur Unterscheidung wird ein anderes Informationsbit (xmax_is_multi) verwendet, und detaillierte Informationen zu den Mitgliedern einer solchen Gruppe und den Sperrmodi befinden sich in den Dateien im Verzeichnis $ PGDATA / pg_multixact /.  Natürlich werden die zuletzt verwendeten Daten in Puffern im gemeinsam genutzten Speicher des Servers gespeichert, um einen schnelleren Zugriff zu ermöglichen. <br><br>  Fügen Sie zu den vorhandenen Sperren eine weitere Ausnahme hinzu, die von einer anderen Transaktion ausgeführt wird (wir können dies tun, da die Modi FOR KEY SHARE und FOR NO KEY UPDATE miteinander kompatibel sind): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 61 | | t | | | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br>  In der ersten Zeile sehen wir, dass die übliche Nummer durch eine Multitransaktionsnummer ersetzt wurde - dies wird durch das Bit xmax_is_multi angezeigt. <br><br>  Um nicht in die Interna der Multitransaction-Implementierung einzutauchen, können Sie eine andere Erweiterung verwenden, mit der Sie alle Informationen zu allen Arten von Zeilensperren auf bequeme Weise anzeigen können. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgrowlocks; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------------------- locked_row | (0,1) locker | 61 multi | t xids | {530494,530495} modes | {"Key Share","No Key Update"} pids | {5892,5928} -[ RECORD 2 ]----------------------------- locked_row | (0,2) locker | 530494 multi | f xids | {530494} modes | {"For Share"} pids | {5892}</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h2>  Einstellung einfrieren </h2><br>  Da für Multitransaktionen, die in das xmax-Feld von Zeilenversionen geschrieben werden, aufgrund der Begrenzung der Bitkapazität des Zählers separate Nummern zugewiesen werden, tritt das gleiche xid-Umlaufproblem auf wie bei einer regulären Nummer. <br><br>  Daher ist es für Mehrfachtransaktionsnummern auch erforderlich, ein Analogon zum Einfrieren durchzuführen - ersetzen Sie die alten Nummern durch neue (oder durch eine reguläre Transaktionsnummer, wenn zum Zeitpunkt des Einfrierens die Sperre nur von einer Transaktion gehalten wird). <br><br>  Beachten Sie, dass das Einfrieren gewöhnlicher Transaktionsnummern nur für das Feld xmin durchgeführt wird (da die Version der Zeile ein nicht leeres xmax-Feld enthält, handelt es sich entweder um eine irrelevante Version, die gelöscht wird, oder die xmax-Transaktion wird abgebrochen und ihre Nummer interessiert uns nicht).  Bei Mehrfachtransaktionen handelt es sich jedoch um das xmax-Feld der aktuellen Version der Zeile, das zwar relevant bleiben kann, jedoch in einem gemeinsam genutzten Modus ständig von verschiedenen Transaktionen blockiert wird. <br><br>  Für das Einfrieren von Mehrfachtransaktionen <em>sind</em> Parameter verantwortlich, die den Parametern des üblichen Einfrierens ähnlich sind: <em>vakuum_multixact_freeze_min_age</em> , <em>vakuum_multixact_freeze_table_age</em> , <em>autovacuum_multixact_freeze_max_age</em> . <br><br><h1>  Wer ist das Extrem? </h1><br>  Allmählich nähern Sie sich dem Süßen.  Lassen Sie uns sehen, wie das Bild von Sperren aussieht, wenn mehrere Transaktionen dieselbe Zeile aktualisieren. <br><br>  Beginnen wir mit der Erstellung einer Ansicht über pg_locks.  Erstens werden wir die Schlussfolgerung etwas kompakter machen und zweitens werden wir uns auf interessante Sperren beschränken (tatsächlich verwerfen wir die Sperren virtueller Transaktionsnummern, den Index in der Kontentabelle, pg_locks und die Ansicht selbst - im Allgemeinen alles, was irrelevant ist und nur ablenkend). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, locktype, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'transactionid'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> transactionid::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>||<span class="hljs-string"><span class="hljs-string">':'</span></span>||tuple::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lockid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'relation'</span></span>,<span class="hljs-string"><span class="hljs-string">'transactionid'</span></span>,<span class="hljs-string"><span class="hljs-string">'tuple'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (locktype != <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><br>  Starten Sie nun die erste Transaktion und aktualisieren Sie die Zeile. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530497 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br>  Was ist mit Schlössern? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5892</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5892 | relation | accounts | RowExclusiveLock | t 5892 | transactionid | 530497 | ExclusiveLock | t (2 rows)</code> </pre><br>  Die Transaktion enthält die Tabelle und eigene Nummernsperren.  Bisher wird alles erwartet. <br><br>  Wir starten die zweite Transaktion und versuchen, dieselbe Zeile zu aktualisieren. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530498 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Was ist mit zweiten Transaktionssperren? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t 5928 | transactionid | 530497 | ShareLock | f 5928 | tuple | accounts:1 | ExclusiveLock | t (4 rows)</code> </pre><br>  Und hier ist es interessanter.  Zusätzlich zum Sperren der Tabelle und der eigenen Nummer sehen wir zwei weitere Sperren.  Bei der zweiten Transaktion wurde festgestellt, dass die Zeile zuerst gesperrt war und auf ihre Nummer wartete (gewährt = f).  Aber woher und warum kam die Zeilenversionssperre (locktype = tuple)? <br><br><blockquote>  Verwechseln Sie nicht die Zeilenversionssperre (Tupel-Sperre) und die Zeilen-Sperre (Zeilen-Sperre).  Die erste ist eine reguläre Sperre vom Typ Tupel, die in pg_locks sichtbar ist.  Die zweite ist eine Markierung auf der Datenseite: xmax und Informationsbits. <br></blockquote><br>  Wenn eine Transaktion eine Zeile ändern soll, führt sie die folgende Abfolge von Aktionen aus: <br><br><ol><li>  Erfasst eine exklusive Sperre für eine veränderbare Version eines Strings (Tupel). </li><li>  Wenn xmax- und Informationsbits anzeigen, dass die Leitung gesperrt ist, werden Sie aufgefordert, die xmax-Transaktionsnummer zu sperren. </li><li>  Verschreibt die xmax- und erforderlichen Informationsbits. </li><li>  Löst die Zeilenversionssperre auf. </li></ol><br>  Wenn die Zeile durch die erste Transaktion aktualisiert wurde, wurde auch die Zeilenversionssperre aktiviert (Schritt 1), diese jedoch sofort freigegeben (Schritt 4). <br><br>  Als die zweite Transaktion eintraf, erfasste sie die Sperre der Zeilenversion (Element 1), musste jedoch eine Sperre für die Nummer der ersten Transaktion (Element 2) anfordern und daran festhalten. <br><br>  Was passiert, wenn eine dritte ähnliche Transaktion angezeigt wird?  Sie wird versuchen, die Sperre der Version der Zeile (Punkt 1) zu erfassen und wird bereits bei diesem Schritt hängen.  Schau es dir an. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530499 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | tuple | accounts:1 | ExclusiveLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br>  Die vierten, fünften usw. Transaktionen, die dieselbe Zeile aktualisieren möchten, unterscheiden sich nicht von Transaktion 3 - sie hängen alle an derselben Zeilenversionssperre. <br><br>  Fügen Sie dem Heap eine weitere Transaktion hinzu. <br><br><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; ||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">||| txid_current | pg_backend_pid ||| --------------+---------------- ||| 530500 | 6000 ||| (1 row)</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530500 | ExclusiveLock | t 6000 | tuple | accounts:1 | ExclusiveLock | f (3 rows)</code> </pre><br>  Ein allgemeines Bild der aktuellen Erwartungen finden Sie in der Ansicht pg_stat_activity, in der Informationen zu Blockierungsprozessen hinzugefügt werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, wait_event_type, wait_event, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | wait_event_type | wait_event | pg_blocking_pids ------+-----------------+---------------+------------------ 5892 | | | {} 5928 | Lock | transactionid | {5892} 5964 | Lock | tuple | {5928} 6000 | Lock | tuple | {5928,5964} (4 rows)</code> </pre><br>  Es stellt sich eine Art „Warteschlange“ heraus, in der sich die erste (diejenige, die die Sperrversion der Zeichenfolge hält) und alle anderen für die erste anstellen. <br><br>  Warum brauchen wir ein so anspruchsvolles Design?  Angenommen, wir hätten keine Versionssperre für die Zeichenfolge.  Dann würden die zweite und dritte (und so weiter) Transaktion auf die Blockierung der Nummer der ersten Transaktion warten.  Zum Zeitpunkt des Abschlusses der ersten Transaktion verschwindet die blockierte Ressource ( <em>und was machen Sie hier, was? Die Transaktion wurde beendet</em> ). Jetzt hängt alles davon ab, welcher der Wartevorgänge zuerst vom Betriebssystem aktiviert wird und dementsprechend Zeit hat, die Leitung zu sperren.  Alle anderen Prozesse werden ebenfalls aktiviert, müssen jedoch erneut in die Warteschlange gestellt werden - jetzt nach einem anderen Prozess. <br><br>  Dies ist mit der Tatsache behaftet, dass einige der Transaktionen auf unbestimmte Zeit warten können, bis sie an die Reihe kommen, wenn sie aufgrund eines unglücklichen Zusammentreffens der Umstände andere Transaktionen immer „umrunden“.  Im Englischen wird diese Situation als Schleusenhunger bezeichnet. <br><br>  In unserem Fall stellt sich heraus, dass es ungefähr dasselbe ist, aber immer noch ein bisschen besser: Die Transaktion, die in der zweiten kam, garantiert, dass sie Zugriff auf die nächste Ressource erhält.  Aber was passiert mit Folgendem (drittes und viertes)? <br><br>  Wenn die erste Transaktion mit einem Rollback endet, ist alles in Ordnung: Die eingehenden Transaktionen werden in der Reihenfolge ausgeführt, in der sie in einer Reihe standen. <br><br>  Aber - das ist Pech - wenn die erste Transaktion mit einem Commit abgeschlossen wird, verschwindet nicht nur die Transaktionsnummer, sondern auch die Version der Zeile!  Das heißt, die Version bleibt natürlich erhalten, ist jedoch nicht mehr relevant, und es muss eine völlig andere, neueste Version (derselben Zeile) aktualisiert werden.  Die Ressource, die an der Reihe war, verschwindet und jeder organisiert ein Rennen um den Besitz einer neuen Ressource. <br><br>  Lassen Sie die erste Transaktion mit Commit abschließen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Die zweite Transaktion wird aufgeweckt und Absätze ausgeführt.  3 und 4. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t (2 rows)</code> </pre><br>  Was ist mit der dritten Transaktion?  Sie überspringt Schritt 1 (weil die Ressource verschwunden ist) und bleibt bei Schritt 2 hängen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | transactionid | 530498 | ShareLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br>  Und das Gleiche passiert mit der vierten Transaktion: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530498 | ShareLock | f 6000 | transactionid | 530500 | ExclusiveLock | t (3 rows)</code> </pre><br>  Das heißt, sowohl die dritte als auch die vierte Transaktion warten auf den Abschluss der zweiten.  Die Linie verwandelte sich in eine <strike>Kürbismenge</strike> . <br><br>  Wir schließen alle gestarteten Transaktionen ab. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">|| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">||| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><blockquote>  Weitere Informationen zum Blockieren von Zeichenfolgen finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README.tuplock</a> . <br></blockquote><br><h1>  Du standest nicht hier </h1><br>  Die Idee eines zweistufigen Blockierungsschemas besteht also darin, die Wahrscheinlichkeit eines ewigen Wartens auf eine "Pech" -Transaktion zu verringern.  Wie wir bereits gesehen haben, ist eine solche Situation jedoch durchaus möglich.  Und wenn die Anwendung gemeinsam genutzte Sperren verwendet, kann alles noch trauriger werden. <br><br>  Lassen Sie die erste Transaktion die Zeile im gemeinsam genutzten Modus sperren. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530501 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+-------- 1 | 100.00 (1 row)</code> </pre><br>  Die zweite Transaktion versucht, dieselbe Zeile zu aktualisieren, kann dies jedoch nicht. Die Modi SHARE und NO KEY UPDATE sind nicht kompatibel. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530502 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Die zweite Transaktion wartet auf den Abschluss der ersten und hält die Zeilenversionssperre - im Moment ist alles wie beim letzten Mal. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530501 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br>  Und dann erscheint eine dritte Transaktion, die eine gemeinsame Sperre wünscht.  Das Problem ist, dass es nicht versucht, die Sperre für die Version der Zeile zu erfassen (weil es die Zeile nicht ändern wird), sondern einfach aus der Reihe kriecht - es ist mit der ersten Transaktion kompatibel. <br><br><pre> <code class="pgsql hljs">|| <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530503 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs">|| acc_no | amount || --------+-------- || 1 | 100.00 || (1 row)</code> </pre><br>  Und jetzt blockieren zwei Transaktionen die Zeile: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------- locked_row | (0,10) locker | 62 multi | t xids | {530501,530503} modes | {Share,Share} pids | {5892,5964}</code> </pre><br>  Was passiert jetzt, wenn die erste Transaktion abgeschlossen ist?  Die zweite Transaktion wird aufgeweckt, es wird jedoch festgestellt, dass die Zeilensperre nirgendwo verschwunden ist, und sie wird erneut in der „Warteschlange“ stehen - diesmal für die dritte Transaktion: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530503 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br>  Und nur wenn die dritte Transaktion abgeschlossen ist (und während dieser Zeit keine anderen freigegebenen Sperren angezeigt werden), kann die zweite die Aktualisierung durchführen. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Vielleicht ist es Zeit, einige praktische Schlussfolgerungen zu ziehen. <br><br><ul><li>  Es ist keine gute Idee, in vielen parallelen Prozessen dieselbe Zeile in einer Tabelle gleichzeitig zu aktualisieren. </li><li>  Wenn Sie in der Anwendung freigegebene Sperren vom Typ SHARE verwenden, dann diskret. </li><li>  Das Überprüfen von Fremdschlüsseln sollte nicht stören, da sich die Schlüsselfelder normalerweise nicht ändern und die Modi KEY SHARE und NO KEY UPDATE kompatibel sind. </li></ul><br><br><h1>  Gebeten, nicht zu leihen </h1><br>  In der Regel erwarten SQL-Befehle, dass sie die benötigten Ressourcen freigeben.  Manchmal möchten Sie jedoch die Ausführung des Befehls ablehnen, wenn die Sperre nicht sofort verfügbar ist.  Mit Befehlen wie SELECT, LOCK, ALTER können Sie dazu den Ausdruck NOWAIT verwenden. <br><br>  Zum Beispiel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOWAIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| ERROR: could not obtain lock on row in relation "accounts"</code> </pre><br>  Der Befehl schlägt sofort fehl, wenn die Ressource ausgelastet ist.  Im Anwendungscode kann ein solcher Fehler abgefangen und verarbeitet werden. <br><br>  Sie können die NOWAIT-Phrase für die Befehle UPDATE und DELETE nicht angeben, aber Sie können zuerst SELECT FOR UPDATE NOWAIT ausführen und dann, wenn möglich, die Zeile aktualisieren oder löschen. <br><br>  Es gibt noch eine andere Option, um nicht zu warten - verwenden Sie den Befehl SELECT FOR mit der Phrase SKIP LOCKED.  Ein solcher Befehl überspringt gesperrte Zeilen, verarbeitet jedoch freie. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> acc_no <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SKIP LOCKED</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs">| acc_no | amount | --------+-------- | 2 | 200.00 | (1 row)</code> </pre><br>  In diesem Beispiel wurde die erste blockierte Zeile übersprungen und die zweite wurde sofort empfangen (und blockiert). <br><br>  In der Praxis können Sie so die Multithread-Verarbeitung von Warteschlangen organisieren.  Sie sollten keine andere Anwendung für diesen Befehl entwickeln. Wenn Sie ihn verwenden möchten, verlieren Sie höchstwahrscheinlich eine einfachere Lösung aus den Augen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><pre> <code class="plaintext hljs">| =&gt; ROLLBACK;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463819/">https://habr.com/ru/post/de463819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463805/index.html">Sieben Bücher für diejenigen, die Spieledesigner werden wollen</a></li>
<li><a href="../de463811/index.html">Vorbereiten der Anwendung für Android Q. Teil 1</a></li>
<li><a href="../de463813/index.html">Multivan und Routing auf Mikrotik RouterOS</a></li>
<li><a href="../de463815/index.html">Warum interessiert sich eine ausländische Bank für die Quelle Ihrer Gelder?</a></li>
<li><a href="../de463817/index.html">20 Produktmanager und die mehrdimensionalste Matrixstruktur von allen. Gespräch mit Skyeng</a></li>
<li><a href="../de463821/index.html">AMO, Bitrix, 1C und andere: Wie wählt man aus, wo man anfangen soll?</a></li>
<li><a href="../de463823/index.html">Rust 1.37.0 Release: Profilgesteuerte Optimierung, unbenannte Konstanten und Frachtanbieter</a></li>
<li><a href="../de463825/index.html">Google Sheets-Projektmanagement-Tool</a></li>
<li><a href="../de463829/index.html">FreePBX Konfigurieren von Asterisk für E-Mail-Benachrichtigungen über verpasste eingehende Anrufe in der Warteschlange</a></li>
<li><a href="../de463831/index.html">Was ist los mit IT-Ausbildung in Russland</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>