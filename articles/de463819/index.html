<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèæ üë©üèæ‚Äçü§ù‚Äçüë©üèª ‚ôªÔ∏è PostgreSQL-Sperren: 2. String-Sperren üõ©Ô∏è üèº üåº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim letzten Mal haben wir √ºber Sperren auf Objektebene gesprochen, insbesondere √ºber Sperren f√ºr Beziehungen. Heute werden wir sehen, wie Zeilensperr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL-Sperren: 2. String-Sperren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/463819/">  Beim letzten Mal haben wir √ºber Sperren auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektebene</a> gesprochen, insbesondere √ºber Sperren f√ºr Beziehungen.  Heute werden wir sehen, wie Zeilensperren in PostgreSQL angeordnet sind und wie sie zusammen mit Objektsperren verwendet werden. Lassen Sie uns √ºber wartende Warteschlangen und √ºber diejenigen sprechen, die aus der Kurve klettern. <br><br><img src="https://habrastorage.org/webt/6x/u5/jj/6xu5jj3edymfhel21v9obwhsxai.png"><br><br><h1>  Zeilensperren </h1><br><h2>  Ger√§t </h2><br>  Ich m√∂chte Sie an einige wichtige Schlussfolgerungen aus dem letzten Artikel erinnern. <br><br><ul><li>  Irgendwo im gemeinsam genutzten Speicher des Servers muss eine Sperre vorhanden sein. </li><li>  Je h√∂her die Granularit√§t von Sperren ist, desto weniger Konkurrenz (Konkurrenz) zwischen gleichzeitig ausgef√ºhrten Prozessen. </li><li>  Je h√∂her die Granularit√§t ist, desto mehr Speicherplatz wird von Sperren belegt. </li></ul><br>  Wir m√∂chten sicher, dass durch die √Ñnderung einer Zeile keine anderen Zeilen derselben Tabelle blockiert werden.  Wir k√∂nnen es uns jedoch nicht leisten, jede Zeile mit einem eigenen Schloss zu beginnen. <br><br>  Es gibt verschiedene M√∂glichkeiten, dieses Problem zu l√∂sen.  In einigen DBMS steigt die Ebene der Sperren: Wenn zu viele Sperren auf Zeilenebene vorhanden sind, werden sie durch eine allgemeinere Sperre ersetzt (z. B. Seitenebene oder die gesamte Tabelle). <br><br>  Wie wir sp√§ter sehen werden, verwendet PostgreSQL diesen Mechanismus ebenfalls, jedoch nur f√ºr Pr√§dikatsperren.  Leitungssperren sind unterschiedlich. <br><a name="habracut"></a><br>  In PostgreSQL werden Informationen dar√ºber, dass eine Zeile gesperrt ist, ausschlie√ülich in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version der Zeile auf</a> der Datenseite (und nicht im RAM) gespeichert.  Das hei√üt, dies ist √ºberhaupt kein Block im √ºblichen Sinne, sondern nur ein Zeichen.  Dieses Vorzeichen ist tats√§chlich die xmax-Transaktionsnummer in Kombination mit zus√§tzlichen Informationsbits.  wenig sp√§ter werden wir im Detail sehen, wie das funktioniert. <br><br>  <strong>Das Plus</strong> ist, dass wir so viele Zeilen blockieren k√∂nnen, wie wir m√∂chten, ohne Ressourcen zu verbrauchen. <br><br>  Es gibt jedoch ein <strong>Minus</strong> : Da Informationen √ºber die Sperre nicht im RAM angezeigt werden, k√∂nnen andere Prozesse nicht in einer Reihe stehen.  Und es gibt keine √úberwachungsm√∂glichkeit (um die Sperren zu berechnen, m√ºssen Sie die gesamte Tabelle lesen). <br><br>  Nun, die √úberwachung ist in Ordnung, aber mit der Warteschlange muss etwas getan werden.  Dazu m√ºssen Sie noch "normale" Sperren verwenden.  Wenn wir warten m√ºssen, bis die Zeile freigegeben ist, m√ºssen wir tats√§chlich bis zum Ende der blockierenden Transaktion warten - alle Sperren werden beim Festschreiben oder Zur√ºcksetzen freigegeben.  Und daf√ºr k√∂nnen Sie eine Sperrnummer einer Sperrtransaktion anfordern (die, wie ich mich erinnere, von der Transaktion selbst im Ausnahmemodus gehalten wird).  Somit ist die Anzahl der verwendeten Sperren proportional zur Anzahl der gleichzeitig ausgef√ºhrten Prozesse und nicht zur Anzahl der zu √§ndernden Zeilen. <br><br><h2>  Au√üergew√∂hnliche Modi </h2><br>  Insgesamt gibt es 4 Modi, in denen Sie die Leitung sperren k√∂nnen.  Von diesen stellen zwei Modi <em>exklusive</em> Sperren dar, die jeweils nur eine Transaktion halten kann. <br><br><ul><li>  Der FOR UPDATE-Modus impliziert eine vollst√§ndige √Ñnderung (oder L√∂schung) einer Zeile. </li><li>  FOR NO KEY UPDATE-Modus - √Ñndern Sie nur die Felder, die nicht in eindeutigen Indizes enthalten sind (mit anderen Worten, bei einer solchen √Ñnderung bleiben alle Fremdschl√ºssel unver√§ndert). </li></ul><br>  Der Befehl UPDATE selbst w√§hlt den minimal geeigneten Sperrmodus aus.  Normalerweise werden Zeilen im FOR NO KEY UPDATE-Modus gesperrt. <br><br>  Wie Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erinnern</a> , wird beim L√∂schen oder √Ñndern einer Zeile die aktuelle Transaktionsversionsnummer in das Feld xmax der aktuellen aktuellen Version geschrieben.  Es zeigt, dass die Version der Zeile durch diese Transaktion gel√∂scht wurde.  Daher wird dieselbe xmax-Nummer als Zeichen der Blockierung verwendet.  Wenn xmax in der Version der Zeile einer aktiven (noch nicht abgeschlossenen) Transaktion entspricht und wir diese bestimmte Zeile aktualisieren m√∂chten, m√ºssen wir auf den Abschluss der Transaktion warten, sodass kein zus√§tzliches Vorzeichen erforderlich ist. <br><br>  Mal sehen.  Erstellen Sie eine Konten√ºbersicht wie im vorherigen Artikel. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">300.00</span></span>);</code> </pre> <br>  Zum Betrachten der Seiten ben√∂tigen wir nat√ºrlich die bereits bekannte pageinspect-Erweiterung. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Erstellen Sie der Einfachheit halber eine Ansicht, in der nur die Informationen angezeigt werden, an denen wir interessiert sind: xmax und einige Informationsbits. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">128</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lock_only, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">4096</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> is_multi, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask2 &amp; <span class="hljs-number"><span class="hljs-number">8192</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keys_upd, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keyshr_lock, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span>) = <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> shr_lock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> lp;</code> </pre><br>  Also starten wir die Transaktion und aktualisieren den Betrag des ersten Kontos (der Schl√ºssel √§ndert sich nicht) und die Nummer des zweiten Kontos (der Schl√ºssel √§ndert sich): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Wir schauen in die Ansicht: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530492 | | | | | (0,2) | 530492 | | | t | | (2 rows)</code> </pre><br>  Der Sperrmodus wird durch das Informationsbit keys_updated bestimmt. <br><br>  Das gleiche xmax-Feld wird auch beim Sperren einer Zeile mit dem Befehl SELECT FOR UPDATE verwendet. In diesem Fall wird jedoch ein zus√§tzliches Informationsbit (xmax_lock_only) abgelegt, das angibt, dass die Version der Zeile nur gesperrt, aber nicht gel√∂scht ist und weiterhin relevant ist. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR NO KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530493 | t | | | | (0,2) | 530493 | t | | t | | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><br><h2>  Gemeinsame Modi </h2><br>  Zwei weitere Modi stellen gemeinsam genutzte Sperren dar, die von mehreren Transaktionen gehalten werden k√∂nnen. <br><br><ul><li>  Der FOR SHARE-Modus wird verwendet, wenn Sie eine Zeichenfolge lesen m√ºssen, aber nicht zulassen d√ºrfen, dass sie durch eine andere Transaktion in irgendeiner Weise ge√§ndert wird. </li><li>  Der FOR KEY SHARE-Modus erm√∂glicht das √Ñndern der Zeichenfolge, jedoch nur von Nicht-Schl√ºsselfeldern.  Insbesondere dieser Modus wird von PostgreSQL beim √úberpr√ºfen von Fremdschl√ºsseln automatisch verwendet. </li></ul><br>  Mal sehen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><br>  In Zeilenversionen sehen wir: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530494 | t | | | t | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br>  In beiden F√§llen wird das Bit keyshr_lock gesetzt, und der SHARE-Modus kann durch Betrachten eines weiteren Informationsbits erkannt werden. <br><br>  So sieht die Kompatibilit√§tsmatrix f√ºr den allgemeinen Modus aus. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Modus </th><th>  F√úR KEY SHARE </th><th>  F√úR TEILEN </th><th>  F√úR KEIN KEY UPDATE </th><th>  F√úR UPDATE </th></tr><tr><td>  F√úR KEY SHARE </td><td></td><td></td><td></td><td>  X. </td></tr><tr><td>  F√úR TEILEN </td><td></td><td></td><td>  X. </td><td>  X. </td></tr><tr><td>  F√úR KEIN KEY UPDATE </td><td></td><td>  X. </td><td>  X. </td><td>  X. </td></tr><tr><td>  F√úR UPDATE </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td></tr></tbody></table></div><br>  Es zeigt, dass: <br><br><ul><li>  au√üergew√∂hnliche Modi stehen in Konflikt miteinander; </li><li>  gemeinsame Modi sind miteinander kompatibel; </li><li>  Der gemeinsam genutzte FOR KEY SHARE-Modus ist mit dem exklusiven FOR NO KEY UPDATE-Modus kompatibel (dh Sie k√∂nnen Nicht-Schl√ºsselfelder gleichzeitig aktualisieren und sicherstellen, dass sich der Schl√ºssel nicht √§ndert). </li></ul><br><h2>  Multi-Transaktion </h2><br>  Bisher dachten wir, dass die Sperre durch die Nummer der blockierenden Transaktion im xmax-Feld dargestellt wird.  Gemeinsame Sperren k√∂nnen jedoch von mehreren Transaktionen gehalten werden, und mehrere Nummern k√∂nnen nicht in dasselbe xmax-Feld geschrieben werden.  Wie man ist <br><br>  F√ºr gemeinsam genutzte Sperren werden die sogenannten Multi-Transaktionen (MultiXact) verwendet.  Dies ist eine Transaktionsgruppe, der eine separate Nummer zugewiesen ist.  Diese Nummer hat dieselbe Dimension wie eine regul√§re Transaktionsnummer, die Nummern werden jedoch unabh√§ngig voneinander zugewiesen (dh das System kann dieselbe Transaktions- und Mehrfachtransaktionsnummer haben).  Zur Unterscheidung wird ein anderes Informationsbit (xmax_is_multi) verwendet, und detaillierte Informationen zu den Mitgliedern einer solchen Gruppe und den Sperrmodi befinden sich in den Dateien im Verzeichnis $ PGDATA / pg_multixact /.  Nat√ºrlich werden die zuletzt verwendeten Daten in Puffern im gemeinsam genutzten Speicher des Servers gespeichert, um einen schnelleren Zugriff zu erm√∂glichen. <br><br>  F√ºgen Sie zu den vorhandenen Sperren eine weitere Ausnahme hinzu, die von einer anderen Transaktion ausgef√ºhrt wird (wir k√∂nnen dies tun, da die Modi FOR KEY SHARE und FOR NO KEY UPDATE miteinander kompatibel sind): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 61 | | t | | | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br>  In der ersten Zeile sehen wir, dass die √ºbliche Nummer durch eine Multitransaktionsnummer ersetzt wurde - dies wird durch das Bit xmax_is_multi angezeigt. <br><br>  Um nicht in die Interna der Multitransaction-Implementierung einzutauchen, k√∂nnen Sie eine andere Erweiterung verwenden, mit der Sie alle Informationen zu allen Arten von Zeilensperren auf bequeme Weise anzeigen k√∂nnen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgrowlocks; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------------------- locked_row | (0,1) locker | 61 multi | t xids | {530494,530495} modes | {"Key Share","No Key Update"} pids | {5892,5928} -[ RECORD 2 ]----------------------------- locked_row | (0,2) locker | 530494 multi | f xids | {530494} modes | {"For Share"} pids | {5892}</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h2>  Einstellung einfrieren </h2><br>  Da f√ºr Multitransaktionen, die in das xmax-Feld von Zeilenversionen geschrieben werden, aufgrund der Begrenzung der Bitkapazit√§t des Z√§hlers separate Nummern zugewiesen werden, tritt das gleiche xid-Umlaufproblem auf wie bei einer regul√§ren Nummer. <br><br>  Daher ist es f√ºr Mehrfachtransaktionsnummern auch erforderlich, ein Analogon zum Einfrieren durchzuf√ºhren - ersetzen Sie die alten Nummern durch neue (oder durch eine regul√§re Transaktionsnummer, wenn zum Zeitpunkt des Einfrierens die Sperre nur von einer Transaktion gehalten wird). <br><br>  Beachten Sie, dass das Einfrieren gew√∂hnlicher Transaktionsnummern nur f√ºr das Feld xmin durchgef√ºhrt wird (da die Version der Zeile ein nicht leeres xmax-Feld enth√§lt, handelt es sich entweder um eine irrelevante Version, die gel√∂scht wird, oder die xmax-Transaktion wird abgebrochen und ihre Nummer interessiert uns nicht).  Bei Mehrfachtransaktionen handelt es sich jedoch um das xmax-Feld der aktuellen Version der Zeile, das zwar relevant bleiben kann, jedoch in einem gemeinsam genutzten Modus st√§ndig von verschiedenen Transaktionen blockiert wird. <br><br>  F√ºr das Einfrieren von Mehrfachtransaktionen <em>sind</em> Parameter verantwortlich, die den Parametern des √ºblichen Einfrierens √§hnlich sind: <em>vakuum_multixact_freeze_min_age</em> , <em>vakuum_multixact_freeze_table_age</em> , <em>autovacuum_multixact_freeze_max_age</em> . <br><br><h1>  Wer ist das Extrem? </h1><br>  Allm√§hlich n√§hern Sie sich dem S√º√üen.  Lassen Sie uns sehen, wie das Bild von Sperren aussieht, wenn mehrere Transaktionen dieselbe Zeile aktualisieren. <br><br>  Beginnen wir mit der Erstellung einer Ansicht √ºber pg_locks.  Erstens werden wir die Schlussfolgerung etwas kompakter machen und zweitens werden wir uns auf interessante Sperren beschr√§nken (tats√§chlich verwerfen wir die Sperren virtueller Transaktionsnummern, den Index in der Kontentabelle, pg_locks und die Ansicht selbst - im Allgemeinen alles, was irrelevant ist und nur ablenkend). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, locktype, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'transactionid'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> transactionid::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>||<span class="hljs-string"><span class="hljs-string">':'</span></span>||tuple::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lockid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'relation'</span></span>,<span class="hljs-string"><span class="hljs-string">'transactionid'</span></span>,<span class="hljs-string"><span class="hljs-string">'tuple'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (locktype != <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><br>  Starten Sie nun die erste Transaktion und aktualisieren Sie die Zeile. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530497 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br>  Was ist mit Schl√∂ssern? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5892</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5892 | relation | accounts | RowExclusiveLock | t 5892 | transactionid | 530497 | ExclusiveLock | t (2 rows)</code> </pre><br>  Die Transaktion enth√§lt die Tabelle und eigene Nummernsperren.  Bisher wird alles erwartet. <br><br>  Wir starten die zweite Transaktion und versuchen, dieselbe Zeile zu aktualisieren. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530498 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Was ist mit zweiten Transaktionssperren? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t 5928 | transactionid | 530497 | ShareLock | f 5928 | tuple | accounts:1 | ExclusiveLock | t (4 rows)</code> </pre><br>  Und hier ist es interessanter.  Zus√§tzlich zum Sperren der Tabelle und der eigenen Nummer sehen wir zwei weitere Sperren.  Bei der zweiten Transaktion wurde festgestellt, dass die Zeile zuerst gesperrt war und auf ihre Nummer wartete (gew√§hrt = f).  Aber woher und warum kam die Zeilenversionssperre (locktype = tuple)? <br><br><blockquote>  Verwechseln Sie nicht die Zeilenversionssperre (Tupel-Sperre) und die Zeilen-Sperre (Zeilen-Sperre).  Die erste ist eine regul√§re Sperre vom Typ Tupel, die in pg_locks sichtbar ist.  Die zweite ist eine Markierung auf der Datenseite: xmax und Informationsbits. <br></blockquote><br>  Wenn eine Transaktion eine Zeile √§ndern soll, f√ºhrt sie die folgende Abfolge von Aktionen aus: <br><br><ol><li>  Erfasst eine exklusive Sperre f√ºr eine ver√§nderbare Version eines Strings (Tupel). </li><li>  Wenn xmax- und Informationsbits anzeigen, dass die Leitung gesperrt ist, werden Sie aufgefordert, die xmax-Transaktionsnummer zu sperren. </li><li>  Verschreibt die xmax- und erforderlichen Informationsbits. </li><li>  L√∂st die Zeilenversionssperre auf. </li></ol><br>  Wenn die Zeile durch die erste Transaktion aktualisiert wurde, wurde auch die Zeilenversionssperre aktiviert (Schritt 1), diese jedoch sofort freigegeben (Schritt 4). <br><br>  Als die zweite Transaktion eintraf, erfasste sie die Sperre der Zeilenversion (Element 1), musste jedoch eine Sperre f√ºr die Nummer der ersten Transaktion (Element 2) anfordern und daran festhalten. <br><br>  Was passiert, wenn eine dritte √§hnliche Transaktion angezeigt wird?  Sie wird versuchen, die Sperre der Version der Zeile (Punkt 1) zu erfassen und wird bereits bei diesem Schritt h√§ngen.  Schau es dir an. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530499 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | tuple | accounts:1 | ExclusiveLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br>  Die vierten, f√ºnften usw. Transaktionen, die dieselbe Zeile aktualisieren m√∂chten, unterscheiden sich nicht von Transaktion 3 - sie h√§ngen alle an derselben Zeilenversionssperre. <br><br>  F√ºgen Sie dem Heap eine weitere Transaktion hinzu. <br><br><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; ||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">||| txid_current | pg_backend_pid ||| --------------+---------------- ||| 530500 | 6000 ||| (1 row)</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530500 | ExclusiveLock | t 6000 | tuple | accounts:1 | ExclusiveLock | f (3 rows)</code> </pre><br>  Ein allgemeines Bild der aktuellen Erwartungen finden Sie in der Ansicht pg_stat_activity, in der Informationen zu Blockierungsprozessen hinzugef√ºgt werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, wait_event_type, wait_event, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | wait_event_type | wait_event | pg_blocking_pids ------+-----------------+---------------+------------------ 5892 | | | {} 5928 | Lock | transactionid | {5892} 5964 | Lock | tuple | {5928} 6000 | Lock | tuple | {5928,5964} (4 rows)</code> </pre><br>  Es stellt sich eine Art ‚ÄûWarteschlange‚Äú heraus, in der sich die erste (diejenige, die die Sperrversion der Zeichenfolge h√§lt) und alle anderen f√ºr die erste anstellen. <br><br>  Warum brauchen wir ein so anspruchsvolles Design?  Angenommen, wir h√§tten keine Versionssperre f√ºr die Zeichenfolge.  Dann w√ºrden die zweite und dritte (und so weiter) Transaktion auf die Blockierung der Nummer der ersten Transaktion warten.  Zum Zeitpunkt des Abschlusses der ersten Transaktion verschwindet die blockierte Ressource ( <em>und was machen Sie hier, was? Die Transaktion wurde beendet</em> ). Jetzt h√§ngt alles davon ab, welcher der Wartevorg√§nge zuerst vom Betriebssystem aktiviert wird und dementsprechend Zeit hat, die Leitung zu sperren.  Alle anderen Prozesse werden ebenfalls aktiviert, m√ºssen jedoch erneut in die Warteschlange gestellt werden - jetzt nach einem anderen Prozess. <br><br>  Dies ist mit der Tatsache behaftet, dass einige der Transaktionen auf unbestimmte Zeit warten k√∂nnen, bis sie an die Reihe kommen, wenn sie aufgrund eines ungl√ºcklichen Zusammentreffens der Umst√§nde andere Transaktionen immer ‚Äûumrunden‚Äú.  Im Englischen wird diese Situation als Schleusenhunger bezeichnet. <br><br>  In unserem Fall stellt sich heraus, dass es ungef√§hr dasselbe ist, aber immer noch ein bisschen besser: Die Transaktion, die in der zweiten kam, garantiert, dass sie Zugriff auf die n√§chste Ressource erh√§lt.  Aber was passiert mit Folgendem (drittes und viertes)? <br><br>  Wenn die erste Transaktion mit einem Rollback endet, ist alles in Ordnung: Die eingehenden Transaktionen werden in der Reihenfolge ausgef√ºhrt, in der sie in einer Reihe standen. <br><br>  Aber - das ist Pech - wenn die erste Transaktion mit einem Commit abgeschlossen wird, verschwindet nicht nur die Transaktionsnummer, sondern auch die Version der Zeile!  Das hei√üt, die Version bleibt nat√ºrlich erhalten, ist jedoch nicht mehr relevant, und es muss eine v√∂llig andere, neueste Version (derselben Zeile) aktualisiert werden.  Die Ressource, die an der Reihe war, verschwindet und jeder organisiert ein Rennen um den Besitz einer neuen Ressource. <br><br>  Lassen Sie die erste Transaktion mit Commit abschlie√üen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Die zweite Transaktion wird aufgeweckt und Abs√§tze ausgef√ºhrt.  3 und 4. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t (2 rows)</code> </pre><br>  Was ist mit der dritten Transaktion?  Sie √ºberspringt Schritt 1 (weil die Ressource verschwunden ist) und bleibt bei Schritt 2 h√§ngen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | transactionid | 530498 | ShareLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br>  Und das Gleiche passiert mit der vierten Transaktion: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530498 | ShareLock | f 6000 | transactionid | 530500 | ExclusiveLock | t (3 rows)</code> </pre><br>  Das hei√üt, sowohl die dritte als auch die vierte Transaktion warten auf den Abschluss der zweiten.  Die Linie verwandelte sich in eine <strike>K√ºrbismenge</strike> . <br><br>  Wir schlie√üen alle gestarteten Transaktionen ab. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">|| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">||| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><blockquote>  Weitere Informationen zum Blockieren von Zeichenfolgen finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README.tuplock</a> . <br></blockquote><br><h1>  Du standest nicht hier </h1><br>  Die Idee eines zweistufigen Blockierungsschemas besteht also darin, die Wahrscheinlichkeit eines ewigen Wartens auf eine "Pech" -Transaktion zu verringern.  Wie wir bereits gesehen haben, ist eine solche Situation jedoch durchaus m√∂glich.  Und wenn die Anwendung gemeinsam genutzte Sperren verwendet, kann alles noch trauriger werden. <br><br>  Lassen Sie die erste Transaktion die Zeile im gemeinsam genutzten Modus sperren. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530501 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+-------- 1 | 100.00 (1 row)</code> </pre><br>  Die zweite Transaktion versucht, dieselbe Zeile zu aktualisieren, kann dies jedoch nicht. Die Modi SHARE und NO KEY UPDATE sind nicht kompatibel. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530502 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Die zweite Transaktion wartet auf den Abschluss der ersten und h√§lt die Zeilenversionssperre - im Moment ist alles wie beim letzten Mal. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530501 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br>  Und dann erscheint eine dritte Transaktion, die eine gemeinsame Sperre w√ºnscht.  Das Problem ist, dass es nicht versucht, die Sperre f√ºr die Version der Zeile zu erfassen (weil es die Zeile nicht √§ndern wird), sondern einfach aus der Reihe kriecht - es ist mit der ersten Transaktion kompatibel. <br><br><pre> <code class="pgsql hljs">|| <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530503 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs">|| acc_no | amount || --------+-------- || 1 | 100.00 || (1 row)</code> </pre><br>  Und jetzt blockieren zwei Transaktionen die Zeile: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------- locked_row | (0,10) locker | 62 multi | t xids | {530501,530503} modes | {Share,Share} pids | {5892,5964}</code> </pre><br>  Was passiert jetzt, wenn die erste Transaktion abgeschlossen ist?  Die zweite Transaktion wird aufgeweckt, es wird jedoch festgestellt, dass die Zeilensperre nirgendwo verschwunden ist, und sie wird erneut in der ‚ÄûWarteschlange‚Äú stehen - diesmal f√ºr die dritte Transaktion: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530503 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br>  Und nur wenn die dritte Transaktion abgeschlossen ist (und w√§hrend dieser Zeit keine anderen freigegebenen Sperren angezeigt werden), kann die zweite die Aktualisierung durchf√ºhren. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Vielleicht ist es Zeit, einige praktische Schlussfolgerungen zu ziehen. <br><br><ul><li>  Es ist keine gute Idee, in vielen parallelen Prozessen dieselbe Zeile in einer Tabelle gleichzeitig zu aktualisieren. </li><li>  Wenn Sie in der Anwendung freigegebene Sperren vom Typ SHARE verwenden, dann diskret. </li><li>  Das √úberpr√ºfen von Fremdschl√ºsseln sollte nicht st√∂ren, da sich die Schl√ºsselfelder normalerweise nicht √§ndern und die Modi KEY SHARE und NO KEY UPDATE kompatibel sind. </li></ul><br><br><h1>  Gebeten, nicht zu leihen </h1><br>  In der Regel erwarten SQL-Befehle, dass sie die ben√∂tigten Ressourcen freigeben.  Manchmal m√∂chten Sie jedoch die Ausf√ºhrung des Befehls ablehnen, wenn die Sperre nicht sofort verf√ºgbar ist.  Mit Befehlen wie SELECT, LOCK, ALTER k√∂nnen Sie dazu den Ausdruck NOWAIT verwenden. <br><br>  Zum Beispiel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOWAIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| ERROR: could not obtain lock on row in relation "accounts"</code> </pre><br>  Der Befehl schl√§gt sofort fehl, wenn die Ressource ausgelastet ist.  Im Anwendungscode kann ein solcher Fehler abgefangen und verarbeitet werden. <br><br>  Sie k√∂nnen die NOWAIT-Phrase f√ºr die Befehle UPDATE und DELETE nicht angeben, aber Sie k√∂nnen zuerst SELECT FOR UPDATE NOWAIT ausf√ºhren und dann, wenn m√∂glich, die Zeile aktualisieren oder l√∂schen. <br><br>  Es gibt noch eine andere Option, um nicht zu warten - verwenden Sie den Befehl SELECT FOR mit der Phrase SKIP LOCKED.  Ein solcher Befehl √ºberspringt gesperrte Zeilen, verarbeitet jedoch freie. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> acc_no <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SKIP LOCKED</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs">| acc_no | amount | --------+-------- | 2 | 200.00 | (1 row)</code> </pre><br>  In diesem Beispiel wurde die erste blockierte Zeile √ºbersprungen und die zweite wurde sofort empfangen (und blockiert). <br><br>  In der Praxis k√∂nnen Sie so die Multithread-Verarbeitung von Warteschlangen organisieren.  Sie sollten keine andere Anwendung f√ºr diesen Befehl entwickeln. Wenn Sie ihn verwenden m√∂chten, verlieren Sie h√∂chstwahrscheinlich eine einfachere L√∂sung aus den Augen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><pre> <code class="plaintext hljs">| =&gt; ROLLBACK;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463819/">https://habr.com/ru/post/de463819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463805/index.html">Sieben B√ºcher f√ºr diejenigen, die Spieledesigner werden wollen</a></li>
<li><a href="../de463811/index.html">Vorbereiten der Anwendung f√ºr Android Q. Teil 1</a></li>
<li><a href="../de463813/index.html">Multivan und Routing auf Mikrotik RouterOS</a></li>
<li><a href="../de463815/index.html">Warum interessiert sich eine ausl√§ndische Bank f√ºr die Quelle Ihrer Gelder?</a></li>
<li><a href="../de463817/index.html">20 Produktmanager und die mehrdimensionalste Matrixstruktur von allen. Gespr√§ch mit Skyeng</a></li>
<li><a href="../de463821/index.html">AMO, Bitrix, 1C und andere: Wie w√§hlt man aus, wo man anfangen soll?</a></li>
<li><a href="../de463823/index.html">Rust 1.37.0 Release: Profilgesteuerte Optimierung, unbenannte Konstanten und Frachtanbieter</a></li>
<li><a href="../de463825/index.html">Google Sheets-Projektmanagement-Tool</a></li>
<li><a href="../de463829/index.html">FreePBX Konfigurieren von Asterisk f√ºr E-Mail-Benachrichtigungen √ºber verpasste eingehende Anrufe in der Warteschlange</a></li>
<li><a href="../de463831/index.html">Was ist los mit IT-Ausbildung in Russland</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>