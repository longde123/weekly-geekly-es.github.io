<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ЁЯЦХЁЯП╝ ЁЯП┤тАНтШая╕П ЁЯдЧ рдЕрдкрдЧреНрд░реЗрдбрд┐рдВрдЧ рдЖрдИрдбреАрдП рдкреНрд░реЛред рд╕реЗрдЧрд╛ рдореЗрдЧрд╛ рдбреНрд░рд╛рдЗрд╡ рдХреЗ рд▓рд┐рдП рдбрд┐рдмрдЧрд░ (рднрд╛рдЧ 2) тЬЛЁЯП┐ ЁЯСЗЁЯП╛ тШВя╕П</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="рд╕рднреА рдХреЛ рдирдорд╕реНрдХрд╛рд░ 


 рдкрд┐рдЫрд▓реЗ рд▓реЗрдЦ рдореЗрдВ, рд╣рдордиреЗ Sega Mega Drive / Genesis рдкрд░ рдЧреЗрдо рдПрдореБрд▓реЗрдЯрд░ рдХреЗ рдХреЛрд░ рдХреЛ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рд╕рдВрд╢реЛрдзрд┐рдд рдХрд┐рдпрд╛, рдЗрд╕рдореЗрдВ рдбрд┐рдмрдЧрд┐рдВрдЧ рдХреНрд╖рдорддрд╛рдУрдВ рдХреЛ рдЬреЛрдбрд╝рд╛ред рдЕ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>рдЕрдкрдЧреНрд░реЗрдбрд┐рдВрдЧ рдЖрдИрдбреАрдП рдкреНрд░реЛред рд╕реЗрдЧрд╛ рдореЗрдЧрд╛ рдбреНрд░рд╛рдЗрд╡ рдХреЗ рд▓рд┐рдП рдбрд┐рдмрдЧрд░ (рднрд╛рдЧ 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435002/"><p><img src="https://habrastorage.org/webt/uc/ln/ec/uclnecmakoun2veml3ooxfvaete.png"></p><br><p>  рд╕рднреА рдХреЛ рдирдорд╕реНрдХрд╛рд░ </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=hi&amp;u=">рдкрд┐рдЫрд▓реЗ рд▓реЗрдЦ рдореЗрдВ,</a> рд╣рдордиреЗ <code>Sega Mega Drive</code> / <code>Genesis</code> рдкрд░ рдЧреЗрдо рдПрдореБрд▓реЗрдЯрд░ рдХреЗ рдХреЛрд░ рдХреЛ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рд╕рдВрд╢реЛрдзрд┐рдд рдХрд┐рдпрд╛, рдЗрд╕рдореЗрдВ рдбрд┐рдмрдЧрд┐рдВрдЧ рдХреНрд╖рдорддрд╛рдУрдВ рдХреЛ рдЬреЛрдбрд╝рд╛ред  рдЕрдм <code>IDA Pro</code> , рд╕рдВрд╕реНрдХрд░рдг <code>7.0</code> рд▓рд┐рдП рдбрд┐рдмрдЧрд░ рдкреНрд▓рдЧрдЗрди рд▓рд┐рдЦрдиреЗ рдХреА рдмрд╛рд░реА рд╣реИред  рдЪрд▓рд┐рдП рд╢реБрд░реВ рдХрд░рддреЗ рд╣реИрдВред <a name="habracut"></a></p><br><h2 id="chast-vtoraya-plagin-otladchik">  рднрд╛рдЧ рджреЛ: рдбреАрдмрдЧрд░ рдкреНрд▓рдЧрд┐рди </h2><br><p>  рд╕рдмрд╕реЗ рдкрд╣рд▓реЗ, рдПрдХ рдирдпрд╛ рдЦрд╛рд▓реА <code>DLL</code> рдкреНрд░реЛрдЬреЗрдХреНрдЯ <code>DLL</code> : <code>File</code> -&gt; <code>New</code> -&gt; <code>Project</code> -&gt; <code>Windows Desktop Wizard</code> -&gt; <code>Dynamic link library (.dll)</code> , <code>Empty Project</code> рдмреЙрдХреНрд╕ рдХреЛ рднреА рдЪреЗрдХ рдХрд░реЗрдВ рдФрд░ рдмрд╛рдХреА рдХреЛ рдЕрдирдЪреЗрдХ рдХрд░реЗрдВред </p><br><p><img src="https://habrastorage.org/webt/59/de/45/59de456d6d52f649312722.png"></p><br><p>  <code>IDA SDK</code> рдЕрдирдкреИрдХ рдХрд░реЗрдВ, рдФрд░ рдЗрд╕реЗ <code>Visual Studio</code> рдореИрдХреНрд░реЛрдЬрд╝ (рдореИрдВ <code>2017 Community</code> рдЙрдкрдпреЛрдЧ рдХрд░реВрдВрдЧрд╛) рдореЗрдВ рд▓рд┐рдЦреВрдВрдЧрд╛ рддрд╛рдХрд┐ рднрд╡рд┐рд╖реНрдп рдореЗрдВ рдЖрдк рдЗрд╕реЗ рдЖрд╕рд╛рдиреА рд╕реЗ рд╕рдВрджрд░реНрднрд┐рдд рдХрд░ рд╕рдХреЗрдВред  рдЙрд╕реА рд╕рдордп, рд╣рдо <code>IDA Pro</code> рдХреЗ рдкрде рдХреЗ рд▓рд┐рдП рдПрдХ рдореИрдХреНрд░реЛ рдЬреЛрдбрд╝ рджреЗрдВрдЧреЗред </p><br><p>  <code>View</code> -&gt; <code>Other Windows</code> -&gt; <code>Property Manager</code> : </p><br><p><img src="https://habrastorage.org/webt/59/de/41/59de412a0dc50466086740.png"></p><br><p>  рдХреНрдпреЛрдВрдХрд┐  рд╣рдо <code>SDK 7.0</code> рд╕рдВрд╕реНрдХрд░рдг <code>SDK 7.0</code> рд╕рд╛рде рдХрд╛рдо рдХрд░ рд░рд╣реЗ рд╣реИрдВ, рд╕рдВрдХрд▓рди <code>x64</code> рд╕рдВрдХрд▓рдХ рджреНрд╡рд╛рд░рд╛ рд╣реЛрдЧрд╛ред  рдЗрд╕рд▓рд┐рдП, <code>Debug | x64</code> рдЪрдпрди <code>Debug | x64</code>  <code>Debug | x64</code> -&gt; <code>Microsoft.Cpp.x64.user</code> -&gt; <code>Properties</code> : </p><br><p><img src="https://habrastorage.org/webt/59/de/42/59de423c59c08942765331.png"></p><br><p>  <code>User Macros</code> рдЕрдиреБрднрд╛рдЧ рдореЗрдВ <code>Add Macro</code> рдмрдЯрди рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВ, рдФрд░ <code>IDA_SDK</code> рдореИрдХреНрд░реЛ рдХреЛ рдЙрд╕ рдкрде рдХреЗ рд╕рд╛рде рд▓рд┐рдЦреЗрдВ рдЬрд╣рд╛рдВ рдЖрдкрдиреЗ <code>SDK</code> рдЕрдирдкреИрдХ рдХрд┐рдпрд╛ рдерд╛: </p><br><p><img src="https://habrastorage.org/webt/59/de/43/59de43354eef5656763373.png"></p><br><p>  рд╣рдо <code>IDA_DIR</code> (рдЖрдкрдХреЗ <code>IDA Pro</code> рдХрд╛ рдкрде) рдХреЗ рд╕рд╛рде рднреА рдРрд╕рд╛ рд╣реА рдХрд░рддреЗ рд╣реИрдВ: </p><br><p><img src="https://habrastorage.org/webt/59/de/43/59de4393df765196799873.png"></p><br><p>  рдореИрдВ рдзреНрдпрд╛рди рджреЗрддрд╛ рд╣реВрдВ рдХрд┐ <code>IDA</code> рдбрд┐рдлрд╝реЙрд▓реНрдЯ рд░реВрдк рд╕реЗ <code>%Program Files%</code> рд╕реЗрдЯ рд╣реИ, рдЬрд┐рд╕рдХреЗ рд▓рд┐рдП рд╡реНрдпрд╡рд╕реНрдерд╛рдкрдХ рдЕрдзрд┐рдХрд╛рд░реЛрдВ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реЛрддреА рд╣реИред </p><br><p>  рдЖрдЗрдП <code>Win32</code> рдХреЙрдиреНрдлрд╝рд┐рдЧрд░реЗрд╢рди рдХреЛ рднреА рд╣рдЯрд╛ рджреЗрдВ (рдЗрд╕ рдЖрд▓реЗрдЦ рдореЗрдВ рдореИрдВ рдПрдХ <code>x86</code> рд╕рд┐рд╕реНрдЯрдо рдкрд░ рд╕рдВрдХрд▓рди рдХреЛ рдкреНрд░рднрд╛рд╡рд┐рдд рдирд╣реАрдВ рдХрд░реВрдВрдЧрд╛), рдХреЗрд╡рд▓ <code>x64</code> рд╡рд┐рдХрд▓реНрдк рдХреЛ рдЫреЛрдбрд╝рдХрд░ред </p><br><p>  рдЕрдм рдбрд┐рдмрдЧрд░ рдИрд╡реЗрдВрдЯ рдХрддрд╛рд░ рд╡рд░реНрдЧ рдЯреЗрдореНрдкрд▓реЗрдЯ рд▓реЗрдВ: </p><br><div class="spoiler">  <b class="spoiler_title">рдбрд╛рдЙрдирд▓реЛрдб рд╕реЛрд░реНрд╕ рдкреИрдХреЗрдЬ ida_debmod.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;deque&gt; #include &lt;ida.hpp&gt; #include &lt;idd.hpp&gt; //-------------------------------------------------------------------------- // Very simple class to store pending events enum queue_pos_t { IN_FRONT, IN_BACK }; struct eventlist_t : public std::deque&lt;debug_event_t&gt; { private: bool synced; public: // save a pending event void enqueue(const debug_event_t &amp;ev, queue_pos_t pos) { if (pos != IN_BACK) push_front(ev); else push_back(ev); } // retrieve a pending event bool retrieve(debug_event_t *event) { if (empty()) return false; // get the first event and return it *event = front(); pop_front(); return true; } };</span></span></span></span></code> </pre> </div></div><br><p>  рдЕрдм рд╕реНрдЯреВрдбрд┐рдпреЛ рдкрд░рд┐рдпреЛрдЬрдирд╛ рдореЗрдВ рд╕рдВрдХрд▓рдХ рдХреЗ рд▓рд┐рдП рдкрд░рд┐рднрд╛рд╖рд┐рдд рдХрд░рдиреЗ рдХрд╛ рдЕрд╡рд╕рд░ рд╣реЛрдЧрд╛, рдЗрд╕рд▓рд┐рдП рд╣рдо рдирд┐рдореНрдирд▓рд┐рдЦрд┐рдд рдЬреЛрдбрд╝рддреЗ рд╣реИрдВ: </p><br><pre> <code class="cpp hljs">__NT__ __IDP__ __X64__</code> </pre> <br><p>  рдПрдХ рдирдпрд╛ рдЦрд╛рд▓реА <code>ida_debug.cpp</code> рдлрд╝рд╛рдЗрд▓ рдЬреЛрдбрд╝реЗрдВ рдФрд░ <code>ida_debug.cpp</code> рдирд┐рдореНрди рдЯреЗрдореНрдкрд▓реЗрдЯ рдЪрд┐рдкрдХрд╛рдПрдБ: </p><br><div class="spoiler">  <b class="spoiler_title">рд╕реНрд░реЛрдд рдкреИрдХреЗрдЬ ida_debug.cpp рдбрд╛рдЙрдирд▓реЛрдб рдХрд░реЗрдВ</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ida.hpp&gt; #include &lt;idd.hpp&gt; #include &lt;auto.hpp&gt; #include &lt;funcs.hpp&gt; #include &lt;idp.hpp&gt; #include &lt;dbg.hpp&gt; #include "ida_debmod.h" #include "debug_wrap.h" static dbg_request_t *dbg_req = NULL; static void pause_execution() { send_dbg_request(dbg_req, REQ_PAUSE); } static void continue_execution() { send_dbg_request(dbg_req, REQ_RESUME); } static void stop_debugging() { send_dbg_request(dbg_req, REQ_STOP); } eventlist_t g_events; static qthread_t events_thread = NULL; // TODO: Implement status register bits mask static const char *const SRReg[] = { }; #define RC_GENERAL (1 &lt;&lt; 0) // TODO: define different register types register_info_t registers[] = { // TODO: Implement registers description }; static const char *register_classes[] = { "General Registers", // TODO: Add other register group names NULL }; static void finish_execution() { if (events_thread != NULL) { qthread_join(events_thread); qthread_free(events_thread); qthread_kill(events_thread); events_thread = NULL; } } static bool idaapi init_debugger(const char *hostname, int portnum, const char *password) { set_processor_type(ph.psnames[0], SETPROC_LOADER); // reset proc to "M68000" return true; } static bool idaapi term_debugger(void) { dbg_req-&gt;is_ida = 0; close_shared_mem(&amp;dbg_req); return true; } static int idaapi process_get_info(procinfo_vec_t *procs) { return 0; } static int idaapi check_debugger_events(void *ud) { while (dbg_req-&gt;dbg_active || dbg_req-&gt;dbg_events_count) { dbg_req-&gt;is_ida = 1; int event_index = recv_dbg_event(dbg_req, 0); if (event_index == -1) { qsleep(10); continue; } debugger_event_t *dbg_event = &amp;dbg_req-&gt;dbg_events[event_index]; debug_event_t ev; switch (dbg_event-&gt;type) { case DBG_EVT_STARTED: ev.eid = PROCESS_START; ev.pid = 1; ev.tid = 1; ev.ea = BADADDR; ev.handled = true; ev.modinfo.name[0] = 'E'; ev.modinfo.name[1] = 'M'; ev.modinfo.name[2] = 'U'; ev.modinfo.name[3] = 'L'; ev.modinfo.name[4] = '\0'; ev.modinfo.base = 0; ev.modinfo.size = 0; ev.modinfo.rebase_to = BADADDR; g_events.enqueue(ev, IN_FRONT); break; case DBG_EVT_PAUSED: ev.pid = 1; ev.tid = 1; ev.ea = dbg_event-&gt;pc; ev.handled = true; ev.eid = PROCESS_SUSPEND; g_events.enqueue(ev, IN_BACK); break; case DBG_EVT_BREAK: ev.pid = 1; ev.tid = 1; ev.ea = dbg_event-&gt;pc; ev.handled = true; ev.eid = BREAKPOINT; ev.bpt.hea = ev.bpt.kea = ev.ea; g_events.enqueue(ev, IN_BACK); break; case DBG_EVT_STEP: ev.pid = 1; ev.tid = 1; ev.ea = dbg_event-&gt;pc; ev.handled = true; ev.eid = STEP; g_events.enqueue(ev, IN_BACK); break; case DBG_EVT_STOPPED: ev.eid = PROCESS_EXIT; ev.pid = 1; ev.handled = true; ev.exit_code = 0; g_events.enqueue(ev, IN_BACK); break; default: break; } dbg_event-&gt;type = DBG_EVT_NO_EVENT; qsleep(10); } return 0; } static int idaapi start_process(const char *path, const char *args, const char *startdir, int dbg_proc_flags, const char *input_path, uint32 input_file_crc32) { g_events.clear(); dbg_req = open_shared_mem(); if (!dbg_req) { show_wait_box("HIDECANCEL\nWaiting for connection to plugin..."); while (!dbg_req) { dbg_req = open_shared_mem(); } hide_wait_box(); } events_thread = qthread_create(check_debugger_events, NULL); send_dbg_request(dbg_req, REQ_ATTACH); return 1; } static void idaapi rebase_if_required_to(ea_t new_base) { } static int idaapi prepare_to_pause_process(void) { pause_execution(); return 1; } static int idaapi emul_exit_process(void) { stop_debugging(); finish_execution(); return 1; } static gdecode_t idaapi get_debug_event(debug_event_t *event, int timeout_ms) { while (true) { // are there any pending events? if (g_events.retrieve(event)) { return g_events.empty() ? GDE_ONE_EVENT : GDE_MANY_EVENTS; } if (g_events.empty()) break; } return GDE_NO_EVENT; } static int idaapi continue_after_event(const debug_event_t *event) { dbg_notification_t req = get_running_notification(); switch (event-&gt;eid) { case STEP: case BREAKPOINT: case PROCESS_SUSPEND: if (req == dbg_null || req == dbg_run_to) continue_execution(); break; } return 1; } static void idaapi stopped_at_debug_event(bool dlls_added) { } static int idaapi thread_suspend(thid_t tid) // Suspend a running thread { return 0; } static int idaapi thread_continue(thid_t tid) // Resume a suspended thread { return 0; } static int idaapi set_step_mode(thid_t tid, resume_mode_t resmod) // Run one instruction in the thread { switch (resmod) { case RESMOD_INTO: ///&lt; step into call (the most typical single stepping) send_dbg_request(dbg_req, REQ_STEP_INTO); break; case RESMOD_OVER: ///&lt; step over call send_dbg_request(dbg_req, REQ_STEP_OVER); break; } return 1; } static int idaapi read_registers(thid_t tid, int clsmask, regval_t *values) { if (!dbg_req) return 0; if (clsmask &amp; RC_GENERAL) { dbg_req-&gt;regs_data.type = REG_TYPE_M68K; send_dbg_request(dbg_req, REQ_GET_REGS); // TODO: Set register values for IDA } // TODO: Implement other registers reading return 1; } static void set_reg(register_type_t type, int reg_index, unsigned int value) { dbg_req-&gt;regs_data.type = type; dbg_req-&gt;regs_data.any_reg.index = reg_index; dbg_req-&gt;regs_data.any_reg.val = value; send_dbg_request(dbg_req, REQ_SET_REG); } static int idaapi write_register(thid_t tid, int regidx, const regval_t *value) { // TODO: Implement set registers for emulator return 1; } static int idaapi get_memory_info(meminfo_vec_t &amp;areas) { memory_info_t info; // Don't remove this loop for (int i = 0; i &lt; get_segm_qty(); ++i) { segment_t *segm = getnseg(i); info.start_ea = segm-&gt;start_ea; info.end_ea = segm-&gt;end_ea; qstring buf; get_segm_name(&amp;buf, segm); info.name = buf; get_segm_class(&amp;buf, segm); info.sclass = buf; info.sbase = 0; info.perm = SEGPERM_READ | SEGPERM_WRITE; info.bitness = 1; areas.push_back(info); } // Don't remove this loop return 1; } static ssize_t idaapi read_memory(ea_t ea, void *buffer, size_t size) { // TODO: Implement memory regions reading return size; } static ssize_t idaapi write_memory(ea_t ea, const void *buffer, size_t size) { return 0; } static int idaapi is_ok_bpt(bpttype_t type, ea_t ea, int len) { switch (type) { //case BPT_SOFT: case BPT_EXEC: case BPT_READ: // there is no such constant in sdk61 case BPT_WRITE: case BPT_RDWR: return BPT_OK; } return BPT_BAD_TYPE; } static int idaapi update_bpts(update_bpt_info_t *bpts, int nadd, int ndel) { for (int i = 0; i &lt; nadd; ++i) { ea_t start = bpts[i].ea; ea_t end = bpts[i].ea + bpts[i].size - 1; bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; switch (bpts[i].type) { case BPT_EXEC: bpt_data-&gt;type = BPT_M68K_E; break; case BPT_READ: bpt_data-&gt;type = BPT_M68K_R; break; case BPT_WRITE: bpt_data-&gt;type = BPT_M68K_W; break; case BPT_RDWR: bpt_data-&gt;type = BPT_M68K_RW; break; } bpt_data-&gt;address = start; bpt_data-&gt;width = bpts[i].size; send_dbg_request(dbg_req, REQ_ADD_BREAK); bpts[i].code = BPT_OK; } for (int i = 0; i &lt; ndel; ++i) { ea_t start = bpts[nadd + i].ea; ea_t end = bpts[nadd + i].ea + bpts[nadd + i].size - 1; bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; switch (bpts[nadd + i].type) { case BPT_EXEC: bpt_data-&gt;type = BPT_M68K_E; break; case BPT_READ: bpt_data-&gt;type = BPT_M68K_R; break; case BPT_WRITE: bpt_data-&gt;type = BPT_M68K_W; break; case BPT_RDWR: bpt_data-&gt;type = BPT_M68K_RW; break; } bpt_data-&gt;address = start; send_dbg_request(dbg_req, REQ_DEL_BREAK); bpts[nadd + i].code = BPT_OK; } return (ndel + nadd); } //-------------------------------------------------------------------------- // // DEBUGGER DESCRIPTION BLOCK // //-------------------------------------------------------------------------- debugger_t debugger = { IDD_INTERFACE_VERSION, "DBGNAME", 0x8000 + 1, "m68k", DBG_FLAG_NOHOST | DBG_FLAG_CAN_CONT_BPT | DBG_FLAG_FAKE_ATTACH | DBG_FLAG_SAFE | DBG_FLAG_NOPASSWORD | DBG_FLAG_NOSTARTDIR | DBG_FLAG_CONNSTRING | DBG_FLAG_ANYSIZE_HWBPT | DBG_FLAG_DEBTHREAD, register_classes, RC_GENERAL, registers, qnumber(registers), 0x1000, NULL, NULL, 0, DBG_RESMOD_STEP_INTO | DBG_RESMOD_STEP_OVER, init_debugger, term_debugger, process_get_info, start_process, NULL, NULL, rebase_if_required_to, prepare_to_pause_process, emul_exit_process, get_debug_event, continue_after_event, NULL, stopped_at_debug_event, thread_suspend, thread_continue, set_step_mode, read_registers, write_register, NULL, get_memory_info, read_memory, write_memory, is_ok_bpt, update_bpts, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, };</span></span></span></span></code> </pre> </div></div><br><p>  рдЕрдЧрд▓рд╛, рдПрдХ рдФрд░ рдлрд╝рд╛рдЗрд▓ рдмрдирд╛рдПрдВ, рдЗрд╕реЗ <code>ida_plugin.cpp</code> рдХреЙрд▓ рдХрд░реЗрдВ рдФрд░ рдЗрд╕рдореЗрдВ рдирд┐рдореНрди рдХреЛрдб рдкреЗрд╕реНрдЯ рдХрд░реЗрдВ: </p><br><div class="spoiler">  <b class="spoiler_title">рд╕реНрд░реЛрдд рдкреИрдХреЗрдЬ ida_plugin.cpp рдбрд╛рдЙрдирд▓реЛрдб рдХрд░реЗрдВ</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ida.hpp&gt; #include &lt;dbg.hpp&gt; #include &lt;idd.hpp&gt; #include &lt;loader.hpp&gt; #include &lt;idp.hpp&gt; #include &lt;offset.hpp&gt; #include &lt;kernwin.hpp&gt; #include "ida_plugin.h" #include "ida_debmod.h" extern debugger_t debugger; static bool plugin_inited; static bool my_dbg; static int idaapi idp_to_dbg_reg(int idp_reg) { int reg_idx = idp_reg; if (idp_reg &gt;= 0 &amp;&amp; idp_reg &lt;= 7) reg_idx = 0 + idp_reg; else if (idp_reg &gt;= 8 &amp;&amp; idp_reg &lt;= 39) reg_idx = 8 + (idp_reg % 8); else if (idp_reg == 91) reg_idx = 16; else if (idp_reg == 92 || idp_reg == 93) reg_idx = 17; else if (idp_reg == 94) reg_idx = 15; else { char buf[MAXSTR]; ::qsnprintf(buf, MAXSTR, "reg: %d\n", idp_reg); warning("SEND THIS MESSAGE TO you@mail.com:\n%s\n", buf); return 0; } return reg_idx; } #ifdef _DEBUG static const char* const optype_names[] = { "o_void", "o_reg", "o_mem", "o_phrase", "o_displ", "o_imm", "o_far", "o_near", "o_idpspec0", "o_idpspec1", "o_idpspec2", "o_idpspec3", "o_idpspec4", "o_idpspec5", }; static const char* const dtyp_names[] = { "dt_byte", "dt_word", "dt_dword", "dt_float", "dt_double", "dt_tbyte", "dt_packreal", "dt_qword", "dt_byte16", "dt_code", "dt_void", "dt_fword", "dt_bitfild", "dt_string", "dt_unicode", "dt_3byte", "dt_ldbl", "dt_byte32", "dt_byte64", }; static void print_insn(insn_t *insn) { if (my_dbg) { msg("cs=%x, ", insn-&gt;cs); msg("ip=%x, ", insn-&gt;ip); msg("ea=%x, ", insn-&gt;ea); msg("itype=%x, ", insn-&gt;itype); msg("size=%x, ", insn-&gt;size); msg("auxpref=%x, ", insn-&gt;auxpref); msg("segpref=%x, ", insn-&gt;segpref); msg("insnpref=%x, ", insn-&gt;insnpref); msg("insnpref=%x, ", insn-&gt;insnpref); msg("flags["); if (insn-&gt;flags &amp; INSN_MACRO) msg("INSN_MACRO|"); if (insn-&gt;flags &amp; INSN_MODMAC) msg("OF_OUTER_DISP"); msg("]\n"); } } static void print_op(ea_t ea, op_t *op) { if (my_dbg) { msg("type[%s], ", optype_names[op-&gt;type]); msg("flags["); if (op-&gt;flags &amp; OF_NO_BASE_DISP) msg("OF_NO_BASE_DISP|"); if (op-&gt;flags &amp; OF_OUTER_DISP) msg("OF_OUTER_DISP|"); if (op-&gt;flags &amp; PACK_FORM_DEF) msg("PACK_FORM_DEF|"); if (op-&gt;flags &amp; OF_NUMBER) msg("OF_NUMBER|"); if (op-&gt;flags &amp; OF_SHOW) msg("OF_SHOW"); msg("], "); msg("dtyp[%s], ", dtyp_names[op-&gt;dtype]); if (op-&gt;type == o_reg) msg("reg=%x, ", op-&gt;reg); else if (op-&gt;type == o_displ || op-&gt;type == o_phrase) msg("phrase=%x, ", op-&gt;phrase); else msg("reg_phrase=%x, ", op-&gt;phrase); msg("addr=%x, ", op-&gt;addr); msg("value=%x, ", op-&gt;value); msg("specval=%x, ", op-&gt;specval); msg("specflag1=%x, ", op-&gt;specflag1); msg("specflag2=%x, ", op-&gt;specflag2); msg("specflag3=%x, ", op-&gt;specflag3); msg("specflag4=%x, ", op-&gt;specflag4); msg("refinfo["); opinfo_t buf; if (get_opinfo(&amp;buf, ea, op-&gt;n, op-&gt;flags)) { msg("target=%x, ", buf.ri.target); msg("base=%x, ", buf.ri.base); msg("tdelta=%x, ", buf.ri.tdelta); msg("flags["); if (buf.ri.flags &amp; REFINFO_TYPE) msg("REFINFO_TYPE|"); if (buf.ri.flags &amp; REFINFO_RVAOFF) msg("REFINFO_RVAOFF|"); if (buf.ri.flags &amp; REFINFO_PASTEND) msg("REFINFO_PASTEND|"); if (buf.ri.flags &amp; REFINFO_CUSTOM) msg("REFINFO_CUSTOM|"); if (buf.ri.flags &amp; REFINFO_NOBASE) msg("REFINFO_NOBASE|"); if (buf.ri.flags &amp; REFINFO_SUBTRACT) msg("REFINFO_SUBTRACT|"); if (buf.ri.flags &amp; REFINFO_SIGNEDOP) msg("REFINFO_SIGNEDOP"); msg("]"); } msg("]\n"); } } #endif typedef const regval_t &amp;(idaapi *getreg_func_t)(const char *name, const regval_t *regvalues); static ssize_t idaapi hook_idp(void *user_data, int notification_code, va_list va) { switch (notification_code) { case processor_t::ev_get_idd_opinfo: { idd_opinfo_t * opinf = va_arg(va, idd_opinfo_t *); ea_t ea = va_arg(va, ea_t); int n = va_arg(va, int); int thread_id = va_arg(va, int); getreg_func_t getreg = va_arg(va, getreg_func_t); const regval_t *regvalues = va_arg(va, const regval_t *); opinf-&gt;ea = BADADDR; opinf-&gt;debregidx = 0; opinf-&gt;modified = false; opinf-&gt;value.ival = 0; opinf-&gt;value_size = 4; insn_t out; if (decode_insn(&amp;out, ea)) { op_t op = out.ops[n]; #ifdef _DEBUG print_insn(&amp;out); #endif int size = 0; switch (op.dtype) { case dt_byte: size = 1; break; case dt_word: size = 2; break; default: size = 4; break; } opinf-&gt;value_size = size; switch (op.type) { case o_mem: case o_near: case o_imm: { flags_t flags; switch (n) { case 0: flags = get_optype_flags0(get_flags(ea)); break; case 1: flags = get_optype_flags1(get_flags(ea)); break; default: flags = 0; break; } switch (op.type) { case o_mem: case o_near: opinf-&gt;ea = op.addr; break; case o_imm: opinf-&gt;ea = op.value; break; } opinfo_t info; if (get_opinfo(&amp;info, ea, n, flags) != NULL) { opinf-&gt;ea += info.ri.base; } } break; case o_phrase: case o_reg: { int reg_idx = idp_to_dbg_reg(op.reg); regval_t reg = getreg(dbg-&gt;registers(reg_idx).name, regvalues); if (op.phrase &gt;= 0x10 &amp;&amp; op.phrase &lt;= 0x1F || // (A0)..(A7), (A0)+..(A7)+ op.phrase &gt;= 0x20 &amp;&amp; op.phrase &lt;= 0x27) // -(A0)..-(A7) { if (op.phrase &gt;= 0x20 &amp;&amp; op.phrase &lt;= 0x27) reg.ival -= size; opinf-&gt;ea = (ea_t)reg.ival; switch (size) { case 1: { uint8_t b = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;b, 1); opinf-&gt;value.ival = b; } break; case 2: { uint16_t w = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;w, 2); w = swap16(w); opinf-&gt;value.ival = w; } break; default: { uint32_t l = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;l, 4); l = swap32(l); opinf-&gt;value.ival = l; } break; } } else opinf-&gt;value = reg; opinf-&gt;debregidx = reg_idx; } break; case o_displ: { regval_t main_reg, add_reg; int main_reg_idx = idp_to_dbg_reg(op.reg); int add_reg_idx = idp_to_dbg_reg(op.specflag1 &amp; 0xF); main_reg.ival = 0; add_reg.ival = 0; if (op.specflag2 &amp; 0x10) { add_reg = getreg(dbg-&gt;registers(add_reg_idx).name, regvalues); if (op.specflag1 &amp; 0x10) { add_reg.ival &amp;= 0xFFFF; add_reg.ival = (uint64)((int16_t)add_reg.ival); } } if (main_reg_idx != 16) main_reg = getreg(dbg-&gt;registers(main_reg_idx).name, regvalues); ea_t addr = (ea_t)main_reg.ival + op.addr + (ea_t)add_reg.ival; opinf-&gt;ea = addr; switch (size) { case 1: { uint8_t b = 0; dbg-&gt;read_memory(addr, &amp;b, 1); opinf-&gt;value.ival = b; } break; case 2: { uint16_t w = 0; dbg-&gt;read_memory(addr, &amp;w, 2); w = swap16(w); opinf-&gt;value.ival = w; } break; default: { uint32_t l = 0; dbg-&gt;read_memory(addr, &amp;l, 4); l = swap32(l); opinf-&gt;value.ival = l; } break; } } break; } opinf-&gt;ea &amp;= 0xFFFFFF; return 1; } } break; default: { #ifdef _DEBUG if (my_dbg) { msg("msg = %d\n", notification_code); } #endif } break; } return 0; } //-------------------------------------------------------------------------- static void print_version() { static const char format[] = NAME " debugger plugin v%s;\nAuthor: Dr. MefistO."; info(format, VERSION); msg(format, VERSION); } //-------------------------------------------------------------------------- // Initialize debugger plugin static int idaapi init(void) { if (ph.id == PLFM_68K) { dbg = &amp;debugger; plugin_inited = true; my_dbg = false; hook_to_notification_point(HT_IDP, hook_idp, NULL); print_version(); return PLUGIN_KEEP; } return PLUGIN_SKIP; } //-------------------------------------------------------------------------- // Terminate debugger plugin static void idaapi term(void) { if (plugin_inited) { unhook_from_notification_point(HT_IDP, hook_idp); plugin_inited = false; } } //-------------------------------------------------------------------------- // The plugin method - usually is not used for debugger plugins static bool idaapi run(size_t arg) { return false; } //-------------------------------------------------------------------------- char comment[] = NAME " debugger plugin by Dr. MefistO."; char help[] = NAME " debugger plugin by Dr. MefistO.\n" "\n" "This module lets you debug Genesis roms in IDA.\n"; //-------------------------------------------------------------------------- // // PLUGIN DESCRIPTION BLOCK // //-------------------------------------------------------------------------- plugin_t PLUGIN = { IDP_INTERFACE_VERSION, PLUGIN_PROC | PLUGIN_DBG | PLUGIN_MOD, // plugin flags init, // initialize term, // terminate. this pointer may be NULL. run, // invoke plugin comment, // long comment about the plugin // it could appear in the status line // or as a hint help, // multiline help about the plugin NAME " debugger plugin", // the preferred short name of the plugin "" // the preferred hotkey to run the plugin };</span></span></span></span></code> </pre> </div></div><br><p>  рдЕрдм рд╕рдордЭрддреЗ рд╣реИрдВ, рдФрд░ рдЙрд╕реА рд╕рдордп рдХреЛрдб рд▓рд┐рдЦрддреЗ рд╣реИрдВред </p><br><h3 id="realizaciya-otladchika">  рдбрд┐рдмрдЧрд░ рдХрд╛рд░реНрдпрд╛рдиреНрд╡рдпрди </h3><br><p>  <code>dbg_req</code> рдЪрд░ рдбрд┐рдмрдЧрд░ рдХреА рдХрд░реНрдиреЗрд▓ рдХреЗ рд╕рд╛рде рд╕рд╛рдЭрд╛ рдХреА рдЧрдИ рдореЗрдореЛрд░реА рдХреЗ рд▓рд┐рдП рдПрдХ рдкреЙрдЗрдВрдЯрд░ рдХреЛ рд╕рдВрдЪрд┐рдд рдХрд░реЗрдЧрд╛ред  рдпрд╣ рдЗрд╕рдореЗрдВ рд╣реИ рдХрд┐ рд╣рдо рдЕрдиреБрд░реЛрдз рднреЗрдЬреЗрдВрдЧреЗ, рдФрд░ рдЗрд╕рд╕реЗ рдЙрддреНрддрд░ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВрдЧреЗред </p><br><p>  рдбреАрдмрдЧрд┐рдВрдЧ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХреЛ рдирд┐рдпрдВрддреНрд░рд┐рдд рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдлрд╝рдВрдХреНрд╢рди <code>pause_execution()</code> , <code>pause_execution()</code> рдФрд░ <code>stop_debugging()</code> рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реЛрддреА рд╣реИред </p><br><p>  <code>eventlist_t g_events</code> рдбрд┐рдмрдЧрд░ рдШрдЯрдирд╛рдУрдВ рдХреА рдПрдХ рд╕реВрдЪреА рд╣реИ рдЬреЛ <code>IDA</code> рд╣рдорд╛рд░реЗ рдХреБрдЫ рдХрд╛рд░реНрдпреЛрдВ (рдЙрджрд╛рд╣рд░рдг рдХреЗ рд▓рд┐рдП, рдкреНрд░рд╛рд░рдВрдн / рд░реЛрдХрдирд╛ рдЕрдиреБрдХрд░рдг, рдЯреНрд░рд┐рдЧрд░ рд╡рд┐рд░рд╛рдо) рдХреЗ рдЬрд╡рд╛рдм рдореЗрдВ рдЙрдореНрдореАрдж рдХрд░реЗрдЧреАред </p><br><p>  рдЦреИрд░, <code>events_thread</code> рдЗрд╕ рд╕реВрдЪреА рдХреЛ рдлрд┐рд░ рд╕реЗ рднрд░ рджреЗрдЧрд╛, рдЬреЛ рд╕рд╛рдЭрд╛ рдореЗрдореЛрд░реА рдореЗрдВ рдбреАрдмрдЧрд░ рдШрдЯрдирд╛рдУрдВ рдХреА рдЙрдкрд╕реНрдерд┐рддрд┐ рдХреА рдирд┐рдЧрд░рд╛рдиреА рдХрд░реЗрдЧрд╛, рдФрд░ рдЙрдиреНрд╣реЗрдВ рд╕рдВрдмрдВрдзрд┐рдд <code>IDA</code> рдШрдЯрдирд╛рдУрдВ рдореЗрдВ рдмрджрд▓ рджреЗрдЧрд╛ред </p><br><p>  рд╣рдо <code>finish_execution()</code> рдлрд╝рдВрдХреНрд╢рди <code>finish_execution()</code> , рдЬреЛ рдХреЗрд╡рд▓ рдбреАрдмрдЧрд┐рдВрдЧ рдЗрд╡реЗрдВрдЯреНрд╕ рдХреЗ рд▓рд┐рдП рдкреНрд░рддреАрдХреНрд╖рд╛ рдереНрд░реЗрдб рд╕рдорд╛рдкреНрдд рдХрд░реЗрдЧрд╛: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish_execution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (events_thread != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { qthread_join(events_thread); qthread_free(events_thread); qthread_kill(events_thread); events_thread = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } }</code> </pre> <br><p>  рдЗрд╕рд▓рд┐рдП, рд╣рдордиреЗ рдЗрд╕рдХрд╛ рдкрддрд╛ рд▓рдЧрд╛рдпрд╛ред  рдЕрдм рд╡рд░реНрдгрди рджрд░реНрдЬ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдиреАрдЪреЗ рдЖрддреЗ рд╣реИрдВред <br>  рд░рдЬрд┐рд╕реНрдЯрд░ рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рдЬрд╛рдирдХрд╛рд░реА рдирд┐рдореНрдирд▓рд┐рдЦрд┐рдд рдлреЙрд░реНрдо рдХреА рдПрдХ рд╕рдВрд░рдЪрдирд╛ рд╣реИ: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">register_info_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; uint32 flags; <span class="hljs-keyword"><span class="hljs-keyword">register_class_t</span></span> register_class; <span class="hljs-keyword"><span class="hljs-keyword">op_dtype_t</span></span> dtype; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *bit_strings; <span class="hljs-keyword"><span class="hljs-keyword">uval_t</span></span> default_bit_strings_mask; };</code> </pre> <br><p>  <code>name</code> рдлрд╝реАрд▓реНрдб рд░рдЬрд┐рд╕реНрдЯрд░ рдХрд╛ рдкрд╛рда рдирд╛рдо рд╣реИред  рдЗрд╕рдХреЗ рдЕрд▓рд╛рд╡рд╛, рд░рдЬрд┐рд╕реНрдЯрд░реЛрдВ рдХреЗ рд╡рд┐рднрд┐рдиреНрди рд╕рдореВрд╣реЛрдВ рдореЗрдВ рдПрдХ рд╣реА рдирд╛рдо рдирд╣реАрдВ рд╣реЛ рд╕рдХрддрд╛ рд╣реИред  рдЙрджрд╛рд╣рд░рдг рдХреЗ рд▓рд┐рдП, рдпрджрд┐ рдЖрдк рджреЛ рдЕрд▓рдЧ-рдЕрд▓рдЧ рдкреНрд░реЛрд╕реЗрд╕рд░ рд╕реЗ <code>PC</code> рд░рдЬрд┐рд╕реНрдЯрд░ рдкреНрд░рджрд░реНрд╢рд┐рдд рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ (рдФрд░ <code>Sega Mega Drive</code> рдореЗрдВ рдЙрдирдореЗрдВ рд╕реЗ рджреЛ рд╣реИрдВ: <code>Motorola 68000</code> рдФрд░ <code>Z80</code> ), рддреЛ рдЖрдкрдХреЛ рдЗрд╕рдХрд╛ рдирд╛рдо рдмрджрд▓рдирд╛ рд╣реЛрдЧрд╛ред </p><br><p>  <code>flags</code> рдореИрджрд╛рди рдореЗрдВ рдирд┐рдореНрди рдореЗрдВ рд╕реЗ рдПрдХ рдпрд╛ рдЕрдзрд┐рдХ <code>flags</code> рд╣реЛ рд╕рдХрддреЗ рд╣реИрдВ: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REGISTER_READONLY 0x0001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///&lt; the user can't modify the current value of this register #define REGISTER_IP 0x0002 ///&lt; instruction pointer #define REGISTER_SP 0x0004 ///&lt; stack pointer #define REGISTER_FP 0x0008 ///&lt; frame pointer #define REGISTER_ADDRESS 0x0010 ///&lt; may contain an address #define REGISTER_CS 0x0020 ///&lt; code segment #define REGISTER_SS 0x0040 ///&lt; stack segment #define REGISTER_NOLF 0x0080 ///&lt; displays this register without returning to the next line ///&lt; allowing the next register to be displayed to its right (on the same line) #define REGISTER_CUSTFMT 0x0100 ///&lt; register should be displayed using a custom data format. ///&lt; the format name is in bit_strings[0] ///&lt; the corresponding ::regval_t will use ::bytevec_t</span></span></span></span></code> </pre> <br><p>  рдпрд╣ рд╕реНрдкрд╖реНрдЯ рд╣реИ рдХрд┐ рдЖрдк <code>REGISTER_IP</code> рдФрд░ <code>REGISTER SP</code> рд╕рдВрдпреЛрдЬрд┐рдд рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗ рд╣реИрдВ, рд▓реЗрдХрд┐рди рдЖрдк рдпрд╣ рдирд┐рд░реНрджрд┐рд╖реНрдЯ рдХрд░ рд╕рдХрддреЗ рд╣реИрдВ рдХрд┐ рдлрд╝реАрд▓реНрдб рдореЗрдВ <code>REGISTER_ADDRESS</code> рдзреНрд╡рдЬ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░ рдкрддрд╛ рд╣реИред </p><br><p>  <code>register_class</code> рдЖрдкрдХреЗ рджреНрд╡рд╛рд░рд╛ рд▓рд╛рдЧреВ рдХрд┐рдП рдЧрдП рд░рдЬрд┐рд╕реНрдЯрд░реЛрдВ рдХреЗ рд╕рдореВрд╣ рдХреА рдореБрдЦреМрдЯрд╛ рд╕рдВрдЦреНрдпрд╛ рд╣реИред  рдЙрджрд╛рд╣рд░рдг рдХреЗ рд▓рд┐рдП, рдореИрдВрдиреЗ рдирд┐рдореНрдирд▓рд┐рдЦрд┐рдд рддреАрди рдЬреЛрдбрд╝реЗ рд╣реИрдВ: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RC_GENERAL (1 &lt;&lt; 0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RC_VDP (1 &lt;&lt; 1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RC_Z80 (1 &lt;&lt; 2)</span></span></code> </pre> <br><p>  <code>dtype</code> рд░рдЬрд┐рд╕реНрдЯрд░ рдХреЗ рдЖрдХрд╛рд░ рдХрд╛ рдПрдХ рд╕рдВрдХреЗрдд рд╣реИред  рд╡рд┐рдХрд▓реНрдк рдЗрд╕ рдкреНрд░рдХрд╛рд░ рд╣реИрдВ: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> dt_byte 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///&lt; 8 bit #define dt_word 1 ///&lt; 16 bit #define dt_dword 2 ///&lt; 32 bit #define dt_float 3 ///&lt; 4 byte #define dt_double 4 ///&lt; 8 byte #define dt_tbyte 5 ///&lt; variable size (\ph{tbyte_size}) #define dt_packreal 6 ///&lt; packed real format for mc68040 #define dt_qword 7 ///&lt; 64 bit #define dt_byte16 8 ///&lt; 128 bit #define dt_code 9 ///&lt; ptr to code (not used?) #define dt_void 10 ///&lt; none #define dt_fword 11 ///&lt; 48 bit #define dt_bitfild 12 ///&lt; bit field (mc680x0) #define dt_string 13 ///&lt; pointer to asciiz string #define dt_unicode 14 ///&lt; pointer to unicode string #define dt_ldbl 15 ///&lt; long double (which may be different from tbyte) #define dt_byte32 16 ///&lt; 256 bit #define dt_byte64 17 ///&lt; 512 bit</span></span></span></span></code> </pre> <br><p>  рджрд░рдЕрд╕рд▓, рдореБрдЭреЗ рдХреЗрд╡рд▓ <code>dt_word</code> , <code>dt_dword</code> ред </p><br><p>  <code>bit_strings</code> рдлрд╝реАрд▓реНрдб <code>bit_strings</code> рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реЛрддреА рд╣реИ, рдЙрджрд╛рд╣рд░рдг рдХреЗ рд▓рд┐рдП, рдЖрдк рдЗрд╕рдХреЗ рд╡реНрдпрдХреНрддрд┐рдЧрдд рдмрд┐рдЯреНрд╕ рдХреЗ рд░реВрдк рдореЗрдВ рдХреБрдЫ рд░рдЬрд┐рд╕реНрдЯрд░ рдХрд╛ рдЙрддреНрдкрд╛рджрди рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВред  рд╡рд┐рд╢реЗрд╖ рд░реВрдк рд╕реЗ, рдЗрд╕рдХрд╛ рдЙрдкрдпреЛрдЧ рд░рдЬрд┐рд╕реНрдЯрд░ рдЭрдВрдбреЗ рдХреЗ рд▓рд┐рдП рдХрд┐рдпрд╛ рдЬрд╛ рд╕рдХрддрд╛ рд╣реИ: <code>Negative</code> , <code>Overflow</code> , <code>Zero</code> , <code>Carry</code> , рдЖрджрд┐ред  рдПрдХ рдЙрджрд╛рд╣рд░рдг: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SRReg[] = { <span class="hljs-string"><span class="hljs-string">"C"</span></span>, <span class="hljs-string"><span class="hljs-string">"V"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"N"</span></span>, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"I"</span></span>, <span class="hljs-string"><span class="hljs-string">"I"</span></span>, <span class="hljs-string"><span class="hljs-string">"I"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"S"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"T"</span></span> };</code> </pre> <br><p>  рдмрд┐рдЯреНрд╕ рдКрдкрд░ рд╕реЗ рдиреАрдЪреЗ (рдХрдо рд╕реЗ рдЙрдЪреНрдЪ рддрдХ) рд╕реЗ рд╢реБрд░реВ рд╣реЛрддреА рд╣реИрдВред  рдпрджрд┐ рдЖрдкрдХреЛ рдмрд┐рдЯ рдорд╛рди рдкреНрд░рджрд░реНрд╢рд┐рдд рдХрд░рдиреЗ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рдирд╣реАрдВ рд╣реИ, рддреЛ рдирд╛рдо рдХреЗ рдмрдЬрд╛рдп <code>NULL</code> рдирд┐рд░реНрджрд┐рд╖реНрдЯ рдХрд░реЗрдВред  рдпрджрд┐ рд░рдЬрд┐рд╕реНрдЯрд░ рдореЗрдВ рдХрдИ рдмрд┐рдЯреНрд╕ рдПрдХ рдЭрдВрдбреЗ рд╕реЗ рд╕рдВрдмрдВрдзрд┐рдд рд╣реИрдВ, рддреЛ рд╣рдо рдПрдХ рд╣реА рдирд╛рдо рдХреЛ рдХрдИ рдмрд╛рд░ рдЖрд╡рд╢реНрдпрдХ рд╕рдВрдЦреНрдпрд╛ рджрд░реНрд╢рд╛рддреЗ рд╣реИрдВред </p><br><p>  рдЦреИрд░, рдЕрдВрддрд┐рдо <code>default_bit_strings_mask</code> рдлрд╝реАрд▓реНрдб рдПрдХ рдмрд┐рдЯрдорд╛рд╕реНрдХ рд╣реИ рдЬрд┐рд╕реЗ рд░рдЬрд┐рд╕реНрдЯрд░ рдмрд┐рдЯ рдорд╛рди рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рд╕реЗ рдкрд╣рд▓реЗ рд▓рд╛рдЧреВ рдХрд┐рдпрд╛ рдЬрд╛рдПрдЧрд╛ред </p><br><p>  рдпрд╣рд╛рдБ <code>Sega Mega Drive</code> рд▓рд┐рдП рд░рдЬрд┐рд╕реНрдЯрд░ рд╕реВрдЪреА рдХреЗ рдореЗрд░реЗ рдХрд╛рд░реНрдпрд╛рдиреНрд╡рдпрди рдХрд╛ рдПрдХ рдЙрджрд╛рд╣рд░рдг рд╣реИ (рдореИрдВрдиреЗ M68K, Z80 рдФрд░ VDP рд░рдЬрд┐рд╕реНрдЯрд░реЛрдВ рдХреЛ рдЪрд╛рд▓реВ рдХрд┐рдпрд╛, рд╕рд╛рде рд╣реА рд╕рд╛рде рдХрд╕реНрдЯрдо рдХреЗ рдПрдХ рдЬреЛрдбрд╝реЗ рдХреЛ рднреА): </p><br><div class="spoiler">  <b class="spoiler_title">рдбрд┐рдмрдЧрд░ рдХреЗ рд▓рд┐рдП рд░рдЬрд┐рд╕реНрдЯрд░реЛрдВ рдХрд╛ рд╡рд┐рд╡рд░рдг</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">register_info_t</span></span> registers[] = { { <span class="hljs-string"><span class="hljs-string">"D0"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D1"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D2"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D3"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D4"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D5"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D6"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D7"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A0"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A1"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A2"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A3"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A4"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A5"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A6"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A7"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"PC"</span></span>, REGISTER_ADDRESS | REGISTER_IP, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"SR"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, RC_GENERAL, dt_word, SRReg, <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> }, { <span class="hljs-string"><span class="hljs-string">"SP"</span></span>, REGISTER_ADDRESS | REGISTER_SP, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"USP"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"ISP"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"PPC"</span></span>, REGISTER_ADDRESS | REGISTER_READONLY, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"IR"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-comment"><span class="hljs-comment">// VDP Registers { "v00", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v01", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v02", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v03", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v04", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v05", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v06", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v07", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v08", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v09", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0A", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0B", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0C", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0D", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0E", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0F", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v10", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v11", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v12", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v13", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v14", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v15", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v16", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v17", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v18", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v19", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1A", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1B", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1C", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1D", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1E", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1F", NULL, RC_VDP, dt_byte, NULL, 0 }, { "DMA_LEN", REGISTER_READONLY, RC_VDP, dt_word, NULL, 0 }, { "DMA_SRC", REGISTER_ADDRESS | REGISTER_READONLY, RC_VDP, dt_dword, NULL, 0 }, { "VDP_DST", REGISTER_ADDRESS | REGISTER_READONLY, RC_VDP, dt_dword, NULL, 0 }, // Z80 regs { "zPC", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zSP", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zAF", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zBC", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zDE", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zHL", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zIX", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zIY", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zWZ", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zAF2", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zBC2", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zDE2", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zHL2", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zR", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zR2", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zIFFI1", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zIFFI2", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zHALT", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zIM", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zI", NULL, RC_Z80, dt_byte, NULL, 0 }, };</span></span></code> </pre> </div></div><br><p>  рдЗрд╕рдХреЗ рдмрд╛рдж <code>register_classes[]</code> рд╕реВрдЪреА рдЖрддреА рд╣реИ, рдЬрд┐рд╕рдореЗрдВ рд╣рдореЗрдВ рд░рдЬрд┐рд╕реНрдЯрд░ рд╕рдореВрд╣реЛрдВ рдХреЗ рдкрд╛рда рдирд╛рдореЛрдВ рдХреЛ рдирд┐рд░реНрджрд┐рд╖реНрдЯ рдХрд░рдирд╛ рд╣реЛрдЧрд╛ред  рдбрд┐рдмрдЧрд┐рдВрдЧ рдХреЗ рджреМрд░рд╛рди рдЙрдиреНрд╣реЗрдВ рдЕрд▓рдЧ-рдЕрд▓рдЧ рдЦрд┐рдбрд╝рдХрд┐рдпреЛрдВ рдореЗрдВ рдЦреЛрд▓рд╛ рдЬрд╛ рд╕рдХрддрд╛ рд╣реИред </p><br><p><img src="https://habrastorage.org/webt/qf/mg/h6/qfmgh6-849gg62-8cugjnxqtss4.png"></p><br><p>  рдпрд╣рд╛рдБ рдореЗрд░рд╛ рдХрд╛рд░реНрдпрд╛рдиреНрд╡рдпрди рд╣реИ (рдЕрдВрддрд┐рдо рддрддреНрд╡ <code>NULL</code> рд╣реЛрдирд╛ рдЪрд╛рд╣рд┐рдП): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *register_classes[] = { <span class="hljs-string"><span class="hljs-string">"General Registers"</span></span>, <span class="hljs-string"><span class="hljs-string">"VDP Registers"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z80 Registers"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre> <br><h3 id="kolbeki-neobhodimye-ida">  рдЖрдИрдбреАрдП рджреНрд╡рд╛рд░рд╛ рдЖрд╡рд╢реНрдпрдХ рдХреЙрд▓рдмреИрдХ </h3><br><h4 id="init_debugger">  init_debugger () </h4><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *hostname, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> portnum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *password)</span></span></span><span class="hljs-function"> </span></span>{ set_processor_type(ph.psnames[<span class="hljs-number"><span class="hljs-number">0</span></span>], SETPROC_LOADER); <span class="hljs-comment"><span class="hljs-comment">// reset proc to "M68000" return true; }</span></span></code> </pre> <br><p>  рдЪреВрдВрдХрд┐ <code>IDA</code> рдореЛрдЯреЛрд░реЛрд▓рд╛ рдкреНрд░реЛрд╕реЗрд╕рд░ рдХреЗ рдХрдИ рд╕рдВрд╕реНрдХрд░рдгреЛрдВ рдХреЛ рд▓рд╛рдЧреВ рдХрд░рддрд╛ рд╣реИ, рдЗрд╕рд▓рд┐рдП рдореИрдВ рдЗрд╕реЗ рд╕реВрдЪреА рдореЗрдВ рдкрд╣рд▓реЗ рд╕реНрдерд╛рди рдкрд░ рдЬрдмрд░рди рд░реАрд╕реЗрдЯ рдХрд░ рджреЗрддрд╛ рд╣реВрдВред </p><br><h4 id="term_debugger">  term_debugger () </h4><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">term_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ dbg_req-&gt;is_ida = <span class="hljs-number"><span class="hljs-number">0</span></span>; close_shared_mem(&amp;dbg_req); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  <strong>рдордЬреЗрджрд╛рд░ рддрдереНрдп</strong> : <code>init_debugger()</code> рдлрд╝рдВрдХреНрд╢рди рдХреЛ рдкреНрд░рддрд┐ рд╕рддреНрд░ рдЗрдореНрдпреВрд▓реЗрд╢рди рдХреА рдкрд╣рд▓реА рд╢реБрд░реБрдЖрдд рдореЗрдВ рдПрдХ рдмрд╛рд░ рдХрд╣рд╛ рдЬрд╛рддрд╛ рд╣реИ, рдФрд░ <code>term_debugger()</code> рдлрд╝рдВрдХреНрд╢рди рдХреЛ рд╣рд░ рдмрд╛рд░ рдбрд┐рдмрдЧрд┐рдВрдЧ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдкреВрд░реА рд╣реЛрдиреЗ рдкрд░ <code>term_debugger()</code> рд╣реИред  рдЗрд╕рд▓рд┐рдП, рдореИрдВ рдпрд╣рд╛рдВ рдЦреБрд▓реА рд╕рд╛рдЭрд╛ рдореЗрдореЛрд░реА рдХреЛ рдмрдВрдж рдХрд░рддрд╛ рд╣реВрдВред </p><br><p>  рд╕рдлрд▓ рд╣реЛрдиреЗ рдкрд░ рджреЛрдиреЛрдВ рдХрд╛рд░реНрдп <code>true</code> рдЪрд╛рд╣рд┐рдПред </p><br><h4 id="process_get_info">  process_get_info () </h4><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_get_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">procinfo_vec_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *procs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  рдпрджрд┐ рдбрд┐рдмрдЧрд┐рдВрдЧ рдХреЗ рджреМрд░рд╛рди рдЖрдк рдХрдИ рдкреНрд░рдХреНрд░рд┐рдпрд╛рдУрдВ рдХреЗ рд╕рд╛рде рдХрд╛рдо рдХрд░ рд░рд╣реЗ рд╣реИрдВ, рддреЛ рдЖрдкрдХреЛ рдЗрд╕ рдХреЙрд▓рдмреИрдХ рдХреЛ рд▓рд╛рдЧреВ рдХрд░рдиреЗ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рд╣реИ, рдЬреЛ рдЙрдирдореЗрдВ рд╕реЗ рдкреНрд░рддреНрдпреЗрдХ рдХреЗ рд▓рд┐рдП <code>IDA</code> рдЬрд╛рдирдХрд╛рд░реА рдХреА рд╕реВрдЪрдирд╛ рджреЗрдЧрд╛, рдЕрд░реНрдерд╛рддреН <code>PID</code> рдФрд░ рдирд╛рдоред </p><br><p>  рдореБрдЭреЗ рдЗрд╕ рдлрд╝рдВрдХреНрд╢рди рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рдирд╣реАрдВ рд╣реИ, рдЗрд╕рд▓рд┐рдП рдореИрдВ <code>0</code> рд╡рд╛рдкрд╕ рдХрд░рддрд╛ рд╣реВрдВред </p><br><h4 id="check_debugger_events---ne-kolbek-no-ochen-vazhen">  check_debugger_events () - рдХреЙрд▓рдмреИрдХ рдирд╣реАрдВ, рд▓реЗрдХрд┐рди рдмрд╣реБрдд рдорд╣рддреНрд╡рдкреВрд░реНрдг рд╣реИ </h4><br><p>  рд╡рд╛рд╕реНрддрд╡ рдореЗрдВ, рдпрд╣ рдбрд┐рдмрдЧрд┐рдВрдЧ рдШрдЯрдирд╛рдУрдВ рдХреА рдкреНрд░рддреАрдХреНрд╖рд╛ рдХрд░ рд░рд╣рд╛ рдПрдХ рдзрд╛рдЧрд╛ рд╣реИред  рдпрд╣рд╛рдБ рдкрд░ рдЕрдзрд┐рдХ рд╡рд┐рд╕реНрддрд╛рд░ рд╕реЗ рдмрддрд╛рдирд╛ рдЖрд╡рд╢реНрдпрдХ рд╣реИред </p><br><p>  рдЬрдм рдбреАрдмрдЧ рдХрд░рдирд╛ рд╢реБрд░реВ рд╣реЛрддрд╛ рд╣реИ, рддреЛ <code>IDA</code> рдХреЛ рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдХреА рдЙрдореНрдореАрдж рдХрд░рдиреЗ рд╡рд╛рд▓реА рдкрд╣рд▓реА рдШрдЯрдирд╛ <code>PROCESS_START</code> рд╣реЛрдиреА рдЪрд╛рд╣рд┐рдПред  рдпрджрд┐ рдкрд╣рд▓реЗ рдПрдХ рдЖрддрд╛ рд╣реИ, рдЙрджрд╛рд╣рд░рдг рдХреЗ рд▓рд┐рдП, рдПрдХ рд╡рд┐рд░рд╛рдо рдЕрдиреБрдХрд░рдг рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рдПрдХ рд╕рдВрджреЗрд╢, <code>IDA</code> рдмрд╕ рдЧрд┐рд░ рдЬрд╛рдПрдЧрд╛ред </p><br><p>  рдЙрд╕рдХреЗ рдмрд╛рдж, рдЖрдк рдкрд╣рд▓реЗ рд╕реЗ рд╣реА рдЕрдиреНрдп рд╕рдВрджреЗрд╢ рдкреНрд░рд╛рдкреНрдд рдХрд░ рд╕рдХрддреЗ рд╣реИрдВред  рдЙрдкрдпреЛрдЧ рдХрд┐рдП рдЬрд╛рдиреЗ рд╡рд╛рд▓реЗ рдореБрдЦреНрдп рд╣реИрдВ: </p><br><ul><li> <code>PROCESS_SUSPEND</code> тАФ  ,          ,    . </li><li> <code>BREAKPOINT</code> тАФ   <code>IDA</code>  ,      тАФ  ,  ,   .   <em></em> ?        <code>PROCESS_SUSPEND</code> ,      ,    <code>IDA</code> </li><li> <code>STEP</code> тАФ    ,   <code>IDA</code>  ,   <code>Step Into</code>  <code>Step Over</code> , ,  ,     <code>PROCESS_SUSPEND</code> </li><li> <code>PROCESS_EXIT</code> тАФ    <code>IDA</code>    ,   .     <code>Stop</code>   , <code>IDA</code>       ,    , <del>    , </del>       . </li></ul><br><p>       : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">debug_event_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event_id_t</span></span> eid; <span class="hljs-comment"><span class="hljs-comment">///&lt; Event code (used to decipher 'info' union) pid_t pid; ///&lt; Process where the event occurred thid_t tid; ///&lt; Thread where the event occurred ea_t ea; ///&lt; Address where the event occurred bool handled; ///&lt; Is event handled by the debugger?. ///&lt; (from the system's point of view) ///&lt; Meaningful for ::EXCEPTION events union { module_info_t modinfo; ///&lt; ::PROCESS_START, ::PROCESS_ATTACH, ::LIBRARY_LOAD int exit_code; ///&lt; ::PROCESS_EXIT, ::THREAD_EXIT char info[MAXSTR]; ///&lt; ::LIBRARY_UNLOAD (unloaded library name) ///&lt; ::INFORMATION (will be displayed in the ///&lt; messages window if not empty) e_breakpoint_t bpt; ///&lt; ::BREAKPOINT e_exception_t exc; ///&lt; ::EXCEPTION }; };</span></span></code> </pre> <br><p> <code>eid</code> тАФ     ,    <br> <code>pid</code> , <code>tid</code> тАФ , <em>Process ID</em>  <em>Thread ID</em> ,     <br> <code>ea</code> тАФ ,    <br> <code>handled</code> тАФ      , ,     <code>IDA SDK</code> ,    ,      ( ?).    <code>true</code> </p><br><p>   ,        . </p><br><p>  <code>PROCESS_START</code>      ( ), <code>ImageBase</code> ,    , ,   <code>ImageBase</code> ,     ,      <code>IDB</code> .        ,   ,  <code>BADADDR</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DBG_EVT_STARTED: ev.eid = PROCESS_START; ev.pid = <span class="hljs-number"><span class="hljs-number">1</span></span>; ev.tid = <span class="hljs-number"><span class="hljs-number">1</span></span>; ev.ea = BADADDR; ev.handled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ev.modinfo.name[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'G'</span></span>; ev.modinfo.name[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'P'</span></span>; ev.modinfo.name[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-string"><span class="hljs-string">'G'</span></span>; ev.modinfo.name[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-string"><span class="hljs-string">'X'</span></span>; ev.modinfo.name[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; ev.modinfo.base = <span class="hljs-number"><span class="hljs-number">0</span></span>; ev.modinfo.size = <span class="hljs-number"><span class="hljs-number">0</span></span>; ev.modinfo.rebase_to = BADADDR; g_events.enqueue(ev, IN_FRONT); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br><p>  <code>BREAKPOINT</code>   <code>bpt</code>  <code>hardware</code> тАФ  <code>kernel</code> -  .         ,   <code>IDA</code>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DBG_EVT_BREAK: ev.pid = <span class="hljs-number"><span class="hljs-number">1</span></span>; ev.tid = <span class="hljs-number"><span class="hljs-number">1</span></span>; ev.ea = dbg_event-&gt;pc; ev.handled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ev.eid = BREAKPOINT; ev.bpt.hea = ev.bpt.kea = ev.ea; g_events.enqueue(ev, IN_BACK); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br><p>   <code>PROCESS_EXIT</code>   <code>exit_code</code> . </p><br><h4 id="start_process"> start_process() </h4><br><p>    ,    ,    ,      . </p><br><p>       ,         (     ),     ,        . </p><br><p>  <code>1</code>   . </p><br><h4 id="rebase_if_required_to"> rebase_if_required_to() </h4><br><p>    , ..     , ,     : </p><br><div class="spoiler"> <b class="spoiler_title"> rebase_if_required_to</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rebase_if_required_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ea_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> new_base)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> currentbase = new_base; <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> imagebase = inf.startIP; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imagebase != currentbase) { <span class="hljs-keyword"><span class="hljs-keyword">adiff_t</span></span> delta = currentbase - imagebase; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code = rebase_program(delta, MSF_FIXONCE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (code != MOVE_SEGM_OK) { msg(<span class="hljs-string"><span class="hljs-string">"Failed to rebase program, error code %d\n"</span></span>, code); warning(<span class="hljs-string"><span class="hljs-string">"IDA failed to rebase the program.\n"</span></span> <span class="hljs-string"><span class="hljs-string">"Most likely it happened because of the debugger\n"</span></span> <span class="hljs-string"><span class="hljs-string">"segments created to reflect the real memory state.\n\n"</span></span> <span class="hljs-string"><span class="hljs-string">"Please stop the debugger and rebase the program manually.\n"</span></span> <span class="hljs-string"><span class="hljs-string">"For that, please select the whole program and\n"</span></span> <span class="hljs-string"><span class="hljs-string">"use Edit, Segments, Rebase program with delta 0x%08a"</span></span>, delta); } } }</code> </pre> </div></div><br><h4 id="prepare_to_pause_process"> prepare_to_pause_process() </h4><br><p>     <code>Pause</code>  <code>IDA</code> ,    . <br>  <code>1</code>      . </p><br><h4 id="get_debug_event"> get_debug_event() </h4><br><p> ,   <code>IDA</code> ,     .    (?) .   ,   <code>debug_event_t</code>   <code>*event</code> ,  : </p><br><ul><li> <code>GDE_ONE_EVENT</code> ,     ,      </li><li> <code>GDE_MANY_EVENTS</code> ,      ,   </li><li> <code>GDE_NO_EVENT</code> ,      </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gdecode_t idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_debug_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">debug_event_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *event, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout_ms)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// are there any pending events? if (g_events.retrieve(event)) { return g_events.empty() ? GDE_ONE_EVENT : GDE_MANY_EVENTS; } if (g_events.empty()) break; } return GDE_NO_EVENT; }</span></span></code> </pre> <br><h4 id="continue_after_event"> continue_after_event() </h4><br><p>  ,         -  <code>IDA</code> .    . </p><br><p>  ,   ,  ,   -      .    : </p><br><ol><li>   <code>STEP</code> </li><li> <code>IDA</code>            ,   .. </li><li>   , ,  <code>Step In</code> </li><li>   <code>continue_after_event()</code> ,      <em></em>    .    тАФ <code>STEP</code> </li><li> <code>IDA</code>   <code>STEP</code> </li></ol><br><p>    , ,       ,        , <strong>  </strong> ! <br>   ,  ,     <code>3</code>   <code>Step Into</code> , <code>Step Over</code> ,  <code>F9</code> ,   . </p><br><p>    <code>STEP</code> , <code>BREAKPOINT</code>  <code>PROCESS_SUSPEND</code> ,       <code>F9</code> ,        <code>continue_execution()</code> .   <code>F9</code>  <code>Run to</code>    : </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">dbg_notification_t</span></span> req = get_running_notification(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req == dbg_null || req == dbg_run_to) continue_execution();</code> </pre> <br><h4 id="stopped_at_debug_event"> stopped_at_debug_event() </h4><br><p>    ,   .   . </p><br><h4 id="thread_suspend-thread_continue"> thread_suspend(), thread_continue() </h4><br><p>   ,        / ,  .   ,        ,   <code>0</code> .       ,        . </p><br><h4 id="set_step_mode"> set_step_mode() </h4><br><p>  ,       <code>Step Into</code> , <code>Step Over</code> , <code>Step Out</code> .        (     <code>debugger_t</code> ,     ). <br>  <code>1</code>   . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_step_mode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">thid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">resume_mode_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resmod)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (resmod) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESMOD_INTO: send_dbg_request(dbg_req, REQ_STEP_INTO); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESMOD_OVER: send_dbg_request(dbg_req, REQ_STEP_OVER); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h4 id="read_registers"> read_registers() </h4><br><p>  <code>IDA</code>   <code>STEP</code> , <code>BREAKPOINT</code>  <code>PROCESS_SUSPEND</code> (.. ,   ),     ,      . </p><br><p>    : </p><br><ul><li> <code>clsmask</code> тАФ        ?   .         </li><li> <code>values</code> тАФ   ,    .        <code>registers[]</code> . </li></ul><br><p>      : </p><br><div class="spoiler"> <b class="spoiler_title"> read_registers()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_registers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">thid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> clsmask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">regval_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *values)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_req) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clsmask &amp; RC_GENERAL) { dbg_req-&gt;regs_data.type = REG_TYPE_M68K; send_dbg_request(dbg_req, REQ_GET_REGS); <span class="hljs-keyword"><span class="hljs-keyword">regs_68k_data_t</span></span> *reg_vals = &amp;dbg_req-&gt;regs_data.regs_68k; values[REG_68K_D0].ival = reg_vals-&gt;d0; values[REG_68K_D1].ival = reg_vals-&gt;d1; values[REG_68K_D2].ival = reg_vals-&gt;d2; values[REG_68K_D3].ival = reg_vals-&gt;d3; values[REG_68K_D4].ival = reg_vals-&gt;d4; values[REG_68K_D5].ival = reg_vals-&gt;d5; values[REG_68K_D6].ival = reg_vals-&gt;d6; values[REG_68K_D7].ival = reg_vals-&gt;d7; values[REG_68K_A0].ival = reg_vals-&gt;a0; values[REG_68K_A1].ival = reg_vals-&gt;a1; values[REG_68K_A2].ival = reg_vals-&gt;a2; values[REG_68K_A3].ival = reg_vals-&gt;a3; values[REG_68K_A4].ival = reg_vals-&gt;a4; values[REG_68K_A5].ival = reg_vals-&gt;a5; values[REG_68K_A6].ival = reg_vals-&gt;a6; values[REG_68K_A7].ival = reg_vals-&gt;a7; values[REG_68K_PC].ival = reg_vals-&gt;pc &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>; values[REG_68K_SR].ival = reg_vals-&gt;sr; values[REG_68K_SP].ival = reg_vals-&gt;sp &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>; values[REG_68K_PPC].ival = reg_vals-&gt;ppc &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>; values[REG_68K_IR].ival = reg_vals-&gt;ir; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clsmask &amp; RC_VDP) { dbg_req-&gt;regs_data.type = REG_TYPE_VDP; send_dbg_request(dbg_req, REQ_GET_REGS); <span class="hljs-keyword"><span class="hljs-keyword">vdp_regs_t</span></span> *vdp_regs = &amp;dbg_req-&gt;regs_data.vdp_regs; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(vdp_regs-&gt;regs_vdp) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(vdp_regs-&gt;regs_vdp[<span class="hljs-number"><span class="hljs-number">0</span></span>]); ++i) { values[REG_VDP_00 + i].ival = vdp_regs-&gt;regs_vdp[i]; } values[REG_VDP_DMA_LEN].ival = vdp_regs-&gt;dma_len; values[REG_VDP_DMA_SRC].ival = vdp_regs-&gt;dma_src; values[REG_VDP_DMA_DST].ival = vdp_regs-&gt;dma_dst; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clsmask &amp; RC_Z80) { dbg_req-&gt;regs_data.type = REG_TYPE_Z80; send_dbg_request(dbg_req, REQ_GET_REGS); <span class="hljs-keyword"><span class="hljs-keyword">regs_z80_data_t</span></span> *z80_regs = &amp;dbg_req-&gt;regs_data.regs_z80; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (REG_Z80_I - REG_Z80_PC + <span class="hljs-number"><span class="hljs-number">1</span></span>); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt;= <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-comment"><span class="hljs-comment">// PC &lt;-&gt; HL2 { values[REG_Z80_PC + i].ival = ((unsigned int *)&amp;z80_regs-&gt;pc)[i]; } else if (i &gt;= 13 &amp;&amp; i &lt;= 19) // R &lt;-&gt; I { values[REG_Z80_PC + i].ival = ((unsigned char *)&amp;z80_regs-&gt;r)[i - 13]; } } } return 1; }</span></span></code> </pre> </div></div><br><p>  <code>1</code>   . </p><br><h4 id="write_register"> write_register() </h4><br><p>      тАФ    .            . </p><br><p>  : </p><br><div class="spoiler"> <b class="spoiler_title"> write_register()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">thid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> regidx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">regval_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx &gt;= REG_68K_D0 &amp;&amp; regidx &lt;= REG_68K_D7) { set_reg(REG_TYPE_M68K, regidx - REG_68K_D0, (uint32)value-&gt;ival); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx &gt;= REG_68K_A0 &amp;&amp; regidx &lt;= REG_68K_A7) { set_reg(REG_TYPE_M68K, regidx - REG_68K_A0, (uint32)value-&gt;ival); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx == REG_68K_PC) { set_reg(REG_TYPE_M68K, REG_68K_PC, (uint32)value-&gt;ival &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx == REG_68K_SR) { set_reg(REG_TYPE_M68K, REG_68K_SR, (uint16)value-&gt;ival); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx == REG_68K_SP) { set_reg(REG_TYPE_M68K, REG_68K_SP, (uint32)value-&gt;ival &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx == REG_68K_USP) { set_reg(REG_TYPE_M68K, REG_68K_USP, (uint32)value-&gt;ival &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx == REG_68K_ISP) { set_reg(REG_TYPE_M68K, REG_68K_ISP, (uint32)value-&gt;ival &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx &gt;= REG_VDP_00 &amp;&amp; regidx &lt;= REG_VDP_1F) { set_reg(REG_TYPE_VDP, regidx - REG_VDP_00, value-&gt;ival &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx &gt;= REG_Z80_PC &amp;&amp; regidx &lt;= REG_Z80_I) { set_reg(REG_TYPE_Z80, regidx - REG_Z80_PC, value-&gt;ival); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> </div></div><br><p>  <code>1</code>   . </p><br><h4 id="get_memory_info"> get_memory_info() </h4><br><p>       <em></em>  ,       .    :    <code>IDB</code>    - ,     .              . </p><br><p>        - ,      ,      .    : </p><br><pre> <code class="cpp hljs"> info.name = <span class="hljs-string"><span class="hljs-string">"DBG_VDP_VRAM"</span></span>; info.start_ea = <span class="hljs-number"><span class="hljs-number">0xD00000</span></span>; info.end_ea = info.start_ea + <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; info.bitness = <span class="hljs-number"><span class="hljs-number">1</span></span>; areas.push_back(info); info.name = <span class="hljs-string"><span class="hljs-string">"DBG_VDP_CRAM"</span></span>; info.start_ea = info.end_ea; info.end_ea = info.start_ea + <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; info.bitness = <span class="hljs-number"><span class="hljs-number">1</span></span>; areas.push_back(info); info.name = <span class="hljs-string"><span class="hljs-string">"DBG_VDP_VSRAM"</span></span>; info.start_ea = info.end_ea; info.end_ea = info.start_ea + <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; info.bitness = <span class="hljs-number"><span class="hljs-number">1</span></span>; areas.push_back(info);</code> </pre> <br><p>  <code>1</code>   . </p><br><h4 id="read_memory"> read_memory() </h4><br><p>    .    ,    ,     <code>XTRN</code> , <code>IDA</code>   . <br>      <code>ea</code> ,    ,   <code>size</code> ,   ,     <code>buffer</code> ,          . </p><br><div class="spoiler"> <b class="spoiler_title">  read_memory()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ssize_t idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ea_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ea, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ea &gt;= <span class="hljs-number"><span class="hljs-number">0xA00000</span></span> &amp;&amp; ea &lt; <span class="hljs-number"><span class="hljs-number">0xA0FFFF</span></span>)) { dbg_req-&gt;mem_data.address = ea; dbg_req-&gt;mem_data.size = size; send_dbg_request(dbg_req, REQ_READ_Z80); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(buffer, &amp;dbg_req-&gt;mem_data.z80_ram[ea &amp; <span class="hljs-number"><span class="hljs-number">0x1FFF</span></span>], size); <span class="hljs-comment"><span class="hljs-comment">// Z80 } else if (ea &lt; MAXROMSIZE) { dbg_req-&gt;mem_data.address = ea; dbg_req-&gt;mem_data.size = size; send_dbg_request(dbg_req, REQ_READ_68K_ROM); memcpy(buffer, &amp;dbg_req-&gt;mem_data.m68k_rom[ea], size); } else if ((ea &gt;= 0xFF0000 &amp;&amp; ea &lt; 0x1000000)) { dbg_req-&gt;mem_data.address = ea; dbg_req-&gt;mem_data.size = size; send_dbg_request(dbg_req, REQ_READ_68K_RAM); memcpy(buffer, &amp;dbg_req-&gt;mem_data.m68k_ram[ea &amp; 0xFFFF], size); // RAM } return size; }</span></span></code> </pre> </div></div><br><h4 id="write_memory"> write_memory() </h4><br><p>   ,   -      :  ,   RAM,  ,      . </p><br><p>       ,    <code>0</code> .   <code>1</code> . </p><br><p>     ,     ,    ,  <code>buffer</code>  тАФ   ,   . </p><br><h4 id="is_ok_bpt"> is_ok_bpt() </h4><br><p>                 <code>len</code>   <code>type</code>   <code>ea</code> . </p><br><p>   ,  <code>BPT_OK</code> ,  тАФ <code>BPT_BAD_TYPE</code> . </p><br><h4 id="update_bpts"> update_bpts() </h4><br><p> ,       <code>IDA</code>   .  ,         ,  .      <code>F9</code> ( <em>Continue</em> ). </p><br><p>       : </p><br><ol><li>     <code>bpts</code> ,    ,  : , , ,        <code>nadd</code>   <code>ndel</code> ,       . </li><li>  ,      ,  <code>bpts[i].code</code>  <code>BPT_OK</code> . </li></ol><br><p>      +  .   <code>nadd + ndel</code> . </p><br><div class="spoiler"> <b class="spoiler_title"> update_bpts()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_bpts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">update_bpt_info_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bpts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nadd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ndel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nadd; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> start = bpts[i].ea; <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> end = bpts[i].ea + bpts[i].size - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bpt_data_t</span></span> *bpt_data = &amp;dbg_req-&gt;bpt_data; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (bpts[i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_EXEC: bpt_data-&gt;type = BPT_M68K_E; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_READ: bpt_data-&gt;type = BPT_M68K_R; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_WRITE: bpt_data-&gt;type = BPT_M68K_W; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_RDWR: bpt_data-&gt;type = BPT_M68K_RW; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } bpt_data-&gt;address = start; bpt_data-&gt;width = bpts[i].size; send_dbg_request(dbg_req, REQ_ADD_BREAK); bpts[i].code = BPT_OK; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ndel; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> start = bpts[nadd + i].ea; <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> end = bpts[nadd + i].ea + bpts[nadd + i].size - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bpt_data_t</span></span> *bpt_data = &amp;dbg_req-&gt;bpt_data; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (bpts[nadd + i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_EXEC: bpt_data-&gt;type = BPT_M68K_E; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_READ: bpt_data-&gt;type = BPT_M68K_R; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_WRITE: bpt_data-&gt;type = BPT_M68K_W; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_RDWR: bpt_data-&gt;type = BPT_M68K_RW; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } bpt_data-&gt;address = start; send_dbg_request(dbg_req, REQ_DEL_BREAK); bpts[nadd + i].code = BPT_OK; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (ndel + nadd); }</code> </pre> </div></div><br><h3 id="struktura-debugger_t">  debugger_t </h3><br><p>     ,     (,  ,  <code>IDA</code>    ,   ,   , ,   ). </p><br><p>    : </p><br><div class="spoiler"> <b class="spoiler_title"> debugger_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">debugger_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-comment"><span class="hljs-comment">///&lt; Expected kernel version, ///&lt; should be #IDD_INTERFACE_VERSION const char *name; ///&lt; Short debugger name like win32 or linux int id; ///&lt; one of \ref DEBUGGER_ID_ /// \defgroup DEBUGGER_ID_ Debugger API module id /// Used by debugger_t::id //@{ #define DEBUGGER_ID_X86_IA32_WIN32_USER 0 ///&lt; Userland win32 processes (win32 debugging APIs) #define DEBUGGER_ID_X86_IA32_LINUX_USER 1 ///&lt; Userland linux processes (ptrace()) #define DEBUGGER_ID_ARM_WINCE_ASYNC 2 ///&lt; Windows CE ARM (ActiveSync transport) #define DEBUGGER_ID_X86_IA32_MACOSX_USER 3 ///&lt; Userland MAC OS X processes #define DEBUGGER_ID_ARM_EPOC_USER 4 ///&lt; Symbian OS #define DEBUGGER_ID_ARM_IPHONE_USER 5 ///&lt; iPhone 1.x #define DEBUGGER_ID_X86_IA32_BOCHS 6 ///&lt; BochsDbg.exe 32 #define DEBUGGER_ID_6811_EMULATOR 7 ///&lt; MC6812 emulator (beta) #define DEBUGGER_ID_GDB_USER 8 ///&lt; GDB remote #define DEBUGGER_ID_WINDBG 9 ///&lt; WinDBG using Microsoft Debug engine #define DEBUGGER_ID_X86_DOSBOX_EMULATOR 10 ///&lt; Dosbox MS-DOS emulator #define DEBUGGER_ID_ARM_LINUX_USER 11 ///&lt; Userland arm linux #define DEBUGGER_ID_TRACE_REPLAYER 12 ///&lt; Fake debugger to replay recorded traces #define DEBUGGER_ID_ARM_WINCE_TCPIP 13 ///&lt; Windows CE ARM (TPC/IP transport) #define DEBUGGER_ID_X86_PIN_TRACER 14 ///&lt; PIN Tracer module #define DEBUGGER_ID_DALVIK_USER 15 ///&lt; Dalvik //@} const char *processor; ///&lt; Required processor name. ///&lt; Used for instant debugging to load the correct ///&lt; processor module uint32 flags; ///&lt; \ref DBG_FLAG_ /// \defgroup DBG_FLAG_ Debugger module features /// Used by debugger_t::flags //@{ #define DBG_FLAG_REMOTE 0x00000001 ///&lt; Remote debugger (requires remote host name unless #DBG_FLAG_NOHOST) #define DBG_FLAG_NOHOST 0x00000002 ///&lt; Remote debugger with does not require network params (host/port/pass). ///&lt; (a unique device connected to the machine) #define DBG_FLAG_FAKE_ATTACH 0x00000004 ///&lt; ::PROCESS_ATTACH is a fake event ///&lt; and does not suspend the execution #define DBG_FLAG_HWDATBPT_ONE 0x00000008 ///&lt; Hardware data breakpoints are ///&lt; one byte size by default #define DBG_FLAG_CAN_CONT_BPT 0x00000010 ///&lt; Debugger knows to continue from a bpt. ///&lt; This flag also means that the debugger module ///&lt; hides breakpoints from ida upon read_memory #define DBG_FLAG_NEEDPORT 0x00000020 ///&lt; Remote debugger requires port number (to be used with DBG_FLAG_NOHOST) #define DBG_FLAG_DONT_DISTURB 0x00000040 ///&lt; Debugger can handle only ///&lt; get_debug_event(), ///&lt; prepare_to_pause_process(), ///&lt; exit_process(). ///&lt; when the debugged process is running. ///&lt; The kernel may also call service functions ///&lt; (file I/O, map_address, etc) #define DBG_FLAG_SAFE 0x00000080 ///&lt; The debugger is safe (probably because it just emulates the application ///&lt; without really running it) #define DBG_FLAG_CLEAN_EXIT 0x00000100 ///&lt; IDA must suspend the application and remove ///&lt; all breakpoints before terminating the application. ///&lt; Usually this is not required because the application memory ///&lt; disappears upon termination. #define DBG_FLAG_USE_SREGS 0x00000200 ///&lt; Take segment register values into account (non flat memory) #define DBG_FLAG_NOSTARTDIR 0x00000400 ///&lt; Debugger module doesn't use startup directory #define DBG_FLAG_NOPARAMETERS 0x00000800 ///&lt; Debugger module doesn't use commandline parameters #define DBG_FLAG_NOPASSWORD 0x00001000 ///&lt; Remote debugger doesn't use password #define DBG_FLAG_CONNSTRING 0x00002000 ///&lt; Display "Connection string" instead of "Hostname" and hide the "Port" field #define DBG_FLAG_SMALLBLKS 0x00004000 ///&lt; If set, IDA uses 256-byte blocks for caching memory contents. ///&lt; Otherwise, 1024-byte blocks are used #define DBG_FLAG_MANMEMINFO 0x00008000 ///&lt; If set, manual memory region manipulation commands ///&lt; will be available. Use this bit for debugger modules ///&lt; that can not return memory layout information #define DBG_FLAG_EXITSHOTOK 0x00010000 ///&lt; IDA may take a memory snapshot at ::PROCESS_EXIT event #define DBG_FLAG_VIRTHREADS 0x00020000 ///&lt; Thread IDs may be shuffled after each debug event. ///&lt; (to be used for virtual threads that represent cpus for windbg kmode) #define DBG_FLAG_LOWCNDS 0x00040000 ///&lt; Low level breakpoint conditions are supported. #define DBG_FLAG_DEBTHREAD 0x00080000 ///&lt; Supports creation of a separate thread in ida ///&lt; for the debugger (the debthread). ///&lt; Most debugger functions will be called from debthread (exceptions are marked below) ///&lt; The debugger module may directly call only #THREAD_SAFE functions. ///&lt; To call other functions please use execute_sync(). ///&lt; The debthread significantly increases debugging ///&lt; speed, especially if debug events occur frequently (to be tested) #define DBG_FLAG_DEBUG_DLL 0x00100000 ///&lt; Can debug standalone DLLs. ///&lt; For example, Bochs debugger can debug any snippet of code #define DBG_FLAG_FAKE_MEMORY 0x00200000 ///&lt; get_memory_info()/read_memory()/write_memory() work with the idb. ///&lt; (there is no real process to read from, as for the replayer module) ///&lt; the kernel will not call these functions if this flag is set. ///&lt; however, third party plugins may call them, they must be implemented. #define DBG_FLAG_ANYSIZE_HWBPT 0x00400000 ///&lt; The debugger supports arbitrary size hardware breakpoints. #define DBG_FLAG_TRACER_MODULE 0x00800000 ///&lt; The module is a tracer, not a full featured debugger module #define DBG_FLAG_PREFER_SWBPTS 0x01000000 ///&lt; Prefer to use software breakpoints //@} const char **register_classes; ///&lt; Array of register class names int register_classes_default; ///&lt; Mask of default printed register classes register_info_t *_registers; ///&lt; Array of registers. Use registers() to access it int registers_size; ///&lt; Number of registers int memory_page_size; ///&lt; Size of a memory page const uchar *bpt_bytes; ///&lt; Array of bytes for a breakpoint instruction uchar bpt_size; ///&lt; Size of this array uchar filetype; ///&lt; for miniidbs: use this value ///&lt; for the file type after attaching ///&lt; to a new process ushort resume_modes; ///&lt; \ref DBG_RESMOD_ /// \defgroup DBG_RESMOD_ Resume modes /// Used by debugger_t::resume_modes //@{ #define DBG_RESMOD_STEP_INTO 0x0001 ///&lt; ::RESMOD_INTO is available #define DBG_RESMOD_STEP_OVER 0x0002 ///&lt; ::RESMOD_OVER is available #define DBG_RESMOD_STEP_OUT 0x0004 ///&lt; ::RESMOD_OUT is available #define DBG_RESMOD_STEP_SRCINTO 0x0008 ///&lt; ::RESMOD_SRCINTO is available #define DBG_RESMOD_STEP_SRCOVER 0x0010 ///&lt; ::RESMOD_SRCOVER is available #define DBG_RESMOD_STEP_SRCOUT 0x0020 ///&lt; ::RESMOD_SRCOUT is available #define DBG_RESMOD_STEP_USER 0x0040 ///&lt; ::RESMOD_USER is available #define DBG_RESMOD_STEP_HANDLE 0x0080 ///&lt; ::RESMOD_HANDLE is available //@} #if !defined(_MSC_VER) // this compiler complains :( static const int default_port_number = 23946; #define DEBUGGER_PORT_NUMBER debugger_t::default_port_number #else #define DEBUGGER_PORT_NUMBER 23946 #endif /// Initialize debugger. /// This function is called from the main thread. /// \return success bool (idaapi *init_debugger)(const char *hostname, int portnum, const char *password); /// Terminate debugger. /// This function is called from the main thread. /// \return success bool (idaapi *term_debugger)(void); /// Return information about the running processes. /// This function is called from the main thread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *get_processes)(procinfo_vec_t *procs); /// Start an executable to debug. /// This function is called from debthread. /// \param path path to executable /// \param args arguments to pass to executable /// \param startdir current directory of new process /// \param dbg_proc_flags \ref DBG_PROC_ /// \param input_path path to database input file. /// (not always the same as 'path' - eg if you're analyzing /// a dll and want to launch an executable that loads it) /// \param input_file_crc32 CRC value for 'input_path' /// \retval 1 ok /// \retval 0 failed /// \retval -2 file not found (ask for process options) /// \retval 1 | #CRC32_MISMATCH ok, but the input file crc does not match /// \retval -1 network error int (idaapi *start_process)(const char *path, const char *args, const char *startdir, int dbg_proc_flags, const char *input_path, uint32 input_file_crc32); /// \defgroup DBG_PROC_ Debug process flags /// Passed as 'dbg_proc_flags' parameter to debugger_t::start_process //@{ #define DBG_PROC_IS_DLL 0x01 ///&lt; database contains a dll (not exe) #define DBG_PROC_IS_GUI 0x02 ///&lt; using gui version of ida #define DBG_PROC_32BIT 0x04 ///&lt; application is 32-bit #define DBG_PROC_64BIT 0x08 ///&lt; application is 64-bit #define DBG_NO_TRACE 0x10 ///&lt; do not trace the application (mac/linux) #define DBG_HIDE_WINDOW 0x20 ///&lt; application should be hidden on startup (windows) //@} #define CRC32_MISMATCH 0x40000000 ///&lt; crc32 mismatch bit (see return values for debugger_t::start_process) /// Attach to an existing running process. /// event_id should be equal to -1 if not attaching to a crashed process. /// This function is called from debthread. /// \param pid process id to attach /// \param event_id event to trigger upon attaching /// \param dbg_proc_flags \ref DBG_PROC_ /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *attach_process)(pid_t pid, int event_id, int dbg_proc_flags); /// Detach from the debugged process. /// May be called while the process is running or suspended. /// Must detach from the process in any case. /// The kernel will repeatedly call get_debug_event() and until ::PROCESS_DETACH. /// In this mode, all other events will be automatically handled and process will be resumed. /// This function is called from debthread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *detach_process)(void); /// Rebase database if the debugged program has been rebased by the system. /// This function is called from the main thread. void (idaapi *rebase_if_required_to)(ea_t new_base); /// Prepare to pause the process. /// Normally the next get_debug_event() will pause the process /// If the process is sleeping then the pause will not occur /// until the process wakes up. The interface should take care of /// this situation. /// If this function is absent, then it won't be possible to pause the program. /// This function is called from debthread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *prepare_to_pause_process)(void); /// Stop the process. /// May be called while the process is running or suspended. /// Must terminate the process in any case. /// The kernel will repeatedly call get_debug_event() and until ::PROCESS_EXIT. /// In this mode, all other events will be automatically handled and process will be resumed. /// This function is called from debthread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *exit_process)(void); /// Get a pending debug event and suspend the process. /// This function will be called regularly by IDA. /// This function is called from debthread. /// IMPORTANT: commdbg does not expect immediately after a BPT-related event /// any other event with the same thread/IP - this can cause erroneous /// restoring of a breakpoint before resume /// (the bug was encountered 24.02.2015 in pc_linux_upx.elf) gdecode_t (idaapi *get_debug_event)(debug_event_t *event, int timeout_ms); /// Continue after handling the event. /// This function is called from debthread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *continue_after_event)(const debug_event_t *event); /// Set exception handling. /// This function is called from debthread or the main thread. void (idaapi *set_exception_info)(const exception_info_t *info, int qty); /// This function will be called by the kernel each time /// it has stopped the debugger process and refreshed the database. /// The debugger module may add information to the database if it wants. /// /// The reason for introducing this function is that when an event line /// LOAD_DLL happens, the database does not reflect the memory state yet /// and therefore we can't add information about the dll into the database /// in the get_debug_event() function. /// Only when the kernel has adjusted the database we can do it. /// Example: for imported PE DLLs we will add the exported function /// names to the database. /// /// This function pointer may be absent, ie NULL. /// This function is called from the main thread. void (idaapi *stopped_at_debug_event)(bool dlls_added); /// \name Threads /// The following functions manipulate threads. /// These functions are called from debthread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error //@{ int (idaapi *thread_suspend) (thid_t tid); ///&lt; Suspend a running thread int (idaapi *thread_continue)(thid_t tid); ///&lt; Resume a suspended thread int (idaapi *set_resume_mode)(thid_t tid, resume_mode_t resmod); ///&lt; Specify resume action //@} /// Read thread registers. /// This function is called from debthread. /// \param tid thread id /// \param clsmask bitmask of register classes to read /// \param values pointer to vector of regvals for all registers. /// regval is assumed to have debugger_t::registers_size elements /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *read_registers)(thid_t tid, int clsmask, regval_t *values); /// Write one thread register. /// This function is called from debthread. /// \param tid thread id /// \param regidx register index /// \param value new value of the register /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *write_register)(thid_t tid, int regidx, const regval_t *value); /// Get information about the base of a segment register. /// Currently used by the IBM PC module to resolve references like fs:0. /// This function is called from debthread. /// \param answer pointer to the answer. can't be NULL. /// \param tid thread id /// \param sreg_value value of the segment register (returned by get_reg_val()) /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *thread_get_sreg_base)(ea_t *answer, thid_t tid, int sreg_value); /// \name Memory manipulation /// The following functions manipulate bytes in the memory. //@{ /// Get information on the memory ranges. /// The debugger module fills 'ranges'. The returned vector MUST be sorted. /// This function is called from debthread. /// \retval -3 use idb segmentation /// \retval -2 no changes /// \retval -1 the process does not exist anymore /// \retval 0 failed /// \retval 1 new memory layout is returned int (idaapi *get_memory_info)(meminfo_vec_t &amp;ranges); /// Read process memory. /// Returns number of read bytes. /// This function is called from debthread. /// \retval 0 read error /// \retval -1 process does not exist anymore ssize_t (idaapi *read_memory)(ea_t ea, void *buffer, size_t size); /// Write process memory. /// This function is called from debthread. /// \return number of written bytes, -1 if fatal error ssize_t (idaapi *write_memory)(ea_t ea, const void *buffer, size_t size); //@} /// Is it possible to set breakpoint?. /// This function is called from debthread or from the main thread if debthread /// is not running yet. /// It is called to verify hardware breakpoints. /// \return ref BPT_ int (idaapi *is_ok_bpt)(bpttype_t type, ea_t ea, int len); /// \defgroup BPT_ Breakpoint verification codes /// Return values for debugger_t::is_ok_bpt //@{ #define BPT_OK 0 ///&lt; breakpoint can be set #define BPT_INTERNAL_ERR 1 ///&lt; interr occurred when verifying breakpoint #define BPT_BAD_TYPE 2 ///&lt; bpt type is not supported #define BPT_BAD_ALIGN 3 ///&lt; alignment is invalid #define BPT_BAD_ADDR 4 ///&lt; ea is invalid #define BPT_BAD_LEN 5 ///&lt; bpt len is invalid #define BPT_TOO_MANY 6 ///&lt; reached max number of supported breakpoints #define BPT_READ_ERROR 7 ///&lt; failed to read memory at bpt ea #define BPT_WRITE_ERROR 8 ///&lt; failed to write memory at bpt ea #define BPT_SKIP 9 ///&lt; update_bpts(): do not process bpt #define BPT_PAGE_OK 10 ///&lt; update_bpts(): ok, added a page bpt //@} /// Add/del breakpoints. /// bpts array contains nadd bpts to add, followed by ndel bpts to del. /// This function is called from debthread. /// \return number of successfully modified bpts, -1 if network error int (idaapi *update_bpts)(update_bpt_info_t *bpts, int nadd, int ndel); /// Update low-level (server side) breakpoint conditions. /// This function is called from debthread. /// \return nlowcnds. -1-network error int (idaapi *update_lowcnds)(const lowcnd_t *lowcnds, int nlowcnds); /// \name Remote file /// Open/close/read a remote file. /// These functions are called from the main thread //@{ int (idaapi *open_file)(const char *file, uint64 *fsize, bool readonly); // -1-error void (idaapi *close_file)(int fn); ssize_t (idaapi *read_file)(int fn, qoff64_t off, void *buf, size_t size); //@} /// Map process address. /// This function may be absent. /// This function is called from debthread. /// \param off offset to map /// \param regs current register values. if regs == NULL, then perform /// global mapping, which is independent on used registers /// usually such a mapping is a trivial identity mapping /// \param regnum required mapping. maybe specified as a segment register number /// or a regular register number if the required mapping can be deduced /// from it. for example, esp implies that ss should be used. /// \return mapped address or #BADADDR ea_t (idaapi *map_address)(ea_t off, const regval_t *regs, int regnum); /// Set debugger options (parameters that are specific to the debugger module). /// See the definition of ::set_options_t for arguments. /// See the convenience function in dbg.hpp if you need to call it. /// The kernel will call this function after reading the debugger specific /// config file (arguments are: keyword="", type=#IDPOPT_STR, value="") /// This function is optional. /// This function is called from the main thread const char *(idaapi *set_dbg_options)( const char *keyword, int pri, int value_type, const void *value); /// Get pointer to debugger specific functions. /// This function returns a pointer to a structure that holds pointers to /// debugger module specific functions. For information on the structure /// layout, please check the corresponding debugger module. Most debugger /// modules return NULL because they do not have any extensions. Available /// extensions may be called from plugins. /// This function is called from the main thread. const void *(idaapi *get_debmod_extensions)(void); /// Calculate the call stack trace. /// This function is called when the process is suspended and should fill /// the 'trace' object with the information about the current call stack. /// If this function is missing or returns false, IDA will use the standard /// mechanism (based on the frame pointer chain) to calculate the stack trace /// This function is called from the main thread. /// \return success bool (idaapi *update_call_stack)(thid_t tid, call_stack_t *trace); /// Call application function. /// This function calls a function from the debugged application. /// This function is called from debthread /// \param func_ea address to call /// \param tid thread to use /// \param fti type information for the called function /// \param nargs number of actual arguments /// \param regargs information about register arguments /// \param stkargs memory blob to pass as stack arguments (usually contains pointed data) /// it must be relocated by the callback but not changed otherwise /// \param retregs function return registers. /// \param[out] errbuf the error message. if empty on failure, see 'event'. /// should not be filled if an appcall exception /// happened but #APPCALL_DEBEV is set /// \param[out] event the last debug event that occurred during appcall execution /// filled only if the appcall execution fails and #APPCALL_DEBEV is set /// \param options appcall options, usually taken from \inf{appcall_options}. /// possible values: combination of \ref APPCALL_ or 0 /// \return ea of stkargs blob, #BADADDR if failed and errbuf is filled ea_t (idaapi *appcall)( ea_t func_ea, thid_t tid, const struct func_type_data_t *fti, int nargs, const struct regobjs_t *regargs, struct relobj_t *stkargs, struct regobjs_t *retregs, qstring *errbuf, debug_event_t *event, int options); /// \defgroup APPCALL_ Appcall options /// Passed as 'options' parameter to debugger_t::appcall //@{ #define APPCALL_MANUAL 0x0001 ///&lt; Only set up the appcall, do not run. ///&lt; debugger_t::cleanup_appcall will not be called by ida! #define APPCALL_DEBEV 0x0002 ///&lt; Return debug event information #define APPCALL_TIMEOUT 0x0004 ///&lt; Appcall with timeout. ///&lt; If timed out, errbuf will contain "timeout". ///&lt; See #SET_APPCALL_TIMEOUT and #GET_APPCALL_TIMEOUT //@} /// Cleanup after appcall(). /// The debugger module must keep the stack blob in the memory until this function /// is called. It will be called by the kernel for each successful appcall(). /// There is an exception: if #APPCALL_MANUAL, IDA may not call cleanup_appcall. /// If the user selects to terminate a manual appcall, then cleanup_appcall will be called. /// Otherwise, the debugger module should terminate the appcall when the called /// function returns. /// This function is called from debthread. /// \retval 2 ok, there are pending events /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *cleanup_appcall)(thid_t tid); /// Evaluate a low level breakpoint condition at 'ea'. /// Other evaluation errors are displayed in a dialog box. /// This call is rarely used by IDA when the process has already been suspended /// for some reason and it has to decide whether the process should be resumed /// or definitely suspended because of a breakpoint with a low level condition. /// This function is called from debthread. /// \retval 1 condition is satisfied /// \retval 0 not satisfied /// \retval -1 network error int (idaapi *eval_lowcnd)(thid_t tid, ea_t ea); /// This function is called from main thread ssize_t (idaapi *write_file)(int fn, qoff64_t off, const void *buf, size_t size); /// Perform a debugger-specific function. /// This function is called from debthread int (idaapi *send_ioctl)(int fn, const void *buf, size_t size, void **poutbuf, ssize_t *poutsize); /// Enable/Disable tracing. /// "trace_flags" can be a set of STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE. /// See thread_t::trace_mode in debugger.h. /// This function is called from the main thread. bool (idaapi *dbg_enable_trace)(thid_t tid, bool enable, int trace_flags); /// Is tracing enabled? ONLY used for tracers. /// "trace_bit" can be one of the following: STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE bool (idaapi *is_tracing_enabled)(thid_t tid, int tracebit); /// Execute a command on the remote computer. /// \return exit code int (idaapi *rexec)(const char *cmdline); /// Get (store to out_pattrs) process/debugger-specific runtime attributes. /// This function is called from main thread. void (idaapi *get_debapp_attrs)(debapp_attrs_t *out_pattrs); /// Get the path to a file containing source debug info for the given module. /// This allows srcinfo providers to call into the debugger when looking for debug info. /// It is useful in certain cases like the iOS debugger, which is a remote debugger but /// the remote debugserver does not provide dwarf info. So, we allow the debugger client /// to decide where to look for debug info locally. /// \param path output path (file might not exist) /// \param base base address of a module in the target process /// \return success, result stored in 'path' bool (idaapi *get_srcinfo_path)(qstring *path, ea_t base); };</span></span></code> </pre> </div></div><br><p>       ,   , ,    . </p><br><h3 id="a-otladchik-ved-tozhe-plagin">      </h3><br><p>  рд╣рд╛рдБ, рд╣рд╛рдБред      <code>ida_plugin.cpp</code> .  ,     . </p><br><h4 id="funkciya-idp_to_dbg_reg">  idp_to_dbg_reg() </h4><br><p>           (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=hi&amp;u="> </a> )   . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">idp_to_dbg_reg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idp_reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reg_idx = idp_reg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idp_reg &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; idp_reg &lt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) reg_idx = <span class="hljs-number"><span class="hljs-number">0</span></span> + idp_reg; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idp_reg &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> &amp;&amp; idp_reg &lt;= <span class="hljs-number"><span class="hljs-number">39</span></span>) reg_idx = <span class="hljs-number"><span class="hljs-number">8</span></span> + (idp_reg % <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idp_reg == <span class="hljs-number"><span class="hljs-number">91</span></span>) reg_idx = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idp_reg == <span class="hljs-number"><span class="hljs-number">92</span></span> || idp_reg == <span class="hljs-number"><span class="hljs-number">93</span></span>) reg_idx = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idp_reg == <span class="hljs-number"><span class="hljs-number">94</span></span>) reg_idx = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[MAXSTR]; ::qsnprintf(buf, MAXSTR, <span class="hljs-string"><span class="hljs-string">"reg: %d\n"</span></span>, idp_reg); warning(<span class="hljs-string"><span class="hljs-string">"SEND THIS MESSAGE TO you@mail.com:\n%s\n"</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reg_idx; }</code> </pre> <br><h4 id="funkciya-hook_idp">  hook_idp() </h4><br><p>     <code>hook_to_notification_point()</code> : </p><br><pre> <code class="cpp hljs">hook_to_notification_point(HT_IDP, hook_idp, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre> <br><p>   <code>unhook_from_notification_point()</code> : </p><br><pre> <code class="cpp hljs">unhook_from_notification_point(HT_IDP, hook_idp);</code> </pre> <br><p>       : <em>debugger hints</em> .     "": </p><br><p><img src="https://habrastorage.org/webt/qs/al/rr/qsalrrtxwyil4zzbcen_k1okmtw.png"></p><br><p> ,    ,      -      ,    .       ,  ,      <code>IDA</code> ,  .   . </p><br><p>            <code>notification_code</code>   <code>ev_get_idd_opinfo</code> .      ,   ,          , , ,           . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">processor_t</span></span>::ev_get_idd_opinfo: { <span class="hljs-keyword"><span class="hljs-keyword">idd_opinfo_t</span></span> * opinf = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">idd_opinfo_t</span></span> *); <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> ea = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> thread_id = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">getreg_func_t</span></span> getreg = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">getreg_func_t</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">regval_t</span></span> *regvalues = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">regval_t</span></span> *); opinf-&gt;ea = BADADDR; opinf-&gt;debregidx = <span class="hljs-number"><span class="hljs-number">0</span></span>; opinf-&gt;modified = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; opinf-&gt;value.ival = <span class="hljs-number"><span class="hljs-number">0</span></span>; opinf-&gt;value_size = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span> out; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decode_insn(&amp;out, ea)) { <span class="hljs-keyword"><span class="hljs-keyword">op_t</span></span> op = out.ops[n]; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _DEBUG print_insn(&amp;out); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> int size = 0; switch (op.dtype) { case dt_byte: size = 1; break; case dt_word: size = 2; break; default: size = 4; break; } opinf-&gt;value_size = size; switch (op.type) { case o_mem: case o_near: case o_imm: { flags_t flags; switch (n) { case 0: flags = get_optype_flags0(get_flags(ea)); break; case 1: flags = get_optype_flags1(get_flags(ea)); break; default: flags = 0; break; } switch (op.type) { case o_mem: case o_near: opinf-&gt;ea = op.addr; break; case o_imm: opinf-&gt;ea = op.value; break; } opinfo_t info; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (get_opinfo(&amp;info, ea, n, flags) != NULL) { opinf-&gt;ea += info.ri.base; } } break; case o_phrase: case o_reg: { int reg_idx = idp_to_dbg_reg(op.reg); regval_t reg = getreg(dbg-&gt;registers(reg_idx).name, regvalues); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (op.phrase &gt;= 0x10 &amp;&amp; op.phrase </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= 0x1F || // (A0)..(A7), (A0)+..(A7)+ op.phrase &gt;= 0x20 &amp;&amp; op.phrase &lt;= 0x27) // -(A0)..-(A7) { if (op.phrase &gt;= 0x20 &amp;&amp; op.phrase &lt;= 0x27) reg.ival -= size; opinf-&gt;ea = (ea_t)reg.ival; switch (size) { case 1: { uint8_t b = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;b, 1); opinf-&gt;value.ival = b; } break; case 2: { uint16_t w = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;w, 2); w = swap16(w); opinf-&gt;value.ival = w; } break; default: { uint32_t l = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;l, 4); l = swap32(l); opinf-&gt;value.ival = l; } break; } } else opinf-&gt;value = reg; opinf-&gt;debregidx = reg_idx; } break; case o_displ: { regval_t main_reg, add_reg; int main_reg_idx = idp_to_dbg_reg(op.reg); int add_reg_idx = idp_to_dbg_reg(op.specflag1 &amp; 0xF); main_reg.ival = 0; add_reg.ival = 0; if (op.specflag2 &amp; 0x10) { add_reg = getreg(dbg-&gt;registers(add_reg_idx).name, regvalues); if (op.specflag1 &amp; 0x10) { add_reg.ival &amp;= 0xFFFF; add_reg.ival = (uint64)((int16_t)add_reg.ival); } } if (main_reg_idx != 16) main_reg = getreg(dbg-&gt;registers(main_reg_idx).name, regvalues); ea_t addr = (ea_t)main_reg.ival + op.addr + (ea_t)add_reg.ival; opinf-&gt;ea = addr; switch (size) { case 1: { uint8_t b = 0; dbg-&gt;read_memory(addr, &amp;b, 1); opinf-&gt;value.ival = b; } break; case 2: { uint16_t w = 0; dbg-&gt;read_memory(addr, &amp;w, 2); w = swap16(w); opinf-&gt;value.ival = w; } break; default: { uint32_t l = 0; dbg-&gt;read_memory(addr, &amp;l, 4); l = swap32(l); opinf-&gt;value.ival = l; } break; } } break; } opinf-&gt;ea &amp;= 0xFFFFFF; return 1; } } break;</span></span></span></span></code> </pre> </div></div><br><p> ,       . </p><br><h4 id="init"> init() </h4><br><p>       ,     . <br>      ,     <code>id</code>   <code>ph</code> . </p><br><p>        <code>PLFM_68K</code> .       <code>dbg</code>       <code>debugger_t</code> . </p><br><p>   <code>HT_IDP</code> ,   <code>PLUGIN_KEEP</code> . ,        ,  <code>PLUGIN_SKIP</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ph.id == PLFM_68K) { dbg = &amp;debugger; plugin_inited = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; my_dbg = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; hook_to_notification_point(HT_IDP, hook_idp, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); print_version(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PLUGIN_KEEP; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PLUGIN_SKIP; }</code> </pre> <br><h4 id="term"> term() </h4><br><p>    <code>IDB</code> -.      ,     <code>init()</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">term</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (plugin_inited) { unhook_from_notification_point(HT_IDP, hook_idp); plugin_inited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h4 id="run"> run() </h4><br><p>  -    .  <code>false</code> . </p><br><h3 id="struktura-plugin_t">  plugin_t </h3><br><p>   :  , ,  ,  ,  : </p><br><div class="spoiler"> <b class="spoiler_title"> plugin_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">plugin_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-comment"><span class="hljs-comment">///&lt; Should be equal to #IDP_INTERFACE_VERSION int flags; ///&lt; \ref PLUGIN_ /// \defgroup PLUGIN_ Plugin features /// Used by plugin_t::flags //@{ #define PLUGIN_MOD 0x0001 ///&lt; Plugin changes the database. ///&lt; IDA won't call the plugin if ///&lt; the processor module prohibited any changes. #define PLUGIN_DRAW 0x0002 ///&lt; IDA should redraw everything after calling the plugin. #define PLUGIN_SEG 0x0004 ///&lt; Plugin may be applied only if the current address belongs to a segment #define PLUGIN_UNL 0x0008 ///&lt; Unload the plugin immediately after calling 'run'. ///&lt; This flag may be set anytime. ///&lt; The kernel checks it after each call to 'run' ///&lt; The main purpose of this flag is to ease ///&lt; the debugging of new plugins. #define PLUGIN_HIDE 0x0010 ///&lt; Plugin should not appear in the Edit, Plugins menu. ///&lt; This flag is checked at the start. #define PLUGIN_DBG 0x0020 ///&lt; A debugger plugin. init() should put ///&lt; the address of ::debugger_t to dbg. #define PLUGIN_PROC 0x0040 ///&lt; Load plugin when a processor module is loaded. (and keep it ///&lt; until the processor module is unloaded) #define PLUGIN_FIX 0x0080 ///&lt; Load plugin when IDA starts and keep it in the memory until IDA stops #define PLUGIN_SCRIPTED 0x8000 ///&lt; Scripted plugin. Should not be used by plugins, ///&lt; the kernel sets it automatically. //@} int (idaapi *init)(void); ///&lt; Initialize plugin - returns \ref PLUGIN_INIT /// \defgroup PLUGIN_INIT Plugin initialization codes /// Return values for plugin_t::init() //@{ #define PLUGIN_SKIP 0 ///&lt; Plugin doesn't want to be loaded #define PLUGIN_OK 1 ///&lt; Plugin agrees to work with the current database. ///&lt; It will be loaded as soon as the user presses the hotkey #define PLUGIN_KEEP 2 ///&lt; Plugin agrees to work with the current database and wants to stay in the memory //@} void (idaapi *term)(void); ///&lt; Terminate plugin. This function will be called ///&lt; when the plugin is unloaded. May be NULL. bool (idaapi *run)(size_t arg); ///&lt; Invoke plugin const char *comment; ///&lt; Long comment about the plugin. ///&lt; it could appear in the status line ///&lt; or as a hint const char *help; ///&lt; Multiline help about the plugin const char *wanted_name; ///&lt; The preferred short name of the plugin const char *wanted_hotkey; ///&lt; The preferred hotkey to run the plugin };</span></span></code> </pre> </div></div><br><p>  рд╢рд╛рдпрдж рдпрд╣реА рд╕рдм рд╣реИред ,  ,          .  ,      <code>IDA</code>    ,     . </p><br><p>   ,   : <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=hi&amp;u=">GPGX Debugger</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=hi&amp;u=">Smd IDA Tools</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/hi435002/">https://habr.com/ru/post/hi435002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../hi434992/index.html">рдЕрдкрдЧреНрд░реЗрдбрд┐рдВрдЧ рдЖрдИрдбреАрдП рдкреНрд░реЛред рд╕реЗрдЧрд╛ рдореЗрдЧрд╛ рдбреНрд░рд╛рдЗрд╡ рдХреЗ рд▓рд┐рдП рдбрд┐рдмрдЧрд░ (рднрд╛рдЧ 1)</a></li>
<li><a href="../hi434994/index.html">рдПрдВрдбреНрд░реЙрдЗрдб: рдбрд╛рдпрдирд╛рдорд┐рдХ рдкреНрд░реЛрдбрдХреНрдЯ рдлреНрд▓реЗрд╡рд░ рдФрд░ рд╕рд╛рдЗрдирд┐рдВрдЧ рдХрдиреНрдлрд┐рдЧреНрд╕</a></li>
<li><a href="../hi434996/index.html">рдореИрдВрдиреЗ рд╡реАрдХреЗ рдПрдкреАрдЖрдИ рдХреЗ рдорд╛рдзреНрдпрдо рд╕реЗ рд╕реНрдерд╛рди рдХреИрд╕реЗ рд╕рд╛рдЭрд╛ рдХрд┐рдпрд╛</a></li>
<li><a href="../hi434998/index.html">рд╕реНрдорд╛рд░реНрдЯрдлреЛрди рдЪреБрдирдиреЗ рдХреЗ рддрд░реАрдХреЗ рдкрд░ рдПрдХ рдФрд░ рд▓реЗрдЦ</a></li>
<li><a href="../hi435000/index.html">рд╡рд┐рдЬреНрдЮрд╛рдкрди рдЪреИрдирд▓реЛрдВ рдХреА рдмрд╛рддрдЪреАрдд рдХреА рдЕрд╡рдзрд╛рд░рдгрд╛ рдФрд░ рдЗрд╕рдХреЗ рд╡реНрдпрд╛рд╡рд╣рд╛рд░рд┐рдХ рдЕрдиреБрдкреНрд░рдпреЛрдЧ</a></li>
<li><a href="../hi435006/index.html">рдкрд░рдорд╛рдгреБ рд░рд┐рдПрдХреНрдЯрд░ рдХрд╣рд╛рдБ рдФрд░ рдХреИрд╕реЗ рдмрдирд╛рддреЗ рд╣реИрдВ</a></li>
<li><a href="../hi435010/index.html">рдбрд┐рдЬрд┐рдЯрд▓ рдЧреАрдд: рдкреНрд░реЛрдЧреНрд░рд╛рдорд┐рдВрдЧ рдФрд░ рдкреНрд░реЛрдЧреНрд░рд╛рдорд░ рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рдЧрд╛рдиреЗ рдФрд░ рдХреНрд▓рд┐рдк рдХрд╛ рдПрдХ рдореЗрдЧрд╛-рдЪрдпрди</a></li>
<li><a href="../hi435012/index.html">рдРрд▓рд┐рд╕ рдХреЗ рд▓рд┐рдП рдкрд╣рд▓рд╛ рд╡реАрдбрд┐рдпреЛ рдЧреЗрдо, рдпрд╛ рдЧреЗрдо рдХрдВрдЯреНрд░реЛрд▓рд░ рдХреЗ рд░реВрдк рдореЗрдВ рдЖрд╡рд╛рдЬ рд╕рд╣рд╛рдпрдХ</a></li>
<li><a href="../hi435014/index.html">рдбрд╛рд░реНрдЯ рдмрдирд╛рдо Node.js: HTTP рд╕рд░реНрд╡рд░ рдХрд╛рд░реНрдпрд╛рдиреНрд╡рдпрди рдкрд░ рдкреНрд░рджрд░реНрд╢рди рдХреА рддреБрд▓рдирд╛</a></li>
<li><a href="../hi435016/index.html">рд▓реИрд░реА рдПрд▓рд┐рд╕рди рдЯреЗрд╕реНрд▓рд╛ рдХреЗ рд▓рд┐рдП рдХреНрдпрд╛ рд▓рд╛рдПрдВрдЧреЗ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>