<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏾 🚗 🎗️ Android Permukaan 🖖🏿 🖖 ⁉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penafian 


 Artikel ini ditujukan untuk pengembang android pemula dengan sedikit pengalaman bekerja dengan video dan / atau kamera, terutama mereka y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android Permukaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480878/"><h2 id="diskleymer">  Penafian </h2><br><p>  Artikel ini ditujukan untuk pengembang android pemula dengan sedikit pengalaman bekerja dengan video dan / atau kamera, terutama mereka yang mulai menganalisis contoh-contoh <a href="https://github.com/google/grafika" rel="nofollow">grafika</a> dan yang merasa kesulitan, di sini kita akan melihat kode yang sama dengan deskripsi sederhana dari langkah-langkah dasar yang diilustrasikan oleh diagram negara. </p><br><p>  Mengapa kelas Surface diberikan di header?  Di android, banyak kelas memiliki kata <em>Surface</em> dalam namanya (Surface, SurfaceHolder, SurfaceTexture, SurfaceView, GLSurfaceView), mereka tidak terhubung oleh hierarki umum, namun, mereka dikombinasikan oleh logika tingkat rendah untuk bekerja dengan output gambar.  Tampaknya masuk akal bagi saya untuk menggunakannya dalam judul untuk menekankan upaya untuk mengungkapkan pekerjaan dengan bagian khusus dari SDK ini. </p><a name="habracut"></a><br><h2 id="primer-ispolzovaniya-s-raznym-api">  Contoh penggunaan dengan API yang berbeda </h2><br><p>  Mari kita coba menulis contoh berikut: <strong>kita akan mengambil pratinjau dari kamera, menayangkan gambar animasi di atasnya, menampilkan semuanya di layar dan, jika perlu, menuliskannya ke file.</strong>  Kode lengkapnya ada di <a href="https://github.com/tttzof351/AndroidSurfaceExample/" rel="nofollow">https://github.com/tttzof351/AndroidSurfaceExample/</a> </p><br><p>  Untuk tampilan, kami akan menggunakan <a href="https://developer.android.com/reference/android/opengl/GLSurfaceView" rel="nofollow">GLSurfaceView</a> , untuk merekam dengan kelas <a href="https://developer.android.com/reference/android/media/MediaCodec" rel="nofollow">MediaCodec</a> dan <a href="https://developer.android.com/reference/android/opengl/EGLSurface" rel="nofollow">EGLSurface</a> , dan berkomunikasi dengan kamera melalui <a href="https://developer.android.com/reference/android/hardware/camera2/package-summary" rel="nofollow">API V2</a> .  Skema umum kira-kira sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/9o/rc/o5/9orco54m0chpg_og4db_qppsrjm.png"></p><br><h2 id="nalozhenie-neskolkih-surface">  Overlay Permukaan Berganda </h2><br><p>  Permukaan sebenarnya adalah pegangan untuk area dalam memori yang perlu diisi dengan gambar.  Kemungkinan besar, kami membuatnya berusaha menampilkan sesuatu di layar atau dalam file, sehingga berfungsi seperti buffer untuk beberapa "proses" yang menghasilkan data. </p><br><p>  Untuk membuat overlay dari beberapa Surface, kita akan menggunakan OpenGL. <br>  Untuk melakukan ini, kita akan membuat dua tekstur eksternal persegi dan dapatkan dari Surface </p><br><p>  Dalam kode tersebut, akan terlihat seperti ini: </p><br><p>  <a href="" rel="nofollow">OpenGLExtarnalTexture.kt</a> </p><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> textures = IntArray(<span class="hljs-number"><span class="hljs-number">1</span></span>) GLES20.glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, textures, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> textureId = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">//    val textureWidth = ... val textureHeight = ... //  val surfaceTexture = SurfaceTexture(textureId) surfaceTexture.setDefaultBufferSize(textureWidth, textureHeight) //, surface  ""    val surface = Surface(surfaceTexture)</span></span></code> </pre> <br><p>  <strong>Koordinat XYZ</strong> </p><br><p>  Sekarang kita perlu memahami cara membuat dan mengatur tekstur, dan untuk ini kita harus ingat bagaimana struktur koordinat disusun dalam OpenGL: pusatnya bertepatan dengan pusat adegan (jendela), dan perbatasan dinormalisasi, mis. Dari -1 hingga 1. </p><br><p>  Dalam adegan ini, kami ingin menetapkan dua persegi panjang (pekerjaan ada di pesawat, jadi semua koordinat z diatur secara logis ke 0f) - merah kami akan menunjukkan satu di mana kami akan menempatkan pratinjau untuk kamera, dan warna biru untuk gambar animasi: </p><br><p>  Kami menuliskan koordinat kami secara eksplisit: </p><br><p><img src="https://habrastorage.org/webt/mu/fj/kr/mufjkrznafatofs4lsn-ywm_h7i.png"></p><br><pre> <code class="kotlin hljs">fullscreenTexture = floatArrayOf( <span class="hljs-comment"><span class="hljs-comment">// X, Y, Z -1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, -1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, ) smallTexture = floatArrayOf( // X, Y, Z 0.3f, 0.3f, 0.0f, 0.8f, 0.3f, 0.0f, 0.3f, 0.8f, 0.0f, 0.8f, 0.8f, 0.0f )</span></span></code> </pre> <br><p>  <strong>Koordinat UV</strong> </p><br><p>  Apakah ini cukup?  Ternyata tidak ada :( </p><br><p>  Tekstur adalah pemetaan gambar ke area adegan dan untuk membuatnya dengan benar, Anda perlu menentukan secara tepat di mana titik-titik dalam gambar akan jatuh di dalam area ini - untuk ini, OpenGL menggunakan koordinat <strong>UV</strong> - mereka keluar dari sudut kiri bawah dan memiliki batas dari 0 ke 1 untuk masing-masing kapak. </p><br><p>  Ini berfungsi sebagai berikut - kami akan mengatur koordinat <strong>UV</strong> untuk setiap titik di daerah kami dan akan mencari titik yang sesuai pada gambar, dengan asumsi bahwa lebar dan tingginya sama dengan 1. </p><br><p>  Pertimbangkan sebuah contoh - kita akan mengasumsikan bahwa kamera memberi kita gambar dalam keadaan terbalik dan terpantul, dan pada saat yang sama kita ingin menunjukkan hanya bagian kanan atas, mis. Ambil 0,8 pada garis lintang dan ketinggian gambar. </p><br><p>  Titik halus - pada tahap ini kita tidak tahu rasio aspek dari area pada layar - kita hanya memiliki kuadrat dalam koordinat relatif, yang akan mengisi seluruh adegan dan sesuai peregangan.  Jika kita membuat kamera layar penuh, maka ukuran relatif kita (2 di setiap sisi) akan meregang ke 1080x1920 konvensional.  Kami berasumsi bahwa kami mengatur dimensi adegan sedemikian sehingga rasio mereka akan sama dengan rasio kamera. <br>  Mari kita lihat ke mana koordinatnya pergi - titik kanan atas area kita (1, 1, 0) harus pergi ke koordinat UV (0, 0), yang kiri bawah di (0.8f, 0.8f), dll. </p><br><p><img src="https://habrastorage.org/webt/fk/ur/ig/fkurigpfo4l_hnl1fonbgj1dao0.png"></p><br><p>  Dengan demikian, kami memperoleh korespondensi XYZ dan UV: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// X, Y, Z, U, V -1.0f, -1.0f, 0.0f, 0.8f, 0.8f, 1.0f, -1.0f, 0.0f, 0.8f, 0.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.8f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f</span></span></code> </pre> <br><p>  Jika rasio aspek antara pratinjau dari kamera dan area pada layar awalnya bertepatan, maka jelas akan terus disimpan, karena dalam kasus kami, kami hanya dikalikan dengan 0,8f. <br>  Dan apa yang akan kita makan, kita akan menetapkan nilai lebih dari 1?  Bergantung pada pengaturan yang kami berikan ke OpenGL, kami akan mendapatkan poin dari beberapa bagian gambar.  Dalam contoh kita, baris terakhir akan diulangi sepanjang sumbu yang sesuai dan kita akan melihat artefak dalam bentuk "garis-garis" </p><br><p>  <strong>Intinya: jika kita ingin mengompres / memotong gambar sambil mempertahankan posisi area pada layar, maka koordinat UV adalah pilihan kita!</strong> </p><br><p>  <strong>Tetapkan koordinat untuk tekstur kami.</strong> </p><br><p><img src="https://habrastorage.org/webt/au/wp/zx/auwpzx9wgczhb79_4bbfu9nyk_a.png"></p><br><pre> <code class="kotlin hljs">fullscreenTexture = floatArrayOf( <span class="hljs-comment"><span class="hljs-comment">// X, Y, Z, U, V -1.0f, -1.0f, 0.0f, 1f, 0f, 1.0f, -1.0f, 0.0f, 0f, 0f, -1.0f, 1.0f, 0.0f, 1f, 1f, 1.0f, 1.0f, 0.0f, 0f, 1f ) smallTexture = floatArrayOf( // X, Y, Z, U, V 0.3f, 0.3f, 0.0f, 0f, 0f, 0.8f, 0.3f, 0.0f, 1f, 0f, 0.3f, 0.8f, 0.0f, 0f, 1f, 0.8f, 0.8f, 0.0f, 1f, 1f )</span></span></code> </pre> <br><p>  <strong>Shader</strong> </p><br><p>  Memiliki koordinat XYZ dan UV statis sangat tidak nyaman - misalnya, kita mungkin ingin memindahkan dan menskalakan tekstur kita dengan gerakan.  Untuk mengubahnya, kita akan membuat dua matriks untuk setiap tekstur: <strong>MVPMatrix</strong> dan <strong>TexMatrix</strong> untuk masing-masing untuk koordinat XYZ dan UV. </p><br><p>  Setiap OpenGL2 harus mengandung shader untuk menampilkan sesuatu di layar.  Tentu saja, ini bukan topik yang dapat diungkapkan dalam satu paragraf, namun, dalam kasus kami, mereka akan sepele, dan karena itu Anda dapat dengan cepat memahami apa yang mereka lakukan, tanpa banyak pengetahuan tentang materi. </p><br><p>  Pertama-tama, ada dua shader - vertex dan fragmen. </p><br><p>  Yang pertama (vertex) akan memproses simpul kita, yaitu, cukup gandakan koordinat XYZ / UV kita dengan matriks yang sesuai dan isi dengan variabel OpenGL <strong>gl_Position</strong> yang persis bertanggung jawab atas posisi akhir dari tekstur kita di layar. </p><br><p>  Yang kedua (fragmen) harus mengisi <strong>gl_FragColor dengan</strong> piksel gambar. </p><br><p>  Total yang kita miliki: variabel di dalam vertex shader kita harus mengisi kolom dengan data kita, yaitu: </p><br><ul><li>  MVPMatrix -&gt; <strong>uMVPMatrix</strong> </li><li>  <strong>TexMatrix -&gt; uTexMatrix</strong> </li><li>  koordinat XYZ vertex kami -&gt; <strong>aPosisi</strong> </li><li>  Koordinat UV -&gt; <strong>aTextureCoord</strong> </li></ul><br><p>  <strong>vTextureCoord</strong> - diperlukan untuk meneruskan data dari vertex shader ke fragment shader <br>  Di fragmen shader, kami mengambil koordinat UV yang dikonversi dan menggunakannya untuk menampilkan piksel gambar di area tekstur. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vertexShader = <span class="hljs-string"><span class="hljs-string">""" uniform mat4 uMVPMatrix; uniform mat4 uTexMatrix; attribute vec4 aPosition; attribute vec4 aTextureCoord; varying vec2 vTextureCoord; void main() { gl_Position = uMVPMatrix * aPosition; vTextureCoord = (uTexMatrix * aTextureCoord).xy; } """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fragmentShader = <span class="hljs-string"><span class="hljs-string">""" #extension GL_OES_EGL_image_external : require precision mediump float; varying vec2 vTextureCoord; uniform samplerExternalOES sTexture; void main() { gl_FragColor = texture2D(sTexture, vTextureCoord); } """</span></span></code> </pre> <br><p>  Untuk referensi, kami menunjukkan perbedaan antara jenis: </p><br><ul><li>  seragam - variabel jenis ini akan mempertahankan nilai selama panggilan berulang, kami menggunakan satu shader yang disebut berurutan untuk dua tekstur, jadi kami masih akan menimpanya dengan setiap rendering </li><li>  atribut - data jenis ini dibaca dari vertex buffer, perlu dimuat di setiap rendering </li><li>  bervariasi - diperlukan untuk mentransfer data dari vertex shader ke fragmen </li></ul><br><p>  Bagaimana cara melewatkan parameter ke shader?  Untuk melakukan ini, Anda harus terlebih dahulu mendapatkan id (pointer) dari variabel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aPositionHandle = GLES20.glGetAttribLocation(programId, <span class="hljs-string"><span class="hljs-string">"aPosition"</span></span>)</code> </pre> <br><p>  Sekarang untuk id ini Anda perlu memuat data: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//      floatbuffer val verticesBuffer = ByteBuffer.allocateDirect( fullscreenTexture.size * FLOAT_SIZE_BYTES ).order( ByteOrder.nativeOrder() ).asFloatBuffer() verticesBuffer.put(fullscreenTexture).position(0) /*    -  XYZ   0 .       id      ,     ,               - 5  - XYZUV,  4 - -   float */ verticesBuffer.position(0) GLES20.glVertexAttribPointer( aPositionHandle, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer )</span></span></code> </pre> <br><p>  <strong>Gambar langsung</strong> </p><br><p>  Setelah kami mengisi shader kami dengan semua data, kami harus meminta tekstur untuk memperbarui gambar, dan OpenGL untuk menggambar simpul kami: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { ... surfaceTexture.updateTexImage() GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) }</code> </pre> <br><p>  Dalam contoh kami, kami akan membagi pekerjaan dengan adegan OpenGL menjadi dua kelas - adegan dan tekstur langsung: </p><br><p>  <a href="https://github.com/tttzof351/AndroidSurfaceExample/blob/master/app/src/main/java/com/example/surfaces/helpers/OpenGLExternalTexture.kt/" rel="nofollow">OpenGLExternalTexture.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenGLExternalTexture</span></span></span></span>(verticesData: FloatArray, ...) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surfaceTexture: SurfaceTexture <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surface: Surface <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,    . } ... fun updateFrame(aPositionHandle: Int, ...) {...} // ,   fun release() {...} //   }</span></span></code> </pre> <br><p>  <a href="" rel="nofollow">OpenGLScene.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenGLScene</span></span></span></span>( sceneWidth: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, sceneHeight: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, ... ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullscreenTexture = OpenGLExternalTexture(...) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> smallTexture = OpenGLExternalTexture(..) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aPositionHandle: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,        . } fun updateFrame() { ... fullscreenTexture.updateFrame(aPositionHandle, ...) smallTexture.updateFrame(aPositionHandle, ...) } fun release() { fullscreenTexture.release() smallTexture.release() } }</span></span></code> </pre> <br><h2 id="statemachine--mashina-sostoyaniy--konechnyy-avtomat">  StateMachine / State Machine / State Machine </h2><br><p>  Semua API yang ingin kami gunakan dalam contoh kami pada dasarnya asinkron (well, mungkin dengan pengecualian Drawable animasi).  Kami akan membungkus panggilan semacam itu di StateMachines yang terpisah, suatu pendekatan di mana status sistem secara eksplisit ditulis, dan transisi di antara mereka terjadi melalui pengiriman peristiwa. </p><br><p>  Mari kita lihat contoh sederhana bagaimana ini akan terlihat, misalkan kita memiliki kode ini: </p><br><pre> <code class="kotlin hljs">imageView.setOnClickListener { loadImage { bitmap -&gt; imageView.setBitmap(bitmap) } }</code> </pre> <br><p>  Secara umum, semuanya baik - baik dan indah, tetapi kami akan mencoba menulis ulang dengan cara berikut: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiMachine = UIMachine() imageView.setOnClickListener { uiMachine.send(Click(imageView)) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIMachine</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: State = WaitClick() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Action</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = transition(action) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Action</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitingClick &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Click -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitBitmap(imageView = action.imageView) loadImage { send(BitmapIsReady(bitmap = it)) } } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitingBitmap &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> BitmapIsReady -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitClick state.imageView.setImageBitmap(action.bitmap) } } } } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> WaitingClick : State() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaitingBitmap</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> imageView: ImageView): State() } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Click</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> imageView: ImageView): Action() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BitmapIsReady</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bitmap: Bitmap): Action() }</code> </pre> <br><p>  Di satu sisi, ternyata <strong><em>jauh</em></strong> lebih <strong><em>banyak</em></strong> , namun, beberapa properti implisit tetapi berguna muncul: pengulangan berulang sekarang tidak mengarah pada <strong>beban yang</strong> tidak perlu dimulai <strong>,</strong> meskipun tidak jelas dengan volume seperti itu, tapi kami menyingkirkan panggilan balik bersarang, yang akan kita gunakan nanti , dan gaya penulisan metode transisi memungkinkan Anda untuk membangun diagram transisi yang mengulang kode satu-satu, yaitu dalam kasus kami: </p><br><p><img src="https://habrastorage.org/webt/-n/2p/mq/-n2pmqdwfsps932me0wfsrvyj_q.png"><br>  Gray menunjukkan transisi yang tidak ditulis secara eksplisit.  Seringkali mereka dicatat atau dilempar pengecualian, menganggapnya sebagai tanda kesalahan.  Untuk saat ini, kami akan berhasil mengabaikannya dan di masa depan kami tidak akan menunjuk ke diagram. </p><br><p>  Buat antarmuka dasar untuk StateMachine: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateMachine</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S : State, A : Action</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: S <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><h2 id="glsurfaceview">  GLSurfaceView </h2><br><p>  Cara termudah untuk menampilkan sesuatu menggunakan OpenGL di android adalah kelas GLSurfaceView - secara otomatis membuat aliran baru untuk menggambar, yang dimulai / dihentikan menggunakan metode GLSurfaceView :: onResume / onPause. </p><br><p>  Untuk kesederhanaan, kami akan menetapkan pandangan kami ke rasio 16: 9. </p><br><p>  Proses rendering itu sendiri dipindahkan ke callback terpisah - GLSurfaceView.Renderer. <br>  Membungkusnya di StateMachine, kita mendapatkan sesuatu seperti ini: </p><br><p>  <a href="" rel="nofollow">GLSurfaceMachine.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLSurfaceMachine</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateMachine</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLSurfaceState, GLSurfaceAction</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: GLSurfaceState = WaitCreate() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLSurfaceAction</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = transition(action) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLSurfaceAction</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitCreate &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Create -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitSurfaceReady(...) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.glSurfaceView?.setRenderer(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> :Renderer { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, width: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, height: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> send(SurfaceReady(width, height, gl)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, config: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EGLConfig</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDrawFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { send(Draw) } }) } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitSurfaceReady &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SurfaceReady -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openGLScene = OpenGLScene(width, height) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = DrawingAvailable(openGLScene, ...) } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DrawingAvailable &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Draw -&gt; { state.openGLScene.updateFrame() } state !<span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitCreate &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Stop -&gt; { state.uiHolder.glSurfaceView?.onPause() state.uiHolder.openGLScene?.release() <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitSurfaceReady() } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitSurfaceReady &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Start -&gt; { state.uiHolder.glSurfaceView?.onResume() } } } } ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> glSurfaceMachine = GLSurfaceMachine() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> glSurfaceView = findViewById(R.id.gl_view) glSurfaceView.layoutParams.width = width glSurfaceView.layoutParams.height = ((<span class="hljs-number"><span class="hljs-number">16f</span></span>/<span class="hljs-number"><span class="hljs-number">9f</span></span>) * width).toInt() glSurfaceMachine.send(GLSurfaceAction.Create(glSurfaceView, ...))</code> </pre> <br><p>  Mari menggambar diagram transisi: </p><br><p><img src="https://habrastorage.org/webt/mx/5i/xb/mx5ixbssfaqci1ktsmumu94jbz0.png"></p><br><p>  Sekarang kode kami mencoba untuk menampilkan sesuatu di layar, meskipun untuk saat ini ia melakukannya dengan buruk - kami tidak akan melihat apa pun selain layar hitam.  Tidak sulit untuk menebak faktanya adalah bahwa tidak ada yang masuk ke Surface kami sekarang karena kami belum mengimplementasikan sumber gambar.  Mari kita perbaiki ini - pertama, buat CanvasDrawable: </p><br><p>  <a href="" rel="nofollow">CanvasDrawable.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanvasDrawable</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Drawable</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundPaint = Paint().apply { ... } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> circlePaint = Paint().apply { ... } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Canvas</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { canvas.drawRect(bounds, backgroundPaint) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> width = bounds.width() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> height = bounds.height() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> posX = ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> posY = ... canvas.drawCircle(posX, posY, <span class="hljs-number"><span class="hljs-number">0.1f</span></span> * width, circlePaint) } ... }</code> </pre> <br><p>  Sekarang kita dapat melengkapi bagian dalam GLSurfaceMachine dengan merender canvasDrawable pada kanvas yang menyediakan permukaan tekstur yang sesuai: </p><br><pre> <code class="kotlin hljs">state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DrawingAvailable &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Draw -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> canvasDrawable = state.canvasDrawable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> smallTexture = state.openGLScene.smallTexture <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bounds = canvasDrawable.bounds <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> canvas = smallSurface.lockCanvas(bounds) canvasDrawable.draw(canvas) smallSurface.unlockCanvasAndPost(canvas) state.openGLScene.updateFrame() }</code> </pre> <br><p>  Setelah itu kita akan melihat sesuatu seperti: </p><br><p><img src="https://habrastorage.org/webt/vo/4r/-d/vo4r-dgpynjvynvxdomy2fezp9y.png"></p><br><h2 id="camera-api-v2">  API Kamera V2 </h2><br><p>  Kotak hijau tentu saja menyenangkan dan menarik, tetapi inilah saatnya untuk mencoba membawa pratinjau dari kamera ke permukaan yang tersisa. </p><br><p>  Mari kita menuliskan langkah-langkah untuk bekerja dengan kamera: </p><br><ul><li>  Kami sedang menunggu izin.  Kami akan memiliki status ini <strong>WaitingStart</strong> </li><li>  Kami mendapatkan contoh manajer kamera, kami menemukan id logis (biasanya ada dua dari mereka - untuk bagian belakang dan depan, dan yang logis adalah karena kamera dapat terdiri dari banyak sensor pada perangkat modern) dari kamera yang diinginkan, pilih ukuran yang sesuai, buka kamera, kami dapatkan cameraDevice.  Status <strong>WaitingOpen</strong> </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> manager = getSystemService(Context.CAMERA_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CameraManager <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultCameraId: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultSize: Size? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cameraId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> manager.cameraIdList) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> chars = manager.getCameraCharacteristics(cameraId) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> facing = chars.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(CameraCharacteristics.LENS_FACING) ?: -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (facing == LENS_FACING_BACK) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> confMap = chars.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>( CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sizes = confMap?.getOutputSizes(SurfaceTexture::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resultSize</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">findSize</span></span></span></span>(sizes) resultCameraId = cameraId <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } resultCameraId?.let { cameraId -&gt; manager.openCamera(cameraId, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraDevice.StateCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOpened</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(camera: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CameraDevice</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//Success open camera ... } }) }</span></span></code> </pre> <br><ul><li>  Memiliki kamera terbuka, kita beralih untuk mengajukan Permukaan untuk menampilkan gambar.  Status <strong>Menunggu Permukaan</strong> </li><li>  Sekarang kita memiliki CameraDevice, Surface, kita perlu membuka sesi sehingga kamera akhirnya mulai mengirimkan data.  Status <strong>Tunggu Sesi</strong> </li></ul><br><pre> <code class="kotlin hljs">cameraDevice.createCaptureSession( arrayListOf(surface), <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraCaptureSession.StateCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(session: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CameraCaptureSession</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { send(CameraAction.SessionReady(session)) } }, handler )</code> </pre> <br><ul><li>  Sekarang kita dapat menangkap pratinjau.  Status MulaiPreview </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> request = cameraDevice.createCaptureRequest( CameraDevice.TEMPLATE_PREVIEW ).apply { addTarget(surface) } session.setRepeatingRequest( request.build(), <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraCaptureSession.CaptureCallback() {...} handler )</code> </pre> <br><p>  Kami menggambarkan skema kami saat ini: </p><br><p>  <a href="" rel="nofollow">CameraMachine.kt</a> </p><br><p><img src="https://habrastorage.org/webt/i6/tj/q1/i6tjq12xls77hudocvpnt0m6qy0.png"></p><br><p><img src="https://habrastorage.org/webt/6w/ad/fp/6wadfpayduldvtqwcrjggkoce6y.png"></p><br><h2 id="mediacodec">  Mediacodec </h2><br><p>  MediaCodec adalah kelas untuk pekerjaan tingkat rendah dengan codec sistem, secara umum, API-nya adalah sekumpulan buffer input / output (terdengar, sayangnya, lebih mudah daripada bekerja dengannya) ke dalam mana data (mentah atau dikodekan tergantung pada mode operasi encoder / decoder) ditempatkan, dan pada output kita mendapatkan hasilnya. </p><br><p>  Terlepas dari kenyataan bahwa ByteBuffer biasanya bertindak sebagai buffer, Anda dapat menggunakan Surface untuk bekerja dengan video, yang akan mengembalikan MediaCodec :: createInputSurface kepada kami, di atasnya kami harus menggambar bingkai yang ingin kami rekam (dengan pendekatan ini, dokumentasi menjanjikan kami pengkodean lebih cepat melalui penggunaan gpu ) </p><br><p>  Nah, sekarang kita perlu belajar cara menggambar Surface yang ada yang kita buat di GLSurfaceMachine on Surface dari MediaCodec.  Penting untuk diingat: Permukaan adalah objek yang menciptakan konsumen, dan secara umum tidak mungkin untuk membaca sesuatu darinya, mis. Tidak ada metode bersyarat getBitmap / readImage / ... </p><br><p>  Kami akan melanjutkan sebagai berikut: berdasarkan konteks GL yang ada, kami akan membuat yang baru yang akan memiliki memori yang sama dengannya, dan oleh karena itu kami dapat menggunakannya untuk menggunakan id-shniks dari tekstur yang kami buat sebelumnya di sana.  Kemudian menggunakan konteks GL baru dan Permukaan dari MediaCodec, kita akan membuat EGLSurface - penyangga di luar layar tempat kita juga dapat membuat kelas OpenGLScene kita.  Kemudian, pada setiap frame rendering, kita akan mencoba menulis frame ke file secara paralel. </p><br><p>  EGL berarti antarmuka interaksi API OpenGL dengan subsistem jendela platform, kami akan mencuri pekerjaan dari grafika.  Saya tidak akan menggambarkan conveyor (EncoderHelper) dengan MediaCodec secara langsung, saya hanya akan memberikan skema terakhir interaksi antara komponen-komponen kami: </p><br><p>  <a href="" rel="nofollow">EncoderMachine.kt</a> <br>  <a href="" rel="nofollow">EncoderHelper.kt</a> </p><br><p><img src="https://habrastorage.org/webt/d1/gc/kf/d1gckfqligsrwynmmkq_bb2yzoy.png"></p><br><h2 id="itog">  Hasilnya: </h2><br><ul><li>  Bekerja dengan video membutuhkan setidaknya keterampilan dasar dalam OpenGL </li><li>  Android Media API adalah level yang cukup rendah, yang memberikan fleksibilitas, tetapi terkadang membuat Anda menulis kode sedikit lebih banyak dari yang Anda inginkan </li><li>  API Asinkron dapat dibungkus dalam StateMachines </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480878/">https://habr.com/ru/post/id480878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480866/index.html">Era baru pengembangan web atau "semuanya sudah ada"</a></li>
<li><a href="../id480870/index.html">Hasil dekade</a></li>
<li><a href="../id480872/index.html">Intel menutup lubang keamanan yang dilaporkan enam bulan lalu</a></li>
<li><a href="../id480874/index.html">Studi tentang neutrino menyebabkan penemuan yang tidak terduga dalam matematika</a></li>
<li><a href="../id480876/index.html">Kami membersihkan Dock dan membuat aplikasi tanpa xCode</a></li>
<li><a href="../id480884/index.html">GUI Python dalam 5 menit</a></li>
<li><a href="../id480888/index.html">DIY Coroutine. Bagian 1. Generator Malas</a></li>
<li><a href="../id480890/index.html">Hasil survei tentang penggunaan panel Express</a></li>
<li><a href="../id480892/index.html">Internet balon</a></li>
<li><a href="../id480900/index.html">Bawa kembali bayiku! (Kisah N.-F)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>