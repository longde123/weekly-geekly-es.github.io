<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•û üó∫Ô∏è ‚ìÇÔ∏è Desenvolvimento de um conversor buck no STM32F334: princ√≠pio de opera√ß√£o, c√°lculos, prototipagem üê∂ üë©üèΩ‚Äçüî¨ üëäüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos meus dois √∫ltimos artigos, falei sobre o m√≥dulo de energia e a placa de controle baseados no microcontrolador STM32F334R8T6, criados especificamen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolvimento de um conversor buck no STM32F334: princ√≠pio de opera√ß√£o, c√°lculos, prototipagem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432778/">  Nos meus dois √∫ltimos artigos, falei sobre o m√≥dulo de energia e a placa de controle baseados no microcontrolador STM32F334R8T6, criados especificamente para a implementa√ß√£o de sistemas de controle para conversores de energia e acionamentos el√©tricos.  Tamb√©m foi considerado um exemplo de um conversor CC / CA, que era uma demonstra√ß√£o, n√£o uma constru√ß√£o conclu√≠da.  Agora √© hora de fazer algo simples, mas √∫til e, o mais importante, conclu√≠do. <br><br>  A maioria das perguntas relacionadas ao projeto e √† eletr√¥nica de pot√™ncia est√° relacionada a topologias espec√≠ficas: algu√©m est√° interessado em aprender o algoritmo de controle do PFC, algu√©m quer aprender a construir uma meia ponte LLC, mas a topologia mais popular √©, sem d√∫vida, uma vantagem.  Afinal, o conversor buck (tamb√©m conhecido como conversor buck) √© o principal dos projetos mais interessantes: este √© o driver para l√¢mpadas LED, a base do controlador MPPT para pain√©is solares, carregadores e muito mais. <br><br>  A rede possui muitas informa√ß√µes sobre buck, incluindo planilhas de dados, mas est√° dispersa e eu pessoalmente n√£o encontrei material que descreva em detalhes o processo de cria√ß√£o de um conversor buck com controle digital.  √â hora de consertar isso.  Praticamente n√£o h√° matem√°tica, a explica√ß√£o est√° "nos dedos", por isso ser√° interessante para todos que est√£o de alguma forma conectados √† eletr√¥nica. <br><br> <a href=""><img src="https://habrastorage.org/webt/j4/jp/fv/j4jpfvx10zexln6bwiv8gd6dbkc.jpeg"></a> <br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  Primeiro, voc√™ precisa entender o que queremos obter no final e que introdu√ß√£o temos.  A topologia do buck √© reduzida, ou seja, permite construir um conversor de tens√£o de redu√ß√£o.  Como voc√™ ver√° mais adiante, a tens√£o na sa√≠da do conversor buck depende quase linearmente da tens√£o na entrada; portanto, √© necess√°rio adicionar feedback.  Hoje vou falar sobre o feedback de tens√£o simples, que √© o mais intuitivo e permitir√° que voc√™ entenda o princ√≠pio de opera√ß√£o, enquanto esse feedback √© suficiente para voc√™ implementar a maioria das tarefas. <br><br>  No final do artigo, obteremos uma fonte de tens√£o estabilizada em funcionamento de acordo com a topologia ‚Äúbuck s√≠ncrona‚Äù, operando em uma frequ√™ncia bastante alta com controle digital, implementada no STM32F334R8T6 usando PWM de alta resolu√ß√£o (HRPWM).  A faixa de tens√£o de entrada √© de 15 a 60V, a tens√£o de sa√≠da √© de 12V e a corrente m√°xima de sa√≠da √© 2A. <br><br><h2>  Cap√≠tulo 1. O princ√≠pio da topologia </h2><br>  Come√ßarei a contar a partir do b√°sico e melhorarei gradualmente nosso conversor, conforme  "Buck s√≠ncrono" √© uma vers√£o da vers√£o aprimorada com maior efici√™ncia e complexidade de controle.  A vers√£o b√°sica da topologia que voc√™ provavelmente usou √© a seguinte: <br><br><img src="https://habrastorage.org/webt/of/mv/yq/ofmvyqyaxkystxgvsiiauznkfqs.png"><br><br>  Essa topologia √© usada em conversores de voltagem de baixa pot√™ncia, por exemplo, para alimentar circuitos digitais e outros dispositivos de baixa pot√™ncia.  A redu√ß√£o de CC / CC que voc√™ usa em seus dispositivos provavelmente √© implementada em microcircuitos, de acordo com esta topologia.  Um exemplo desse chip √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LMR16006</a> . <br><br>  O princ√≠pio de opera√ß√£o deste circuito √© muito simples, um sinal PWM √© fornecido ao transistor VT1, o trabalho em si √© dividido em 2 etapas, que alternam uma ap√≥s a outra: <br><br><ul><li>  <b>O est√°gio de armazenamento de energia no circuito LC.</b>  Nesta fase, o transistor VT1 est√° aberto e a corrente flui atrav√©s do transistor para a carga, armazenando simultaneamente energia no capacitor do indutor e de sa√≠da: <br><br><img src="https://habrastorage.org/webt/xb/x9/fi/xbx9fi3blibz8mc6t-unq7qeaau.png"></li><li>  <b>Est√°gio de descarga.</b>  Nesta fase, o transistor VT1 fecha e ent√£o a divers√£o come√ßa.  Acelerador - √© algo que acumula energia se um potencial √© aplicado a ele (VT1 aberto) e o distribui se o potencial desaparecer (VT1 √© fechado).  Ao mesmo tempo, ele busca n√£o apenas fornecer energia, mas salvar o valor da corrente e sua dire√ß√£o; portanto, para usar essa propriedade, √© necess√°rio adicionar o diodo VD1 para fechar o circuito, porque a corrente flui apenas em um circuito fechado: <br><br><img src="https://habrastorage.org/webt/fm/qr/z2/fmqrz2uboiwpztct_hjh9stsgws.png"></li></ul><br>  Quando me familiarizei com essa topologia na 6¬™ √† 7¬™ classe, n√£o entendi imediatamente por que o diodo n√£o conduz corrente no 1¬∫ est√°gio, agora parece comum, mas acho que vale a pena mencionar.  Quando o VT1 est√° aberto, o potencial + VIN, por exemplo, + 20V, √© aplicado ao c√°todo do diodo VD1 e o potencial terra, respectivamente, no √¢nodo do diodo.  Para que a corrente flua atrav√©s do diodo, deve ser exatamente o oposto: o potencial no √¢nodo deve ser maior que o potencial no c√°todo; portanto, no buck-e, na fase de armazenamento de energia, o diodo √© "fechado".  No est√°gio de descarga, o diodo j√° fecha o circuito, o potencial + VIN n√£o age em seu c√°todo e n√£o o "bloqueia".  Espero ter explicado claramente. <br><br>  Ent√£o voc√™ deve ter uma pergunta: ‚ÄúE qual voltagem estar√° na sa√≠da, se aplicarmos 20V √† entrada?‚Äù.  Como sempre, tudo √© simples: <br><br><img src="https://habrastorage.org/webt/hv/oz/g6/hvozg6kwwhf1nekotraxpmdo2gc.png"><br><br>  Como pode ser visto na f√≥rmula, a tens√£o de sa√≠da depende linearmente do fator de servi√ßo do sinal PWM que fornecemos ao transistor VT1.  Se algu√©m n√£o souber ou esquecer o ‚Äúfator de servi√ßo‚Äù, essa √© a raz√£o entre o tempo em que o transistor est√° no estado aberto e a dura√ß√£o do per√≠odo.  Este coeficiente pode assumir um valor de 0 a 1 ou de 0 a 100%.  Al√©m disso, operaremos com essa figura em particular ao controlar o conversor, mas, para entender a ess√™ncia, vamos substituir essa rela√ß√£o na f√≥rmula: <br><br><img src="https://habrastorage.org/webt/c5/ij/ax/c5ijaxxjgvlviopshgx_uumfvh4.png"><br><br>  A frequ√™ncia de opera√ß√£o do conversor buck √© constante e √© selecionada durante o projeto, n√£o muda durante a opera√ß√£o e, portanto, o per√≠odo (T) √© constante.  Acontece que a tens√£o de sa√≠da depende diretamente de duas quantidades f√≠sicas: <br><br><ul><li>  a partir do momento em que abrimos o transistor superior (VT1) - quanto mais aberto, mais energia tem tempo para acumular no filtro LC e, consequentemente, a tens√£o de sa√≠da √© maior; </li><li>  da tens√£o de entrada, por exemplo, se fixarmos o preenchimento em 50% e mudarmos o Vin de 20 para 40V, a tens√£o de sa√≠da tamb√©m mudar√° de 10 para 20V. </li></ul><br>  Penso que o quadro geral e o princ√≠pio do trabalho come√ßaram a aparecer em voc√™, vamos corrigi-lo agora e examinar os oscilogramas reais e verificar essa propor√ß√£o na pr√°tica.  Montei um layout de fanfarr√£o carregado com um LED de 10 W.  Usei 3 canais do oscilosc√≥pio, inclu√≠dos nos seguintes pontos: <br><br><img src="https://habrastorage.org/webt/xo/pd/by/xopdbyfozm6wgh3fgz8pdeuojum.png"><br><br>  <b>Experi√™ncia n¬∫ 1 - Tens√£o de entrada (Vin) constante 20V, o ciclo de trabalho muda</b> <br><br><ul><li>  Vin = 20V, D = 25%, Vout = D * Vin = 0,25 * 20V = 5V <br><br><img src="https://habrastorage.org/webt/i3/5k/p5/i35kp5uw2m0tsofihsydvow6xws.png"></li><li>  Vin = 20V, D = 50%, Vout = D * Vin = 0,5 * 20V = 10V <br><br><img src="https://habrastorage.org/webt/lg/zt/bb/lgztbbg8ztwdqwwni9zfgzrdyg4.png"></li></ul><br>  Como voc√™ pode ver nas formas de onda, a rela√ß√£o entre a tens√£o de sa√≠da e o ciclo de servi√ßo est√° correta.  Obviamente, esse foi um experimento "idealizado"; na realidade, a tens√£o de entrada n√£o √© est√°vel e flutua em uma faixa bastante ampla.  Vamos agora ver qual ser√° a depend√™ncia da tens√£o de entrada em um enchimento fixo. <br><br>  <b>Experi√™ncia n¬∫ 2 - A tens√£o de entrada (Vin) est√° mudando, o ciclo de trabalho √© constante e igual a 50%</b> <br><br><ul><li>  Vin = 15V, D = 50%, Vout = D * Vin = 0,5 * 15V = 7,5V <br><br><img src="https://habrastorage.org/webt/er/at/_k/erat_kgnli3usl6pf2gnvs4tgky.png"></li><li>  Vin = 20V, D = 50%, Vout = D * Vin = 0,5 * 20V = 10V <br><br><img src="https://habrastorage.org/webt/u7/_1/ek/u7_1ekajdvcyhccqmttgiiiqbzy.png"></li><li>  Vin = 30V, D = 50%, Vout = D * Vin = 0,5 * 30V = 15V <br><br><img src="https://habrastorage.org/webt/ak/1z/na/ak1znaux-gyaj1o6uxx49ewcisu.png"></li></ul><br>  Agora vimos na pr√°tica que a tens√£o de sa√≠da tamb√©m depende linearmente da tens√£o de entrada em um ciclo de trabalho fixo.  Voc√™ j√° entende como isso estabilizar√° a sa√≠da?  O princ√≠pio de estabiliza√ß√£o √© simples como a pr√≥pria f√≥rmula - Vout √© 12V e constante, podemos alterar o ciclo de trabalho com a ajuda de um microcontrolador; portanto, se Vin aumentar, a tens√£o de sa√≠da tamb√©m aumenta e, neste momento, diminu√≠mos o fator de trabalho at√© que se torne 12V novamente.  Assim, quando o Vin diminui, come√ßamos a aumentar o ciclo de trabalho at√© que a tens√£o Vout se torne 12V. <br><br>  O que mais eu gostaria de chamar a aten√ß√£o na se√ß√£o te√≥rica ... Ah, sim!  Certamente voc√™ est√° se perguntando como um PWM com uma amplitude de 20V depois que um transistor acabou se transformando em uma tens√£o constante com ondula√ß√µes escassas?  De fato, se colocarmos a sonda vermelha do oscilosc√≥pio na fonte do transistor VT1, a sonda verde ap√≥s o filtro LC, veremos a seguinte imagem: <br><br><img src="https://habrastorage.org/webt/pe/3o/ox/pe3ooxj5ghth4p2ibxtpubt-rg8.png"><br><br>  Voc√™ pode ver como o filtro LC ‚Äúlubrifica‚Äù a tens√£o alternada em tens√£o constante, mas o importante √© que a energia armazenada na indut√¢ncia e na capacit√¢ncia n√£o pode ser consumida instantaneamente, portanto, a tens√£o n√£o pode mudar instantaneamente.  Entendemos que no momento em que o PWM na frente do indutor se torna 0V, a tens√£o de sa√≠da √© fornecida pela energia armazenada no filtro, que n√£o absorve imediatamente e √© suficiente para manter a tens√£o no momento em que o VT1 fecha.  Est√° tudo nos dedos, √© claro, se √© interessante aprofundar, ent√£o, como sempre, aconselho <b>B. Yu.</b>  <b>Semenova "Eletr√¥nica de Pot√™ncia: do simples ao complexo"</b> , h√° um cap√≠tulo inteiro sobre buck (helic√≥ptero). <br><br><h3>  A luta pela efici√™ncia </h3><br>  Como escrevi um pouco antes, essa era a vers√£o b√°sica da topologia.  Sua principal desvantagem s√£o as altas perdas no diodo de travamento.  Qual √© a corrente nos sistemas simples que operam no MK e no CPLD?  Geralmente dentro de 1A, √†s vezes 2A, se houver algum tipo de exibi√ß√£o TFT.  Nesse caso, a perda, mesmo ao usar um diodo Schottky, ser√° de 0,4V * 2A = 0,8 watts.  Em princ√≠pio, √© aceit√°vel dissipar tanto no pacote SMA / SMB sem problemas, embora com uma tens√£o de 3,3V e 2A, uma perda de 0,8V ainda seja 12% de efici√™ncia! <br><br>  Agora imagine o caso em que a corrente que temos √© 20A.  Pode ser um controlador MPPT, um grande sistema de energia FPGA e muito mais.  Nesse caso, a perda ser√° de 0,4V * 20A = 8 W!  O que isso significa?  Por exemplo, no caso do MPPT, voc√™ ter√° menos energia armazenada na bateria; no caso da energia do FPGA, ser√£o 8 watts adicionais de calor, que devem ser dissipados em algum lugar e, em ambos os casos, √© sem d√∫vida uma perda de efici√™ncia geral.  O que pode ser feito?  E vamos substituir o diodo VD1 por outro Mosfet de canal N e obter este circuito: <br><br><img src="https://habrastorage.org/webt/nb/om/7b/nbom7baf8horcmhuevpeeelxkoc.png"><br><br>  Agora, o transistor VT2 atua como um diodo, ou seja, ele conduz corrente quando o VT1 √© fechado.  O diodo, que estava na vers√£o b√°sica, n√£o exigia controle, agora somos obrigados a pagar um canal de controle adicional com um sinal PWM para melhorar o desempenho. <br><br>  Primeiro, vamos calcular quanto reduzimos as perdas.  A resist√™ncia do canal de um mosfet moderno √© de v√°rios megaohms.  Como exemplo, vamos pegar um transistor do meu m√≥dulo de pot√™ncia, sobre o qual falei em artigos anteriores - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IPP083N10N5AKSA1</a> com uma resist√™ncia de canal de 8,3 mOhm.  Temos perdas est√°ticas iguais a 0,0083 * 20A * 20A = 3,32 watts.  Obviamente, haver√° perdas din√¢micas, que com um driver adequadamente projetado n√£o ser√£o mais do que 20%, ou seja, as perdas totais para n√≥s ser√£o de 4 watts.  Conclu√≠mos que a transi√ß√£o de um buck convencional para um s√≠ncrono pode reduzir pela metade a perda do diodo. <br><br>  Agora, vejamos o gerenciamento mais complicado.  Como j√° entendemos, o diodo de bloqueio estava conduzindo corrente quando o VT1 foi fechado.  Da√≠ resulta que o VT2 deve ser fechado quando o VT1 est√° aberto e, portanto, o VT2 est√° aberto quando o VT1 est√° fechado.  Se for mais simples, os transistores funcionam alternadamente: um est√° aberto ou o outro, se os dois transistores estiverem abertos, haver√° uma corrente de passagem, porque  eles est√£o interconectados entre VIN e GND.  Vamos ver qual deve ser o sinal, onde o "canal amarelo" √© o transistor VT1 e o "canal verde" √© o transistor VT2: <br><br><img src="https://habrastorage.org/webt/wu/bc/mo/wubcmogqwk-__w6eroszeyozsv0.png"><br><br>  Como voc√™ pode ver, se o "1" l√≥gico estiver definido no canal amarelo (no VT1), nesse momento o "0" l√≥gico dever√° ser definido no canal verde (no VT2).  Conseguimos que o VT1 bombeie energia para o filtro LC, e o VT2 fecha o circuito no est√°gio de descarga. <br><br>  H√° mais um ponto que voc√™ j√° ouviu ou leu acima - <b>atrav√©s da corrente</b> .  O fato √© que um transistor real, e n√£o ideal (mosfet), tem uma certa capacit√¢ncia no port√£o, ou seja, na realidade n√£o passa instantaneamente do log.0 para o log.1, e a energia no transistor n√£o se dissolve instantaneamente, resultando em transistores por um curto per√≠odo de tempo no momento da troca, ambos podem estar abertos.  Isso pode levar, na melhor das hip√≥teses, a maiores perdas, o que significa aquecimento e, na pior, a uma bab√°, porque  corrente de passagem √© um curto-circuito comum (curto-circuito).  Para evitar isso, √© introduzido um atraso ou o chamado tempo morto entre desligar um transistor e ligar outro.  √â assim: <br><br><img src="https://habrastorage.org/webt/u8/wg/if/u8wgifnybpzrkjg1gfxua-w0gye.png"><br><br>  Eu acho que voc√™ percebeu que h√° uma pequena lacuna no limite de comuta√ß√£o de sinal.  Eu o instalei conscientemente grande (cerca de 3%) para que voc√™ possa v√™-lo, na realidade √© muito menor.  Em geral, o tempo morto (doravante dt) √© definido o mais curto poss√≠vel, mas ao mesmo tempo suficiente para permitir que os transistores se fechem.  Pode ser calculado, ou pode ser selecionado empiricamente. Pessoalmente, acho que essa e aquela op√ß√£o s√£o normais, mas o Jedi barbudo provavelmente lhe dir√°: "√â necess√°rio consider√°-lo, mas √© melhor model√°-lo!"  Isso certamente est√° correto, mas decida por si mesmo - se voc√™ n√£o for muito pregui√ßoso, modele no LTspice levando em considera√ß√£o indut√¢ncias e capacit√¢ncias dispersas de condutores e componentes. <br><br>  Para o suporte deste artigo, defino dt como ~ 100 ns (na verdade, 104).  Meu m√≥dulo permite que voc√™ o instale muito menos, porque  o driver √© aplicado com muita rigor, mas com certeza muitos de voc√™s criar√£o seu layout sem o meu m√≥dulo, o que significa que provavelmente haver√° ranho.  Para n√£o ficar preso devido ao ranho, deixarei o dt com uma margem e, se voc√™ tiver uma fia√ß√£o normal na placa, poder√° reduzi-la - ent√£o, no cap√≠tulo do c√≥digo, voc√™ ver√° como, por enquanto, veremos se h√° realmente dt: <br><br><img src="https://habrastorage.org/webt/b-/tm/ft/b-tmftfkzmq7xezwdbbd67gaxf4.png"><br><br>  Pode-se ver que dt dura 2,5 divis√µes e cada divis√£o √© de 40 ns, o que significa que a dura√ß√£o √© de ~ 100 ns, como pretendido.  Espero que voc√™ entenda por que o dt √© necess√°rio, quanto tempo deve durar e como o conversor funciona de acordo com a topologia buck.  Se voc√™ n√£o entende, ent√£o, como de costume, s√£o aceitas perguntas nos coment√°rios, PM e correio, enquanto pare√ßo responder a todos. <br><br><h2>  Cap√≠tulo 2. O C√°lculo dos Componentes Principais </h2><br>  Nesta parte do artigo, mostrarei como calcular r√°pida e facilmente os principais componentes de pot√™ncia de um conversor s√≠ncrono, a saber: indutor, capacitores de entrada e sa√≠da, transistores. <br><br>  <u>Deixe-me lembr√°-lo dos dados de entrada:</u> <br><br><ul><li>  Tens√£o de entrada: 15 ... 30V </li><li>  Tens√£o de sa√≠da: 12V </li><li>  Corrente nominal de sa√≠da: 2A </li><li>  Frequ√™ncia de comuta√ß√£o: 100 kHz </li></ul><br>  A tens√£o de sa√≠da de 12V √© selecionada porque  Eu pretendo usar um LED de 12V 20W como carga, que ficou √† m√£o e √© uma carga muito √≥bvia.  Antecipando as perguntas dos "especialistas" nos coment√°rios - sim, eu sei que o LED precisa de estabiliza√ß√£o de corrente, mas ent√£o fazemos um estabilizador de tens√£o e o LED √© apenas uma carga. <br><br>  A tens√£o de entrada √© selecionada no bulldozer, voc√™ pode fazer de 15 a 60V; portanto, se voc√™ estiver interessado em uma faixa diferente, poder√° calcular o valor dos componentes para si mesmo.  Uma corrente nominal de 2A √© escolhida para obter a pot√™ncia de sa√≠da de 12V * 2A = 24 W, ou seja, um pouco mais do que o necess√°rio para o LED.  O pr√≥prio LED a 12V consome cerca de 1,82 ... 1,9A. <br><br>  O par√¢metro mais interessante permaneceu - a frequ√™ncia de opera√ß√£o do conversor.  O que deveria ser?  Voc√™ ter√° que responder aqui voc√™ mesmo, no meu caso, √© 100 kHz.  A escolha √© baseada em dois pontos: <br><br><ul><li>  Um aumento na frequ√™ncia leva a uma diminui√ß√£o da indut√¢ncia necess√°ria do indutor, capacitor de entrada e sa√≠da.  Simplificando - com o aumento da frequ√™ncia, as dimens√µes do dispositivo diminuem.  Com frequ√™ncia decrescente, as dimens√µes aumentam. </li><li>  Uma diminui√ß√£o na frequ√™ncia leva a um aumento na efici√™ncia, j√° que  perdas din√¢micas quando os transistores chaveadores s√£o reduzidos.  Aumentar a frequ√™ncia aumenta o componente din√¢mico dos transistores e, consequentemente, reduz a efici√™ncia. </li></ul><br>  Agora n√£o vou discutir a escolha da frequ√™ncia, basta assumir que 100 kHz.  Depois de mostrar a metodologia de c√°lculo, retornaremos a essa pergunta, porque  de acordo com as f√≥rmulas, a depend√™ncia das classifica√ß√µes dos principais componentes na frequ√™ncia de opera√ß√£o ser√° mais claramente vis√≠vel. <br><br>  <b>Etapa 1. Escolhendo transistores</b> <br><br>  Estaremos interessados ‚Äã‚Äãprincipalmente em tr√™s par√¢metros: a tens√£o m√°xima "fonte de drenagem", a resist√™ncia do canal no estado aberto e a capacit√¢ncia do port√£o.  O potencial total da fonte de tens√£o (Vin) √© aplicado ao transistor, e tamb√©m h√° surtos no momento da comuta√ß√£o.  Voc√™ tem duas op√ß√µes: pegue o transistor VT1 e VT2 com uma margem de tens√£o ou a hist√≥ria do amortecedor RC no VT2.  No meu caso, o m√≥dulo de pot√™ncia possui transistores de 100V e, com uma entrada de 30V, essa √© uma enorme margem de tens√£o, at√© 60V foi suficiente para ficar sem amortecedores e proteger o transistor de quebra. <br><br>  Resist√™ncia do canal - quanto menor, melhor, mas existe uma MAS.  Com uma diminui√ß√£o na resist√™ncia do canal, reduzimos as perdas est√°ticas (I <sup>2</sup> * R), mas a tecnologia √© tal que a capacit√¢ncia da porta aumenta, e isso leva a um aumento nas perdas din√¢micas.  Voc√™ precisa encontrar um meio termo entre "resist√™ncia do canal" e "capacidade do obturador".  Para tens√µes de at√© 100V, aconselho que voc√™ preste aten√ß√£o aos transistores da s√©rie Infineon OptiMOS, j√° observe as altas tens√µes por pesquisa param√©trica ou mesmo para transistores IGBT.  Estes √∫ltimos tamb√©m s√£o suportados pelo meu m√≥dulo de energia e n√£o exigem nenhuma altera√ß√£o no driver. <br><br>  <b>Etapa 2. O c√°lculo da indut√¢ncia do indutor</b> <br><br>  √â necess√°rio calcular o valor m√≠nimo da indut√¢ncia, o que permitir√° que nosso conversor dc / dc funcione no modo de corrente cont√≠nua (L <sub>min</sub> ): <br><br><img src="https://habrastorage.org/webt/mj/np/-j/mjnp-jzmvy7qfodji_da3ryjeya.png"><br><br>  Em termos de vari√°veis, acho que tudo est√° claro, exceto - k <sub>ind</sub> .  Essas s√£o correntes de ondula√ß√£o permitidas no indutor, geralmente escolhem um valor de 20 ... 50%, mas eu quase sempre defino 30%.  Quanto menor a ondula√ß√£o da corrente, mais longe estaremos da borda de satura√ß√£o do n√∫cleo no qual o indutor √© enrolado, mas, como pode ser visto na f√≥rmula, √© necess√°ria uma grande indut√¢ncia do indutor. <br><br>  Agora calculamos o valor m√≠nimo da indut√¢ncia, que ser√° necess√°rio para os meus dados de entrada, a ondula√ß√£o que colocarei 30% como escrevi acima: <br><br><img src="https://habrastorage.org/webt/ri/t9/2h/rit92hfsubagcqaozaebmcl7alw.png"><br><br>  Deve-se entender que essa √© a indut√¢ncia m√≠nima necess√°ria para o conversor buck operar no modo de correntes inextric√°veis, mas novamente h√° uma nuance.  No processo de aumentar a corrente atuando no enrolamento, a permeabilidade do n√∫cleo e a indut√¢ncia do indutor SEM corrente e Com corrente s√£o um pouco diferentes, a depend√™ncia √© diferente para diferentes materiais.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar a situa√ß√£o em que, com um aumento da corrente no indutor, a indut√¢ncia diminui abaixo de L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e dc / dc n√£o entra no modo de corrente de ruptura, √© necess√°rio aumentar a indut√¢ncia um pouco, ou seja, adicionar algumas voltas extras durante o enrolamento. Um aumento na indut√¢ncia de 10 a 15% ser√° suficiente para o material de Kool Mu, e meu estrangulamento estar√° nele. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 3. C√°lculo e fabrica√ß√£o do indutor</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gostaria de descrever este procedimento na se√ß√£o "prototipagem", mas a etapa de c√°lculo da indut√¢ncia permaneceria menos clara para voc√™, e provavelmente perdi as imagens interessantes, por isso descreverei tudo aqui. Para a fabrica√ß√£o do acelerador, levarei o acelerador R26 / 14/11 (R √© o anel e os n√∫meros s√£o as dimens√µes) do material Kool Mu com permeabilidade 60, voc√™ pode fazer o download da documenta√ß√£o e comprar aqui -</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lepkos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/kc/mp/e1/kcmpe19wpeprrdiz0qznmnefxyk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora voc√™ precisa calcular quantas voltas e qual fio precisa enrolar. Vamos come√ßar com o n√∫mero de turnos, talvez. Existe um par√¢metro t√£o conveniente na documenta√ß√£o para o n√∫cleo - A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que √© igual a 75 nH / turno </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aqui com cuidado - vira um quadrado! Para encontrar a indut√¢ncia do n√∫cleo, multiplique </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LA</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pelo n√∫mero de voltas no quadrado. A partir daqui, a f√≥rmula para encontrar o n√∫mero de voltas √© assim: </font></font><br><br><img src="https://habrastorage.org/webt/ls/dn/zr/lsdnzrojp7ab0aijmv46pxllh0q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para obter a indut√¢ncia m√≠nima necess√°ria, √© necess√°rio dar 40 voltas, mas como j√° discutimos, √© necess√°rio aumentar levemente a indut√¢ncia, vamos adicionar 3 voltas. Damos o anel e giramos 43 voltas, conseguimos um acelerador:</font></font><br><br><img src="https://habrastorage.org/webt/un/5e/ij/un5eijbi_ksbefygjbn4pkrckli.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, por uma quest√£o de interesse, calculamos qual indut√¢ncia deve resultar: </font></font><br><br><img src="https://habrastorage.org/webt/rj/yl/mm/rjylmmkynrrleoebfmoilq1oyzm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E, para confiabilidade, verificamos a indut√¢ncia do indutor com uma pin√ßa: </font></font><br><br><img src="https://habrastorage.org/webt/tm/ze/qj/tmzeqjuzno3yp3tkpkcmy8jozoa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">137 ŒºH, √≥timo! Resultados convergente, um erro de ¬± 8% a A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vale mencionar apenas que, se voc√™ n√£o puder medir a indut√¢ncia, n√£o compre n√∫cleos para aliexpress, no ChiD, computador, engenheiro eletr√¥nico e outros "restaurantes" - h√° uma chance de obter o n√∫cleo de outro material ou com a permeabilidade incorreta, mas com a marca√ß√£o correta - verificado. Sem a capacidade de medir a indut√¢ncia, voc√™ n√£o poder√° verificar A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e poder√° se atormentar bastante em busca da causa do "babakh" do seu conversor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso levanta uma quest√£o razo√°vel: ‚Äúteremos n√∫cleo suficiente e suas dimens√µes? Talvez fosse necess√°rio mais? ". Para o material Kool Mu, o limite de indu√ß√£o magn√©tica √© de 0,5 T; na pr√°tica, √© melhor n√£o ultrapassar o limite acima de 0,45 T sem claramente necess√°rio. Acontece que o enrolamento no n√∫cleo n√£o precisa criar indu√ß√£o em cada ponto do n√∫cleo mais de 0,45 T, portanto verificamos: </font></font><br><br><img src="https://habrastorage.org/webt/1w/vf/me/1wvfmenl-jqsxqbnhsj-itnzgoe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode ver, o valor da indu√ß√£o magn√©tica de 0,06 T √© muito menor que o limite de 0,5 T. Duas conclus√µes podem ser tiradas disso: em primeiro lugar, o acelerador n√£o entrar√° em satura√ß√£o; em segundo lugar, o n√∫cleo √© muito grande e √© poderoso usar um anel muito menor. Peguei o anel R26 simplesmente porque tenho a caixa inteira, n√£o h√° outro significado secreto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resta determinar qual se√ß√£o do fio levar para o indutor. Em primeiro lugar, eu recomendo fortemente que voc√™ n√£o pegue um fio com um di√¢metro superior a 1 ... 1,2 mm em frequ√™ncias t√£o altas, porque o efeito de pele j√° tem um efeito significativo e reduz a se√ß√£o transversal efetiva. Em segundo lugar, a densidade de corrente no fio deve ser selecionada com base nas condi√ß√µes e pot√™ncia de resfriamento. Em pot√™ncias baixas (at√© 10-20 W), √© poss√≠vel estabelecer com seguran√ßa uma densidade de corrente de 8 a 10 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mesmo sem fluxo de ar. Em pot√™ncias de at√© v√°rios quilowatts, √© melhor estabelecer a densidade de corrente na faixa de 5 ... 6 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e em pot√™ncias de 10 kW em diante, ser√° razo√°vel reduzir a densidade de corrente para 3 ... 4 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na ponta dos meus dedos, havia um fio envernizado com um di√¢metro de 0,8 mm. Sua se√ß√£o transversal, respectivamente, √© de ~ 0,5 mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em uma corrente de 2A, obtemos uma densidade de corrente no enrolamento de cerca de 4 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Eu poderia usar um fio com metade da se√ß√£o transversal, mas meu n√∫cleo √© grande o suficiente, para que um fio de se√ß√£o transversal maior se encaixe sem problemas. Ao otimizar o seu dispositivo, voc√™ primeiro precisa contar e, em seguida, adquirir o fio da se√ß√£o transversal desejada, para obter as dimens√µes ideais do indutor. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 4. C√°lculo do capacitor de sa√≠da</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, como no caso da indut√¢ncia, consideraremos o valor m√≠nimo da capacit√¢ncia que deve ser instalada no filtro LC na sa√≠da do conversor buck. Assim, se voc√™ instalar mais, ser√° melhor e depois veja o porqu√™. Vamos calcular a capacidade: </font></font><br><br><img src="https://habrastorage.org/webt/qn/_v/sf/qn_vsfifikijddrrspohgtod9a8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© claro, a capacidade tamb√©m deve ser colocada com alguma margem, especialmente se voc√™ usar apenas cer√¢mica na sa√≠da, porque sua capacidade √© bastante reduzida dependendo da tens√£o aplicada a ele. Tamb√©m vale a pena prestar aten√ß√£o √† depend√™ncia de pulsa√ß√µes - o </font><sub><font style="vertical-align: inherit;">pulso</font></sub><font style="vertical-align: inherit;"> V vari√°vel</font></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este √© o valor m√°ximo da ondula√ß√£o na sa√≠da, ou seja, idealmente, com uma capacit√¢ncia de 147,8 ŒºF, a amplitude da ondula√ß√£o ser√° de 0,2V, ou seja, a tens√£o de sa√≠da flutuar√° na faixa de 11,9 ... 12,1V. Deseja reduzir a ondula√ß√£o? Em seguida, reduza-os na f√≥rmula e o valor da capacidade resultante aumentar√° de acordo. Obviamente, voc√™ n√£o ter√° uma fonte de alimenta√ß√£o de laborat√≥rio simplesmente aumentando a capacidade de sa√≠da. Tamb√©m √© necess√°rio levar em considera√ß√£o a necessidade de uma VHS baixa, para isso eles costumam colocar 1-2 eletr√≥litos em paralelo e pendurar cer√¢micas v√°rias microfarads paralelas a eles com um diel√©trico X7R, de prefer√™ncia. Se o or√ßamento permitir, √© poss√≠vel substituir o capacitor eletrol√≠tico pelo pol√≠mero de t√¢ntalo (como na GPU) e, portanto, a cer√¢mica n√£o √© necess√°ria, pois eles t√™m uma pequena ESR. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considera√ß√µes sobre frequ√™ncia</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, como eu disse, retornaremos √† quest√£o de escolher a frequ√™ncia de opera√ß√£o do conversor. </font><font style="vertical-align: inherit;">Deixe-me dividir as conclus√µes em alguns pensamentos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como voc√™ v√™ na f√≥rmula, a frequ√™ncia aparece, quanto maior a frequ√™ncia operacional, menor a indut√¢ncia do indutor ser√° necess√°ria e menos voltas ter√£o que ser enroladas - economizamos cobre e simplificamos a fabrica√ß√£o de produtos de enrolamento </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A indut√¢ncia e o n√∫mero de voltas est√£o presentes na f√≥rmula para calcular a indu√ß√£o magn√©tica, embora, como voc√™ se lembra, a indut√¢ncia tenha uma depend√™ncia quadr√°tica das voltas, o que significa que quando o n√∫mero de voltas √© reduzido em 2 vezes, a indut√¢ncia diminui em 4 vezes. </font><font style="vertical-align: inherit;">Da√≠ resulta que, com frequ√™ncia crescente, a indut√¢ncia e o valor da indu√ß√£o magn√©tica diminuem, o que significa que um n√∫cleo menor pode ser usado, ou seja, reduzimos as dimens√µes</font></font></li><li>      ,     ‚Äî     ,     ,    .  ! </li><li>   ‚Ä¶  ,              .          buck-  mosfet-  200   .    ( )   ?     GaN     </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acho que, a partir dessas teses, ficou claro para voc√™ o que a frequ√™ncia de comuta√ß√£o afeta, agora voc√™ precisa aprender como encontrar a ‚Äúm√©dia de ouro‚Äù entre as perdas nos transistores e o tamanho do dispositivo. </font><font style="vertical-align: inherit;">Em um dos artigos a seguir, ensinarei a otimizar a frequ√™ncia de opera√ß√£o para obter a m√°xima efici√™ncia, o principal √© n√£o esquecer que eu faria isso.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cap√≠tulo 3. Montando um Layout do Conversor Buck </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, a parte mais entediante, mas importante, acabou, agora o hardware e o c√≥digo desaparecer√£o. Vamos montar um layout no qual implementaremos c√°lculos te√≥ricos. Para fazer isso, voc√™ precisar√° de dois m√≥dulos sobre os quais falei nos artigos anteriores: o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√≥dulo de energia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√≥dulo de controle no STM32F334</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Voc√™ tamb√©m pode montar uma meia ponte de qualquer lixo improvisado do tipo IR2110 em uma placa de ensaio e usar qualquer MK como controle: STM32-Discovery, LaunchPad, Arduino e apenas adaptar a l√≥gica do trabalho e do c√≥digo ao seu MK favorito, nada ser√° complicado se voc√™ entendeu nos dois primeiros cap√≠tulos como o conversor buck funciona.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos tornar nosso diagrama mais realista, adicionando os valores de todos os componentes a ele e refletir corretamente o n√∫mero de capacitores, al√©m de observar qual parte do meu m√≥dulo de pot√™ncia pode realizar:</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/bo/qw/hx/boqwhxzou-myasxcamvspvq_oac.png"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode ver no diagrama, o m√≥dulo j√° cont√©m uma meia ponte (dois transistores) para implementar um buck s√≠ncrono e um capacitor de entrada, a prop√≥sito, ele est√° no m√≥dulo com uma margem enorme - existem 3 eletr√≥litos de 1000 uF e 100V cada, isso √© suficiente para montar facilmente um buck para 500 -800 watts Resta adicionar um estrangulamento, que j√° fabricamos e capacitamos para sa√≠da, este √∫ltimo tamb√©m a prop√≥sito com uma margem, porque Eu encontrei apenas 4700 uF 25V para baixa voltagem, mas eles s√£o algum tipo de chin√™s, ent√£o decidi paralelizar alguns. De fato, existem 470 uF suficientes l√°, mas eu simplesmente n√£o tive essa ninharia na vers√£o de sa√≠da. Acontece que este design:</font></font><br><br><img src="https://habrastorage.org/webt/sh/_r/ku/sh_rkup3otnnyiokil-egegoena.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como mencionado anteriormente, um poderoso LED de 20 W √© usado como carga. </font><font style="vertical-align: inherit;">N√£o sei quanta luz brilha e n√£o √© muito interessante, mas consome apenas 21 ... 22 W a 12 V para a qual meu conversor buck foi projetado. </font><font style="vertical-align: inherit;">O pr√≥prio LED revestiu o KPT-8 e parafusou-o no radiador, √© claro que n√£o √© suficiente, mas dura de 5 a 7 minutos sem problemas (aquece at√© +40 ... 50 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C) e n√£o preciso mais. </font><font style="vertical-align: inherit;">Conectamos 2 sinais HRPWM, GND do m√≥dulo de controle e, por meio do divisor, conectamos a sa√≠da buck ao ADC, como resultado, temos um suporte:</font></font><br><br><img src="https://habrastorage.org/webt/dl/ll/9v/dlll9v0povwnn86na34l1z1nvtc.jpeg"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cap√≠tulo 4. Gravando Software e Iniciando o Conversor </font></font></h2><br>  Agora, temos tudo o que precisamos para come√ßar a escrever c√≥digo e revitalizar nosso conversor buck.  Primeiro, vejamos a pinagem do microcontrolador STM32F334R8T6, localizado no m√≥dulo de controle: <br><br><img src="https://habrastorage.org/webt/bw/0i/ao/bw0iaobhw935ug8xttkq_q73uio.png"><br><br>  Agora entendemos quais pinos do microcontrolador ser√£o usados.  No pr√≥prio m√≥dulo, eu preciso de apenas 1 em cada 5 canais para controlar a unidade de energia, usaremos o canal "A".  Este canal, como todo o resto, possui 2 sa√≠das de PWM de alta precis√£o (HRPWM), 1 entrada de erro (n√£o o usamos), GND para combinar o terra das placas e 2 canais ADC (usaremos apenas um para tens√£o). <br><br>  <b>Um pouco sobre HRPWM</b> <br><br>  Nas extens√µes do segmento da Internet em idioma russo, quase n√£o encontrei nenhum material de treinamento sobre HRPWM e n√£o encontrei nenhum material sobre como trabalhar com HRPWM baseado em microcontroladores STM32, e este √© um perif√©rico muito √∫til. <br><br>  N√£o vou me aprofundar na teoria dessa periferia dentro da estrutura deste artigo; portanto, descreverei a ess√™ncia.  HRPWM ou PWM de alta resolu√ß√£o √© o nosso m√≥dulo PWM habitual, que possui uma resolu√ß√£o aumentada para definir o fator de servi√ßo e, al√©m disso, geralmente possui configura√ß√µes mais flex√≠veis. <br><br> <a href=""><img src="https://habrastorage.org/webt/mx/kb/ct/mxkbctdf9dhgu2ssfv1briuowmm.png"></a> <br><br><ul><li>  O microcontrolador STM32F334R8T6 possui 10 canais HRPWM, que s√£o combinados em 5 grupos de 2 canais.  Esses 2 canais dentro do grupo podem trabalhar de forma independente e formar um par complementar - precisamos do √∫ltimo; </li><li>  Dentro do par complementar entre 2 sinais PWM, √© poss√≠vel instalar o tempo morto do hardware para prote√ß√£o contra a corrente de passagem; </li><li>  Todos os 10 canais s√£o cronometrados a partir de um timer - Master timer, para que todos sejam sincronizados um com o outro e voc√™ n√£o precise configurar manualmente uma cadeia de temporizadores.  Basta ligar o mestre e os temporizadores A ... E para obter um tempo a partir dele; </li><li>  A frequ√™ncia em HRPWM √© dobrada, ou seja, em uma frequ√™ncia central de 72 MHz, em HRPWM √© de 144 MHz ap√≥s um multiplicador adicional (x2) com PLL.  Isso torna poss√≠vel controlar os conversores a uma frequ√™ncia de centenas de kHz; </li><li>  Muitas configura√ß√µes para o controle PWM, por exemplo, juntamente com a capacidade de vincular a gera√ß√£o do PWM ao in√≠cio e ao final do per√≠odo, existem mais 4 eventos configur√°veis ‚Äã‚Äã(comp) que permitem converter o PWM para 0 ou 1 em qualquer ponto do per√≠odo que n√£o seja o in√≠cio / fim do per√≠odo; </li><li>  Existem modos para topologias espec√≠ficas, por exemplo, modo push-pull, que permitem implementar muitas topologias push-pull. </li></ul><br>  E isso √© apenas uma pequena parte dos recursos. No diagrama de dispositivos HRPWM, voc√™ pode ver os recursos de sincroniza√ß√£o com v√°rios eventos, DACs, comparadores incorporados ao MK e, juntamente com este diagrama de blocos, h√° muitas outras possibilidades documentadas. <br><br>  Resta a √∫ltima pergunta que precisa ser abordada - ‚Äúpor que esse PWM √© alto?‚Äù.  Para fazer isso, considere um exemplo simples.  Imagine que decidimos usar o MK sem HRPWM, digamos STM32F103C8T6, que tamb√©m funciona a uma frequ√™ncia de 72 MHz.  Precisamos controlar a meia ponte a uma frequ√™ncia de 70 kHz, consideramos que etapa de regula√ß√£o podemos obter: 72 000 000/1025 etapas = 70 243 Hz.  Sim, temos 1025 etapas e, ao ajustar, podemos alterar a tens√£o de sa√≠da com uma etapa te√≥rica de 1/1025 = ~ 0,1%.  Agora, pegamos o STM32F334, com uma frequ√™ncia de clock de 144 MHz e uma largura de deslocamento do timer de 32 bits, obtemos a frequ√™ncia equivalente a 144 MHz * 32 = 4,608 GHz.  Para quem ficou assustado e duvidou da figura: <br><br><img src="https://habrastorage.org/webt/7n/ot/o2/7noto2gpr5ht4fnztxskohfhx-m.png"><br><br>  N√£o, essa n√£o √© uma frequ√™ncia operacional, √© uma frequ√™ncia equivalente.  O que isso nos d√°?  Tomamos a frequ√™ncia equivalente de 4 608 000 000 Hz / 70 300 Hz = 65 535 passos.  Agora podemos ajustar a tens√£o (ou corrente) na sa√≠da em incrementos de 1/65 535 = ~ 0,001%, ou seja, 100 vezes mais preciso! <br><br>  E agora vamos faz√™-lo - temos uma frequ√™ncia de 700 kHz, o que √© normal para um dinheirinho multif√°sico, por exemplo.  O F103 ter√° 72.000.000 Hz / 700.000 Hz = 102 etapas, o que permite obter 1% de regula√ß√£o na melhor das hip√≥teses, mas isso √© 1% para servi√ßo, ou seja, na realidade, com tantas etapas, voc√™ ter√° a tens√£o flutuando na sa√≠da como se estivesse estabilizando e n√£o realmente.  Enquanto no F334 o n√∫mero de etapas ser√° aproximadamente 6500, o que ainda permite criar um regulador de tens√£o ou corrente muito preciso.  Conclu√≠mos que a resolu√ß√£o (etapa) da configura√ß√£o do ciclo de trabalho √© muito mais alta / com mais freq√º√™ncia do que com um MK convencional com um m√≥dulo PWM padr√£o interno. <br><br>  <b>Configura√ß√£o do sistema de rel√≥gio</b> <br><br>  Eu usei o TrueSTUDIO como o ambiente de desenvolvimento neste artigo, porque √© gratuito, n√£o √© t√£o miser√°vel quanto Keil ou IAR <s>, sim, conte-me sobre seu maravilhoso depurador</s> , plataforma cruzada e talvez a melhor solu√ß√£o para iniciantes e n√£o apenas.  No final do artigo, haver√° um arquivo com o projeto especificamente para este IDE.  N√£o vou lhe dizer como criar e configurar um projeto, apenas deixarei um link para o v√≠deo, onde tudo √© mostrado em detalhes - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">assista</a> . <br><br>  Depois de criar um projeto e piscar o LED, voc√™ precisa configurar o sistema de clock, a partir de 8 MHz, aumentar a frequ√™ncia para 72 MHz e aplicar no n√∫cleo e, em seguida, ajustar o divisor para reduzir a frequ√™ncia fornecida ao ADC: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartInitClock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;CR |= RCC_CR_HSEON; <span class="hljs-comment"><span class="hljs-comment">// Enable HSE while (!(RCC-&gt;CR &amp; RCC_CR_HSERDY)); FLASH-&gt;ACR |= FLASH_ACR_LATENCY_1; RCC-&gt;CFGR |= RCC_CFGR_PLLMUL9; // PLL mult x9 RCC-&gt;CFGR |= RCC_CFGR_PLLSRC; // Source HSE RCC-&gt;CFGR2 |= RCC_CFGR2_ADCPRE12_DIV10; // ADC source AHB/10 RCC-&gt;CR |= RCC_CR_PLLON; while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0){} RCC-&gt;CFGR &amp;= ~RCC_CFGR_SW; RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; // Select source SYSCLK = PLL while((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {} // Wait PLL }</span></span></code> </pre> <br>  Aqui, eu acho que o algoritmo de ajuste √© o seguinte: <i>ele muda para quartzo externo (HSE) -&gt; esperamos quando a transi√ß√£o √© conclu√≠da e o sinalizador pronto √© definido -&gt; enviamos o sinal do quartzo para a entrada PLL -&gt; multiplicamos 8 MHz por 9 -&gt; dividimos a frequ√™ncia por 72 MHz por 10 para registrar o ADC -&gt; ativar PLL -&gt; aguardar at√© que acenda e definir o sinalizador pronto -&gt; enviar um sinal do PLL para o barramento e n√∫cleo do sistema -&gt; aguardar at√© que a chave seja conclu√≠da -&gt; conclu√≠da.</i> <br><br>  <b>Configura√ß√£o HRPWM</b> <br><br>  Aqui tudo √© um pouco mais complicado, porque  Este m√≥dulo possui muitas funcionalidades, v√°rias configura√ß√µes e a quantidade de documenta√ß√£o √© muito grande, mas √© um sinal de menos e, ao mesmo tempo, mais - voc√™ precisa pagar pela flexibilidade. <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN;</code> </pre><br>  Voc√™ precisa especificar que o HRTIM tenha o clock da PLL, o multiplicador x2 j√° est√° ativado por padr√£o.  Em seguida, simplesmente ligamos o rel√≥gio para o HRTIM, eis o primeiro recurso - pois entendemos que o timer recebe o rel√≥gio da PLL, mas o APB2.  Isso n√£o √© totalmente l√≥gico, mas √© facilmente pesquisado no arquivo com CMSIS ou na documenta√ß√£o. <br><br><pre> <code class="cpp hljs"> RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; <span class="hljs-comment"><span class="hljs-comment">// Alternative PP GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; // Very high speed GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; GPIOA-&gt;AFR[1] |= 0xDD; // PA8 and PA9 - AF13</span></span></code> </pre><br>  PA8 e PA9 s√£o a sa√≠da do Timer A, que no meu m√≥dulo vai para o canal n¬∫ 1, que voc√™ pode ver no diagrama e na pinagem.  As pernas s√£o configuradas como push-pull com uma fun√ß√£o alternativa; o n√∫mero da fun√ß√£o em si para as duas pernas √© o 13¬∫.  Tamb√©m √© importante sintonizar a frequ√™ncia GPIO m√°xima; caso contr√°rio, haver√° um bloqueio incompreens√≠vel do sinal frontal e de queda, o que √© extremamente cr√≠tico para a eletr√¥nica de pot√™ncia. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET);</code> </pre><br>  Antes de come√ßar, voc√™ precisa calibrar o timer, porque  Funciona com atrasos m√≠nimos e aguarde o sinalizador pronto. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].PERxR = PeriodTimerA; <span class="hljs-comment"><span class="hljs-comment">// Period for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Duty for timer A</span></span></code> </pre><br>  Isso √© flexibilidade.  Primeiro, podemos definir nossa pr√≥pria frequ√™ncia para cada timer A ... E, aqui simplesmente registramos o per√≠odo do nosso PWM.  Em segundo lugar, por padr√£o, temos o alinhamento do PWM no in√≠cio do per√≠odo, ou seja, o sinal passa para o log.1 no in√≠cio de um novo per√≠odo e agora precisamos escolher quando ele retornar√° ao log.0, nesse caso, pelo comparador n¬∫ 1, ou seja, Eu pergunto nele essencialmente o fator dever. <br><br>  Por exemplo, voc√™ pode converter o PWM n√£o no in√≠cio do per√≠odo, mas pelo comparador n¬∫ 1 e retornar ao log.0 pelo comparador n¬∫ 2 e, assim, mover o hardware da fase. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK;</span></span></code> </pre><br>  Nesta fase, habilitamos o tempo morto e configuramos, em princ√≠pio, os coment√°rios cont√™m todas as f√≥rmulas, tamb√©m podem ser encontrados no manual de refer√™ncia.  TD com uma dura√ß√£o de ~ 100 ns que voc√™ j√° viu na forma de onda no cap√≠tulo te√≥rico deste artigo.  O tempo morto pode ser definido separadamente na borda e no decl√≠nio do sinal.  A prop√≥sito, [0] √© o timer A, respectivamente [1] √© o timer B e assim por diante. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2;</span></span></code> </pre><br>  Para mim, este n√£o foi o momento mais √≥bvio.  A linha inferior √© - quero garantir que, durante 10% da dura√ß√£o do per√≠odo do timer A, seja gerado um evento que desencadeie a convers√£o ADC e me√ßa o sinal de feedback.  Por que 10%?  Simplesmente, idealmente, a medi√ß√£o n√£o deve ocorrer no momento da transi√ß√£o do PWM de 0 para 1 ou vice-versa, porque  neste momento na unidade de energia, existem transit√≥rios e interfer√™ncias, mas n√£o precisamos medi-los.  Portanto, 10% no meu caso √© ideal, porque  na sa√≠da de 12V e 30V, a tens√£o de entrada do fator de servi√ßo n√£o cair√° para 10% e o momento da troca do transistor n√£o corresponder√° exatamente √† medi√ß√£o ADC. <br><br>  Agora voc√™ precisa examinar o sistema de comunica√ß√£o de eventos entre o HRTIM e o ADC: <br><br><img src="https://habrastorage.org/webt/r7/p6/g2/r7p6g2w3zcs-vrrsvzeev7uhwbc.png"><br><br>  Na primeira linha, escolhemos quando o comparador ser√° acionado, no meu caso, √© 10% do per√≠odo do timer A. Em seguida, selecionamos um acionador espec√≠fico no ADC que entrar√° em contato com o MK, temos acesso ao 1¬∫ ou 3¬∫.  Agora, ele simplesmente indica qual evento enviar√° o sinal para o ADC, no meu caso, √© o comparador n¬∫ 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN;</span></span></code> </pre><br>  E o acorde final!  Permitimos que o HRTIM produza sinais do Timer A para o nosso GPIO.  Agora, selecionamos o modo, acontece sem fim (eu tenho), mas acontece que o timer √© ativado por um per√≠odo e depois disso precisa ser reiniciado.  Em seguida, defina o per√≠odo para o timer mestre e ligue-o como o √∫ltimo passo, ele come√ßa a registrar os temporizadores do canal e o sinal PWM aparece na sa√≠da. <br><br>  Era uma fun√ß√£o de ajuste, resta fazer uma fun√ß√£o que definir√° o fator de servi√ßo; √© com ele que trabalharemos ao criar o controlador: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDutyTimerA</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duty)</span></span></span><span class="hljs-function"> </span></span>{ HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].CMP1xR = duty; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Listando configura√ß√µes de fun√ß√µes e definindo o ciclo de servi√ßo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// f = 102,4 kHz #define PeriodTimerA ((uint16_t)45000) void InitHRPWM (void) { RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN; /************************************************ * Setting GPIO ***********************************************/ RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; // Alternative PP GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; // Very high speed GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; // PA8 and PA9 - AF13 GPIOA-&gt;AFR[1] |= 0xDD; /************************************************ * Setting timer A ***********************************************/ HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; while ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET); // Period for timer A HRTIM1-&gt;sTimerxRegs[0].PERxR = PeriodTimerA; // Duty for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK; // Event forces the output to active state for TA1 HRTIM1-&gt;sTimerxRegs[0].SETx1R |= HRTIM_SET1R_PER; // Event forces the output to inactive state for TA1 HRTIM1-&gt;sTimerxRegs[0].RSTx1R |= HRTIM_RST1R_CMP1; /************************************************ * ADC trigger intialization (with CMP2 event) ************************************************/ // Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2; /************************************************ * HRTIM start ***********************************************/ // Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN; } void SetDutyTimerA (uint16_t duty) { HRTIM1-&gt;sTimerxRegs[0].CMP1xR = duty; }</span></span></code> </pre><br></div></div><br>  Agora vamos descobrir se estamos seguindo o caminho certo.  Na fun√ß√£o <i>principal</i> , inicialize a configura√ß√£o HRTIM e defina o ciclo de servi√ßo, por exemplo, 22500. Com uma tens√£o de entrada de 20V e um per√≠odo de 45000, nosso ciclo de trabalho ser√° de 50% e a sa√≠da ser√° de cerca de 10V.  Isso n√£o √© suficiente para expandir o LED para cheio, mas deve acender e entenderemos se a se√ß√£o de energia est√° funcionando, est√° tudo bem com dt e assim por diante.  Comecei tudo na primeira vez: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HTLbf9aMAGs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Voc√™ pode ver que todos os c√°lculos te√≥ricos anteriores foram confirmados.  Com um fator de servi√ßo fixo de 50%, a tens√£o de sa√≠da foi simplesmente dividida por 2: 20V -&gt; 10V, 22V -&gt; 11V, 18V -&gt; 9V.  Agora vamos tornar a tens√£o de sa√≠da est√°vel e independente da entrada, ou seja, adicionar feedback. <br><br>  <b>ADC e ajuste do controlador</b> <br><br>  Muito j√° foi escrito sobre os ADCs do STM32 antes de mim, apenas me refiro √† configura√ß√£o do gatilho associado ao comparador HRTIM.  Vou falar brevemente sobre as configura√ß√µes restantes da ADC.  Examinamos a fun√ß√£o de inicializa√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitBasicADC</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;AHBENR |= RCC_AHBENR_ADC12EN; RCC-&gt;AHBENR |= RCC_AHBENR_GPIOCEN; <span class="hljs-comment"><span class="hljs-comment">/************************************************ * Calibration ***********************************************/</span></span> ADC2-&gt;CR &amp;= ~ADC_CR_ADVREGEN; ADC2-&gt;CR |= ADC_CR_ADVREGEN_0; <span class="hljs-comment"><span class="hljs-comment">// Vref enable Delay(10); ADC2-&gt;CR &amp;= ~ADC_CR_ADCALDIF; ADC2-&gt;CR |= ADC_CR_ADCAL; // Start calibration while (ADC2-&gt;CR &amp; ADC_CR_ADCAL); // Wait end calibration /************************************************ * Select event trigger and channel ***********************************************/ // Enable start conversion external trigger ADC2-&gt;CFGR |= ADC_CFGR_EXTEN_0; // Event 7 - HRTIM ADC2-&gt;CFGR |= ADC_CFGR_EXTSEL_0 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_2; // Select ADC2 channel IN5 ADC2-&gt;SQR1 |= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_2; // Length regular ADC channel = 1 ADC2-&gt;SQR1 &amp;= ~ADC_SQR1_L; ADC2-&gt;IER |= ADC_IER_EOCIE; // Interrupt enable NVIC_EnableIRQ(ADC1_2_IRQn); // enable interrupt ADC1 and ADC2 /************************************************ * Start ADC ***********************************************/ ADC2-&gt;CR |= ADC_CR_ADEN; // Enable ADC2 Delay(10); ADC2-&gt;CR |= ADC_CR_ADSTART; }</span></span></code> </pre><br>  Eu uso o modo de canal regular, tenho apenas um canal e ele √© selecionado no registro <i>SQR1</i> .  O n√∫mero de ADC envolvido 2, ou seja, sua entrada IN5, √© r√°pido e pode operar na frequ√™ncia m√°xima de amostragem, mas n√£o desta vez.  A frequ√™ncia de amostragem √© igual √† frequ√™ncia PWM, porque  1 per√≠odo = 1 amostra, em princ√≠pio, isso √© mais do que suficiente. <br><br>  Al√©m disso, no registro <i>CFGR</i> , precisamos selecionar o evento pelo qual a convers√£o ser√° iniciada, ou seja, o <i>Evento 7</i> , por que exatamente?  N√≥s olhamos no RM: <br><br><img src="https://habrastorage.org/webt/mr/f0/wn/mrf0wnno0sft4episcxokfnsduy.png"><br><br>  O gatilho 1 do m√≥dulo HRPWM chega ao Evento 7 para o nosso ADC No. 2, que neste caso funciona como escravo, depois √© controlado pelo m√≥dulo HRPWM.  Eu acho que agora est√° claro como conectar 2 m√≥dulos, em princ√≠pio, o algoritmo √© semelhante para qualquer periferia e qualquer timer, apenas o nome do registro ser√° diferente. <br><br>  Quando o contador do per√≠odo do timer mestre for atingido, uma convers√£o ser√° iniciada, que ap√≥s cerca de 15 ciclos (para quanto exatamente √© exibido no RM) causar√° uma interrup√ß√£o e voc√™ poder√° obter o resultado.  √â nessa interrup√ß√£o que organizamos o algoritmo de controle.  Sim, dentro da interrup√ß√£o, algo maci√ßo √© melhor n√£o faz√™-lo, √© melhor definir o sinalizador e transmitir a execu√ß√£o, mas vou me permitir tal simplifica√ß√£o, porque neste caso meu controlador n√£o est√° particularmente carregado e conseguir√° calcular e sair da interrup√ß√£o com uma probabilidade de 146% para o surgimento de um novo. <br><br>  <b>Um pouco sobre gerenciamento</b> <br><br>  Imagine que voc√™ entrou no banheiro e decidiu lavar as m√£os na pia.  Voc√™ abre levemente a √°gua, toca com a m√£o, fria?  Adicione mais √°gua quente, mais quente?  Bom!  Adicione mais √°gua quente?  Quase o que voc√™ precisa?  Bom!  Adicione mais √°gua quente, tente com a m√£o, queime-se?  Vamos desligar um pouco o calor agora.  Ta bom  E assim, para o infinito, voc√™ abrir√° a torneira at√© a temperatura da √°gua se tornar ideal.  Este √© o bot√£o mais f√°cil! <br><br>  Somente n√≥s n√£o regulamos a quantidade de √°gua quente, mas o ciclo de trabalho do PWM.  Em vez de uma m√£o, temos um ADC com um resultado medido.  Resta apenas implementar a l√≥gica.  Calculamos o que o ADC deve produzir na sa√≠da de 12V e, usando a condi√ß√£o <i>if</i> , for√ßaremos nosso controlador a manter esse valor alterando o fator de servi√ßo. <br><br>  Para come√ßar, vamos desligar um divisor de tens√£o para reduzir 12V para 2-2,5V, por exemplo, porque  O ADC pode medir de 0 a + 3,3V e, se for fornecido 12V, o microcontrolador queimar√° simplesmente.  Portanto, colocarei um divisor com valores nominais de 10 kOhm e 2 kOhm, o que dar√° uma taxa de divis√£o de 6 e, portanto, nossos + 12V se transformar√£o em + 2V.  Nosso ADC produzir√° o resultado: adcResult = (V <sub>out</sub> / k) / V <sub>ref</sub> * 2 <sup>12</sup> = (12V / 6) / 3,3 * 4095 = 2481. Agora, escrevemos o c√≥digo para o manipulador de interrup√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ADC1_2_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ADC2-&gt;ISR |= ADC_ISR_EOC; adcResult = ADC2-&gt;DR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adcResult &gt; <span class="hljs-number"><span class="hljs-number">2480</span></span>) { dutyControl = dutyControl - <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dutyControl = dutyControl + <span class="hljs-number"><span class="hljs-number">10</span></span>; } SetDutyTimerA(dutyControl); }</code> </pre><br>  Primeiro de tudo, depois de entrar no manipulador de interrup√ß√µes, voc√™ precisa limpar o sinalizador dessa interrup√ß√£o; caso contr√°rio, na segunda vez, voc√™ n√£o entrar√° nele.  Em seguida, lemos o resultado e o salvamos como uma vari√°vel <i>adcResult</i> .  Agora, conhecendo a tens√£o na sa√≠da, voc√™ precisa ajustar o ciclo de trabalho do PWM, eu implementei isso simplesmente atrav√©s da condi√ß√£o <i>if</i> .  Em cada per√≠odo do PWM, fazemos uma medi√ß√£o, aumentamos ou diminu√≠mos o ciclo de servi√ßo e definimos o resultado para o pr√≥ximo per√≠odo.  Tudo √© simples, r√°pido e a ess√™ncia √© vis√≠vel.  Analisamos o resultado do trabalho: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JxpeGDzYd3A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Como voc√™ pode ver, tudo funciona e quando a tens√£o de entrada muda, a sa√≠da em si permanece est√°vel em 12V.  Muito atencioso pode notar pequenas agulhas deslizando, ent√£o voc√™ s√≥ precisa pendurar a cer√¢mica X7R na sa√≠da de 1-10 microfarads e elas sair√£o, estou com pregui√ßa de procur√°-la e sold√°-la.  Agora o pr√≥prio oscilograma, para n√£o estragar os olhos: <br><br><img src="https://habrastorage.org/webt/ff/xf/be/ffxfbeq791q3wqwwfmohhheyg10.png"><br><br>  Aqui voc√™ pode ver como a tens√£o de sa√≠da aumenta.  O fato √© que, devido ao algoritmo de controle, para que o preenchimento atinja um valor de 0 a 10000, por exemplo, s√£o necess√°rios mil per√≠odos ou cerca de 10 ms.  Combina comigo porque um in√≠cio suave, se voc√™ deseja reduzir o tempo de subida, complica um pouco o algoritmo e adiciona +1000, n√£o +10, e quanto mais perto voc√™ chegar dos 12V especificados, menos regulamenta√ß√£o voc√™ far√° at√© atingir +10 .  Em geral, muitas coisas podem ser feitas em termos de gerenciamento, para que voc√™ tenha um campo para experimentos. <br><br>  Outro ponto interessante √© a oscila√ß√£o no momento do desligamento, como uma "gaita".  O fato √© que, depois de desligar a energia, minha parte digital continua a trabalhar em outro PSU e tenta manter o valor desejado na sa√≠da.  De onde vem a energia?  Sim, pelo capacitor de entrada, s√£o aqueles que s√£o 1000 microfarads j√° com 3 pe√ßas, este √© um fen√¥meno t√£o interessante. <br><br><h2>  Conclus√£o </h2><br>  O artigo n√£o era pequeno, mas voc√™ queria tudo e imediatamente eles dizem que vamos preparar o peda√ßo de ferro - prepare-o.  Espero que voc√™ goste do artigo, tentei torn√°-lo n√£o cient√≠fico, mas popular, para que o material seja acess√≠vel a pessoas com diferentes n√≠veis de conhecimento e experi√™ncia.  Talvez no futuro eu analise similarmente outras topologias como boost, bridge cheia e outras. <br><br>  A prop√≥sito, este artigo e c√≥digo servir√£o para o novo controlador MPPT em 20A, que estou projetando.  Agora estou aguardando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">as placas PCBway</a> , que realmente se ofereceram para patrocinar meus projetos de c√≥digo aberto com placas de circuito impresso, as fontes MPPT tamb√©m estar√£o abertas como para todos os meus m√≥dulos. <br><br>  Eu esqueci a coisa mais importante!  Mantenha o projeto com o c√≥digo para TrueSTDIO - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RAR</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt432778/">https://habr.com/ru/post/pt432778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt432768/index.html">Fones de ouvido sem fio para "maratonas em s√©rie": a Dolby os oferecer√° por US $ 599</a></li>
<li><a href="../pt432770/index.html">Botnets e seus tipos: o que √© conhecido em 2018</a></li>
<li><a href="../pt432772/index.html">Como criamos um servi√ßo de campanha publicit√°ria em conformidade com o GDPR</a></li>
<li><a href="../pt432774/index.html">Frontend DevDay. Grava√ß√£o de relat√≥rio</a></li>
<li><a href="../pt432776/index.html">O livro "Reaja em a√ß√£o"</a></li>
<li><a href="../pt432780/index.html">Por que a empatia √© necess√°ria no mundo da tecnologia</a></li>
<li><a href="../pt432782/index.html">Instala√ß√£o multi-servidor do Zimbra Collaboration Suite</a></li>
<li><a href="../pt432784/index.html">Castlevania Bot</a></li>
<li><a href="../pt432786/index.html">.NET - localiza√ß√£o sem dor. (N) gettext + poedit</a></li>
<li><a href="../pt432788/index.html">Prot√≥tipos: como criar um produto de sucesso e salvar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>