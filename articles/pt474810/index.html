<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüë¶‚Äçüë¶ ü§üüèª üòØ Como a criptografia de curva el√≠ptica funciona no TLS 1.3 üññüèø ü§üüèø üë©üèº‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alguns alertas do leitor: 

 Para (de alguma forma) simplificar o processo de descri√ß√£o e aumentar o volume do artigo que vamos escrever, √© essencial ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como a criptografia de curva el√≠ptica funciona no TLS 1.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/474810/"><img src="https://hsto.org/webt/qy/r5/a6/qyr5a6ywaf8vbc2kxtaazdmvgz8.png" alt="imagem"><br><br>  Alguns alertas do leitor: <br><br>  Para (de alguma forma) simplificar o processo de descri√ß√£o e aumentar o volume do artigo que vamos escrever, √© essencial fazer uma observa√ß√£o significativa e declarar a principal restri√ß√£o imediatamente - tudo o que vamos dizer hoje sobre a pr√°tica O lado problem√°tico √© vi√°vel apenas em termos do TLS 1.3.  Isso significa que, embora seu certificado ECDSA ainda funcione no TLS 1.2, se voc√™ desejar, fornecendo compatibilidade com vers√µes anteriores, a descri√ß√£o do processo real de handshake, roupas de cifra e benchmarks cliente-servidor abrange apenas o TLS 1.3.  Obviamente, isso n√£o est√° relacionado √† descri√ß√£o matem√°tica de algoritmos por tr√°s dos modernos sistemas de criptografia. <br><br>  Este artigo n√£o foi escrito por um matem√°tico nem por um engenheiro - embora esses tenham ajudado a encontrar uma maneira de contornar a matem√°tica assustadora e revido este artigo.  Muito obrigado aos funcion√°rios da Qrator Labs. <br><br><h3>  ( <b>C</b> elve el√≠ptico) <b>D</b> iffie- <b>H</b> ellman ( <b>E</b> phemeral) </h3> <b>O legado de Diffie - Hellman no s√©culo 21</b> <br><br>  Claro, isso n√£o come√ßou com Diffie nem Hellman.  Mas, para fornecer uma linha do tempo correta, precisamos apontar datas e eventos principais. <br><br>  Havia v√°rias personas principais no desenvolvimento da criptografia moderna.  Mais notavelmente, Alan Turing e Claud Shannon lan√ßaram uma quantidade incr√≠vel de trabalho no campo da teoria da computa√ß√£o e teoria da informa√ß√£o, bem como da criptoan√°lise geral, e Diffie e Hellman s√£o oficialmente creditados por terem a ideia de chave p√∫blica criptografia (ou assim√©trica) (embora se saiba que no Reino Unido houve avan√ßos s√©rios na criptografia que permaneceram em sigilo por muito tempo), tornando esses dois senhores pioneiros. <br><br>  Em que exatamente? <br><a name="habracut"></a><br>  Bem, isso pode parecer peculiar;  no entanto, antes de 6 de novembro de 1976, n√£o havia conhecimento p√∫blico dos sistemas de criptografia de chave p√∫blica.  Whitfield Diffie e Martin Hellman (e, de fato, Ralph Merkle) - matem√°ticos, engenheiros de computa√ß√£o e entusiastas, al√©m de criptologistas, foram os primeiros. <br><br>  Para aqueles que n√£o est√£o cientes - devido ao papel que a an√°lise de criptografia assumiu durante a Segunda Guerra Mundial e seu enorme impacto em manter as informa√ß√µes em segredo, os dois pa√≠ses que acreditavam ter o conhecimento mais avan√ßado sobre criptografia - os EUA e o Reino Unido inclu√≠ram criptografia em suas listas de muni√ß√µes e utilizaram uma proibi√ß√£o pesada de exporta√ß√£o (enfraquecendo simultaneamente a implementa√ß√£o da criptografia para uso dom√©stico e comercial dom√©stico).  Por esse motivo, os pesquisadores do Reino Unido que trabalham na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20141030210530/">t√©cnica de troca de chaves assim√©trica</a> na sede de comunica√ß√µes do governo e desenvolvem um esquema an√°logo n√£o foram reconhecidos para esta inven√ß√£o at√© 1997, quando as restri√ß√µes aos algoritmos de criptografia e sua descri√ß√£o se tornaram ineficazes. <br><br>  Voltando aos nossos inventores duplos - o que Diffie e Hellman revolucionaram especificamente? <br><br>  Vamos dar uma olhada no artigo original, ilustrando perfeitamente o grande salto que eles introduziram (mesmo teoricamente com o trabalho de pesquisa): <br><img src="https://habrastorage.org/webt/tt/rb/ig/ttrbigv4-qiw2ugkittwgox65se.png" alt="imagem"><br>  E o seguinte: <br><img src="https://habrastorage.org/webt/3c/n5/6g/3cn56g2moitap1tsu-dpsnspfc4.png" alt="imagem"><br>  Essas duas figuras ilustram perfeitamente a enorme mudan√ßa que Whitfield Diffie e Martin Hellman introduziram ap√≥s s√©culos de evolu√ß√£o na criptografia e criptografia - o estabelecimento de uma chave secreta compartilhada como resultado de uma computa√ß√£o criptogr√°fica. <br><br>  Vamos dar uma olhada em outra boa foto com cores: <br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Diffie-Hellman_Key_Exchange.svg/375px-Diffie-Hellman_Key_Exchange.svg.png" alt="imagem"><br><br>  Isso explica o que est√° acontecendo.  Antes da inven√ß√£o do contrato de chave de Diffie e Hellman, havia apenas uma chave sim√©trica - ela era usada para criptografar e descriptografar a mensagem.  Se voc√™ deseja fornecer a algu√©m uma "chave", ela deve ser transferida por um canal "seguro".  Voc√™ pode imaginar todas as restri√ß√µes de um esquema de gera√ß√£o anterior imediatamente - voc√™ precisa de um canal seguro j√° estabelecido, n√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode reutilizar a chave</a> e, idealmente, o comprimento da chave deve ser o mesmo que o comprimento da mensagem. <br><br>  Claude Shannon, em seu trabalho classificado em tempo de guerra, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Theory Communication of Secrecy Systems</a> ", provou que todas as cifras teoricamente inquebr√°veis ‚Äã‚Äãdevem ter os mesmos requisitos que a almofada de uso √∫nico - conhecida como cifra Vernam, pelo autor dessa cifra sim√©trica de fluxo polialfab√©tico. <br><br>  Mais uma vez, vamos dar uma olhada no artigo original: <br><img src="https://habrastorage.org/webt/p1/p0/yf/p1p0yfmprijaobfof3kb2lu4bpk.png" alt="imagem"><br><br>  Antes de prosseguirmos, vamos nos perguntar - como dois, mesmo que brilhantes, no entanto, os seres humanos obtiveram uma melhoria t√£o significativa em um campo aplicado com essa hist√≥ria, especialmente em tempos de guerra? <br>  Bem, por causa do: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teoria da informa√ß√£o</a> , formulada por Claude Shannon; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teoria da computa√ß√£o</a> influenciada, principalmente, por Alonzo Church, John von Neumann e Alan Turing; </li><li>  E, mais importante, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teoria da computabilidade</a> baseada principalmente no trabalho de Turing, que poder√≠amos dizer que todos desenvolveram e amadureceram no mesmo per√≠odo do s√©culo XX.  Diffie e Hellman mencionaram Claude Shannon como o influenciador mais significativo de seu trabalho. </li></ul><br>  A ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seguran√ßa Universal</a> ‚Äù da Lenstra ilustra a quantidade de energia necess√°ria para ‚Äúquebrar‚Äù o sistema criptogr√°fico sim√©trico com v√°rios comprimentos de chave.  Descobriu-se que a quebra de uma chave de curva el√≠ptica de 228 bits exigiria a mesma quantidade de energia necess√°ria para ferver toda a √°gua da Terra.  Por√©m, √© v√°lido apenas sob considera√ß√£o de algoritmos e hardware conhecidos, pois, estritamente falando, ningu√©m sabe se existem algoritmos ou hardware significativamente mais eficientes.  A chave CE de 228 bits √© compar√°vel √† chave RSA de 2380 bits, mais sobre isso mais tarde.  Embora nessa estimativa as chaves RSA e EC sejam usadas em um esquema de criptografia assim√©trica, esses comprimentos de chave s√£o um pouco equivalentes a uma chave de criptografia sim√©trica de 128 bits. <br><br>  √â f√°cil imaginar que algo "dif√≠cil de calcular" exigiria muita energia e / ou tempo necess√°rio para o c√°lculo.  Tendemos a pensar que os computadores podem "calcular tudo", mas acontece que isso n√£o √© verdade.  Primeiro, existem exemplos indecid√≠veis, como o problema da parada, embora no campo da criptografia possamos evitar essa armadilha.  Segundo, se considerarmos o tempo necess√°rio para a execu√ß√£o de um determinado algoritmo, ele pode ser arbitrariamente alto.  √â isso que exploramos na criptografia.  Um problema √© considerado "f√°cil" para calcular se o tempo necess√°rio para executar o respectivo algoritmo depende do tamanho da entrada (medido em bits) como um polin√¥mio: <math> </math> $ inline $ T (n) = O (n ^ k) $ inline $   , por alguma constante positiva <math> </math> $ inline $ k $ inline $   .  No campo da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teoria da complexidade computacional</a> , esses problemas formam a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe de complexidade P.</a> <br><br>  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe de complexidade P</a> √© quase central, pois representa o problema para o qual existe um algoritmo de tempo polinomial determin√≠stico.  Outra classe de complexidade √© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NP</a> (os problemas que s√£o "dif√≠ceis de calcular"), representando um conjunto de problemas de decis√£o, ou seja, problemas que exigem resposta "sim" ou "n√£o", que t√™m uma prova verific√°vel em tempo polinomial.  Voc√™ v√™ a palavra "prova" aqui?  √â a√≠ que chegamos √†s fun√ß√µes do al√ßap√£o, pertencentes √† classe de complexidade NP. <br><br><img src="https://imgs.xkcd.com/comics/travelling_salesman_problem.png" alt="imagem"><br>  Cr√©ditos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">xkcd</a> <br><br><h3>  Fun√ß√µes unidirecionais;  Fun√ß√µes de al√ßap√£o </h3><br>  Por defini√ß√£o, uma fun√ß√£o unidirecional √© uma fun√ß√£o que √© f√°cil de calcular em todas as entradas, mas √© dif√≠cil de reverter, ou seja, computa a entrada original apenas com a sa√≠da.  "F√°cil" e "dif√≠cil" se referem √†s defini√ß√µes da teoria da complexidade computacional acima.  √â interessante notar que a exist√™ncia de fun√ß√µes unidirecionais n√£o √© (matematicamente) comprovada, porque sua exist√™ncia provaria que as classes de complexidade P e NP n√£o s√£o iguais, enquanto P √© igual a NP ou n√£o √© atualmente um problema em aberto.  Portanto, lembre-se de que toda criptografia moderna se baseia em hip√≥teses n√£o comprovadas. <br><br>  Agora, em seu artigo original, Diffie e Hellman apresentam outra gera√ß√£o de fun√ß√µes unidirecionais que eles chamam de "fun√ß√µes de al√ßap√£o".  Como eles diferem? <br>  Como eles explicam em seu documento de refer√™ncia: <blockquote>  Em um sistema de criptografia de chave p√∫blica, a codifica√ß√£o e decifra√ß√£o s√£o governadas por chaves distintas, E e D, de modo que a computa√ß√£o de D a partir de E √© computacionalmente invi√°vel (por exemplo, exigir <math> </math> $ inline $ 10 ^ {100} $ inline $   instru√ß√µes).  A chave de codifica√ß√£o E pode ser divulgada [em um diret√≥rio] sem comprometer a chave de decodifica√ß√£o D. Isso permite que qualquer usu√°rio do sistema envie uma mensagem a qualquer outro usu√°rio codificado de tal maneira que apenas o destinat√°rio pretendido possa decifr√°-la. .. O problema da autentica√ß√£o √© talvez uma barreira ainda mais s√©ria √† ado√ß√£o universal de telecomunica√ß√µes para transa√ß√µes comerciais do que os problemas de distribui√ß√£o de chaves ... [ele] ... est√° no centro de qualquer sistema que envolva contratos e cobran√ßa. </blockquote>  Por conven√ß√£o, os caracteres de criptografia "Alice" e "Bob" (buscando comunica√ß√£o segura) s√£o freq√ºentemente usados ‚Äã‚Äãpara explicar o conceito de chave p√∫blica.  Alice e Bob concordam em n√∫meros inteiros grandes <math> </math> $ inline $ n $ inline $   e <math> </math> $ inline $ g $ inline $   com <math> </math> $ inline $ 1 &lt;g &lt;n $ inline $   .  A sele√ß√£o afeta a seguran√ßa do sistema.  "O m√≥dulo <math> </math> $ inline $ n $ inline $   deve ser primo;  mais importante <math> </math> $ inline $ (n-1) / 2 $ inline $   tamb√©m deve ser um primo &lt;...&gt; e <math> </math> $ inline $ g $ inline $   deve ser um m√≥dulo raiz primitivo <math> </math> $ inline $ n $ inline $   &lt;...&gt; [e] <math> </math> $ inline $ n $ inline $   deve ter pelo menos 512 bits. "  O protocolo Diffie - Hellman pode ser declarado em forma elementar em 5 etapas. <br><br><ol><li>  Alice escolhe <math> </math> $ inline $ x $ inline $   (um inteiro aleat√≥rio grande) e calcula <math> </math> $ inline $ X = g ^ x \ bmod n $ inline $ </li><li>  Bob escolhe <math> </math> $ inline $ y $ inline $   (um inteiro aleat√≥rio grande) e calcula <math> </math> $ inline $ Y = g ^ y \ bmod n $ inline $ </li><li>  Alice envia <math> </math> $ inline $ X $ inline $   para Bob, enquanto Bob envia <math> </math> $ inline $ Y $ inline $   para Alice (eles mant√™m <math> </math> $ inline $ x $ inline $   e <math> </math> $ inline $ y $ inline $   segredo um do outro) </li><li>  Alice calcula <math> </math> $ inline $ k = Y ^ x \ bmod n $ inline $ </li><li>  Bob calcula <math> </math> $ inline $ k '= X ^ y \ bmod n $ inline $ </li></ol><br>  Como resultado, Alice e Bob t√™m o mesmo valor <math> </math> $ inline $ k = k '$ inline $   que serve como um segredo compartilhado. <br><br>  A fun√ß√£o Trapdoor √© uma fun√ß√£o unidirecional que possibilita encontrar sua inversa se houver uma informa√ß√£o especial chamada ‚Äútrapdoor‚Äù.  Parece f√°cil, embora tenha sido bastante dif√≠cil encontrar essas fun√ß√µes - o primeiro m√©todo vi√°vel foi encontrado na implementa√ß√£o de um algoritmo de criptografia assim√©trica de criptografia de chave p√∫blica chamado RSA em homenagem a seus criadores: Ron Rivest, Adi Shamir e Leonard Adleman. <br><br><h3>  RSA </h3><br>  No RSA, a dureza de inverter a fun√ß√£o √© baseada no fato de que o fatorar (encontrar multiplicadores primos de um n√∫mero) leva muito mais tempo que multiplica√ß√£o, ou dever√≠amos dizer aqui que nenhum m√©todo de tempo polinomial para fatorar grandes n√∫meros inteiros em um computador cl√°ssico tem foi encontrado, no entanto, n√£o foi provado que n√£o exista. <br><br>  No RSA, como em qualquer outro sistema de criptografia de chave p√∫blica, existem duas chaves: p√∫blica e privada.  O RSA pega a mensagem de entrada (representada como uma sequ√™ncia de bits) e aplica uma opera√ß√£o matem√°tica (m√≥dulo de exponencia√ß√£o um grande n√∫mero inteiro) para obter um resultado parecendo indistingu√≠vel aleatoriamente.  A descriptografia obt√©m esse resultado e aplica uma opera√ß√£o semelhante para retornar a mensagem original.  Na criptografia assim√©trica, a criptografia √© feita com a chave p√∫blica e descriptografada com a privada. <br><br>  Como  Porque os operandos pertencem a um grupo c√≠clico finito (um conjunto de n√∫meros inteiros com multiplica√ß√£o na aritm√©tica modular).  Os computadores n√£o lidam muito bem com n√∫meros arbitrariamente grandes, mas, felizmente, nosso grupo c√≠clico de n√∫meros inteiros √© executar uma opera√ß√£o chamada ‚Äúenvolver‚Äù - um n√∫mero maior que o m√°ximo permitido √© envolvido em um n√∫mero no intervalo v√°lido em que operamos .  Isso nos permite operar com teclas de comprimento "n√£o superior a".  Na criptografia de curva el√≠ptica, tamb√©m s√£o usados ‚Äã‚Äãgrupos c√≠clicos (multiplicativos), mas constru√≠dos de maneira um pouco diferente, como veremos mais adiante. <br><br>  Basicamente, o que a RSA faz √© pegar dois n√∫meros primos grandes e multiplic√°-los para obter o chamado m√≥dulo.  Todos os outros n√∫meros a serem tratados residem entre zero e o m√≥dulo.  O m√≥dulo deve fazer parte da chave p√∫blica e seu comprimento de bit determina o comprimento da chave.  A segunda parte da chave p√∫blica √© um n√∫mero escolhido entre zero e o totiente de Euler (a implementa√ß√£o moderna do RSA toma o totient de Carmichael em vez do de Euler) do m√≥dulo com algumas restri√ß√µes adicionais.  Finalmente, a chave privada deve ser calculada resolvendo-se alguma equa√ß√£o modular.  Para criptografar um n√∫mero, simplesmente aumentamos para a pot√™ncia igual √† chave p√∫blica e, para decriptografar um n√∫mero, aumentamos para a pot√™ncia igual √† chave privada.  Gra√ßas √† natureza c√≠clica do grupo, recuperamos o n√∫mero inicial. <br><br>  Atualmente, existem dois problemas significativos com a RSA, sendo uma conseq√º√™ncia da outra.  √Ä medida que o comprimento de uma chave (ou seja, o n√∫mero de bits) aumenta, o fator de complexidade cresce n√£o t√£o r√°pido quanto se pode esperar.  Isso ocorre porque existe um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algoritmo de</a> fatora√ß√£o subexponencial (mas ainda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">super polinomial</a> ).  Portanto, para manter um n√≠vel de seguran√ßa apropriado, o comprimento da chave RSA precisa crescer um pouco mais r√°pido que o comprimento da chave ECC.  √â por isso que a maioria das chaves RSA difundidas atualmente tem 2048 ou 3072 bits. <br><br>  Um pouco mais tarde, veremos em n√∫meros como o comprimento da chave afeta a efici√™ncia geral do sistema de criptografia comparando o certificado RSA e ECDSA assinado com a autoridade Let's Encrypt. <br><br><h3>  ( <b>C</b> elve el√≠ptico) Ignor√¢ncia digital <b>S</b> Algoritmo </h3><br>  A busca por uma melhor fun√ß√£o de al√ßap√£o acabou levando os criptografistas a uma evolu√ß√£o ativa no ramo da matem√°tica em meados dos anos 80, dedicado √†s curvas el√≠pticas. <br><br>  Seria a tarefa final descrever a criptografia de curva el√≠ptica em um artigo, portanto n√£o o faremos.  Em vez disso, vamos dar uma olhada em uma fun√ß√£o de al√ßap√£o de curva el√≠ptica com base no problema de logaritmo discreto. <br><br>  Existem muitos iniciadores e introdu√ß√µes mais aprofundadas da criptografia de curva el√≠ptica, e recomendamos especialmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o ‚ÄúECC: uma introdu√ß√£o suave‚Äù de Andrea Corbellini,</a> se voc√™ estiver interessado em matem√°tica. <br><br>  O que nos interessa s√£o par√¢metros bastante "simples". <br><br>  A curva el√≠ptica √© definida por uma equa√ß√£o como esta: <math> </math> $ inline $ y ^ 2 = x ^ 3 + ax + b $ inline $ <br>  Essa curva √© necess√°ria para construir um subgrupo c√≠clico sobre um campo finito.  Portanto, os seguintes par√¢metros est√£o sendo usados: <br><br><ul><li>  O <b>principal</b> <math> </math> <b>$ inline $ p $ inline $</b>   que especifica o tamanho do campo finito; </li><li>  Os <b>coeficientes</b> <math> </math> <b>$ inline $ a $ inline $</b>   <b>e</b> <math> </math> <b>$ inline $ b $ inline $</b>   da equa√ß√£o da curva el√≠ptica; </li><li>  O <b>ponto base</b> <math> </math> <b>$ inline $ g $ inline $</b>   que gera o subgrupo mencionado; </li><li>  A <b>ordem</b> <math> </math> <b>$ inline $ n $ inline $</b>   do subgrupo; </li><li>  O <b>cofator</b> <math> </math> <b>$ inline $ h $ inline $</b>   do subgrupo. </li></ul><br>  Em conclus√£o, os <b>par√¢metros de dom√≠nio</b> para nossos algoritmos √© o <b>sextuplet</b> <math> </math> $ inline $ (p, a, b, G, n, h) $ inline $   . <br>  Tais curvas el√≠pticas funcionam sobre o campo finito <math> </math> $ inline $ \ mathbb {F} _p $ inline $   onde <math> </math> $ inline $ p $ inline $   √© um n√∫mero primo bastante grande.  Ent√£o, n√≥s temos um conjunto de m√≥dulos inteiros <math> </math> $ inline $ p $ inline $   , em que opera√ß√µes como adi√ß√£o, subtra√ß√£o, multiplica√ß√£o, inverso aditivo e inverso multiplicativo s√£o poss√≠veis.  A adi√ß√£o e a multiplica√ß√£o funcionam de maneira semelhante √† aritm√©tica modular ou denominada ‚Äúrel√≥gio‚Äù que vimos nas ‚Äúvoltas‚Äù da RSA. <br>  Como a curva √© sim√©trica em rela√ß√£o ao eixo x, dado qualquer ponto <math> </math> $ inline $ P $ inline $   , podemos pegar <math> </math> $ inline $ ‚àíP $ inline $   para ser o ponto oposto a ele.  Tomamos <math> </math> $ inline $ ‚àíO $ inline $   ser apenas <math> </math> $ inline $ O $ inline $   . <br>  A adi√ß√£o de pontos de curva √© definida de maneira que dados pontos <math> </math> $ inline $ P $ inline $   e <math> </math> $ inline $ Q $ inline $   , podemos desenhar uma linha que cruza esses pontos e a curva de interse√ß√£o em um terceiro ponto <math> </math> $ inline $ R $ inline $   para que <math> </math> $ inline $ P + Q = -R $ inline $   e <math> </math> $ inline $ P + Q + R = 0 $ inline $   . <br><br>  Vamos dar uma olhada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">explica√ß√£o de Marc Hughes</a> : <br><blockquote><img src="https://www.allaboutcircuits.com/uploads/articles/Curve_Cryptography_fig09.jpg" alt="imagem"><br><br>  Uma linha de inclina√ß√£o constante que viaja ao longo da superf√≠cie do toro √© mostrada acima.  Essa linha passa por dois pontos inteiros selecionados aleatoriamente na curva. <br><br><img src="https://www.allaboutcircuits.com/uploads/articles/Curve_Cryptography_fig10.gif" alt="imagem"><br><br>  Para adicionar dois pontos no gr√°fico, desenhe uma linha a partir do primeiro ponto selecionado <math> </math> $ inline $ P $ inline $   para o segundo ponto selecionado <math> </math> $ inline $ Q $ inline $   e estenda a linha at√© cruzar outro ponto no gr√°fico <math> </math> $ inline $ -R $ inline $   , estendendo-o al√©m dos limites da plotagem, se necess√°rio. <br><br>  Depois de interceptar um ponto inteiro, reflita o ponto verticalmente no meio do gr√°fico (uma linha pontilhada laranja) para encontrar o novo ponto <math> </math> $ inline $ R $ inline $   no gr√°fico  Portanto, <math> </math> $ inline $ P + Q = R $ inline $   . </blockquote>  A multiplica√ß√£o por um escalar agora √© trivial: <math> </math> $ inline $ n \ cdot P = P + P + P + \ pontos + P $ inline $   (aqui est√£o <math> </math> $ inline $ n $ inline $   summands). <br><br>  A fun√ß√£o al√ßap√£o aqui est√° no problema do logaritmo discreto (para curvas el√≠pticas), n√£o na fatora√ß√£o que analisamos na se√ß√£o RSA.  O problema √©: se sabemos <math> </math> $ inline $ P $ inline $   e <math> </math> $ inline $ Q $ inline $   , o que √© tal <math> </math> $ inline $ k $ inline $   que <math> </math> $ inline $ Q = k \ cdot P $ inline $   ? <br><br>  Sup√µe-se que tanto o problema de fatora√ß√£o (subjacente ao RSA) quanto o logaritmo discreto para curvas el√≠pticas (que √© a base do ECDSA e ECDH) sejam dif√≠ceis, ou seja, n√£o h√° algoritmos conhecidos para resolver esse problema no tempo polinomial de uma determinada chave comprimento. <br><br>  Enquanto, normalmente, qualquer pessoa ficaria envergonhada por misturar o ECDH (Troca de Chaves) com o algoritmo de assinatura (ECDSA), precisamos explicar como eles trabalham juntos.  Um certificado TLS moderno cont√©m uma chave p√∫blica, no nosso caso, do par de chaves gerado pelo algoritmo de curva el√≠ptica, geralmente assinado por uma autoridade de n√≠vel superior.  O cliente verifica a assinatura do servidor e obt√©m o segredo compartilhado.  O segredo compartilhado √© usado em um algoritmo de criptografia sim√©trica, como AES ou ChaCha20.  No entanto, o princ√≠pio permanece o mesmo: concorde com os par√¢metros do dom√≠nio (o sextuplet), obtenha o par de chaves, onde a chave privada √© um n√∫mero inteiro selecionado aleatoriamente (o multiplicando de <math> </math> $ inline $ Q = k \ cdot P $ inline $   ) e a chave p√∫blica √© um ponto na curva.  Algoritmos de assinatura usam o ponto base <math> </math> $ inline $ g $ inline $   , que √© um gerador para um subgrupo de grande ordem principal <math> </math> $ inline $ n $ inline $   , de modo que <math> </math> $ inline $ n \ cdot G = 0 $ inline $   , onde 0 √© o elemento de identidade.  A assinatura prova que a conex√£o segura est√° sendo estabelecida com a parte aut√™ntica - um servidor que possui o certificado TLS (chave p√∫blica) assinado por alguma autoridade de certifica√ß√£o para o nome do servidor especificado. <br><br><h3>  (EC) DH (E) + ECDSA = Forma atual do handshake </h3><br>  No TLS moderno (1.3), o cliente e o servidor geram seu par de chaves p√∫blico-privado em tempo real, enquanto estabelecem a conex√£o, isso √© chamado de vers√£o ef√™mera da troca de chaves.  As bibliotecas TLS do navegador mais populares suportam isso.  Eles usam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">principalmente a curva el√≠ptica Edwards 25519</a> , apresentada por Daniel J. Bernstein (djb), oferecendo seguran√ßa de 128 bits.  Desde 2014, o openssh usa essa curva para a cria√ß√£o do par de chaves.  Em 2019, por√©m, os navegadores ainda n√£o suportam sess√µes TLS com servidores com um certificado com chave p√∫blica EdDSA. <br><br>  Mas vamos voltar a como as coisas funcionam no final de 2019 com o TLS 1.3. <br><br>  Os principais mecanismos de troca no TLS 1.3 s√£o restritos a (EC) DH (E) (com o x25519 √© o suportado nas bibliotecas TLS do lado do cliente dos navegadores mais populares, bem como nas bibliotecas TLS do lado do servidor, como OpenSSL, que examinaremos um pouco mais tarde) e a lista de conjuntos de criptografia cont√©m apenas tr√™s entradas: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384 e TLS_CHACHA20_POLY1305_SHA256.  Para aqueles que sabem como os conjuntos de cifras foram nomeados na vers√£o TLS 1.2, √© evidente imediatamente que o mecanismo de troca de chaves agora est√° "desanexado" do nome do conjunto de cifras, tamb√©m os modos de troca est√°tico RSA e est√°tico Diffie - Hellman removidos inteiramente da especifica√ß√£o.  At√© a retomada da sess√£o com base no PSK √© feita sobre ECDHE no TLS 1.3.  Isso tamb√©m se aplica aos par√¢metros DH personalizados, que n√£o s√£o permitidos agora, deixando apenas aqueles geralmente aceitos como seguros na especifica√ß√£o final do protocolo. <br><br>  √â interessante que exista uma diferen√ßa bastante significativa em como os algoritmos de criptografia assim√©trica funcionam atualmente.  Com o ECC (e os certificados ECDSA em particular), usamos chaves menores para obter n√≠veis "convenientes" de seguran√ßa, em compara√ß√£o com o RSA.  Isso permite o uso de um algoritmo de criptografia assim√©trica mais forte e mecanismos de troca de chaves em dispositivos menores e, √†s vezes, at√© em coisas que geralmente n√£o s√£o consideradas um dispositivo (cart√£o inteligente). <br><br>  Antes de tudo, √© necess√°rio mencionar o que ‚Äúsistema de criptografia h√≠brido‚Äù significa em termos do TLS 1.3. <br>  Um sistema de criptografia h√≠brido √© aquele que usa criptografia assim√©trica (chave p√∫blica) para estabelecer um segredo compartilhado, que √© usado ainda mais como chave em um fluxo sim√©trico ou em uma cifra de bloco. <br><br>  Em segundo lugar, infraestrutura e certificados de chave p√∫blica.  √â interessante que, em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sua entrevista de 2004,</a> Martin Hellman mencionou um "her√≥i n√£o reconhecido" Loren Kohnfelder, cuja tese de bacharel no MIT introduziu uma estrutura em √°rvore do que hoje conhecemos como infraestrutura de chave p√∫blica.  No entanto, vamos reverter para certificados. <br><br>  O fato de o servidor realmente possuir a chave privada √© garantido por sua assinatura, que pode ser verificada com a chave p√∫blica do servidor.  E o certificado garante que alguma chave p√∫blica perten√ßa a um servidor espec√≠fico.  Isso significa que voc√™ est√° estabelecendo uma comunica√ß√£o segura com a parte espec√≠fica e n√£o com um impostor.  Seu banco, n√£o um cibercriminoso.  No TLS 1.3, h√° uma melhoria significativa em rela√ß√£o ao formato de negocia√ß√£o anterior - o servidor assina todas as informa√ß√µes que possui at√© o momento: o cliente Ol√° e o Servidor Ol√°, incluindo a cifra negociada.  Vamos dar uma olhada na se√ß√£o correspondente da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC 8446</a> : <br><br><pre><code class="plaintext hljs">Client Server Key ^ ClientHello Exch | + key_share* | + signature_algorithms* | + psk_key_exchange_modes* v + pre_shared_key* --------&gt; ServerHello ^ Key + key_share* | Exch + pre_shared_key* v {EncryptedExtensions} ^ Server {CertificateRequest*} v Params {Certificate*} ^ {CertificateVerify*} | Auth {Finished} v &lt;-------- [Application Data*] ^ {Certificate*} Auth | {CertificateVerify*} v {Finished} --------&gt; [Application Data] &lt;-------&gt; [Application Data]</code> </pre> <br>  No TLS 1.3, o cliente envia o compartilhamento de chave (junto com os par√¢metros necess√°rios), algoritmos de assinatura imediatamente na primeira mensagem (Client Hello).  As chaves necess√°rias para trocar com o servidor s√£o criadas em segundo plano, sem que o usu√°rio perceba esse fato.  Eles s√£o trocados ainda com o servidor para criar um segredo comum, a partir de chaves secretas pr√©-mestre que foram estabelecidas quando o servidor enviou sua mensagem (Server Hello) respondendo ao cliente. <br>  No lado ‚ÄúServer Hello‚Äù, voc√™ pode ver o Certificado * sendo transferido para o cliente, junto com a parte Verifica√ß√£o de Certificado *, que verifica se a parte possui a chave privada para a entrada de chave p√∫blica correspondente e cria a chave de sess√£o (sim√©trica) se tudo corre como planejado - o que significa que o lado que solicitou os dados (cliente) verificou com √™xito o lado de resposta (servidor), criando ainda um segredo comum. <br><br>  Existem duas opera√ß√µes essenciais ocultas nessas transmiss√µes - cria√ß√£o e verifica√ß√£o de assinaturas.  Essas s√£o feitas nos dois lados da comunica√ß√£o, uma vez que a ‚Äúassinatura‚Äù √© essencialmente uma prova de que a parte realmente possui a chave privada correspondente √† chave p√∫blica, que os dados s√£o do signat√°rio e que a mensagem n√£o foi alterada em tr√¢nsito. <br><br>  Com a RSA, como veremos mais adiante, a opera√ß√£o de assinatura √© a mais cara.  Como estamos assinando com uma chave longa de 2048 ou 3072 bits, essa opera√ß√£o carrega o servidor significativamente, muito mais do que o cliente que verifica essa assinatura. <br><br>  Com o ECDSA, temos chaves menores (veremos o ECDSA com o NIST P-256 (ou o secp256v1)), mas com opera√ß√µes mais complexas.  Como resultado, ele pode ser visto como o RSA ‚Äúinvertido‚Äù - o cliente √© carregado mais, pelo c√°lculo da verifica√ß√£o de assinatura, enquanto o servidor lida facilmente com a cria√ß√£o da assinatura.  As medi√ß√µes verificam isso, consulte a se√ß√£o "Um pouco de refer√™ncia". <br><br>  Esse efeito dimensiona facilmente a Internet atualmente - j√° que os clientes modernos s√£o quase igualmente poderosos como os servidores (levando em conta apenas a frequ√™ncia de n√∫cleo da CPU), para que possam efetivamente levar a opera√ß√£o cara a descoberto.  O servidor, por sua vez, pode usar os recursos liberados para criar mais assinaturas e estabelecer mais sess√µes. <br><br><h3>  Vamos criptografar a assinatura do certificado </h3><br>  Portanto, para fornecer ao leitor algumas instru√ß√µes pr√°ticas e pr√°ticas sobre como criar um servidor habilitado para TLS com o par de chaves ECDSA assinado pela autoridade Let's Encrypt, decidimos ilustrar um processo completo de cria√ß√£o de um par de chaves necess√°rio criar um CSR (solicita√ß√£o de assinatura de certificado) para o Let's Encrypt e, como resultado, obter o certificado ECDSA necess√°rio para o nosso servidor. <br><br>  Temos que gerar uma chave privada para continuar.  Usaremos a biblioteca OpenSSL. <br>  O manual do OpenSSL descreve a gera√ß√£o de qualquer chave EC por meio de um comando especial, designado especialmente para o ramo da curva el√≠ptica do algoritmo de gera√ß√£o. <br><br><pre> <code class="plaintext hljs">openssl ecparam -genkey -name -secp256v1 -out privatekey.pem</code> </pre> <br>  Para verificar se a biblioteca OpenSSL fez tudo certo, podemos executar o comando <code>ec</code> . <br><br><pre> <code class="plaintext hljs">openssl ec -in privatekey.pem -noout -text</code> </pre> <br>  A sa√≠da nos mostrar√° a curva especificada com a qual a chave foi criada. <br><br>  O pr√≥ximo passo √© essencial para a cria√ß√£o do CSR - para pular o processo de preenchimento de todos os detalhes de informa√ß√µes necess√°rias para obter o certificado, precisamos do arquivo de configura√ß√£o.  Felizmente, a Mozilla fez todo o trabalho por n√≥s, introduzindo o " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SSL Configuration Generator</a> ".  L√°, voc√™ pode escolher entre qualquer op√ß√£o de servidor dispon√≠vel.  A configura√ß√£o pura do OpenSSL, peculiarmente n√£o presente na p√°gina do gerador, seria algo como isto: <br><br><pre> <code class="plaintext hljs">[ req ] prompt = no encrypt_key = no default_md = sha256 distinguished_name = dname req_extensions = reqext [ dname ] CN = example.com emailAddress = admin@example.com [ reqext ] subjectAltName = DNS:example.com, DNS:*.example.com</code> </pre> <br>  <i>Nota: n√£o √© necess√°rio ter o CNF - caso contr√°rio, voc√™ dever√° preencher esses detalhes na linha de comando.</i> <br><br>  Agora, siga a cria√ß√£o de um pr√≥prio CSR.  Aqui temos um pr√°tico comando OpenSSL. <br><br><pre> <code class="plaintext hljs">openssl req -new -config -pathtoconfigfile.cnf -key privatekey.pem -out csr.pem</code> </pre> <br>  Tamb√©m podemos verificar a corre√ß√£o de um CSR rec√©m-criado. <br><br><pre> <code class="plaintext hljs">openssl req -in csr.pem -noout -text -verify</code> </pre> <br>  Aqui chegamos √† fase final - usando um cliente ACME, certbot, para passar nossa solicita√ß√£o de assinatura de certificado para Let's Encrypt. <br><br>  O Certbot ajuda voc√™ a obter o certificado necess√°rio e tem v√°rias op√ß√µes.  Dito isso, se voc√™ √© novo na criptografia de chave p√∫blica e na infraestrutura de PKI que temos em 2019, √© melhor usar <code>--dry-run</code> antes de tentar obter o certificado para qualquer dom√≠nio seu. <br><br><pre> <code class="plaintext hljs">certbot certonly --dry-run --dns-somednsprovider --domain ‚Äúexample.com‚Äù --domain ‚Äú*.example.com‚Äù --csr csr.pem</code> </pre> <br>  Nesse caso, o cliente certbot verifica se a lista de dom√≠nios solicitados (na linha de comandos) corresponde aos dom√≠nios listados na solicita√ß√£o de assinatura de certificado.  No comando <code>--dns-somednsprovider</code> √© uma mentira, porque existem v√°rias maneiras de voc√™ provar que o Let's Encrypt est√° de posse de uma parte espec√≠fica do tr√°fego da Internet.  No entanto, se voc√™ estiver usando algum provedor de hospedagem em nuvem p√∫blica, digamos DigitalOcean, Hetzner, Amazon, Azure, qualquer coisa - provavelmente haveria uma maneira mais natural de fornecer as informa√ß√µes necess√°rias, porque seu provedor j√° fez alguma ferramenta de integra√ß√£o. <br><br>  Depois, se tiver certeza da exatid√£o dos par√¢metros que voc√™ est√° usando ao passar seu CSR para o Let's Encrypt via um cliente certbot - exclua o par√¢metro <code>--dry-run</code> do seu comando e continue. <br><br>  Se for bem-sucedido, o cliente produzir√° v√°rios certificados como sa√≠da: o pr√≥prio certificado assinado, as certifica√ß√µes raiz e intermedi√°ria e a combina√ß√£o deste √∫ltimo como a cadeia de certificados com o √∫ltimo nome, tudo no formato de arquivo .pem. <br><br>  O OpenSSL possui um comando que poder√≠amos usar para inspecionar os certificados: <br><br><pre> <code class="plaintext hljs">openssl x509 -in chainfilepath.pem -noout -text</code> </pre> <br>  Nesse momento, fica evidente que o Let's Encrypt assinou o certificado usando o resumo SHA256.  Al√©m disso, a assinatura de raiz e intermedi√°rios do ECDSA se enquadra na se√ß√£o "Pr√≥ximos recursos", o que significa efetivamente que, no momento, voc√™ obteria apenas intermedi√°rios do RSA.  Mas tudo bem, pois voc√™ ainda est√° usando a chave p√∫blica ECDSA. <br><br>  No final desta se√ß√£o, gostar√≠amos de dizer algo relacionado ao comprimento das chaves.  Na seguran√ßa da informa√ß√£o, √© comum dizer que o n√≠vel de seguran√ßa √© 2 ^ x, onde x √© o tamanho do bit (o RSA √© uma exce√ß√£o aqui, pois cresce um pouco mais lentamente do que exponencialmente).  Para aproximar como as chaves usadas para diferentes algoritmos se correspondem, consultar√≠amos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina wiki</a> do OpenSSL. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Comprimento da chave sim√©trica</b> <br></td><td>  <b>Comprimento da chave RSA</b> <br></td><td>  <b>Comprimento da chave da curva el√≠ptica</b> <br></td></tr><tr><td>  80 <br></td><td>  1024 <br></td><td>  160 <br></td></tr><tr><td>  112 <br></td><td>  2048 <br></td><td>  224 <br></td></tr><tr><td>  128 <br></td><td>  3072 <br></td><td>  256 <br></td></tr><tr><td>  192 <br></td><td>  7680 <br></td><td>  384 <br></td></tr><tr><td>  256 <br></td><td>  15360 <br></td><td>  512 <br></td></tr></tbody></table></div>  Como voc√™ pode ver, as diferen√ßas s√£o bastante proeminentes.  Embora com o Let's Encrypt n√£o possamos obter nenhum certificado assinado fora das chaves da curva el√≠ptica 256 (secp256v1) e 384 (secp384r1). <br><br><h3>  Problemas e exce√ß√µes conhecidos, e a NSA </h3><br><img src="https://imgs.xkcd.com/comics/random_number.png" alt="imagem"><br>  Cr√©ditos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">xkcd</a> <br><br>  Provavelmente, a quest√£o central do uso da criptografia de curva el√≠ptica ao longo dos anos foi a necessidade de um gerador de n√∫meros aleat√≥rios cuidadosamente criado, a fim de criar chaves do n√≠vel de seguran√ßa necess√°rio. <br><br>  Houve um esc√¢ndalo maci√ßo em torno do algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dual_EC_DRBG</a> (gerador de bit aleat√≥rio determin√≠stico de curva el√≠ptica), que levou muitos anos para ser resolvido.  Al√©m disso, h√° incerteza em torno das patentes da ECC, pois √© sabido que muitas delas pertenciam √† empresa Certicom, que foi adquirida pela Blackberry.  Tamb√©m existem empresas que s√£o certificadas pelo uso do ECC da Blackberry.  Certamente, existe uma simples desconfian√ßa em alguns padr√µes do NIST, que podem ou n√£o ser afetados pela NSA ou por qualquer outra institui√ß√£o de fiscaliza√ß√£o e fiscaliza√ß√£o dos Estados Unidos. <br><br>  O lado da implementa√ß√£o de um problema √© uma quest√£o totalmente diferente.  Em 2010, o console PlayStation 3 sofreu uma recupera√ß√£o de chave privada da Sony devido √† implementa√ß√£o inadequada do algoritmo ECDSA - eles tinham um aleat√≥rio est√°tico que tornava a fun√ß√£o do al√ßap√£o solucion√°vel.  O OpenSSL tamb√©m sofreu no ano seguinte, no entanto, corrigindo rapidamente a vulnerabilidade que permitia a recupera√ß√£o de uma chave privada com a ajuda de um ataque de tempo, para obter mais informa√ß√µes, consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo original</a> . <br><br>  Em 2013, na confer√™ncia da RSA, um grupo de pesquisadores apresentou sua ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">falha aleat√≥ria!</a>  Artigo sobre vulnerabilidades da classe Java SecureRandom.  Meio ano depois, ele chegou √†s carteiras do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bitcoin</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Android</a> , criadas usando PRNG criptograficamente seguro. <br><br>  Devido a s√©rias vulnerabilidades seriais descobertas, no mesmo m√™s de agosto de 2013, a IETF lan√ßou uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC 6979</a> , descrevendo uma gera√ß√£o determin√≠stica de k usada na cria√ß√£o da chave.  Poder√≠amos dizer que essa medida corrigiu o problema, mas n√£o o iremos - a qualquer momento os pesquisadores poder√£o encontrar problemas em v√°rias implementa√ß√µes devido a um desvio desnecess√°rio das especifica√ß√µes do protocolo. <br><br>  Sobre a NSA.  Se voc√™ n√£o ouviu falar da hist√≥ria do Dual_EC_DRBG - reserve um tempo e leia os artigos correspondentes, n√£o se arrepender√° de entrar em detalhes.  Edward Snowden faz parte dessa hist√≥ria porque as revela√ß√µes de 2013 provaram as suspeitas anteriores.  Isso resultou em muitos cript√≥grafos proeminentes perdendo a confian√ßa no NIST desde que a organiza√ß√£o projetou e descreveu muitas das curvas e algoritmos adicionais subjacentes ao ECDSA. <br><br>  A curva 25519 de Daniel Bernstein e a fun√ß√£o DH s√£o a resposta para esses dois problemas e, como descrevemos anteriormente, a transi√ß√£o para o EdDSA √© lenta, embora evidente.  Mesmo com as curvas do NIST, nenhuma evid√™ncia de sua vulnerabilidade foi encontrada ainda e, como j√° mencionamos, a experi√™ncia relacionada ao acaso tem sido bastante instrutiva. <br><br>  Para concluir esta parte, queremos citar John von Neumann: "Qualquer pessoa que tente gerar n√∫meros aleat√≥rios por meios determin√≠sticos est√°, √© claro, vivendo em estado de pecado". <br><br><h3>  Um pouco de refer√™ncia </h3><br>  Usamos um servidor NGINX 1.16.0 com OpenSSL 1.1.1d para executar esses benchmarks com v√°rios certificados.  Como mencionamos anteriormente, atualmente o Let's Encrypt permite apenas os algoritmos prime256v1 e secp384r1 para solicita√ß√µes de assinatura de certificados e n√£o fornece certificados ECDSA raiz e intermedi√°rios, provavelmente trabalhando nesse recurso no momento em que escrevemos este artigo. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de assinatura</b> </td><td>  <b>Apertos de m√£o por segundo</b> </td></tr><tr><td>  <b>ECDSA (prime256v1 / nistp256)</b> </td><td>  3358,6 </td></tr><tr><td>  <b>RSA 2048</b> </td><td>  972,5 </td></tr></tbody></table></div>  Como voc√™ pode ver, para um √∫nico n√∫cleo da CPU Intel¬Æ Xeon¬Æ Silver 4114 a 2,20GHz (lan√ßado no terceiro trimestre de 17), a diferen√ßa geral no desempenho do ECDSA, em compara√ß√£o com o amplamente adotado RSA 2048 √© de 3,5x. <br><br>  Agora, vamos dar uma olhada nos resultados de velocidade OpenSSL do mesmo processador com ECDSA e RSA. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de assinatura</b> <br></td><td>  <b>sinal</b> <br></td><td>  <b>verificar</b> <br></td><td>  <b>sinal / s</b> <br></td><td>  <b>verificar / s</b> <br></td></tr><tr><td>  <b>RSA 2048 bit</b> <br></td><td>  717 Œºs <br></td><td>  20,2 Œºs <br></td><td>  1393,9 <br></td><td>  49458,2 <br></td></tr><tr><td>  <b>ECDSA de 256 bits (nistp256)</b> <br></td><td>  25,7 Œºs <br></td><td>  81,8 Œºs <br></td><td>  38971,6 <br></td><td>  12227.1 <br></td></tr></tbody></table></div>  Aqui podemos ver uma confirma√ß√£o da tese anterior de diferentes custos computacionais para as opera√ß√µes de sinaliza√ß√£o e verifica√ß√£o do ECC e RSA.  Como resultado, atualmente equipado com TLS 1.3 ECC fornece um aumento significativo no desempenho no n√≠vel de seguran√ßa de bit mais alto, comparado com o RSA.  Essa √© a raz√£o mais substancial pela qual n√≥s, na Qrator Labs, incentivamos nossos clientes a adotar a ECDSA.  Com as CPUs modernas, voc√™ obt√©m quase a diferen√ßa de 5x em favor da ECDSA. <br><br>  Se voc√™ estiver interessado em saber como sua CPU executa c√°lculos criptogr√°ficos, voc√™ pode executar um simples comando <code>openssl speed</code> .  Os <code>-rsa</code> , <code>-ecdsa</code> e <code>-eddsa</code> forneceriam resultados de refer√™ncia para os algoritmos de assinatura correspondentes. <br><br><h3>  (Sobreposto) Futuro </h3><br><img src="https://pbs.twimg.com/media/CB4sHACVEAAYMyZ?format=jpg&amp;name=large" alt="imagem"><br>  Cr√©ditos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">djb</a> <br><br>  √â ir√¥nico que enquanto est√°vamos preparando este artigo, o Google anunciou " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alcan√ßar a supremacia qu√¢ntica</a> ".  Isso significa que estamos em perigo agora e tudo o que foi desenvolvido at√© esse momento n√£o fornece segredo? <br><br>  Bem, n√£o. <br><br>  Como Bruce Schneier escreveu em seu ensaio para a IEEE Security and Privacy " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criptografia ap√≥s as terras alien√≠genas</a> ", um enorme golpe com um computador qu√¢ntico poderoso o suficiente poderia ser causado √† criptografia de chave p√∫blica (assim√©trica).  A criptografia sim√©trica ainda seria forte. <br><br>  Queremos citar Bruce Schneier com o seguinte: <br><blockquote>  H√° mais um cen√°rio futuro a considerar, que n√£o requer um computador qu√¢ntico.  Embora existam v√°rias teorias matem√°ticas que sustentam a via √∫nica que usamos na criptografia, provar que a validade dessas teorias √© de fato um dos grandes problemas em aberto na ci√™ncia da computa√ß√£o.  Assim como √© poss√≠vel para um criptografador inteligente encontrar um novo truque que facilita a quebra de um algoritmo espec√≠fico, podemos imaginar alien√≠genas com teoria matem√°tica suficiente para quebrar todos os algoritmos de criptografia.  Para n√≥s, hoje, isso √© rid√≠culo.  A criptografia de chave p√∫blica √© toda teoria dos n√∫meros e potencialmente vulner√°vel a alien√≠genas com maior inclina√ß√£o matem√°tica.  A criptografia sim√©trica √© tanta confus√£o n√£o-linear, t√£o f√°cil de tornar mais complexa e t√£o f√°cil de aumentar o comprimento da chave, que esse futuro √© inimagin√°vel.  Considere uma variante AES com um tamanho de bloco e chave de 512 bits e 128 rodadas.  A menos que a matem√°tica seja fundamentalmente diferente da nossa compreens√£o atual, isso estar√° seguro at√© que os computadores sejam feitos de algo que n√£o seja mat√©ria e ocupem algo que n√£o seja o espa√ßo. <br><br>  Mas se o inimagin√°vel acontecer, isso nos deixaria com criptografia baseada apenas na teoria da informa√ß√£o: blocos √∫nicos e suas variantes. </blockquote><br>  Essa √© a √°rea em que, exceto procurando falhas de implementa√ß√£o, a maioria dos problemas pode ser encontrada.  Se houver um grupo de matem√°ticos bem financiados, criptoanalistas / criptografadores e engenheiros de computa√ß√£o trabalhando para provar ou refutar alguns problemas matem√°ticos complexos extraordin√°rios (como P? = NP) e obter resultados substanciais at√© esse momento, podemos estar com problemas.  No entanto, √© improv√°vel que tais avan√ßos nas ci√™ncias da computa√ß√£o, nas teorias da informa√ß√£o e da computabilidade ocorram, pois esse fato escreveria os nomes de seus criadores nas p√°ginas da History e, especificamente, dos livros de Hist√≥ria da Internet, que n√£o t√™m pre√ßo para quem √© inteligente. .  Portanto, esse cen√°rio pode ser considerado quase imposs√≠vel. <br><br>  N√£o est√° claro se, nos pr√≥ximos 5 anos, haveria algum sucesso com a computa√ß√£o qu√¢ntica, embora j√° existam v√°rias primitivas de criptografia consideradas adequadas para o mundo p√≥s-qu√¢ntico: treli√ßas, curvas el√≠pticas supersingulares baseadas em isogenia, hashes e c√≥digos.  Por enquanto, os especialistas em seguran√ßa est√£o apenas experimentando com eles.  No entanto, n√£o h√° d√∫vida de que, no caso de uma necessidade, a humanidade empregaria rapidamente tais algoritmos em escala de massa. <br><br>  Por enquanto, a criptografia baseada em curva el√≠ptica parece se encaixar perfeitamente na d√©cada futura, fornecendo seguran√ßa e desempenho. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474810/">https://habr.com/ru/post/pt474810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474796/index.html">O que √© a Internet das coisas e como isso ajudar√° as empresas a ganhar mais?</a></li>
<li><a href="../pt474800/index.html">Desempenho no .NET Core</a></li>
<li><a href="../pt474804/index.html">Progresso tecnol√≥gico russo no esporte: interfaces neurais, c√¢meras IP, CRM esportivo e BigData de um carro de corrida</a></li>
<li><a href="../pt474806/index.html">UDP Flood do Google ou como n√£o privar todo o Youtube</a></li>
<li><a href="../pt474808/index.html">Vers√£o Rust 1.39.0: ass√≠ncrona / aguardada, atributos para par√¢metros de fun√ß√£o, novas fun√ß√µes constantes</a></li>
<li><a href="../pt474812/index.html">Shader n√£o √© m√°gico. Escrevendo shaders no Unity. Vertex Shaders</a></li>
<li><a href="../pt474814/index.html">Antiguidades: o mensageiro da decad√™ncia ou obsolesc√™ncia n√£o planejada</a></li>
<li><a href="../pt474816/index.html">Projetos para animais de estima√ß√£o - vida pequena</a></li>
<li><a href="../pt474818/index.html">Existem n√∫meros aleat√≥rios em CSS?</a></li>
<li><a href="../pt474822/index.html">WISE-PaaS - uma plataforma em nuvem para a Internet industrial das coisas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>