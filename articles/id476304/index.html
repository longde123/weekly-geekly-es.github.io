<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍑 👩🏻‍🤝‍👨🏾 👨🏿‍💼 Otentikasi dongle perangkat keras perangkat Linux pada sistem tingkat atas 🧀 ⏭️ 👩🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Industrial IoT adalah pemantauan, penjadwalan, dan otomatisasi sistem teknik fasilitas industri, bangunan, fasilitas bisnis. Sensor dari berbagai para...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otentikasi dongle perangkat keras perangkat Linux pada sistem tingkat atas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476304/">  Industrial IoT adalah pemantauan, penjadwalan, dan otomatisasi sistem teknik fasilitas industri, bangunan, fasilitas bisnis.  Sensor dari berbagai parameter, meter dan pengontrol mengumpulkan data dari objek-objek ini, misalnya, suhu dan kelembaban di ruang server, pembacaan meter air di gedung apartemen, tingkat karbon dioksida di kamar.  Pengendali memproses informasi ini dan mengirim semuanya ke "cloud". <br><br>  Wiren Board memproduksi pengontrol Linux untuk IoT industri.  Perangkat mengumpulkan data dari sumur minyak dan cabang bank, memantau iklim mikro di server dan supermarket.  Pengendali terintegrasi dengan sistem mitra perusahaan tingkat atas.  Sistem mengotentikasi perangkat - mereka mengerti bahwa mereka berbicara dengan sensor mereka, dan bukan dengan milik orang lain, dan kemudian mereka memberikan otorisasi.  Pada tahap ini, muncul masalah - ada ribuan pengendali, ratusan pelanggan, tetapi tidak ada sistem integrasi tunggal.  Metode tradisional sederhana, seperti pasangan login / kata sandi, rentan terhadap serangan dan tidak nyaman untuk digunakan. <br><br><img src="https://habrastorage.org/webt/sk/xm/mt/skxmmtcf6uhcrlm0xkcqilqwjuo.jpeg"><br><br>  Oleh karena itu, perusahaan mengembangkan otentikasi dalam sistem tingkat atas menggunakan kunci perangkat keras - berdasarkan kriptografi asimetris standar menggunakan elemen yang dilindungi perangkat keras untuk menyimpan kunci.  Sekarang sistem integrasi terpadu tidak diperlukan - otentikasi dan otorisasi dilindungi dan berfungsi di luar kotak.  <b>Evgeny Boger</b> akan memberi tahu Anda bagaimana melakukan ini: bagaimana mereka memilih "chip kripto", bagaimana mereka mengacaukannya ke perangkat keras dan Linux, bagaimana perpustakaan umum dan perangkat lunak dibuat untuk menjadi teman dengannya.  Penekanan khusus pada penyebaran: pengenalan inisialisasi perangkat dalam produksi, pengenalan dukungan untuk berbagai perangkat lunak tingkat atas, termasuk dalam perangkat orang lain dan perangkat tertutup. <br><a name="habracut"></a><br>  <b>Tentang pembicara:</b> <b>Eugene Boger</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">evgeny_boger</a> ) - CTO dan salah satu pendiri Wiren Board.  Terlibat dalam sistem tertanam dan, terutama, Linux tertanam. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tbXmNAs5IrM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Masalahnya </h2><br>  Untuk mulai dengan, apa yang kita lakukan dan dari mana masalah ini berasal.  Kami di Wiren Board mendesain dan memproduksi peralatan di Rusia.  Dulu disebut M2M, tapi sekarang - IOT industri.  Ini adalah otomatisasi sistem teknik bangunan, pemantauan dan penjadwalan.  Secara singkat, semua pekerjaan terlihat seperti ini: sensor dari berbagai parameter, aktuator, penghitung dan pengontrol (edge-computing atau IoT-gateway) mengumpulkan data yang berbeda dari objek, memprosesnya, mengeksekusi logika lokal, dan kemudian mengumpulkannya dalam satu pengiriman besar, pemantauan atau sistem kontrol . <br><br><img src="https://habrastorage.org/webt/ns/fh/xa/nsfhxa9qezcmcuuc9y8kijenyhw.jpeg"><br><br>  Kami tidak memiliki seluruh ekosistem, tidak seperti beberapa pesaing.  Kami memproduksi peralatan yang terintegrasi dengan beberapa sistem tingkat atas dari mitra kami.  Ada banyak perusahaan mitra dan mereka berbagi tanggung jawab.  Tanpa sarana teknis yang baik, integrasi tidak akan berfungsi - tidak bisa dinegosiasikan. <br><br>  Ada dua solusi sederhana untuk menyelesaikan masalah ini.  Yang pertama adalah <b>memberikan nama pengguna / kata sandi kepada klien</b> , seperti yang dilakukan semua orang, dan yang kedua adalah untuk <b>menghasilkan dan menjahit "rahasia" di tempat kerja</b> .  Kedua opsi tidak cocok untuk kami - saya akan memberi tahu Anda alasannya. <br><br><h2>  Solusi sederhana </h2><br>  <b>Solusi pertama adalah dengan mengeluarkan nama pengguna dan kata sandi untuk klien</b> .  Kita semua melakukannya hingga saat ini. <br><br>  Untuk mengotentikasi perangkat yang mengirim data ke beberapa sistem, Anda dapat membuat kunci rahasia - login / kata sandi kondisional ("rahasia").  Ini akan umum pada pengontrol dan pada sistem tingkat atas yang mengumpulkan data dari beberapa pengontrol. <br><br>  Sepasang nama pengguna / kata sandi ("rahasia" yang umum) harus diberikan kepada klien - perusahaan atau orang tersebut.  Seseorang harus menghasilkan pasangan rahasia, mengirimkannya melalui email, mengautentikasi klien dengan nomor akun.  Ini adalah prosedur standar - teknologi rendah. <br><br>  <b>Masalah</b>  Kami memiliki banyak sistem seperti itu.  Klien kami, dan dia dapat mengirim data ke sistem mitra kami.  Ini adalah interaksi yang kompleks antara semua pihak yang terlibat. <br><br>  Selain masalah banyak sistem, ada yang lain. <br><br><ul><li>  <b>Pengiriman buruk dan pengiriman ke pelanggan</b> . <br></li><li>  <b>Login dan kata sandi disimpan di server</b> .  Jika kita juga menyimpan hash, ini akan sedikit melindungi kita dari kebocoran.  Namun demikian, perasaan tidak menyenangkan muncul ketika kunci rahasia untuk semua pengontrol klien disimpan di server.  Beberapa dari mereka dapat menangani tugas-tugas penting: penerangan di luar ruangan, pemantauan rig minyak. <br></li><li>  <b>Sinkronisasi antar layanan</b> . <br></li><li>  <b>Kerugian pemulihan</b> .  Tidak jelas apa yang harus dilakukan jika kehilangan, ketika klien menghapus memori controller - dalam memori apa saya harus menulis?  Anda harus mengulanginya lagi. <br></li><li>  <b>Perlindungan terhadap penyalinan detail</b> .  Ada sistem pemantauan berbayar yang menyediakan layanan dan membebankan biaya berlangganan kepada pelanggan.  Saya tidak ingin pelanggan akhir dapat memintas sistem melalui kami - bayar satu kali, tetapi gunakan dua. <br></li></ul><br>  <b>Solusi kedua adalah menghasilkan dan menjahit "rahasia" dalam produksi</b> .  Ini merupakan peningkatan pada solusi sebelumnya. <br><br>  Skemanya adalah ini: kami, sebagai produsen pengontrol, pra-menghasilkan nama pengguna dan kata sandi untuk semua orang, menjahitnya ke dalam sistem kami dan memasukkannya ke dalam peralatan.  Login dan kata sandi dari peralatan tidak dapat dibaca atau diubah.  Ini lebih baik dari opsi sebelumnya, karena tidak memerlukan interaksi antar orang. <br><br>  <b>Masalahnya</b> .  Semua masalah tetap ada, kecuali yang pertama, tetapi yang utama adalah <b>sinkronisasi antara layanan dan intranet</b> .  Ada banyak layanan dan tidak jelas bagaimana menyinkronkannya - karena ini, kami tidak dapat mengimplementasikan solusi kedua.  Kami memiliki klien yang menggunakan peralatan di jaringan tertutup mereka.  Kami merilis pengontrol baru, menjualnya ke klien, dan sistemnya ditutup.  Sudah diatur, itu berfungsi sekali, dan sulit untuk menyampaikan "rahasia" lebih lanjut.  Laporkan dalam batch?  Semuanya rumit dalam organisasi, meskipun secara teknis sederhana. <br><br>  Kedua solusi tidak cocok untuk kita.  Karena itu, kami memutuskan untuk mengambil jalan yang berbeda.  Tetapi sebelum itu mereka memutuskan untuk menguraikan tujuan dan sasaran bersama. <br><br><h2>  Tugas dan Tujuan </h2><br>  Tugas umum pertama. <br><br>  <b>Otentikasi</b>  Ini adalah cara untuk memahami siapa yang berbicara dengan sistem tingkat atas, siapa yang sebenarnya terhubung ke sistem pengiriman. <br><br><blockquote>  Otentikasi tidak memberikan atau membatasi hak akses, tetapi cara memahami siapa yang berbicara kepada kami. </blockquote><br>  <b>Tugas mengirim data</b> .  Pengontrol kami adalah komputer Linux yang dirancang untuk tugas khusus.  Kami membutuhkan mereka untuk mengirim data ke sistem tingkat atas, terhubung melalui VPN.  Pada saat yang sama, kami ingin pengiriman berfungsi "di luar kotak" - tanpa pengaturan dan interaksi pelanggan kami dan pengguna akhir sistem dengan kami dan dengan pelanggan. <br><br>  <b>Tugas lainnya</b> .  Ini adalah koneksi yang andal, enkripsi saluran data, tetapi masalah terpisah adalah <b>otorisasi</b> .  Tugas otorisasi dikaitkan dengan layanan eksternal dan dibagi menjadi tiga bagian. <br><br><ul><li>  <b>Layanan pabrikan gratis</b> .  Berikan akses dengan nomor seri perangkat. <br></li><li>  <b>Daftar putih nomor seri</b> untuk layanan mitra kami - menautkan pembelian dan akses ke akun klien. <br></li><li>  <b>Lisensi</b>  Izinkan atau tolak akses berdasarkan opsi yang ditentukan dalam sertifikat. <br></li></ul><br>  Tujuan adalah apa yang ingin kita capai ketika kita memecahkan masalah. <br><br>  <b>Penerbitan dan pengiriman ke pelanggan</b> .  Tanpa partisipasi orang - informasi dijahit oleh robot dalam produksi. <br><br>  <b>Kerugian pemulihan</b> .  Kami ingin tidak ada kehilangan detail rahasia sama sekali. <br><br>  <b>Pengiriman dari produksi ke layanan</b> .  Kami ingin melakukannya tanpa itu, sehingga Anda tidak perlu mengirimkan apa pun ke layanan.  Saat meluncurkan peralatan baru, kami tidak ingin memperbarui basis data semua layanan yang harus mengotentikasi perangkat ini. <br><br>  <b>Penyimpanan di server</b> .  Dianjurkan untuk tidak menyimpan apa pun di sana. <br><br>  <b>Sinkronisasi antara layanan dan intranet</b> .  Disarankan juga untuk tidak menyinkronkan apa pun - karena kami tidak akan menyimpan apa pun. <br><br>  <b>Perlindungan terhadap penyalinan detail</b> .  Kami menginginkan sesuatu yang rahasia, untuk mana uang itu diambil, tidak mungkin untuk menyalin dan menerima secara gratis. <br><br><h2>  Tanda tangan digital bergegas untuk menyelamatkan </h2><br><blockquote>  Tanda tangan digital elektronik (EDS) adalah teknologi di mana semuanya bekerja untuk kita. </blockquote><br>  Ini seperti tanda tangan biasa, hanya digital.  EDS mudah diverifikasi, tetapi sulit dipalsukan.  Kebenaran umum kriptografi, yang sudah berusia puluhan tahun. <br><br>  Tanda tangan elektronik adalah sesuatu yang dapat dihitung dengan pesan jika Anda tahu kunci pribadi rahasia (kunci pribadi).  Jika Anda mengetahui kunci publik (kunci publik), mudah untuk memverifikasi bahwa tanda tangan elektronik untuk pesan itu benar.  Namanya jelas - masyarakat biasa memberi tahu semua orang, dan rahasianya hanya untuk orang yang menandatanganinya. <br><br><blockquote>  Semua tanda tangan dan kunci hanya angka. </blockquote><br>  Dalam kasus kami, ini adalah 32 byte data, yang bekerja pada "sihir" matematika.  Matematika memastikan tanda tangan itu mudah diverifikasi, tetapi sulit dipalsukan. <br><br>  Kami menggunakan tanda tangan ECDSA-256 + SHA-256: <br><br><ul><li> <code>e = HASH(m)</code> - fungsi hash kriptografis mengubah pesan m menjadi angka e; <br></li><li>  <code>private key (dA)</code> - nomor acak; <br></li><li>  <code>public key (QA)</code> - dihasilkan dari kunci pribadi, tetapi tidak sebaliknya; <br></li><li>  <code>signature (r,s) = sign(private key, e)</code> - tanda tangan; <br></li><li>  <code>verify(public key, signature, e)</code> - verifikasi tanda tangan. <br></li></ul><br><h3>  Otentikasi EDS.  Upaya pertama </h3><br>  Apa yang dapat dilakukan untuk tugas kita menggunakan mekanisme rumit ini, yang bekerja dengan satu arah secara sederhana dan yang sulit lainnya? <br><br>  <b>Penerbitan dan pengiriman ke pelanggan</b> .  Kami menghasilkan kunci pribadi acak untuk setiap perangkat dalam produksi.  Kami tidak memberi tahu siapa pun, karena kami bahkan tidak mengenalnya, dan kami menulis ke perangkat. <br><br>  <b>Pengiriman dari produksi ke layanan</b> .  Selanjutnya, kami hanya menggunakan kunci publik perangkat ini untuk otentikasi pada layanan.  Pada layanan, kami hanya menyimpan daftar kunci publik alih-alih kata sandi. <br><br>  Algoritma pemeriksaan kesehatan standar: <br><br><ul><li>  layanan mengirim pesan acak <code>m</code> ke controller; <br></li><li>  controller: <code>sign(private key, m)</code> ; <br></li><li>  controller mengirim tanda tangan ke layanan; <br></li><li>  layanan: <code>verify(public key, signature, m)</code> . <br></li></ul><br>  Satu-satunya hal yang kami putuskan dengan cara ini adalah bahwa kami <b>tidak lagi menyimpan "rahasia" umum pada layanan kami</b> dalam bentuk terbuka atau dalam cache.  Ini bukan yang kita inginkan. <br><br><h3>  Otentikasi EDS.  Upaya kedua </h3><br>  Kami tidak ingin menyimpan sesuatu di layanan.  Untuk mencapai ini, kami dapat memaksa perangkat kami untuk mengirim kunci publik mereka ke layanan. <br><br>  Pada tahap terakhir, kami memecahkan dua masalah.  Yang pertama - kami <b>memeriksa bahwa mereka memberikan kunci ke layanan</b> .  Kami memiliki kunci publik, yang berarti kami juga membuat kunci pribadi.  Yang kedua - kami memastikan bahwa <b>perangkat memiliki kunci pribadi</b> , yang terletak di suatu tempat di USB flash drive.  Jika perangkat dapat menandatangani sesuatu, maka itu memiliki kunci pribadi. <br><br>  Sekarang perangkat juga akan mengirim kunci publik ke layanan.  Bagaimana memeriksa bahwa tidak ada yang mencegatnya, tidak memalsukannya, dan semuanya bekerja? <br><br>  <b>Memeriksa kunci publik</b> .  Kami menciptakan diri kami sendiri kunci publik lainnya.  Dia akan menjadi kunci kita sebagai produsen.  Ini adalah kunci root "kunci pribadi kunci + kunci publik".  Dengan kunci rahasia root ini dalam produksi, kami akan menandatangani kunci publik perangkat dan kami akan menyimpan tanda tangan ini pada perangkat.  Perangkat harus mengirim kunci publik dan tanda tangan kunci publiknya ke layanan.  Sekarang layanan dapat memeriksa kunci publik perangkat.  Jika ditandatangani dengan kunci privat root, maka kami menerbitkan kunci ini. <br><br><blockquote>  Hanya pabrikan - kami dapat membuat dan menyimpan tanda tangan pada perangkat, tetapi memeriksa semuanya. </blockquote>  Kami menerbitkan kunci publik di situs di bagian "Kontak".  Siapa pun dapat mengambilnya dan memeriksa kunci publik perangkat yang mengirim perangkat ke layanan.  Kemudian Anda dapat memverifikasi bahwa perangkat itu sendiri memiliki kunci privatnya sendiri. <br><br>  Algoritma umum terlihat seperti ini. <br><br><ul><li>  <code>(once) random root private key</code> ; <br></li><li>  <code>factory: random device private key</code> ; <br></li><li>  <code>factory: sign(root private key, device public key) = signature_1</code> ; <br></li><li>  <code>device-&gt;service:  device public key + signature_1</code> ; <br></li><li> <code>service: verify(root public key, signature_1, device public key)?</code> <br> </li></ul><br><h3>  Hasil percobaan kedua </h3><br>  Kami memecahkan masalah dengan <b>pengiriman</b> ke klien - informasi dijahit di lokasi produksi, dan <b>tidak ada yang perlu dipulihkan</b> . <br><br>  Penting bagi kami untuk memecahkan masalah <b>pengiriman "rahasia" ke layanan tingkat atas</b> , karena semua yang perlu disimpan pada layanan adalah kunci publik pabrikan.  Seluruh kunci adalah 33 byte.  Dengan bantuan dan keajaiban matematika, Anda dapat terus membuat koneksi jabat tangan dan memverifikasi bahwa perangkat memiliki kunci pribadi yang sesuai. <br><br>  <b>Di server</b> kami hanya menyimpan kunci pabrikan (root public key). <br><br>  Kami tidak memiliki <b>sinkronisasi antara layanan dan intranet</b> , yang telah kami bicarakan.  Selain itu, kami tidak memiliki <b>perlindungan terhadap penyalinan detail</b> . <br><br>  Satu-satunya hal yang kami lupakan adalah <b>otentikasi</b> .  Perangkat mengirim kunci pribadi, dan kami memeriksa apakah kami melakukannya dan mengeluarkannya, dan memeriksa apakah perangkat itu memilikinya.  Tapi kami tidak tahu perangkat apa ini, dan kami memproduksi ribuan perangkat. <br><br>  Karena itu, kami menerapkan trik yang disebut "Sertifikat". <br><br><h2>  Otentikasi dan Sertifikat </h2><br>  Pada langkah ini, di semua keajaiban matematika dengan tanda tangan dan ceknya, kami menambahkan <b>informasi tambahan - sertifikat</b> .  Untuk melakukan ini, kami masuk ke pabrik tidak hanya kunci publik (kunci publik perangkat), tetapi kunci dengan informasi tambahan. <br><br>  Informasi tambahan dalam kasus kami. <br><br><ul><li>  Tanggal pembuatan dan pabrikan. <br></li><li>  Konfigurasi model dan perangkat keras. <br></li><li>  Nomor seri yang digunakan perangkat untuk mengautentikasi. <br></li><li>  Opsi: perangkat keras dan perangkat lunak.  Konfigurasi yang berbeda mungkin tidak berbeda secara fisik satu sama lain, tetapi sertifikat akan berisi informasi tentang apa yang dibayar klien. <br></li><li>  Nama pelanggan dan nomor akun. <br></li></ul><br>  Kami akan menandatangani semua informasi ini bersama dengan kunci publik dengan kunci publik kunci-kunci produsen kami.  Setelah itu, informasi akan masuk ke layanan dan mereka akan dapat memastikan bahwa itu benar.  Karena ini adalah layanan kami dan mitra kami, mereka mempercayai kami. <br><br><h3>  Status Sasaran </h3><br>  Informasi juga dijahit di pabrik, dan <b>pengiriman</b> ke layanan tidak diperlukan.  <b>Di server kami</b> hanya menyimpan kunci pabrikan. <br><br>  <b>Kerugian pemulihan</b> .  Kami menjahit semua informasi dari sertifikat ke dalam memori flash perangkat.  Secara teoritis, ini dapat secara tidak sengaja atau sengaja dihapus, tetapi tidak ada rahasia dalam informasi ini dalam sertifikat.  Bahkan tanda tangan itu sendiri bukan rahasia - ada kunci publik dan tanda tangan dengan kunci kami.  Satu-satunya rahasia dalam sertifikat adalah volume penjualan perangkat dengan opsi berbeda. <br><br>  Sertifikat dapat disimpan di pabrik dan dikirim ke klien jika hilang.  Klien jarang secara spesifik menghapus area layanan memori.  Biasanya kita melakukan ini selama prosedur pemulihan perangkat: perangkat tiba dari klien, benar-benar melewati inisialisasi, semuanya terhapus, diunduh lagi, dan sertifikat disalin dari database pabrik. <br><br>  Kami tidak memiliki <b>pemulihan</b> kerugian, perlindungan salinan, dan <b>sinkronisasi antara layanan</b> . <br><br>  <b>Pada tahap otentikasi,</b> kami menerima dan memverifikasi sertifikat.  Kami memahami perangkat apa itu - kami tahu pabrikan, model, dan nomor seri, apa yang bisa dan tidak bisa ia lakukan. <br><br><h3>  Login </h3><br>  Sertifikat memungkinkan Anda menyimpan informasi untuk otorisasi. <br><br>  <b>Layanan pabrikan gratis</b> .  Mengetahui nomor seri perangkat, Anda dapat memberikan akses ke semua orang.  Dalam layanan kami, kami memberikan akses ke semua pelanggan dasar kami. <br><br>  <b>Daftar putih nomor seri</b> .  Untuk layanan mitra kami, Anda dapat membuat tabel dengan daftar putih nomor seri: "Klien dengan mudah membeli dari kami dua pengendali dengan nomor seri seperti itu yang terkait dengan akunnya" <br><br>  <b>Lisensi</b>  Anda dapat menjual sesuatu di muka, dan kemudian mengizinkan atau menolak akses <b>berdasarkan opsi yang</b> ditentukan dalam sertifikat - pengontrol dengan lisensi untuk sistem X. <br><br>  Tidak ada basis umum antara layanan, pabrikan atau pabrikan sistem.  Semuanya bekerja secara eksklusif pada informasi dari pengontrol yang ditandatangani oleh kami, sebagai produsen, ketika diotentikasi dalam sistem. <br><br><h2>  Sertifikat Menengah </h2><br>  Masalah teknis lain yang kami selesaikan di jalan.  Dalam skema yang baru saja saya bicarakan, ada sertifikat root dari pabrikan - root private key.  Secara fisik diperlukan setiap kali Anda membuat perangkat.  Tetapi jika ada banyak perangkat, maka kunci ini membutuhkan akses konstan untuk lingkaran terbatas orang.  Ini buruk, karena jika Anda kehilangan itu, Anda harus memperbarui kunci publik di semua layanan, dan itu tidak boleh sampai ke penyerang.  Ini adalah masalah organisasi yang besar.  Tapi ada solusinya. <br><br><blockquote>  Kami memperkenalkan kunci perantara ke sejumlah perangkat yang tidak begitu menakutkan untuk hilang. </blockquote><br>  Kami melakukan hal yang sama, hanya rantai yang lebih panjang. <br><br><img src="https://habrastorage.org/webt/x-/mb/s3/x-mbs3xfmihxr-qjdmpm7f5buey.jpeg"><br><br>  Dengan sertifikat pabrikan, kami menandatangani kunci perantara.  Secara fisik, ini adalah "flash drive", yang diberikan kepada mandor di pabrik selama sehari.  Perangkat keras membatasi jumlah perangkat yang dapat ditandatangani oleh suatu tombol.  Di tengah skema, kami menambahkan sertifikat perantara, jika tidak, tidak ada yang berubah. <br><br><h2>  Amankan keystore </h2><br>  Dalam semua ini, kami tidak memiliki <b>perlindungan yang</b> cukup <b>untuk kunci pribadi perangkat</b> - ini masih merupakan file yang terletak pada USB flash drive.  Seorang penyerang dapat menyalinnya, tetapi kemungkinan besar mereka akan kehilangannya atau secara tidak sengaja membuka akses. <br><br>  Dalam kasus ideal, alangkah baiknya untuk melindungi kunci pribadi perangkat dari penyalinan - memasukkannya ke dalam kotak hitam. <br><br>  Kotak hitam melakukan 4 operasi: <br><br><ul><li>  di dalam dirinya sendiri menghasilkan kunci berdasarkan permintaan, tetapi tidak memberi; <br></li><li>  memberikan kunci publik; <br></li><li>  Menandatangani pesan <br></li><li>  memverifikasi tanda tangan. <br></li></ul><br><img src="https://habrastorage.org/webt/by/ck/zf/byckzfred-odhrigx-ayq2gkytk.jpeg"><br>  <i>Untuk memverifikasi tanda tangan, Anda hanya perlu kunci publik, sehingga tiga operasi sudah cukup.</i> <br><br>  Dalam pemahaman saya, ini harus menjadi solusi perangkat keras, sebaiknya terpisah dari prosesor.  Ada beberapa opsi, yang terbaik adalah <b>prosesor crypto khusus di dalam SoC</b> atau sebagai chip terpisah. <br><br>  Opsi kotak hitam pertama yang kami ulas adalah <b>modul CAAM</b> dalam prosesor NXP i.mx 6, 7, 8 yang kami gunakan.  Masalahnya adalah itu diimplementasikan secara programatik dalam Boot ROM prosesor. <br><br>  Ini mungkin mengandung bug yang dapat ditemukan dan bahkan dieksploitasi melalui fungsi prosesor lainnya.  Beberapa tahun yang lalu, lubang ditemukan dalam modul ini yang memungkinkan untuk memotong verifikasi tanda tangan saat mengunduh firmware.  Ini bukan fungsi yang kita butuhkan, tetapi sedimen tetap ada.  Masalah lain adalah bahwa sulit untuk mengimpor prosesor dengan modul ini ke Rusia, mereka perlu mengisi dokumen. <br><br>  Karena itu, kami mengambil chip yang terpisah.  Saya mengakui dengan jujur, saya mengandalkan fakta bahwa jika kita tidak bisa membawanya ke Rusia, kita akan menemukan sesuatu - chip itu kecil, harganya $ 1.  Tapi semuanya berjalan baik - mereka menemukan chip <b>Microchip ATECC</b> , yang sudah memiliki semua kertas. <br><br><h2>  Microchip ATECC608A </h2><br>  Ini adalah chip kecil terpisah yang harganya satu sen.  Chip terhubung melalui I2C - dua "kaki" prosesor, yang juga dapat Anda bagikan dengan perangkat lain.  Chip ini memiliki pinout standar.  Kami menggunakan chip di versi pertama peralatan dan hanya menyoldernya di atas chip lain dengan protokol dan pinout yang sama, karena standar. <br><br>  Chip dapat melakukan apa yang kita butuhkan dari chip seperti itu: baca tanda tangan, kunci toko, dan banyak lagi. <br><br><img src="https://habrastorage.org/webt/_h/sb/jb/_hsbjbw9dyvjo2ta5emvp_wuqk4.jpeg"><br><br>  Karakteristik <br><br><ul><li>  16 slot kunci; <br></li><li>  dapat membaca tanda tangan ECSDSA, hash, MAC, dan mengenkripsi AES, dapat DH; <br></li><li>  memiliki penghitung angka acak dan penghitung kriptografi; <br></li><li>  Lampiran: SOIC-8, DFN6; <br></li><li>  protokol: I2C, kawat tunggal; <br></li><li>  ~0.7$@1000pcs. <br></li></ul><br><h3>  Cara bekerja dengan sirkuit mikro </h3><br>  Ada <b>dokumentasi yang</b> layak <b>untuk itu</b> , tetapi di bawah NDA.  Jika Anda segera menulis ke gamma.spb.ru, maka mereka akan memberikannya kepada Anda dalam 2 minggu.  Jika di perusahaan lain - setelah 3 bulan.  Kami menulis kepada dua perusahaan, dan ketika kami telah melakukan segalanya, dealer Microchip lain menjawab kami. <br><br>  <b>Ada beberapa catatan aplikasi</b> dan lebih buruk dari rata-rata.  Ada <b>perangkat lunak</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub</a> - perpustakaan dengan HAL.  Lucu - dokumentasinya ada di bawah NDA, dan perangkat lunak yang tertulis di dalamnya ada di GitHub.  Perangkat lunak ini tidak mendukung Linux, tetapi mendukung Raspberry Pi dan Atmel MK - ini sedikit berbeda.  Para pengembang percaya bahwa pada semua peralatan hanya ada satu bus I2C, misalnya, kakinya disebut seperti pada Raspberry Pi. <br><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">integrasi</a> dengan <b>OpenSSL</b> - tidak bekerja dengan baik, tetapi itu berhasil.  <b>Tidak ada contoh di Linux</b> dan tidak ada pekerjaan dengan <b>personalisasi</b> . <br><br><h3>  Kustomisasi chip </h3><br><blockquote>  Personalisasi adalah sakit kepala terbesar dengan chip. </blockquote><br>  Masalahnya adalah chip dapat melakukan banyak hal.  Ini memiliki 16 slot di mana 16 kunci disimpan: data pengguna, atau kunci publik, atau penyimpanan sementara untuk slot lain - ada banyak opsi. <br><br>  Anda perlu entah bagaimana membatasi akses ke slot, dan ada juga banyak opsi konfigurasi: batasi dengan kata sandi, dengan otentikasi di slot lain, pada saat akses ke pabrik. <br><br><img src="https://habrastorage.org/webt/-a/du/mm/-adumml8w8ijipo3nbep8jz5nry.jpeg"><br>  <i>Di tabel, jenis kunci, akses baca dan tulis, hubungan antara slot - SlotConfig, KeyConfig.</i> <br><br>  Dalam topeng bit (16 bit) dari setiap kunci yang kita gunakan, ada angka yang berbeda di mana-mana. <br><br>  Yang paling menyedihkan adalah bahwa zona konfigurasi adalah satu kali, yang menetapkan fungsi slot.  Kami mengacaukan 50 chip sebelum melakukan semuanya dengan benar.  Chip hanya berfungsi <b>setelah mengunci konfigurasi</b> .  Secara terpisah, ada <b>kunci untuk slot individual</b> <br><br>  Tidak ada dokumentasi dalam contoh atau perangkat lunak.  Ada dokumentasi untuk bit individu, tetapi semuanya rumit di sana.  Dalam semua contoh dari Microchip tertulis: "Unduh blok seperti itu, dan entah bagaimana itu akan bekerja untuk Anda, seperti dalam contoh pengiriman data ke Amazon." <br><br>  Butuh banyak waktu, tetapi dalam prosesnya mereka membuat utilitas yang keren. <br><br><h3>  Utilitas Atecc-util </h3><br>  Ini adalah utilitas konsol yang dapat melakukan sebagian besar fungsi chip dan memungkinkan Anda untuk bekerja sedikit lebih mudah.  Ini tersedia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub di</a> bawah lisensi MIT. <br><br>  Utilitas menggunakan CryptoAuthLib.  Dia tahu cara bekerja lebih ramah dengan zona konfigurasi, dia tahu cara bekerja dengan SHA, MAC, ECDSA, DH.  Antarmukanya ramah batch, karena kami telah menciptakan utilitas untuk digunakan dalam skrip.  Fakta bahwa seseorang dapat menyebabkannya adalah fitur sampingan.  Utilitas dapat membuat daftar - rencana perintah: "Pertama, mempersonalisasikan zona ini, kemudian tuliskan kunci seperti itu." <br><br>  Contoh memanggil utilitas cukup mudah dibaca oleh manusia. <br><br><pre> <code class="plaintext hljs">atecc - b 10 - c 'serial' - c 'read-config /tmp/config.dump'</code> </pre> <br>  Utilitas ini dibangun di bawah Linux, di bawah AMD64 - itu ada dalam paket Debian. <br><br><img src="https://habrastorage.org/webt/lc/yr/bs/lcyrbsjcuggnfwuzetwwjy3auxg.jpeg"><br><br><h3>  Alat personalisasi lainnya </h3><br>  Kami memiliki pelat Excel untuk membaca bit.  Jika Anda menunjukkan kepada kami pemindaian NDA dengan Microchip, kami akan memberikannya kepada Anda. <br><br><img src="https://habrastorage.org/webt/gs/j5/r9/gsj5r9tr6ngrcascp8tqxdq6dla.jpeg"><br><br>  Kami membahas semuanya dengan tes, karena ada banyak opsi ketika Anda dapat melupakan sedikit dan beberapa perintah layanan akan membaca kunci pribadi Anda.  Tes menguji perangkat nyata.  Mereka beralih ke sirkuit mikro dan memeriksa konfigurasi yang benar pada perangkat: dapatkah slot ini dibaca, dapatkah tanda tangan dibuat? <br><br>  Sejalan dengan bit, kami membuat daftar jaminan bahwa perangkat ini harus memuaskan, dan memeriksa bagaimana semuanya bekerja.  Kami menggunakan <b>kerangka kelelawar</b> - hal yang sangat menarik.  Ini terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/wr/kd/op/wrkdopidmf6zn2ko70ue36p7fxc.jpeg"><br>  <i>Daftar tes sebagai contoh.</i>  <i>Yang atas dilewati, tetapi yang lebih rendah tidak.</i> <br><br><h3>  Pengaturan dalam perangkat </h3><br>  <b>Bagi kami sendiri, kami hanya menggunakan dua slot</b> untuk tugas yang saya bicarakan.  Di kedua kami menyimpan kunci pribadi perangkat.  Perbedaannya adalah bahwa yang pertama dikaitkan dengan <b>sertifikat permanen</b> , yang dikeluarkan pada tahun 1970 selama 200 tahun. <br><br>  Hal ini disebabkan oleh fakta bahwa dalam IoT waktu tidak selalu disinkronkan.  Infrastruktur sertifikat melibatkan verifikasi keabsahan sertifikat.  Jika sinkronisasi pada perangkat rusak, maka beberapa layanan penting mungkin gagal, misalnya, VPN. <br><br>  Oleh karena itu, <b>satu slot tidak terbatas - permanen</b> .  Ini dihasilkan sekali dan tidak berubah sepanjang umur perangkat.  Untuk kunci ini, sertifikat dihasilkan selama 200 tahun - untuk jaringan tertutup. <br><br>  Slot lain sedang diperbarui.  Masa berlaku sertifikat maksimum adalah satu tahun.  Ini dilakukan untuk berjaga-jaga seandainya ada sesuatu yang dikompromikan.  Kunci perangkat yang dapat diperbarui secara pribadi dihasilkan saat periode validitas sertifikat perangkat berakhir.  Digunakan untuk otentikasi di jaringan terbuka, diperbarui sebulan sekali atau kurang, bersama dengan sertifikat. <br><br>  <b>Untuk pengguna, kami menghasilkan berbagai kombinasi</b> , termasuk beberapa slot untuk kunci ECDSA pribadi.  Pengguna dapat membuat kunci mereka di slot terpisah jika mereka tidak mempercayai kunci pribadi kami.  Untuk ini, Anda hanya perlu mempercayai Microchip.  Pengguna dapat membaca tanda tangan, melakukan enkripsi - kami memberikan semua yang dapat dilakukan chip. <br><br>  Sejauh ini, sayangnya, belum ada yang menggunakan, tapi kami harap begitu. <br><br><h3>  Infrastruktur: Kunci Menengah </h3><br>  Saya sudah mengatakan bahwa pada beberapa titik kami menerapkan sertifikat perantara agar tidak bersinar dengan sertifikat root yang tidak boleh hilang.  Dia tidak pernah muncul di pabrik. <br><br><img src="https://habrastorage.org/webt/uh/m0/dl/uhm0dl6mdkegvzwl2avlsqpe7kc.jpeg"><br><br>  Sertifikat perantara fisik adalah chip ATECC508A.  Ini sedikit berbeda dari 608, tetapi pada 508 ada fungsi yang berguna untuk kunci, tetapi pada 608 tidak lagi ada. <br><br>  Chip terhubung melalui adaptor USB-I2C.  Ini adalah USBISP dengan firmware mungil-usb-i2c - seorang programmer yang dapat di-flash ke USB-I2C bridge.  Sertifikat perantara menandatangani sertifikat perangkat dengan kunci privat mereka. <br><br>  Dua fitur dari rangkaian mikro ternyata berguna bagi kami. <br><br>  <b>Slot perlindungan kata sandi perangkat keras</b> .  Chip dapat diprogram untuk membaca tanda tangan hanya jika dua kondisi terpenuhi: <br><br><ul><li>  ketika perangkat macet di komputer; <br></li><li>  kata sandi dimasukkan. <br></li></ul><br>  Kami memberikan mandor kepada produksi kunci menengah dan kata sandi untuk sejumlah pengontrol.  Karenanya, Anda perlu mencuri kunci dan kata sandi untuk mendapatkan akses.  Kami mendapat kesempatan ini secara gratis, tetapi meningkatkan keamanan sistem. <br><br>  <b>Batas perangkat keras pada jumlah penggunaan</b> .  Penghitung kriptografi di dalam hanya dapat meningkat.  Ketika mencapai batas yang telah ditentukan sekali, sirkuit mikro tidak menandatangani apa pun. <br><br><img src="https://habrastorage.org/webt/tm/qv/4-/tmqv4-eakpcudfupub3oy6nt9bw.jpeg"><br><br><h2>  OpenSSL pada klien </h2><br>  Mari kita pertimbangkan bagaimana semuanya bekerja pada klien.  Kami memiliki OpenSSL pada controller.  Kami tidak menemukan apa pun - ini TLS biasa, PKI biasa.  Kami juga membutuhkan perpustakaan klien.  Pada sebagian besar perangkat lunak Linux, ini digunakan untuk koneksi yang aman. <br><br>  Kami mengambil kode dari Microchip, menambahkannya sedikit, mendukung OpenSSL yang baru <br>  1.1.  Akibatnya, ia tahu cara bekerja dengan kunci perangkat keras - perangkat keras mendukung kata sandi untuk kunci pribadi. <br><br>  Itu terlihat seperti ini. <br><br><pre> <code class="plaintext hljs">openssl req -new -engine ateccx08 -keyform engine -key ATECCx08:00:04:C0:00 -subj "/CN=wirenboard-AP6V5MDG" -out device AP6V5MDG.csr</code> </pre> <br>  Ini adalah panggilan ke OpenSSL reguler dan instruksi untuk menggunakan modul engine yang sesuai.  Kuncinya diatur di sini: alamat, model, dan dua byte terakhir adalah jumlah slot yang digunakan.  Semuanya ditransmisikan seolah-olah itu adalah file kunci, tetapi itu bukan file - Anda harus masuk ke perangkat. <br><br><h2>  SSL di server </h2><br>  SSL apa pun berfungsi di server, termasuk OpenSSL.  Tidak diperlukan modifikasi dan custom build di sisi server.  Semua yang diperlukan di server adalah <b>untuk dapat memeriksa rantai bundel sertifikat</b> (sertifikat perangkat + sertifikat menengah), dan <b>menyimpan kunci publik kami</b> , yang kami publikasikan di situs - Wiren Board ROOT CA. <br><br>  TLS standar mengatakan bahwa kedua pihak harus saling mengautentikasi.    —   —   .    —    handshake. <br><br>         :    .    ,         .   letsencrypt    SSL,   ,      . <br><br>       ,    — MQTT. <br><br><h2> MQTT: mosquitto   </h2><br>          IBM.               . <br><br> Mosquitto —       ,   ,  Linux.    ,   OpenSSL engine (  )    «keyfile»,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   ,  20 . <br><br>     bundle. <br><br><img src="https://habrastorage.org/webt/ea/ju/ge/eajugei4pidm4h7ramzyhh-vpkq.jpeg"><br><br>             . <br><br><pre> <code class="plaintext hljs">mosquitto_sub -h mqtt.wirenboard.com -p 8884 -cert /etc/ssl/device/device_bundle.crt.pem --key 'engine:ateccx08:ATECCx08:00:04:C0:00' --capath /etc/ssl/certs/ -t /# -v</code> </pre> <br>     .     —    <code>-cert</code> .   bundle- — .      <code>--key</code> .       . <br><br>  ,    <code>--capath</code> ,    .       SSL-,     letsencrypt. <br><br>   <b> </b> . <br><br><pre> <code class="plaintext hljs">root@wirenboard-AXXVJI62:~# cat /etc/mosquitto/conf.d/bridge-hw.conf connection wb_devices_cloud.wirenboard-AXXVJI62 address contactless.ru:8884 bridge_capath /etc/ssl/certs/ bridge_certfile /etc/ssl/device/device_bundle.crt.pem bridge_keyfile engine:ateccx08:ATECCx08:00:04:C0:00 notifications true notification_topic /client/wirenboard-AXXVJI62/bridge_status topic/# both 1 ""/dient/wirenboard-AXXVJI62</code> </pre> <br> Mosquito-     . <br><br> <b>   Mosquitto</b> —    . <br><br><pre> <code class="plaintext hljs">per _listener_settings true listener 8884 0.0.0.0 cafile/etc/mosquitto/certs/WirenBoard_Root_CA.crt certfile /etc/letsencrypt/live/contactless.ru/fullchain.pem keyfile/etc/letsencrypt/live/contactless.ru/privkey.pem require.certificate true use_identity_as_username true password_file /etc/mosquitto/passwd.conf allow_anonymous false acl_file /etc/mosquitto/ad.conf :~$ cat /etc/mosquitto/acl.conf pattern write /client/%u/# pattern read /client/%u/#</code> </pre> <br>   —  . <br><br><ul><li>  Root CA  letsencrypt-   —   .     . <br></li><li>    Mosquitto.           <code>username</code>      MQTT. <br></li><li>  ,     , ,   (CN) wirenboard-AXXVJI62,   ,      . <br></li><li> <code>per_listener_settings:</code>   ,      / (&gt;1.5.5). <br></li></ul><br>    MQTT-  Wiren Board IoT Cloud Platform. <br><br><h2>  Openvpn </h2><br> OpenVPN  ,      ,     .   ,                . <br><br>  OpenVPN <b> </b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,   .       ,   : bundle,  , engine. <br><br><pre> <code class="plaintext hljs">openvpn --capath /etc/ssl/certs/ --cert /etc/ssl/device/device_bundle.crt.pem --key engine:ateccx08:ATECCx08:00:04:C0:00</code> </pre> <br> <b> </b>    letsencrypt. <br><br><pre> <code class="plaintext hljs">ca /etc/openvpn/WirenBoard_Root_CA.crt cert /etc/letsencrypt/live/vpn1.wirenboard.com/fullchain.pem key /etc/letsencrypt/live/vpn1.wirenboard.com/privkey.pem</code> </pre> <br>     —       .      -  . <br><br><h2> Nginx </h2><br>   . Nginx   ,    ,        , SSL.      nginx     web-,  reverse-proxy.   —      nginx. <br><br> nginx   ,  HTTP-,       .   ,       : Common Name,      ,        .   ,   400. <br><br><pre> <code class="plaintext hljs">ssl_client_certificate WirenBoard_Root_CA.crt; ssl_verify_client on;</code> </pre> <br> <b>nginx  </b> .     — ,     HTTP.  Linux-   nginx  ,        SSL,   ,   OpenSSL. <br><br>    wget  , bash    ,   HTTP-  TLS   .    10 . <br><br><pre> <code class="plaintext hljs">server { listen 8080; location / { proxy_pass https://example.com; proxy_ssl_name example.com; proxy_ssl_server_name on; proxy_ssl_certificate/etc/ssl/device/device_bundle.crt.pem; proxy_ssl_certificate_key engine:ateccx08;ATECCx08:00:04:C0:00; } }</code> </pre> <br><h2>   </h2><br>      <b>Wiren Board 6</b> ,     .     ,       . <br><br>         web-   cloud.wirenboard.com  OpenVPN  .     Grafana  InfluxDB,      MQTT.     saymon.info —    (MQTT)  . <br><br>      ,  -  ,     , Grafana, MQTT-,   ,  , .   — . <br><br>  ,    ,   : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> —  OpenSSL    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> —  .  ! <br><br><blockquote>           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">InoThings Conf 2019</a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YouTube-</a>       2019 .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  Telegram.     ,  ,       IoT. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476304/">https://habr.com/ru/post/id476304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476292/index.html">SVG atau kanvas?</a></li>
<li><a href="../id476294/index.html">Jaringan game yang didistribusikan sebagai alternatif untuk GFN: bagaimana dan mengapa itu bisa lepas landas, di mana ia sudah bekerja di Federasi Rusia</a></li>
<li><a href="../id476296/index.html">21 November, Rapat Rekayasa Produk: Siapa Insinyur Produk?</a></li>
<li><a href="../id476298/index.html">Pergi melalui duri untuk sepeda, bagian satu: mempelajari dasar-dasar menyesuaikan debugger Visual Studio menggunakan plugin</a></li>
<li><a href="../id476300/index.html">Majalah Tram adalah bintang yang terang dan cepat pudar dari avant-garde anak-anak Rusia</a></li>
<li><a href="../id476306/index.html">Instruksi TelegramBot untuk membuat fungsionalitas dasar untuk bot. (Bagian 1)</a></li>
<li><a href="../id476308/index.html">5 Praktik Pengembangan Perangkat Lunak Teratas yang Diikuti pada tahun 2020</a></li>
<li><a href="../id476310/index.html">CRM wajah manusia</a></li>
<li><a href="../id476312/index.html">Bereaksi atau Angular atau Vue.js - apa yang harus dipilih?</a></li>
<li><a href="../id476316/index.html">Vue Storefront: Isi data dalam ES</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>