<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤ğŸ¿ â¬›ï¸ ğŸ›€ğŸ¾ n-Queens Completion Problem - algoritma solusi linier ğŸŒµ ğŸ‘‡ğŸ¼ ğŸš§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ericgrig 



 Kata Pengantar 
 Saya ingin memulai kata pengantar dengan kata-kata terima kasih kepada dua programmer yang hebat dari Odessa: Andrei Ki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>n-Queens Completion Problem - algoritma solusi linier</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483036/">  Ericgrig <br><p><br></p><h4>  Kata Pengantar </h4><br>  Saya ingin memulai kata pengantar dengan kata-kata terima kasih kepada dua programmer yang hebat dari Odessa: Andrei Kiper (Lohica) dan Timur Giorgadze (Luxoft), untuk verifikasi independen atas hasil saya, pada tahap awal penelitian. <br><br><ol><li>  Artikel "Algoritma linear untuk solusi n-Queens Completion Problem" diterbitkan di <a href="https://arxiv.org/pdf/1912.05935.pdf">(arXiv.org)</a> pada awal hari pertama tahun 2020.  Awalnya, artikel itu ditulis dalam bahasa Rusia, jadi presentasi dasar disajikan di sini, dan ada terjemahannya. </li><li>  Tugas ini, dan beberapa lainnya dari banyak set NP-Complete (tugas memuaskan formula Boolean (3-SAT), tugas untuk menemukan klik maksimum, atau klik dengan ukuran tertentu ...) pada waktu yang berbeda, berada dalam bidang yang saya minati.  Saya sedang mencari solusi algoritmik berdasarkan berbagai eksperimen komputasi, tetapi tidak ada keberhasilan konkret.  Itu seperti seseorang yang mencoba belajar bagaimana menjadi bugar di bar horizontal dengan satu tangan.  Tidak ada hasil, tetapi setiap kali ada harapan bahwa semuanya akan segera berhasil.  Terakhir kali saya memutuskan bahwa saya harus tinggal lebih lama pada tugas Penyelesaian n-Queens (sebagai salah satu anggota keluarga) dan mencoba melakukan sesuatu.  Di sini tepat untuk mengingat lelucon Odessa yang indah: "Di dalam bus yang penuh sesak yang kembali ke pinggiran kota di jalan bergelombang di malam hari, suara seorang wanita terdengar - Pria, jika Anda benar-benar memakainya, lakukan setidaknya sesuatu." </li><li>  Penelitian ini berlangsung cukup lama - hampir satu setengah tahun.  Di satu sisi, ini disebabkan oleh kenyataan bahwa tugas-tugas lain dipertimbangkan dalam proses penelitian, dan di sisi lain, ada pertanyaan-pertanyaan sulit di sepanjang jalan, yang tanpanya kami tidak bisa maju.  Saya akan membuat daftar beberapa di antaranya: <br><br><ul><li>  Ada n baris dalam matriks keputusan, dalam urutan apa indeks baris harus dipilih jika jumlah kemungkinan untuk pilihan seperti itu adalah n! </li><li>  ketika sebuah baris dibuat, yang mana dari posisi bebas yang tersisa di baris ini harus dipilih, karena jumlah kemungkinan untuk seleksi sedemikian besar sehingga dapat dianggap sebagai "kerabat dekat" tanpa batas (misalnya, jumlah cara yang mungkin untuk memilih posisi bebas di semua baris untuk papan catur ukuran 100) x 100 adalah sekitar 10 <sup>124</sup> ) </li><li>  Bersama-sama, kedua indikator ini membentuk ruang negara (ruang pilihan).  Tampaknya ada peluang besar, Anda dapat memilih apa yang Anda inginkan.  Namun di balik setiap pilihan spesifik pada setiap langkah, ada masalah lain - keterbatasan pilihan dalam semua langkah selanjutnya.  Selain itu, ini sangat sensitif pada tahap terakhir dari penyelesaian masalah.  Kita dapat mengatakan bahwa matriks keputusan itu "pendendam."  Semua "kesalahan tak sadar" yang Anda buat ketika membuat pilihan pada tahap sebelumnya adalah "terakumulasi", dan pada akhir keputusan ini dimanifestasikan dalam kenyataan bahwa di baris di mana Anda harus meletakkan ratu, tidak ada posisi kosong dan cabang pencarian terhenti. .  Di sini, seperti halnya Zhvanetsky: "satu langkah yang salah, dan Anda hamil." </li><li>  Ketika cabang pencarian solusi terhenti, kami memiliki kesempatan untuk kembali ke beberapa posisi sebelumnya (Back Tracking), sehingga dari posisi ini kami akan kembali membentuk cabang pencarian untuk solusi.  Ini adalah "properti" alami dari masalah non-deterministik.  Pertanyaannya adalah level mana yang sebelumnya harus dikembalikan.  Ini adalah masalah terbuka yang sama dengan pertanyaan memilih indeks baris, atau memilih posisi bebas di baris ini. </li><li>  Akhirnya, masalah yang berkaitan dengan kecepatan algoritma harus diperhatikan.  Alangkah menyedihkan jika tidak ada tujuan untuk membuat algoritma yang berjalan cepat.  Dalam proses pemodelan, tidak mungkin untuk mengembangkan satu algoritma yang akan bekerja dengan cepat dan efisien di semua bidang solusi masalah.  Saya harus mengembangkan tiga algoritma.  Mereka mengirimkan hasil satu sama lain, seperti tongkat.  Salah satunya bekerja sangat cepat, tetapi kasar, yang lain - sebaliknya, bekerja perlahan tapi efisien.  Masing-masing dari mereka bekerja di "zona tanggung jawab mereka". </li></ul></li><li>  Awalnya, tujuan dari penelitian ini hanya untuk menemukan setidaknya beberapa solusi.  Saya harus mencari tahu sebelum solusi pertama dikembangkan.  Butuh lebih dari empat bulan.  Itu mungkin untuk berhenti di sana, tujuannya tercapai - yah, oke.  Tetapi bagi saya tampaknya tidak semua kemungkinan solusi algoritmik untuk masalah ini telah habis.  Secara alami, ada keinginan untuk meningkatkan algoritma yang dikembangkan sehingga kompleksitas waktu dari algoritma itu linier-O (n).  Ketika solusi linear ditemukan, ada "satu keinginan lagi" - untuk mengurangi jumlah kasus ketika prosedur Pelacakan Kembali (BT) diterapkan ketika membentuk cabang pencarian solusi.  Itu adalah keinginan "kurang ajar" untuk mengalihkan tugas dari tidak deterministik ke ditentukan secara kondisional (sejauh mungkin).  Butuh banyak waktu, tetapi tujuannya tercapai, misalnya, dalam interval nilai ukuran papan catur n = (320, ..., 22500), jumlah kasus ketika prosedur BT tidak pernah digunakan lebih dari 50%.  Ternyata dalam 50% kasus ketika program diluncurkan, algoritma "sengaja" membentuk solusi, tidak pernah "tersandung".  (Mengingat dongeng tentang ikan mas, aku berhenti pada dua keinginan ini ...) </li><li>  Membandingkan publikasi yang berhasil saya kenali selama penelitian, saya sampai pada kesimpulan bahwa masalah ini dan masalah lain semacam ini tidak dapat diselesaikan berdasarkan pendekatan matematika yang ketat, yaitu, hanya berdasarkan definisi, pernyataan lemmas dan bukti teorema.  Ada "pernyataan filosofis" tentang ini dalam artikel ini.  Saya yakin bahwa banyak masalah dari banyak NP-Complete dapat diselesaikan hanya berdasarkan matematika algoritmik dengan menggunakan pemodelan komputer.  Kesimpulan seperti itu tidak berarti membatasi matematika, sebaliknya, itu berarti memperluas kemampuan matematika melalui pengembangan metode matematika algoritmik.  Untuk setiap keluarga masalah Anda perlu menggunakan pendekatan matematika Anda sendiri yang memadai.  (Mengapa menugaskan mahasiswa pascasarjana untuk menyelesaikan masalah dari keluarga NP-Complete tanpa menerapkan matematika algoritmik dan metode pemodelan komputer, jika diketahui bahwa tidak ada yang benar-benar akan datang dari usaha semacam itu). </li><li>  Algoritma apa saja (program) memiliki properti sederhana - baik itu berfungsi atau tidak!  Saya ingin menarik bagi anggota Komunitas Habro kami yang memiliki komputer dengan Matlab diinstal di zona aksesibilitas.  Saya ingin meminta Anda untuk menguji operasi algoritma yang dipertimbangkan untuk menyelesaikan <i>Masalah Penyelesaian n-Queens</i> .  Ini akan memakan waktu hanya 5-10 menit.  Untuk menguji algoritme, Anda perlu mengikuti beberapa langkah sederhana: <br><br><ul><li>  Hasilkan komposisi acak dari <i>k</i> queens dan periksa kebenaran komposisi ini. </li><li>  Berdasarkan algoritma keputusan yang diusulkan, isi komposisi ini hingga solusi lengkap.  Atau program harus memutuskan bahwa komposisi ini tidak memiliki solusi. </li><li>  Periksa kebenaran solusi yang diperoleh sebagai hasil dari konfigurasi. </li></ul><br><br>  Anda tidak harus menulis kode apa pun untuk pengujian semacam itu.  Selain program utama, saya menyiapkan dua program lagi dalam bahasa Matlab: <br><br>  1. <i>Generarion_k_Queens_Composition</i> - pembuatan komposisi acak ukuran <i>k</i> untuk papan catur acak berukuran <i>nxn</i> <br><br>  2. <i>Completion_k_Queens_Composition.m</i> - menyelesaikan komposisi sewenang-wenang hingga keputusan lengkap, atau memutuskan bahwa komposisi ini tidak memiliki solusi ( <b>program utama</b> ). <br><br>  3. <i>Validation_n_Queens_Solution.m</i> - memeriksa kebenaran solusi dari <i>Masalah n-Queens</i> , atau kebenaran komposisi <i>k</i> queens. <br><br>  Mereka bekerja sangat cepat.  Misalnya, untuk papan catur, yang ukurannya <i>1000 x 1000</i> sel, total waktu yang dibutuhkan rata-rata untuk menghasilkan komposisi sewenang-wenang (0,0015 dt.), Lengkapi komposisi ini (0,0622 dt.), Dan verifikasi kebenaran solusi yang diperoleh (0,0003 dt.) tidak melebihi 0,1 detik.  (tidak termasuk waktu yang diperlukan untuk mengunduh data, atau menyimpan hasilnya) <br><br>  Email saya (ericgrig@gmail.com), jika Anda memiliki kesempatan untuk membantu teman, saya akan segera mengirimkan kepada Anda tiga program ini.  Saya akan berterima kasih kepada semua kolega saya yang secara objektif dapat menguji algoritma dan mengungkapkan pendapat mereka dalam diskusi. </li><li>  Saya menyiapkan kode sumber program, dengan komentar terperinci, yang, saya harap, akan segera diterbitkan di HabrÃ©.  Saya pikir mereka yang tertarik untuk menyelesaikan masalah kompleks dari keluarga <i>NP-Complete</i> akan menemukan sesuatu yang menarik untuk diri mereka sendiri. </li><li>  Saya ingin memohon lagi kepada anggota Komunitas Habr, tetapi untuk alasan yang berbeda.  Di sini, di Marseilles (Prancis), pembentukan tim <i>Grup Perancis Lipat</i> sedang berlangsung, yang tujuannya adalah untuk meneliti dan mengembangkan algoritma untuk memprediksi sifat fisikokimia senyawa berat molekul tinggi.  Saya pikir itu tidak layak untuk mengatakan bahwa ini adalah tugas yang agak sulit, dengan sejarah yang panjang, dan bahwa tim serius di berbagai negara sedang mengerjakan masalah ini, termasuk tim <i>Khasabis</i> dari <i>Deep Mind</i> (Anda dapat melihat artikel tentang HabrÃ© <a href="https://habr.com/ru/post/431948/">(habr.com_Folding)</a> . Tujuannya adalah untuk menciptakan tim yang kuat yang tidak takut untuk menyelesaikan masalah yang kompleks. Bentuk organisasi kerja bersama didistribusikan. Setiap anggota tim tinggal di kotanya dan bekerja pada proyek di waktu luangnya dari pekerjaan utamanya. Kita membutuhkan programmer dan peneliti (fisikawan, kimiawan, ahli matematika, ahli biologi) ), dll.  osto "sembrono" programmer- (kuadrat). Tuliskan saya jika Anda merasa menarik, di atas adalah email saya. Secara lebih rinci saya bisa kirim dalam surat tanggapan. </li></ol><br>  Kata pengantar untuk artikel itu ternyata sepanjang artikel itu sendiri.  Format presentasi keluarga tentang HabrÃ© memungkinkan saya untuk mengekspresikan pikiran saya lebih bebas, tetapi menilai dari ukurannya, saya memanfaatkannya dengan cukup bebas.  Saya ingin menulis sebentar, tetapi "ternyata seperti biasa." <br><br>  PS Saya berpikir bahwa anggota Komunitas Habr akan tertarik untuk mengetahui kesulitan apa yang saya temui ketika mencoba untuk mempublikasikan hasil penelitian.  Ketika artikel itu disiapkan, saya memformatnya ke dalam format .tex sesuai dengan persyaratan Journal of Artificial Intelligence Research (JAIR) dan mengirimkannya ke sana.  Dulu ada publikasi tentang topik serupa.  Dari catatan khusus adalah artikel <i>C. Gent, I.-P.</i>  <i>Jefferson dan P. Nightingale (2017)</i> <a href="https://jair.org/index.php/jair/article/view/11079/26262">(Kompleksitas penyelesaian n-queens)</a> , di mana penulis membuktikan bahwa masalah tersebut adalah milik set NP-Complete dan berbicara tentang kesulitan yang dihadapi dalam mencoba menyelesaikan masalah ini.  Dalam kesimpulan, penulis menulis: "Bagi siapa pun yang memahami aturan catur, n-Queens Completion mungkin menjadi salah satu masalah NP-Complete paling alami dari semua" ( <i>Untuk semua orang yang memahami aturan catur, tugas Penyelesaian n-Queens dapat menjadi salah satu dari tugas NP-Complete paling alami</i> ). <br><br>  Setelah 10 hari, saya menerima penolakan dari JAIR, dengan kata-kata: "artikel itu tidak sesuai dengan format jurnal", yaitu  bahkan tidak mengambil artikel untuk dipertimbangkan.  Saya tidak mengharapkan jawaban seperti itu.  Saya berpikir bahwa jika jurnal menerbitkan artikel yang penulis simpulkan bahwa sangat sulit untuk menyelesaikan masalah yang diberikan dan tidak memberikan solusi konkret, maka artikel yang menyediakan algoritma solusi yang efektif tentu akan diterima untuk dipertimbangkan.  Namun, redaksi memiliki pendapat sendiri tentang hal ini.  (Saya percaya bahwa spesialis yang kompeten bekerja di sana, dan kemungkinan besar mereka ditanyai dengan judul artikel â€œkurang ajarâ€ dan segala sesuatu yang dinyatakan di sana. Kami berpikir, â€œkemungkinan besar ada semacam kesalahan dan dengan lembut mengirim saya pergi, merujuk pada format "). <br><br>  Saya harus memilih publikasi ilmiah berkala peer-review lain tentang topik yang relevan.  Di sini saya dihadapkan dengan kenyataan pahit.  Faktanya adalah bahwa sekitar 80% dari semua majalah dibayar: baik saya harus membayar jumlah yang layak ke majalah sehingga artikel tersedia secara bebas untuk semua pembaca, atau mereka perlu memberikan artikel sebagai hadiah "di haluan", dan mereka akan membebankan biaya kepada semua orang yang ingin berkenalan dengan penelitian ini.  Dan opsi pertama dan kedua secara fundamental tidak dapat saya terima.  Saya merasa senang dengan metode raket penerbit ini ketika saya mencoba membiasakan diri dengan beberapa publikasi. <br><br>  Majalah berikutnya, yang menganut prinsip akses gratis ke informasi, adalah <i>SMAI Journal of Computational Mathematics</i> .  Mereka juga menolak dengan kata-kata yang sama, meskipun jauh lebih cepat - dalam dua hari. <br><br>  Kemudian sebuah jurnal dipilih: <i>Discrete Mathematics &amp; Theoretical Computer Science</i> .  Di sini persyaratannya sederhana, pertama Anda perlu menerbitkan artikel di arXiv.org, dan hanya setelah itu daftarkan artikel untuk dipertimbangkan.  Oke, kami akan mengikuti aturan - saya mengirimkan artikel di <i>arXiv.org</i> .  Mereka menulis kepada saya bahwa mereka akan menerbitkan artikel dalam 8 jam.  Namun, ini tidak terjadi setelah 8 jam, tidak setelah 8 hari.  Artikel itu "dipegang" oleh para mentor, dan hanya setelah 9 hari diterbitkan.  Tidak ada keluhan dalam bentuk dan esensi artikel.  Saya pikir, seperti dalam kasus JAIR, mentor memiliki keraguan tentang kemungkinan "melakukan ini dan menulis tentang itu."  Beberapa waktu kemudian, setelah memperbaiki kesalahan teknis, artikel itu diperbarui dan dalam bentuk akhirnya dirilis pada malam Tahun Baru. <br><br>  Saya harus membahas hal ini secara rinci untuk menunjukkan bahwa pada tahap publikasi hasil penelitian mungkin ada masalah yang tidak dapat dijelaskan secara logis. <br><br>  Berikut ini adalah artikel yang terjemahannya ke dalam bahasa Inggris diterbitkan di <a href="https://arxiv.org/pdf/1912.05935.pdf">(arXiv.org)</a> . <br><br><h3>  1. Pendahuluan </h3><br>  Di antara berbagai opsi untuk merumuskan <i>masalah</i> <i>n-Queens,</i> tugas <i>Penyelesaian n-Queens yang</i> bersangkutan memiliki posisi khusus karena kerumitannya.  Dalam karya mereka <a href="https://jair.org/index.php/jair/article/view/11079/26262">(Gent at all (2017))</a> menunjukkan bahwa <i>masalah Penyelesaian n-Queens</i> milik set <i>NP-Complete</i> ( <i>menunjukkan bahwa Penyelesaian n-Queens adalah NP-Complete dan # P-Complete</i> ).  Diasumsikan bahwa solusi untuk masalah ini dapat membuka jalan bagi kita untuk menyelesaikan beberapa masalah lain dari set <i>NP-Complete</i> . <br><br>  Masalahnya dirumuskan sebagai berikut.  Ada komposisi <i>k</i> ratu, yang secara konsisten didistribusikan di papan catur berukuran <i>nxn</i> .  Diperlukan untuk membuktikan bahwa komposisi ini dapat diselesaikan untuk solusi yang lengkap, dan memberikan setidaknya satu solusi, atau untuk membuktikan bahwa solusi seperti itu tidak ada.  Di sini, dengan konsistensi, yang kami maksud adalah komposisi <i>k</i> ratu yang memenuhi tiga kondisi masalah: di setiap baris, setiap kolom, dan juga diagonal kiri dan kanan melewati sel tempat ratu berada, tidak lebih dari satu ratu berada.  Masalah dalam bentuk ini pertama kali dirumuskan oleh <i>Nauk (1850)</i> . <br><br>  <b>1.1 Definisi</b> <br><br>  Selanjutnya, kita akan menunjukkan ukuran sisi papan catur dengan simbol <i>n</i> .  Sebuah solusi akan disebut lengkap jika semua <i>n</i> queens secara konsisten ditempatkan di papan catur.  Semua solusi lain, ketika jumlah <i>k</i> ratu yang ditempatkan dengan benar kurang dari <i>n</i> - kami akan memanggil komposisi.  Kami menyebut komposisi <i>k</i> ratu positif jika dapat diselesaikan sebelum solusi lengkap.  Karenanya, komposisi yang tidak dapat diselesaikan hingga solusi lengkap disebut negatif.  Sebagai analog dari "papan catur" ukuran <i>nxn</i> , kami juga akan mempertimbangkan "matriks solusi" ukuran <i>nxn</i> .  Sebagai contoh, semua algoritma yang dikembangkan untuk memecahkan masalah akan disajikan dalam bahasa Matlab. <br><br>  Penelitian dilakukan berdasarkan simulasi komputer (simulasi komputasi).  Untuk menguji hipotesis ini atau itu, kami melakukan eksperimen komputasi dalam berbagai nilai <i>n</i> = (10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 500, 800, 800, 1000, 3000, 3000, 5000, 10.000, 30.000, 50.000, 80.000, 10 <sup>5</sup> , 3 * 10 <sup>5</sup> , 5 * 10 <sup>5</sup> , 10 <sup>6</sup> , 3 * 10 <sup>6</sup> , 5 * 10 <sup>6</sup> , 10 <sup>7</sup> , 3 * 10 <sup>7</sup> , 5 * 10 <sup>7</sup> , 8 * 10 <sup>7</sup> , 10 <sup>8</sup> ) dan, tergantung pada nilai <i>n</i> , sampel yang cukup besar dihasilkan untuk analisis.  Kami menyebut daftar tersebut sebagai " <i>daftar dasar nilai n</i> " untuk melakukan eksperimen komputasi.  Semua perhitungan dilakukan pada komputer biasa.  Pada saat perakitan (awal 2013), itu adalah konfigurasi yang cukup sukses: <i>CPU - Intel Core i7-3820, 3,60 GH, RAM-32,0 GB, GPU-NVIDIA Ge Forse GTX 550 Ti, perangkat disk- ATA Intel SSD, SCSI, OS- Sistem Operasi 64-bit Windows 7 Professional</i> .  Kami menyebut kit ini secara sederhana - <i>desktop-13</i> . <br><br><h3>  2. Persiapan data </h3><br>  Algoritme dimulai dengan membaca file yang berisi array data satu dimensi tentang distribusi komposisi sewenang-wenang dari <i>k</i> queens.  Diasumsikan bahwa data disusun dengan cara berikut.  Biarkan ada array yang memusatkan perhatian <i>Q (i) = 0, i = (1, ..., n)</i> , di mana indeks sel-sel array ini sesuai dengan indeks baris matriks solusi.  Jika dalam beberapa baris arbitrer <i>i dari</i> matriks solusi ada ratu di posisi <i>j</i> , maka tugas <i>Q (i) = j</i> dilakukan.  Dengan demikian, ukuran komposisi <i>k</i> , akan sama dengan jumlah sel bukan nol dari array <i>Q.</i>  (Misalnya, <i>Q = (0, 0, 5, 0, 4, 0, 0, 3, 0, 0)</i> berarti bahwa kami mempertimbangkan komposisi <i>k = 3</i> ratu pada matriks <i>n = 10</i> , di mana ratu terletak di ke-3, Baris ke-5 dan ke-8, masing-masing di posisi: 5, 4, 3). <br><br><h3>  3. Algoritma untuk memverifikasi kebenaran solusi masalah n-Queens </h3><br>  Untuk penelitian, kami membutuhkan algoritma yang akan memungkinkan kami untuk menentukan kebenaran solusi dari masalah <i>n-Queens</i> dalam waktu singkat.  Mengontrol lokasi ratu di setiap baris dan setiap kolom sederhana.  Pertanyaannya adalah tentang batas diagonal.  Kita dapat membangun algoritma yang efektif untuk penghitungan seperti itu jika kita dapat memetakan setiap sel dari matriks solusi ke sel tertentu dari vektor kontrol tertentu yang akan secara unik mengkarakterisasi pengaruh pembatasan diagonal pada sel yang dimaksud.  Kemudian, berdasarkan apakah sel vektor kontrol bebas atau sibuk, kita dapat menilai apakah sel yang sesuai dari matriks keputusan bebas atau tertutup.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gagasan seperti itu pertama kali digunakan oleh </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sosic &amp; Gu (1990)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk memperhitungkan dan mengakumulasikan sejumlah situasi konflik antara berbagai posisi ratu. Kami menggunakan ide serupa dalam algoritme yang disajikan di bawah ini, tetapi hanya untuk memperhitungkan apakah sel matriks solusi bebas atau sibuk. Gambar 1, sebagai contoh, menunjukkan papan catur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 x 8 di</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atas yang urutan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sel </font><font style="vertical-align: inherit;">terletak di atas </font><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/webt/sx/0f/ws/sx0fwsydzdsy954rtlqpdwwigqg.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 1. Contoh demo dari korespondensi proyeksi diagonal dari sel-sel matriks ke sel-sel yang sesuai dari array kontrol </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 8) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangkan 15 sel pertama sebagai elemen dari vektor kontrol </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Proyeksi semua diagonal kiri dari sel mana pun dari matriks solusi jatuh ke dalam salah satu sel dari vektor kontrol </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Faktanya, semua proyeksi seperti itu terletak di dalam dua segmen garis paralel, yang satu menghubungkan sel dari matriks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(8.1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan sel pertama dari vektor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan yang kedua - sel dari matriks (1.8) dengan sel ke 15 dari vektor kontrol </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kami memberikan definisi yang sama untuk proyeksi diagonal kanan. Untuk melakukan ini, pindahkan titik asal dari sel 1 ke sel 9 ke kanan, dan pertimbangkan urutan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sel sebagai elemen dari vektor kontrol </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dalam gambar, ini adalah sel dari 9 ke 24). Proyeksi semua diagonal kanan dari sel mana pun dari matriks solusi akan jatuh ke salah satu sel dari vektor kontrol ini, mulai dari sel ke-2 hingga ke-16 (dalam gambar, dari 10 24). Di sini, semua proyeksi seperti itu terletak di antara dua segmen garis paralel - segmen yang menghubungkan sel (8,8) dari matriks solusi dengan sel 16 dari vektor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (sel 24 pada gambar) dan segmen yang menghubungkan sel (1,1) dari matriks solusi dengan sel 2 dari vektor kontrol </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (sel 10 pada gambar). Proyeksi semua sel dari matriks solusi terletak pada jatuh diagonal kiri yang sama ke dalam sel yang sama dari vektor kontrol </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, masing-masing, proyeksi semua sel dari matriks solusi yang terletak pada diagonal kanan yang sama jatuh ke dalam sel yang sama dari vektor kontrol kanan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dengan demikian, dua vektor kontrol ini </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , memungkinkan kontrol penuh semua penghambatan diagonal untuk setiap sel dari matriks keputusan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting untuk dicatat bahwa gagasan menggunakan proyeksi diagonal ke sel-sel vektor kontrol untuk menentukan apakah sel matriks solusi dengan koordinat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bebas atau sibuk </font><font style="vertical-align: inherit;">juga kemudian diimplementasikan dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richards (1997)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini menyediakan salah satu algoritma pencarian rekursif tercepat untuk semua solusi, berdasarkan operasi dengan sedikit topeng. Perbedaan penting adalah bahwa algoritma yang ditunjukkan dirancang untuk pencarian berurutan dari semua solusi, mulai dari baris pertama dari matriks solusi - turun, atau dari baris terakhir dari matriks - naik. Algoritma yang kami usulkan didasarkan pada kondisi bahwa pilihan jumlah setiap baris untuk lokasi ratu harus sewenang-wenang. Untuk algoritma yang dipertimbangkan, ini sangat penting. Perhatikan bahwa gambar di atas 1, kami membangun dengan analogi dengan apa yang diterbitkan dalam makalah ini. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suatu program untuk memeriksa apakah solusi yang diberikan dari masalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> benar, atau apakah komposisi yang diberikan dari </font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;"> benar</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ratu adalah sebagai berikut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Untuk mengontrol hambatan diagonal, buat dua array </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (1: n2)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (1: n2)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana n2 = 2 * n, dan sebuah array </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (1: n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mengontrol hunian kolom kolom dari matriks solusi. Hentikan tiga array ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Kami memperkenalkan penghitung jumlah ratu yang dipasang dengan benar ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totPos = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Secara konsisten, dalam satu siklus, mulai dari baris pertama, kami mempertimbangkan semua posisi ratu yang disediakan. Jika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q (i)&gt; 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka berdasarkan indeks baris </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan indeks posisi ratu di baris ini </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j = Q (i), kami</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> membentuk indeks yang sesuai untuk array kontrol </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i </font></font></i> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = j + i</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. Jika semua kondisi ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 0, D2 (t) = 0, B (j) = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">terpenuhi </font><font style="vertical-align: inherit;">, ini berarti bahwa sel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gratis dan tidak termasuk dalam zona proyeksi pembatasan diagonal yang dibentuk oleh ratu yang telah ditetapkan sebelumnya. Posisi ratu dalam posisi ini benar. Jika setidaknya salah satu dari kondisi ini tidak terpenuhi, maka pilihan posisi seperti itu akan salah, masing-masing, dan keputusan akan salah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Jika solusinya benar, maka </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambahkan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> penghitung jumlah ratu yang dipasang dengan benar ( </font><i><font style="vertical-align: inherit;">totPos = totPos + 1</font></i><font style="vertical-align: inherit;"> ), dan tutup sel yang sesuai dari array kontrol: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(D1 (r) = 1, D2 (t) = 1, B (j) = 1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jadi kami menutup semua sel di kolom</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan sel-sel dari matriks solusi yang terletak di sepanjang diagonal kiri dan kanan berpotongan di dalam sel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Ulangi prosedur verifikasi untuk semua posisi yang tersisa. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin ini adalah salah satu algoritma tercepat untuk mengevaluasi kebenaran solusi untuk masalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Waktu verifikasi satu juta posisi untuk matriks solusi 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desktop-13</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah 0,175 detik, yang kira-kira sama dengan waktu menekan tombol "Enter". </font><font style="vertical-align: inherit;">Jelas, algoritma ini linier sehubungan dengan penghitungan waktu sehubungan dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Deskripsi algoritma untuk memecahkan masalah </font></font></h3><br>  <b>Jenderal</b> .  <i>Masalah penyelesaian n-Queens</i> adalah <i>masalah</i> klasik non-deterministik.  Kesulitan utama solusinya terkait dengan masalah memilih indeks baris dan indeks posisi di baris ini, dalam kondisi ketika ruang keadaan sangat besar.  Saat mencari semua solusi yang mungkin, masalah seperti itu tidak muncul.  Kami harus mempertimbangkan semua cabang pencarian yang valid di ruang negara, dan urutan yang dianggap tidak masalah.  Namun, ketika komposisi sewenang-wenang dari <i>k</i> ratu perlu diselesaikan sampai solusi lengkap, maka dalam hal ini kita membutuhkan algoritma untuk memilih indeks baris dan kolom yang cukup memahami komposisi yang ada dan mengarah ke solusi lebih cepat daripada yang lain.  Dalam proyek ini, kami memutuskan pertanyaan pilihan berdasarkan posisi umum berikut - <i>jika kami tidak dapat merumuskan kondisi yang memberikan preferensi untuk setiap baris atau posisi apa pun di baris ini daripada yang lain, maka kami menggunakan algoritma pemilihan acak berdasarkan nomor acak yang didistribusikan secara merata</i> .  Metode seleksi acak serupa untuk memecahkan masalah di mana ruang negara sangat besar adalah sangat alami.  Salah satu edisi dari seri Prosiding <i>Workshop DIMACS (1999)</i> sepenuhnya dikhususkan untuk penggunaan seleksi acak dalam pengembangan algoritma untuk memecahkan masalah yang kompleks.  Implementasi yang benar dari algoritma pemilihan acak dapat menjadi solusi yang cukup produktif, meskipun ini adalah kondisi yang diperlukan tetapi tidak cukup untuk penyelesaian solusi.  <i>Sosic dan Gu (1990)</i> adalah salah satu studi pertama yang menggunakan algoritma pemilihan acak untuk menyelesaikan <i>Masalah n-Queens</i> .  Algoritma yang mereka teliti didasarkan pada ide yang cukup sederhana dan ringkas.  Biarkan ada urutan angka dari <i>1</i> hingga <i>n</i> , yang disusun ulang secara acak.  Seperangkat angka seperti itu memiliki sifat penting.  Terdiri dari fakta bahwa tidak peduli bagaimana angka-angka ini didistribusikan pada baris yang berbeda dari matriks solusi sebagai posisi ratu (satu angka per baris), dua aturan pertama akan selalu dipenuhi dalam pernyataan masalah: setiap baris dan setiap kolom tidak akan memiliki lebih dari satu ratu.  Namun, hanya sebagian dari posisi yang diperoleh akan bebas dari batasan diagonal.  Bagian lain akan berada dalam kondisi "konflik" dengan ratu yang sudah ada sebelumnya.  Untuk keluar dari situasi ini, penulis menggunakan metode membandingkan dan menukar posisi yang saling bertentangan untuk mendapatkan solusi yang lengkap.  Dalam algoritme yang kami usulkan, situasi konflik tidak mungkin, karena pada setiap langkah penyelesaian masalah, ratu dipasang di sel garis yang dipertanyakan hanya jika sel itu bebas. <br><br>  <b>4.1 Memilih Model untuk Pelacakan Kembali (BT)</b> <br><br>  Dalam proses menemukan solusi untuk suatu masalah, sebuah situasi mungkin muncul ketika rantai solusi berurutan mengarah ke jalan buntu.  Ini adalah properti "genetik" dari masalah non-deterministik.  Dalam hal ini, Anda harus kembali ke salah satu langkah sebelumnya, mengembalikan keadaan tugas sesuai dengan level ini dan mulai lagi mencari solusi dari posisi ini.  Pertanyaannya adalah level mana dari yang sebelumnya harus dikembalikan dan berapa level yang seharusnya (berdasarkan level, kami maksudkan langkah tertentu dalam menyelesaikan masalah dengan sejumlah ratu yang dipasang dengan benar).  Jelas, memilih level solusi untuk kembali sama relevannya dengan memilih indeks baris atau indeks posisi di baris itu.  Oleh karena itu, terlepas dari pendekatan untuk menyelesaikan masalah ini, perlu terlebih dahulu menentukan jumlah tingkat dasar untuk kembali, serta mekanisme dan kondisi untuk kembali ke salah satu tingkat ini.  Dalam algoritma yang kami usulkan, kami membagi matriks solusi menjadi tiga level dasar.  Ini adalah poin kembali.  Jika, sebagai akibat dari solusi, kebuntuan terjadi, maka, tergantung pada parameter tugas, kami kembali ke salah satu dari tiga level dasar ini.  Level dasar pertama ( <i>baseLevel1</i> ) sesuai dengan keadaan saat verifikasi data komposisi yang dimaksud selesai.  Ini adalah awal dari program.  Nilai dari dua level dasar berikut ( <i>baseLevel2</i> dan <i>baseLevel3</i> ) tergantung pada ukuran matriks <i>n</i> .  Ketergantungan empiris dari nilai-nilai dasar ini pada ukuran matriks solusi didirikan atas dasar sejumlah besar eksperimen komputasi.  Untuk representasi yang lebih akurat dari ketergantungan ini, kami membagi seluruh interval yang dipertimbangkan dari 7 hingga 10 <sup>8</sup> menjadi dua bagian.  Biarkan <i>u = log (n)</i> , lalu jika <i>n &lt;30 000</i> , maka <br><br>  <i>baseLevel2 = n - putaran (12.749568 * u3 - 46.535838 * u2 + 120.011829 * u - 89.600272)</i> <br>  <i>baseLevel3 = n - putaran (9.717958 * u3 - 46.144187 * u2 + 101.296409 * u - 50.669273)</i> <br><br>  jika tidak <br><br>  <i>baseLevel2 = n - bulat (-0.886344 * u3 + 56.136743 * u2 + 146.486415 * u + 227.967782)</i> <br>  <i>baseLevel3 = n - putaran (14.959815 * u3 - 253.661725 * u2 + 1584.713376 * u - 3060.691342)</i> <br><br>  <b>4.2 Struktur blok</b> <br><br>  Algoritma dibangun dalam bentuk urutan <i>lima blok peristiwa</i> , di mana setiap peristiwa dikaitkan dengan eksekusi bagian tertentu dari solusi untuk masalah tersebut.  Algoritma pemrosesan di setiap blok berbeda satu sama lain.  Hanya tiga dari lima blok yang berfungsi membentuk rantai solusi berurutan, dan dua blok lainnya merupakan persiapan.  Pilihan nomor blok tempat perhitungan dimulai tergantung pada nilai <i>n</i> dan pada hasil membandingkan ukuran komposisi <i>k</i> dengan nilai-nilai <i>baseLeve2</i> dan <i>baseLevel3</i> .  Pengecualian adalah interval nilai <i>n = (7, ..., 99)</i> , yang dapat disebut "zona turbulen" karena kekhasan perilaku algoritma di bagian ini.  Untuk nilai <i>n = (7, ..., 49)</i> , terlepas dari ukuran komposisi, setelah memasukkan dan memantau data, perhitungan dimulai dari blok ke-4.  Untuk nilai <i>n = (50, ..., 99)</i> , tergantung pada ukuran komposisi, perhitungan dimulai dari blok kedua atau dari keempat.  Seperti disebutkan di atas, pada setiap langkah penyelesaian masalah, hanya posisi-posisi dalam garis yang dianggap tidak termasuk dalam zona pembatasan yang dibuat oleh ratu yang telah didirikan sebelumnya.  Posisi inilah <i>yang disebut bebas</i> . <br>  Mari kita jelaskan secara singkat perhitungan apa yang dilakukan di masing-masing dari lima blok program ini. <br><br>  <b>4.3 Awal algoritma</b> <br><br>  Data dimasukkan dan komposisi diperiksa kebenarannya.  Pada setiap langkah verifikasi, sel-sel array kontrol diubah.  Jumlah ratu yang dipasang dengan benar dihitung.  Jika tidak ada kesalahan dalam komposisi, solusi berlanjut, jika tidak, pesan kesalahan ditampilkan.  Setelah verifikasi selesai, salinan array utama dibuat untuk digunakan kembali pada tingkat ini.  Setelah itu, kontrol ditransfer ke <i>Blok-1</i> . <br><br>  <b>4.4 Blok 1</b> <br><br>  Awal pembentukan cabang pencarian.  Kami menganggap <i>k</i> queens yang terletak di papan catur sebagai posisi awal.  Diperlukan untuk terus menyelesaikan komposisi ini dan menempatkan ratu di papan catur sampai jumlah totalnya sama dengan <i>baseLevel2</i> .  Algoritma yang digunakan di sini disebut <i>randSet &amp; randSet</i> .  Hal ini disebabkan oleh fakta bahwa di sini kita terus-menerus membandingkan dua daftar indeks acak, mencari pasangan yang bebas dari batasan diagonal yang sesuai.  Untuk melakukan ini, tindakan berikut dilakukan: <br><br>  a) dua daftar dibentuk: daftar indeks baris gratis dan daftar indeks kolom gratis; <br><br>  b) menyusun ulang angka secara acak di masing-masing daftar ini; <br><br>  c) dalam satu lingkaran, setiap pasangan nilai berturut-turut <i>(i, j)</i> , di mana indeks <i>(i)</i> dipilih dari daftar indeks baris gratis dan indeks <i>(j)</i> dari daftar indeks kolom gratis, dianggap sebagai posisi ratu potensial dan akan diperiksa apakah ini posisi di area proyeksi pengecualian diagonal. <br><br>  Jika aturan pengecualian diagonal tidak dilanggar, maka posisinya dianggap benar, dan ratu ditempatkan di posisi ini.  Setelah itu, penghitung bertambah untuk jumlah ratu yang dipasang dengan benar, dan sel-sel yang sesuai dari array kontrol diubah.  Jika posisi <i>(i, j)</i> jatuh ke zona pembatasan diagonal yang dibentuk oleh ratu yang ditetapkan sebelumnya, maka tidak ada perubahan dan transisi ke pertimbangan pasangan nilai berikutnya terjadi. <br><br>  Ketika siklus perbandingan semua pasangan daftar selesai, maka, berdasarkan indeks yang tersisa yang berada di zona pengecualian diagonal, daftar indeks baris bebas yang tersisa dan kolom bebas dibentuk lagi, dan prosedur ini diulangi hingga jumlah total ratu yang ditempatkan dengan benar <i>(totPos )</i> tidak akan sama dengan atau melebihi nilai batas <i>baseLevel2</i> .  Setelah kondisi ini dipenuhi, kontrol ditransfer ke <i>Blok-2</i> .  Jika ternyata sebagai hasil pencarian solusi, muncul situasi dari seluruh daftar indeks baris bebas dan kolom bebas yang tersisa, tidak ada pasangan yang cocok untuk lokasi ratu, maka dalam hal ini, nilai asli array kontrol dipulihkan berdasarkan salinan yang dibuat sebelumnya , dan kontrol ditransfer ke awal <i>Blok-1</i> untuk penghitungan ulang. <br><br>  <b>4.5 Blok 2</b> <br><br>  Blok ini berfungsi sebagai tahap persiapan untuk transisi ke <i>Blok-3</i> .  Pada level ini, jumlah baris bebas yang tersisa ( <i>freeRows</i> ) secara signifikan kurang dari <i>n</i> .  Ini memungkinkan Anda untuk mentransfer peristiwa dari matriks asli ukuran <i>nxn</i> ke matriks berukuran lebih kecil <i>L (1: freeRows, 1: freeRows)</i> .  Selain itu, berdasarkan pada informasi tentang baris bebas yang tersisa dan kolom bebas dalam matriks keputusan asli, nol dituliskan ke sel yang sesuai dari array <i>L</i> , yang menunjukkan bahwa sel-sel ini bebas.  Dengan transisi <i>"proyeksi" ini</i> , korespondensi indeks baris dan kolom dari matriks baru dengan indeks yang sesuai dari matriks asli dipertahankan.  Penting untuk dicatat bahwa meskipun, dalam proses penyelesaian masalah ini, semua peristiwa terungkap pada matriks awal ukuran <i>nxn</i> , dan matriks semacam itu adalah arena tindakan utama, dalam <i>kenyataannya matriks ini tidak dibuat</i> , dan hanya mengontrol array akuntansi untuk indeks baris <i>A (1: n)</i> dan kolom <i>B (1: n) dari</i> matriks ini. <br><br>  Bersama dengan array L, dua array yang bekerja <i>rAr (1: freeRows)</i> dan <i>tAr (1: freeRows)</i> juga dibentuk di blok ini untuk menyimpan indeks yang sesuai dari array kontrol <i>D1</i> dan <i>D2</i> .  Ini disebabkan oleh fakta bahwa ketika kita menginstal ratu berikutnya dalam sel <i>(i, j) dari</i> matriks awal ukuran <i>nxn</i> , maka setelah itu kita harus mengecualikan sel-sel dari array <i>L</i> yang jatuh ke zona proyeksi pengecualian diagonal dari array "besar" yang asli.  Karena kontrol kendala diagonal dilakukan hanya dalam matriks asli ukuran <i>nxn</i> , keberadaan array yang bekerja <i>rAr</i> dan <i>tAr</i> memungkinkan <i>kita</i> untuk mempertahankan korespondensi dan menerjemahkan sel terlarang ke batas array L. Ini sangat menyederhanakan penghitungan posisi yang dikecualikan. <br>  Setelah menyelesaikan pekerjaan persiapan di blok ini, salinan array utama dibuat untuk digunakan kembali pada tingkat ini, dan kontrol ditransfer ke <i>Blok-3</i> . <br><br>  <b>4.6 Blok 3</b> <br><br>  Di blok ini, pembentukan cabang pencarian solusi berlanjut berdasarkan data yang disiapkan di blok sebelumnya.  Jumlah baris di mana ratu diatur dengan benar sama dengan atau lebih besar dari <i>baseLevel-2</i> .  Anda harus terus memilih sampai jumlah ratu yang dipasang sama dengan <i>baseLevel-3</i> .  Di sini kita menggunakan algoritma pencarian <i>rand &amp; rand</i> solution, yaitu  untuk membentuk posisi ratu, alih-alih daftar indeks gratis, hanya dua indeks yang digunakan, nilai indeks acak dari baris bebas dan nilai indeks acak dari posisi bebas di baris ini.  Prosedur ini diulang secara siklis sampai jumlah total ratu yang ditempatkan sama dengan nilai <i>baseLevel-3</i> .  Segera setelah kondisi ini dipenuhi, kontrol dipindahkan ke <i>Blok-4</i> .  Jika, sebagai hasil perhitungan, cabang pencarian ternyata buntu, maka bagian formasi cabang pencarian ini ditutup dan kembali ke awal <i>Blok 3</i> , dari mana perhitungan diulangi lagi.  Untuk ini, nilai awal semua array kontrol dipulihkan. <br><br>  <b>4.7 Blok 4</b> <br><br>  Di blok ini, data disiapkan untuk transfer kontrol ke <i>Blok-5</i> .  Untuk langkah ini, setelah menyelesaikan prosedur di <i>Blok-3</i> , jumlah garis bebas ( <i>nRow</i> ) menjadi semakin sedikit.  Oleh karena itu, juga bermanfaat untuk menerjemahkan acara dari array yang lebih besar ke array yang lebih kecil.  Pendekatan ini memberi kita kesempatan untuk dengan cepat menentukan karakteristik yang diperlukan untuk garis yang tersisa yang kita butuhkan pada tahap ini.  Yang sangat penting adalah kenyataan bahwa berdasarkan array seperti itu, dimungkinkan untuk memprediksi prospek cabang pencarian untuk banyak langkah ke depan tanpa harus menyelesaikan perhitungan.  Kondisinya cukup sederhana.  Jika ternyata di antara garis bebas yang tersisa ada garis di mana tidak ada posisi bebas, maka cabang pencarian yang dipertimbangkan ditutup dan kontrol ditransfer ke salah satu blok tingkat bawah.  Tindakan persiapan yang dilakukan di sini sebagian besar mirip dengan apa yang dilakukan di <i>Blok-2</i> .  Berdasarkan indeks asli dari baris bebas dan kolom bebas, array 2 dimensi baru dibentuk, nilai nol yang sesuai dengan posisi bebas dalam matriks solusi asli.  Selain itu, array khusus <i>E (1: nRow, 1: nRow)</i> dibuat di blok ini, berdasarkan di mana Anda dapat menentukan jumlah posisi bebas di garis bebas yang tersisa yang akan ditutup jika Anda memilih posisi <i>(i, j)</i> untuk mengatur ratu dalam matriks sumber.  Sebelum mentransfer kontrol ke <i>Blok 5</i> , tindakan berikut dilakukan: <br><br>  a) jumlah posisi kosong di semua jalur yang tersisa ditentukan, <br><br>  b) array jumlah posisi bebas, untuk baris yang dimaksud, diurutkan dalam urutan menaik, <br><br>  c) jika semua jalur bebas yang tersisa memiliki posisi bebas (mis. nilai minimum dalam daftar peringkat ini berbeda dari 0), maka kontrol ditransfer ke Blok-5. <br><br>  Jika ternyata di salah satu baris yang tersisa tidak ada posisi bebas, maka array yang diperlukan dikembalikan berdasarkan salinan yang disimpan, dan, tergantung pada parameter tugas, kontrol ditransfer ke salah satu level dasar. <br><br>  d) salinan cadangan dari semua larik kontrol untuk tingkat 4 ini dibentuk. <br><br>  <b>4.8 Blok 5</b> <br><br>  Tahap ini adalah final, dan di sini, pembentukan cabang pencarian dilakukan lebih "seimbang" dan "rasional".  Ini adalah "last mile", hanya sejumlah kecil jalur bebas yang tersisa.  Tetapi pada saat yang sama, ini adalah bagian yang paling sulit.  Semua kesalahan yang berpotensi dilakukan pada tahap-tahap sebelumnya dari pembentukan cabang pencarian solusi, secara agregat muncul di sini - dalam bentuk kurangnya posisi bebas di garis. <br><br>  Algoritma dari blok ini dieksekusi atas dasar dua loop bersarang, di mana loop ketiga dieksekusi.  Fitur dari siklus ketiga adalah dapat diulangi, tanpa mengubah parameter dari dua siklus eksternal.  Ini terjadi jika cabang pencarian yang dihasilkan menemui jalan buntu.  Jumlah pengulangan seperti itu tidak melebihi nilai batas <i>repeatBound</i> , nilai optimal yang ditetapkan atas dasar eksperimen komputasi. <br><br>  Indeks loop luar dikaitkan dengan pilihan indeks baris berurutan yang tetap bebas setelah perhitungan di tingkat dasar ketiga.  Ini dilakukan berdasarkan daftar baris yang sebelumnya diperingkat dengan jumlah posisi bebas di baris.  Seleksi dimulai dengan garis, dengan jumlah minimum posisi bebas dan kemudian, dalam langkah-langkah berikutnya, dalam urutan menaik.  Di dalam siklus ini, siklus kedua terbentuk, indeks yang berulang atas indeks semua posisi bebas di baris yang dimaksud.  Tujuan dari siklus pertama hanya untuk memilih indeks dari salah satu garis bebas pada level ini.  Dengan demikian, tujuan dari siklus kedua hanya untuk memilih satu posisi bebas dalam garis yang dipertimbangkan.  Tindakan ini hanya terjadi pada tingkat dasar ketiga.  Setelah pilihan ini, jumlah ratu yang diinstal bertambah, dan sel-sel yang sesuai dari semua array kontrol diubah.  Selanjutnya, kontrol ditransfer dalam siklus bersarang (ketiga), zona aktivitas yang sudah semua jalur bebas yang tersisa.  Di dalam siklus ini, pilihan indeks baris dan pilihan posisi bebas di baris ini dilakukan berdasarkan aturan berikut: <br><br>  a) <b>Pilih jalur gratis</b> .  Semua garis bebas yang tersisa dipertimbangkan, dan jumlah posisi bebas ditentukan di setiap garis.  Baris dipilih dengan jumlah posisi bebas minimal.  Ini meminimalkan risiko yang terkait dengan kemungkinan mengecualikan posisi kosong terakhir di beberapa jalur yang tersisa di mana negara minimal dan kritis dalam hal jumlah posisi kosong ( <b>aturan risiko minimum</b> ).  Kebetulan, dengan aturan ini dalam pikiran bahwa indeks siklus pertama di blok kelima ini dimulai dengan pemilihan baris berurutan dengan nilai minimum jumlah posisi bebas dalam satu baris.  Jika pada beberapa langkah ternyata kedua garis memiliki jumlah posisi bebas minimum yang sama, maka indeks salah satu dari dua posisi yang tercantum pertama dalam daftar peringkat dipilih secara acak.  Jika jumlah baris yang memiliki jumlah minimum posisi bebas yang sama lebih dari dua, maka indeks salah satu dari tiga posisi yang terdaftar pertama dalam daftar peringkat dipilih secara acak. <br><br>  b) <b>Pemilihan posisi bebas berturut-turut</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari daftar semua posisi bebas pada baris yang dipermasalahkan, satu dipilih yang menyebabkan kerusakan minimal pada posisi kosong di semua baris yang tersisa. Ini dilakukan berdasarkan array E. yang dihasilkan sebelumnya. Dengan â€œkerusakan minimalâ€, kami maksudkan pilihan posisi seperti itu dalam garis yang diberikan yang mengecualikan paling sedikit jumlah posisi bebas di semua garis yang tersisa ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aturan kerusakan minimum)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Jika ternyata dua atau lebih posisi bebas berturut-turut memiliki nilai minimum yang sama sesuai dengan kriteria kerusakan, maka indeks salah satu dari dua posisi yang tercantum pertama dalam daftar dipilih secara acak. Memilih posisi yang mengecualikan jumlah minimum posisi bebas di garis yang tersisa meminimalkan "kerusakan" yang terkait dengan posisi ratu di posisi ini. Menggunakan kedua aturan ini memungkinkan penggunaan sumber daya yang lebih rasional di setiap langkah pembentukan cabang pencarian. Ini sangat mengurangi risiko dan meningkatkan kemungkinan memilih komposisi sewenang-wenang untuk solusi lengkap jika komposisi tersebut memiliki solusi. Jika pada beberapa langkah solusi ternyata di salah satu baris yang tersisa untuk dipertimbangkan tidak ada posisi kosong, maka cabang pencarian ini ditutup. Dalam hal ini,berdasarkan cadangan, semua larik kontrol dipulihkan, dan jika jumlah penghitung pengulangan tidak melebihi nilai batas</font></font><i>repeatBound</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kemudian tanpa mengubah indeks siklus eksternal pertama dan kedua, pekerjaan siklus bersarang ketiga diulangi lagi. Ini disebabkan oleh fakta bahwa dalam kasus-kasus di mana nilai minimum dari kriteria yang relevan bertepatan, kami membuat pilihan acak. Pembentukan kembali cabang pencarian pada kondisi yang sama pada tingkat dasar memungkinkan penggunaan "sumber daya awal" yang lebih efisien yang disediakan pada tingkat ini. Jumlah awal yang berulang dari siklus bersarang ketiga terbatas, dan jika nilai batas terlampaui, operasi siklus ini terputus. Setelah itu, nilai array kontrol dipulihkan, dan kontrol ditransfer ke siklus level dasar ketiga untuk menuju ke nilai indeks berikutnya. Prosedur ini diulang secara siklis sampai diperoleh solusi lengkap, atau ternyata demikianbahwa kami menggunakan semua jalur bebas dan semua posisi bebas di jalur ini di tingkat dasar ini. Dalam hal ini, tergantung pada jumlah total perhitungan berulang pada berbagai level dasar, dan dengan mempertimbangkan ukuran matriks keputusan dan ukuran komposisi, seseorang kembali ke salah satu level yang lebih rendah untuk perhitungan berulang, atau penilaian dibuat bahwa komposisi yang dimaksud tidak dapat dilengkapi untuk menyelesaikan solusi. Dalam program ini, untuk membatasi waktu total tagihan, dapat diterima bahwa proseduratau penilaian dibuat bahwa komposisi tersebut tidak dapat diselesaikan sampai keputusan lengkap. Dalam program ini, untuk membatasi waktu total tagihan, dapat diterima bahwa proseduratau penilaian dibuat bahwa komposisi tersebut tidak dapat diselesaikan sampai keputusan lengkap. Dalam program ini, untuk membatasi waktu total tagihan, dapat diterima bahwa prosedur</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelacakan Kembali</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , terlepas dari level mana sebelumnya yang dihasilkan, dapat dilakukan tidak lebih dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totSimBound</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kali. </font><font style="vertical-align: inherit;">Nilai batas ini dipilih berdasarkan eksperimen komputasi untuk berbagai nilai n.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Analisis efektivitas algoritma seleksi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efisiensi dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Untuk menganalisis kemampuan algoritma ini, percobaan komputasi dilakukan, yang terdiri dalam </font><font style="vertical-align: inherit;">menempatkan ratu dalam matriks solusi </font><font style="vertical-align: inherit;">berdasarkan pada model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selama kemungkinan ini ada. Segera setelah cabang pencarian mencapai jalan buntu, atau solusi lengkap diperoleh, ukuran komposisi, waktu solusi diperbaiki, dan tes diulangi lagi. Percobaan komputasi dilakukan untuk seluruh daftar dasar nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jumlah tes berulang untuk nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (30, 40, ..., 90, 100, 200, 300, 500, 800, 1000)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sama dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu juta</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , untuk nilai yang tersisa, jumlah tes, dengan peningkatan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, secara bertahap menurun dari 100000 menjadi 100. Analisis hasil eksperimen komputasi memungkinkan kita untuk menarik kesimpulan berikut: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Sebagai hasil dari hanya siklus pertama dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prosedur randSet &amp; randSet,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rata-rata sekitar 60% dari semua ratu ditempatkan dengan benar. Untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100, jumlah ratu yang ditempatkan dengan benar adalah 60,05%. Dengan peningkatan nilai n, nilai ini menurun secara bertahap, dan untuk n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berjumlah 59,97%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Histogram distribusi nilai panjang komposisi yang diperoleh memiliki bentuk yang sama, terlepas dari ukuran matriks keputusan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Selain itu, mereka semua memiliki fitur karakteristik - sisi kiri distribusi (dengan nilai modal) berbeda dari sisi kanan. Pada Gambar 2, sebagai contoh, histogram yang sesuai untuk </font></font><br><br><img src="https://habrastorage.org/webt/fu/h3/xy/fuh3xyqsx5ro7zx8ru7b66fliy8.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar. 2. Histogram distribusi solusi dari berbagai panjang untuk model randSet &amp; randSet ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100, ukuran sampel = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100. Tampaknya histogram dikumpulkan dari distribusi frekuensi dua peristiwa yang berbeda, karena frekuensi kejadian peristiwa di bagian kiri dan kanan distribusi berbeda. Untuk menggambarkan distribusi ini, kemungkinan besar cocok untuk menggunakan dua fungsi dari kepadatan distribusi normal, salah satunya mencakup interval ke nilai modal, yang lain - interval setelah nilai modal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Nilai rata-rata jumlah ratu ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) yang dapat diatur dalam matriks keputusan berdasarkan algoritma ini meningkat dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Seperti yang dapat dilihat dari Gambar 3, di mana grafik ketergantungan dari rasio </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada ukuran matriks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> disajikan </font><font style="vertical-align: inherit;">, rasio ini meningkat dengan peningkatan ukuran matriks. Misalnya, </font></font><br><img src="https://habrastorage.org/webt/wi/5b/kr/wi5bkrcaftlplvllyxfmek0lycg.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gbr. 3. Ketergantungan rasio </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk berbagai ukuran matriks solusi. Modelnya adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah nilai rata-rata dari panjang solusi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika untuk matriks ukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100x100,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algoritma untuk memilih posisi adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memungkinkan "tanpa henti" untuk menempatkan ratu rata-rata di 89 baris, maka untuk matriks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000x1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jumlah garis tersebut meningkat rata-rata menjadi 967. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d) Berdasarkan pada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma randSet &amp; randSet,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda bisa mendapatkan solusi lengkap, tetapi "produktivitas" dari pendekatan ini sangat rendah . Seperti dapat dilihat dari Gambar 4, untuk </font></font><br><br><img src="https://habrastorage.org/webt/7w/gt/jg/7wgtjgp2ria3lxqff4ouw9zqzpw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar. 4. Penurunan probabilitas untuk mendapatkan solusi lengkap dalam model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan peningkatan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 7, probabilitas untuk mendapatkan solusi lengkap adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,057</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Selanjutnya, dengan meningkatnya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">probabilitas mendapatkan solusi lengkap berkurang dengan cepat, mendekati nol secara asimptot. Mulai dari nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 48, probabilitas untuk mendapatkan solusi lengkap adalah di urutan 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Setelah nilai ambang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 70, untuk nilai-nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berikutnya </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> tidak satu solusi lengkap diperoleh (dengan jumlah tes sama dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu juta</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e) Model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menghasilkan cabang pencarian dengan kecepatan yang sangat tinggi. Untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000, waktu rata-rata untuk mendapatkan komposisi adalah 0,0015 detik. Panjang rata-rata komposisi adalah 967. Dengan demikian, untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">waktu rata-rata adalah 2,6754 detik dengan panjang lagu rata-rata 999793. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f) Kecuali untuk interval kecil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;= 70, ketika model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam kasus yang sangat langka dapat mengarah ke solusi yang lengkap, dalam semua kasus cabang keputusan berakhir dengan pembentukan komposisi negatif, yang tidak dapat diselesaikan sampai solusi lengkap. Jadi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini memiliki keuntungan penting - kecepatan tinggi pembentukan cabang pencarian, dan kelemahan yang signifikan adalah bahwa jika ukuran komposisi melebihi nilai ambang batas tertentu, algoritma ini mengarah pada pembentukan komposisi yang tidak dapat diselesaikan hingga solusi lengkap. Untuk mengatasi kelemahan ini, kami menghentikan pembentukan cabang pencarian ketika ambang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel-2 tercapai</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efisiensi algoritma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Untuk menentukan kemampuan algoritma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , simulasi komputer yang cukup rinci dilakukan untuk daftar dasar nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Seperti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">halnya model randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jumlah tes ulang dalam banyak kasus sama dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu juta</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Untuk nilai-nilai lain, jumlah tes secara bertahap menurun dari 100.000 menjadi 100. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua algoritma didasarkan pada prinsip seleksi acak. Oleh karena itu, harus diharapkan bahwa kesimpulan yang ditarik di sini pada dasarnya akan identik dengan kesimpulan yang dirumuskan untuk model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Namun, ada perbedaan mendasar di antara mereka, dan itu terdiri dari yang berikut: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak bekerja "keras" seperti model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika kita berbicara tentang "indeks penggunaan peluang yang disediakan secara rasional," model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada setiap langkah menggunakan sumber daya lebih rasional. Ini mengarah pada fakta bahwa, misalnya, pada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 30, probabilitas untuk mendapatkan solusi lengkap 0,00170 dalam model ini adalah 15 kali lebih besar dari nilai yang sama 0,00011 untuk model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Selain itu, di sini, hingga nilai ambang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 370, probabilitas untuk mendapatkan setidaknya satu solusi lengkap selama satu juta tes tetap. Setelah nilai ambang ini, untuk nilai selanjutnya dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan jumlah tes sama dengan satu juta, </font><font style="vertical-align: inherit;">tidak satu solusi lengkap diperoleh </font><font style="vertical-align: inherit;">berdasarkan model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) algoritma ini jauh lebih lambat daripada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika untuk</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000 untuk menghasilkan komposisi ukuran 967, waktu rata-rata untuk mendapatkan satu komposisi adalah 0,0497 detik, yaitu 33 lebih dari nilai yang sesuai 0,0015 untuk model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alasan perbedaan antara dua metode seleksi acak yang pada dasarnya serupa adalah karena kenyataan bahwa dalam model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , untuk mempercepat perhitungan, pemilihan acak dari daftar yang tersisa tidak dilakukan pada setiap langkah. Sebagai gantinya, sepasang indeks dipilih secara berurutan dari dua daftar, yang unsur-unsurnya disusun secara acak. Seleksi semacam itu tidak acak pada tingkat penuh, namun, itu cocok dengan logika masalah dan memungkinkan Anda untuk dengan cepat menghitung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk secara visual menunjukkan operasi algoritma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, percobaan berikut dilakukan: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Untuk papan catur ukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100x100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, setelah setiap langkah dari lokasi ratu dalam garis apa pun, jumlah posisi bebas di masing-masing garis bebas yang tersisa ditentukan. Dengan demikian, setelah setiap langkah menyelesaikan masalah, kami menerima daftar jalur bebas dan daftar terkait jumlah posisi bebas di jalur ini. Ini memungkinkan untuk membuat grafik di mana indeks kolom dari matriks tersebut diplot sepanjang sumbu absis, dan jumlah posisi bebas yang tersisa di sepanjang sumbu ordinat. Sebagai perbandingan, perhitungan juga dilakukan untuk model pemilihan posisi berurutan. Dengan pemilihan berurutan dimaksudkan sebagai berikut. Baris pertama dipertimbangkan, di mana posisi bebas pertama dalam daftar dipilih. Kemudian, baris kedua dipertimbangkan, di mana posisi bebas pertama dalam daftar, dll. Juga dipilih. Dalam Gambar 5 dan 6</font></font><br><br><img src="https://habrastorage.org/webt/y1/b5/vc/y1b5vcf2es-tsqteleekwvp5dly.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 5. Mengurangi jumlah posisi bebas di garis bebas yang tersisa setelah penempatan ratu. Pemilihan posisi secara teratur dan berurutan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil yang sesuai dengan model yang dipertimbangkan disajikan. Untuk kejelasan, grafik menunjukkan hasil hanya setelah langkah-langkah (10, 40, 60). Untuk model posisi pemilihan berurutan, yang terakhir adalah grafik setelah langkah ke-62, karena cabang pencarian berakhir karena kurangnya posisi bebas di baris ke-63. Di sisi lain, dalam model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , grafik terakhir disajikan setelah langkah ke-70 menempatkan ratu, meskipun di sini, jumlah rata-rata ratu yang ditempatkan dengan benar mencapai 89, yang merupakan 26 langkah lebih banyak daripada dalam model berurutan. Tampilan grafik yang aneh dalam model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">karena fakta bahwa indeks baris dipilih secara acak di antara baris bebas yang tersisa, dan oleh karena itu mereka tersebar secara acak di seluruh matriks solusi. Perbandingan kedua angka ini menunjukkan bahwa dalam model pemilihan posisi berurutan, kisaran variabilitas jumlah posisi bebas lebih tinggi daripada model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Hal ini disebabkan oleh fakta bahwa dengan seleksi reguler, kendala diagonal yang tidak seragam mengecualikan posisi bebas di baris yang tersisa, yang mengarah pada fakta bahwa dalam beberapa baris tingkat pengurangan jumlah posisi kosong lebih tinggi daripada di baris lainnya. </font></font><br><br><img src="https://habrastorage.org/webt/9y/mn/m6/9ymnm6wo_jsazg8_u474pjngke8.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 6. Mengurangi jumlah posisi bebas di garis bebas yang tersisa setelah penempatan ratu. Model penentuan posisi adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebaliknya, dengan pemilihan acak dari indeks baris bebas dan indeks kolom bebas, posisi ratu didistribusikan secara merata di atas "area" dari matriks keputusan, yang mengurangi tingkat "rata-rata" pengurangan jumlah posisi bebas di baris yang tersisa. Jadi, dengan mempertimbangkan kemampuan algoritma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kami menggunakannya dalam program untuk melanjutkan pembentukan cabang pencarian solusi sampai level </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel-3 tercapai</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu dicatat bahwa meskipun algoritma seleksi ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet, rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) tidak begitu efisien, kita masih harus menggunakan beberapa metode pemilihan acak lainnya ketika mengembangkan algoritma. Ini karena pernyataan masalahnya.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah penyelesaian n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika kita membayangkan bahwa ada algoritma optimal tertentu yang memecahkan masalah, maka pada input algoritma seperti itu akan selalu menerima seperangkat indeks baris dan kolom acak tertentu. Setiap kali itu akan menjadi kumpulan indeks baris dan kolom acak baru dari berbagai kemungkinan. Agar dapat "menerima" algoritma seperti berbagai komposisi acak, algoritma itu sendiri harus dibangun berdasarkan seleksi acak. Pencocokan harus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seperti kunci kunci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika kita membuat algoritma berdasarkan prinsip ini, maka komposisi yang konsisten dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ratu akan dianggap sebagai posisi awal (awal) dalam siklus pengambilan keputusan. </font><font style="vertical-align: inherit;">Dan lebih jauh, tujuannya hanya akan melanjutkan pembentukan cabang pencarian solusi sampai solusi untuk komposisi yang diberikan ditemukan, atau terbukti bahwa solusi seperti itu tidak ada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Contoh penggunaan aturan risiko minimum (n = 100) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap awal menemukan solusi, ketika jumlah posisi bebas di baris tidak kritis, maka pilihan indeks baris bebas, atau indeks posisi di baris ini, tidak fatal. Namun, pada tahap terakhir, ketika jumlah posisi bebas di beberapa baris adalah 1 atau 2, maka dalam hal ini, Anda harus memilih algoritma pemilihan yang berbeda. Pada level ini, algoritma pilihan acak </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak lagi berfungsi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alasan mengapa algoritma pemilihan acak tidak akan berfungsi dapat dijelaskan dengan contoh sederhana berikut ini. Biarkan pada beberapa langkah pemecahan masalah, untuk nilai n sembarang dari n, di baris tersisa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jumlah posisi kosong (ditunjukkan dalam tanda kurung) adalah: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (2), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (4), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (5), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (3), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (4)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dll. Jika Anda memilih secara acak baris mana pun, tetapi bukan baris </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana hanya ada satu posisi bebas, ini dapat menyebabkan situasi risiko ketika larangan diagonal terkait dengan posisi ratu di baris yang dipilih dapat menyebabkan penutupan satu-satunya posisi bebas di baris. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang akan menyebabkan solusi macet. Dari semua baris </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang paling rentan dan peka terhadap pilihan indeks baris adalah baris </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dalam situasi seperti itu, Anda harus terlebih dahulu memilih baris yang statusnya paling kritis dan menciptakan risiko untuk menyelesaikan masalah. Oleh karena itu, pada tahap terakhir penyelesaian masalah, pada setiap langkah perlu untuk memilih posisi garis berdasarkan algoritma sederhana dengan risiko minimal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk kejelasan, mari kita perhatikan, sebagai contoh, untuk matriks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100 x 100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tahap terakhir dalam pembentukan beberapa solusi nyata, setelah langkah ke-88. Hingga tugas selesai, 12 garis bebas tetap, untuk masing-masing jumlah posisi bebas ditemukan (garis-garis tersebut diperingkat dalam urutan peningkatan jumlah posisi bebas):</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah-89 - 25 (1), 12 (2), 22 (2), 82 (2), 88 (2), 7 (3), 64 (3), 3 (4), 76 (4), 91 (4), 4 (5), 96 (5)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - menunjukkan indeks garis bebas, dan dalam tanda kurung - jumlah posisi bebas di garis ini. Menurut aturan risiko minimum, pada langkah ke 89 untuk menyelesaikan masalah, baris 25 dipilih dan satu posisi bebas yang ada di dalamnya. Sebagai hasil penghitungan ulang, kami memiliki 11 jalur bebas tersisa: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah-90 - 7 (2), 12 (2), 22 (2), 82 (2), 88 (2), 3 (3), 64 (3), 76 (3), 4 (4), 91 (4), 96 (4).</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, jumlah posisi bebas di lima baris pertama adalah sama dan sama dengan 2. Oleh karena itu, indeks salah satu dari tiga baris pertama dipilih secara acak. </font><font style="vertical-align: inherit;">Dalam hal ini, baris ke-12 dipilih dan posisi dua yang tersisa di baris ini, yang mengarah ke kerusakan minimal. </font><font style="vertical-align: inherit;">Jadi, pada langkah ke-91 dari pembentukan larutan, kami memiliki 10 garis bebas: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah-91 - 22 (1), 3 (2), 7 (2), 82 (2), 88 (2), 64 (3) 76 (3), 91 (3), 4 (4), 96 (4)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pada langkah ini, baris 22 dipilih dan satu posisi bebas yang ada di dalamnya. </font><font style="vertical-align: inherit;">Melanjutkan dengan cara yang sama, urutan keputusan berikut ini dibentuk (Tabel 1). </font><font style="vertical-align: inherit;">Indeks dari baris yang dipilih ditampilkan dalam huruf tebal.</font></font><br><div class="scrollable-table"><table><caption> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel 1. Demonstrasi penggunaan aturan risiko minimum ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100).</font></font></b> <br></caption><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Langkah </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 89 </font></font></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25 (1)</font></font></b> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12 (2) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 22 (2) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 82 (2) </font></font></td><td> 7(3) </td><td> 64(3) </td><td> 3(4) </td><td> 76(4) </td><td> 91(4) </td><td> 4(5) </td><td> 96(5) </td></tr><tr><td> 90 </td><td> 7(2) </td><td> <b>12(2)</b> </td><td> 22(2) </td><td> 82(2) </td><td> 3(3) </td><td> 64(3) </td><td> 76(3) </td><td> 4(4) </td><td> 91(4) </td><td> 96(4) </td><td></td></tr><tr><td>  91 </td><td> <b>22(1)</b> </td><td> 3(2) </td><td> 7(2) </td><td> 82(2) </td><td> 64(3) </td><td> 76(3) </td><td> 91(3) </td><td> 4(4) </td><td> 96(4) </td><td></td><td></td></tr><tr><td>  92 </td><td> <b>88(1)</b> </td><td> 3(2) </td><td> 7(2) </td><td> 82(2) </td><td> 91(2) </td><td> 64(3) </td><td> 76(3) </td><td> 4(4) </td><td> 96(4) </td><td></td><td></td></tr><tr><td>  93 </td><td> <b>3(1)</b> </td><td> 7(2) </td><td> 76(2) </td><td> 82(2) </td><td> 91(2) </td><td> 4(3) </td><td> 64(3) </td><td> 96(4) </td><td></td><td></td><td></td></tr><tr><td>  94 </td><td> <b>76(1)</b> </td><td> 4(2) </td><td> 7(2) </td><td> 82(2) </td><td> 91(2) </td><td> 64(3) </td><td> 96(4) </td><td></td><td></td><td></td><td></td></tr><tr><td>  95 </td><td> <b>91(1)</b> </td><td> 7(2) </td><td> 82(2) </td><td> 64(3) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  96 </td><td> <b>4(1)</b> </td><td> 82(1) </td><td> 7(2) </td><td> 64(3) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  97 </td><td> <b>7(1)</b> </td><td> 82(1) </td><td> 64(2) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  98 </td><td> <b>82(1)</b> </td><td> 64(2) </td><td> 96(2) </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  99 </td><td> 64(1) </td><td> <b>96(1)</b> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  100 </td><td> <b>64(1)</b> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam contoh khusus ini, dalam 11 kasus dari 12, ada situasi ketika dalam daftar saluran bebas yang tersisa ada setidaknya satu baris di mana hanya satu posisi bebas yang tersisa. Jika kami tidak menggunakan aturan risiko minimum, kami tidak akan dapat mencapai tujuan. Karena satu "gerakan salah" dalam memilih indeks dari garis bebas, kemungkinan besar akan mengarah pada penghancuran satu-satunya posisi bebas yang ada di salah satu garis bebas yang tersisa. Ini adalah alasan bahwa ketika hanya menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma randSet x randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand x rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mendapatkan solusi yang lengkap, pada tahap terakhir, solusi tersebut menemui jalan buntu.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu dicatat bahwa algoritma risiko minimum memiliki makna sehari-hari yang sederhana, dan sering digunakan dalam pengambilan keputusan. </font><font style="vertical-align: inherit;">Sebagai contoh, dokter pertama-tama beroperasi pada pasien yang kondisinya paling kritis seumur hidup, seperti halnya petani, selama kekeringan parah, mencoba menyelamatkan tanaman, pertama-tama menyirami daerah-daerah yang berada dalam kondisi paling kritis ...</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Analisis efisiensi algoritma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengevaluasi efisiensi algoritma untuk berbagai nilai n, percobaan komputasi yang cukup panjang (dalam hal waktu total) dilakukan. Awalnya, algoritma yang cukup cepat dikembangkan untuk menghasilkan array solusi nQueens Problem untuk nilai arbitrer n. Kemudian, berdasarkan program ini, sampel besar solusi dibentuk untuk daftar dasar nilai n. Ukuran sampel yang diperoleh dari solusi nQueens Problem untuk berbagai nilai n, masing-masing, sama: (10) - 1000, (20, 30, ..., 90, 100, 200, 300, 500, 800, 800, 800, 1000, 3000, 5000, 10.000) - -10000, (30000, 50000, 80000) - 5000, (105, 3 * 105) - 3000, (5 * 105, 8 * 105, 106) - 1000, (3 * 106) - 300, ( 5 * 106) - 200, (10 * 106) - 100, (30 * 106) - 50, (50 * 106) - 30, (80 * 106, 100 * 106) - 20. Di sini, dalam tanda kurung, daftar nilai n ditunjukkan, dan tanda hubung ganda menunjukkan ukuran sampel dari solusi yang diperoleh.Setelah itu, komposisi acak dengan ukuran acak dibentuk berdasarkan masing-masing sampel larutan. Misalnya, untuk masing-masing 10.000 solusi untuk n = 1000, 100 komposisi acak ukuran arbitrer dibentuk. Hasilnya adalah sampel satu juta lagu. Karena setiap komposisi ukuran sewenang-wenang, yang dibentuk berdasarkan solusi yang ada, dapat diselesaikan setidaknya satu kali hingga solusi lengkap, tugasnya adalah menyelesaikan setiap komposisi dari sampel yang dihasilkan hingga solusi lengkap berdasarkan pada algoritma solusi masalah penyelesaian n-Queens Completion Problem . Karena dalam algoritma yang dipertimbangkan pada setiap langkah, penempatan ratu yang benar di papan catur diperiksa, di sini, pada prinsipnya, mereka tidak dapatkomposisi acak dengan ukuran acak dibentuk atas dasar masing-masing sampel larutan. Misalnya, untuk masing-masing 10.000 solusi untuk n = 1000, 100 komposisi acak ukuran arbitrer dibentuk. Hasilnya adalah sampel satu juta lagu. Karena setiap komposisi ukuran sewenang-wenang, yang dibentuk berdasarkan solusi yang ada, dapat diselesaikan setidaknya satu kali hingga solusi lengkap, tugasnya adalah menyelesaikan setiap komposisi dari sampel yang dihasilkan hingga solusi lengkap berdasarkan pada algoritma solusi masalah penyelesaian n-Queens Completion Problem . Karena dalam algoritma yang dipertimbangkan pada setiap langkah, penempatan ratu yang benar di papan catur diperiksa, di sini, pada prinsipnya, mereka tidak dapatkomposisi acak dengan ukuran acak dibentuk atas dasar masing-masing sampel larutan. Misalnya, untuk masing-masing 10.000 solusi untuk n = 1000, 100 komposisi acak ukuran arbitrer dibentuk. Hasilnya adalah sampel satu juta lagu. Karena setiap komposisi ukuran sewenang-wenang, dibentuk berdasarkan solusi yang ada, dapat diselesaikan setidaknya satu kali hingga solusi lengkap, tugasnya adalah untuk menyelesaikan setiap komposisi dari sampel yang dihasilkan ke solusi lengkap berdasarkan pada algoritma solusi masalah penyelesaian n-Queens Completion Problem . Karena dalam algoritma yang dipertimbangkan pada setiap langkah, penempatan ratu yang benar di papan catur diperiksa, di sini, pada prinsipnya, mereka tidak dapat100 komposisi acak ukuran acak dibentuk. Hasilnya adalah sampel satu juta lagu. Karena setiap komposisi ukuran sewenang-wenang, yang dibentuk berdasarkan solusi yang ada, dapat diselesaikan setidaknya satu kali hingga solusi lengkap, tugasnya adalah menyelesaikan setiap komposisi dari sampel yang dihasilkan hingga solusi lengkap berdasarkan pada algoritma solusi masalah penyelesaian n-Queens Completion Problem . Karena dalam algoritma yang dipertimbangkan pada setiap langkah, penempatan ratu yang benar di papan catur diperiksa, di sini, pada prinsipnya, mereka tidak dapat100 komposisi acak ukuran acak dibentuk. Hasilnya adalah sampel satu juta lagu. Karena setiap komposisi ukuran sewenang-wenang, yang dibentuk berdasarkan solusi yang ada, dapat diselesaikan setidaknya satu kali hingga solusi lengkap, tugasnya adalah menyelesaikan setiap komposisi dari sampel yang dihasilkan hingga solusi lengkap berdasarkan pada algoritma solusi masalah penyelesaian n-Queens Completion Problem . Karena dalam algoritma yang dipertimbangkan pada setiap langkah, penempatan ratu yang benar di papan catur diperiksa, di sini, pada prinsipnya, mereka tidak dapatmaka tugasnya adalah menyelesaikan setiap komposisi dari sampel yang dihasilkan, berdasarkan pada algoritma solusi Masalah penyelesaian n-Queens, menjadi solusi lengkap. Karena dalam algoritma yang dipertimbangkan pada setiap langkah, penempatan ratu yang benar di papan catur diperiksa, di sini, pada prinsipnya, mereka tidak dapatmaka tugasnya adalah menyelesaikan setiap komposisi dari sampel yang dihasilkan, berdasarkan pada algoritma solusi Masalah penyelesaian n-Queens, menjadi solusi lengkap. Karena dalam algoritma yang dipertimbangkan pada setiap langkah, penempatan ratu yang benar di papan catur diperiksa, di sini, pada prinsipnya, mereka tidak dapat</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keputusan </font><i><font style="vertical-align: inherit;">Positif Palsu</font></i><font style="vertical-align: inherit;"> (mis. Keputusan salah yang kami anggap salah, benar). Namun, mungkin ada </font><font style="vertical-align: inherit;">solusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">False Negative</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - dalam hal komposisi apa pun yang terbentuk berdasarkan solusi yang ada tidak diselesaikan oleh program sampai solusi selesai (walaupun kita tahu bahwa semua komposisi memiliki solusi). Melakukan eksperimen komputasi dalam rentang n nilai yang begitu luas, kami menetapkan sendiri sasaran berikut: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) untuk menentukan kompleksitas waktu dari algoritma, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) untuk menentukan probabilitas solusi Negatif Salah yang muncul untuk berbagai nilai n, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) untuk menentukan frekuensi penggunaan prosedur Pelacakan Kembali untuk nilai n yang berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil percobaan komputasi tersebut disajikan pada tabel 2.</font></font><br><div class="scrollable-table"><table><caption> <b> 2.         n.</b> <br> <i>n</i> â€“   ; <i>m</i> â€“   ; t <sub>mean</sub> , t <sub>min</sub> , t <sub>max</sub> â€“ ,     ; t90 <sub>mean</sub> â€“   ,    10%    ; FalseNeg( FalseNegative) â€“  ,      ; <i>t <sub>row</sub> = t <sub>mean</sub> *10 <sup>6</sup> / n</i> ,   10 <sup>6</sup>   ,            <i>nxn</i> . <br></caption><tbody><tr><th> n </th><th> m </th><th> t <sub>mean</sub> </th><th> t90 <sub>mean</sub> </th><th> t <sub>min</sub> </th><th> t <sub>max</sub> </th><th> FalseNeg </th><th> t <sub>row</sub> </th></tr><tr><td>  10 </td><td> 5000 </td><td> <b>0.001010</b> </td><td> 0.000532 </td><td> 0.000168 </td><td> 0.080673 </td><td>  2 </td><td> 1.0102 </td></tr><tr><td>  20 </td><td> 10 <sup>5</sup> </td><td> <b>0.003589</b> </td><td> 0.001809 </td><td> 0.000197 </td><td> 0.363096 </td><td>  5 </td><td> 1.7945 </td></tr><tr><td>  30 </td><td> 10 <sup>5</sup> </td><td> <b>0.008025</b> </td><td> 0.003793 </td><td> 0.000244 </td><td> 0.495716 </td><td>  10 </td><td> 2.6752 </td></tr><tr><td>  40 </td><td> 10 <sup>5</sup> </td><td> <b>0.014323</b> </td><td> 0.009127 </td><td> 0.000252 </td><td> 0.965817 </td><td>  7 </td><td> 3.5807 </td></tr><tr><td>  50 </td><td> 10 <sup>5</sup> </td><td> <b>0.005357</b> </td><td> 0.003589 </td><td> 0.000313 </td><td> 0.441711 </td><td>  9 </td><td> 10.7146 </td></tr><tr><td> 60 </td><td> 10 <sup>5</sup> </td><td> <b>0.005991</b> </td><td> 0.004103 </td><td> 0.000340 </td><td> 0.013738 </td><td>  10 </td><td> 9.9852 </td></tr><tr><td>  70 </td><td> 10 <sup>5</sup> </td><td> <b>0.006533</b> </td><td> 0.004566 </td><td> 0.000368 </td><td> 0.583897 </td><td>  8 </td><td> 9.3328 </td></tr><tr><td>  80 </td><td> 10 <sup>5</sup> </td><td> <b>0.006975</b> </td><td> 0.004987 </td><td> 0.000394 </td><td> 0.635676 </td><td>  7 </td><td> 8.7187 </td></tr><tr><td> 90 </td><td> 10 <sup>5</sup> </td><td> <b>0.006912</b> </td><td> 0.004763 </td><td> 0.000393 </td><td> 1.012710 </td><td>  4 </td><td> 7.6840 </td></tr><tr><td>  100 </td><td> 10 <sup>5</sup> </td><td> <b>0.007264</b> </td><td> 0.005107 </td><td> 0.000419 </td><td> 0.692387 </td><td>  4 </td><td> 7.2641 </td></tr><tr><td>  300 </td><td> 10 <sup>5</sup> </td><td> <b>0.013518</b> </td><td> 0.009496 </td><td> 0.000986 </td><td> 3.349766 </td><td>  3 </td><td> 4.5060 </td></tr><tr><td> 500 </td><td> 10 <sup>5</sup> </td><td> <b>0.028194</b> </td><td> 0.014554 </td><td> 0.001541 </td><td> 4.558749 </td><td>  2 </td><td> 5.6388 </td></tr><tr><td> 800 </td><td> 10 <sup>5</sup> </td><td> <b>0.049385</b> </td><td> 0.022735 </td><td> 0.002367 </td><td> 6.192782 </td><td>  1 </td><td> 6.1731 </td></tr><tr><td> 1000 </td><td> <b>10 <sup>6</sup></b> </td><td> <b>0.062157</b> </td><td> 0.027727 </td><td> 0.002943 </td><td> 8.015123 </td><td>  0 </td><td> 6.2156 </td></tr><tr><td> 3000 </td><td> 10 <sup>5</sup> </td><td> <b>0.177290</b> </td><td> 0.088507 </td><td> 0.008537 </td><td> 16.713140 </td><td>  0 </td><td> 5.9097 </td></tr><tr><td> 5000 </td><td> 10 <sup>5</sup> </td><td> <b>0.159239</b> </td><td> 0.136047 </td><td> 0.014224 </td><td> 42.181080 </td><td>  0 </td><td> 3.1849 </td></tr><tr><td> 10 <sup>4</sup> </td><td> 10 <sup>5</sup> </td><td> <b>0.321003</b> </td><td> 0.270927 </td><td> 0.028594 </td><td> 79.321174 </td><td>  0 </td><td> 3.2100 </td></tr><tr><td> 3*10 <sup>4</sup> </td><td> 10 <sup>4</sup> </td><td> <b>0.968795</b> </td><td> 0.651618 </td><td> 0.084936 </td><td> 139.28827 </td><td>  0 </td><td> 3.2293 </td></tr><tr><td> 5*10 <sup>4</sup> </td><td> 5000 </td><td> <b>1.147196</b> </td><td> 0.864045 </td><td> 0.143005 </td><td> 154.38225 </td><td>  0 </td><td> 2.2944 </td></tr><tr><td> 8*10 <sup>4</sup> </td><td> 4000 </td><td> <b>2.112079</b> </td><td> 1.215612 </td><td> 0.229532 </td><td> 204.27321 </td><td>  0 </td><td> 2.6401 </td></tr><tr><td> 10 <sup>5</sup> </td><td> 2000 </td><td> <b>2.253118</b> </td><td> 1.433197 </td><td> 0.290566 </td><td> 224.34623 </td><td>  0 </td><td> 2.2531 </td></tr><tr><td> 3*10 <sup>5</sup> </td><td> 2000 </td><td> <b>4.330649</b> </td><td> 3.181905 </td><td> 0.990932 </td><td> 340.29584 </td><td>  0 </td><td> 1.4435 </td></tr><tr><td> 5*10 <sup>5</sup> </td><td> 2000 </td><td> <b>5.985339</b> </td><td> 4.532205 </td><td> 1.488209 </td><td> 382.20016 </td><td>  0 </td><td> 1.1971 </td></tr><tr><td> 8*10 <sup>5</sup> </td><td> 2000 </td><td> <b>8.297512</b> </td><td> 6.554302 </td><td> 2.902425 </td><td> 75.87513 </td><td>  0 </td><td> 1.0372 </td></tr><tr><td> 10 <sup>6</sup> </td><td> 1000 </td><td> <b>11.376632</b> </td><td> 7.932194 </td><td> 2.954968 </td><td> 510.6265 </td><td>  0 </td><td> 1.1377 </td></tr><tr><td> 3*10 <sup>6</sup> </td><td> 400 </td><td> <b>23.138609</b> </td><td> 18.521503 </td><td> 10.433580 </td><td> 122.7597 </td><td>  0 </td><td> 0.7713 </td></tr><tr><td> 5*10 <sup>6</sup> </td><td>  300 </td><td> <b>33.103386</b> </td><td> 28.057816 </td><td> 14.937556 </td><td> 155.0890 </td><td>  0 </td><td> 0.6621 </td></tr><tr><td> 10*10 <sup>6</sup> </td><td> 200 </td><td> <b>61.444001</b> </td><td> 52.269241 </td><td> 31.624475 </td><td> 228.3087 </td><td>  0 </td><td> 0.6144 </td></tr><tr><td> 30*10 <sup>6</sup> </td><td>  50 </td><td> <b>149.71717</b> </td><td> 136.66441 </td><td> 84.556686 </td><td> 352.0534 </td><td>  0 </td><td> 0.4991 </td></tr><tr><td> 50*10 <sup>6</sup> </td><td>  40 </td><td> <b>253.86220</b> </td><td> 228.93732 </td><td> 105.37934 </td><td> 558.4629 </td><td>  0 </td><td> 0.5077 </td></tr><tr><td> 80*10 <sup>6</sup> </td><td>  30 </td><td> <b>372.29294</b> </td><td> 341.56397 </td><td> 250.80182 </td><td> 728.4806 </td><td>  0 </td><td> 0.4654 </td></tr><tr><td> 100*10 <sup>6</sup> </td><td>  20 </td><td> <b>508.43573</b> </td><td> 474.04890 </td><td> 354.80864 </td><td> 831.3753 </td><td>  0 </td><td> 0.5084 </td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan umum yang dapat ditarik berdasarkan hasil yang diperoleh adalah sebagai berikut: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Algoritma bekerja cukup cepat. Misalnya, waktu kompilasi rata-rata komposisi sewenang-wenang untuk papan catur ukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang diperoleh berdasarkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu juta</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eksperimen komputasi, adalah 0,062157 detik. Ini berarti bahwa jika komposisi memiliki solusi, maka akan segera ditemukan setelah menekan tombol </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Enter"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Waktu kompilasi rata-rata komposisi sewenang-wenang, untuk semua nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dalam kisaran 7 hingga 30.000, tidak melebihi satu detik.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Dalam setiap sampel, ada sekitar 10% komposisi, yang membutuhkan lebih banyak waktu untuk menyelesaikannya. Komposisi semacam itu membentuk ekor kanan panjang dalam histogram distribusi. Jika kita mengecualikan 10% komposisi ini dan melakukan perhitungan untuk sisa 90% solusi, maka waktu perhitungan ( </font><i><sub><font style="vertical-align: inherit;">rata-rata</font></sub></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t90</font></font><sub><font style="vertical-align: inherit;"></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) akan jauh lebih sedikit. Misalnya, untuk papan catur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , waktu penghitungan rata-rata adalah 0,027727 detik, yaitu 2,24 kali lebih kecil dari waktu rata-rata yang diperoleh dari seluruh sampel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Untuk nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nâ‰¤800</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dalam sampel komposisi ada yang tidak dapat diselesaikan sampai solusi lengkap. Ini adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">False Negative</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keputusan. Dalam batas yang ditentukan dalam program, yang memungkinkan prosedur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelacakan Kembali</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dilakukan </font><font style="vertical-align: inherit;">hingga 1000 kali, algoritma gagal menyelesaikan komposisi ini. Mereka secara keliru diklasifikasikan sebagai komposisi negatif, yaitu mereka yang tidak punya solusi. Jumlah </font><font style="vertical-align: inherit;">solusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Negatif Palsu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seperti </font><font style="vertical-align: inherit;">itu tidak signifikan, dan bagian mereka dalam sampel kurang dari 0,0001. Lebih lanjut, ketika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> meningkat </font><font style="vertical-align: inherit;">, proporsi </font><font style="vertical-align: inherit;">solusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Negatif Palsu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berkurang. Untuk semua nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; 800, dalam rangkaian eksperimen komputasi ini, tidak ada satu pun kasus </font><font style="vertical-align: inherit;">solusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Negatif Salah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Namun, jelas bahwa jika ukuran sampel meningkat berkali-kali, kemungkinan munculnya </font><i><font style="vertical-align: inherit;">False Negative</font></i><font style="vertical-align: inherit;"> tidak dikecualikan.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solusi, meskipun kemungkinan kejadian seperti itu akan menjadi jumlah yang sangat kecil. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompleksitas waktu dari algoritma</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Gambar 7 menunjukkan grafik perubahan waktu pengambilan rata-rata komposisi acak untuk berbagai nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/fe/lj/zy/feljzywqkqijg-0pftjholzx3es.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 7. Ketergantungan waktu pengambilan rata-rata ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dari komposisi acak pada ukuran ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dari matriks keputusan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logaritma desimal dari nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diplot pada sumbu absis </font><font style="vertical-align: inherit;">, dan logaritma, meningkat 1000 kali, dari waktu penghitungan rata-rata, diplot pada sumbu ordinat. Untuk kejelasan, gambar tersebut juga menunjukkan garis putus-putus dari diagonal kuadran. Dapat dilihat bahwa waktu pengambilan meningkat secara linear dengan peningkatan n. Seluruh rentang n dari 50 hingga 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai-nilai eksperimental dari waktu penghitungan membentuk garis lurus, yang dengan korelasi yang cukup tinggi ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = 0,9998</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dijelaskan oleh </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">log</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> persamaan regresi linier </font><i><font style="vertical-align: inherit;">(1000 * t) = - 0,628927 + 0,781568 * log (n)</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sedikit penyimpangan dari tren umum hanya khas untuk nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = ( 10, ... 49)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang disebabkan oleh fakta bahwa hanya blok perhitungan kelima yang digunakan dalam kisaran ini untuk menyelesaikan masalah, algoritma yang berbeda secara signifikan dari operasi algoritma dari blok pertama dan ketiga. Dalam ketergantungan yang dihasilkan, koefisien linier ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,781568</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) kurang dari satu, yang mengarah pada fakta bahwa dengan meningkatnya nilai n, garis regresi dan diagonal kuadran diverge. Untuk menjelaskan dengan jelas alasan perbedaan tersebut alih-alih waktu awal, kami mempertimbangkan waktu rata-rata yang diperlukan untuk lokasi satu ratu pada satu baris, mis. bagi waktu penghitungan rata-rata dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kami menyebut indikator semacam itu sebagai </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengurangan waktu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jelas, jika pengurangan waktu tidak berubah dengan meningkatnya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka solusi seperti itu akan linier ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Seperti yang terlihat pada Gambar 8, di mana plot logaritma dari waktu yang diberikan, </font></font><br><br><img src="https://habrastorage.org/webt/rm/zo/i5/rmzoi5vzkips2kreyaltswbzivm.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar. 8 Ketergantungan waktu rata-rata ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baris</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), yang diperlukan agar ratu ditempatkan pada satu garis arbitrer, dari ukuran ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) matriks solusi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tRow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), meningkat 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kali, dari logaritma ukuran matriks solusi, dalam kisaran n dari 50 hingga 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , waktu yang berkurang berkurang dengan meningkatnya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika pengurangan waktu untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 50</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah 10.7146 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> detik, maka waktu yang sesuai untuk n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dikurangi sebesar 21 kali dan 0,5084 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detik. Perilaku algoritma seperti itu, pada pandangan pertama, tampak keliru, karena tidak ada alasan obyektif mengapa algoritma akan menganggapnya lebih lambat untuk nilai n kecil daripada nilai besar. Namun, tidak ada kesalahan, dan ini adalah properti objektif dari algoritma ini. Ini disebabkan oleh fakta bahwa algoritma ini adalah komposisi dari tiga algoritma yang beroperasi pada kecepatan yang berbeda. Selain itu, jumlah baris yang diproses oleh masing-masing algoritma ini berubah dengan meningkatnya nilai n. Karena alasan inilah waktu penghitungan meningkat dalam rentang nilai awal n = (10, 20, 30, 40), karena semua perhitungan di area kecil ini dilakukan hanya berdasarkan blok prosedur kelima, yang bekerja sangat efisien, tetapi tidak secepat blok prosedur pertama. Jadi, mengingat bahwa waktu penghitungan diperlukan untuk memposisikan sang ratu pada satu baris,berkurang dengan meningkatnya ukuran papan catur, kompleksitas waktu dari algoritma ini dapat disebut menurun - linear.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frekuensi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelacakan Kembali (BT) telah digunakan</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dalam semua kasus percobaan komputasi, kami melacak jumlah kasus menggunakan prosedur BT dalam menyelesaikan setiap masalah. Penjumlahan kumulatif dibuat dari semua kasus menggunakan BT, terlepas dari tingkat dasar apa yang dikembalikan ke dalam proses menemukan solusi. Ini memberi kami kesempatan untuk menentukan, untuk setiap sampel, proporsi keputusan-keputusan di mana prosedur BT tidak pernah digunakan. Gambar 9 menunjukkan </font></font><br><br><img src="https://habrastorage.org/webt/_l/5t/h5/_l5th5fsxg_u7aw_dei4o3b5h2w.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar. 9. Persentase solusi sampel di mana prosedur Kembali Tracking pernah menggunakan </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grafik yang menunjukkan bagaimana proporsi solusi tanpa prosedur BT ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nol Kembali Tracking</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dengan peningkatan nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dapat dilihat bahwa dalam kisaran nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (7, ..., 100000)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jumlah solusi di mana prosedur BT tidak pernah digunakan melebihi 35%. Selain itu, dalam kisaran nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (320, ..., 22500)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jumlah kasus tersebut melebihi 50%. Hasil yang paling efektif diperoleh untuk papan catur dengan ukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5000 x 5000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana, dalam sampel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> komposisi, dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61,92%</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kasus </font><font style="vertical-align: inherit;">solusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"deterministik"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari masalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">non-deterministik</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dilakukan </font><font style="vertical-align: inherit;">, karena Prosedur BT pada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61,92%</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kasing tidak pernah digunakan. Dalam solusi yang tersisa, dalam 21,87% kasus, prosedur BT digunakan 1 kali, pada 9,07% kasus - 2 kali, dan dalam 3,77% kasus - 3 kali. Bersama-sama, ini menyumbang 96,63% dari kasus. Fakta bahwa setelah nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 5000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jumlah kasus penyelesaian masalah konfigurasi tanpa menggunakan prosedur BT secara bertahap menurun, dikaitkan dengan model yang dipilih untuk memilih nilai batas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Anda dapat mengubah parameter ini dan mencapai peningkatan jumlah solusi tanpa menggunakan prosedur BT. Namun, ini akan mengarah pada peningkatan waktu perhitungan, karena partisipasi blok kelima dalam operasi algoritma akan meningkat. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Histogram dari pembagian waktu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pada Gambar 10, untuk nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">histogram distribusi waktu pengambilan untuk satu juta solusi disajikan. Pandangan yang tidak biasa dari histogram distribusi (yang kemungkinan besar menyerupai siluet malam bangunan tinggi) tidak terkait dengan kesalahan dalam pemilihan panjang atau jumlah interval. Ini adalah sifat alami dari algoritma ini. Untuk memahami, </font></font><br><br><img src="https://habrastorage.org/webt/cm/ii/z9/cmiiz94kbp7hxfss1aqzkejd09o.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gbr. 10. Histogram dari waktu kompilasi komposisi ukuran sewenang-wenang. ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ukuran sampel = 1.000.000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengapa histogram memiliki formulir ini, pertimbangkan distribusi waktu pengambilan untuk komposisi yang memiliki ukuran yang sama. Untuk ini, sebagai contoh, dari sampel awal kami akan memilih semua komposisi yang ukurannya 800. Ada 998 komposisi tersebut dalam sampel satu juta. Gambar 11 menunjukkan histogram dari distribusi waktu penghitungan untuk sampel ini. Dapat dilihat dari gambar bahwa distribusi terdiri dari enam histogram terpisah, dengan ukuran yang menurun. </font></font><br><br><img src="https://habrastorage.org/webt/ku/70/xa/ku70xadamrocfeimg3zpvyvurgu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 11. Histogram waktu kompilasi komposisi dengan ukuran yang sama (k = 800). ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ukuran sampel = 998</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alasan mengapa waktu kompilasi 998 komposisi, di mana masing-masing 800 ratu didistribusikan secara acak, "dikelompokkan" menjadi 6 kelompok, karena prosedur </font><i><font style="vertical-align: inherit;">Pelacakan Kembali</font></i><font style="vertical-align: inherit;"> digunakan</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Histogram pertama pada gambar, dengan ukuran sampel maksimum, adalah solusi memilih di mana prosedur BT tidak pernah digunakan. Ini adalah kelompok solusi tercepat. Histogram kedua, yang secara signifikan lebih kecil dalam ukuran daripada yang pertama, adalah solusi di mana prosedur BT hanya digunakan sekali. Oleh karena itu, waktu keputusan dalam grup ini sedikit lebih lama daripada yang pertama. Dengan demikian, pada kelompok ketiga, prosedur BT digunakan dua kali, pada kelompok keempat - tiga kali, dll., Yaitu Keputusan di mana prosedur BT digunakan berulang kali dilakukan lebih lama. Solusi semacam itu membentuk ekor kanan panjang dari distribusi yang diinginkan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi Negatif Salah</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika kita membagi semua komposisi yang mungkin untuk nilai arbitrer dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke positif dan negatif, maka di antara komposisi positif ada yang algoritma ini dapat diklasifikasikan sebagai negatif. Ini disebabkan oleh kenyataan bahwa, dalam batas yang ditentukan oleh parameter pencarian, algoritma tidak dapat menemukan cara yang tepat untuk menyelesaikan komposisi tersebut. Seperti yang ditunjukkan oleh hasil percobaan (Tabel 2), jumlah kasus seperti itu tidak melebihi 0,0001 dari ukuran sampel, dan nilai kesalahan ini berkurang dengan meningkatnya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Selain itu, untuk semua nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n&gt; 800,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak ada satu pun kasus </font><font style="vertical-align: inherit;">solusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">False Negative</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bahkan meningkatkan ukuran sampel menjadi satu juta untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak menghasilkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">False Negative</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keputusan. </font><font style="vertical-align: inherit;">Hasilnya memungkinkan kami untuk merumuskan aturan berikut untuk menyelesaikan masalah: â€œSetiap komposisi acak </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ratu yang didistribusikan secara konsisten pada papan catur acak berukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat diselesaikan hingga solusi lengkap dibuat, atau akan diputuskan bahwa komposisi ini negatif, dan tidak dapat harus diselesaikan. </font><font style="vertical-align: inherit;">Probabilitas membuat keputusan seperti itu tidak melebihi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0001</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ketika ukuran papan catur meningkat, kemungkinan membuat keputusan yang salah berkurang. </font><font style="vertical-align: inherit;">Kompleksitas waktu dari algoritma adalah linear. â€</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Kesimpulan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Algoritma disajikan yang memungkinkan, dalam waktu linier, untuk menyelesaikan masalah set lengkap sampai solusi lengkap dari komposisi acak </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ratu, secara konsisten didistribusikan pada papan catur ukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sewenang-wenang </font><font style="vertical-align: inherit;">. Selain itu, untuk komposisi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ratu ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1â‰¤ k &lt;n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), solusi diberikan, jika ada, atau keputusan dibuat bahwa komposisi ini tidak dapat diselesaikan. Probabilitas kesalahan dalam membuat keputusan seperti itu tidak melebihi 0,0001, dan nilai ini menurun dengan meningkatnya ukuran papan catur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Pengoperasian algoritma ini didasarkan pada penggunaan dua aturan penting:</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Pada tahap akhir penyelesaian masalah, dari semua jalur bebas yang tersisa, satu dipilih yang jumlah posisi bebasnya minimal ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aturan risiko minimum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ini meminimalkan risiko yang terkait dengan kemungkinan mengecualikan posisi kosong terakhir di beberapa jalur yang tersisa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Dari semua posisi kosong dalam garis yang dipermasalahkan, posisi itu dipilih yang menyebabkan kerusakan minimal pada posisi bebas di garis bebas yang tersisa ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aturan kerusakan minimum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Yang dimaksud dengan " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kerusakan minimal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " adalah pemilihan posisi seperti itu dalam garis yang mengecualikan jumlah posisi bebas paling sedikit di semua jalur bebas yang tersisa.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Ditetapkan bahwa sebagai hasil dari operasi algoritma ini, waktu rata-rata yang diperlukan untuk ratu untuk ditempatkan pada satu baris berkurang dengan meningkatnya n. Waktu rata-rata yang diperlukan untuk menempatkan ratu pada satu baris dalam kasus ketika n adalah 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah 21 kali lebih kecil dari waktu yang sesuai untuk kasus n = 50. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Ditemukan bahwa dalam kisaran nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (7, ..., 100000)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jumlah solusi di mana prosedur pelacakan Kembali tidak pernah digunakan melebihi 35%. Selain itu, dalam kisaran nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (320, ..., 22500)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jumlah kasus tersebut melebihi 50%, yang menunjukkan efisiensi tinggi dari algoritma ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Model untuk mengatur prosedur </font><i><font style="vertical-align: inherit;">Pelacakan Kembali</font></i><font style="vertical-align: inherit;"> diusulkan.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, berdasarkan pemisahan urutan langkah-langkah keputusan di tingkat dasar. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level berarti langkah keputusan tertentu dengan sejumlah ratu yang ditempatkan dengan benar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Rumus regresi diberikan untuk menghitung nilai level dasar kedua dan ketiga tergantung pada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Hasil analisis komparatif dari dua metode seleksi acak, yang disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><i><font style="vertical-align: inherit;">disajikan</font></i><font style="vertical-align: inherit;"> . Ditemukan bahwa algoritma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cepat tapi kasar. Karena itu, penggunaannya terbatas ketika mencapai tingkat dasar kedua. Setelah itu, </font><i><font style="vertical-align: inherit;">rand &amp; rand</font></i><font style="vertical-align: inherit;"> digunakan.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang dilakukan tidak begitu cepat, tetapi lebih efektif menempatkan ratu di papan catur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Algoritma yang efektif untuk memverifikasi kebenaran solusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens Problem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diberikan </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Program ini juga dirancang untuk memverifikasi kebenaran komposisi acak ukuran sewenang-wenang. </font><font style="vertical-align: inherit;">Program ini bekerja cukup cepat. </font><font style="vertical-align: inherit;">Misalnya, waktu yang diperlukan untuk memvalidasi solusi yang terdiri dari 5 juta posisi adalah 0,85 detik.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Komentar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Seperti yang ditunjukkan pada awal artikel, penelitian dilakukan dalam kisaran nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dari 7 hingga 100 juta. Namun, program ini diuji dalam rentang nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n yang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lebih luas </font><font style="vertical-align: inherit;">, hingga satu miliar. Benar, dalam kasus terakhir, program harus sedikit disesuaikan, mengingat ukuran array yang besar. Oleh karena itu, jika ukuran RAM memungkinkan, maka dimungkinkan untuk melakukan perhitungan untuk nilai n yang besar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Nilai-nilai indikator dasar, serta nilai batas jumlah pengulangan di berbagai tingkat, dioptimalkan untuk menyelesaikan masalah dalam seluruh rentang penelitian. Mereka dapat diubah dalam rentang yang lebih kecil dan mengurangi waktu penghitungan. Penting untuk tidak meningkatkan pangsa </font><font style="vertical-align: inherit;">solusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Negatif Palsu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Pada artikel ini, saya menggunakan waktu keystroke </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masukkan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagai semacam ukuran waktu untuk menilai seberapa cepat algoritma bekerja. Jika hasilnya muncul segera setelah menekan tombol, maka pada tingkat persepsi pengguna tampaknya program bekerja "sangat" cepat. Tidak peduli seberapa cepat algoritma ini bekerja, hasilnya tidak akan muncul di layar sampai kunci selesai. Oleh karena itu, bagi saya tampak bahwa ukuran waktu yang kondisional dapat berfungsi sebagai tingkat ambang batas untuk tidak secara ketat membandingkan kecepatan berbagai algoritma.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Filosofis ... Selama penelitian, sejumlah besar publikasi yang terkait dengan solusi masalah non-deterministik dipertimbangkan. Dalam kebanyakan kasus, ini adalah tugas di mana perlu untuk membuat pilihan di ruang besar negara di bawah ketentuan pembatasan yang diberikan. Membandingkan mereka, itu menarik untuk mengetahui sejauh mana seseorang dapat maju dalam memecahkan masalah seperti itu menggunakan pendekatan matematika standar. Saya mendapat kesan bahwa tidak mungkin menyelesaikan masalah seperti itu hanya berdasarkan definisi, pernyataan lemma dan bukti teorema. Tampak bagi saya bahwa untuk menyelesaikan masalah seperti itu perlu menggunakan metode matematika algoritmik menggunakan simulasi komputer. Untuk menunjukkan validitas kesimpulan ini, sebagai contoh sederhana, saya menyiapkan papan catur yang ukurannya 10</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dua komposisi dengan ukuran yang sama, terdiri dari 999.999.482 ratu. Mereka disiapkan seperti yang dijelaskan di awal artikel dan disajikan sebagai dua file dalam format .mat. Mereka dapat diunduh di tautan ini </font></font><a href="https://drive.google.com/drive/folders/1p5VJO4fAEs8vNp_EonFIitd1o6EJqzQt%3Fusp%3Dsharing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Dua file uji)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . File cukup "berat", ukuran masing-masing adalah sekitar 3,97 Gb. Dalam 999 997 976 baris (dalam 99,9998% kasus) posisi ratu di kedua komposisi bertepatan, dan hanya dalam 1506 garis sewenang-wenang posisi ratu berbeda.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melengkapi data komposisi ke solusi lengkap, Anda perlu menempatkan ratu dengan benar di 518 baris bebas yang tersisa. Jumlah cara yang mungkin untuk mengatur 518 ratu di jalur bebas yang tersisa (dengan mempertimbangkan hanya jumlah cara untuk memilih posisi bebas di jalur yang dipilih) adalah sekitar 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1466</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Perbedaan antara kedua komposisi ini hanya bahwa salah satu dari mereka adalah positif dan dapat diselesaikan sampai solusi lengkap, dan komposisi lainnya negatif - tidak dapat diselesaikan sampai solusi lengkap. Pertanyaan: "Apakah mungkin, berdasarkan pendekatan matematis yang ketat (yaitu, tanpa melakukan operasi komputasi algoritmik), untuk menentukan mana dari dua komposisi ini yang positif?" Jika ini tidak mungkin diselesaikan, maka kita dapat mengasumsikan bahwa proposisi yang dibuat terbukti dengan kontradiksi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya ingin mencatat bahwa apa pun pendekatan terhadap solusi matematis ketat untuk masalah ini, perlu untuk menentukan status 518 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sel di baris bebas yang tersisa. Untuk melakukan ini, perlu untuk mempertimbangkan setiap posisi ratu yang didirikan sebelumnya, dan ada hampir satu miliar dari mereka, untuk menetapkan batasan yang masing-masing ratu yang didirikan memaksakan pada posisi bebas di 518 baris yang tersisa. Saya tidak menemukan "titik tumpu" yang memungkinkan saya melakukan pekerjaan ini hanya berdasarkan pendekatan matematis yang ketat, tanpa perhitungan algoritmik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini saya telah memberikan contoh minimal yang hanya terdiri dari dua komposisi. Jika perlu, jumlah komposisi tersebut dapat ditingkatkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu dicatat bahwa berdasarkan algoritma linear yang diusulkan, sedikit disesuaikan untuk bekerja dengan komposisi besar, tugas-tugas yang mana dari dua komposisi uji dapat diselesaikan sampai solusi lengkap dilakukan pada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desktop-13</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dalam waktu sekitar 4,5 menit (tidak termasuk waktu pemuatan data input). </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Penambahan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tindakan para profesor yang merekomendasikan tugas-tugas yang mampu bagi siswa untuk dikembangkan dan diteliti layak dihargai. </font><font style="vertical-align: inherit;">Ini membutuhkan upaya yang cukup besar, tetapi mengatasi kesulitan, peneliti melihat tugas kompleks lainnya secara berbeda. </font><font style="vertical-align: inherit;">Saya pikir akan bermanfaat untuk memperluas opsi untuk mengatur Masalah n-Queens untuk tujuan tersebut. </font><font style="vertical-align: inherit;">Jika Anda melihat tugas yang sama dari perspektif yang berbeda, Anda dapat melihat berbagai hal. </font><font style="vertical-align: inherit;">Berikut adalah beberapa di antaranya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Pertimbangkan masalah mengatur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ratu di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papan "catur" persegi panjang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxm</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nyatakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k = m - n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Biarkan beberapa solusi diperoleh, dan di masing-masing </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada satu ratu di setiap baris. Kami mengecualikan posisi tersebut di mana ratu berada dari pertimbangan lebih lanjut. Sekarang di setiap baris ada </font><font style="vertical-align: inherit;">posisi bebas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dalam posisi bebas yang tersisa, kami kembali menemukan satu solusi. Seperti sebelumnya, kami mengecualikan dari pertimbangan lebih lanjut posisi di mana ratu dari solusi kedua berada. Sekarang di setiap baris ada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m-2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> posisi bebas. Jelas, solusi pertama dan kedua tidak berpotongan di posisi mereka di baris mana pun - mereka ortogonal. Diperlukan untuk menentukan jumlah maksimum solusi saling ortogonal untuk berbagai nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saling solusi ortogonal ditemukan untuk nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maka Royal Latin Square akan dibangun. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komentar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kertas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grigoryan E. (2018)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> telah menunjukkan bahwa untuk setiap solusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ada solusi yang saling melengkapi, yang tidak mengganggu itu. Ini berarti bahwa untuk nilai arbitrer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , himpunan semua solusi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dibagi menjadi dua </font><font style="vertical-align: inherit;">himpunan bagian </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berukuran sama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Solusi apa pun dari subset kedua adalah solusi pelengkap untuk solusi yang sesuai dari subset pertama. Aturannya cukup sederhana, jika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q1 (i) adalah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solusi dari set pertama, maka solusi komplementer yang sesuai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q2 (i)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari subset kedua ditentukan oleh rumus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q2 (i) = n + 1 - Q1 (i), di mana i = (1, ..., n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aturan inilah yang menjelaskan fakta bahwa jumlah semua solusi dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , untuk nilai sewenang-wenang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , selalu merupakan bilangan genap. (Aturan ini memungkinkan kita untuk mengurangi separuh waktu untuk menghitung semua solusi lengkap untuk ukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sembarang </font><i><font style="vertical-align: inherit;">dari</font></i><font style="vertical-align: inherit;"> papan catur. Jika kita menyatakan dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 * k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jumlah total semua solusi, maka nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sama dengan indeks dalam daftar berurutan semua solusi ketika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q (k) + Q ( k + 1) = n + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Dalam rumusan awal masalah Masalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-Qeens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , setelah ratu ditempatkan pada posisi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tindakan berikut dilakukan: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) semua sel baris </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan kolom </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dikecualikan; b) semua sel yang terletak di garis diagonal kiri dan kanan yang melewati sel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dikecualikan </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengubah kondisi b) dalam pernyataan masalah. Alih-alih menghilangkan sel, kita akan menggunakan switching sel. Jika sel yang terletak di garis diagonal kiri atau kanan bebas, maka kita akan menutupnya, jika sel ditutup, maka kita akan membukanya. Ini membuatnya lebih mudah untuk menemukan solusi. Namun, alih-alih matriks kuadrat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kami menganggap matriks persegi panjang dengan ukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nx (n - k)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diperlukan, untuk nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n yang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diberikan </font><font style="vertical-align: inherit;">, untuk menemukan nilai maksimum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana setidaknya tiga solusi ortogonal dapat diperoleh. Bagaimana nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berubah </font><font style="vertical-align: inherit;">dengan meningkatnya nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Ubah beberapa kondisi dalam formulasi awal masalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ketika ratu diposisikan pada posisi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada papan catur berukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) kita mengecualikan semua sel dalam baris </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) jika indeks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j adalah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bilangan genap, maka: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b1) kita mengecualikan sel dalam baris genap j, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b2) kita mengecualikan sel dalam garis genap yang memotong diagonal kiri dan kanan melewati sel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Jika indeks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angka ganjil, maka item b1) dan b2) dipenuhi untuk sel yang terletak pada garis ganjil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1 Telah diketahui </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Sloane-2016)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bahwa daftar nilai semua solusi dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah nQueens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (8, 9, 10, 11, 12, 13, 14, 15, 16)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , masing-masing, adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bagaimana jumlah semua solusi berubah jika, dalam pernyataan masalah, kondisi standar untuk pengecualian diagonal diubah menjadi paragraf b) atau paragraf c)?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2 Diketahui oleh Grigoryan (2018) bahwa jika kita menentukan frekuensi partisipasi sel-sel yang berbeda dari matriks solusi dalam pembentukan daftar semua solusi, kita dapat menemukan bahwa ada hubungan yang harmonis antara semua sel dalam bentuk simetri vertikal dan horizontal dari frekuensi yang sesuai. Ini berarti bahwa jika kita mengasumsikan bahwa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k &lt;n / 2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka frekuensi sel-sel dari baris </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-th</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan identik dengan frekuensi sel-sel dari baris </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-k + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Demikian pula, frekuensi sel kolom </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-th</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan identik dengan frekuensi sel kolom </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n-k + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pertanyaan: "Bagaimana hubungan harmonis ini berubah dalam konteks tugas?"</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Semua sel papan catur dibagi menjadi dua kelas berdasarkan warnanya. Diyakini bahwa satu warna putih, yang lain hitam. Pertimbangkan dua papan catur dan letakkan salah satunya di sisi yang lain sehingga ujungnya benar-benar bertepatan. Hasilnya, kami mendapatkan "sandwich" dari dua papan catur, di mana pengaturan sel putih dan hitam bertepatan. Tugasnya adalah untuk menemukan solusi secara bersamaan pada dua papan, mengamati kondisi berikut: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Jika pada salah satu papan ratu berada pada sel hitam dengan indeks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- pada kedua papan semua sel hitam yang terjadi pada baris </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan kolom </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- pada kedua papan semua sel hitam yang terletak di sepanjang diagonal kiri dan kanan yang melewati sel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dikecualikan </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Jika pada salah satu papan ratu terletak pada sel putih dengan indeks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka semua tindakan paragraf a) dilakukan hanya untuk sel putih. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Bayangkan bahwa dalam matriks solusi ukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , baris dapat bergeser relatif satu sama lain ke kanan atau kiri, dengan langkah </font><font style="vertical-align: inherit;">sel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Selain itu, jika baris sebelumnya digeser, misalnya, ke kiri, maka baris berikutnya harus digeser ke kanan, mis. setiap baris berikutnya digeser ke arah yang berlawanan dengan baris sebelumnya. Sebagai hasil dari konstruksi ini, kami memperoleh matriks ukuran persegi panjang</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nx (n + k)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana di setiap baris k sel dari awal baris atau dari akhir akan dikecualikan dari pertimbangan. Tugasnya adalah </font><font style="vertical-align: inherit;">menemukan nilai maksimum </font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;"> untuk nilai arbitrer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang setidaknya ada satu solusi </font><i><font style="vertical-align: inherit;">n-Queens Problem</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pertimbangkan varian masalah di mana offset satu baris terhadap yang lain adalah bilangan acak mulai dari </font><i><font style="vertical-align: inherit;">k1</font></i><font style="vertical-align: inherit;"> hingga </font><i><font style="vertical-align: inherit;">k2</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">6. </font><b><font style="vertical-align: inherit;">Formulasi</font></b><font style="vertical-align: inherit;"> satu- </font><b><font style="vertical-align: inherit;">dimensi dari </font></b><b><i><font style="vertical-align: inherit;">Masalah nQueens</font></i></b><font style="vertical-align: inherit;"> . Biarkan </font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;"> segmen dengan panjang sewenang-wenang, yang dinomori dari </font><i><font style="vertical-align: inherit;">1 hingga n</font></i><font style="vertical-align: inherit;"> , diletakkan pada setengah-sumbu </font><font style="vertical-align: inherit;">. Bagilah setiap segmen dengan </font><i><font style="vertical-align: inherit;">n</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sel dengan ukuran acak, dan dalam setiap segmen, jumlah sel dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 hingga n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kami menyebut sel tersebut terbuka. Hal ini membutuhkan dekat satu sel pada setiap segmen, mengingat keterbatasan berikut: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Kita bisa memilih sel terbuka dengan indeks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segmen th jika: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 0; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 0; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i, t = j + i, D1 dan D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah array kontrol satu dimensi yang terdiri dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sel yang sebelumnya nol. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Setelah pilihan ini, segmen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan sel dengan nomor </font><i><font style="vertical-align: inherit;">j</font></i><font style="vertical-align: inherit;"> akan ditutup</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di semua segmen gratis yang tersisa. Juga diperlukan untuk menutup sel yang sesuai dalam array kontrol: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 1; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 1; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam pengaturan ini, tugas benar-benar identik dengan yang asli. Yang menarik adalah rumusan masalah ini dengan kondisi kendala lainnya. Misalnya, jika bukan rumus: </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i, t = j + i,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan dipertimbangkan rasio lainnya, yang secara fungsional terkait indeks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indeks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> membuat matriks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata-kata tugas berdasarkan guci dengan bola</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (identik dengan kata-kata sebelumnya). Misalkan ada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> guci bernomor dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 ke n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan di setiap guci ada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bola, juga dinomori dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 hingga n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Membutuhkan guci jauh dari masing-masing bola, mengingat keterbatasan berikut: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) kita dapat memilih balon dengan jumlah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> urn th jika: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i, t = j + i, D1 dan D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah array kontrol satu dimensi yang terdiri dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sel yang sebelumnya nol. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Setelah pilihan ini, kotak suara </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan bola dengan nomor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan ditutup </font><font style="vertical-align: inherit;">di semua kotak suara gratis yang tersisa. Penting juga untuk menutup sel yang sesuai dalam array kontrol:</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t) = 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam pengaturan ini, tugas benar-benar identik dengan yang asli. Seperti dalam kasus sebelumnya, pernyataan masalah ini dengan kondisi lain yang secara fungsional menghubungkan indeks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan indeks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) dari</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> matriks keputusan </font><font style="vertical-align: inherit;">adalah menarik </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permainan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pertimbangkan papan catur berukuran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mari kita kembali warna ke ratu, biarkan beberapa ratu memiliki warna putih, yang lain hitam. Kami juga mengembalikan warna putih dan hitam bolak-balik ke sel-sel papan catur, berdasarkan fakta bahwa sel dengan indeks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1, n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus putih. Semua sel di awal permainan dianggap gratis. Ratu putih membuat langkah pertama. Pemain menempatkan ratu dalam sel bebas sewenang-wenang dengan indeks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Biarkan itu menjadi sel putih. Sebagai hasil dari pilihan ini, mereka ditutup: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) semua sel putih baris </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) semua sel putih kolom </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) semua sel putih yang terletak di diagonal kiri dan kanan melewati sel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika sel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berubah menjadi hitam, maka semua poin </font><i><font style="vertical-align: inherit;">(a, b, c)</font></i><font style="vertical-align: inherit;"> terpenuhi</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan karenanya, semua sel warna hitam ditutup. Selanjutnya, Black melakukan gerakan, menempatkan ratu di salah satu sel bebas yang tersisa. Setelah itu, dengan cara yang sama, sel-sel menutup, seperti dijelaskan di atas. Waktu untuk memikirkan langkah selanjutnya sudah ditentukan, dan dipilih berdasarkan persetujuan para pihak. Jika selama waktu yang ditentukan, salah satu pemain tidak menyelesaikan langkahnya, maka permainan akan ditransfer ke yang lain. Permainan berakhir jika kedua pemain, satu demi satu, gagal menyelesaikan giliran mereka dalam waktu yang ditentukan. Orang yang bisa menempatkan lebih banyak ratu di papan menang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Tentang stabilitas pemilihan acak. Pertimbangkan model </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sebagai hasil dari membandingkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pasangan acak dari indeks baris dan kolom, pada tahap pertama siklus, adalah mungkin untuk menetapkan ratu rata-rata di</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k * n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baris. Nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat dianggap sebagai nilai konstan sama dengan 0,6. Nilainya bervariasi dari 0,605701 pada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 10</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan hingga 0,599777, pada n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan, dengan meningkatnya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , varian nilai ini menurun. Apa alasan untuk "keteguhan" seperti itu? Mengapa, dengan pemilihan acak indeks baris dan indeks posisi ratu di baris ini, atas dasar dua daftar angka yang diperoleh atas dasar permutasi acak angka dari 1 hingga n, dimungkinkan untuk secara konsisten menempatkan ratu (rata-rata) pada 60% garis? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Biarkan ukuran papan catur menjadi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Berdasarkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prosedur randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letakkan ratu di papan catur sampai cabang pencarian menemui jalan buntu. Nyatakan panjang komposisi yang diperoleh </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika, untuk nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n yang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diberikan </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> ulangi prosedur ini berkali-kali, dan buat histogram dari distribusi nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ternyata perubahan frekuensi kejadian peristiwa dengan nilai mode distribusi berbeda dari perubahan frekuensi kemunculan peristiwa setelah nilai ini. Jika, berdasarkan nilai modal, histogram dibagi menjadi dua bagian, maka bagian kiri tidak akan bertepatan dengan bagian kanan. Pola ini adalah karakteristik untuk nilai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mengapa, setelah transisi panjang komposisi melalui nilai modal, apakah frekuensi timbulnya peristiwa mengambil bentuk yang berbeda? </font><font style="vertical-align: inherit;">Yang dimaksud dengan suatu peristiwa, yang kami maksud adalah menerima komposisi dengan ukuran tertentu, sebelum mencapai tingkat kemandekan.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sastra </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Nauck, F. (1850). </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefwechsel mit allen fur alle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Illustrierte Zeitung, 15, 182. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. </font></font><a href="https://jair.org/index.php/jair/article/view/11079/26262"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gent, IP, Jefferson, C. &amp; Nightingale, P. (2017). </font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompleksitas penyelesaian n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jurnal Penelitian Kecerdasan Buatan., 59, 815-848. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Sosic, R., &amp; Gu, J. (1990). </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma waktu polinomial untuk masalah n-queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Buletin SIGART, 1 (3), 7â€“11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. </font></font><a href="https://www.cl.cam.ac.uk/~mr10/backtrk.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richards, M. (1997). </font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma backtracking di MCPL menggunakan pola bit dan rekursi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tech. rep., Laboratorium Komputer, Universitas Cambridge. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode Pengacakan dalam Desain Algoritma</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Prosiding Lokakarya DIMACS, Princeton, New Jersey, AS, 12-14 Desember 1997. Seri DIMACS dalam Matematika Diskrit dan Ilmu Komputer Teoretis 43, DIMACS / AMS 1999, ISBN 978-0-8218-0916-7 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. </font></font><a href="http://ejournal11.com/journals_n/1537458681.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grigoryan E. (2018). </font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Investigasi Keteraturan dalam Pembentukan Solusi Masalah n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Modeling of Artificial Intelligence, 5 (1), 3-21 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. </font></font><a href="http://oeis.org/A000170,%25202016"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sloane N.-JA (2016). </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensiklopedia on-line dari urutan bilangan bulat.</font></font><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483036/">https://habr.com/ru/post/id483036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483018/index.html">Topeng-R CNN dari pemula hingga profesional</a></li>
<li><a href="../id483024/index.html">"Apa yang dilakukan korporasi dengan privasi Anda?", Arthur Khachuyan (Tazeros Global)</a></li>
<li><a href="../id483026/index.html">Java / Spring: Cara menghasilkan sepenuhnya API CRUD REST menggunakan Speedment</a></li>
<li><a href="../id483030/index.html">API yang membuat Anda menangis</a></li>
<li><a href="../id483032/index.html">Pindah dari CIS ke Republik Ceko, pengalaman sendiri (bagian 2)</a></li>
<li><a href="../id483038/index.html">Memulai kembali dunia game dengan kompeten</a></li>
<li><a href="../id483040/index.html">Obeng ajaib untuk perakitan Timur Jauh Excel 97</a></li>
<li><a href="../id483042/index.html">9 Tips Kinerja Vue</a></li>
<li><a href="../id483048/index.html">Terminal Fun: 10 lelucon klasik</a></li>
<li><a href="../id483050/index.html">5 Perusahaan Pengembangan Top ReactJS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>