<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏻 👩‍👩‍👧‍👦 🍝 Pensamento funcional. Parte 7 👈🏿 😡 🔶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos nossa série de artigos sobre programação funcional em F #. Hoje temos um tópico muito interessante: a definição de funções. Inclusive, vam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensamento funcional. Parte 7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433398/"><p>  Continuamos nossa série de artigos sobre programação funcional em F #.  Hoje temos um tópico muito interessante: a definição de funções.  Inclusive, vamos falar sobre funções anônimas, funções sem parâmetros, funções recursivas, combinadores e muito mais.  Olhe embaixo do gato! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Primeira parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Segunda parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Terceira parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quarta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quinta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sexta parte</a></strong> <a name="habracut"></a></li></ul><br><h1>  Definição de Função </h1><br><p>  Já sabemos como criar funções regulares usando a sintaxe "let": </p><br><pre><code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Neste artigo, veremos outras maneiras de criar funções, além de dicas para defini-las. </p><br><h2>  Funções anônimas (lambdas) </h2><br><p>  Se você estiver familiarizado com lambdas em outros idiomas, os parágrafos a seguir parecerão familiares.  Funções anônimas (ou "expressões lambda") são definidas da seguinte maneira: </p><br><pre> <code class="plaintext hljs">fun parameter1 parameter2 etc -&gt; expression</code> </pre> <br><p>  Comparado às lambdas do C #, há duas diferenças: </p><br><ul><li>  lambdas deve começar com a palavra-chave <code>fun</code> , que não é necessária em C # </li><li>  seta única <code>-&gt;</code> usada <code>-&gt;</code> , em vez de dupla <code>=&gt;</code> de C #. </li></ul><br><p>  Definição lambda da função de adição: </p><br><pre> <code class="plaintext hljs">let add = fun xy -&gt; x + y</code> </pre> <br><p>  Mesma função na forma tradicional: </p><br><pre> <code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Lambdas são freqüentemente usadas na forma de pequenas expressões ou quando não há desejo de definir uma função separada para uma expressão.  Como você já viu, ao trabalhar com listas, isso não é incomum. </p><br><pre> <code class="plaintext hljs">//    let add1 i = i + 1 [1..10] |&gt; List.map add1 //        [1..10] |&gt; List.map (fun i -&gt; i + 1)</code> </pre> <br><p>  Observe que os parênteses devem ser usados ​​em torno das lambdas. </p><br><p>  Lambdas também são usados ​​quando uma função claramente diferente é necessária.  Por exemplo, o " <code>adderGenerator</code> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discutido anteriormente, discutido anteriormente,</a> pode ser reescrito usando lambdas. </p><br><pre> <code class="plaintext hljs">//   let adderGenerator x = (+) x //     let adderGenerator x = fun y -&gt; x + y</code> </pre> <br><p>  A versão lambda é um pouco mais longa, mas imediatamente deixa claro que uma função intermediária será retornada. </p><br><p>  Lambdas podem ser aninhadas.  Outro exemplo de uma definição <code>adderGenerator</code> , desta vez apenas em lambdas. </p><br><pre> <code class="plaintext hljs">let adderGenerator = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Você está claro que todas as três definições são equivalentes? </p><br><pre> <code class="plaintext hljs">let adderGenerator1 xy = x + y let adderGenerator2 x = fun y -&gt; x + y let adderGenerator3 = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Caso contrário, leia novamente o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">capítulo sobre curry</a> .  Isso é muito importante para a compreensão! </p><br><h2>  Correspondência de padrões </h2><br><p>  Quando uma função é definida, é possível passar parâmetros explicitamente, como nos exemplos acima, mas também é possível comparar com um modelo diretamente na seção de parâmetros.  Em outras palavras, a seção de parâmetros pode conter padrões (padrões correspondentes), e não apenas identificadores! </p><br><p>  O exemplo a seguir demonstra o uso de padrões em uma definição de função: </p><br><pre> <code class="plaintext hljs">type Name = {first:string; last:string} //    let bob = {first="bob"; last="smith"} //   //     let f1 name = //   let {first=f; last=l} = name //     printfn "first=%s; last=%s" fl //   let f2 {first=f; last=l} = //        printfn "first=%s; last=%s" fl //  f1 bob f2 bob</code> </pre> <br><p>  Esse tipo de comparação pode ocorrer apenas quando a correspondência é sempre decidível.  Por exemplo, você não pode combinar tipos e listas de união dessa maneira, porque alguns casos não podem ser correspondidos. </p><br><pre> <code class="plaintext hljs">let f3 (x::xs) = //       printfn "first element is=%A" x</code> </pre> <br><p>  O compilador emitirá um aviso sobre correspondência incompleta (uma lista vazia causará um erro no tempo de execução na entrada desta função). </p><br><h2>  Erro comum: tuplas vs.  muitos parâmetros </h2><br><p>  Se você vem de uma linguagem do tipo C, a tupla usada como único argumento da função pode dolorosamente se assemelhar a uma função de vários parâmetros.  Mas isso não é a mesma coisa!  Como observei anteriormente, se você vir uma vírgula, provavelmente é uma tupla.  Os parâmetros são separados por espaços. </p><br><p>  Exemplo de confusão: </p><br><pre> <code class="plaintext hljs">//      let addTwoParams xy = x + y //      -  let addTuple aTuple = let (x,y) = aTuple x + y //         //        let addConfusingTuple (x,y) = x + y</code> </pre> <br><ul><li>  A primeira definição, " <code>addTwoParams</code> ", usa dois parâmetros, separados por um espaço. </li><li>  A segunda definição, " <code>addTuple</code> ", usa um parâmetro.  Este parâmetro liga "x" e "y" da tupla e os soma. </li><li>  A terceira definição, " <code>addConfusingTuple</code> ", usa um parâmetro como " <code>addTuple</code> ", mas o truque é que essa tupla seja descompactada (correspondida ao padrão) e vinculada como parte da definição de parâmetro usando a correspondência de padrões.  Nos bastidores, tudo acontece exatamente da mesma forma que no <code>addTuple</code> . </li></ul><br><p>  Vejamos as assinaturas (sempre olhe para elas, se você não tiver certeza de alguma coisa). </p><br><pre> <code class="plaintext hljs">val addTwoParams : int -&gt; int -&gt; int //   val addTuple : int * int -&gt; int // tuple-&gt;int val addConfusingTuple : int * int -&gt; int // tuple-&gt;int</code> </pre> <br><p>  E agora aqui: </p><br><pre> <code class="plaintext hljs">// addTwoParams 1 2 // ok --      addTwoParams (1,2) // error -     // =&gt; error FS0001: This expression was expected to have type // int but here has type 'a * 'b</code> </pre> <br><p>  Aqui vemos um erro na segunda chamada. </p><br><p>  Primeiramente, o compilador trata <code>(1,2)</code> como uma tupla generalizada do formulário <code>('a * 'b)</code> , que tenta passar como o primeiro parâmetro para <code>addTwoParams</code> .  Depois disso, ele reclama que o primeiro parâmetro esperado <code>addTwoParams</code> não <code>addTwoParams</code> <code>int</code> , mas foi feita uma tentativa de passar uma tupla. </p><br><p>  Para fazer uma tupla, use uma vírgula! </p><br><pre> <code class="plaintext hljs">addTuple (1,2) // ok addConfusingTuple (1,2) // ok let x = (1,2) addTuple x // ok let y = 1,2 //  , //  ! addTuple y // ok addConfusingTuple y // ok</code> </pre> <br><p>  E vice-versa, se você passar vários argumentos para uma função aguardando uma tupla, também receberá um erro incompreensível. </p><br><pre> <code class="plaintext hljs">addConfusingTuple 1 2 // error --          // =&gt; error FS0003: This value is not a function and // cannot be applied</code> </pre> <br><p>  Dessa vez, o compilador decidiu que, depois que dois argumentos fossem <code>addConfusingTuple</code> , o <code>addConfusingTuple</code> deveria ser curry.  E a entrada " <code>addConfusingTuple 1</code> " é um aplicativo parcial e deve retornar uma função intermediária.  Tentar chamar essa função intermediária com o parâmetro "2" gerará um erro, porque  não há função intermediária!  Vemos o mesmo erro do capítulo sobre curry, onde discutimos problemas com muitos parâmetros. </p><br><h3>  Por que não usar tuplas como parâmetros? </h3><br><p>  A discussão das tuplas acima mostra outra maneira de definir funções com muitos parâmetros: em vez de passá-las separadamente, todos os parâmetros podem ser montados em uma estrutura.  No exemplo abaixo, a função usa um único parâmetro - uma tupla de três elementos. </p><br><pre> <code class="plaintext hljs">let f (x,y,z) = x + y * z //  - int * int * int -&gt; int //  f (1,2,3)</code> </pre> <br><p>  Note-se que a assinatura é diferente da assinatura de uma função com três parâmetros.  Há apenas uma seta, um parâmetro e asteriscos apontando para a tupla <code>(int*int*int)</code> . </p><br><p>  Quando é necessário enviar argumentos com parâmetros separados e quando uma tupla? </p><br><ul><li>  Quando as tuplas são significativas em si mesmas.  Por exemplo, para operações no espaço tridimensional, as tuplas triplas serão mais convenientes do que três coordenadas separadamente. </li><li>  Às vezes, as tuplas são usadas para combinar dados que devem ser armazenados juntos em uma única estrutura.  Por exemplo, os métodos <code>TryParse</code> da biblioteca .NET retornam o resultado e uma variável booleana como uma tupla.  Mas para armazenar uma grande quantidade de dados relacionados, é melhor definir uma classe ou registro ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">registro</a> . </li></ul><br><h3>  Caso especial: Tuplas e funções da biblioteca .NET </h3><br><p>  Ao chamar bibliotecas .NET, vírgulas são muito comuns! </p><br><p>  Todos eles aceitam tuplas e as chamadas são iguais às do C #: </p><br><pre> <code class="plaintext hljs">//  System.String.Compare("a","b") //   System.String.Compare "a" "b"</code> </pre> <br><p>  O motivo é que as funções do .NET clássico não são curry e não podem ser parcialmente aplicadas.  <em>Todos os</em> parâmetros <em>sempre</em> devem ser transmitidos imediatamente, e a maneira mais óbvia é usar uma tupla. </p><br><p>  Observe que essas chamadas parecem apenas transferir tuplas, mas esse é realmente um caso especial.  Você não pode passar tuplas reais para essas funções: </p><br><pre> <code class="plaintext hljs">let tuple = ("a","b") System.String.Compare tuple // error System.String.Compare "a","b" // error</code> </pre> <br><p>  Se você deseja aplicar parcialmente as funções .NET, basta escrever sobre elas, como foi feito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anteriormente</a> ou como mostrado abaixo: </p><br><pre> <code class="plaintext hljs">//    let strCompare xy = System.String.Compare(x,y) //    let strCompareWithB = strCompare "B" //      ["A";"B";"C"] |&gt; List.map strCompareWithB</code> </pre> <br><h2>  Guia para selecionar parâmetros individuais e agrupados </h2><br><p>  A discussão das tuplas leva a um tópico mais geral: quando os parâmetros devem ser separados e quando agrupados? </p><br><p>  Você deve prestar atenção em como o F # difere do C # nesse sentido.  Em C #, <em>todos os</em> parâmetros são <em>sempre</em> passados, portanto, essa pergunta nem sequer aparece lá!  No F #, devido à aplicação parcial, apenas alguns dos parâmetros podem ser representados; portanto, é necessário distinguir entre o caso em que os parâmetros devem ser combinados e o caso em que são independentes. </p><br><p>  Recomendações gerais sobre como estruturar parâmetros ao projetar suas próprias funções. </p><br><ul><li>  No caso geral, é sempre melhor usar parâmetros separados em vez de passar uma estrutura, seja uma tupla ou um registro.  Isso permite um comportamento mais flexível, como aplicação parcial. </li><li>  Porém, quando um grupo de parâmetros <em>precisa</em> ser passado por vez, algum tipo de mecanismo de agrupamento deve ser usado. </li></ul><br><p>  Em outras palavras, ao desenvolver uma função, pergunte a si mesmo: "Posso fornecer esse parâmetro separadamente?"  Se a resposta for não, os parâmetros devem ser agrupados. </p><br><p>  Vejamos alguns exemplos: </p><br><pre> <code class="plaintext hljs">//     . //      ,       let add xy = x + y //         //      ,    let locateOnMap (xCoord,yCoord) = //  //      //      -     type CustomerName = {First:string; Last:string} let setCustomerName aCustomerName = //  let setCustomerName first last = //   //     //     //    ,     let setCustomerName myCredentials aName = //</code> </pre> <br><p>  Por fim, verifique se a ordem dos parâmetros ajudará na aplicação parcial (consulte o manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ).  Por exemplo, por que coloquei <code>myCredentials</code> antes de <code>aName</code> na última função? </p><br><h2>  Funções sem parâmetros </h2><br><p>  Às vezes, você pode precisar de uma função que não aceita nenhum parâmetro.  Por exemplo, você precisa da função "olá mundo", que pode ser chamada várias vezes.  Como mostrado na seção anterior, a definição ingênua não funciona. </p><br><pre> <code class="plaintext hljs">let sayHello = printfn "Hello World!" //     </code> </pre> <br><p>  Mas isso pode ser corrigido adicionando um parâmetro de unidade à função ou usando um lambda. </p><br><pre> <code class="plaintext hljs">let sayHello() = printfn "Hello World!" //  let sayHello = fun () -&gt; printfn "Hello World!" // </code> </pre> <br><p>  Depois disso, a função deve sempre ser chamada com o argumento <code>unit</code> : </p><br><pre> <code class="plaintext hljs">//  sayHello()</code> </pre> <br><p>  O que acontece com frequência ao interagir com bibliotecas .NET: </p><br><pre> <code class="plaintext hljs">Console.ReadLine() System.Environment.GetCommandLineArgs() System.IO.Directory.GetCurrentDirectory()</code> </pre> <br><p>  Lembre-se, chame-os com parâmetros de <code>unit</code> ! </p><br><h2>  Definindo novos operadores </h2><br><p>  Você pode definir funções usando um ou mais caracteres do operador (consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> para obter uma lista de caracteres): </p><br><pre> <code class="plaintext hljs">//  let (.*%) xy = x + y + 1</code> </pre> <br><p>  Você deve usar parênteses nos caracteres para definir a função. </p><br><p>  Os operadores que começam com <code>*</code> requerem um espaço entre parênteses e <code>*</code> , porque  em F # <code>(*</code> atua como o início de um comentário (como <code>/*...*/</code> em C #): </p><br><pre> <code class="plaintext hljs">let ( *+* ) xy = x + y + 1</code> </pre> <br><p>  Uma vez definida, uma nova função pode ser usada da maneira usual se estiver entre colchetes: </p><br><pre> <code class="plaintext hljs">let result = (.*%) 2 3</code> </pre> <br><p>  Se a função for usada com dois parâmetros, você poderá usar o registro do operador infix sem parênteses. </p><br><pre> <code class="plaintext hljs">let result = 2 .*% 3</code> </pre> <br><p>  Você também pode definir operadores de prefixo começando com <code>!</code>  ou <code>~</code> (com algumas restrições, consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> ) </p><br><pre> <code class="plaintext hljs">let (~%%) (s:string) = s.ToCharArray() // let result = %% "hello"</code> </pre> <br><p>  No F #, definir instruções é uma operação bastante comum e muitas bibliotecas exportam instruções com nomes como <code>&gt;=&gt;</code> e <code>&lt;*&gt;</code> . </p><br><h2>  Estilo sem ponto </h2><br><p>  Já vimos muitos exemplos de funções que careciam dos parâmetros mais recentes para reduzir o nível de caos.  Esse estilo é chamado <strong>de estilo sem ponto</strong> ou <strong>programação tácita</strong> . </p><br><p>  Aqui estão alguns exemplos: </p><br><pre> <code class="plaintext hljs">let add xy = x + y //  let add x = (+) x // point free let add1Times2 x = (x + 1) * 2 //  let add1Times2 = (+) 1 &gt;&gt; (*) 2 // point free let sum list = List.reduce (fun sum e -&gt; sum+e) list //  let sum = List.reduce (+) // point free</code> </pre> <br><p>  Esse estilo tem seus prós e contras. </p><br><p>  Uma das vantagens é que a ênfase está na composição de funções de ordem superior, em vez de mexer com objetos de baixo nível.  Por exemplo, " <code>(+) 1 &gt;&gt; (*) 2</code> " é uma adição explícita seguida por multiplicação.  E " <code>List.reduce (+)</code> " deixa claro que a operação de adição é importante, independentemente das informações da lista. </p><br><p>  Um estilo inútil permite que você se concentre no algoritmo básico e identifique recursos comuns no código.  A função " <code>reduce</code> " usada acima é um bom exemplo.  Este tópico será discutido em uma série planejada sobre o processamento de listas. </p><br><p>  Por outro lado, o uso excessivo desse estilo pode tornar o código obscuro.  Parâmetros explícitos agem como documentação e seus nomes (como "lista") facilitam a compreensão do que a função faz. </p><br><p>  Como tudo na programação, a melhor recomendação é preferir a abordagem que forneça mais clareza. </p><br><h2>  Combinadores </h2><br><p>  " <strong>Combinadores</strong> " são chamados de funções cujo resultado depende apenas de seus parâmetros.  Isso significa que não há dependência do mundo exterior e, em particular, nenhuma outra função ou valores globais podem afetá-los. </p><br><p>  Na prática, isso significa que as funções combinatórias são limitadas por uma combinação de seus parâmetros de várias maneiras. </p><br><p>  Já vimos vários combinadores: um operador de tubo e composição.  Se você observar as definições deles, ficará claro que tudo o que eles fazem é reordenar os parâmetros de várias maneiras. </p><br><pre> <code class="plaintext hljs">let (|&gt;) xf = fx //  pipe let (&lt;|) fx = fx //  pipe let (&gt;&gt;) fgx = g (fx) //   let (&lt;&lt;) gfx = g (fx) //  </code> </pre> <br><p>  Por outro lado, funções como "printf", embora primitivas, não são combinadoras porque são dependentes do mundo externo (E / S). </p><br><h3>  Aves combinatórias </h3><br><p>  Os combinadores são a base de toda uma seção da lógica (naturalmente chamada de "lógica combinatória"), que foi inventada muitos anos antes dos computadores e das linguagens de programação.  A lógica combinatória tem uma influência muito grande na programação funcional. </p><br><p>  Para aprender mais sobre combinadores e lógica combinatória, recomendo o livro de Raymond Smullyan, "To Mock a Mockingbird".  Nele, ele explica outros combinadores e fantasia-lhes <a href="">nomes de pássaros</a> .  Aqui estão alguns exemplos de combinadores padrão e seus nomes de pássaros: </p><br><pre> <code class="plaintext hljs">let I x = x //  ,  Idiot bird let K xy = x // the Kestrel let M x = x &gt;&gt; x // the Mockingbird let T xy = yx // the Thrush ( !) let Q xyz = y (xz) // the Queer bird ( !) let S xyz = xz (yz) // The Starling //   ... let rec Y fx = f (Y f) x // Y-,  Sage bird</code> </pre> <br><p>  Os nomes das letras são bastante padrão, portanto, você pode consultar o combinador K para qualquer pessoa familiarizada com esta terminologia. </p><br><p>  Acontece que muitos padrões de programação comuns podem ser representados por esses combinadores padrão.  Por exemplo, o Kestrel é um padrão regular na interface fluente em que você faz algo, mas retorna o objeto original.  Thrush é um pipe, Queer é uma composição direta e o combinador Y faz um excelente trabalho na criação de funções recursivas. </p><br><p>  De fato, existe um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teorema bem conhecido de</a> que qualquer função computável pode ser construída usando apenas dois combinadores básicos, Kestrel e Starling. </p><br><h3>  Bibliotecas Combinatórias </h3><br><p>  Bibliotecas combinatórias são bibliotecas que exportam muitas funções combinatórias projetadas para serem compartilhadas.  Um usuário dessa biblioteca pode facilmente combinar funções para obter funções ainda maiores e mais complexas, como cubos facilmente. </p><br><p>  Uma biblioteca combinadora bem projetada permite que você se concentre em funções de alto nível e oculte "ruído" de baixo nível.  Já vimos seu poder em vários exemplos da série "por que usar F #", e o módulo <code>List</code> está cheio dessas funções, " <code>fold</code> " e " <code>map</code> " também são combinadores, se você pensar bem. </p><br><p>  Outra vantagem dos combinadores é que eles são o tipo mais seguro de função.  Porque  eles não têm dependências do mundo exterior e não podem mudar quando o ambiente global muda.  Uma função que lê um valor global ou usa funções de biblioteca pode interromper ou mudar entre chamadas, se o contexto mudar.  Isso nunca acontecerá aos combinadores. </p><br><p>  No F #, as bibliotecas combinadoras estão disponíveis para análise (FParsec), criação de HTML, estruturas de teste etc.  Discutiremos e usaremos combinadores mais adiante na próxima série. </p><br><h2>  Funções recursivas </h2><br><p>  Muitas vezes, uma função precisa se referir a si mesma a partir de seu corpo.  Um exemplo clássico é a função Fibonacci. </p><br><pre> <code class="plaintext hljs">let fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Infelizmente, esta função não poderá compilar: </p><br><pre> <code class="plaintext hljs">error FS0039: The value or constructor 'fib' is not defined</code> </pre> <br><p>  Você deve informar ao compilador que esta é uma função recursiva usando a palavra-chave <code>rec</code> . </p><br><pre> <code class="plaintext hljs">let rec fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Funções recursivas e estruturas de dados são muito comuns na programação funcional, e espero dedicar uma série inteira a esse tópico posteriormente. </p><br><h1>  Recursos Adicionais </h1><br><p>  Existem muitos tutoriais para F #, incluindo materiais para quem vem com experiência em C # ou Java.  Os links a seguir podem ser úteis à medida que você avança no F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # para diversão e lucro</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprenda X em Y Minutos: F #</a> </li></ul><br><p>  Várias outras maneiras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de começar a aprender F #</a> também <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">são</a> descritas. </p><br><p>  Finalmente, a comunidade F # é muito amigável para iniciantes.  Há um bate-papo muito ativo no Slack, suportado pela F # Software Foundation, com salas para iniciantes nas quais você <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode participar livremente</a> .  É altamente recomendável que você faça isso! </p><br><p>  Não se esqueça de visitar o site da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comunidade de língua russa F #</a> !  Se você tiver alguma dúvida sobre o aprendizado de um idioma, teremos prazer em discuti-los nas salas de bate-papo: </p><br><ul><li>  room <code>#ru_general</code> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # Software Foundation Slack Chat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chat em telegrama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conversar em gitter</a> </li><li>  room #en_general no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # Software Foundation Slack Chat</a> </li></ul><br><h2>  Sobre autores de tradução </h2><br><p>  Traduzido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  As mudanças de tradução e editoriais foram feitas pelos esforços da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comunidade de desenvolvedores de F # de língua russa</a> .  Agradecemos também a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>@schvepsss</em></a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>@shwars</em></a> pela preparação deste artigo para publicação. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433398/">https://habr.com/ru/post/pt433398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433386/index.html">Como usar uma visão computacional para avaliar a condição do carro. Experimente o Yandex.Taxi</a></li>
<li><a href="../pt433388/index.html">Fã de fórmula ou por que jogamos jogos</a></li>
<li><a href="../pt433390/index.html">A Yandex juntou-se à proteção do Linux e da indústria de TI contra trolling de patentes</a></li>
<li><a href="../pt433392/index.html">Revisão do telefone IP Snom D725</a></li>
<li><a href="../pt433396/index.html">Frontend 2018: resultados do ano</a></li>
<li><a href="../pt433400/index.html">Tutorial Reagir Parte 2: Componentes Funcionais</a></li>
<li><a href="../pt433402/index.html">Pensamento funcional. Parte 8</a></li>
<li><a href="../pt433404/index.html">Tutorial Reagir Parte 3: Arquivos de Componentes, Estrutura do Projeto</a></li>
<li><a href="../pt433406/index.html">Pensamento funcional. Parte 9</a></li>
<li><a href="../pt433408/index.html">Manipulação eficiente de memória no Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>