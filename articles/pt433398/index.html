<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèª üë©‚Äçüë©‚Äçüëß‚Äçüë¶ üçù Pensamento funcional. Parte 7 üëàüèø üò° üî∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos nossa s√©rie de artigos sobre programa√ß√£o funcional em F #. Hoje temos um t√≥pico muito interessante: a defini√ß√£o de fun√ß√µes. Inclusive, vam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensamento funcional. Parte 7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433398/"><p>  Continuamos nossa s√©rie de artigos sobre programa√ß√£o funcional em F #.  Hoje temos um t√≥pico muito interessante: a defini√ß√£o de fun√ß√µes.  Inclusive, vamos falar sobre fun√ß√µes an√¥nimas, fun√ß√µes sem par√¢metros, fun√ß√µes recursivas, combinadores e muito mais.  Olhe embaixo do gato! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Primeira parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Segunda parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Terceira parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quarta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quinta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sexta parte</a></strong> <a name="habracut"></a></li></ul><br><h1>  Defini√ß√£o de Fun√ß√£o </h1><br><p>  J√° sabemos como criar fun√ß√µes regulares usando a sintaxe "let": </p><br><pre><code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Neste artigo, veremos outras maneiras de criar fun√ß√µes, al√©m de dicas para defini-las. </p><br><h2>  Fun√ß√µes an√¥nimas (lambdas) </h2><br><p>  Se voc√™ estiver familiarizado com lambdas em outros idiomas, os par√°grafos a seguir parecer√£o familiares.  Fun√ß√µes an√¥nimas (ou "express√µes lambda") s√£o definidas da seguinte maneira: </p><br><pre> <code class="plaintext hljs">fun parameter1 parameter2 etc -&gt; expression</code> </pre> <br><p>  Comparado √†s lambdas do C #, h√° duas diferen√ßas: </p><br><ul><li>  lambdas deve come√ßar com a palavra-chave <code>fun</code> , que n√£o √© necess√°ria em C # </li><li>  seta √∫nica <code>-&gt;</code> usada <code>-&gt;</code> , em vez de dupla <code>=&gt;</code> de C #. </li></ul><br><p>  Defini√ß√£o lambda da fun√ß√£o de adi√ß√£o: </p><br><pre> <code class="plaintext hljs">let add = fun xy -&gt; x + y</code> </pre> <br><p>  Mesma fun√ß√£o na forma tradicional: </p><br><pre> <code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Lambdas s√£o freq√ºentemente usadas na forma de pequenas express√µes ou quando n√£o h√° desejo de definir uma fun√ß√£o separada para uma express√£o.  Como voc√™ j√° viu, ao trabalhar com listas, isso n√£o √© incomum. </p><br><pre> <code class="plaintext hljs">//    let add1 i = i + 1 [1..10] |&gt; List.map add1 //        [1..10] |&gt; List.map (fun i -&gt; i + 1)</code> </pre> <br><p>  Observe que os par√™nteses devem ser usados ‚Äã‚Äãem torno das lambdas. </p><br><p>  Lambdas tamb√©m s√£o usados ‚Äã‚Äãquando uma fun√ß√£o claramente diferente √© necess√°ria.  Por exemplo, o " <code>adderGenerator</code> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discutido anteriormente, discutido anteriormente,</a> pode ser reescrito usando lambdas. </p><br><pre> <code class="plaintext hljs">//   let adderGenerator x = (+) x //     let adderGenerator x = fun y -&gt; x + y</code> </pre> <br><p>  A vers√£o lambda √© um pouco mais longa, mas imediatamente deixa claro que uma fun√ß√£o intermedi√°ria ser√° retornada. </p><br><p>  Lambdas podem ser aninhadas.  Outro exemplo de uma defini√ß√£o <code>adderGenerator</code> , desta vez apenas em lambdas. </p><br><pre> <code class="plaintext hljs">let adderGenerator = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Voc√™ est√° claro que todas as tr√™s defini√ß√µes s√£o equivalentes? </p><br><pre> <code class="plaintext hljs">let adderGenerator1 xy = x + y let adderGenerator2 x = fun y -&gt; x + y let adderGenerator3 = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Caso contr√°rio, leia novamente o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cap√≠tulo sobre curry</a> .  Isso √© muito importante para a compreens√£o! </p><br><h2>  Correspond√™ncia de padr√µes </h2><br><p>  Quando uma fun√ß√£o √© definida, √© poss√≠vel passar par√¢metros explicitamente, como nos exemplos acima, mas tamb√©m √© poss√≠vel comparar com um modelo diretamente na se√ß√£o de par√¢metros.  Em outras palavras, a se√ß√£o de par√¢metros pode conter padr√µes (padr√µes correspondentes), e n√£o apenas identificadores! </p><br><p>  O exemplo a seguir demonstra o uso de padr√µes em uma defini√ß√£o de fun√ß√£o: </p><br><pre> <code class="plaintext hljs">type Name = {first:string; last:string} //    let bob = {first="bob"; last="smith"} //   //     let f1 name = //   let {first=f; last=l} = name //     printfn "first=%s; last=%s" fl //   let f2 {first=f; last=l} = //        printfn "first=%s; last=%s" fl //  f1 bob f2 bob</code> </pre> <br><p>  Esse tipo de compara√ß√£o pode ocorrer apenas quando a correspond√™ncia √© sempre decid√≠vel.  Por exemplo, voc√™ n√£o pode combinar tipos e listas de uni√£o dessa maneira, porque alguns casos n√£o podem ser correspondidos. </p><br><pre> <code class="plaintext hljs">let f3 (x::xs) = //       printfn "first element is=%A" x</code> </pre> <br><p>  O compilador emitir√° um aviso sobre correspond√™ncia incompleta (uma lista vazia causar√° um erro no tempo de execu√ß√£o na entrada desta fun√ß√£o). </p><br><h2>  Erro comum: tuplas vs.  muitos par√¢metros </h2><br><p>  Se voc√™ vem de uma linguagem do tipo C, a tupla usada como √∫nico argumento da fun√ß√£o pode dolorosamente se assemelhar a uma fun√ß√£o de v√°rios par√¢metros.  Mas isso n√£o √© a mesma coisa!  Como observei anteriormente, se voc√™ vir uma v√≠rgula, provavelmente √© uma tupla.  Os par√¢metros s√£o separados por espa√ßos. </p><br><p>  Exemplo de confus√£o: </p><br><pre> <code class="plaintext hljs">//      let addTwoParams xy = x + y //      -  let addTuple aTuple = let (x,y) = aTuple x + y //         //        let addConfusingTuple (x,y) = x + y</code> </pre> <br><ul><li>  A primeira defini√ß√£o, " <code>addTwoParams</code> ", usa dois par√¢metros, separados por um espa√ßo. </li><li>  A segunda defini√ß√£o, " <code>addTuple</code> ", usa um par√¢metro.  Este par√¢metro liga "x" e "y" da tupla e os soma. </li><li>  A terceira defini√ß√£o, " <code>addConfusingTuple</code> ", usa um par√¢metro como " <code>addTuple</code> ", mas o truque √© que essa tupla seja descompactada (correspondida ao padr√£o) e vinculada como parte da defini√ß√£o de par√¢metro usando a correspond√™ncia de padr√µes.  Nos bastidores, tudo acontece exatamente da mesma forma que no <code>addTuple</code> . </li></ul><br><p>  Vejamos as assinaturas (sempre olhe para elas, se voc√™ n√£o tiver certeza de alguma coisa). </p><br><pre> <code class="plaintext hljs">val addTwoParams : int -&gt; int -&gt; int //   val addTuple : int * int -&gt; int // tuple-&gt;int val addConfusingTuple : int * int -&gt; int // tuple-&gt;int</code> </pre> <br><p>  E agora aqui: </p><br><pre> <code class="plaintext hljs">// addTwoParams 1 2 // ok --      addTwoParams (1,2) // error -     // =&gt; error FS0001: This expression was expected to have type // int but here has type 'a * 'b</code> </pre> <br><p>  Aqui vemos um erro na segunda chamada. </p><br><p>  Primeiramente, o compilador trata <code>(1,2)</code> como uma tupla generalizada do formul√°rio <code>('a * 'b)</code> , que tenta passar como o primeiro par√¢metro para <code>addTwoParams</code> .  Depois disso, ele reclama que o primeiro par√¢metro esperado <code>addTwoParams</code> n√£o <code>addTwoParams</code> <code>int</code> , mas foi feita uma tentativa de passar uma tupla. </p><br><p>  Para fazer uma tupla, use uma v√≠rgula! </p><br><pre> <code class="plaintext hljs">addTuple (1,2) // ok addConfusingTuple (1,2) // ok let x = (1,2) addTuple x // ok let y = 1,2 //  , //  ! addTuple y // ok addConfusingTuple y // ok</code> </pre> <br><p>  E vice-versa, se voc√™ passar v√°rios argumentos para uma fun√ß√£o aguardando uma tupla, tamb√©m receber√° um erro incompreens√≠vel. </p><br><pre> <code class="plaintext hljs">addConfusingTuple 1 2 // error --          // =&gt; error FS0003: This value is not a function and // cannot be applied</code> </pre> <br><p>  Dessa vez, o compilador decidiu que, depois que dois argumentos fossem <code>addConfusingTuple</code> , o <code>addConfusingTuple</code> deveria ser curry.  E a entrada " <code>addConfusingTuple 1</code> " √© um aplicativo parcial e deve retornar uma fun√ß√£o intermedi√°ria.  Tentar chamar essa fun√ß√£o intermedi√°ria com o par√¢metro "2" gerar√° um erro, porque  n√£o h√° fun√ß√£o intermedi√°ria!  Vemos o mesmo erro do cap√≠tulo sobre curry, onde discutimos problemas com muitos par√¢metros. </p><br><h3>  Por que n√£o usar tuplas como par√¢metros? </h3><br><p>  A discuss√£o das tuplas acima mostra outra maneira de definir fun√ß√µes com muitos par√¢metros: em vez de pass√°-las separadamente, todos os par√¢metros podem ser montados em uma estrutura.  No exemplo abaixo, a fun√ß√£o usa um √∫nico par√¢metro - uma tupla de tr√™s elementos. </p><br><pre> <code class="plaintext hljs">let f (x,y,z) = x + y * z //  - int * int * int -&gt; int //  f (1,2,3)</code> </pre> <br><p>  Note-se que a assinatura √© diferente da assinatura de uma fun√ß√£o com tr√™s par√¢metros.  H√° apenas uma seta, um par√¢metro e asteriscos apontando para a tupla <code>(int*int*int)</code> . </p><br><p>  Quando √© necess√°rio enviar argumentos com par√¢metros separados e quando uma tupla? </p><br><ul><li>  Quando as tuplas s√£o significativas em si mesmas.  Por exemplo, para opera√ß√µes no espa√ßo tridimensional, as tuplas triplas ser√£o mais convenientes do que tr√™s coordenadas separadamente. </li><li>  √Äs vezes, as tuplas s√£o usadas para combinar dados que devem ser armazenados juntos em uma √∫nica estrutura.  Por exemplo, os m√©todos <code>TryParse</code> da biblioteca .NET retornam o resultado e uma vari√°vel booleana como uma tupla.  Mas para armazenar uma grande quantidade de dados relacionados, √© melhor definir uma classe ou registro ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">registro</a> . </li></ul><br><h3>  Caso especial: Tuplas e fun√ß√µes da biblioteca .NET </h3><br><p>  Ao chamar bibliotecas .NET, v√≠rgulas s√£o muito comuns! </p><br><p>  Todos eles aceitam tuplas e as chamadas s√£o iguais √†s do C #: </p><br><pre> <code class="plaintext hljs">//  System.String.Compare("a","b") //   System.String.Compare "a" "b"</code> </pre> <br><p>  O motivo √© que as fun√ß√µes do .NET cl√°ssico n√£o s√£o curry e n√£o podem ser parcialmente aplicadas.  <em>Todos os</em> par√¢metros <em>sempre</em> devem ser transmitidos imediatamente, e a maneira mais √≥bvia √© usar uma tupla. </p><br><p>  Observe que essas chamadas parecem apenas transferir tuplas, mas esse √© realmente um caso especial.  Voc√™ n√£o pode passar tuplas reais para essas fun√ß√µes: </p><br><pre> <code class="plaintext hljs">let tuple = ("a","b") System.String.Compare tuple // error System.String.Compare "a","b" // error</code> </pre> <br><p>  Se voc√™ deseja aplicar parcialmente as fun√ß√µes .NET, basta escrever sobre elas, como foi feito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anteriormente</a> ou como mostrado abaixo: </p><br><pre> <code class="plaintext hljs">//    let strCompare xy = System.String.Compare(x,y) //    let strCompareWithB = strCompare "B" //      ["A";"B";"C"] |&gt; List.map strCompareWithB</code> </pre> <br><h2>  Guia para selecionar par√¢metros individuais e agrupados </h2><br><p>  A discuss√£o das tuplas leva a um t√≥pico mais geral: quando os par√¢metros devem ser separados e quando agrupados? </p><br><p>  Voc√™ deve prestar aten√ß√£o em como o F # difere do C # nesse sentido.  Em C #, <em>todos os</em> par√¢metros s√£o <em>sempre</em> passados, portanto, essa pergunta nem sequer aparece l√°!  No F #, devido √† aplica√ß√£o parcial, apenas alguns dos par√¢metros podem ser representados; portanto, √© necess√°rio distinguir entre o caso em que os par√¢metros devem ser combinados e o caso em que s√£o independentes. </p><br><p>  Recomenda√ß√µes gerais sobre como estruturar par√¢metros ao projetar suas pr√≥prias fun√ß√µes. </p><br><ul><li>  No caso geral, √© sempre melhor usar par√¢metros separados em vez de passar uma estrutura, seja uma tupla ou um registro.  Isso permite um comportamento mais flex√≠vel, como aplica√ß√£o parcial. </li><li>  Por√©m, quando um grupo de par√¢metros <em>precisa</em> ser passado por vez, algum tipo de mecanismo de agrupamento deve ser usado. </li></ul><br><p>  Em outras palavras, ao desenvolver uma fun√ß√£o, pergunte a si mesmo: "Posso fornecer esse par√¢metro separadamente?"  Se a resposta for n√£o, os par√¢metros devem ser agrupados. </p><br><p>  Vejamos alguns exemplos: </p><br><pre> <code class="plaintext hljs">//     . //      ,       let add xy = x + y //         //      ,    let locateOnMap (xCoord,yCoord) = //  //      //      -     type CustomerName = {First:string; Last:string} let setCustomerName aCustomerName = //  let setCustomerName first last = //   //     //     //    ,     let setCustomerName myCredentials aName = //</code> </pre> <br><p>  Por fim, verifique se a ordem dos par√¢metros ajudar√° na aplica√ß√£o parcial (consulte o manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ).  Por exemplo, por que coloquei <code>myCredentials</code> antes de <code>aName</code> na √∫ltima fun√ß√£o? </p><br><h2>  Fun√ß√µes sem par√¢metros </h2><br><p>  √Äs vezes, voc√™ pode precisar de uma fun√ß√£o que n√£o aceita nenhum par√¢metro.  Por exemplo, voc√™ precisa da fun√ß√£o "ol√° mundo", que pode ser chamada v√°rias vezes.  Como mostrado na se√ß√£o anterior, a defini√ß√£o ing√™nua n√£o funciona. </p><br><pre> <code class="plaintext hljs">let sayHello = printfn "Hello World!" //     </code> </pre> <br><p>  Mas isso pode ser corrigido adicionando um par√¢metro de unidade √† fun√ß√£o ou usando um lambda. </p><br><pre> <code class="plaintext hljs">let sayHello() = printfn "Hello World!" //  let sayHello = fun () -&gt; printfn "Hello World!" // </code> </pre> <br><p>  Depois disso, a fun√ß√£o deve sempre ser chamada com o argumento <code>unit</code> : </p><br><pre> <code class="plaintext hljs">//  sayHello()</code> </pre> <br><p>  O que acontece com frequ√™ncia ao interagir com bibliotecas .NET: </p><br><pre> <code class="plaintext hljs">Console.ReadLine() System.Environment.GetCommandLineArgs() System.IO.Directory.GetCurrentDirectory()</code> </pre> <br><p>  Lembre-se, chame-os com par√¢metros de <code>unit</code> ! </p><br><h2>  Definindo novos operadores </h2><br><p>  Voc√™ pode definir fun√ß√µes usando um ou mais caracteres do operador (consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> para obter uma lista de caracteres): </p><br><pre> <code class="plaintext hljs">//  let (.*%) xy = x + y + 1</code> </pre> <br><p>  Voc√™ deve usar par√™nteses nos caracteres para definir a fun√ß√£o. </p><br><p>  Os operadores que come√ßam com <code>*</code> requerem um espa√ßo entre par√™nteses e <code>*</code> , porque  em F # <code>(*</code> atua como o in√≠cio de um coment√°rio (como <code>/*...*/</code> em C #): </p><br><pre> <code class="plaintext hljs">let ( *+* ) xy = x + y + 1</code> </pre> <br><p>  Uma vez definida, uma nova fun√ß√£o pode ser usada da maneira usual se estiver entre colchetes: </p><br><pre> <code class="plaintext hljs">let result = (.*%) 2 3</code> </pre> <br><p>  Se a fun√ß√£o for usada com dois par√¢metros, voc√™ poder√° usar o registro do operador infix sem par√™nteses. </p><br><pre> <code class="plaintext hljs">let result = 2 .*% 3</code> </pre> <br><p>  Voc√™ tamb√©m pode definir operadores de prefixo come√ßando com <code>!</code>  ou <code>~</code> (com algumas restri√ß√µes, consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> ) </p><br><pre> <code class="plaintext hljs">let (~%%) (s:string) = s.ToCharArray() // let result = %% "hello"</code> </pre> <br><p>  No F #, definir instru√ß√µes √© uma opera√ß√£o bastante comum e muitas bibliotecas exportam instru√ß√µes com nomes como <code>&gt;=&gt;</code> e <code>&lt;*&gt;</code> . </p><br><h2>  Estilo sem ponto </h2><br><p>  J√° vimos muitos exemplos de fun√ß√µes que careciam dos par√¢metros mais recentes para reduzir o n√≠vel de caos.  Esse estilo √© chamado <strong>de estilo sem ponto</strong> ou <strong>programa√ß√£o t√°cita</strong> . </p><br><p>  Aqui est√£o alguns exemplos: </p><br><pre> <code class="plaintext hljs">let add xy = x + y //  let add x = (+) x // point free let add1Times2 x = (x + 1) * 2 //  let add1Times2 = (+) 1 &gt;&gt; (*) 2 // point free let sum list = List.reduce (fun sum e -&gt; sum+e) list //  let sum = List.reduce (+) // point free</code> </pre> <br><p>  Esse estilo tem seus pr√≥s e contras. </p><br><p>  Uma das vantagens √© que a √™nfase est√° na composi√ß√£o de fun√ß√µes de ordem superior, em vez de mexer com objetos de baixo n√≠vel.  Por exemplo, " <code>(+) 1 &gt;&gt; (*) 2</code> " √© uma adi√ß√£o expl√≠cita seguida por multiplica√ß√£o.  E " <code>List.reduce (+)</code> " deixa claro que a opera√ß√£o de adi√ß√£o √© importante, independentemente das informa√ß√µes da lista. </p><br><p>  Um estilo in√∫til permite que voc√™ se concentre no algoritmo b√°sico e identifique recursos comuns no c√≥digo.  A fun√ß√£o " <code>reduce</code> " usada acima √© um bom exemplo.  Este t√≥pico ser√° discutido em uma s√©rie planejada sobre o processamento de listas. </p><br><p>  Por outro lado, o uso excessivo desse estilo pode tornar o c√≥digo obscuro.  Par√¢metros expl√≠citos agem como documenta√ß√£o e seus nomes (como "lista") facilitam a compreens√£o do que a fun√ß√£o faz. </p><br><p>  Como tudo na programa√ß√£o, a melhor recomenda√ß√£o √© preferir a abordagem que forne√ßa mais clareza. </p><br><h2>  Combinadores </h2><br><p>  " <strong>Combinadores</strong> " s√£o chamados de fun√ß√µes cujo resultado depende apenas de seus par√¢metros.  Isso significa que n√£o h√° depend√™ncia do mundo exterior e, em particular, nenhuma outra fun√ß√£o ou valores globais podem afet√°-los. </p><br><p>  Na pr√°tica, isso significa que as fun√ß√µes combinat√≥rias s√£o limitadas por uma combina√ß√£o de seus par√¢metros de v√°rias maneiras. </p><br><p>  J√° vimos v√°rios combinadores: um operador de tubo e composi√ß√£o.  Se voc√™ observar as defini√ß√µes deles, ficar√° claro que tudo o que eles fazem √© reordenar os par√¢metros de v√°rias maneiras. </p><br><pre> <code class="plaintext hljs">let (|&gt;) xf = fx //  pipe let (&lt;|) fx = fx //  pipe let (&gt;&gt;) fgx = g (fx) //   let (&lt;&lt;) gfx = g (fx) //  </code> </pre> <br><p>  Por outro lado, fun√ß√µes como "printf", embora primitivas, n√£o s√£o combinadoras porque s√£o dependentes do mundo externo (E / S). </p><br><h3>  Aves combinat√≥rias </h3><br><p>  Os combinadores s√£o a base de toda uma se√ß√£o da l√≥gica (naturalmente chamada de "l√≥gica combinat√≥ria"), que foi inventada muitos anos antes dos computadores e das linguagens de programa√ß√£o.  A l√≥gica combinat√≥ria tem uma influ√™ncia muito grande na programa√ß√£o funcional. </p><br><p>  Para aprender mais sobre combinadores e l√≥gica combinat√≥ria, recomendo o livro de Raymond Smullyan, "To Mock a Mockingbird".  Nele, ele explica outros combinadores e fantasia-lhes <a href="">nomes de p√°ssaros</a> .  Aqui est√£o alguns exemplos de combinadores padr√£o e seus nomes de p√°ssaros: </p><br><pre> <code class="plaintext hljs">let I x = x //  ,  Idiot bird let K xy = x // the Kestrel let M x = x &gt;&gt; x // the Mockingbird let T xy = yx // the Thrush ( !) let Q xyz = y (xz) // the Queer bird ( !) let S xyz = xz (yz) // The Starling //   ... let rec Y fx = f (Y f) x // Y-,  Sage bird</code> </pre> <br><p>  Os nomes das letras s√£o bastante padr√£o, portanto, voc√™ pode consultar o combinador K para qualquer pessoa familiarizada com esta terminologia. </p><br><p>  Acontece que muitos padr√µes de programa√ß√£o comuns podem ser representados por esses combinadores padr√£o.  Por exemplo, o Kestrel √© um padr√£o regular na interface fluente em que voc√™ faz algo, mas retorna o objeto original.  Thrush √© um pipe, Queer √© uma composi√ß√£o direta e o combinador Y faz um excelente trabalho na cria√ß√£o de fun√ß√µes recursivas. </p><br><p>  De fato, existe um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teorema bem conhecido de</a> que qualquer fun√ß√£o comput√°vel pode ser constru√≠da usando apenas dois combinadores b√°sicos, Kestrel e Starling. </p><br><h3>  Bibliotecas Combinat√≥rias </h3><br><p>  Bibliotecas combinat√≥rias s√£o bibliotecas que exportam muitas fun√ß√µes combinat√≥rias projetadas para serem compartilhadas.  Um usu√°rio dessa biblioteca pode facilmente combinar fun√ß√µes para obter fun√ß√µes ainda maiores e mais complexas, como cubos facilmente. </p><br><p>  Uma biblioteca combinadora bem projetada permite que voc√™ se concentre em fun√ß√µes de alto n√≠vel e oculte "ru√≠do" de baixo n√≠vel.  J√° vimos seu poder em v√°rios exemplos da s√©rie "por que usar F #", e o m√≥dulo <code>List</code> est√° cheio dessas fun√ß√µes, " <code>fold</code> " e " <code>map</code> " tamb√©m s√£o combinadores, se voc√™ pensar bem. </p><br><p>  Outra vantagem dos combinadores √© que eles s√£o o tipo mais seguro de fun√ß√£o.  Porque  eles n√£o t√™m depend√™ncias do mundo exterior e n√£o podem mudar quando o ambiente global muda.  Uma fun√ß√£o que l√™ um valor global ou usa fun√ß√µes de biblioteca pode interromper ou mudar entre chamadas, se o contexto mudar.  Isso nunca acontecer√° aos combinadores. </p><br><p>  No F #, as bibliotecas combinadoras est√£o dispon√≠veis para an√°lise (FParsec), cria√ß√£o de HTML, estruturas de teste etc.  Discutiremos e usaremos combinadores mais adiante na pr√≥xima s√©rie. </p><br><h2>  Fun√ß√µes recursivas </h2><br><p>  Muitas vezes, uma fun√ß√£o precisa se referir a si mesma a partir de seu corpo.  Um exemplo cl√°ssico √© a fun√ß√£o Fibonacci. </p><br><pre> <code class="plaintext hljs">let fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Infelizmente, esta fun√ß√£o n√£o poder√° compilar: </p><br><pre> <code class="plaintext hljs">error FS0039: The value or constructor 'fib' is not defined</code> </pre> <br><p>  Voc√™ deve informar ao compilador que esta √© uma fun√ß√£o recursiva usando a palavra-chave <code>rec</code> . </p><br><pre> <code class="plaintext hljs">let rec fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Fun√ß√µes recursivas e estruturas de dados s√£o muito comuns na programa√ß√£o funcional, e espero dedicar uma s√©rie inteira a esse t√≥pico posteriormente. </p><br><h1>  Recursos Adicionais </h1><br><p>  Existem muitos tutoriais para F #, incluindo materiais para quem vem com experi√™ncia em C # ou Java.  Os links a seguir podem ser √∫teis √† medida que voc√™ avan√ßa no F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # para divers√£o e lucro</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprenda X em Y Minutos: F #</a> </li></ul><br><p>  V√°rias outras maneiras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de come√ßar a aprender F #</a> tamb√©m <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√£o</a> descritas. </p><br><p>  Finalmente, a comunidade F # √© muito amig√°vel para iniciantes.  H√° um bate-papo muito ativo no Slack, suportado pela F # Software Foundation, com salas para iniciantes nas quais voc√™ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode participar livremente</a> .  √â altamente recomend√°vel que voc√™ fa√ßa isso! </p><br><p>  N√£o se esque√ßa de visitar o site da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comunidade de l√≠ngua russa F #</a> !  Se voc√™ tiver alguma d√∫vida sobre o aprendizado de um idioma, teremos prazer em discuti-los nas salas de bate-papo: </p><br><ul><li>  room <code>#ru_general</code> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # Software Foundation Slack Chat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chat em telegrama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conversar em gitter</a> </li><li>  room #en_general no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # Software Foundation Slack Chat</a> </li></ul><br><h2>  Sobre autores de tradu√ß√£o </h2><br><p>  Traduzido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  As mudan√ßas de tradu√ß√£o e editoriais foram feitas pelos esfor√ßos da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comunidade de desenvolvedores de F # de l√≠ngua russa</a> .  Agradecemos tamb√©m a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>@schvepsss</em></a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>@shwars</em></a> pela prepara√ß√£o deste artigo para publica√ß√£o. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433398/">https://habr.com/ru/post/pt433398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433386/index.html">Como usar uma vis√£o computacional para avaliar a condi√ß√£o do carro. Experimente o Yandex.Taxi</a></li>
<li><a href="../pt433388/index.html">F√£ de f√≥rmula ou por que jogamos jogos</a></li>
<li><a href="../pt433390/index.html">A Yandex juntou-se √† prote√ß√£o do Linux e da ind√∫stria de TI contra trolling de patentes</a></li>
<li><a href="../pt433392/index.html">Revis√£o do telefone IP Snom D725</a></li>
<li><a href="../pt433396/index.html">Frontend 2018: resultados do ano</a></li>
<li><a href="../pt433400/index.html">Tutorial Reagir Parte 2: Componentes Funcionais</a></li>
<li><a href="../pt433402/index.html">Pensamento funcional. Parte 8</a></li>
<li><a href="../pt433404/index.html">Tutorial Reagir Parte 3: Arquivos de Componentes, Estrutura do Projeto</a></li>
<li><a href="../pt433406/index.html">Pensamento funcional. Parte 9</a></li>
<li><a href="../pt433408/index.html">Manipula√ß√£o eficiente de mem√≥ria no Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>