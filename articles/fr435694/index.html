<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèΩ üôä üíª Comment et pourquoi nous avons optimis√© l'algorithme de nettoyage des caches SLAB dans le noyau Linux ü§¥üèø üëÉüèª üë©‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La popularit√© croissante des conteneurs et leur utilisation conjointement avec des groupes de contr√¥le ont r√©v√©l√© un grave probl√®me d'√©volutivit√©, ce ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment et pourquoi nous avons optimis√© l'algorithme de nettoyage des caches SLAB dans le noyau Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/virtuozzo/blog/435694/">  La popularit√© croissante des conteneurs et leur utilisation conjointement avec des groupes de contr√¥le ont r√©v√©l√© un grave probl√®me d'√©volutivit√©, ce qui entra√Æne une baisse significative des performances sur les grandes machines.  Le probl√®me est que le temps de contournement des caches SLAB d√©pend quadratique du nombre de conteneurs, et la consommation active de grandes quantit√©s de m√©moire dans une courte p√©riode peut entra√Æner le syst√®me √† entrer dans une boucle occup√©e, consommant 100% du temps du processeur.  Aujourd'hui, je voudrais vous dire comment nous avons r√©solu ce probl√®me en modifiant l'algorithme de comptabilit√© pour utiliser le groupe de contr√¥le memcg pour utiliser les objets de cache SLAB et en optimisant la fonction shrink_slab (). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99b/7f3/83b/99b7f383beadeec2c814a6792e507b6c.jpg" alt="Nettoyage de la m√©moire"><br><a name="habracut"></a><br>  Pourquoi la question de l'optimisation des processus dans le noyau s'est-elle pos√©e?  Tout a commenc√© avec le fait que l'un de nos clients, utilisant activement des conteneurs et des groupes de contr√¥le de la m√©moire (memcg), a attir√© l'attention sur les √©tranges pics de consommation de ressources processeur qui se produisent de temps en temps.  La charge syst√®me normale √©tait d'environ 50%, et aux heures de pointe, 100% du temps du processeur √©tait pris, et presque tout √©tait consomm√© par le noyau (temps sys). <br>  Le n≈ìud lui-m√™me √©tait multi-utilisateur et environ 200 conteneurs OpenVZ ont √©t√© lanc√©s dessus.  L'analyse a montr√© qu'un grand nombre d'utilisateurs ont cr√©√© des conteneurs Docker imbriqu√©s et des hi√©rarchies √† plusieurs niveaux de groupes de contr√¥le de la m√©moire.  Chaque conteneur de niveau sup√©rieur de niveau utilisateur contenait environ 20 points de montage et 20 groupes de m√©moire de contr√¥le (memcg) cr√©√©s par systemd.  De plus, il y avait des points de montage et des groupes de contr√¥le cr√©√©s par le Docker susmentionn√©.  Autrement dit, le n≈ìud √©tait lourdement charg√©, et la charge sur celui-ci √©tait beaucoup plus forte que la moyenne de tous nos autres clients.  Nous √©tions int√©ress√©s √† trouver la raison de l'apparition de ces pics, car le m√™me probl√®me pouvait appara√Ætre sur des machines moins occup√©es, o√π il √©tait √† peine perceptible (par exemple, donner des pics √† + 5% de temps sys, ce qui d√©grade les performances). <br><br>  En manipulant la perf, j'ai r√©ussi √† rattraper le pic et √† supprimer la piste.  Il s'est av√©r√© que la majeure partie du temps du processeur est consacr√©e √† l'effacement des caches SLAB, √† savoir les caches superblocs: <br><br><pre><code class="markdown hljs"><span class="hljs-bullet"><span class="hljs-bullet">- </span></span>100,00% 0,00% kswapd0 [kernel.vmlinux] [k] kthread - 99,31% balance<span class="hljs-emphasis"><span class="hljs-emphasis">_pgdat - 82,11% shrink_</span></span>zone - 61,69% shrink<span class="hljs-emphasis"><span class="hljs-emphasis">_slab - 58,29% super_</span></span>cache<span class="hljs-emphasis"><span class="hljs-emphasis">_count + 54,56% list_</span></span>lru<span class="hljs-emphasis"><span class="hljs-emphasis">_count_</span></span>one</code> </pre> <br><br>  Ici, il vaut la peine de faire une explication et de s'attarder sur cette question plus en d√©tail.  Tout le monde sait que le noyau met en cache les donn√©es inutilis√©es pendant un certain temps avant de lib√©rer enfin de la m√©moire.  Le noyau utilise largement ce principe.  Par exemple, le cache de pages contient des pages de donn√©es li√©es au fichier, ce qui acc√©l√®re consid√©rablement leur acc√®s r√©p√©t√© lors de la lecture (car vous n'avez pas besoin d'acc√©der √† nouveau au disque).  Dans notre cas, le probl√®me est survenu avec le cache de m√©tadonn√©es de superbloc contenu dans deux listes LRU: s_dentry_lru et s_inode_lru. <br><br>  <b>LRU (le moins r√©cemment utilis√©)</b> <b><br></b> <br>  struct lru_list pointe vers un tableau de listes li√©es, et chaque memcg actif correspond √† un √©l√©ment (list_lru_one) dans ce tableau.  Lorsqu'un certain objet SLAB n'est plus utilis√© par le noyau, le noyau l'ajoute √† l'une des listes li√©es du tableau (selon le memcg auquel appartient l'objet ou, en gros, quel memcg le processus a utilis√© lorsqu'il a cr√©√© cet objet).  Le tableau lui-m√™me est d√©crit comme suit (lru_list :: node :: memcg_lrus): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_memcg</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* array of per cgroup lists, indexed by memcg_cache_id */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lru</span></span></span><span class="hljs-class">[0];</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* may become negative during memcg reparenting */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_items; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> };</code> </pre><br>  lru [0] indique une liste d'objets li√©s √† memcg avec l'ID 0; <br>  lru [1] indique une liste d'objets li√©s √† memcg avec l'ID 1; <br>  ... <br>  lru [n] indique une liste d'objets li√©s √† memcg avec l'ID n; <br><br>  Les listes LRU s_dentry_lru et s_inode_lru apparaissent dans notre probl√®me et, comme leur nom l'indique, elles contiennent des objets de syst√®me de fichiers dentry et inode inutilis√©s. <br>  √Ä l'avenir, s'il n'y a pas assez de m√©moire dans le syst√®me ou un memcg sp√©cifique, certains des √©l√©ments de la liste sont finalement lib√©r√©s, et un m√©canisme sp√©cial appel√© r√©tr√©cisseur le fait. <br><br>  <b>Shrinker</b> <b><br></b> <br>  Lorsque le noyau doit allouer des pages de m√©moire, mais qu'il n'y a pas de m√©moire libre sur le n≈ìud NUMA ou dans le syst√®me, le m√©canisme de nettoyage d√©marre.  Il essaie de jeter ou de jeter une certaine quantit√© de disque: 1) des pages du contenu des fichiers du cache de pages;  2) pages li√©es √† la m√©moire anonyme dans un swap, et 3) objets SLAB mis en cache (le probl√®me que nous avons rencontr√© leur est li√©). <br><br>  L'√©limination d'une partie des objets SLAB mis en cache n'affecte pas directement la publication des pages: leur taille, en r√®gle g√©n√©rale, est nettement inf√©rieure √† la taille de la page, et une page contient des centaines d'objets.  Lorsqu'une partie des objets est lib√©r√©e, des lacunes de m√©moire libres apparaissent dans les pages SLAB, qui peuvent √™tre utilis√©es pour cr√©er d'autres objets SLAB.  Cet algorithme est volontairement accept√© dans le noyau: il est simple et assez efficace.  Un lecteur int√©ress√© peut voir la formule de s√©lection d'une partie des objets √† nettoyer dans la fonction do_shrink_slab (). <br><br>  Cette fonction effectue le nettoyage proprement dit d'une partie des objets, guid√©e par la description qui lui est transmise dans le r√©ducteur de structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrink_control *shrinkctl, struct shrinker *shrinker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> freeable = shrinker-&gt;count_objects(shrinker, shrinkctl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (freeable == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; total_scan = _(freeable); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (total_scan &gt;= batch_size) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret = shrinker-&gt;scan_objects(shrinker, shrinkctl); total_scan -= shrinkctl-&gt;nr_scanned; } ... }</code> </pre> <br>  Par rapport au superbloc de r√©tr√©cissement, ces fonctions sont impl√©ment√©es comme suit.  Chaque superbloc g√®re ses propres listes s_dentry_lru et s_inode_lru des objets inutilis√©s qui lui sont associ√©s: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">super_block</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrinker</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_shrink</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* per-sb shrinker handle */</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_dentry_lru</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_inode_lru</span></span></span><span class="hljs-class">;</span></span> ‚Ä¶ };</code> </pre> <br><br>  La m√©thode .count_objects renvoie le nombre d'objets: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ total_objects += list_lru_shrink_count(&amp;sb-&gt;s_dentry_lru, sc); total_objects += list_lru_shrink_count(&amp;sb-&gt;s_inode_lru, sc); <span class="hljs-comment"><span class="hljs-comment">/*     ) */</span></span> total_objects = vfs_pressure_ratio(total_objects); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total_objects; }</code> </pre> <br><br>  La m√©thode .scan_objects lib√®re en fait des objets: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_scan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     s_dentry_lru */</span></span> prune_dcache_sb(sb, sc); <span class="hljs-comment"><span class="hljs-comment">/*     s_inode_lru */</span></span> prune_icache_sb(sb, sc); }</code> </pre> <br>  Le nombre d'objets √† lib√©rer est pass√© dans le param√®tre sc.  En outre, memcg y est indiqu√©, dont les objets doivent √™tre jet√©s hors de la LRU: <br><br><pre> <b><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nid; <span class="hljs-comment"><span class="hljs-comment">/* ID NUMA  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_to_scan; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memcg</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* memcg */</span></span> };</code></b> </pre><br>  Ainsi, prune_dcache_sb () s√©lectionne une liste li√©e dans le tableau struct list_lru_memcg :: lru [] et travaille avec elle.  Prune_icache_sb () fait de m√™me. <br><br>  <b>Ancien algorithme de contournement de r√©tr√©cissement</b> <b><br></b> <br>  Avec l'approche standard, ¬´√©jecter¬ª des objets de SLAB sans m√©moire dans <br>  sc-&gt; target_mem_cgroup se produit comme suit: <br><br><pre> <code class="cpp hljs">shrink_node() { ‚Ä¶ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target_mem_cgroup</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      sc-&gt;target_mem_cgroup  */</span></span> memcg = mem_cgroup_iter(root, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;reclaim); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { ‚Ä¶ shrink_slab(memcg, ...); ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((memcg = mem_cgroup_iter(root, memcg, &amp;reclaim))); ... }</code> </pre><br>  Nous passons en revue tous les enfants memcg et appelons shrink_slab () pour chacun d'eux.  Ensuite, dans la fonction shrink_slab (), nous passons par tous les shrinkers et pour chacun d'eux appelons do_shrink_slab (): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">gfp_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gfp_mask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nid, struct mem_cgroup *memcg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ list_for_each_entry(shrinker, &amp;shrinker_list, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class"> = {</span></span> .nid = nid, .memcg = memcg, }; ret = do_shrink_slab(&amp;sc, shrinker, ...); } }</code> </pre><br>  Rappelons que pour chaque superbloc, son propre r√©tr√©cisseur est ajout√© √† cette liste.  Comptons combien de fois do_shrink_slab () sera appel√© pour le cas avec 200 conteneurs de 20 memcg et 20 points de montage dans chacun.  Au total, nous avons 200 * 20 points de montage et 200 * 20 groupes de contr√¥le.  S'il n'y a pas assez de m√©moire dans le memcg le plus haut, nous serons oblig√©s de contourner tous ses memcg enfants (c'est-√†-dire tout en g√©n√©ral), et pour chacun d'eux, appelez chacun du r√©tr√©cisseur √† partir de la liste de r√©tr√©cissement.  Ainsi, le noyau fera 200 * 20 * 200 * 20 = 16000000 appels √† la fonction do_shrink_slab (). <br><br>  De plus, le nombre √©crasant d'appels √† cette fonction sera inutile: les conteneurs sont g√©n√©ralement isol√©s entre eux, et la probabilit√© que CT1 utilise super_block2 cr√©√© dans CT2 est g√©n√©ralement faible.  Ou, ce qui est le m√™me, si memcg1 est un groupe de contr√¥le de CT1, alors l'√©l√©ment correspondant du tableau super_block2-&gt; s_dentry_lru-&gt; node-&gt; memcg_lrus-&gt; lru [memcg1_id] sera une liste vide et il n'y a aucun int√©r√™t √† appeler do_shrink_slab () pour cela. <br><br>  Ce probl√®me peut √™tre mod√©lis√© √† l'aide d'un simple script bash (les donn√©es du patchset, qui ont ensuite √©t√© transmises au noyau, sont utilis√©es ici): <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 1 &gt; /sys/fs/cgroup/memory/memory.use_hierarchy <span class="hljs-variable"><span class="hljs-variable">$mkdir</span></span> /sys/fs/cgroup/memory/ct <span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 4000M &gt; /sys/fs/cgroup/memory/ct/memory.kmem.limit_in_bytes <span class="hljs-variable"><span class="hljs-variable">$for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> `seq 0 4000`; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mkdir /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ &gt; /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/cgroup.procs; mkdir -ps/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; mount -t tmpfs <span class="hljs-variable"><span class="hljs-variable">$is</span></span>/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; touch s/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/file; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br>  Voyons ce qui se passe si vous appelez la proc√©dure de r√©initialisation du cache 5 fois de suite: <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br>  La premi√®re it√©ration dure 14 secondes, car les objets mis en cache sont vraiment en m√©moire: <i>0,00 utilisateur 13,78 syst√®me <b>0: 13,78 √©coul√©</b> 99% CPU.</i> <br>  La deuxi√®me it√©ration prend 5 secondes, bien qu'il n'y ait plus d'objets: <i>0.00user 5.59system <b>0: 05.60elapsed</b> 99% CPU.</i> <br>  La troisi√®me it√©ration prend 5 secondes: <i>0.00user 5.48system <b>0: 05.48elapsed</b> 99% CPU</i> <br>  La quatri√®me it√©ration prend 8 secondes: <i>0.00utilisateur 8.35system <b>0: 08.35elapsed</b> 99% CPU</i> <br>  La cinqui√®me it√©ration prend 8 secondes: <i>0,00 utilisateur 8,34 syst√®me <b>0: 08,35</b> CPU 99% <b>√©coul√©</b></i> <br><br>  Il est devenu √©vident que l'algorithme de contournement de r√©tr√©cissement utilis√© par le noyau vanilla n'est pas optimal, et nous devons le changer pour le mieux en termes d'√©volutivit√©. <br><br>  <b>Nouvel algorithme de contournement de r√©tr√©cissement</b> <b><br></b> <br>  √Ä partir du nouvel algorithme, je voulais atteindre les objectifs suivants: <br><br><ol><li>  le lib√©rer des d√©fauts de l'ancien et </li><li>  N'ajoutez pas de nouveaux verrous.  Appelez do_shrink_slab () uniquement lorsque cela a du sens (c'est-√†-dire que la liste li√©e correspondante du tableau s_dentry_lru ou du tableau s_inode_lru n'est pas vide), mais n'acc√©dez pas directement √† la m√©moire de la liste li√©e. </li></ol><br>  Il √©tait clair que cela ne pouvait √™tre fourni que par une nouvelle structure de donn√©es au-dessus de r√©tracteurs h√©t√©rog√®nes (il existe non seulement des r√©tr√©cisseurs du superbloc, mais √©galement d'autres objets de donn√©es non d√©crits dans cet article. Le lecteur peut se familiariser avec eux en recherchant le mot-cl√© prealloc_shrinker () dans le code du noyau).  La nouvelle structure de donn√©es devrait permettre le codage de deux √©tats: ¬´il est logique d'appeler do_shrink_slab ()¬ª et ¬´cela n'a aucun sens d'appeler do_shrink_slab ()¬ª. <br><br>  Les structures de donn√©es de type IDA ont √©t√© rejet√©es car  ils utilisent des verrous en eux-m√™mes.  La structure de donn√©es du champ de bits convient parfaitement √† ce r√¥le: elle permet la modification atomique de bits individuels et, en combinaison avec des barri√®res de m√©moire, vous permet de cr√©er un algorithme efficace sans utiliser de verrous. <br><br>  Chaque r√©ducteur obtient son propre identifiant unique (shrinker :: id), et chaque memcg obtient un bitmap capable de contenir le plus grand identifiant des identifiants actuellement enregistr√©s.  Lorsque le premier √©l√©ment est ajout√© √† la liste s_dentry_lru-&gt; node-&gt; memcg_lrus-&gt; lru [memcg_id], le bitmap memcg correspondant est d√©fini sur 1 bit avec le num√©ro shrinker-&gt; id.  M√™me chose avec s_inode_id. <br><br>  Maintenant, la boucle dans shrink_slab () peut √™tre optimis√©e pour contourner uniquement les r√©tr√©cisseurs n√©cessaires: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ for_each_set_bit(i, <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>, shrinker_nr_max) { ‚Ä¶ shrinker = idr_find(&amp;shrinker_idr, i); ‚Ä¶ do_shrink_slab(&amp;sc, shrinker, priority); ‚Ä¶ } }</code> </pre><br>  (Le nettoyage des bits est √©galement impl√©ment√© lorsque le r√©ducteur entre dans l'√©tat ¬´cela n'a aucun sens d'appeler do_shrink_slab (). Voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commit</a> Github pour plus de d√©tails. <br><br>  Si vous r√©p√©tez le test de r√©initialisation du cache, puis en utilisant le nouvel algorithme, il montre des r√©sultats nettement meilleurs: <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br>  Premi√®re it√©ration: <i>0.00user 1.10system <b>0: 01.10elapsed</b> 99% CPU</i> <i><br></i>  Deuxi√®me it√©ration: <i>0,00 utilisateur 0,00 syst√®me <b>0: 00,01</b> CPU 64% <b>√©coul√©</b></i> <i><br></i>  Troisi√®me it√©ration: <i>0,00 utilisateur 0,01 syst√®me <b>0: 00,01</b> CPU 82% <b>√©coul√©</b></i> <i><br></i>  Quatri√®me it√©ration: <i>0,00 utilisateur 0,00 syst√®me <b>0: 00,01</b> CPU 64% <b>√©coul√©</b></i> <i><br></i>  Cinqui√®me it√©ration: <i>0,00 utilisateur 0,01 syst√®me <b>0: 00,01</b> CPU 82% <b>√©coul√©</b></i> <br>  La dur√©e des deuxi√®me √† cinqui√®me it√©rations est de 0,01 seconde, <b>548 fois plus rapide qu'auparavant.</b> <br><br>  √âtant donn√© que des actions similaires pour r√©initialiser les caches se produisent avec chaque manque de m√©moire sur la machine, cette optimisation am√©liore consid√©rablement le fonctionnement des machines avec un grand nombre de conteneurs et de groupes de contr√¥le de m√©moire.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un ensemble de correctifs</a> (17 pi√®ces) a √©t√© accept√© dans le noyau vanilla, et vous pouvez le trouver √† partir de la version 4.19. <br><br>  Au cours de l'examen des correctifs, un employ√© de Google est apparu et il s'est av√©r√© qu'ils avaient le m√™me probl√®me.  Par cons√©quent, les patchs ont √©t√© test√©s sur un type de charge diff√©rent. <br>  En cons√©quence, le patchset a √©t√© adopt√© √† partir de la 9√®me it√©ration;  et son entr√©e dans le noyau de vanille a pris environ 4 mois.  Aujourd'hui encore, le patchset est inclus dans notre propre noyau Virtuozzo 7, √† partir de la version vz7.71.9 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435694/">https://habr.com/ru/post/fr435694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435684/index.html">Oak Ridge National Laboratory a r√©solu le principal probl√®me des d√©veloppeurs d'appareils spatiaux: la carence en plutonium 238</a></li>
<li><a href="../fr435686/index.html">Pavel Durov liquide Telegram Messenger LLP</a></li>
<li><a href="../fr435688/index.html">Exemple d'application Flutter Client Server</a></li>
<li><a href="../fr435690/index.html">[Quel est le probl√®me avec GraphQL] ... Et comment y faire face</a></li>
<li><a href="../fr435692/index.html">Y Combinator: ¬´Au d√©but, certaines des plus grandes entreprises technologiques ressemblent √† des jouets¬ª</a></li>
<li><a href="../fr435696/index.html">Antiquit√©s: publicit√© informatique 1997</a></li>
<li><a href="../fr435698/index.html">√âcrire votre propre bon gestionnaire de m√©moire</a></li>
<li><a href="../fr435700/index.html">Questions d'entretiens chez 8 Worst Vue.js</a></li>
<li><a href="../fr435702/index.html">Les trolls brevet√©s commencent et gagnent: comment je suis rest√© sans jeu</a></li>
<li><a href="../fr435704/index.html">Solutions architecturales pour un jeu mobile. Partie 2: commande et leurs files d'attente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>