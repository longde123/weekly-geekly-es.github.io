<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûø üõÄüèæ ‚öúÔ∏è Por que, por que e quando usar o ValueTask üìä üõ†Ô∏è üë©üèø‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta tradu√ß√£o surgiu gra√ßas ao bom coment√°rio 0x1000000 . 
 




 O .NET Framework 4 introduziu o espa√ßo System.Threading.Tasks e, com ele, a classe T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por que, por que e quando usar o ValueTask</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458828/"><p>  <sup>Esta tradu√ß√£o surgiu gra√ßas ao bom coment√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">0x1000000</a> .</sup> <sup><br></sup> </p><p><img src="https://habrastorage.org/webt/4t/kr/wh/4tkrwhp_br-sobqvgwwyimflsjq.jpeg" alt="imagem"></p><br><p>  O .NET Framework 4 introduziu o espa√ßo System.Threading.Tasks e, com ele, a classe Task.  Esse tipo e a tarefa &lt;TResult&gt; gerada aguardam muito tempo at√© serem reconhecidos pelos padr√µes no .NET como os principais aspectos do modelo de programa√ß√£o ass√≠ncrona que foi introduzido no C # 5 com suas instru√ß√µes async / waitit.  Neste artigo, falarei sobre novos tipos de ValueTask / ValueTask &lt;TResult&gt;, projetados para melhorar o desempenho de m√©todos ass√≠ncronos nos casos em que a sobrecarga da aloca√ß√£o de mem√≥ria deve ser levada em considera√ß√£o. </p><a name="habracut"></a><br><h3 id="task">  Tarefa </h3><br><p> A tarefa atua em diferentes fun√ß√µes, mas a principal √© a ‚Äúpromessa‚Äù (promessa), um objeto que representa a poss√≠vel conclus√£o de alguma opera√ß√£o.  Voc√™ inicia uma opera√ß√£o e obt√©m um objeto Task, que ser√° executado quando a opera√ß√£o for conclu√≠da, o que pode ocorrer no modo s√≠ncrono como parte da inicializa√ß√£o da opera√ß√£o (por exemplo, recebendo dados que j√° est√£o no buffer), no modo ass√≠ncrono com execu√ß√£o no momento em que voc√™ obt√©m a tarefa (recebendo dados n√£o do buffer, mas muito rapidamente) ou no modo ass√≠ncrono, mas depois de j√° ter a tarefa (recebendo dados de um recurso remoto).  Como a opera√ß√£o pode terminar de forma ass√≠ncrona, voc√™ bloqueia o fluxo de execu√ß√£o, aguarda o resultado (o que geralmente torna a assincronia da chamada sem sentido) ou cria uma fun√ß√£o de retorno de chamada que ser√° ativada ap√≥s a conclus√£o da opera√ß√£o.  No .Net 4, a cria√ß√£o de um retorno de chamada √© implementada pelos m√©todos ContinueWith do objeto Task, que demonstram explicitamente esse modelo ao aceitar uma fun√ß√£o delegada para execut√°-lo ap√≥s a execu√ß√£o da tarefa: </p><br><pre><code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p>  Mas, no .NET Framework 4.5 e C # 5, os objetos Task podem ser simplesmente chamados pelo operador wait, o que facilita o resultado de uma opera√ß√£o ass√≠ncrona, e o c√≥digo gerado otimizado para as op√ß√µes acima funcionar√° corretamente em todos os casos quando a opera√ß√£o for conclu√≠da no modo s√≠ncrono, r√°pido ass√≠ncrono ou ass√≠ncrono ao fazer callbacka: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  A tarefa √© uma classe muito flex√≠vel e possui v√°rias vantagens.  Por exemplo, voc√™ pode esperar v√°rias vezes para qualquer n√∫mero de consumidores de uma s√≥ vez.  Voc√™ pode coloc√°-lo em uma cole√ß√£o (dicion√°rio) para aguardar repetidamente no futuro, para us√°-lo como um cache dos resultados de chamadas ass√≠ncronas.  Voc√™ pode bloquear a execu√ß√£o enquanto aguarda a conclus√£o da tarefa, se necess√°rio.  E voc√™ pode escrever e aplicar v√°rias opera√ß√µes nos objetos Task (√†s vezes chamados de "combinadores"), por exemplo, "quando houver" por aguardar de forma ass√≠ncrona a primeira conclus√£o de v√°rias tarefas. <br>  Mas essa flexibilidade se torna sup√©rflua no caso mais comum: basta chamar a opera√ß√£o ass√≠ncrona e aguardar a conclus√£o da tarefa: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Aqui n√£o precisamos aguardar a execu√ß√£o v√°rias vezes.  N√£o precisamos garantir que as expectativas sejam competitivas.  N√£o precisamos executar o bloqueio s√≠ncrono.  N√£o escreveremos combinadores.  Estamos apenas aguardando a promessa de uma opera√ß√£o ass√≠ncrona ser conclu√≠da.  No final, √© assim que escrevemos o c√≥digo s√≠ncrono (por exemplo, TResult result = SomeOperation ();), e normalmente √© traduzido para async / waitit. </p><br><p>  Al√©m disso, o Task possui uma fraqueza potencial, especialmente quando um grande n√∫mero de inst√¢ncias √© criado, e alto rendimento e desempenho s√£o os principais requisitos - o Task √© uma classe.  Isso significa que qualquer opera√ß√£o que necessite de uma tarefa √© for√ßada a criar e colocar um objeto, e quanto mais objetos s√£o criados, mais trabalho para o coletor de lixo (GC) e esse trabalho consome recursos que poder√≠amos gastar em algo mais √∫til. </p><br><p>  O tempo de execu√ß√£o e as bibliotecas do sistema ajudam a atenuar esse problema em muitas situa√ß√µes.  Por exemplo, se escrevermos um m√©todo como este: </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p>  como regra, haver√° espa√ßo livre suficiente no buffer e a opera√ß√£o ser√° executada de forma s√≠ncrona.  Quando isso acontece, n√£o h√° necessidade de fazer nada com a tarefa, que deve ser retornada, j√° que n√£o h√° valor de retorno, isso est√° usando a tarefa como o equivalente a um m√©todo s√≠ncrono que retorna um valor vazio (vazio).  Portanto, o ambiente pode simplesmente armazenar em cache uma tarefa n√£o gen√©rica e us√°-la repetidamente como resultado da execu√ß√£o de qualquer m√©todo ass√≠ncrono que termina de forma s√≠ncrona (esse singleton em cache pode ser obtido via Task.CompletedTask).  Ou, por exemplo, voc√™ escreve: </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p>  e, em geral, espere que os dados j√° estejam no buffer, portanto, o m√©todo simplesmente verifica o valor de _bufferedCount, v√™ que √© maior que 0 e retorna verdadeiro;  e somente se ainda n√£o houver dados no buffer, voc√™ precisar√° executar uma opera√ß√£o ass√≠ncrona.  E como existem apenas dois resultados poss√≠veis do tipo Booleano (verdadeiro e falso), existem apenas dois objetos de Tarefas poss√≠veis necess√°rios para representar esses resultados, o ambiente pode armazenar em cache esses objetos e retorn√°-los com o valor correspondente sem alocar mem√≥ria.  Somente no caso de conclus√£o ass√≠ncrona, o m√©todo precisar√° criar uma nova tarefa, pois precisar√° ser retornada antes que o resultado da opera√ß√£o seja conhecido. <br></p><p>  O ambiente fornece armazenamento em cache para alguns outros tipos, mas n√£o √© realista armazenar em cache todos os tipos poss√≠veis.  Por exemplo, o seguinte m√©todo: </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p>  tamb√©m ser√° frequentemente executado de forma s√≠ncrona.  Mas, diferentemente de uma variante com resultado do tipo Boolean, esse m√©todo retorna Int32, que possui cerca de 4 bilh√µes de valores, e o armazenamento em cache de todas as variantes da tarefa &lt;int&gt; exigir√° centenas de gigabytes de mem√≥ria.  O ambiente fornece um cache pequeno para a tarefa &lt;int&gt;, mas um conjunto muito limitado de valores, por exemplo, se esse m√©todo terminar de forma s√≠ncrona (os dados j√° est√£o no buffer) com o valor de retorno 4, ser√° uma tarefa em cache, mas se o valor 42 for retornado, ser√° necess√°rio criar um novo. Tarefa &lt;int&gt;, semelhante a chamar Task.FromResult (42). </p><br><p>  Muitos m√©todos de biblioteca tentam suavizar isso fornecendo seu pr√≥prio cache.  Por exemplo, uma sobrecarga no .NET Framework 4.5 do m√©todo MemoryStream.ReadAsync sempre termina de forma s√≠ncrona, pois ele l√™ dados da mem√≥ria.  ReadAsync retorna uma tarefa &lt;int&gt;, onde um resultado Int32 indica quantos bytes foram lidos.  Esse m√©todo √© frequentemente usado em um loop, geralmente com o mesmo n√∫mero necess√°rio de bytes para cada chamada e, geralmente, essa necessidade √© atendida na √≠ntegra.  Portanto, para chamadas repetidas para o ReadAsync, √© razo√°vel esperar que a tarefa &lt;int&gt; retorne de forma s√≠ncrona com o mesmo valor da chamada anterior.  Portanto, um MemoryStream cria um cache para um objeto que retornou na √∫ltima chamada bem-sucedida.  E na pr√≥xima chamada, se o resultado for repetido, ele retornar√° o objeto em cache e, se n√£o, criar√° um novo com Task.FromResult, salve-o no cache e retorne-o. </p><br><p>  No entanto, existem muitos outros casos em que a opera√ß√£o √© executada de forma s√≠ncrona, mas o objeto Task &lt;TResult&gt; √© for√ßado a ser criado. </p><br><h4 id="valuetasktresult-i-sinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; e execu√ß√£o s√≠ncrona </h4><br><p>  Tudo isso exigiu a implementa√ß√£o de um novo tipo no .NET Core 2.0, dispon√≠vel nas vers√µes anteriores do .NET no pacote NuGet System.Threading.Tasks.Extensions: ValueTask &lt;TResult&gt;. <br>  O ValueTask &lt;TResult&gt; foi criado no .NET Core 2.0 como uma estrutura capaz de agrupar TResult e Task &lt;TResult&gt;.  Isso significa que ele pode ser retornado do m√©todo ass√≠ncrono e, se esse m√©todo for executado de forma s√≠ncrona e bem-sucedida, voc√™ n√£o precisar√° colocar nenhum objeto no heap: basta inicializar essa estrutura ValueTask &lt;TResult&gt; com o valor TResult e retorn√°-lo.  Somente no caso de execu√ß√£o ass√≠ncrona, o objeto Task &lt;TResult&gt; ser√° colocado e o ValueTask &lt;TResult&gt; o envolver√° (para minimizar o tamanho da estrutura e otimizar o caso de execu√ß√£o bem-sucedida, o m√©todo ass√≠ncrono, que termina com uma exce√ß√£o n√£o suportada, tamb√©m colocar√° a tarefa &lt;TResult&gt;. O ValueTask &lt;TResult&gt; tamb√©m apenas envolve a tarefa &lt;TResult&gt; e n√£o carrega consigo um campo adicional para armazenar Exce√ß√£o). </p><br><p>  Com base nisso, um m√©todo como MemoryStream.ReadAsync, mas retornando um ValueTask &lt;int&gt;, n√£o deve lidar com o cache, mas pode ser escrito assim: </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h4 id="valuetasktresult-i-asinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; e execu√ß√£o ass√≠ncrona </h4><br><p>  A capacidade de escrever um m√©todo ass√≠ncrono que pode ser conclu√≠do de forma s√≠ncrona sem a necessidade de posicionamento adicional para o resultado √© uma grande vit√≥ria.  √â por isso que o ValueTask &lt;TResult&gt; foi adicionado no .NET Core 2.0, e novos m√©todos que provavelmente ser√£o usados ‚Äã‚Äãem aplicativos que exigem desempenho agora s√£o anunciados com o retorno do ValueTask &lt;TResult&gt; em vez da Tarefa &lt;TResult&gt;.  Por exemplo, quando adicionamos uma nova sobrecarga ReadAsync da classe Stream ao .NET Core 2.1, para poder passar a Mem√≥ria em vez do byte [], retornamos o tipo ValueTask &lt;int&gt;.  Nesse formul√°rio, os objetos Stream (nos quais o m√©todo ReadAsync √© frequentemente executado de forma s√≠ncrona, como no exemplo anterior do MemoryStream) podem ser usados ‚Äã‚Äãcom muito menos aloca√ß√£o de mem√≥ria. <br></p><p>  No entanto, quando trabalhamos com servi√ßos com largura de banda muito alta, ainda queremos evitar a aloca√ß√£o de mem√≥ria o m√°ximo poss√≠vel, o que significa reduzir e eliminar a aloca√ß√£o de mem√≥ria ao longo da rota de execu√ß√£o ass√≠ncrona. <br>  No modelo de espera, para qualquer opera√ß√£o que seja conclu√≠da de forma ass√≠ncrona, precisamos da capacidade de retornar um objeto que represente a poss√≠vel conclus√£o da opera√ß√£o: o chamador precisa redirecionar o retorno de chamada que ser√° iniciado no final da opera√ß√£o, e isso requer um objeto exclusivo no heap, que pode servir como canal de transmiss√£o para esta opera√ß√£o em particular.  Isso, ao mesmo tempo, n√£o significa nada se esse objeto ser√° reutilizado ap√≥s a conclus√£o da opera√ß√£o.  Se esse objeto puder ser reutilizado, a API poder√° organizar um cache para um ou mais desses objetos e us√°-lo para opera√ß√µes sequenciais, no sentido de n√£o usar o mesmo objeto para v√°rias opera√ß√µes ass√≠ncronas intermedi√°rias, mas us√°-lo para acesso n√£o competitivo. <br>  No .NET Core 2.1, a classe ValueTask &lt;TResult&gt; foi aprimorada para oferecer suporte a pool e reutiliza√ß√£o semelhantes.  Em vez de apenas agrupar TResult ou Task &lt;TResult&gt;, uma classe revisada pode agrupar uma nova interface IValueTaskSource &lt;TResult&gt;.  Essa interface fornece a funcionalidade b√°sica necess√°ria para acompanhar uma opera√ß√£o ass√≠ncrona com um objeto ValueTask &lt;TResult&gt; da mesma maneira que a Tarefa &lt;TResult&gt;: </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted(Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  O m√©todo GetStatus √© usado para implementar propriedades como ValueTask &lt;TResult&gt; .IsCompleted, que retorna informa√ß√µes se uma opera√ß√£o ass√≠ncrona √© executada ou conclu√≠da e como √© conclu√≠da (bem-sucedida ou n√£o).  O m√©todo OnCompleted √© usado pelo objeto em espera para anexar um retorno de chamada para continuar a execu√ß√£o a partir do ponto de espera quando a opera√ß√£o for conclu√≠da.  E o m√©todo GetResult √© necess√°rio para obter o resultado da opera√ß√£o; portanto, ap√≥s a conclus√£o da opera√ß√£o, o chamador pode obter o objeto TResult ou passar qualquer exce√ß√£o lan√ßada. </p><br><p>  A maioria dos desenvolvedores n√£o precisa dessa interface: os m√©todos simplesmente retornam um objeto ValueTask &lt;TResult&gt;, que pode ser criado como um wrapper para um objeto que implementa essa interface, e o m√©todo de chamada permanecer√° no escuro.  Essa interface √© para desenvolvedores que precisam evitar a aloca√ß√£o de mem√≥ria ao usar uma API de desempenho cr√≠tico. </p><br><p>  Existem v√°rios exemplos dessa API no .NET Core 2.1.  Os m√©todos mais famosos s√£o Socket.ReceiveAsync e Socket.SendAsync com novas sobrecargas adicionadas no 2.1, por exemplo </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync(Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  Essa sobrecarga retorna uma ValueTask &lt;int&gt;.  Se a opera√ß√£o for conclu√≠da de forma s√≠ncrona, ela pode simplesmente retornar uma ValueTask &lt;int&gt; com o valor correspondente: </p><br><pre> <code class="plaintext hljs">int result = ‚Ä¶; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p>  Quando finalizado de forma ass√≠ncrona, ele pode usar um objeto do pool que implementa a interface: </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = ‚Ä¶; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  A implementa√ß√£o do soquete suporta um desses objetos no pool para recep√ß√£o e outro para transmiss√£o, pois n√£o pode haver mais de um objeto para cada dire√ß√£o aguardando para ser executado ao mesmo tempo.  Essas sobrecargas n√£o alocam mem√≥ria, mesmo no caso de uma opera√ß√£o ass√≠ncrona.  Esse comportamento √© mais aparente na classe NetworkStream. <br>  Por exemplo, no .NET Core 2.1 Stream fornece: </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync(Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p>  que √© redefinido no NetworkStream.  O m√©todo NetworkStream.ReadAsync simplesmente usa o m√©todo Socket.ReceiveAsync, para que os ganhos no Socket sejam transmitidos para o NetworkStream, e o NetworkStream.ReadAsync tamb√©m n√£o aloca mem√≥ria. </p><br><h4 id="neobobschyonnyy-valuetask">  ValueTask n√£o compartilhado </h4><br><p>  Quando ValueTask &lt;TResult&gt; apareceu no .NET Core 2.0, somente o caso de execu√ß√£o s√≠ncrona foi otimizado para excluir o posicionamento do objeto Task &lt;TResult&gt; se o valor TResult j√° estiver pronto.  Isso significava que a classe ValueTask n√£o gen√©rica n√£o era necess√°ria: para o caso de execu√ß√£o s√≠ncrona, o singleton Task.CompletedTask poderia simplesmente ser retornado do m√©todo, e isso foi feito pelo ambiente implicitamente nos m√©todos ass√≠ncronos que retornam Task. </p><br><p>  No entanto, com a obten√ß√£o de opera√ß√µes ass√≠ncronas sem alocar mem√≥ria, o uso do ValueTask n√£o compartilhado voltou a ser relevante.  No .NET Core 2.1, introduzimos os gen√©ricos ValueTask e IValueTaskSource.  Eles fornecem equivalentes diretos para vers√µes gen√©ricas, para uso semelhante, com apenas um valor de retorno vazio. </p><br><h4 id="realizaciya-ivaluetasksourceivaluetasksourcet">  Implementar IValueTaskSource / IValueTaskSource &lt;T&gt; </h4><br><p>  A maioria dos desenvolvedores n√£o deve implementar essas interfaces.  Al√©m disso, n√£o √© t√£o f√°cil.  Se voc√™ decidir fazer isso, v√°rias implementa√ß√µes no .NET Core 2.1 podem servir como ponto de partida, por exemplo: </p><br><ul><li>  AwaitableSocketAsyncEventArgs </li><li>  AsyncOperation &lt;TResult&gt; </li><li>  DefaultPipeReader </li></ul><br><p>  Para facilitar isso, no .NET Core 3.0, planejamos apresentar toda a l√≥gica necess√°ria inclu√≠da no tipo ManualResetValueTaskSourceCore &lt;TResult&gt;, uma estrutura que pode ser incorporada em outro objeto que implementa IValueTaskSource &lt;TResult&gt; e / ou IValueTaskSource, para que possa ser delegada a Essa estrutura √© a maior parte da funcionalidade.  Voc√™ pode aprender mais sobre isso em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/dotnet/corefx/issues/32664</a> no reposit√≥rio dotnet / corefx. </p><br><h4 id="patterny-primeneniya-valuetasks">  Padr√µes de aplicativos ValueTasks </h4><br><p>  √Ä primeira vista, o escopo de ValueTask e ValueTask &lt;TResult&gt; √© muito mais limitado que Task e Task &lt;TResult&gt;.  Isso √© bom e at√© esperado, j√° que a principal maneira de us√°-los √© simplesmente usar o operador wait. </p><br><p>  No entanto, como eles podem quebrar objetos que s√£o reutilizados, h√° restri√ß√µes significativas em seu uso em compara√ß√£o com a Tarefa e a Tarefa &lt;TResult&gt;, se voc√™ se afastar da maneira usual de espera simples.  Em casos gerais, as seguintes opera√ß√µes nunca devem ser executadas com ValueTask / ValueTask &lt;TResult&gt;: </p><br><ul><li>  <strong>Espera repetida ValueTask / ValueTask &lt;TResult&gt;</strong> O objeto de resultado j√° pode ser descartado e usado em outra opera√ß√£o.  Por outro lado, a Tarefa / Tarefa &lt;TResult&gt; nunca faz a transi√ß√£o de um estado conclu√≠do para um incompleto; portanto, voc√™ pode esperar novamente quantas vezes forem necess√°rias e obter o mesmo resultado todas as vezes. </li><li>  <strong>Espera paralela ValueTask / ValueTask &lt;TResult&gt;</strong> O objeto de resultado espera processar com apenas um retorno de chamada de um consumidor por vez, e tentar esperar de diferentes fluxos ao mesmo tempo pode facilmente levar a corridas e erros sutis do programa.  Al√©m disso, tamb√©m √© um caso mais espec√≠fico da opera√ß√£o anterior de ‚Äúre-espera‚Äù inv√°lida.  Em compara√ß√£o, a Tarefa / Tarefa &lt;TResult&gt; fornece qualquer n√∫mero de espera paralela. </li><li>  <strong>Usando .GetAwaiter (). GetResult () quando a opera√ß√£o ainda n√£o foi conclu√≠da. A</strong> implementa√ß√£o de IValueTaskSource / IValueTaskSource &lt;TResult&gt; n√£o precisa de suporte de bloqueio at√© que a opera√ß√£o seja conclu√≠da e, provavelmente, n√£o o far√°, portanto, essa opera√ß√£o definitivamente levar√° a corridas e provavelmente n√£o ser√° executado como o m√©todo de chamada espera.  Tarefa / Tarefa &lt;TResult&gt; bloqueia o encadeamento de chamada at√© que a tarefa seja conclu√≠da. </li></ul><br><p>  Se voc√™ recebeu um ValueTask ou ValueTask &lt;TResult&gt;, mas precisa executar uma dessas tr√™s opera√ß√µes, pode usar .AsTask (), obter Task / Task &lt;TResult&gt; e trabalhar com o objeto recebido.  Depois disso, voc√™ n√£o poder√° mais usar esse ValueTask / ValueTask &lt;TResult&gt;. </p><br><p>  Em resumo, a regra √© a seguinte: ao usar ValueTask / ValueTask &lt;TResult&gt;, voc√™ deve aguard√°-lo diretamente (possivelmente com .ConfigureAwait (false)) ou chamar AsTask () e n√£o us√°-lo mais: </p><br><pre> <code class="plaintext hljs">//   ,  ValueTask&lt;int&gt; public ValueTask&lt;int\&gt; SomeValueTaskReturningMethodAsync(); ... // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); //       , //     // BAD: await   ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: await  (    ) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD:  GetAwaiter().GetResult(),     ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p>  Espero que exista um padr√£o mais avan√ßado que os programadores possam aplicar somente ap√≥s medi√ß√µes cuidadosas e obten√ß√£o de vantagens significativas.  As classes ValueTask / ValueTask &lt;TResult&gt; t√™m v√°rias propriedades que relatam o estado atual da opera√ß√£o, por exemplo, a propriedade IsCompleted retornar√° true se a opera√ß√£o for conclu√≠da (ou seja, ela n√£o ser√° mais executada e conclu√≠da com √™xito ou sem √™xito) e a propriedade IsCompletedSuccessfully retornar√° true, apenas se for conclu√≠do com √™xito (enquanto aguarda e recebe o resultado, nenhuma exce√ß√£o foi lan√ßada).  Para os segmentos de execu√ß√£o mais exigentes, nos quais o desenvolvedor deseja evitar os custos que surgem no modo ass√≠ncrono, essas propriedades podem ser verificadas antes de uma opera√ß√£o que realmente destr√≥i o objeto ValueTask / ValueTask &lt;TResult&gt;, por exemplo, aguarde, .AsTask ().  Por exemplo, na implementa√ß√£o do SocketsHttpHandler no .NET Core 2.1, o c√≥digo l√™ da conex√£o e recebe uma ValueTask &lt;int&gt;.  Se esta opera√ß√£o for realizada de forma s√≠ncrona, n√£o precisamos nos preocupar com o encerramento antecipado da opera√ß√£o.  Mas, se for executado de forma ass√≠ncrona, precisamos conectar o processamento de interrup√ß√£o para que a solicita√ß√£o de interrup√ß√£o interrompa a conex√£o.  Como esse √© um trecho de c√≥digo muito estressante, se o perfil mostrar a necessidade das seguintes pequenas altera√ß√µes, ele poder√° ser estruturado da seguinte maneira: </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><h4 id="dolzhen-li-kazhdyy-novyy-metod-asinhronnogo-api-vozvraschat-valuetaskvaluetasktresult">  Todo novo m√©todo de API ass√≠ncrono deve retornar um ValueTask / ValueTask &lt;TResult&gt;? </h4><br><p>  Para responder brevemente: n√£o, por padr√£o ainda vale a pena escolher Tarefa / Tarefa &lt;TResult&gt;. <br>  Conforme destacado acima, a Tarefa e a Tarefa &lt;TResult&gt; s√£o mais f√°ceis de usar corretamente do que o ValueTask e o ValueTask &lt;TResult&gt;, e desde que os requisitos de desempenho n√£o superem os requisitos de praticidade, a Tarefa e a Tarefa &lt;TResult&gt; s√£o preferidas.  Al√©m disso, existem pequenos custos associados ao retorno de uma ValueTask &lt;TResult&gt; em vez de uma tarefa &lt;TResult&gt;, ou seja, os micro-benchmarks mostram que aguardar a tarefa &lt;TResult&gt; √© mais r√°pido do que esperar ValueTask &lt;TResult&gt;.  Portanto, se voc√™ usar o cache de tarefas, por exemplo, seu m√©todo retornar√° Tarefa ou Tarefa, para desempenho, vale a pena ficar com Tarefa ou Tarefa.  Os objetos ValueTask / ValueTask &lt;TResult&gt; ocupam v√°rias palavras na mem√≥ria; portanto, quando s√£o esperados e seus campos s√£o reservados na m√°quina de estado que chama o m√©todo ass√≠ncrono, eles ocupam mais mem√≥ria. <br></p><p>  - ValueTask/ValueTask&lt;TResult&gt;    : )  ,        await, )        , )     ,          .   ,                /  . </p><br><h4 id="chto-dalshe-s-valuetask-i-valuetasktresult">    ValueTask  ValueTask&lt;TResult&gt;? </h4><br><p>    .NET      ,  Task/Task&lt;TResult&gt;,  ,  ValueTask/ValueTask&lt;TResult&gt;,     ,   .      ‚Äì   IAsyncEnumerator&lt;T&gt;,     .NET Core 3.0. IEnumerator&lt;T&gt;   MoveNext,   bool,     IAsyncEnumerator&lt;T&gt;   MoveNextAsync.     , ,     Task,             . ,   ,       ,        (           ),        await   foreach,      ValueTask.        ,         .      C#   ,    ,     ,   . </p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458828/">https://habr.com/ru/post/pt458828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458812/index.html">JVM TI: como criar um plug-in para uma m√°quina virtual</a></li>
<li><a href="../pt458814/index.html">Lan√ßar um site para um produto com demanda n√£o formada</a></li>
<li><a href="../pt458818/index.html">Contempor√¢neos proeminentes</a></li>
<li><a href="../pt458820/index.html">Sobre a implementa√ß√£o do famoso g√™nero na plataforma Minecraft</a></li>
<li><a href="../pt458826/index.html">Como eliminar artigos antigos para que eles cres√ßam muito no org√¢nico: + 104% do tr√°fego por seis meses</a></li>
<li><a href="../pt458830/index.html">Webinars da Dell Technologies: todos os detalhes do nosso tutorial</a></li>
<li><a href="../pt458832/index.html">Cinco alunos e tr√™s lojas de valores-chave distribu√≠dos</a></li>
<li><a href="../pt458834/index.html">Lado da personalidade de Paul Allen, sobre o qual poucas pessoas sabiam como eu gostaria</a></li>
<li><a href="../pt458836/index.html">√çndice Borsch. Uma abordagem sistem√°tica para avaliar, comparar, determinar a rela√ß√£o pre√ßo / qualidade</a></li>
<li><a href="../pt458840/index.html">Como perfuramos o grande firewall chin√™s (parte 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>