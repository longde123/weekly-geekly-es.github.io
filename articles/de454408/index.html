<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêë üë®‚Äçüîß ü§º CortexM3 / M4 (ARM) -Hardware-Bitbanding, Kernelarchitektur, Assembler, C / C ++ 14 und ein Tropfen Metaprogrammierung üë∏üèª ‚õÖÔ∏è ü•°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Achtung, dies ist kein weiterer "Hallo Welt" -Artikel dar√ºber, wie man eine LED blinkt oder in ihren ersten Interrupt auf STM32 ger√§t. Ic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CortexM3 / M4 (ARM) -Hardware-Bitbanding, Kernelarchitektur, Assembler, C / C ++ 14 und ein Tropfen Metaprogrammierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454408/"><h2>  Einf√ºhrung </h2><br>  Achtung, dies ist kein weiterer "Hallo Welt" -Artikel dar√ºber, wie man eine LED blinkt oder in ihren ersten Interrupt auf STM32 ger√§t.  Ich habe jedoch versucht, umfassende Erkl√§rungen zu allen aufgeworfenen Fragen zu geben, so dass der Artikel nicht nur f√ºr viele Fachleute n√ºtzlich sein wird und davon tr√§umt, solche Entwickler zu werden (wie ich hoffe), sondern auch f√ºr unerfahrene Mikrocontroller-Programmierer, da dieses Thema aus irgendeinem Grund auf unz√§hligen Websites / herumkommt. Blogs "MK Programmierlehrer." <br><br><img src="https://habrastorage.org/webt/e5/rs/75/e5rs75rpejygxwippglfvpftzci.png" alt="Bild"><br><a name="habracut"></a><br><h2>  Warum habe ich beschlossen, dies zu schreiben? </h2><br>  Obwohl ich √ºbertrieben habe, nachdem ich zuvor gesagt habe, dass das Hardware-Bit-Banding der Cortex-M-Familie nicht auf speziellen Ressourcen beschrieben wird, gibt es immer noch Stellen, an denen diese Funktion behandelt wird (und hier sogar einen Artikel erf√ºllt), aber dieses Thema muss eindeutig erg√§nzt und modernisiert werden.  Ich stelle fest, dass dies auch f√ºr englischsprachige Ressourcen gilt.  Im n√§chsten Abschnitt werde ich erkl√§ren, warum diese Kernelfunktion extrem wichtig sein kann. <br><br><h2>  Theorie </h2><br>  <i>(und diejenigen, die sie kennen, k√∂nnen sofort in die Praxis einsteigen)</i> <br>  Hardware-Bit-Banding ist ein Merkmal des Kerns selbst und h√§ngt daher nicht von der Familie und dem Unternehmen des Mikrocontroller-Herstellers ab. Hauptsache, der Kern ist geeignet.  In unserem Fall sei es Cortex-M3.  Daher sollten Informationen zu diesem Thema in einem offiziellen Dokument √ºber den Kern selbst eingeholt werden. Es gibt ein solches Dokument. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier wird</a> in Abschnitt 4.2 ausf√ºhrlich beschrieben, wie dieses Tool verwendet wird. <br><br>  Hier m√∂chte ich einen kleinen technischen Exkurs f√ºr Programmierer machen, die mit Assembler nicht vertraut sind, von denen die Mehrheit jetzt aufgrund der propagierten Komplexit√§t und Nutzlosigkeit von Assembler f√ºr so "ernsthafte" 32-Bit-Mikrocontroller wie STM32, LPC usw. ist. Au√üerdem kann man h√§ufig auf Versuche sto√üen Kritik f√ºr den Einsatz von Assembler in diesem Bereich, auch auf dem Habr.  In diesem Abschnitt m√∂chte ich kurz den Mechanismus des Schreibens in den MK-Speicher beschreiben, der die Vorteile der Bitbandierung verdeutlichen soll. <br><br>  Ich werde ein spezielles einfaches Beispiel f√ºr die meisten STM32 erkl√§ren.  Angenommen, ich muss PB0 in einen Allzweckausgang verwandeln.  Eine typische L√∂sung w√ºrde folgenderma√üen aussehen: <br><br><pre><code class="cpp hljs">GPIOB-&gt;MODER |= GPIO_MODER_MODER0_0;</code> </pre> <br>  Offensichtlich verwenden wir das bitweise "ODER", um die verbleibenden Bits des Registers nicht zu √ºberschreiben. <br><br>  F√ºr den Compiler bedeutet dies den folgenden Satz von 4 Anweisungen: <br><br><ol><li>  Laden Sie GPIOB-&gt; MODER in das Allzweckregister (RON) herunter. </li><li>  Laden Sie die Werte von p1 auf die in der ROZ angegebene Adresse auf die andere ROZ hoch. </li><li>  Machen Sie mit GPIO_MODER_MODER0_0 ein bitweises ODER aus diesem Wert. </li><li>  Laden Sie das Ergebnis zur√ºck auf GPIOB-&gt; MODER. </li></ol><br>  Au√üerdem sollte man nicht vergessen, dass dieser Kernel den Befehlssatz thumb2 verwendet, was bedeutet, dass die Lautst√§rke unterschiedlich sein kann.  Ich stelle auch fest, dass wir √ºberall √ºber den Grad der Optimierung von O3 sprechen. <br><br>  In der Assemblersprache sieht es so aus: <br><br><img src="https://habrastorage.org/webt/kt/px/tf/ktpxtfc4bapih79fj96yf7poi64.png" alt="Bild"><br><br>  Es ist ersichtlich, dass der allererste Befehl nichts anderes als ein Pseudobefehl mit einem Versatz ist. Wir finden die Adresse des Registers an der PC-Adresse (angesichts des F√∂rderbandes) + 0x58. <br><br><img src="https://habrastorage.org/webt/wf/ar/ea/wfareavtgdjjmqckiemg0jfbygs.png" alt="Bild"><br><br>  Es stellt sich heraus, dass wir 4 Schritte (und mehr Taktzyklen) und 14 Bytes belegten Speicher pro Operation haben. <br>  Wenn Sie mehr dar√ºber wissen wollen, dann empfehle ich das Buch [2], das es √ºbrigens auch auf Russisch gibt. <br><br><h3>  Wir gehen zur bit_banding-Methode √ºber. </h3><br>  Das Wesentliche ist laut dem Bauern, dass der Prozessor einen speziell zugewiesenen Speicherbereich hat, der die Werte schreibt, in die wir keine anderen Bits des Peripherieregisters oder des RAM √§ndern.  Das hei√üt, wir m√ºssen die oben beschriebenen Punkte 2) und 3) nicht erf√ºllen, und dazu reicht es aus, nur die Adresse gem√§√ü den Formeln aus [1] wiederzugeben. <br><br><img src="https://habrastorage.org/webt/t1/fo/yu/t1foyujiyauoiecjczide1myroi.png" alt="Bild"><br><br>  Wir versuchen, eine √§hnliche Operation durchzuf√ºhren, ihren Assembler: <br><br><img src="https://habrastorage.org/webt/j_/g-/6d/j_g-6dq9yi1cjt0yxbo7rzqbmrw.png" alt="Bild"><br><br>  Neu berechnete Adresse: <br><br><img src="https://habrastorage.org/webt/du/1k/qp/du1kqpsrhjinmp6y4i2hkuqeut4.png" alt="Bild"><br><br>  Hier haben wir eine Schreibanweisung Nr. 1 in den ROZ eingef√ºgt, aber das Ergebnis sind 10 Bytes anstelle von 14 und ein paar Taktzyklen weniger. <br><br><h2>  Aber was ist, wenn der Unterschied l√§cherlich ist? </h2><br>  Einerseits sind die Einsparungen nicht signifikant, insbesondere in Zyklen, in denen es bereits √ºblich ist, den Controller auf 168 MHz zu √ºbertakten.  In einem durchschnittlichen Projekt liegen die Momente, in denen Sie diese Methode anwenden k√∂nnen, zwischen 40 und 80. In Byte k√∂nnen die Einsparungen 250 Byte erreichen, wenn sich die Adressen unterscheiden.  Und wenn wir bedenken, dass das Programmieren von MK direkt in Registern jetzt als "zashkvar" angesehen wird und es "cool" ist, alle Arten von W√ºrfelw√ºrfeln zu verwenden, k√∂nnen die Einsparungen viel h√∂her sein. <br><br>  Die Zahl von 250 Bytes wird auch durch die Tatsache verzerrt, dass Bibliotheken auf hoher Ebene aktiv in der Community verwendet werden und die Firmware auf unanst√§ndige Gr√∂√üen aufgeblasen wird.  Bei niedriger Programmierung sind dies mindestens 2 - 5% des Softwarevolumens f√ºr ein durchschnittliches Projekt mit kompetenter Architektur und O3-Optimierung. <br><br>  <i>Auch hier m√∂chte ich nicht sagen, dass dies eine Art Super-Duper-Mega-Cool-Tool ist, das jeder MK-Programmierer mit Selbstachtung verwenden sollte.</i>  <i>Aber wenn ich die Kosten auch nur um einen so kleinen Teil senken kann, warum dann nicht?</i> <br><br><h2>  Implementierung </h2><br>  Alle Optionen werden nur zur Konfiguration der Peripherieger√§te angegeben, da ich nicht auf eine Situation gesto√üen bin, in der RAM erforderlich w√§re.  Genau genommen ist die Formel f√ºr RAM √§hnlich. √Ñndern Sie einfach die Basisadressen f√ºr die Berechnung.  Wie setzen Sie das um? <br><br><h4>  Assembler </h4><br>  Lass uns von unten gehen, von meinem geliebten Assembler. <br><br>  Bei Assembler-Projekten ordne ich normalerweise ein paar 2-Byte-ROZ (gem√§√ü den Anweisungen, die mit ihnen funktionieren) RON unter # 0 und # 1 f√ºr das gesamte Projekt zu und verwende sie auch in Makros, wodurch ich kontinuierlich weitere 2 Bytes reduziere.  Bemerkung, ich habe CMSIS in Assembler f√ºr STM nicht gefunden, weil ich die Bitnummer sofort in das Makro eingef√ºgt habe und nicht den Registerwert. <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung f√ºr GNU Assembler</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">@  . MOVW R0, 0x0000 MOVW R1, 0x0001 @   .macro PeriphBitSet PerReg, BitNum LDR R3, =(BIT_BAND_ALIAS+(((\PerReg) - BIT_BAND_REGION) * 32) + ((\BitNum) * 4)) STR R1, [R3] .endm @   .macro PeriphBitReset PerReg, BitNum LDR R3, =(BIT_BAND_ALIAS+((\PerReg - BIT_BAND_REGION) * 32) + (\BitNum * 4)) STR R0, [R3] .endm</code> </pre> <br></div></div><br>  Beispiele: <br><br><div class="spoiler">  <b class="spoiler_title">Assembler-Beispiele</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">PeriphSet TIM2_CCR2, 0 PeriphBitReset USART1_SR, 5</code> </pre><br></div></div><br>  Der zweifelsfreie Vorteil dieser Option besteht darin, dass wir die volle Kontrolle haben, was √ºber weitere Optionen nicht gesagt werden kann.  Und wie der letzte Abschnitt des Artikels zeigen wird, ist dieser <b>sehr</b> bedeutsam. <br><br>  Es ben√∂tigt jedoch niemand Projekte f√ºr MK in Assembler, etwa ab dem Ende der Null, was bedeutet, dass Sie zu SI wechseln m√ºssen. <br><br><h4>  Ebene c </h4><br>  Ehrlich gesagt, habe ich am Anfang des Pfades irgendwo im riesigen Netzwerk eine einfache Sishny-Option gefunden.  Zu diesem Zeitpunkt habe ich bereits Bit-Banding in Assembler implementiert und bin versehentlich auf eine C-Datei gesto√üen. Es hat sofort funktioniert und ich habe beschlossen, nichts zu erfinden. <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung f√ºr einfaches C.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*!&lt;=================PLAIN C SECTION========================&gt;!*/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT31(A) (A==0x80000000)? 31 : 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT30(A) (A==0x40000000)? 30 : MASK_TO_BIT31(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT29(A) (A==0x20000000)? 29 : MASK_TO_BIT30(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT28(A) (A==0x10000000)? 28 : MASK_TO_BIT29(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT27(A) (A==0x08000000)? 27 : MASK_TO_BIT28(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT26(A) (A==0x04000000)? 26 : MASK_TO_BIT27(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT25(A) (A==0x02000000)? 25 : MASK_TO_BIT26(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT24(A) (A==0x01000000)? 24 : MASK_TO_BIT25(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT23(A) (A==0x00800000)? 23 : MASK_TO_BIT24(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT22(A) (A==0x00400000)? 22 : MASK_TO_BIT23(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT21(A) (A==0x00200000)? 21 : MASK_TO_BIT22(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT20(A) (A==0x00100000)? 20 : MASK_TO_BIT21(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT19(A) (A==0x00080000)? 19 : MASK_TO_BIT20(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT18(A) (A==0x00040000)? 18 : MASK_TO_BIT19(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT17(A) (A==0x00020000)? 17 : MASK_TO_BIT18(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT16(A) (A==0x00010000)? 16 : MASK_TO_BIT17(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT15(A) (A==0x00008000)? 15 : MASK_TO_BIT16(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT14(A) (A==0x00004000)? 14 : MASK_TO_BIT15(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT13(A) (A==0x00002000)? 13 : MASK_TO_BIT14(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT12(A) (A==0x00001000)? 12 : MASK_TO_BIT13(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT11(A) (A==0x00000800)? 11 : MASK_TO_BIT12(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT10(A) (A==0x00000400)? 10 : MASK_TO_BIT11(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT09(A) (A==0x00000200)? 9 : MASK_TO_BIT10(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT08(A) (A==0x00000100)? 8 : MASK_TO_BIT09(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT07(A) (A==0x00000080)? 7 : MASK_TO_BIT08(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT06(A) (A==0x00000040)? 6 : MASK_TO_BIT07(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT05(A) (A==0x00000020)? 5 : MASK_TO_BIT06(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT04(A) (A==0x00000010)? 4 : MASK_TO_BIT05(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT03(A) (A==0x00000008)? 3 : MASK_TO_BIT04(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT02(A) (A==0x00000004)? 2 : MASK_TO_BIT03(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT01(A) (A==0x00000002)? 1 : MASK_TO_BIT02(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT(A) (A==0x00000001)? 0 : MASK_TO_BIT01(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) (*(volatile uint32_t*)(PERIPH_BB_BASE+32*((uint32_t)(&amp;(reg))-PERIPH_BASE)+4*((uint32_t)(MASK_TO_BIT(reg_val)))))</span></span></code> </pre><br></div></div><br>  Wie Sie sehen k√∂nnen, handelt es sich um einen sehr einfachen und unkomplizierten Code, der in der Sprache des Prozessors geschrieben ist.  Die Hauptarbeit hier ist die √úbersetzung von CMSIS-Werten in eine Bitnummer, die als Notwendigkeit f√ºr eine Assembler-Version fehlte. <br><br>  Oh ja, benutze diese Option wie folgt: <br><br><div class="spoiler">  <b class="spoiler_title">Beispiele f√ºr einfaches C.</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = 1; // (!0)</span></span></code> </pre><br></div></div><br>  Moderne Trends (nach meinen Beobachtungen massiv, ungef√§hr ab 2015) sprechen jedoch daf√ºr, C auch f√ºr MK durch C ++ zu ersetzen.  Und Makros sind nicht das zuverl√§ssigste Werkzeug, daher sollte die n√§chste Version geboren werden. <br><br><h4>  Cpp03 </h4><br>  Hier, einem sehr interessanten und diskutierten, aber angesichts seiner Komplexit√§t wenig genutzten, mit einem abgedroschenen Beispiel einer Fakult√§t, taucht das Tool Metaprogrammierung auf. <br><br>  Schlie√ülich ist die Aufgabe, den Wert einer Variablen in eine Bitzahl zu √ºbersetzen, ideal (es gibt bereits Werte in CMSIS), und in diesem Fall ist es praktisch f√ºr die Kompilierungszeit. <br><br>  Ich habe dies mithilfe von Vorlagen wie folgt implementiert: <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung f√ºr C ++ 03</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> val, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> comp_val, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cur_bit_num&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bit_num_from_value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { bit_num = (val == comp_val) ? cur_bit_num : bit_num_from_value&lt;val, <span class="hljs-number"><span class="hljs-number">2</span></span> * comp_val, cur_bit_num + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;::bit_num }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> val&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bit_num_from_value</span></span></span><span class="hljs-class">&lt;val, static_cast&lt;uint32_t&gt;(0x80000000), static_cast&lt;uint32_t&gt;(31)&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { bit_num = <span class="hljs-number"><span class="hljs-number">31</span></span> }; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) *(reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;volatile uint32_t *&gt;(PERIPH_BB_BASE + 32 * (reinterpret_cast&lt;uint32_t&gt;(&amp;(reg)) - PERIPH_BASE) + 4 * (bit_num_from_value&lt;static_cast&lt;uint32_t&gt;(reg_val), static_cast&lt;uint32_t&gt;(0x01), static_cast&lt;uint32_t&gt;(0)&gt;::bit_num)))</span></span></span></span></code> </pre><br></div></div><br>  Sie k√∂nnen es auf die gleiche Weise verwenden: <br><br><div class="spoiler">  <b class="spoiler_title">Beispiele f√ºr C ++ 03</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = true; //</span></span></code> </pre><br></div></div><br>  Und warum wurde das Makro verlassen?  Tatsache ist, dass ich keinen anderen Weg kenne, um diesen Vorgang garantiert einzuf√ºgen, ohne in einen anderen Bereich des Programmcodes zu wechseln.  Ich w√ºrde mich sehr freuen, wenn sie mich in den Kommentaren dazu auffordern w√ºrden.  Weder Vorlagen noch Inline-Funktionen bieten eine solche Garantie.  Ja, und das Makro hier kommt mit seiner Aufgabe perfekt zurecht. Es macht keinen Sinn, es zu √§ndern, nur weil der <s>Konformist</s> dies f√ºr ‚Äûnicht sicher‚Äú h√§lt. <br><br>  √úberraschenderweise stand die Zeit immer noch nicht still, Compiler unterst√ºtzten zunehmend C ++ 14 / C ++ 17, warum nicht die Innovationen nutzen und den Code verst√§ndlicher machen? <br><br><h4>  Cpp14 / cpp17 </h4><br><div class="spoiler">  <b class="spoiler_title">Implementierung f√ºr C ++ 14</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bit_num_from_value_cpp14</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comp_val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bit_num = (val == comp_val) ? bit_num : bit_num_from_value_cpp14(val, <span class="hljs-number"><span class="hljs-number">2</span></span> * comp_val, bit_num + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) *(reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;volatile uint32_t *&gt;(PERIPH_BB_BASE + 32 * (reinterpret_cast&lt;uint32_t&gt;(&amp;(reg)) - PERIPH_BASE) + 4 * (bit_num_from_value_cpp14(static_cast&lt;uint32_t&gt;(reg_val), static_cast&lt;uint32_t&gt;(0x01), static_cast&lt;uint32_t&gt;(0)))))</span></span></span></span></code> </pre><br></div></div><br>  Wie Sie sehen, habe ich gerade die Vorlagen durch eine rekursive constexpr-Funktion ersetzt, die meiner Meinung nach f√ºr das menschliche Auge klarer ist. <br><br>  Verwenden Sie den gleichen Weg.  √úbrigens k√∂nnen Sie in C ++ 17 im Prinzip die rekursive Lambda-Constexpr-Funktion verwenden, aber ich bin nicht sicher, ob dies zu zumindest einigen Vereinfachungen f√ºhrt und auch die Assembler-Reihenfolge nicht kompliziert. <br><br>  <b>Zusammenfassend geben alle drei C / Cpp-Implementierungen gem√§√ü dem Abschnitt Theorie einen gleicherma√üen korrekten Befehlssatz.</b>  <b>Ich habe lange mit allen Implementierungen auf IAR ARM 8.30 und gcc 7.2.0 gearbeitet.</b> <br><br><h2>  √úbung ist eine Schlampe </h2><br>  Das ist alles, wie es scheint, passiert.  Die Speichereinsparungen wurden berechnet, die Implementierung ausgew√§hlt und bereit, die Leistung zu verbessern.  Nicht hier, es handelte sich nur um eine Divergenz von Theorie und Praxis.  Und wann war es anders? <br><br>  Ich h√§tte es nie ver√∂ffentlicht, wenn ich es nicht getestet h√§tte, aber wie viel realistisch ist das belegte Volumen bei Projekten reduziert.  Ich habe dieses Makro speziell bei einigen alten Projekten durch eine regul√§re Implementierung ohne Maske ersetzt und mir den Unterschied angesehen.  Das Ergebnis √ºberraschte unangenehm. <br><br>  Wie sich herausstellte, bleibt die Lautst√§rke praktisch unver√§ndert.  Ich habe speziell Projekte ausgew√§hlt, bei denen genau 40-50 solcher Anweisungen verwendet wurden.  Nach der Theorie musste ich mindestens 100 Bytes und h√∂chstens 200 Bytes gut einsparen. In der Praxis stellte sich heraus, dass der Unterschied 24 - 32 Bytes betrug.  Aber warum? <br><br>  Normalerweise richten Sie beim Einrichten von Peripherieger√§ten fast hintereinander 5-10 Register ein.  Und bei einem hohen Grad an Optimierung ordnet der Compiler die Anweisungen nicht genau in der Reihenfolge der Register an, sondern ordnet die Anweisungen so an, wie es richtig erscheint, und st√∂rt sie manchmal an scheinbar untrennbaren Stellen. <br><br>  Ich sehe zwei M√∂glichkeiten (hier sind meine Spekulationen): <br><br><ol><li>  Oder der Compiler ist so schlau, dass er f√ºr Sie wei√ü, wie es besser ist, den Befehlssatz zu optimieren </li><li>  Oder der Compiler ist immer noch nicht schlauer als eine Person und verwirrt sich, wenn er auf solche Konstruktionen st√∂√üt </li></ol><br>  Das hei√üt, es stellt sich heraus, dass diese Methode in ‚ÄûHochsprachen‚Äú mit einem hohen Optimierungsgrad nur dann korrekt funktioniert, wenn sich keine √§hnlichen Operationen in der N√§he einer solchen Operation befinden. <br><br>  Auf der O0-Ebene laufen Theorie und Praxis √ºbrigens auf jeden Fall zusammen, aber diese Optimierung interessiert mich nicht. <br><br><h2>  Ich fasse zusammen </h2><br>  Ein negatives Ergebnis ist auch ein Ergebnis.  Ich denke, jeder wird Schlussfolgerungen f√ºr sich ziehen.  Pers√∂nlich werde ich diese Technik weiterhin anwenden, es wird sicherlich nicht schlimmer sein. <br><br>  Ich hoffe, es war interessant und ich m√∂chte denjenigen, die bis zum Ende gelesen haben, gro√üen Respekt aussprechen. <br><br><h2>  Literaturliste </h2><br><ol><li>  "Technisches Referenzhandbuch f√ºr Cortex-M3", Abschnitt 4.2, ARM 2005. </li><li>  Der endg√ºltige Leitfaden zum ARM Cortex-M3, Joseph Yiu. </li></ol><br>  PS Ich habe eine kleine Berichterstattung √ºber Themen im Zusammenhang mit der Entwicklung eingebetteter Elektronik in meiner Tasche.  Lassen Sie mich wissen, wenn Sie interessiert sind, werde ich sie langsam bekommen. <br><br>  PPS Irgendwie stellte sich heraus, dass es schief war, Abschnitte des Codes einzuf√ºgen. Bitte sagen Sie mir, wie ich mich verbessern kann, wenn m√∂glich.  Im Allgemeinen k√∂nnen Sie einen Code von Interesse in den Notizblock kopieren und unangenehme Emotionen in der Analyse vermeiden. <br><br><h2>  UPD: </h2>  Auf Wunsch der Leser weise ich darauf hin, dass die Bitbanding-Operation selbst atomar ist, was uns eine gewisse Sicherheit bei der Arbeit mit Registern gibt.  Dies ist eines der wichtigsten Merkmale dieser Methode. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454408/">https://habr.com/ru/post/de454408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454398/index.html">Von Kritikern zu Algorithmen: Wie Demokratie und Technokratie in die Musikindustrie kamen</a></li>
<li><a href="../de454400/index.html">T√§gliche Berichte zum Status der virtuellen Maschine mit R und PowerShell</a></li>
<li><a href="../de454402/index.html">Unity State Machine-Architektur zum Organisieren von Einheitenverhalten</a></li>
<li><a href="../de454404/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 6. F√ºllen Sie die L√ºcken aus (DHCP, TCP, "Handshake", allgemeine Portnummern)</a></li>
<li><a href="../de454406/index.html">Akihabara: Otaku-Nistplatz</a></li>
<li><a href="../de454410/index.html">Neu in PHP 7.4</a></li>
<li><a href="../de454414/index.html">SDL 2 Lektionen: Lektion 2 - Haupt ohne Gummi</a></li>
<li><a href="../de454416/index.html">Hadoop Distribution Distribution importieren</a></li>
<li><a href="../de454418/index.html">Drei nicht offensichtliche Beispiele f√ºr die Verwendung von Template-Engines im Backend</a></li>
<li><a href="../de454420/index.html">Backup, Teil 3: √úbersicht und Testen der Duplizit√§t, Duplikate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>