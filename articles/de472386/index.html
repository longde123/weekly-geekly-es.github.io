<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👿 🎎 👩🏾‍✈️ ZIO & Cats Effect: eine erfolgreiche Allianz 👩🏽‍🎓 🤴🏽 🥢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cats Effect ist zu einer Art „Reactive Streams“ für die funktionale Scala-Welt geworden, mit der Sie das gesamte vielfältige Ökosystem von Bibliotheke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZIO & Cats Effect: eine erfolgreiche Allianz</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/472386/">  Cats Effect ist zu einer Art „Reactive Streams“ für die funktionale Scala-Welt geworden, mit der Sie das gesamte vielfältige Ökosystem von Bibliotheken miteinander kombinieren können. <br><br>  Viele ausgezeichnete Bibliotheken: http4s, fs2, doobie - werden nur auf der Basis von Typklassen von Cats Effect implementiert.  Bibliotheken wie ZIO und Monix bieten wiederum Instanzen dieser Typklassen für ihre Effekttypen.  Trotz einiger Probleme, die in Version 3.0 behoben werden, hilft Cats Effect vielen Open Source-Mitarbeitern, das gesamte funktionale Ökosystem der Scala-Sprache organisch zu unterstützen.  Entwickler, die Cats Effect verwenden, stehen vor einer schwierigen Wahl: Welche Implementierung von Effekten für ihre Anwendungen verwendet werden soll? <br><br>  Heute gibt es drei Alternativen: <br><br><ul><li>  Cats IO, Referenzimplementierung; </li><li>  Monix, der Task-Datentyp und seine Reaktivität im Code; </li><li>  ZIO, der ZIO-Datentyp und sein Cross-Threading-Bereich. </li></ul><br>  In diesem Beitrag werde ich versuchen, Ihnen zu beweisen, dass ZIO für die Erstellung Ihrer Anwendung mit Cats Effect eine gute Wahl ist, da Designlösungen und Funktionen sich stark von der Referenzimplementierung in Cats IO unterscheiden. <br><a name="habracut"></a><br><h2>  1. Bessere MTL / Tagless-Final-Architektur </h2><br>  MTL (Monad Transformers Library) ist ein Programmierstil, bei dem Funktionen nach Art ihres Effekts polymorph sind und ihre Anforderungen durch eine „Typklassenbeschränkung“ ausdrücken.  In Scala wird dies oft als tagless-final-Stil bezeichnet (obwohl es nicht dasselbe ist), insbesondere wenn die Typklasse keine Gesetze hat. <br><br>  Es ist bekannt, dass es unmöglich ist, eine globale Instanz für klassische MTL-Typklassen wie Writer und State sowie für Effekttypen wie Cats IO zu definieren.  Das Problem besteht darin, dass Instanzen dieser Typklassen für diese Arten von Effekten Zugriff auf einen veränderlichen Status erfordern, der nicht global erstellt werden kann, da das Erstellen eines veränderlichen Status ebenfalls ein Effekt ist. <br><br>  Für eine optimale Leistung ist es jedoch wichtig, "Monadentransformatoren" zu vermeiden und die Write and State-Implementierung direkt über den Haupteffekttyp bereitzustellen. <br><br>  Um dies zu erreichen, verwenden Scala-Programmierer einen Trick: Sie erstellen (aber bereinigen) Instanzen auf der obersten Ebene ihrer Programme mit Effekten und stellen sie dann als lokale Implikationen weiter im Programm bereit: <br><br><pre><code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Ref</span></span>.make[<span class="hljs-type"><span class="hljs-type">AppState</span></span>](initialAppState).flatMap(ref =&gt; <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monadState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>, <span class="hljs-type"><span class="hljs-type">AppState</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">AppState</span></span>] = ref.get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">AppState</span></span>): <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = ref.set(s).unit } myProgram )</code> </pre> <br>  Trotz der Tatsache, dass ein solcher Trick nützlich ist, ist er immer noch eine „Krücke“.  In einer idealen Welt könnten alle Instanzen von Typklassen kohärent sein (eine Instanz pro Typ) und nicht lokal erstellt werden, wodurch Effekte erzeugt werden, und sich dann auf magische Weise in implizite Werte einwickeln, die von nachfolgenden Methoden verwendet werden. <br><br>  Eine großartige Funktion von MTL / tagless-final ist, dass Sie die meisten Instanzen direkt über dem ZIO-Datentyp mithilfe der ZIO-Umgebung definieren können. <br><br>  Hier ist eine Möglichkeit, eine globale MonadState-Definition für einen ZIO-Datentyp zu erstellen: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadState</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">State</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">S</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.set(s).unit) }</code> </pre><br>  Eine Instanz wird jetzt global für jede Umgebung definiert, die mindestens <code>State[S]</code> . <br><br>  Ähnliches gilt für <code>FunctorListen</code> , auch bekannt als <code>MonadWriter</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOFunctorListen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>: <span class="hljs-type"><span class="hljs-type">Semigroup</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">Writer</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get.flatMap(w =&gt; fa.map(a =&gt; a -&gt; w))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span></span>(w: <span class="hljs-type"><span class="hljs-type">W</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.update(_ |+| w).unit) }</code> </pre><br>  Und natürlich können wir dasselbe für <code>MonadError</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>]{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">E</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = fa catchAll f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raiseError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](e: <span class="hljs-type"><span class="hljs-type">E</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fail(e) }</code> </pre> <br>  Diese Technik ist leicht auf andere Typklassen anwendbar, einschließlich Tagless-Final-Typklassen, für deren Instanzen möglicherweise Effekte (Änderungen, Konfigurationen) generiert werden müssen, Testfunktionen, die Effekte generieren (Kombination von Umgebungseffekten mit Tagless-Final), oder alles andere, auf das über die Umgebung leicht zugegriffen werden kann . <br><br>  Keine langsamen monadischen Transformationen mehr!  Sagen wir "Nein" zum Erstellen von Effekten beim Initialisieren von Instanzen der Klassenklasse und zu lokalen Auswirkungen.  Keine Krücken mehr nötig.  Direktes Eintauchen in die reine Funktionsprogrammierung. <br><br><h2>  2. Ressourcen für bloße Sterbliche sparen </h2><br>  Eine der ersten Funktionen von ZIO war die Interraption - die Fähigkeit der ZIO-Laufzeit, ausführbare Effekte sofort zu unterbrechen und garantiert alle Ressourcen freizugeben.  Eine grobe Implementierung dieser Funktion traf Cats IO. <br><br>  Haskell nannte diese Funktionalität eine asynchrone Ausnahme, mit der Sie Latenzzeiten, effiziente parallele und wettbewerbsfähige Vorgänge und global optimale Berechnungen erstellen und effizient nutzen können.  Solche Unterbrechungen bringen nicht nur große Vorteile mit sich, sondern stellen auch komplexe Aufgaben im Bereich der Unterstützung des sicheren Zugangs zu Ressourcen. <br><br>  Programmierer sind es gewohnt, Fehler in Programmen durch einfache Analyse zu verfolgen.  Dies kann auch mit ZIO erfolgen, das ein Typsystem verwendet, um Fehler zu erkennen.  Aber Unterbrechung ist etwas anderes.  Ein aus vielen anderen Effekten erzeugter Effekt kann an jeder Grenze unterbrochen werden. <br><br>  Betrachten Sie den folgenden Effekt: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle) _ &lt;- closeFile(handle) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> data</code> </pre> <br>  Die meisten Entwickler werden von diesem Szenario nicht überrascht sein: <code>closeFile</code> wird nicht ausgeführt, wenn <code>readFile</code> abstürzt.  Glücklicherweise verfügt das Effektsystem über eine <code>ensuring</code> ( <code>guarantee</code> in Cats Effect), mit der Sie dem Finalizer-Effekt einen Final-Handler hinzufügen können, ähnlich wie bei finally. <br><br>  Das Hauptproblem des obigen Codes kann also leicht gelöst werden: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle).ensuring(closeFile(handle)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br>  Jetzt ist der Effekt " <code>readFile</code> " geworden, in dem Sinne, dass die Datei immer noch geschlossen bleibt, wenn die <code>readFile</code> kaputt geht.  Wenn <code>readFile</code> erfolgreich ist, wird die Datei ebenfalls geschlossen.  In allen Fällen wird die Datei geschlossen. <br><br>  Aber immer noch gar nicht ganz.  Unterbrechung bedeutet, dass der Effekt überall unterbrochen werden kann, auch zwischen <code>openFile</code> und <code>readFile</code> .  In diesem Fall wird die geöffnete Datei nicht geschlossen und es tritt ein Ressourcenleck auf. <br><br>  Das Muster zum Abrufen und Freigeben einer Ressource ist so weit verbreitet, dass ZIO einen Bracket-Operator einführte, der auch in Cats Effect 1.0 enthalten war.  Die Bracket-Anweisung schützt vor Unterbrechungen: Wenn die Ressource erfolgreich empfangen wurde, erfolgt die Freigabe auch dann, wenn der Effekt, der die Ressource verwendet, unterbrochen wird.  Ferner kann weder der Empfang noch die Freigabe der Ressource unterbrochen werden, wodurch eine Garantie für die Ressourcensicherheit gegeben ist. <br><br>  Mit der Klammer würde das obige Beispiel folgendermaßen aussehen: <br><br><pre> <code class="scala hljs">openFile(file).bracket(closeFile(_))(readFile(_))</code> </pre> <br>  Leider kapselt die Klammer nur ein (ziemlich allgemeines) Ressourcenverbrauchsmuster.  Es gibt viele andere, insbesondere bei wettbewerbsfähigen Datenstrukturen, auf die für Interrupts zugegriffen werden muss, da sonst Lecks möglich sind. <br><br>  Im Allgemeinen sind alle Interrupt-Arbeiten auf zwei Hauptpunkte zurückzuführen: <br><br><ul><li>  Vermeiden Sie Unterbrechungen in einigen Bereichen, die möglicherweise unterbrochen werden. </li><li>  Unterbrechung in Bereichen zulassen, die einfrieren können. </li></ul><br>  ZIO kann beides implementieren.  Zum Beispiel können wir unsere eigene Version von Bracket mithilfe von ZIO-Abstraktionen auf niedriger Ebene entwickeln: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.uninterruptible { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { a &lt;- acquire exit &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.interruptible(use(a)) .run.flatMap(exit =&gt; release(a, exit) .const(exit)) b &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.done(exit) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> b }</code> </pre><br>  In diesem Code ist die <code>use(a)</code> der einzige Teil, der unterbrochen werden kann.  Der umgebende Code garantiert in jedem Fall die Ausführung der <code>release</code> . <br><br>  Sie können jederzeit prüfen, ob die Möglichkeit von Unterbrechungen besteht.  Hierzu werden nur zwei primitive Operationen benötigt (der Rest wird von ihnen abgeleitet). <br><br>  Mit diesem kompositorischen Interrupt-Modell mit vollem Funktionsumfang können Sie nicht nur eine einfache Bracket-Implementierung implementieren, sondern auch andere Szenarien im Ressourcenmanagement implementieren, in denen ein Gleichgewicht zwischen den Vor- und Nachteilen von Interrupts gefunden wird. <br><br>  Cats IO bietet nur eine Operation zur Steuerung von Interrupts: den nicht abbrechbaren Kombinator.  Dadurch wird der gesamte Codeblock nicht unterbrochen.  Obwohl dieser Vorgang selten verwendet wird, kann er zu einem Ressourcenleck oder zu Sperren führen. <br><br>  Gleichzeitig stellt sich heraus, dass Sie in Cats IO ein Grundelement definieren können, mit dem Sie mehr Kontrolle über Interrupts erhalten.  Die sehr komplizierte Implementierung von Fabio Labella erwies sich als äußerst langsam. <br><br>  Mit ZIO können Sie Code mit Unterbrechungen schreiben, der mit deklarativen zusammengesetzten Anweisungen auf hoher Ebene arbeitet, und Sie müssen nicht zwischen schwerer Komplexität in Kombination mit geringer Leistung und blockierenden Lecks wählen. <br><br>  Darüber hinaus ermöglicht der kürzlich hinzugefügte Software-Transaktionsspeicher in ZIO dem Benutzer das deklarative Schreiben von Datenstrukturen und Code, die automatisch asynchron und wettbewerbsfähig sind und Interrupts zulassen. <br><br><h2>  3. Garantierte Finalizer </h2><br>  Der try / finally-Block in vielen Programmiersprachen bietet die erforderlichen Garantien, um synchronen Code zu schreiben, ohne Ressourcen zu verlieren. <br><br>  Dieser Block garantiert insbesondere Folgendes: Wenn ein try-Block die Ausführung startet, wird der finally-Block ausgeführt, wenn try versucht wird. <br><br>  Diese Garantie gilt für: <br><br><ul><li>  Es gibt verschachtelte "try / finally" -Blöcke. </li><li>  Es gibt Fehler im "Try-Block". </li><li>  Es gibt Fehler im verschachtelten finally-Block. </li></ul><br>  Der ZIO-Sicherstellungsvorgang kann genau wie try / finally verwendet werden: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect2 = effect.ensuring(cleanup)</code> </pre> <br>  ZIO bietet die folgenden Garantien für "effect.ensuring (finalizer)": Wenn "effect" ausgeführt wurde, startet "finalizer" die Ausführung, wenn "effect" stoppt. <br><br>  Wie bei try / finally bleiben diese Garantien in den folgenden Fällen bestehen: <br><br><ul><li>  Es gibt verschachtelte "Sicherstellungs" -Kompositionen; </li><li>  es gibt Fehler in der "Wirkung"; </li><li>  Es gibt Fehler im verschachtelten "Finalizer". </li></ul><br>  Darüber hinaus bleibt die Garantie auch dann erhalten, wenn der Effekt unterbrochen wird (Garantien für die „Klammer“ sind ähnlich, tatsächlich wird „Klammer“ für „Sicherstellung“ implementiert). <br><br>  Der Datentyp Cats IO bietet eine weitere, schwächere Garantie.  Für "effect.guarantee (finalizer)" wird es wie folgt geschwächt: Wenn "effect" ausgeführt wurde, startet "finalizer" die Ausführung, wenn "effect" stoppt, wenn der Problemeffekt nicht in "effect" eingefügt wird. <br><br>  Eine schwächere Garantie findet sich auch bei der Implementierung der „Klammer“ in Cats IO. <br><br>  Um ein Ressourcenleck zu erhalten, verwenden Sie einfach den Effekt, der im Effekt "Garantie" oder "bracket.use" verwendet wird, und setzen Sie ihn wie folgt zusammen: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   `interruptedFiber` -    val bigTrouble = interruptedFiber.join</span></span></code> </pre> <br>  Wenn bigTrouble auf diese Weise in einen anderen Effekt eingefügt wird, wird der Effekt nicht unterbrochen - es werden keine durch die "Garantie" festgelegten "Finalizer" oder die Reinigung von Ressourcen durch die "Klammer" nicht ausgeführt.  All dies führt zu einem Ressourcenverbrauch, selbst wenn sich ein „Finalizer“ im Block befindet. <br><br>  Beispielsweise startet der "Finalizer" im folgenden Code niemals die Ausführung: <br><br><pre> <code class="scala hljs">(<span class="hljs-type"><span class="hljs-type">IO</span></span>.unit &gt;&gt; bigTrouble).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>(println(<span class="hljs-string"><span class="hljs-string">"Won't be executed!!!«)))</span></span></code> </pre> <br>  Bei der Auswertung des Codes ohne Berücksichtigung des globalen Kontexts kann nicht festgestellt werden, ob ein Effekt wie "bigTrouble" an einer beliebigen Stelle im "use" -Effekt der Operation "bracket" oder im Block "finalizer" eingefügt wird. <br><br>  Daher können Sie nicht herausfinden, ob das Cats IO-Programm mit Ressourcenlecks oder fehlenden "Finalizer" -Blöcken funktioniert, ohne das gesamte Programm zu bewerten.  Das gesamte Programm kann nur manuell ausgewertet werden, und dieser Vorgang geht immer mit Fehlern einher, die vom Compiler nicht überprüft werden können.  Darüber hinaus muss dieser Vorgang jedes Mal wiederholt werden, wenn wichtige Änderungen im Code auftreten. <br><br>  ZIO hat eine benutzerdefinierte Implementierung von "Garantie" von Cats Effect, "Garantiefall" und "Klammer".  Implementierungen verwenden native ZIO-Semantik (nicht Cats IO-Semantik), mit der wir mögliche Probleme mit Ressourcenlecks hier und jetzt bewerten können, da wir wissen, dass in allen Situationen Finalizer gestartet und Ressourcen freigegeben werden. <br><br><h2>  4. Stabiles Schalten </h2><br>  Cats Effect verfügt über die Methode "evalOn" von "ContextShift", mit der Sie die Ausführung eines Codes in einen anderen Ausführungskontext verschieben können. <br><br>  Dies ist aus mehreren Gründen nützlich: <br><br><ul><li>  Viele Client-Bibliotheken zwingen Sie dazu, einige Arbeiten in ihrem Thread-Pool auszuführen. </li><li>  UI-Bibliotheken erfordern einige Aktualisierungen im UI-Thread. </li><li>  Einige Effekte erfordern die Isolierung von Thread-Pools, die an ihre spezifischen Funktionen angepasst sind. </li></ul><br>  Die Operation „EvalOn“ führt den Effekt dort aus, wo er ausgeführt werden soll, und kehrt dann zum ursprünglichen Ausführungskontext zurück.  Zum Beispiel: <br><br><pre> <code class="scala hljs">cs.evalOn(kafkaContext)(kafkaEffect)</code> </pre> <br>  Hinweis: Cats IO verfügt über ein ähnliches "Shift" -Konstrukt, mit dem Sie in einen anderen Kontext wechseln können, ohne zurück zu gehen. In der Praxis ist dieses Verhalten jedoch selten erforderlich. Daher wird "evalOn" bevorzugt. <br><br>  Die ZIO-Implementierung von "evalOn" (erstellt auf dem ZIO-Grundelement "lock") bietet die Garantien, die erforderlich sind, um eindeutig zu verstehen, wo der Effekt funktioniert - der Effekt wird immer in einem bestimmten Kontext ausgeführt. <br><br>  Cats IO hat eine andere, schwächere Garantie - der Effekt wird in einem bestimmten Kontext bis zur ersten asynchronen Operation oder internen Umschaltung ausgeführt. <br><br>  In Anbetracht eines kleinen Codeteils ist es unmöglich, sicher zu wissen, ob ein asynchroner Effekt (oder eine verschachtelte Umschaltung) in den umzuschaltenden Effekt integriert wird, da Asynchronität in Typen nicht angezeigt wird. <br><br>  Wie im Fall der Ressourcensicherheit ist es daher erforderlich, das gesamte Programm zu untersuchen, um zu verstehen, wo der Cats IO-Effekt ausgelöst wird.  In der Praxis und aus meiner Erfahrung sind Cats IO-Benutzer überrascht, wenn bei der Verwendung von „evalOn“ in einem Kontext später festgestellt wird, dass der größte Teil des Effekts versehentlich in einem anderen ausgeführt wurde. <br><br>  Mit ZIO können Sie festlegen, wo Effekte ausgelöst werden sollen, und darauf vertrauen, dass dies in allen Fällen der Fall ist, unabhängig davon, wie die Effekte in andere Effekte integriert sind. <br><br><h2>  5. Sicherheit von Fehlermeldungen </h2><br>  Jeder Effekt, der Parallelität, Parallelität oder sicheren Zugriff auf Ressourcen unterstützt, führt zu einem linearen Fehlermodell: Im Allgemeinen können nicht alle Fehler gespeichert werden. <br><br>  Dies gilt sowohl für "Throwable", einen in Cats IO integrierten festen Fehlertyp, als auch für den von ZIO unterstützten polymorphen Fehlertyp. <br><br>  Beispiele für Situationen mit mehreren einmaligen Fehlern: <br><br><ul><li>  Finalizer löst eine Ausnahme aus. </li><li>  zwei (fallende) Effekte werden parallel ausgeführt; </li><li>  zwei (fallende) Effekte im Rennzustand; </li><li>  Der unterbrochene Effekt lässt nach, bevor der Abschnitt vor Unterbrechungen geschützt bleibt. </li></ul><br>  Da nicht alle Fehler gespeichert werden, bietet ZIO eine "Cause [E]" - Datenstruktur basierend auf einem freien Semiring (eine Abstraktion von der abstrakten Algebra, deren Wissen hier nicht angenommen wird), die es ermöglicht, serielle und parallele Fehler für jede Art von Fehler zu verbinden.  Während aller Vorgänge (einschließlich der Reinigung auf einen heruntergefallenen oder unterbrochenen Effekt) aggregiert ZIO Fehler in der Datenstruktur „Ursache [E]“.  Diese Datenstruktur ist jederzeit verfügbar.  Infolgedessen speichert ZIO immer alle Fehler: Sie sind immer verfügbar, können protokolliert, untersucht und transformiert werden, wie es die Geschäftsanforderungen erfordern. <br><br>  Cats IO hat ein Modell mit Verlust von Fehlerinformationen ausgewählt.  Während ZIO die beiden Fehler über Ursache [E] verbindet, verliert Cats IO eine der Fehlermeldungen, indem es beispielsweise "e.printStackTrace ()" für den auftretenden Fehler aufruft. <br><br>  Beispielsweise geht ein Fehler im „Finalizer“ in diesem Code verloren. <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 1"</span></span>)).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 2«)))</span></span></code> </pre> <br>  Dieser Ansatz zur Verfolgung von Fehlern bedeutet, dass Sie nicht das gesamte Spektrum der Fehler lokal lokalisieren und verarbeiten können, die aufgrund der Kombination von Effekten auftreten.  Mit ZIO können Sie jede Art von Fehler verwenden, einschließlich "Throwable" (oder spezifischerer Untertypen wie "IOExceptio" oder einer anderen benutzerdefinierten Ausnahmehierarchie), um sicherzustellen, dass während der Programmausführung keine Fehler verloren gehen. <br><br><h2>  6. Asynchronität ohne Deadlocks </h2><br>  Sowohl ZIO als auch Cats IO bieten einen Konstruktor, mit dem Sie Code mit einem Rückruf nehmen und in Kraft setzen können <br><br>  Diese Funktion wird über die Async-Pipe-Klasse in Cats Effect bereitgestellt: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Data</span></span>] = <span class="hljs-type"><span class="hljs-type">Async</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>].async(k =&gt; getDataWithCallbacks( onSuccess = v =&gt; k(<span class="hljs-type"><span class="hljs-type">Right</span></span>(v)), onFailure = e =&gt; k(<span class="hljs-type"><span class="hljs-type">Left</span></span>(e)) ))</code> </pre><br>  Dadurch wird ein asynchroner Effekt erstellt, der bei Ausführung wartet, bis der Wert angezeigt wird, und dann fortgesetzt wird. All dies ist für den Benutzer des Effekts offensichtlich.  Daher ist die funktionale Programmierung für die Entwicklung von asynchronem Code so attraktiv. <br><br>  Beachten Sie, dass die Rückruffunktion (hier heißt sie "k") aufgerufen wird, sobald sich der Rückrufcode in einen Effekt verwandelt.  Diese Rückruffunktion wird mit einem Erfolgs- / Fehlerwert beendet.  Wenn diese Rückruffunktion aufgerufen wird, wird die Ausführung des Effekts (zuvor angehalten) fortgesetzt. <br><br>  ZIO garantiert, dass der Effekt die Ausführung im Laufzeit-Thread-Pool wieder aufnimmt, wenn der Effekt keinem bestimmten speziellen Kontext oder einem anderen Kontext zugewiesen wurde, an den der Effekt angehängt wurde. <br><br>  Cats IO setzt den Effekt auf den Rückruf-Thread fort.  Der Unterschied zwischen diesen Optionen ist sehr groß: Der Thread, der den Rückruf verursacht, erwartet nicht, dass der Rückrufcode für immer ausgeführt wird, sondern lässt nur eine geringfügige Verzögerung zu, bevor das Steuerelement zurückkehrt.  Auf der anderen Seite gibt Cats IO überhaupt keine solche Garantie: Der aufrufende Thread, der startende Rückruf, kann einfrieren und auf eine unbestimmte Zeit warten, wenn die Ausführungssteuerung zurückkehrt. <br><br>  Frühere Versionen der konkurrierenden Datenstrukturen in Cats Effect ("Deferred", "Semaphore") setzten Effekte fort, die die Kontrolle über die Ausführung nicht an den aufrufenden Thread zurückgaben.  Infolgedessen wurden Probleme im Zusammenhang mit Deadlocks und einem fehlerhaften Ausführungsplaner darin entdeckt.  Obwohl all diese Probleme gefunden wurden, sind sie nur für wettbewerbsfähige Datenstrukturen in Cats Effect behoben. <br><br>  Benutzercode, der einen ähnlichen Ansatz wie in Cats IO verwendet, wird in solche Probleme geraten, da solche Aufgaben nicht deterministisch sind und Fehler zur Laufzeit nur sehr selten auftreten können, was das Debuggen und die Problemerkennung zu einem schwierigen Prozess macht. <br><br>  ZIO bietet sofort einen Deadlock-Schutz und einen normalen Taskplaner und lässt den Benutzer das Verhalten von Cats IO explizit auswählen (z. B. "unsafeRun" für "Promise", was zu einem wieder aufgenommenen asynchronen Effekt führte). <br><br>  Obwohl keine der Lösungen für absolut alle Fälle geeignet ist und ZIO und Cats IO genügend Flexibilität bieten, um alle Situationen (auf unterschiedliche Weise) zu lösen, bedeutet die Auswahl von ZIO, dass Sie „Async“ ohne Sorgen verwenden und den Problemcode in „unsafeRun“ einfügen müssen. was bekanntermaßen Deadlock verursacht <br><br><h2>  7. Kompatibel mit der Zukunft </h2><br>  Die Verwendung von „Future“ aus der Scala-Standardbibliothek ist für eine große Anzahl von Codebasen Realität.  ZIO wird mit einer "fromFuture" -Methode geliefert, die einen vorgefertigten Ausführungskontext bereitstellt: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fromFuture(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ec =&gt; <span class="hljs-comment"><span class="hljs-comment">// Create some Future using `ec`: ??? )</span></span></code> </pre> <br>  Wenn diese Methode verwendet wird, um Future in einen Effekt zu verpacken, kann ZIO festlegen, wo Future ausgeführt wird, und andere Methoden, wie z. B. evalOn, übertragen Future korrekt in den gewünschten Ausführungskontext.  Cats IO akzeptiert "Future", das mit einem externen "ExecutionContext" erstellt wurde.  Dies bedeutet, dass Cats IO die Ausführung von Future nicht gemäß den Anforderungen der evalOn- oder Shift-Methode verschieben kann.  Darüber hinaus belastet dies den Benutzer mit der Bestimmung des Ausführungskontexts für Future, was eine enge Auswahl und eine separate Umgebung bedeutet. <br><br>  Da der bereitgestellte ExecutionContext ignoriert werden kann, kann ZIO als Summe der Cats IO-Funktionen dargestellt werden, was im allgemeinen Fall eine reibungslosere und genauere Interaktion mit Future garantiert. Es gibt jedoch immer noch Ausnahmen. <br><br><h2>  8. Blockieren von E / A. </h2><br>  Wie im Artikel „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread Pool.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Best Practices mit ZIO</a> “Für Serveranwendungen sind mindestens zwei separate Pools erforderlich, um maximale Effizienz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu erzielen</a> : <br><br><ul><li>  fester Pool für CPU / asynchrone Effekte; </li><li>  dynamisch, mit der Möglichkeit, die Anzahl der blockierenden Threads zu erhöhen. </li></ul><br>  Die Entscheidung, alle Effekte auf einen festen Thread-Pool auszuführen, führt eines Tages zu einem Deadlock, während das Auslösen aller Effekte auf einen dynamischen Pool zu Leistungseinbußen führen kann. <br><br>  In der JVM bietet ZIO zwei Vorgänge, die Blockierungseffekte unterstützen: <br><br><ul><li>  Operator "Blocking (Effekt"), der die Ausführung eines bestimmten Effekts im Pool blockierender Threads mit guten Voreinstellungen umschaltet, die bei Bedarf geändert werden können); </li><li> «effectBlocking(effect)» ,          ,        . </li></ul><br>     ,     ,       ,       «blocking».   ,    -    ,  ,       «effectBlocking»     ,    ZIO  (  ). <br><br> Cats IO    ,         .    ,     «blocking»,    «evalOn», , ,         . <br><br>           (      ZIO)         (,        ),          . <br><br><h2> 9.   </h2><br>  ,      Scala,          : <br><br><ul><li> «ReaderT»/ «Kleisli»,       ; </li><li> «EitherT»,      ( «OptionT»,     «EitherT»   «Unit»    ). </li></ul><br>    ,          (, http4s   «Kleisli»  «OptionT»).        («effect totation»), ZIO   «reader»  «typed error»      ZIO.         «reader»  «typed error» , ZIO    ,    . , «Task[A]»,    «reader»  «typed errors». <br><br>   ZIO     ()      - .  ,      ZIO     ,      . <br><br> Cats IO    .  ,  ,   «reader»  «typed errors»      «state», «writer»  ,      . <br><br> ZIO     8   Cats IO    .               ,          Scala          . <br><br><h2> 10.   </h2><br> ZIO   ,        ,      . ,           Scala,      . <br><br>   ZIO   2000  ,    «typed errors»  ,       —     375    .        Scala ,      .     ,      ,         . <br><br>           : <br><br><ul><li>      ; </li><li>        ; </li><li>  ,       ; </li><li>       . </li></ul><br>         .   , -    ,      . <br><br> -            .        ,     .      ZIO    . Cats IO    ,     ,  ZIO ( ,       ). <br><br><h2> 11.   </h2><br>  ZIO   ,     ,  -       . <br><br><ul><li>  ,  : «ZIO. succeed»  «Applicative[F].pure», «zip»  «Apply[F].product», «ZIO.foreach»  «Traverse[F].traverse». <br></li><li>         (Cats, Cats Effect, Scalaz     ). </li><li>  ,       (  «Runtime»,      Cats Effect  -   Cats Effect).  —        Cats IO. </li><li>    . </li><li>         . : "zip"/"zipPar", "ZIO.foreach"/"ZIO.foreachPar", "ZIO.succeed"/"ZIO.succeedLazy«. <br></li><li>      ,        «».   ZIO    IDE. </li><li>      Scala  ZIO  : «ZIO.fromFuture», «ZIO.fromOption», «ZIO.fromEither», «ZIO.fromTry». </li><li>         «». </li></ul><br> ,          Scala,    ,  ZIO   ,       ,   ,   ZIO,     . Cats IO     ,        Cats. <br><br>     ,      ,     ,       ( , ,    ). <br><br><h2> 12.  </h2><br> ZIO —  - ,           . <br><br>     : <br><br><ul><li>     ,  «Ref», «Promise», «Queue», «Semaphore»   «Stream»    //; </li><li> STM,       , ,     ; </li><li> «Schedule»,    ; </li><li>    «Clock», «Random», «Console»  «System» ,     ; </li><li>      ,    . </li></ul><br> -   Cats IO    .    Cats IO  ,      (  )      . <br><br><h2>  Fazit </h2><br>  Cats Effect      Scala-,   ,    . <br><br>  ,   Cats Effect,    ,         Cats Effect : Cats IO, Monix, Zio. <br><br>    ,      .        ,    , ,  : ZIO  Cats Effect    . <br><br><blockquote>          Scala      —    .          ,   Scala. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ScalaConf  ,   18     ,     John A De Goes  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472386/">https://habr.com/ru/post/de472386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472372/index.html">Android-Automatisierung Super einfache Anleitung zum Erstellen Ihres ersten Espresso-Tests</a></li>
<li><a href="../de472374/index.html">Warum wir Server nach Island verlegt haben</a></li>
<li><a href="../de472378/index.html">Flash-Zuverlässigkeit: erwartet und unerwartet. Teil 2. XIV. Konferenz der USENIX Association. Dateispeichertechnologien</a></li>
<li><a href="../de472380/index.html">MIRO - eine offene Indoor-Roboterplattform</a></li>
<li><a href="../de472384/index.html">Ein Blick auf Android-Updates aus Entwicklersicht</a></li>
<li><a href="../de472388/index.html">Walmart erklärt Amazon Preiskrieg</a></li>
<li><a href="../de472392/index.html">Aufstieg, Fall und mögliche Rückkehr von Audiokassetten - wir beschäftigen uns mit Mythen und geben einen Überblick über die Situation</a></li>
<li><a href="../de472394/index.html">Bewertung der Auswirkungen künstlicher Intelligenz auf Offshore-Öl und -Gas</a></li>
<li><a href="../de472396/index.html">In 4 Sekunden um die Welt im Columnstore (Teil 1)</a></li>
<li><a href="../de472402/index.html">RTMP-Videoanruf-Streaming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>