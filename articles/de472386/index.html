<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¿ ğŸ ğŸ‘©ğŸ¾â€âœˆï¸ ZIO & Cats Effect: eine erfolgreiche Allianz ğŸ‘©ğŸ½â€ğŸ“ ğŸ¤´ğŸ½ ğŸ¥¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cats Effect ist zu einer Art â€Reactive Streamsâ€œ fÃ¼r die funktionale Scala-Welt geworden, mit der Sie das gesamte vielfÃ¤ltige Ã–kosystem von Bibliotheke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZIO & Cats Effect: eine erfolgreiche Allianz</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/472386/">  Cats Effect ist zu einer Art â€Reactive Streamsâ€œ fÃ¼r die funktionale Scala-Welt geworden, mit der Sie das gesamte vielfÃ¤ltige Ã–kosystem von Bibliotheken miteinander kombinieren kÃ¶nnen. <br><br>  Viele ausgezeichnete Bibliotheken: http4s, fs2, doobie - werden nur auf der Basis von Typklassen von Cats Effect implementiert.  Bibliotheken wie ZIO und Monix bieten wiederum Instanzen dieser Typklassen fÃ¼r ihre Effekttypen.  Trotz einiger Probleme, die in Version 3.0 behoben werden, hilft Cats Effect vielen Open Source-Mitarbeitern, das gesamte funktionale Ã–kosystem der Scala-Sprache organisch zu unterstÃ¼tzen.  Entwickler, die Cats Effect verwenden, stehen vor einer schwierigen Wahl: Welche Implementierung von Effekten fÃ¼r ihre Anwendungen verwendet werden soll? <br><br>  Heute gibt es drei Alternativen: <br><br><ul><li>  Cats IO, Referenzimplementierung; </li><li>  Monix, der Task-Datentyp und seine ReaktivitÃ¤t im Code; </li><li>  ZIO, der ZIO-Datentyp und sein Cross-Threading-Bereich. </li></ul><br>  In diesem Beitrag werde ich versuchen, Ihnen zu beweisen, dass ZIO fÃ¼r die Erstellung Ihrer Anwendung mit Cats Effect eine gute Wahl ist, da DesignlÃ¶sungen und Funktionen sich stark von der Referenzimplementierung in Cats IO unterscheiden. <br><a name="habracut"></a><br><h2>  1. Bessere MTL / Tagless-Final-Architektur </h2><br>  MTL (Monad Transformers Library) ist ein Programmierstil, bei dem Funktionen nach Art ihres Effekts polymorph sind und ihre Anforderungen durch eine â€TypklassenbeschrÃ¤nkungâ€œ ausdrÃ¼cken.  In Scala wird dies oft als tagless-final-Stil bezeichnet (obwohl es nicht dasselbe ist), insbesondere wenn die Typklasse keine Gesetze hat. <br><br>  Es ist bekannt, dass es unmÃ¶glich ist, eine globale Instanz fÃ¼r klassische MTL-Typklassen wie Writer und State sowie fÃ¼r Effekttypen wie Cats IO zu definieren.  Das Problem besteht darin, dass Instanzen dieser Typklassen fÃ¼r diese Arten von Effekten Zugriff auf einen verÃ¤nderlichen Status erfordern, der nicht global erstellt werden kann, da das Erstellen eines verÃ¤nderlichen Status ebenfalls ein Effekt ist. <br><br>  FÃ¼r eine optimale Leistung ist es jedoch wichtig, "Monadentransformatoren" zu vermeiden und die Write and State-Implementierung direkt Ã¼ber den Haupteffekttyp bereitzustellen. <br><br>  Um dies zu erreichen, verwenden Scala-Programmierer einen Trick: Sie erstellen (aber bereinigen) Instanzen auf der obersten Ebene ihrer Programme mit Effekten und stellen sie dann als lokale Implikationen weiter im Programm bereit: <br><br><pre><code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Ref</span></span>.make[<span class="hljs-type"><span class="hljs-type">AppState</span></span>](initialAppState).flatMap(ref =&gt; <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monadState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>, <span class="hljs-type"><span class="hljs-type">AppState</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">AppState</span></span>] = ref.get <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">AppState</span></span>): <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = ref.set(s).unit } myProgram )</code> </pre> <br>  Trotz der Tatsache, dass ein solcher Trick nÃ¼tzlich ist, ist er immer noch eine â€KrÃ¼ckeâ€œ.  In einer idealen Welt kÃ¶nnten alle Instanzen von Typklassen kohÃ¤rent sein (eine Instanz pro Typ) und nicht lokal erstellt werden, wodurch Effekte erzeugt werden, und sich dann auf magische Weise in implizite Werte einwickeln, die von nachfolgenden Methoden verwendet werden. <br><br>  Eine groÃŸartige Funktion von MTL / tagless-final ist, dass Sie die meisten Instanzen direkt Ã¼ber dem ZIO-Datentyp mithilfe der ZIO-Umgebung definieren kÃ¶nnen. <br><br>  Hier ist eine MÃ¶glichkeit, eine globale MonadState-Definition fÃ¼r einen ZIO-Datentyp zu erstellen: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadState</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">State</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadState</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">S</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">S</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.set(s).unit) }</code> </pre><br>  Eine Instanz wird jetzt global fÃ¼r jede Umgebung definiert, die mindestens <code>State[S]</code> . <br><br>  Ã„hnliches gilt fÃ¼r <code>FunctorListen</code> , auch bekannt als <code>MonadWriter</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Ref</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOFunctorListen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>: <span class="hljs-type"><span class="hljs-type">Semigroup</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">Writer</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>], <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FunctorListen</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">W</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.get.flatMap(w =&gt; fa.map(a =&gt; a -&gt; w))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span></span>(w: <span class="hljs-type"><span class="hljs-type">W</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.accessM(_.state.update(_ |+| w).unit) }</code> </pre><br>  Und natÃ¼rlich kÃ¶nnen wir dasselbe fÃ¼r <code>MonadError</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZIOMonadError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>]: <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MonadError</span></span>[<span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, ?], <span class="hljs-type"><span class="hljs-type">E</span></span>]{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](fa: <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">E</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = fa catchAll f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raiseError</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](e: <span class="hljs-type"><span class="hljs-type">E</span></span>): <span class="hljs-type"><span class="hljs-type">ZIO</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">E</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fail(e) }</code> </pre> <br>  Diese Technik ist leicht auf andere Typklassen anwendbar, einschlieÃŸlich Tagless-Final-Typklassen, fÃ¼r deren Instanzen mÃ¶glicherweise Effekte (Ã„nderungen, Konfigurationen) generiert werden mÃ¼ssen, Testfunktionen, die Effekte generieren (Kombination von Umgebungseffekten mit Tagless-Final), oder alles andere, auf das Ã¼ber die Umgebung leicht zugegriffen werden kann . <br><br>  Keine langsamen monadischen Transformationen mehr!  Sagen wir "Nein" zum Erstellen von Effekten beim Initialisieren von Instanzen der Klassenklasse und zu lokalen Auswirkungen.  Keine KrÃ¼cken mehr nÃ¶tig.  Direktes Eintauchen in die reine Funktionsprogrammierung. <br><br><h2>  2. Ressourcen fÃ¼r bloÃŸe Sterbliche sparen </h2><br>  Eine der ersten Funktionen von ZIO war die Interraption - die FÃ¤higkeit der ZIO-Laufzeit, ausfÃ¼hrbare Effekte sofort zu unterbrechen und garantiert alle Ressourcen freizugeben.  Eine grobe Implementierung dieser Funktion traf Cats IO. <br><br>  Haskell nannte diese FunktionalitÃ¤t eine asynchrone Ausnahme, mit der Sie Latenzzeiten, effiziente parallele und wettbewerbsfÃ¤hige VorgÃ¤nge und global optimale Berechnungen erstellen und effizient nutzen kÃ¶nnen.  Solche Unterbrechungen bringen nicht nur groÃŸe Vorteile mit sich, sondern stellen auch komplexe Aufgaben im Bereich der UnterstÃ¼tzung des sicheren Zugangs zu Ressourcen. <br><br>  Programmierer sind es gewohnt, Fehler in Programmen durch einfache Analyse zu verfolgen.  Dies kann auch mit ZIO erfolgen, das ein Typsystem verwendet, um Fehler zu erkennen.  Aber Unterbrechung ist etwas anderes.  Ein aus vielen anderen Effekten erzeugter Effekt kann an jeder Grenze unterbrochen werden. <br><br>  Betrachten Sie den folgenden Effekt: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle) _ &lt;- closeFile(handle) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> data</code> </pre> <br>  Die meisten Entwickler werden von diesem Szenario nicht Ã¼berrascht sein: <code>closeFile</code> wird nicht ausgefÃ¼hrt, wenn <code>readFile</code> abstÃ¼rzt.  GlÃ¼cklicherweise verfÃ¼gt das Effektsystem Ã¼ber eine <code>ensuring</code> ( <code>guarantee</code> in Cats Effect), mit der Sie dem Finalizer-Effekt einen Final-Handler hinzufÃ¼gen kÃ¶nnen, Ã¤hnlich wie bei finally. <br><br>  Das Hauptproblem des obigen Codes kann also leicht gelÃ¶st werden: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { handle &lt;- openFile(file) data &lt;- readFile(handle).ensuring(closeFile(handle)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br>  Jetzt ist der Effekt " <code>readFile</code> " geworden, in dem Sinne, dass die Datei immer noch geschlossen bleibt, wenn die <code>readFile</code> kaputt geht.  Wenn <code>readFile</code> erfolgreich ist, wird die Datei ebenfalls geschlossen.  In allen FÃ¤llen wird die Datei geschlossen. <br><br>  Aber immer noch gar nicht ganz.  Unterbrechung bedeutet, dass der Effekt Ã¼berall unterbrochen werden kann, auch zwischen <code>openFile</code> und <code>readFile</code> .  In diesem Fall wird die geÃ¶ffnete Datei nicht geschlossen und es tritt ein Ressourcenleck auf. <br><br>  Das Muster zum Abrufen und Freigeben einer Ressource ist so weit verbreitet, dass ZIO einen Bracket-Operator einfÃ¼hrte, der auch in Cats Effect 1.0 enthalten war.  Die Bracket-Anweisung schÃ¼tzt vor Unterbrechungen: Wenn die Ressource erfolgreich empfangen wurde, erfolgt die Freigabe auch dann, wenn der Effekt, der die Ressource verwendet, unterbrochen wird.  Ferner kann weder der Empfang noch die Freigabe der Ressource unterbrochen werden, wodurch eine Garantie fÃ¼r die Ressourcensicherheit gegeben ist. <br><br>  Mit der Klammer wÃ¼rde das obige Beispiel folgendermaÃŸen aussehen: <br><br><pre> <code class="scala hljs">openFile(file).bracket(closeFile(_))(readFile(_))</code> </pre> <br>  Leider kapselt die Klammer nur ein (ziemlich allgemeines) Ressourcenverbrauchsmuster.  Es gibt viele andere, insbesondere bei wettbewerbsfÃ¤higen Datenstrukturen, auf die fÃ¼r Interrupts zugegriffen werden muss, da sonst Lecks mÃ¶glich sind. <br><br>  Im Allgemeinen sind alle Interrupt-Arbeiten auf zwei Hauptpunkte zurÃ¼ckzufÃ¼hren: <br><br><ul><li>  Vermeiden Sie Unterbrechungen in einigen Bereichen, die mÃ¶glicherweise unterbrochen werden. </li><li>  Unterbrechung in Bereichen zulassen, die einfrieren kÃ¶nnen. </li></ul><br>  ZIO kann beides implementieren.  Zum Beispiel kÃ¶nnen wir unsere eigene Version von Bracket mithilfe von ZIO-Abstraktionen auf niedriger Ebene entwickeln: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.uninterruptible { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { a &lt;- acquire exit &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.interruptible(use(a)) .run.flatMap(exit =&gt; release(a, exit) .const(exit)) b &lt;- <span class="hljs-type"><span class="hljs-type">ZIO</span></span>.done(exit) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> b }</code> </pre><br>  In diesem Code ist die <code>use(a)</code> der einzige Teil, der unterbrochen werden kann.  Der umgebende Code garantiert in jedem Fall die AusfÃ¼hrung der <code>release</code> . <br><br>  Sie kÃ¶nnen jederzeit prÃ¼fen, ob die MÃ¶glichkeit von Unterbrechungen besteht.  Hierzu werden nur zwei primitive Operationen benÃ¶tigt (der Rest wird von ihnen abgeleitet). <br><br>  Mit diesem kompositorischen Interrupt-Modell mit vollem Funktionsumfang kÃ¶nnen Sie nicht nur eine einfache Bracket-Implementierung implementieren, sondern auch andere Szenarien im Ressourcenmanagement implementieren, in denen ein Gleichgewicht zwischen den Vor- und Nachteilen von Interrupts gefunden wird. <br><br>  Cats IO bietet nur eine Operation zur Steuerung von Interrupts: den nicht abbrechbaren Kombinator.  Dadurch wird der gesamte Codeblock nicht unterbrochen.  Obwohl dieser Vorgang selten verwendet wird, kann er zu einem Ressourcenleck oder zu Sperren fÃ¼hren. <br><br>  Gleichzeitig stellt sich heraus, dass Sie in Cats IO ein Grundelement definieren kÃ¶nnen, mit dem Sie mehr Kontrolle Ã¼ber Interrupts erhalten.  Die sehr komplizierte Implementierung von Fabio Labella erwies sich als Ã¤uÃŸerst langsam. <br><br>  Mit ZIO kÃ¶nnen Sie Code mit Unterbrechungen schreiben, der mit deklarativen zusammengesetzten Anweisungen auf hoher Ebene arbeitet, und Sie mÃ¼ssen nicht zwischen schwerer KomplexitÃ¤t in Kombination mit geringer Leistung und blockierenden Lecks wÃ¤hlen. <br><br>  DarÃ¼ber hinaus ermÃ¶glicht der kÃ¼rzlich hinzugefÃ¼gte Software-Transaktionsspeicher in ZIO dem Benutzer das deklarative Schreiben von Datenstrukturen und Code, die automatisch asynchron und wettbewerbsfÃ¤hig sind und Interrupts zulassen. <br><br><h2>  3. Garantierte Finalizer </h2><br>  Der try / finally-Block in vielen Programmiersprachen bietet die erforderlichen Garantien, um synchronen Code zu schreiben, ohne Ressourcen zu verlieren. <br><br>  Dieser Block garantiert insbesondere Folgendes: Wenn ein try-Block die AusfÃ¼hrung startet, wird der finally-Block ausgefÃ¼hrt, wenn try versucht wird. <br><br>  Diese Garantie gilt fÃ¼r: <br><br><ul><li>  Es gibt verschachtelte "try / finally" -BlÃ¶cke. </li><li>  Es gibt Fehler im "Try-Block". </li><li>  Es gibt Fehler im verschachtelten finally-Block. </li></ul><br>  Der ZIO-Sicherstellungsvorgang kann genau wie try / finally verwendet werden: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect2 = effect.ensuring(cleanup)</code> </pre> <br>  ZIO bietet die folgenden Garantien fÃ¼r "effect.ensuring (finalizer)": Wenn "effect" ausgefÃ¼hrt wurde, startet "finalizer" die AusfÃ¼hrung, wenn "effect" stoppt. <br><br>  Wie bei try / finally bleiben diese Garantien in den folgenden FÃ¤llen bestehen: <br><br><ul><li>  Es gibt verschachtelte "Sicherstellungs" -Kompositionen; </li><li>  es gibt Fehler in der "Wirkung"; </li><li>  Es gibt Fehler im verschachtelten "Finalizer". </li></ul><br>  DarÃ¼ber hinaus bleibt die Garantie auch dann erhalten, wenn der Effekt unterbrochen wird (Garantien fÃ¼r die â€Klammerâ€œ sind Ã¤hnlich, tatsÃ¤chlich wird â€Klammerâ€œ fÃ¼r â€Sicherstellungâ€œ implementiert). <br><br>  Der Datentyp Cats IO bietet eine weitere, schwÃ¤chere Garantie.  FÃ¼r "effect.guarantee (finalizer)" wird es wie folgt geschwÃ¤cht: Wenn "effect" ausgefÃ¼hrt wurde, startet "finalizer" die AusfÃ¼hrung, wenn "effect" stoppt, wenn der Problemeffekt nicht in "effect" eingefÃ¼gt wird. <br><br>  Eine schwÃ¤chere Garantie findet sich auch bei der Implementierung der â€Klammerâ€œ in Cats IO. <br><br>  Um ein Ressourcenleck zu erhalten, verwenden Sie einfach den Effekt, der im Effekt "Garantie" oder "bracket.use" verwendet wird, und setzen Sie ihn wie folgt zusammen: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   `interruptedFiber` -    val bigTrouble = interruptedFiber.join</span></span></code> </pre> <br>  Wenn bigTrouble auf diese Weise in einen anderen Effekt eingefÃ¼gt wird, wird der Effekt nicht unterbrochen - es werden keine durch die "Garantie" festgelegten "Finalizer" oder die Reinigung von Ressourcen durch die "Klammer" nicht ausgefÃ¼hrt.  All dies fÃ¼hrt zu einem Ressourcenverbrauch, selbst wenn sich ein â€Finalizerâ€œ im Block befindet. <br><br>  Beispielsweise startet der "Finalizer" im folgenden Code niemals die AusfÃ¼hrung: <br><br><pre> <code class="scala hljs">(<span class="hljs-type"><span class="hljs-type">IO</span></span>.unit &gt;&gt; bigTrouble).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>(println(<span class="hljs-string"><span class="hljs-string">"Won't be executed!!!Â«)))</span></span></code> </pre> <br>  Bei der Auswertung des Codes ohne BerÃ¼cksichtigung des globalen Kontexts kann nicht festgestellt werden, ob ein Effekt wie "bigTrouble" an einer beliebigen Stelle im "use" -Effekt der Operation "bracket" oder im Block "finalizer" eingefÃ¼gt wird. <br><br>  Daher kÃ¶nnen Sie nicht herausfinden, ob das Cats IO-Programm mit Ressourcenlecks oder fehlenden "Finalizer" -BlÃ¶cken funktioniert, ohne das gesamte Programm zu bewerten.  Das gesamte Programm kann nur manuell ausgewertet werden, und dieser Vorgang geht immer mit Fehlern einher, die vom Compiler nicht Ã¼berprÃ¼ft werden kÃ¶nnen.  DarÃ¼ber hinaus muss dieser Vorgang jedes Mal wiederholt werden, wenn wichtige Ã„nderungen im Code auftreten. <br><br>  ZIO hat eine benutzerdefinierte Implementierung von "Garantie" von Cats Effect, "Garantiefall" und "Klammer".  Implementierungen verwenden native ZIO-Semantik (nicht Cats IO-Semantik), mit der wir mÃ¶gliche Probleme mit Ressourcenlecks hier und jetzt bewerten kÃ¶nnen, da wir wissen, dass in allen Situationen Finalizer gestartet und Ressourcen freigegeben werden. <br><br><h2>  4. Stabiles Schalten </h2><br>  Cats Effect verfÃ¼gt Ã¼ber die Methode "evalOn" von "ContextShift", mit der Sie die AusfÃ¼hrung eines Codes in einen anderen AusfÃ¼hrungskontext verschieben kÃ¶nnen. <br><br>  Dies ist aus mehreren GrÃ¼nden nÃ¼tzlich: <br><br><ul><li>  Viele Client-Bibliotheken zwingen Sie dazu, einige Arbeiten in ihrem Thread-Pool auszufÃ¼hren. </li><li>  UI-Bibliotheken erfordern einige Aktualisierungen im UI-Thread. </li><li>  Einige Effekte erfordern die Isolierung von Thread-Pools, die an ihre spezifischen Funktionen angepasst sind. </li></ul><br>  Die Operation â€EvalOnâ€œ fÃ¼hrt den Effekt dort aus, wo er ausgefÃ¼hrt werden soll, und kehrt dann zum ursprÃ¼nglichen AusfÃ¼hrungskontext zurÃ¼ck.  Zum Beispiel: <br><br><pre> <code class="scala hljs">cs.evalOn(kafkaContext)(kafkaEffect)</code> </pre> <br>  Hinweis: Cats IO verfÃ¼gt Ã¼ber ein Ã¤hnliches "Shift" -Konstrukt, mit dem Sie in einen anderen Kontext wechseln kÃ¶nnen, ohne zurÃ¼ck zu gehen. In der Praxis ist dieses Verhalten jedoch selten erforderlich. Daher wird "evalOn" bevorzugt. <br><br>  Die ZIO-Implementierung von "evalOn" (erstellt auf dem ZIO-Grundelement "lock") bietet die Garantien, die erforderlich sind, um eindeutig zu verstehen, wo der Effekt funktioniert - der Effekt wird immer in einem bestimmten Kontext ausgefÃ¼hrt. <br><br>  Cats IO hat eine andere, schwÃ¤chere Garantie - der Effekt wird in einem bestimmten Kontext bis zur ersten asynchronen Operation oder internen Umschaltung ausgefÃ¼hrt. <br><br>  In Anbetracht eines kleinen Codeteils ist es unmÃ¶glich, sicher zu wissen, ob ein asynchroner Effekt (oder eine verschachtelte Umschaltung) in den umzuschaltenden Effekt integriert wird, da AsynchronitÃ¤t in Typen nicht angezeigt wird. <br><br>  Wie im Fall der Ressourcensicherheit ist es daher erforderlich, das gesamte Programm zu untersuchen, um zu verstehen, wo der Cats IO-Effekt ausgelÃ¶st wird.  In der Praxis und aus meiner Erfahrung sind Cats IO-Benutzer Ã¼berrascht, wenn bei der Verwendung von â€evalOnâ€œ in einem Kontext spÃ¤ter festgestellt wird, dass der grÃ¶ÃŸte Teil des Effekts versehentlich in einem anderen ausgefÃ¼hrt wurde. <br><br>  Mit ZIO kÃ¶nnen Sie festlegen, wo Effekte ausgelÃ¶st werden sollen, und darauf vertrauen, dass dies in allen FÃ¤llen der Fall ist, unabhÃ¤ngig davon, wie die Effekte in andere Effekte integriert sind. <br><br><h2>  5. Sicherheit von Fehlermeldungen </h2><br>  Jeder Effekt, der ParallelitÃ¤t, ParallelitÃ¤t oder sicheren Zugriff auf Ressourcen unterstÃ¼tzt, fÃ¼hrt zu einem linearen Fehlermodell: Im Allgemeinen kÃ¶nnen nicht alle Fehler gespeichert werden. <br><br>  Dies gilt sowohl fÃ¼r "Throwable", einen in Cats IO integrierten festen Fehlertyp, als auch fÃ¼r den von ZIO unterstÃ¼tzten polymorphen Fehlertyp. <br><br>  Beispiele fÃ¼r Situationen mit mehreren einmaligen Fehlern: <br><br><ul><li>  Finalizer lÃ¶st eine Ausnahme aus. </li><li>  zwei (fallende) Effekte werden parallel ausgefÃ¼hrt; </li><li>  zwei (fallende) Effekte im Rennzustand; </li><li>  Der unterbrochene Effekt lÃ¤sst nach, bevor der Abschnitt vor Unterbrechungen geschÃ¼tzt bleibt. </li></ul><br>  Da nicht alle Fehler gespeichert werden, bietet ZIO eine "Cause [E]" - Datenstruktur basierend auf einem freien Semiring (eine Abstraktion von der abstrakten Algebra, deren Wissen hier nicht angenommen wird), die es ermÃ¶glicht, serielle und parallele Fehler fÃ¼r jede Art von Fehler zu verbinden.  WÃ¤hrend aller VorgÃ¤nge (einschlieÃŸlich der Reinigung auf einen heruntergefallenen oder unterbrochenen Effekt) aggregiert ZIO Fehler in der Datenstruktur â€Ursache [E]â€œ.  Diese Datenstruktur ist jederzeit verfÃ¼gbar.  Infolgedessen speichert ZIO immer alle Fehler: Sie sind immer verfÃ¼gbar, kÃ¶nnen protokolliert, untersucht und transformiert werden, wie es die GeschÃ¤ftsanforderungen erfordern. <br><br>  Cats IO hat ein Modell mit Verlust von Fehlerinformationen ausgewÃ¤hlt.  WÃ¤hrend ZIO die beiden Fehler Ã¼ber Ursache [E] verbindet, verliert Cats IO eine der Fehlermeldungen, indem es beispielsweise "e.printStackTrace ()" fÃ¼r den auftretenden Fehler aufruft. <br><br>  Beispielsweise geht ein Fehler im â€Finalizerâ€œ in diesem Code verloren. <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 1"</span></span>)).guarantee(<span class="hljs-type"><span class="hljs-type">IO</span></span>.raiseError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Error 2Â«)))</span></span></code> </pre> <br>  Dieser Ansatz zur Verfolgung von Fehlern bedeutet, dass Sie nicht das gesamte Spektrum der Fehler lokal lokalisieren und verarbeiten kÃ¶nnen, die aufgrund der Kombination von Effekten auftreten.  Mit ZIO kÃ¶nnen Sie jede Art von Fehler verwenden, einschlieÃŸlich "Throwable" (oder spezifischerer Untertypen wie "IOExceptio" oder einer anderen benutzerdefinierten Ausnahmehierarchie), um sicherzustellen, dass wÃ¤hrend der ProgrammausfÃ¼hrung keine Fehler verloren gehen. <br><br><h2>  6. AsynchronitÃ¤t ohne Deadlocks </h2><br>  Sowohl ZIO als auch Cats IO bieten einen Konstruktor, mit dem Sie Code mit einem RÃ¼ckruf nehmen und in Kraft setzen kÃ¶nnen <br><br>  Diese Funktion wird Ã¼ber die Async-Pipe-Klasse in Cats Effect bereitgestellt: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> effect: <span class="hljs-type"><span class="hljs-type">Task</span></span>[<span class="hljs-type"><span class="hljs-type">Data</span></span>] = <span class="hljs-type"><span class="hljs-type">Async</span></span>[<span class="hljs-type"><span class="hljs-type">Task</span></span>].async(k =&gt; getDataWithCallbacks( onSuccess = v =&gt; k(<span class="hljs-type"><span class="hljs-type">Right</span></span>(v)), onFailure = e =&gt; k(<span class="hljs-type"><span class="hljs-type">Left</span></span>(e)) ))</code> </pre><br>  Dadurch wird ein asynchroner Effekt erstellt, der bei AusfÃ¼hrung wartet, bis der Wert angezeigt wird, und dann fortgesetzt wird. All dies ist fÃ¼r den Benutzer des Effekts offensichtlich.  Daher ist die funktionale Programmierung fÃ¼r die Entwicklung von asynchronem Code so attraktiv. <br><br>  Beachten Sie, dass die RÃ¼ckruffunktion (hier heiÃŸt sie "k") aufgerufen wird, sobald sich der RÃ¼ckrufcode in einen Effekt verwandelt.  Diese RÃ¼ckruffunktion wird mit einem Erfolgs- / Fehlerwert beendet.  Wenn diese RÃ¼ckruffunktion aufgerufen wird, wird die AusfÃ¼hrung des Effekts (zuvor angehalten) fortgesetzt. <br><br>  ZIO garantiert, dass der Effekt die AusfÃ¼hrung im Laufzeit-Thread-Pool wieder aufnimmt, wenn der Effekt keinem bestimmten speziellen Kontext oder einem anderen Kontext zugewiesen wurde, an den der Effekt angehÃ¤ngt wurde. <br><br>  Cats IO setzt den Effekt auf den RÃ¼ckruf-Thread fort.  Der Unterschied zwischen diesen Optionen ist sehr groÃŸ: Der Thread, der den RÃ¼ckruf verursacht, erwartet nicht, dass der RÃ¼ckrufcode fÃ¼r immer ausgefÃ¼hrt wird, sondern lÃ¤sst nur eine geringfÃ¼gige VerzÃ¶gerung zu, bevor das Steuerelement zurÃ¼ckkehrt.  Auf der anderen Seite gibt Cats IO Ã¼berhaupt keine solche Garantie: Der aufrufende Thread, der startende RÃ¼ckruf, kann einfrieren und auf eine unbestimmte Zeit warten, wenn die AusfÃ¼hrungssteuerung zurÃ¼ckkehrt. <br><br>  FrÃ¼here Versionen der konkurrierenden Datenstrukturen in Cats Effect ("Deferred", "Semaphore") setzten Effekte fort, die die Kontrolle Ã¼ber die AusfÃ¼hrung nicht an den aufrufenden Thread zurÃ¼ckgaben.  Infolgedessen wurden Probleme im Zusammenhang mit Deadlocks und einem fehlerhaften AusfÃ¼hrungsplaner darin entdeckt.  Obwohl all diese Probleme gefunden wurden, sind sie nur fÃ¼r wettbewerbsfÃ¤hige Datenstrukturen in Cats Effect behoben. <br><br>  Benutzercode, der einen Ã¤hnlichen Ansatz wie in Cats IO verwendet, wird in solche Probleme geraten, da solche Aufgaben nicht deterministisch sind und Fehler zur Laufzeit nur sehr selten auftreten kÃ¶nnen, was das Debuggen und die Problemerkennung zu einem schwierigen Prozess macht. <br><br>  ZIO bietet sofort einen Deadlock-Schutz und einen normalen Taskplaner und lÃ¤sst den Benutzer das Verhalten von Cats IO explizit auswÃ¤hlen (z. B. "unsafeRun" fÃ¼r "Promise", was zu einem wieder aufgenommenen asynchronen Effekt fÃ¼hrte). <br><br>  Obwohl keine der LÃ¶sungen fÃ¼r absolut alle FÃ¤lle geeignet ist und ZIO und Cats IO genÃ¼gend FlexibilitÃ¤t bieten, um alle Situationen (auf unterschiedliche Weise) zu lÃ¶sen, bedeutet die Auswahl von ZIO, dass Sie â€Asyncâ€œ ohne Sorgen verwenden und den Problemcode in â€unsafeRunâ€œ einfÃ¼gen mÃ¼ssen. was bekanntermaÃŸen Deadlock verursacht <br><br><h2>  7. Kompatibel mit der Zukunft </h2><br>  Die Verwendung von â€Futureâ€œ aus der Scala-Standardbibliothek ist fÃ¼r eine groÃŸe Anzahl von Codebasen RealitÃ¤t.  ZIO wird mit einer "fromFuture" -Methode geliefert, die einen vorgefertigten AusfÃ¼hrungskontext bereitstellt: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">ZIO</span></span>.fromFuture(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ec =&gt; <span class="hljs-comment"><span class="hljs-comment">// Create some Future using `ec`: ??? )</span></span></code> </pre> <br>  Wenn diese Methode verwendet wird, um Future in einen Effekt zu verpacken, kann ZIO festlegen, wo Future ausgefÃ¼hrt wird, und andere Methoden, wie z. B. evalOn, Ã¼bertragen Future korrekt in den gewÃ¼nschten AusfÃ¼hrungskontext.  Cats IO akzeptiert "Future", das mit einem externen "ExecutionContext" erstellt wurde.  Dies bedeutet, dass Cats IO die AusfÃ¼hrung von Future nicht gemÃ¤ÃŸ den Anforderungen der evalOn- oder Shift-Methode verschieben kann.  DarÃ¼ber hinaus belastet dies den Benutzer mit der Bestimmung des AusfÃ¼hrungskontexts fÃ¼r Future, was eine enge Auswahl und eine separate Umgebung bedeutet. <br><br>  Da der bereitgestellte ExecutionContext ignoriert werden kann, kann ZIO als Summe der Cats IO-Funktionen dargestellt werden, was im allgemeinen Fall eine reibungslosere und genauere Interaktion mit Future garantiert. Es gibt jedoch immer noch Ausnahmen. <br><br><h2>  8. Blockieren von E / A. </h2><br>  Wie im Artikel â€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread Pool.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Best Practices mit ZIO</a> â€œFÃ¼r Serveranwendungen sind mindestens zwei separate Pools erforderlich, um maximale Effizienz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu erzielen</a> : <br><br><ul><li>  fester Pool fÃ¼r CPU / asynchrone Effekte; </li><li>  dynamisch, mit der MÃ¶glichkeit, die Anzahl der blockierenden Threads zu erhÃ¶hen. </li></ul><br>  Die Entscheidung, alle Effekte auf einen festen Thread-Pool auszufÃ¼hren, fÃ¼hrt eines Tages zu einem Deadlock, wÃ¤hrend das AuslÃ¶sen aller Effekte auf einen dynamischen Pool zu LeistungseinbuÃŸen fÃ¼hren kann. <br><br>  In der JVM bietet ZIO zwei VorgÃ¤nge, die Blockierungseffekte unterstÃ¼tzen: <br><br><ul><li>  Operator "Blocking (Effekt"), der die AusfÃ¼hrung eines bestimmten Effekts im Pool blockierender Threads mit guten Voreinstellungen umschaltet, die bei Bedarf geÃ¤ndert werden kÃ¶nnen); </li><li> Â«effectBlocking(effect)Â» ,          ,        . </li></ul><br>     ,     ,       ,       Â«blockingÂ».   ,    -    ,  ,       Â«effectBlockingÂ»     ,    ZIO  (  ). <br><br> Cats IO    ,         .    ,     Â«blockingÂ»,    Â«evalOnÂ», , ,         . <br><br>           (      ZIO)         (,        ),          . <br><br><h2> 9.   </h2><br>  ,      Scala,          : <br><br><ul><li> Â«ReaderTÂ»/ Â«KleisliÂ»,       ; </li><li> Â«EitherTÂ»,      ( Â«OptionTÂ»,     Â«EitherTÂ»   Â«UnitÂ»    ). </li></ul><br>    ,          (, http4s   Â«KleisliÂ»  Â«OptionTÂ»).        (Â«effect totationÂ»), ZIO   Â«readerÂ»  Â«typed errorÂ»      ZIO.         Â«readerÂ»  Â«typed errorÂ» , ZIO    ,    . , Â«Task[A]Â»,    Â«readerÂ»  Â«typed errorsÂ». <br><br>   ZIO     ()      - .  ,      ZIO     ,      . <br><br> Cats IO    .  ,  ,   Â«readerÂ»  Â«typed errorsÂ»      Â«stateÂ», Â«writerÂ»  ,      . <br><br> ZIO     8   Cats IO    .               ,          Scala          . <br><br><h2> 10.   </h2><br> ZIO   ,        ,      . ,           Scala,      . <br><br>   ZIO   2000  ,    Â«typed errorsÂ»  ,       â€”     375    .        Scala ,      .     ,      ,         . <br><br>           : <br><br><ul><li>      ; </li><li>        ; </li><li>  ,       ; </li><li>       . </li></ul><br>         .   , -    ,      . <br><br> -            .        ,     .      ZIO    . Cats IO    ,     ,  ZIO ( ,       ). <br><br><h2> 11.   </h2><br>  ZIO   ,     ,  -       . <br><br><ul><li>  ,  : Â«ZIO. succeedÂ»  Â«Applicative[F].pureÂ», Â«zipÂ»  Â«Apply[F].productÂ», Â«ZIO.foreachÂ»  Â«Traverse[F].traverseÂ». <br></li><li>         (Cats, Cats Effect, Scalaz     ). </li><li>  ,       (  Â«RuntimeÂ»,      Cats Effect  -   Cats Effect).  â€”        Cats IO. </li><li>    . </li><li>         . : "zip"/"zipPar", "ZIO.foreach"/"ZIO.foreachPar", "ZIO.succeed"/"ZIO.succeedLazyÂ«. <br></li><li>      ,        Â«Â».   ZIO    IDE. </li><li>      Scala  ZIO  : Â«ZIO.fromFutureÂ», Â«ZIO.fromOptionÂ», Â«ZIO.fromEitherÂ», Â«ZIO.fromTryÂ». </li><li>         Â«Â». </li></ul><br> ,          Scala,    ,  ZIO   ,       ,   ,   ZIO,     . Cats IO     ,        Cats. <br><br>     ,      ,     ,       ( , ,    ). <br><br><h2> 12.  </h2><br> ZIO â€”  - ,           . <br><br>     : <br><br><ul><li>     ,  Â«RefÂ», Â«PromiseÂ», Â«QueueÂ», Â«SemaphoreÂ»   Â«StreamÂ»    //; </li><li> STM,       , ,     ; </li><li> Â«ScheduleÂ»,    ; </li><li>    Â«ClockÂ», Â«RandomÂ», Â«ConsoleÂ»  Â«SystemÂ» ,     ; </li><li>      ,    . </li></ul><br> -   Cats IO    .    Cats IO  ,      (  )      . <br><br><h2>  Fazit </h2><br>  Cats Effect      Scala-,   ,    . <br><br>  ,   Cats Effect,    ,         Cats Effect : Cats IO, Monix, Zio. <br><br>    ,      .        ,    , ,  : ZIO  Cats Effect    . <br><br><blockquote>          Scala      â€”    .          ,   Scala. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ScalaConf  ,   18     ,     John A De Goes  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472386/">https://habr.com/ru/post/de472386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472372/index.html">Android-Automatisierung Super einfache Anleitung zum Erstellen Ihres ersten Espresso-Tests</a></li>
<li><a href="../de472374/index.html">Warum wir Server nach Island verlegt haben</a></li>
<li><a href="../de472378/index.html">Flash-ZuverlÃ¤ssigkeit: erwartet und unerwartet. Teil 2. XIV. Konferenz der USENIX Association. Dateispeichertechnologien</a></li>
<li><a href="../de472380/index.html">MIRO - eine offene Indoor-Roboterplattform</a></li>
<li><a href="../de472384/index.html">Ein Blick auf Android-Updates aus Entwicklersicht</a></li>
<li><a href="../de472388/index.html">Walmart erklÃ¤rt Amazon Preiskrieg</a></li>
<li><a href="../de472392/index.html">Aufstieg, Fall und mÃ¶gliche RÃ¼ckkehr von Audiokassetten - wir beschÃ¤ftigen uns mit Mythen und geben einen Ãœberblick Ã¼ber die Situation</a></li>
<li><a href="../de472394/index.html">Bewertung der Auswirkungen kÃ¼nstlicher Intelligenz auf Offshore-Ã–l und -Gas</a></li>
<li><a href="../de472396/index.html">In 4 Sekunden um die Welt im Columnstore (Teil 1)</a></li>
<li><a href="../de472402/index.html">RTMP-Videoanruf-Streaming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>