<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç™ ‚òÑÔ∏è ‚õµÔ∏è Rendimiento de animaci√≥n del sitio web ü§∂üèø üìí üë®üèª‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando se desarrollan sitios que van m√°s all√° del marco de un bootstrap condicional, tarde o temprano surgen preguntas sobre el rendimiento de las ani...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendimiento de animaci√≥n del sitio web</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450484/"><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="imagen"></p><br><p> Cuando se desarrollan sitios que van m√°s all√° del marco de un bootstrap condicional, tarde o temprano surgen preguntas sobre el rendimiento de las animaciones.  Son especialmente importantes en los sitios de dise√±o, como los que se incluyen en los cat√°logos Awwwards, FWA, CSS Design Awards, etc.  En este caso, a menudo la tarea de crear animaciones y la posterior optimizaci√≥n, si es necesario, recae sobre los hombros de desarrolladores poco experimentados que ni siquiera saben por d√≥nde empezar.  Por lo general, todo esto se traduce en sitios inhibitorios que son imposibles de usar, y la actitud negativa posterior a toda la clase de tales proyectos.  En este art√≠culo, intentaremos averiguar d√≥nde est√° el l√≠mite del rendimiento de animaci√≥n aceptable, qu√© cuellos de botella son comunes y d√≥nde buscar en las herramientas de desarrollador en primer lugar. </p><a name="habracut"></a><br><p>  <em>Una peque√±a observaci√≥n: dado que este art√≠culo est√° destinado m√°s a desarrolladores principiantes y su objetivo es mostrar enfoques generales para optimizar las animaciones, muchas cosas se dar√°n en una forma simplificada, no del todo acad√©mica.</em> </p><br><h2 id="kak-brauzer-otobrazhaet-stranicu">  C√≥mo muestra la p√°gina el navegador </h2><br><p>  En primer lugar, es √∫til comprender qu√© sucede cuando el navegador nos muestra el estado actual de la p√°gina.  Hay cuatro pasos principales: </p><br><ol><li>  C√°lculo de estilos (el navegador analiza los selectores CSS, determina qu√© estilos se deben aplicar a qu√©) </li><li>  Creaci√≥n de dise√±o (el dise√±o de p√°gina est√° realmente formado) </li><li>  Pintura (crea representaciones de elementos en p√≠xeles para su posterior representaci√≥n) </li><li>  Composici√≥n de la capa (el navegador recopila todo junto y lo muestra en la pantalla) </li></ol><br><p>  Adem√°s, el navegador siempre act√∫a en esta secuencia y llega al final.  Cuando la p√°gina se muestra inicialmente despu√©s de cargarla, se realizan los cuatro pasos.  En el futuro, nuestras acciones pueden provocar la ejecuci√≥n de una de ellas, pero al mismo tiempo se ejecutar√°n todas las posteriores.  Pero no los anteriores. </p><br><p>  Consideraremos m√°s a fondo los cuellos de botella de cada uno de estos pasos, y ahora haremos una pregunta tonta a primera vista, a partir de la cual, en teor√≠a, debe comenzar ... </p><br><h2 id="tormozit-ili-ne-tormozit-vot-v-chem-vopros">  Si se ralentiza o no, esa es la pregunta ... </h2><br><p>  Muy a menudo puedes conocer gente que no est√° haciendo nada con un sitio web claramente lento y decir "pero la velocidad de mi p√°gina da 100 puntos, todo est√° bien".  O viceversa, en un sitio que funciona bien, las personas han estado involucradas en alg√∫n tipo de optimizaciones durante mucho tiempo, porque algunos algoritmos funcionan de manera ineficiente en funci√≥n de algunas m√©tricas misteriosas.  Pero entre estos extremos deber√≠a estar el medio del sentido com√∫n, entonces, ¬ød√≥nde est√°? </p><br><p><img src="https://habrastorage.org/webt/zv/su/nv/zvsunvxfwjqvs98q0_yhc9s5jry.jpeg" alt="imagen"></p><br><p>  A <del>  conocer zen </del>  Para comprender si necesita optimizar sus animaciones, necesita realizar un profundo pensamiento filos√≥fico: </p><br><blockquote>  Si ve que el sitio es lento, significa que es lento.  Si no ve que el sitio se est√° desacelerando, entonces no se est√° desacelerando. </blockquote><p>  Por alguna raz√≥n, muchas personas encuentran esta afirmaci√≥n muy est√∫pida, pero ¬øes as√≠?  Para el usuario final, el rendimiento no es alg√∫n tipo de m√©trica o algoritmo ideal con una rigurosa justificaci√≥n matem√°tica.  Para √©l, el rendimiento es una de dos cosas: se ralentiza o no se ralentiza. </p><br><p>  ¬øC√≥mo determina esto?  El ojo de una persona que pasa mucho tiempo detr√°s del monitor comienza a reaccionar bruscamente a una ca√≠da de fps.  Esto causa una extra√±a sensaci√≥n de incomodidad.  En consecuencia, nuestra tarea, como desarrolladores, es evitar el hundimiento.  ¬øEl usuario est√° acostumbrado a ver que el navegador funciona a 60 fps?  Bueno, entonces estamos haciendo todo para que todo siga as√≠.  Tomamos una laptop con plancha mediana y miramos.  Vemos mucho menos de 60 fps: optimizamos.  Vemos unos 60, no toques nada.  El usuario no notar√° la diferencia de todos modos, y dedicaremos mucho tiempo a la optimizaci√≥n en aras de las optimizaciones. </p><br><blockquote>  No haga optimizaciones para optimizaciones. </blockquote><br><h2 id="165ms">  16.5ms </h2><br><p>  Expresarse en t√©rminos de fps no es conveniente, as√≠ que pasemos a milisegundos.  Con una divisi√≥n simple de 1000ms / 60fps, obtenemos aproximadamente 16.5ms de tiempo por cuadro. </p><br><p>  ¬øQu√© significa esto?  Durante 16.5 ms, el navegador debe mostrarnos el estado actual de la p√°gina con la animaci√≥n, siguiendo los pasos que vimos anteriormente, y al mismo tiempo, los recursos deben permanecer para el trabajo de otros scripts, comunicaci√≥n con el servidor, etc.  Si se dedica m√°s tiempo a mostrar el estado actual de la p√°gina, veremos a trav√©s de nuestros ojos el retraso.  Si son unos 16 ms, no habr√° hundimiento, pero es probable que la carga de hierro sea muy alta, los refrigeradores zumben y los tel√©fonos se calienten.  Por lo tanto, debemos asegurarnos de que la representaci√≥n de un cuadro no se acerque a este valor a tiempo, y a√∫n mejor no sea m√°s de 10 ms, de modo que haya un margen en el rendimiento.  No olvide que las pruebas siempre se realizan en el hardware del medio; por ejemplo, en los siguientes ejemplos, las capturas de pantalla se tomar√°n en Pentium Silver con gr√°ficos integrados. </p><br><blockquote>  Pruebe el hardware que es m√°s probable que tengan sus usuarios.  Si tiene un procesador de gama alta y una granja minera debajo de la mesa en su lugar de trabajo, entonces todo funcionar√° bien para usted, mientras que sus usuarios con computadoras port√°tiles econ√≥micas pueden ser muy tristes. </blockquote><p>  Para no confiar solo en su buen ojo e intuici√≥n, es √∫til dominar las herramientas de desarrollo, al menos a un nivel b√°sico.  No solo proporcionar√°n datos de rendimiento precisos, sino que tambi√©n le indicar√°n d√≥nde buscar el problema, si todo no funciona muy bien. </p><br><h2 id="instrumenty-razrabotchika-v-google-chrome">  Herramientas para desarrolladores en Google Chrome </h2><br><p>  Muchas veces, las herramientas de desarrollo en el navegador sorprenden a muchos codificadores m√°s que a la consola de Linux.  Pero, de hecho, no hay nada que temer.  S√≠, hay muchos botones, pero son redundantes para resolver nuestros problemas.  Ahora veremos d√≥nde vale la pena prestar atenci√≥n en primer lugar para comprender qu√© hacer con la animaci√≥n y si es necesario hacer algo. </p><br><p>  Cuando se trata de rendimiento, pasaremos la mayor parte del tiempo en la pesta√±a de rendimiento y presionaremos el mismo bot√≥n. </p><br><p><img src="https://habrastorage.org/webt/a_/wd/vn/a_wdvnjnvppuvnrzp_f4sxp4gb0.png" alt="imagen"></p><br><p>  El acceso directo Ctrl-E o el bot√≥n redondo a la izquierda comienza y detiene la grabaci√≥n de lo que est√° sucediendo.  Los resultados se muestran aqu√≠.  El navegador escribe muchas cosas, pero es mejor verlo una vez que leerlo muchas veces, as√≠ que tomemos alg√∫n tipo de animaci√≥n y miremos.  Que sea una simple animaci√≥n CSS para empezar.  Si lo abre en pantalla completa, puede ver que funciona con atascos notables: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/Xwrqpw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Grabaremos unos segundos en modo de pantalla completa y veremos qu√© sucede all√≠: </p><br><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="imagen"></p><br><p>  El navegador registra todo lo que hace.  En la parte superior de la ventana vemos un gr√°fico fps.  Se puede usar f√°cilmente para detectar una anomal√≠a si, en el proceso de trabajar con la p√°gina, comienza a ralentizarse bruscamente.  Si hace clic en el gr√°fico con el mouse y lo tira hacia un lado o gira la rueda, puede seleccionar este rango de tiempo y la informaci√≥n detallada para ello se mostrar√° a continuaci√≥n.  En nuestro ejemplo simple, no hay anomal√≠as, pero se ve claramente que no todo funciona de manera muy uniforme. </p><br><p>  Preste atenci√≥n de inmediato a la l√≠nea <em>Marcos</em> , que contiene informaci√≥n sobre el tiempo dedicado a cada marco.  Puede notar que esta vez salta constantemente y supera significativamente los 16 ms (a continuaci√≥n, en ejemplos pr√°cticos, mejoraremos ligeramente esta animaci√≥n). </p><br><p>  A continuaci√≥n, vemos varias l√≠neas en las que la carga se muestra en diferentes colores: puede ver cu√°nto tiempo pas√≥ el navegador en diferentes tipos de actividades.  Nuestra animaci√≥n es uniforme y se realizan las mismas operaciones para cada cuadro, indicadas en p√∫rpura y verde.  Si mueve el mouse sobre los bloques de colores, quedar√° claro que estamos tratando con los elementos que se mencionaron al principio: <em>recalcular el estilo</em> y <em>actualizar el √°rbol de capas</em> son morados, y las <em>capas de</em> <em>pintura</em> y <em>compuestas</em> son verdes. </p><br><p>  Considera otra animaci√≥n.  Esta vez con scripts, un simple generador de ruido.  Este es un ejemplo bastante ilustrativo, aunque no es de inter√©s desde el punto de vista del dise√±o: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/QRLrBJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Puede notar que se han agregado bloques amarillos que muestran la ejecuci√≥n de scripts.  Si habr√° muchas llamadas de funci√≥n, entonces para cada llamada se agregar√° un bloque m√°s; por su tama√±o, es f√°cil encontrar la funci√≥n "m√°s pesada", con la cual, probablemente, deber√≠a comenzar la optimizaci√≥n. </p><br><p><img src="https://habrastorage.org/webt/er/j_/cb/erj_cbmcg89tvzk-dco35nqcmia.jpeg" alt="imagen"></p><br><p>  En el ejemplo, el tiempo dedicado a un cuadro fluct√∫a alrededor de 80 ms.  Pero lo que hay all√≠, incluso a simple vista, puedes ver claramente c√≥mo se bloquea todo.  Mirando la secci√≥n de <em>resumen a</em> continuaci√≥n, vemos que las secuencias de comandos ocupan m√°s tiempo.  En comparaci√≥n con ellos, el <em>renderizado</em> y la <em>pintura</em> parecen errores que se pueden descuidar.  No siempre, por supuesto, sucede, pero con bastante frecuencia. </p><br><p>  Si hace clic en el bloque marcado como <em>llamada de funci√≥n</em> , a continuaci√≥n hay un enlace a la funci√≥n en el c√≥digo del script.  Si lo revisa, puede ver que en este ejemplo hay un ciclo a trav√©s de todos los p√≠xeles en la pantalla.  Ser√≠a m√°s l√≥gico hacer esa tarea en los sombreadores, luego el rendimiento ser√≠a mucho mejor.  Pero lo veremos en ejemplos pr√°cticos. </p><br><h2 id="chto-delat-esli">  Qu√© hacer si ... </h2><br><p>  Aprendimos qu√© pasos hay cuando se muestra el estado actual de una p√°gina en un navegador, y d√≥nde ver cu√°l toma m√°s tiempo.  Es hora de familiarizarse con las razones m√°s comunes por las cuales un paso en particular comienza a requerir demasiados recursos y da un par de consejos sobre qu√© hacer en un caso particular. </p><br><h2 id="style-calculation">  C√°lculo de estilo </h2><br><p>  Si ve que ya en este paso comienzan los problemas, lo m√°s probable es que el punto no est√© ni siquiera en la animaci√≥n, sino en el hecho de que hay demasiados elementos en la p√°gina.  En los sitios de dise√±o esto es bastante raro, por lo general, tal problema es un sat√©lite de tablas grandes con miles de elementos, pero si a√∫n se encuentra con esto: </p><br><blockquote>  Reduzca el n√∫mero de elementos en la p√°gina, simplifique el dise√±o.  Preste especial atenci√≥n a la repetici√≥n de piezas de c√≥digo con envoltorios, es probable que puedan eliminarse. </blockquote><p>  La segunda raz√≥n asociada con la primera son los selectores CSS complejos.  Si en p√°ginas peque√±as es bastante posible usar anidamiento profundo, trucos complicados con elementos vecinos, etc., en una p√°gina realmente grande, todo esto puede conducir a un bajo rendimiento. </p><br><blockquote>  Simplifique los selectores CSS, use BEM. </blockquote><br><h2 id="layout-creation">  Creaci√≥n de dise√±o </h2><br><p>  Este elemento ya est√° m√°s cerca del dise√±o y las animaciones, aqu√≠ comienzan cosas interesantes.  Lo primero que es importante entender es que se forma todo el dise√±o.  Si cambiamos algo, se forma de nuevo.  Por esta raz√≥n, incluso peque√±os cambios en la p√°gina grande pueden causar retrasos notables en este paso. </p><br><p>  La regla principal que nos gu√≠a al crear animaciones es no permitir la reestructuraci√≥n del dise√±o a cualquier costo.  Por lo tanto, generalmente no intentamos optimizarlo (y no hay oportunidades particulares), es decir, tratamos de evitarlo. </p><br><p>  Hay muchas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedades</a> que pueden causar la reconstrucci√≥n del dise√±o, puede encontrar listas en Internet, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">csstriggers.com</a> no es malo.  M√°s a menudo que otros en las animaciones puedes encontrar propiedades: </p><br><pre><code class="plaintext hljs">display position / top / left / right / bottom width / height padding / margin border font-size / font-weight / line-height ...</code> </pre> <br><p>  Puede notar que todas estas propiedades est√°n unidas por una cosa: describen las caracter√≠sticas geom√©tricas de los elementos: par√°metros de visualizaci√≥n, tama√±o y ubicaci√≥n f√≠sica.  Entonces, en lugar de memorizarlos a todos, recuerde a qu√© se refieren. </p><br><blockquote>  No cambie las propiedades geom√©tricas de los elementos, es mejor usar transformaci√≥n y opacidad. </blockquote><p>  Por separado, vale la pena se√±alar que cambiar el fondo del elemento tambi√©n nos devolver√° a este paso.  Se olvidan constantemente de esto, por lo que destacamos en una recomendaci√≥n por separado: </p><br><blockquote>  No cambie los elementos de fondo. </blockquote><p>  En algunos navegadores ( <del>  No voy a meter un dedo en Firefox </del>  ) puede aparecer un retraso t√≠pico de animaciones CSS con transformaciones, especialmente si se realiza m√°s de una animaci√≥n por unidad de tiempo.  Exteriormente, esto puede parecer no solo como una pausa en su trabajo, sino tambi√©n como "aver√≠as" de la animaci√≥n desde el principio.  Parece que el navegador est√° constantemente recalculando algo.  Este comportamiento casi siempre se corrige utilizando la propiedad de <em>visibilidad posterior</em> . </p><br><blockquote>  Si es posible, agregue visibilidad posterior: oculta a los elementos animados. </blockquote><p>  Adem√°s, la reconstrucci√≥n del dise√±o es causada por nuestras llamadas a elementos desde scripts.  Adem√°s, esto no tiene que ser un cambio directo a CSS, tambi√©n puede ser atractivo para algunas propiedades y m√©todos de elementos.  Los m√°s comunes son: </p><br><pre> <code class="plaintext hljs">offset*** client*** inner*** scroll***</code> </pre> <br><p>  En las animaciones, debes tener cuidado con ellas, porque  Si comenzamos a referirnos a estas propiedades y m√©todos para una gran cantidad de elementos, cada vez esto causar√° una reestructuraci√≥n del dise√±o. </p><br><blockquote>  Evite referirse a las propiedades y m√©todos mencionados para elementos individuales en bucles. </blockquote><br><h2 id="painting-i-layer-composition">  Pintura y composici√≥n de capas. </h2><br><p>  Consideraremos estos dos pasos juntos, como  est√°n algo relacionados y, por lo general, si hay problemas con uno, lo estar√°n con el otro.  Omitir estos pasos, evitarlos no funcionar√°, por lo que estamos tratando de optimizarlos de alguna manera. </p><br><p>  El navegador no prepara la imagen en p√≠xeles de la p√°gina, sino en partes: las capas.  Puede haber muchos.  Cada capa existe como si fuera en s√≠ misma y no afecta al resto, lo que crea la base para algunos hacks CSS.  Pero hablaremos de ellos en otro momento.  Luego, la imagen final se recoge de estas capas.  En el contexto de las animaciones, es muy √∫til colocar elementos animados en una capa separada para que sus cambios no afecten a todo.  Es deseable que el contenido de los elementos sea peque√±o.  Podemos hacer esto usando la propiedad <em>will-change</em> o, como lo hicimos antes, <em>transform: translateZ (0)</em> .  Lo √∫nico que debe recordar es que no puede aumentar el n√∫mero de capas indefinidamente.  En alg√∫n momento, esto jugar√° un truco y el rendimiento opuesto caer√°.  Entonces habr√° dos consejos: </p><br><blockquote>  Utilice will-change o transform: translateZ (0) para mover los elementos animados a una capa separada. </blockquote><p>  pero al mismo tiempo </p><br><blockquote>  No te excedas con este negocio.  Compruebe en las herramientas de desarrollador que no es peor. </blockquote><p>  Muy a menudo, los filtros causan problemas serios que de alguna manera transforman la imagen de los elementos.  Pueden ser simples filtros CSS con opciones <em>borrosas</em> u confusas con SVG, pero el efecto ser√° el mismo: una disminuci√≥n notable en el rendimiento. </p><br><blockquote>  No use filtros complejos.  Si a√∫n necesita el efecto deseado, considere implementarlo en WebGL. </blockquote><br><h2 id="naskolko-eti-sovety-rabotayut">  ¬øC√≥mo funcionan estos consejos? </h2><br><p>  Funcionan, pero no necesita esperar un milagro de ellos.  En la red, los novatos a veces dicen: "Agregu√© un cambio de voluntad, pero nada ha cambiado".  Por lo general, esto significa que el problema principal estaba en otro lugar, y esta t√©cnica produjo un aumento tan peque√±o en la productividad que pas√≥ desapercibido.  Por eso es importante usar las herramientas del desarrollador para comprender claramente d√≥nde est√° el cuello de botella y no gastar tiempo y esfuerzo tratando de optimizar lo que funciona bien de todos modos. </p><br><p>  De todo esto podemos concluir que no hay muchas formas de influir en la representaci√≥n de una p√°gina, y el efecto de ellas no siempre ser√° significativo.  Estos trucos no son balas de plata, son m√°s bien necesarios para pulir la animaci√≥n.  Si observamos sitios con un rendimiento realmente bajo, notaremos que en la gran mayor√≠a de los casos nuestros propios guiones son los culpables, y no problemas misteriosos con el an√°lisis de CSS en alg√∫n lugar de las entra√±as del navegador. </p><br><h2 id="skripty">  Guiones ... </h2><br><p>  ¬øSabes d√≥nde crecen los problemas con las animaciones inhibitorias con mayor frecuencia (seg√∫n mis observaciones)?  Aqu√≠ de este enfoque de desarrollo: </p><br><p><img src="https://habrastorage.org/webt/31/ov/_a/31ov_auhpakgnb4tu2mtfapgi7w.jpeg" alt="imagen"></p><br><p>  Suena tonto, pero lo es.  Constantemente hay soluciones, obviamente copiadas de alg√∫n lugar completamente sin entender lo que estaba sucediendo.  Incluso sucede que puede eliminar la mitad del c√≥digo y todo continuar√° funcionando.  A menudo, el c√≥digo en las respuestas a SO o Toaster no est√° destinado a su producci√≥n.  Eso deber√≠a ser obvio.  Muestra la idea, responde la pregunta, pero no es la opci√≥n final √≥ptima para su tarea espec√≠fica. </p><br><blockquote>  Si ya est√° copiando, al menos mire el c√≥digo en busca de acciones innecesarias. </blockquote><br><h2 id="requestanimationframe">  RequestAnimationFrame </h2><br><p>  A menudo hablan sobre este m√©todo y recomiendan usarlo en lugar de <em>setTimeout / setInterval</em> en las animaciones.  Esto tiene sentido, ya que esos m√©todos tienden a estar fuera de sincronizaci√≥n con los marcos que el navegador vuelve a dibujar, lo que resulta en peque√±os retrasos.  Pero hay dos puntos. </p><br><p>  En primer lugar, si se anima m√°s de un elemento en la p√°gina y llamamos a requestAnimationFrame muchas veces, esto conducir√° a un fuerte hundimiento de fps.  En teor√≠a, esto no deber√≠a ser, pero en la pr√°ctica, todo sucede as√≠.  Puede familiarizarse con las pruebas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><blockquote>  Combine todas las devoluciones de llamada de animaci√≥n en una sola solicitudAnimationFrame. </blockquote><p>  Es probable que el segundo punto est√© relacionado con la situaci√≥n en la que ya tenemos animaci√≥n pesada, tal vez con el uso del lienzo, del cual no podemos deshacernos o no tenemos tiempo para rehacer, y sucede lo siguiente: digamos que la animaci√≥n debe completarse en N segundos y ya usamos <em>requestAnimationFrame</em> .  Pero se necesitan muchos recursos para calcular el estado actual y vemos esta imagen: la animaci√≥n funciona sin problemas, bellamente, pero en 2N, o incluso 3N segundos.  Como resultado, todo se percibe taaaaaan.  Para corregir de alguna manera este comportamiento, puede ir en contra de todas las recomendaciones, usar <em>setInterval / setTimeout</em> y vincular los estados de los elementos animados al tiempo f√≠sico y no a cuadros abstractos.  Como resultado, obtenemos una disminuci√≥n formal en fps, pero con el efecto psicol√≥gico de las ganancias de productividad. </p><br><blockquote>  En el caso de animaciones extremadamente lentas, podr√≠a tener sentido rechazar requestAnimationFrame a favor de setInterval / setTimeout. </blockquote><br><h2 id="canvas-i-sheydery">  Lonas y sombreadores </h2><br><p>  Una parte importante de las animaciones en sitios no est√°ndar est√° relacionada con el lienzo.  Esto es comprensible, CSS es algo limitado, pero aqu√≠ podemos realizar las fantas√≠as de cualquier dise√±ador.  Pero debe tener en cuenta que el 2d-canvas habitual est√° lejos de ser la tecnolog√≠a m√°s productiva.  Si comienzas a dibujar muchos elementos en √©l o trabajas con p√≠xeles directamente, entonces te dar√°s cuenta r√°pidamente de que fps se est√° hundiendo, o que de repente la <em>pintura</em> y la <em>composici√≥n de capas</em> comienzan a tomar indecentemente mucho tiempo.  Este problema se puede ver claramente en el ejemplo: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/vdYRoj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Veamos qu√© hace el navegador (la √∫ltima versi√≥n de Google Chrome en Linux): </p><br><p><img src="https://habrastorage.org/webt/na/ox/5k/naox5kmmcqfuosbsfhgozpq91zw.jpeg" alt="imagen"></p><br><p>  Observe cu√°nto se ha expandido el paso de <em>composici√≥n de capa</em> .  Parece un poco il√≥gico, porque solo hay un elemento, ¬øqu√© se puede ensamblar all√≠ durante tanto tiempo?  Pero cuando se usa el lienzo 2D, este comportamiento no es infrecuente, y algo que tiene que ver con esto es muy problem√°tico.  Esta es una de las razones por las que solemos utilizar WebGL, no existen tales preguntas. </p><br><blockquote>  Si hay una opci√≥n entre el lienzo 2d y WebGL, elija el segundo.  Esto dar√° una bonificaci√≥n de rendimiento inicial en las mismas tareas. </blockquote><p>  ¬øQu√© se suele asociar con WebGL?  Con sombreadores.  Y depurar sombreadores es un dolor de cabeza para cualquiera que trabaje con ellos.  Y las herramientas de desarrollo aqu√≠ son pr√°cticamente impotentes.  Por lo general, si hay demasiados c√°lculos en los sombreadores, vemos en el resumen a continuaci√≥n que la mayor parte del tiempo es "simple", que de hecho es la ejecuci√≥n de nuestros sombreadores independientemente del navegador, y no podemos obtener ning√∫n detalle √∫til. </p><br><p>  Hay diferentes recomendaciones sobre qu√© funciones preferir sobre los sombreadores, porque supuestamente est√°n mejor optimizadas.  O que se deben evitar las operaciones de bloqueo.  Todo esto es cierto, pero seg√∫n mis observaciones, en la mayor√≠a de los casos, los sombreadores que ralentizan demasiado el sitio son simplemente sombreadores muy grandes.  Si escribi√≥ 100 l√≠neas GLSL en un solo lugar, es casi seguro que funcionar√° mal.  Y si tambi√©n hay diferentes construcciones anidadas, bucles, entonces todo: la escritura se ha ido.  Es dif√≠cil dar alguna recomendaci√≥n aqu√≠, a menos que: </p><br><blockquote>  Si durante el trabajo se dio cuenta de que todo es m√°s complicado de lo que parec√≠a inicialmente, y que habr√° mucho c√≥digo y se ralentizar√°, es mejor discutir esto con el dise√±ador y el cliente lo antes posible y pensar en lo que se puede cambiar. </blockquote><p>  A menudo, puede llegar a la conclusi√≥n de que un video preparado previamente funcionar√° mucho mejor que tratar de generar alg√∫n tipo de confusi√≥n en tiempo real.  Recuerda esto  S√≠, todos quieren mostrarse, quieren presumir "pero puedo hacerlo as√≠", pero no se olviden de los usuarios finales. </p><br><p>  En relaci√≥n con este pensamiento, recuerdo la "enfermedad" a la que la antigua Olimpiada es especialmente susceptible.  Por alguna raz√≥n, se manifiesta fuertemente cuando se trabaja con lienzo.  Por esta raz√≥n, siempre debe copiar cuidadosamente el c√≥digo de esas personas.  Intentan utilizar los algoritmos matem√°ticos "correctos", f√≥rmulas f√≠sicas complejas, para calcular todos los movimientos de los elementos con gran precisi√≥n, incluso cuando es completamente in√∫til.  Esto lleva a un aumento en la carga del procesador y al hecho de que para nuestros 10 ms condicionales no tiene tiempo para contar nada.  En la pr√°ctica, a menudo puedes sobrevivir con f√≥rmulas aproximadas y conocimientos escolares de f√≠sica.  No es necesario complicar las cosas, creamos sitios web, no software para misiles bal√≠sticos. </p><br><blockquote>  Usa algoritmos simples. </blockquote><p>  Hay otro truco llamado <em>RayMarching</em> .  Algunas personas consideran que la creaci√≥n de diferentes efectos es algo as√≠ como un desaf√≠o, un calentamiento para la mente y, a veces, los resultados son muy impresionantes.  Por ejemplo, aqu√≠ se genera un mundo submarino completo (insert√© un video, porque de los c√°lculos de esto en tiempo real el tel√©fono / computadora port√°til puede colgarse): </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mQXUHTTq4E8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  El sombreador en s√≠ se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  En la pr√°ctica, todo esto requiere recursos incre√≠bles para trabajar.  En modo de pantalla completa, tenemos 400-800ms por cuadro (en general, en este ejemplo, puede llegar hasta 1500ms): </p><br><p><img src="https://habrastorage.org/webt/pj/jj/pj/pjjjpj9fu4fcqkvtqg2bggwhqhc.jpeg" alt="imagen"></p><br><p>  Entonces, si te sorprendiste pensando en hacer algo como esto en un sitio de combate, date un teclado en la cabeza, bebe t√© y piensa en opciones alternativas para implementar efectos. </p><br><blockquote>  No use RayMarching, esta es una forma segura de matar el rendimiento. </blockquote><br><h2 id="prakticheskiy-primer">  Ejemplo pr√°ctico </h2><br><p>  A menudo no hay suficientes ejemplos en art√≠culos sobre productividad, pero puede ser dif√≠cil expresar una palabra.  As√≠ que considera una pareja.  ¬øRecuerdas el primer ejemplo de t√∫nel giratorio CSS?  El navegador hizo muchas cosas: </p><br><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="imagen"></p><br><p>  Queremos acelerar un poco las cosas.  Por donde empezar  Vemos bloques morados, lo que significa que el navegador est√° reconstruyendo constantemente el dise√±o.  No hay scripts all√≠, pero hay animaciones CSS en las que algo cambia.  Veamos su c√≥digo: </p><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> rotate { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotate</span></span>(0); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotate</span></span>(360deg); } } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> move-block { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(0); <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: @color1; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(-@block-size * 6); <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: @color2; } }</code> </pre> <br><p>  Las transformaciones no nos asustan, pero vemos un cambio en el fondo de los elementos.  Recordamos que esto puede causar una reestructuraci√≥n del dise√±o, y creemos que se puede hacer en esta situaci√≥n ... </p><br><p>  El cambio del fondo debe eliminarse a toda costa, por lo que, seg√∫n la idea general de animaci√≥n, decidimos que puede colocar un degradado radial en la parte superior, lo que crear√° casi el mismo efecto de volumen.  Alguien dir√° que los gradientes tienen un efecto negativo en el rendimiento, pero no vamos a cambiarlo.  Que sea mejor una vez que afecte gravemente que tendremos una monta√±a entera de elementos que afectan constantemente.  El resultado es: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/OYLZpx" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Veamos qu√© hace el navegador: </p><br><p><img src="https://habrastorage.org/webt/0i/hc/oh/0ihcohn8cxnwbrq78qgmo8b0-w4.jpeg" alt="imagen"></p><br><p>  Wow ... En lugar de un mont√≥n de acciones, vemos llamadas raras a la GPU y nada m√°s, mientras que la animaci√≥n en s√≠ comenz√≥ a funcionar notablemente m√°s suave. </p><br><h2 id="esche-primer">  Otro ejemplo </h2><br><p>  Recuerde c√≥mo se ve√≠a el navegador en el generador de ruido: </p><br><p><img src="https://habrastorage.org/webt/er/j_/cb/erj_cbmcg89tvzk-dco35nqcmia.jpeg" alt="imagen"></p><br><p>  El problema definitivamente est√° en los guiones.  Se puede ver que el bloque "render" es el m√°s grande.  Esta es nuestra funci√≥n principal para renderizar la imagen.  Miremosla: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageData = CTX.createImageData(CTX.canvas.width, CTX.canvas.height); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; imageData.data.length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = getRandom(); imageData.data[i] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">2</span></span>] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">255</span></span>; } CTX.putImageData(imageData, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); requestAnimationFrame(render); }</code> </pre> <br><p>  Definitivamente hay trabajo en curso con p√≠xeles individuales.  Esto no es muy saludable.  Dijimos que, si es posible, es mejor usar no 2d-canvas, sino WebGL, y esta tarea solo quiere ser paralela usando un sombreador.  Hag√°moslo: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/VOZxGp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  ¬øCu√°l ser√° el resultado?  V√©alo usted mismo: </p><br><p><img src="https://habrastorage.org/webt/3m/td/vh/3mtdvhlrjo4-cjuqmzieis4tr7w.jpeg" alt="imagen"></p><br><p>  El tiempo para un cuadro disminuy√≥ a casi 16 ms.  Por supuesto, esto no es ideal, pero a√∫n mejor que 80ms.  En animaciones hermosas y complejas, tal aumento de rendimiento puede ser muy notable.  Aprovecho esta oportunidad para recomendar que los principiantes se familiaricen con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">introducci√≥n de sombreadores en la programaci√≥n</a> y con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">continuaci√≥n con ejemplos</a> . </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  En este art√≠culo, descubrimos cu√°ndo se trata de optimizar el rendimiento de las animaciones, c√≥mo usar las herramientas de desarrollador en Chrome en este contexto y qu√© buscar primero.  Espero que esta informaci√≥n sea √∫til para los desarrolladores que se enfrentan a tales tareas por primera vez y no saben por d√≥nde empezar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450484/">https://habr.com/ru/post/450484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450472/index.html">¬øC√≥mo hacer una hoja de ruta perfecta?</a></li>
<li><a href="../450474/index.html">Introducci√≥n a Python</a></li>
<li><a href="../450476/index.html">C√≥mo registramos una empresa en la UE</a></li>
<li><a href="../450478/index.html">Hoy, muchos complementos populares para Firefox han dejado de funcionar debido a problemas con los certificados.</a></li>
<li><a href="../450480/index.html">C√≥mo la computaci√≥n cu√°ntica puede afectar el desarrollo de software</a></li>
<li><a href="../450486/index.html">9. Check Point Getting Started R80.20. Control de aplicaciones y filtrado de URL</a></li>
<li><a href="../450488/index.html">Aplicaci√≥n para Android Chock Norris Facts en Kotlin</a></li>
<li><a href="../450490/index.html">Acuerdo de $ 6.9 mil millones: ¬øpor qu√© un desarrollador de GPU compra un fabricante de equipos de red?</a></li>
<li><a href="../450492/index.html">Trabajo social y dise√±o abierto. Introduccion</a></li>
<li><a href="../450494/index.html">¬øC√≥mo depende la traducci√≥n del t√©rmino troncal del proveedor del conmutador?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>