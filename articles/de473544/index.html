<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🌾 👎🏼 👩🏽‍🏭 JPEG Multiple Reload-Studie 💇🏽 🤢 👦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VK hat eine Gruppe mit folgender Beschreibung: 
 Das gleiche Foto wird jeden Tag manuell auf einem Computer gespeichert und erneut hochgeladen, wodurc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JPEG Multiple Reload-Studie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473544/"><p>  VK hat eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gruppe</a> mit folgender Beschreibung: </p><br><blockquote>  Das gleiche Foto wird jeden Tag manuell auf einem Computer gespeichert und erneut hochgeladen, wodurch die Qualität allmählich abnimmt. </blockquote><p>  Links ist das Originalbild, das am 7. Juni 2012 hochgeladen wurde, rechts ist es das, was es jetzt ist. </p><br><p><img src="https://habrastorage.org/webt/k1/nd/gc/k1ndgcipxujc4rl7mplffliy3ae.jpeg" alt="KDPV"></p><br><div class="spoiler">  <b class="spoiler_title">Video</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ymca5aWPurM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><p>  Dieser Unterschied ist sehr verdächtig.  Versuchen wir herauszufinden, was in diesen 7 Jahren passiert ist.  Zur Bekanntschaft gibt es auf Medusa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> über diese Gruppe, aber nur die technische Seite wird uns interessieren. </p><a name="habracut"></a><br><h1 id="pochemu-i-na-kakom-etape-jpeg-szhimaet-s-poteryami">  Warum und zu welchem ​​Zeitpunkt komprimiert JPEG mit Verlusten </h1><br><p>  Betrachten Sie ein stark vereinfachtes JPEG-Codierungs- und Decodierungsschema.  Es werden nur die Operationen gezeigt, die die Grundprinzipien des JPEG-Algorithmus veranschaulichen. </p><br><p><img src="https://habrastorage.org/webt/bf/3l/mo/bf3lmo7c2boozc7d2id4pkqslka.png" alt="JPEG-Prinzipien"></p><br><p>  Also 4 Operationen: </p><br><ul><li>  DCT ist eine diskrete Cosinustransformation. </li><li>  Quantisierung - Rundung jedes Werts auf das nächste Vielfache des Quantisierungsschritts: y = [x / h] * h, wobei h der Schritt ist. </li><li>  IDCT ist die inverse diskrete Cosinustransformation. </li><li>  Rundung ist normale Rundung.  Diese Phase konnte im Diagramm nicht dargestellt werden, da dies offensichtlich ist.  Aber dann wird seine Bedeutung demonstriert. </li></ul><br><p>  Die grüne Farbe zeigt Operationen an, bei denen alle Informationen gespeichert werden (ohne Verluste bei der Arbeit mit Gleitkommazahlen zu berücksichtigen), die rosa verlieren.  Das heißt, Verluste und Artefakte treten nicht aufgrund der Kosinustransformation auf, sondern aufgrund der einfachen Quantisierung.  Der Artikel wird keine wichtige Phase berücksichtigen - die Huffman-Codierung, da sie ohne Verlust ausgeführt wird. </p><br><p>  Betrachten Sie diese Schritte genauer. </p><br><h3 id="dct">  DCT </h3><br><p>  Da es für alle Fälle verschiedene DCT-Varianten gibt, möchte ich klarstellen, dass JPEG einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten DCT-Typ</a> mit Normalisierung verwendet.  Bei der Codierung wird jedes Bild in 8 x 8 Quadrate (für jeden Kanal) unterteilt.  Jedes solche Quadrat kann als 64-dimensionaler Vektor dargestellt werden.  Die Kosinustransformation besteht darin, die Koordinaten dieses Vektors auf einer anderen orthonormalen Basis zu finden.  Es ist schwierig, den 64-dimensionalen Raum zu visualisieren, daher werden im Folgenden zweidimensionale Analogien angegeben.  Sie können sich vorstellen, dass das Bild in 2x1 Blöcke unterteilt ist.  In den unten gezeigten Diagrammen entspricht die x-Achse den Werten des ersten Pixels des Blocks, die y-Achse dem zweiten. </p><br><p>  Wenn Sie die Analogie mit einem bestimmten Beispiel fortsetzen, nehmen Sie an, dass die Werte von zwei Pixeln aus dem Originalbild 3 und 4 sind. Zeichnen Sie den Vektor (3, 4) auf der Originalbasis, wie in der folgenden Abbildung gezeigt.  Die ursprüngliche Basis ist blau markiert.  Die Koordinaten des Vektors in einer neuen Basis sind (4.8, 1.4). </p><br><p><img src="https://habrastorage.org/webt/qx/dh/xk/qxdhxkiyfx4j5uyh98m1y4c1ava.png" alt="Ein Beispiel für eine Vektortransformation auf einer neuen Basis"></p><br><p>  Im betrachteten Beispiel wurde zufällig eine neue Basis ausgewählt.  DCT bietet eine sehr spezifische 64-dimensionale feste Basis.  Die Begründung, warum es in JPEG verwendet wird, ist sehr interessant und wurde von mir in einem anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel beschrieben</a> .  Wir werden nur auf das Wesentliche eingehen.  Im Allgemeinen sind die Werte aller Pixel äquivalent.  Wenn wir sie jedoch mit DCT konvertieren, können wir aus den resultierenden 64 Koordinaten auf einer neuen Basis (als DCT-Transformationskoeffizienten bezeichnet) einige von ihnen mit minimalen Verlusten sicher auf Null setzen oder grob abrunden.  Dies ist dank der Funktionen komprimierbarer Bilder möglich. </p><br><h3 id="kvantovanie">  Quantisierung </h3><br><p>  Bruchwerte können nicht in einer Datei gespeichert werden.  Daher werden abhängig vom Quantisierungsschritt die Werte 4.8, 1.4 wie folgt gespeichert: </p><br><ul><li>  in Schritt 1 (die sanfteste Option): 5 und 1, </li><li>  in Schritt 2: 4 und 2 </li><li>  in Schritt 3: 6 und 0. </li></ul><br><p>  Normalerweise wird der Schritt für jeden Wert unterschiedlich gewählt.  Eine JPEG-Datei verfügt über mindestens ein Array, eine sogenannte Quantisierungstabelle, in der 64 Quantisierungsschritte gespeichert sind.  Diese Tabelle hängt von der in einem Grafikeditor festgelegten Komprimierungsqualität ab. </p><br><h3 id="idct">  IDCT </h3><br><p>  Wie DCT, jedoch transponiert.  Mathematisch ist x = IDCT (DCT (x)). Wenn es also keine Quantisierung gäbe, wäre es möglich, sich ohne Verlust zu erholen.  Aber es würde keine Komprimierung geben.  Aufgrund der Verwendung der Quantisierung kann der ursprüngliche Vektor nicht immer genau berechnet werden.  Die folgende Abbildung zeigt 2 Beispiele mit genauer und ungenauer Wiederherstellung.  Das schräge Gitter entspricht einer neuen Basis, die gerade Linie der ursprünglichen. </p><br><p><img src="https://habrastorage.org/webt/cl/ne/1g/clne1geexpruaosbsgwypmla0_8.png" alt="2 Beispiele mit genauer und ungenauer Vektorrekonstruktion"></p><br><p>  Die offensichtliche Frage stellt sich: Kann eine Sequenz der Transcodierung zu einem Vektor führen, der sich stark vom Original unterscheidet?  Vielleicht. </p><br><p><img src="https://habrastorage.org/webt/df/hm/ww/dfhmwwv_bcn3ru6qcgq8lrupkac.png" alt="Vektor-Transcodierungssequenz"></p><br><p>  Es wäre interessant, alle ganzzahligen Vektoren zu sortieren und zu sehen, wozu ihre Transcodierung führen wird.  Um das Informationsrauschen zu reduzieren, entfernen wir das Gitter der Anfangsbasis und verbinden die ursprünglichen und rekonstruierten Vektoren (ohne Zwischenschritt) direkt durch Segmente.  Betrachten Sie zunächst einen Quantisierungsschritt gleich 1 für alle Koordinaten.  Die neue Basis in der folgenden Abbildung ist um 45 Grad gedreht, und dafür haben wir 17,1% der ungenauen Wiederherstellungen.  Die Farben der Segmente bedeuten nichts, aber sie sind nützlich, um ihre visuelle Verschmelzung zu verhindern. </p><br><p><img src="https://habrastorage.org/webt/qv/oc/xv/qvocxvslveuyrvh76oxhqa-4tjk.png" alt="Aufzählung von Vektoren für eine neue Basis bei 45 Grad"></p><br><p>  Diese Basis ist 10,3 Grad mit 7,4% ungenauen Wiederfindungsraten: </p><br><p><img src="https://habrastorage.org/webt/bs/ig/3k/bsig3kc6xvaiympimbjemxmz6ci.png" alt="Aufzählung von Vektoren für eine neue Basis bei 10,3 Grad"></p><br><p>  In der Nähe: </p><br><p><img src="https://habrastorage.org/webt/zz/nx/lk/zznxlkpwk7zcgdjbzotimj5p6ho.png" alt="Aufzählung von Vektoren für eine neue Basis bei 10,3 Grad in der Nähe"></p><br><p>  Und dieser liegt bei 10,4 von 6,4%: </p><br><p><img src="https://habrastorage.org/webt/3j/uj/w_/3jujw_15jsspkq_gyi8ke-o-xje.png" alt="Aufzählung von Vektoren für eine neue Basis bei 10,4 Grad"></p><br><p>  19 Grad von 12,5%: </p><br><p><img src="https://habrastorage.org/webt/4o/xb/cf/4oxbcfgakefxb4jwkcna18nv_04.png" alt="Aufzählung von Vektoren für eine neue Basis bei 19 Grad"></p><br><p>  Wenn Sie jedoch den Quantisierungsschritt größer als 1 einstellen, konzentrieren sich die rekonstruierten Vektoren deutlich in der Nähe der Gitterknoten.  Dies ist Schritt 5: </p><br><p><img src="https://habrastorage.org/webt/lc/2v/uh/lc2vuhd2pk0dyvk7c3e3malrrqw.png" alt="Schritt 5"></p><br><p>  Dies ist 2: </p><br><p><img src="https://habrastorage.org/webt/0j/dj/wi/0jdjwier8s0zqh162fbq1k7evmw.png" alt="Schritt 2"></p><br><p>  Wenn Sie das Bild mehrmals, jedoch mit derselben Tonhöhe, neu codieren, geschieht im Vergleich zu einer einzelnen Neukodierung fast nichts.  Die Werte scheinen in den Knoten des Gitters "stecken zu bleiben" und können von dort nicht mehr zu anderen Knoten "springen".  Wenn der Schritt anders ist, „springt“ der Vektor von einem Gitterknoten zum anderen.  Das kann ihn überall hin bringen.  Die folgende Abbildung zeigt das Ergebnis von 4 Transcodierungen mit den Schritten 1, 2, 3, 4. Mit Schritt 12 sehen Sie ein großes Raster. Dieser Wert ist das kleinste gemeinsame Vielfache von 1, 2, 3, 4. </p><br><p><img src="https://habrastorage.org/webt/t7/ee/tx/t7eetx-d2upsghi2ayvlz1jh7ra.png" alt="Ergebnis von 4 Rekodierungen mit den Schritten 1, 2, 3, 4"></p><br><p>  Und dazu - mit Schritten von 1 bis 7. Die Visualisierung wird nur für einen Teil der ursprünglichen Vektoren angezeigt, um die Visualisierung zu verbessern. </p><br><p><img src="https://habrastorage.org/webt/xj/mw/t2/xjmwt2uyzvtcpjuq64xsj5qerqg.png" alt="4 Umcodierung führt zu Schritten von 1 bis 4"></p><br><h3 id="okruglenie">  Rundung </h3><br><p>  Warum Werte nach IDCT abrunden?  Wenn Sie diese Phase loswerden, wird das wiederhergestellte Bild durch Bruchwerte dargestellt, und wir verlieren beim Neucodieren nichts.  Aus mathematischer Sicht werden wir einfach ohne Verlust von einer Basis zur anderen wechseln.  Hier ist die Umwandlung von Farbräumen zu erwähnen.  Obwohl JPEG den Farbraum nicht reguliert und es Ihnen ermöglicht, direkt im Quell-RGB zu speichern, wird in den allermeisten Fällen die vorläufige Konvertierung in YCbCr verwendet.  Augenmerkmale und all das.  Und eine solche Umwandlung führt auch zu Verlusten. </p><br><p>  Angenommen, wir erhalten eine JPEG-Datei, die mit maximaler Qualität komprimiert ist, dh mit einem Quantisierungsschritt von 1 für alle Koeffizienten.  Wir wissen nicht, welcher Codec verwendet wurde, aber normalerweise führen Codecs nach der RGB -&gt; YCbCr-Konvertierung eine Rundung durch.  Da die Qualität maximal ist, erhalten wir nach IDCT gebrochene, aber ziemlich nahe an den ursprünglichen Werten im YCbCr-Raum liegende Werte.  Wenn wir runden, werden die meisten von ihnen genau wiederhergestellt. </p><br><p>  Wenn sie jedoch nicht gerundet sind, kann die YCbCr -&gt; RGB-Konvertierung sie aufgrund der geringen Unterschiede noch weiter von den ursprünglichen Werten entfernen.  Mit der anschließenden Transcodierung wird die Lücke immer größer.  Um diesen Prozess irgendwie zu visualisieren, verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Hauptkomponentenmethode,</a> um 64-dimensionale Vektoren auf eine Ebene zu projizieren.  Dann erhalten wir für 1000 Transcodes ungefähr die folgende Folge von Änderungen: </p><br><p><img src="https://habrastorage.org/webt/lk/et/ii/lketiizdbzs1n3ak2ou9pm39rem.png" alt="Änderungen ohne Rundung"></p><br><p>  Die absoluten Werte der Achsen sind hier nicht sehr sinnvoll, aber die relative Bedeutung der Verzerrungen kann verwendet werden. </p><br><h1 id="primery-mnogokratnogo-perekodirovaniya">  Beispiele für mehrere Transcodierungen </h1><br><p>  Quellkatze: </p><br><p><img src="https://habrastorage.org/webt/xf/n8/uh/xfn8uhltsnwghy5mdkgffzis0jc.jpeg" alt="Quellkatze"></p><br><p>  Nach einer Konservierung mit Qualität 50: </p><br><p><img src="https://habrastorage.org/webt/lz/fh/gb/lzfhgbgntfvhase6t7z-kisz_ja.jpeg" alt="Originalkatze nach einmaliger Konservierung mit Qualität 50"></p><br><p>  Nach einer nachfolgenden Anzahl von Transcodes mit derselben Qualität ändert sich das Bild nicht.  Jetzt werden wir die Qualität schrittweise von 90 auf 50 in 1 reduzieren: </p><br><p><img src="https://habrastorage.org/webt/br/zj/px/brzjpxgha8w0sfl_wzwzg0uybwq.jpeg" alt="Allmähliche Qualitätsminderung von 90 auf 50 in 1"></p><br><p>  In der folgenden Tabelle ist ungefähr dasselbe passiert: </p><br><p><img src="https://habrastorage.org/webt/xj/mw/t2/xjmwt2uyzvtcpjuq64xsj5qerqg.png" alt="4 Umcodierung führt zu Schritten von 1 bis 4"></p><br><p>  Nach einer Konservierung mit Qualität 20: </p><br><p><img src="https://habrastorage.org/webt/zz/pq/lc/zzpqlcbvnfdv-af3zscizmk4eeg.jpeg" alt="Nach einer Konservierung mit Qualität 20"></p><br><p>  Nahtlos von 90 bis 20: </p><br><p><img src="https://habrastorage.org/webt/ve/3z/qo/ve3zqos_tivr6s6vw4cdgncizpw.jpeg" alt="Allmählicher Qualitätsverlust von 90 auf 20"></p><br><p>  Jetzt 1000 mal mit zufälliger Qualität von 80 bis 90: </p><br><p><img src="https://habrastorage.org/webt/iw/4u/zg/iw4uzgbnuyp5x8z40dhcd-qhxfg.jpeg" alt="1000 Re-Stores mit zufälliger Qualität von 80 bis 90"></p><br><p>  10.000 Mal: </p><br><p><img src="https://habrastorage.org/webt/ve/eh/ww/veehwwqlhvfzy2rlk9hgjrqh2qu.jpeg" alt="10.000 Filialen mit zufälliger Qualität von 80 bis 90"></p><br><h1 id="analiz-kartinok-gruppy-vk">  VK Group Bilderanalyse </h1><br><p>  Beginnen wir mit der Analyse von mehr als 2000 Bildern aus der VK-Gruppe.  Überprüfen Sie zunächst die durchschnittliche absolute Abweichung vom ersten.  Die x-Achse ist die Bildnummer (oder der Tag), die y-Achse ist die Abweichung. </p><br><p><img src="https://habrastorage.org/webt/ln/5v/4h/ln5v4hqh-48jdun5t95ruzo0gue.png" alt="Die durchschnittliche absolute Abweichung von der ersten"></p><br><p>  Fahren wir mit dem Differentialdiagramm fort, das die durchschnittliche absolute Abweichung der benachbarten Bilder zeigt. </p><br><p><img src="https://habrastorage.org/webt/hv/gg/i5/hvggi5lzyjh4bdyt3i2zelokkv4.png" alt="Die durchschnittliche absolute Abweichung benachbarter Bilder"></p><br><p>  Kleine Schwankungen am Anfang sind normal.  Bis zum 232. läuft alles gut, die Bilder sind völlig identisch.  Und der 233. unterscheidet sich plötzlich um durchschnittlich 1,23 für jedes Pixel (auf einer Skala von 0 bis 255).  Das ist viel.  Vielleicht haben sich die Quantisierungstabellen gerade geändert.  Schau es dir an.  Gleichzeitig ist es mit der Größe der empfangenen Dateien vergleichbar. </p><br><p><img src="https://habrastorage.org/webt/xb/cg/qo/xbcgqoo2ifxqgr8c2gtusw64kgm.png" alt="Qualitätsänderungen"></p><br><p>  Ja, die Tabellen haben sich geändert.  Aber nicht früher als in den 700ern.  Dann trat möglicherweise eine versteckte Zwischen-Transcodierung mit geringer Qualität auf.  Versuchen wir, den 232. zweimal neu zu codieren.  Zum ersten Mal werden wir verschiedene Qualitätsstufen durchlaufen, und zum zweiten Mal verwenden wir dieselbe Quantisierungstabelle wie für alle vom 1. bis zum 700er.  Unser Ziel ist es, das Bild so ähnlich wie möglich zum 233. zu machen.  In der folgenden Abbildung ist entlang der x-Achse die Qualität der Zwischentranscodierung angegeben, entlang y ist die durchschnittliche absolute Abweichung von der 233 .. </p><br><p><img src="https://habrastorage.org/webt/sg/6o/ax/sg6oaxjxeqk75kwsantwy2gncbu.png" alt="Versteckte Transcodierung hinzufügen"></p><br><p>  Es gibt zwar einen Fehler im Diagramm mit einer Qualität von 75%, ungefähr gleich 1, aber immer noch weit von der gewünschten Null entfernt.  Das Hinzufügen der 2. Zwischenstufe und das Ändern der Parameter der Unterabtastung verbesserte die Situation nicht. </p><br><p>  Bei den restlichen Bildern ist alles ungefähr gleich, und die Änderung in den Quantisierungstabellen wird ebenfalls überlagert.  Das heißt, irgendwann ändert sich das Bild dramatisch, dann stabilisiert es sich in wenigen Tagen, aber nur bis ein neuer Anstieg auftritt.  Möglicherweise ändert sich das Image selbst auf den Servern.  Ich kann die Beteiligung des Gruppenadministrators nicht vollständig ausschließen. </p><br><p>  Leider habe ich nicht herausgefunden, was wirklich mit dem Bild passiert ist.  Zumindest bin ich mir jetzt sicher, dass es nicht nur eine Erhaltung war.  Vor allem aber wurde es besser, die laufenden Prozesse während des Codierens und Decodierens darzustellen.  Hoffe du auch. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Archiv mit Bildern</a> für unabhängige Recherchen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473544/">https://habr.com/ru/post/de473544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473516/index.html">Schreiben eines Microservice-Blogs - Teil 2 von API Gateway</a></li>
<li><a href="../de473528/index.html">Eine Stadt ohne Staus</a></li>
<li><a href="../de473530/index.html">Einführung in das Ausnutzen und Umkehren (nicht von Grund auf neu) mit IDA FREE und anderen kostenlosen Tools</a></li>
<li><a href="../de473532/index.html">Was ist die Gefahr von Hackerangriffen auf IoT-Geräte: echte Geschichten</a></li>
<li><a href="../de473534/index.html">Automatisieren Sie Änderungen an OEM-Informationen</a></li>
<li><a href="../de473546/index.html">Anwendung auf TSD und Kommunikation mit 1C: Enterprise 8.3 über HTTP-Service. Teil 2 (API-Implementierung auf der 1C-Seite)</a></li>
<li><a href="../de473548/index.html">PKI-Dezentralisierung: Vorgeschlagene Ansätze zur Verbesserung der Sicherheit</a></li>
<li><a href="../de473550/index.html">Joker 2019: Triumph des Jahres</a></li>
<li><a href="../de473552/index.html">Deanonymisierung durch Clickjacking im Jahr 2019</a></li>
<li><a href="../de473560/index.html">Erstellen einer REST-API mit Node.js und einer Oracle-Datenbank. Teil 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>