<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💥 🗓️ 👨🏿‍🤝‍👨🏻 ORM: pourquoi cette tâche n'a pas de solution, mais pour y faire face, néanmoins, quelque chose doit être 🎅🏼 👩‍🏭 ↖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les technologies de l'information modernes étonnent par leur puissance, elles sont dépassées par les opportunités qui s'ouvrent, elles sont découragée...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ORM: pourquoi cette tâche n'a pas de solution, mais pour y faire face, néanmoins, quelque chose doit être</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458286/"><img src="https://habrastorage.org/webt/ih/bm/-r/ihbm-rqpvgk6lhwhg43njjt3i3c.jpeg"><br><br>  Les technologies de l'information modernes étonnent par leur puissance, elles sont dépassées par les opportunités qui s'ouvrent, elles sont découragées par la perfection technique qui leur est inhérente, mais il y a un point ridicule sur lequel l'informatique se casse les dents encore et encore.  Afficher les données utilisateur de la base de données, obtenir des informations de sa part, les replacer dans la base de données, afficher le résultat.  Champs de saisie, boutons, coches, inscriptions - il semblerait qu'ils puissent être tellement prohibitifs d'exiger des constructions déroutantes comme des cadres au-dessus des moteurs de modèles au-dessus des cadres au-dessus des transpilateurs?  Et pourquoi, malgré tous les efforts énormes, nous avons le fait que les exemples de jouets dans le tutoriel, bien sûr, sont fabriqués facilement et agréablement, mais dès que la boîte à outils rencontre les vrais problèmes de la vie réelle ... comment dire plus doucement ... avec une complexité croissante des tâches à résoudre, il y a une forte non-linéarité d'augmentation difficultés de mise en œuvre.  Eh bien, il s'agirait de quelque chose de vraiment déroutant au niveau de la physique théorique ou de la technologie spatiale, car il n'y en a pas de toute façon - des boutons et des coches.  Pourquoi cette absurdité continue-t-elle d'empoisonner la vie des citoyens et des collectifs de travail pendant des décennies? <br><br>  Les raisons, probablement, comme toujours, sont nombreuses.  Ils méritent probablement tous d'être pris en considération d'une manière ou d'une autre, mais ici et maintenant, nous parlerons de la tâche ORM (Object-Relational Mapping), qui se trouve toujours derrière certains de ces «boutons et coches» sous une forme ou une autre. <br><a name="habracut"></a><br><h4>  Que savons-nous de l'ORM </h4><br><ol><li>  Stocker des données dans des tables relationnelles ne veut pas dire que c'est une question très simple, mais en général, l'idée et les modalités de son application sont assez claires et bien étudiées. </li><li>  Avec la programmation d'objets, tout n'est pas si bon (il y a plusieurs approches concurrentes), mais en général, avec la mise en œuvre et l'application des technologies, tout est aussi plus ou moins clair. </li><li>  À la fois cela et un autre - sur les données, leur stockage et leur traitement.  C'est en fait à peu près la même chose. </li><li>  Il nous semble logique qu'il devrait y avoir un pont simple, compréhensible, pratique, prévisible et universel entre les deux mondes. </li><li>  Et chaque fois que nous trouvons ce pont facilement, mais le malheur, sa simplicité, sa compréhensibilité, sa commodité, sa prévisibilité et son universalité ne fonctionnent pas au-delà de simples exemples tirés de tutoriels. </li><li>  Tout le monde souffre: les développeurs, qui doivent faire beaucoup de travail extrêmement ennuyeux, et les utilisateurs qui doivent se battre avec des logiciels maladroits, et l'entreprise, dont la réalisation des besoins s'avère soudainement insupportablement longue et coûteuse, et l'industrie dans son ensemble. </li><li>  J'ai vu de nombreux ORM différents, mais je n'en ai pas vu de bons.  Autrement dit, celui qui, au-delà des simples exemples, ne se transforme pas en fardeau et en lit procrustéen. </li></ol><br><h4>  Pourquoi tout est-il si bizarre </h4><br>  La base idéologique de la théorie et de la pratique des bases de données relationnelles est le calcul des prédicats, c'est-à-dire une branche des mathématiques.  Quant à la POO, une base idéologique similaire y fait défaut.  On peut essayer de formuler l'idée de base de la POO comme ceci: puisque le monde est constitué d'objets, il serait commode de le modéliser, ce monde, en créant des objets à l'intérieur d'un système logiciel.  En ce sens, deux erreurs à la fois.  Premièrement, le monde lui-même ne consiste pas et n'a jamais été constitué d'objets.  Deuxièmement, je suis désolé, mais pourquoi le programme doit-il simuler le monde?  Autrement dit, nous avons une déclaration conceptuellement incorrecte, parfaitement complétée par une déclaration dénuée de sens du problème. <br><br>  Tout ORM est une tentative d'étirer clairement la correspondance unifiée entre, en fait, la branche des mathématiques et un ensemble vague de pratiques diverses, basées sur des considérations de commodité, des approches historiquement établies, et aussi souvent sur des légendes, des opinions des autorités et simplement des idées fausses.  In vitro, il peut être fait pour fonctionner, mais in vivo, il est voué à paraître pathétique et à apporter plus de chagrin que de joie. <br><br><h4>  Sur l'inévitabilité de l'orientation des objets </h4><br>  Néanmoins, la nécessité de l'orientation objet de notre logiciel est notre réalité inévitable.  Cette inévitabilité est basée principalement sur le fait que fonctionner avec des objets est l'essence et le fondement de l'une de nos activités.  Le monde lui-même ne se compose pas d'objets, mais pour comprendre quelque chose dans ce monde et faire quelque chose avec ce monde, nous déclarons nous-mêmes ses parties en tant qu'objets, les appelons des noms, essayons de comprendre leur comportement, appliquons à lui s'efforce d'obtenir les résultats souhaités.  C'est notre façon de fonctionner, il est impossible de la quitter et ce n'est pas nécessaire.  Tout est objet, non pas parce qu'il l'est vraiment, mais parce que nous ne pouvons pas faire autrement.  Ce qui ne peut en aucun cas être un objet se situe complètement en dehors des limites de notre capacité à comprendre et ne peut pas faire l'objet de nos efforts. <br><br>  Même si le programme est écrit sans utiliser de techniques OOP, il contient inévitablement des objets (au sens large du terme), en manipulant ce que le développeur résout son problème - variables, types de données, opérateurs, algorithmes, constructions syntaxiques, fonctions, modules.  Du point de vue de l'utilisateur, le programme dispose également d'un ensemble d'objets avec lesquels il interagit - boutons, étiquettes, champs de saisie, pages, sites et l'ensemble du système. <br><br><h4>  Ce que nous stockons dans nos bases de données </h4><br>  Comme mentionné ci-dessus, les bases de données relationnelles sont basées sur le calcul des prédicats.  Un prédicat est un fait formulé et, dans notre cas, stocké sur un support.  Juste au cas où, je note que la base de données relationnelle n'est pas seulement et pas tellement sur les relations entre les tables par des clés étrangères.  Dans la terminologie appropriée, les relations sont ce que nous appelons simplement des tables.  Autrement dit, même si votre base de données n'a qu'une seule table avec deux colonnes (par exemple, le nom et le numéro de téléphone), vous disposez déjà d'une base de données relationnelle qui établit la relation entre deux ensembles, dans ce cas, des ensembles de noms et de numéros de téléphone.  <i>Une base de données relationnelle ne stocke pas d'objets, elle stocke des faits.</i>  Les faits stockés, bien sûr, ont un objet («de quoi s'agit-il?»), Et lorsque nous essayons d'apprendre au système à répondre à cette question, nous avons des entités, c'est-à-dire des objets auxquels des faits sont associés.  Si vous travaillez correctement, la structure de notre base est née d'une série de réponses à la question «quel genre de faits avons-nous l'intention de garder?», Et ce n'est qu'à l'étape suivante que nous obtenons quelque chose qui ressemble à des objets qui donnent des faits à l'objectivité.  Vous pouvez, bien sûr, concevoir «à partir d'objets», mais je ne recommanderais pas de le faire, sauf dans les travaux de laboratoire sur des sujets qui ne sont pas directement liés à la conception de bases de données.  Le danger de lourdes erreurs architecturales est trop grand.  De plus, c'est au moins gênant. <br><br>  <b>Une petite digression sur les bases de données d'objets.</b>  Une pensée très simple: si nous sommes fatigués des problèmes d'ORM, alors peut-être devrions-nous faire quelque chose avec la partie qui est "R"?  Que notre base de données ne soit pas un monstre relationnel difficile et exigeant, mais quelque chose de jeune à la mode spécialement conçu pour stocker des objets.  Une sorte de base NoSQL schématique, par exemple.  Mais au final, il s'avère soudain que les ORM de type NoSQL sont encore plus maladroits et contre nature que les bons vieux SQL.  Quoi qu'il en soit, nous pouvons avoir et utiliser avec plaisir un SGBD sans circuit, mais il n'y a pas de données sans circuit dans la nature.  Il n'y a rien de plus impuissant, irresponsable et immoral que l'ORM pour les bases de données sans circuit. <br><br><h4>  Bon ORM </h4><br>  Un bon ORM est l'ORM manquant.  Eh bien, sérieusement.  Regardez l'un de vos systèmes ORM et essayez honnêtement de répondre à votre question: quels sont les avantages de ce monstre?  Quelle est la raison de son utilisation, sauf pour les promesses de bonheur non tenues et les préjugés discrédités à plusieurs reprises?  Bien sûr, il y a des choses utiles, mais quelles sont-elles dans le contexte des déformations architecturales introduites et des problèmes de performance qui surgissent constamment à l'improviste? <br><br>  En règle générale, l'API de base de données «bas niveau» est simple, pratique, complète et cohérente.  Habituellement, suffisamment de doigts pour répertorier toutes les fonctionnalités.  Les apprendre n'est pas une nouvelle divine quelle tâche. <br><br>  Je vais essayer d'esquisser un ensemble de principes architecturaux qui vous permettent de mapper des objets à une base de données sans utiliser ORM: <br><br><ol><li>  <i>Nous stockons les faits, opérons sur des objets.</i>  N'oubliez pas que la base de données stocke des faits et que les modèles d'objets impliqués dans le traitement des données sont des projections d'ensembles de faits de différents points de vue.  Par exemple, pour l'exemple donné avec les noms et les numéros de téléphone, nous pouvons avoir la classe Abonent, pour laquelle plusieurs numéros peuvent être stockés, et aussi la classe PhoneNumber, pour laquelle plusieurs abonnés peuvent être définis (n'oubliez pas qu'en plus des numéros de mobile personnels, nous avons où il y a encore des téléphones d'appartement et de bureau).  Et la table dans la base de données est juste celle qui définit la relation plusieurs-à-plusieurs entre plusieurs noms et numéros de téléphone.  Juste deux projections différentes.  Cette approche, soit dit en passant, évolue normalement vers des cas beaucoup plus complexes, vous permettant d'avoir des classes utiles dans le système comme, par exemple, "les ventes moyennes pour une période donnée selon une combinaison donnée de critères". </li><li>  <i>Les faits sont projetés dans des objets et vice versa via une API orientée problème.</i>  Sans appliquer une solution qui se veut universelle.  Si vous ne savez toujours pas comment composer des API pratiques, découvrez comment.  Et surtout, apprenez-vous à les documenter immédiatement. </li><li>  <i>Commandez avant tout.</i>  Si vous utilisez la version classique d'un SGBD avec un schéma de données rigide, ce schéma en lui-même met de l'ordre dans le travail avec les données.  La structure supplémentaire codée par la structure des objets est simplement redondante.  Si vous utilisez un SGBD sans schéma, vous devrez bien sûr faire quelques efforts pour vous assurer que votre base de données ne se transforme pas en une montagne d'ordures car les différents développeurs ont des idées différentes sur ce qui est stocké. </li><li>  <i>Indépendance du SGBD (si nécessaire).</i>  Si la propriété d'ORM la plus intéressante pour vous est l'indépendance du SGBD, utilisez des outils spéciaux tels que ODBC, JDBC, ADO, ou si cela n'est pas possible, créez votre propre niveau d'abstraction.  Ce n'est pas aussi difficile que cela puisse paraître au premier abord.  Vous n'avez pas besoin de support pour absolument toutes les capacités de absolument tous les SGBD pour votre tâche, non? </li><li>  <i>N'oubliez pas les aspects supplémentaires de l'utilisation des données.</i>  Tels que, par exemple, le partage de l'accès aux données (qui peuvent être arbitrairement complexes), la surveillance, la réplication, etc.  Mais ici, j'ai de bonnes nouvelles pour vous: parce que dans votre ORM préféré, l'ajout.  l'aspect est toujours mis en œuvre selon le principe «vous ne plairez pas à tout le monde, mangez ce que vous donnez», le rejet d'un service douteux avec lequel vous devez faire plus que coopérer s'avérera finalement être une décision stratégiquement correcte. </li></ol><br><h4>  Total </h4><br>  L'ORM est un sujet très sensible pour notre industrie.  À une époque où l'intelligence artificielle du cloud laboure la blockchain quantique, la grande majorité de la main-d'œuvre est occupée à visser la logique métier et une interface utilisateur aux bases de données.  Des millions de lignes de code terrible, clouées avec des microscopes, la douleur et le désespoir accompagnent partout ce processus créatif.  L'une des racines de cette triste situation est l'idée fausse extrêmement persistante qu'un ORM universel est en principe possible.  Mais c'est impossible, et il y a une raison fondamentale à cela, qui ne peut être éliminée.  La prise de conscience de ce fait est la première étape vers la sortie de ce cauchemar.  Il existe un moyen de sortir, il existe des alternatives, mais vous devez d'abord vous rendre compte, ressentir et apprendre à garder le focus de l'attention. <br><br>  PS Je m'excuse sincèrement auprès des frères de la profession qui ont investi beaucoup de temps et d'efforts dans la création de nombreux meilleurs universels dans le monde de l'ORM.  Je suis vraiment désolée. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458286/">https://habr.com/ru/post/fr458286/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458272/index.html">Ça alors! pour les voyageurs - l'histoire d'un projet de maison</a></li>
<li><a href="../fr458276/index.html">La première simulation de l'Univers basée sur l'IA a été développée. Un réseau de neurones fait si bien son travail que c'est même bizarre</a></li>
<li><a href="../fr458278/index.html">Comment les pirates utilisent Microsoft Excel contre lui-même</a></li>
<li><a href="../fr458280/index.html">Un autre pas vers la fin de la loi de Moore</a></li>
<li><a href="../fr458282/index.html">Avant Netscape: les navigateurs Web oubliés du début des années 1990</a></li>
<li><a href="../fr458288/index.html">Anton Belichkov: «La façon la plus simple de comprendre la puissance d'OpenStreetMap est de commencer à éditer la carte vous-même»</a></li>
<li><a href="../fr458290/index.html">Ordinateur biosynthétique à double cœur dans une cellule vivante</a></li>
<li><a href="../fr458292/index.html">PHP Digest n ° 159 (17 juin - 1er juillet 2019)</a></li>
<li><a href="../fr458298/index.html">Fabriqué un grand demi-engrenage sur des panneaux solaires pour 250 000 roubles (2 parties)</a></li>
<li><a href="../fr458300/index.html">Evolution de l'outil le plus populaire de chaque développeur (dans Visual Studio)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>