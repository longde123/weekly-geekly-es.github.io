<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏑 ✔️ 👩‍🌾 Parsing Wawancara Kerja Google: Menemukan Hubungan 👩🏼‍🍳 💍 🧖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat datang di artikel berikutnya dalam serangkaian teka-teki yang saya tanyakan di wawancara Google sebelum mereka dilarang setelah kebocoran. Sej...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parsing Wawancara Kerja Google: Menemukan Hubungan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467371/"><img src="https://habrastorage.org/getpro/habr/post_images/915/39d/3b3/91539d3b3be71056861dc65e18921c88.png"><br><br>  Selamat datang di artikel berikutnya dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian</a> teka-teki yang saya tanyakan di wawancara Google sebelum mereka dilarang setelah kebocoran.  Sejak itu, saya berhenti bekerja sebagai insinyur perangkat lunak di Google dan pindah ke posisi manajer pengembangan di Reddit, tetapi saya masih memiliki beberapa topik hebat.  Sampai saat ini, kami telah memeriksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman dinamis</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meningkatkan matriks ke kekuatan</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sinonim dari pertanyaan</a> .  Kali ini pertanyaan yang sama sekali baru. <br><a name="habracut"></a><br>  Tapi pertama, dua poin.  Pertama, pekerjaan di Reddit luar biasa.  Selama delapan bulan terakhir, saya telah membangun dan memimpin tim Relevansi Iklan baru dan mendirikan kantor pengembangan baru di New York.  Tidak peduli betapa menyenangkannya itu, sayangnya, saya menemukan bahwa sampai saat ini saya tidak punya waktu atau tenaga untuk blog.  Saya takut bahwa saya meninggalkan seri ini sedikit.  Maaf atas keterlambatannya. <br><br>  Kedua, jika Anda mengikuti artikel, maka setelah masalah terakhir Anda mungkin berpikir bahwa saya akan mulai menggali opsi sinonim dari pertanyaan.  Meskipun saya ingin kembali ke suatu saat, saya harus mengakui bahwa saya kehilangan minat karena masalah ini karena perubahan pekerjaan dan sejauh ini saya memutuskan untuk menundanya.  Namun, tetap terhubung!  Saya berutang pada saya, dan saya bermaksud mengembalikannya.  Hanya, Anda tahu, sedikit kemudian ... <br><br>  <i>Penafian cepat: Meskipun mewawancarai kandidat adalah salah satu tugas profesional saya, blog ini menyajikan pengamatan pribadi saya, kisah pribadi, dan pendapat pribadi.</i>  <i>Tolong jangan mengambil ini untuk pernyataan resmi dari Google, Alfabet, Reddit atau orang atau organisasi lain.</i> <br><br><h2>  Cari pertanyaan baru </h2><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> saya menggambarkan salah satu pertanyaan favorit saya yang saya gunakan sejak lama, sebelum kebocoran yang tak terhindarkan.  Pertanyaan-pertanyaan sebelumnya menarik dari sudut pandang teoretis, tetapi saya ingin memilih masalah yang sedikit lebih relevan bagi Google sebagai sebuah perusahaan.  Ketika pertanyaan ini dilarang, saya ingin mencari penggantinya, dengan mempertimbangkan batasan baru: untuk membuat pertanyaan <i>lebih sederhana</i> . <br><br>  Sekarang ini mungkin tampak sedikit mengejutkan mengingat proses wawancara yang terkenal di Google.  Tetapi pada saat itu masalah yang lebih sederhana masuk akal.  Alasan saya terdiri dari dua bagian.  Yang pertama adalah pragmatis: para kandidat biasanya tidak dapat mengatasi dengan baik pertanyaan-pertanyaan sebelumnya, meskipun ada banyak petunjuk dan penyederhanaan, dan saya tidak selalu sepenuhnya yakin mengapa.  Yang teoretis kedua: proses wawancara harus membagi kandidat ke dalam kategori "layak merekrut" dan "tidak layak merekrut", dan saya ingin tahu apakah ini bisa dilakukan sedikit lebih mudah dengan pertanyaan. <br><br>  Sebelum mengklarifikasi dua poin ini, saya ingin menunjukkan apa yang <i>tidak</i> mereka maksudkan.  "Saya tidak selalu yakin mengapa seseorang memiliki masalah" tidak berarti ketidakbergunaan pertanyaan dan saya ingin menyederhanakan wawancara karena alasan ini.  Bahkan pertanyaan yang paling sulit, banyak diatasi dengan baik.  Maksud saya, ketika kandidat memiliki masalah, sulit bagi saya untuk memahami apa yang mereka lewatkan. <br><br>  Wawancara yang baik memberikan gambaran luas tentang kekuatan dan kelemahan kandidat.  Tidak cukup bagi komite perekrutan untuk sekadar mengatakan bahwa itu “gagal”: komite menentukan apakah kandidat memiliki kualitas khusus perusahaan yang mereka cari.  Demikian pula, kata-kata "dia keren" tidak membantu panitia memutuskan seorang kandidat yang kuat di beberapa bidang, tetapi ragu-ragu di bidang lain.  Saya telah menemukan bahwa masalah yang lebih kompleks terlalu sering memisahkan kandidat ke dalam dua kategori ini.  Dalam hal ini, "Saya tidak selalu yakin mengapa seseorang memiliki masalah" berarti "ketidakmampuan untuk maju tentang masalah ini tidak dengan sendirinya melukiskan gambaran kemampuan kandidat ini." <br><br>  Klasifikasi kandidat sebagai "layak merekrut" dan "tidak layak merekrut" <i>tidak</i> berarti bahwa proses wawancara harus memisahkan kandidat bodoh dari yang pintar.  Saya tidak dapat mengingat satu calon pun yang tidak cerdas, berbakat, dan tidak termotivasi.  Banyak yang datang dari universitas-universitas terbaik, dan sisanya jelas sangat termotivasi.  Melewati wawancara telepon sudah menjadi saringan yang bagus, dan bahkan menolak pada tahap ini bukanlah pertanda kurangnya kemampuan. <br><br>  Namun, saya <i>dapat</i> mengingat banyak orang yang tidak cukup siap untuk wawancara atau bekerja terlalu lambat, atau membutuhkan terlalu banyak pengawasan untuk menyelesaikan masalah, atau dikomunikasikan dengan cara yang tidak jelas, atau tidak dapat menerjemahkan ide-ide mereka ke dalam kode, atau memegang posisi yang tidak akan memimpin Keberhasilannya dalam jangka panjang, dll. Definisi “layak merekrut” tidak jelas dan bervariasi tergantung pada perusahaan, dan proses wawancara adalah untuk menentukan apakah setiap kandidat memenuhi persyaratan perusahaan tertentu. <br><br>  Saya membaca banyak komentar reddit mengeluh tentang pertanyaan wawancara yang terlalu kompleks.  Saya ingin tahu apakah masih mungkin untuk membuat rekomendasi yang layak / tidak layak untuk tugas yang lebih sederhana.  Saya curiga ini akan memberikan sinyal yang berguna tanpa perlu berteriak dengan gugup.  Saya akan memberi tahu Anda tentang kesimpulan saya di akhir artikel ... <br><br>  Dengan pemikiran ini, saya mencari pertanyaan baru.  Di dunia yang ideal, ini adalah pertanyaan yang cukup sederhana untuk diselesaikan dalam 45 menit, tetapi dengan pertanyaan tambahan sehingga kandidat yang lebih kuat menunjukkan keterampilan mereka.  Ini juga harus ringkas dalam implementasi, karena banyak kandidat masih menulis di papan tulis.  Nilai tambah besar jika topik tersebut terkait dengan produk Google. <br><br>  Akhirnya, saya memutuskan sebuah pertanyaan yang dijelaskan dan dimasukkan oleh beberapa orang yang luar biasa ke dalam basis data pertanyaan kami.  Sekarang saya telah berkonsultasi dengan mantan rekan kerja dan memastikan bahwa pertanyaannya masih dilarang, jadi Anda pasti tidak akan ditanyai saat wawancara.  Saya menyajikannya dalam bentuk yang menurut saya paling efektif, dengan permintaan maaf kepada penulis asli. <br><br><h2>  Pertanyaan </h2><br>  Bicara tentang mengukur jarak.  <i>Hand</i> adalah satuan ukuran empat inci yang biasa digunakan di negara-negara berbahasa Inggris untuk mengukur ketinggian kuda.  <i>Tahun cahaya</i> adalah satuan pengukuran lain yang sama dengan jarak yang ditempuh partikel (atau gelombang?) Cahaya dalam jumlah detik tertentu, kira-kira sama dengan satu tahun bumi.  Pada pandangan pertama, mereka memiliki sedikit kesamaan satu sama lain, kecuali bahwa mereka digunakan untuk mengukur jarak.  Tetapi ternyata Google dapat mengonversinya dengan mudah: <br><br><img src="https://habrastorage.org/webt/uu/8z/y-/uu8zy-po4rpuvr61dtewmyhjns0.png"><br><br>  Ini mungkin tampak jelas: pada akhirnya, keduanya mengukur jarak, jadi jelas bahwa ada transformasi.  Tetapi jika Anda memikirkannya, ini agak aneh: bagaimana mereka menghitung tingkat konversi ini?  Jelas, tidak ada yang benar-benar menghitung jumlah tangan dalam satu tahun yang cerah.  Sebenarnya, Anda tidak perlu mengambil ini secara langsung.  Anda cukup menggunakan konversi terkenal: <br><br><ul><li>  <i>1 tangan</i> = <i>4 inci</i> <br></li><li>  <i>4 inci</i> = <i>0,33333 kaki</i> <br></li><li>  <i>0,33333 kaki</i> = <i>6,3125e - 5 mil</i> <br></li><li>  <i>6.3125e - 5 miles</i> = <i>1.0737e - 17 tahun cahaya</i> </li></ul><br>  Tujuan dari tugas ini adalah untuk mengembangkan sistem yang akan melakukan transformasi ini.  Khususnya: <br><br><blockquote>  Pada input Anda memiliki daftar faktor konversi (diformat dalam bahasa pilihan Anda) dalam bentuk seperangkat unit pengukuran awal, unit akhir dan faktor, misalnya: <br><br><pre>  ft 12
 yard kaki 0,3333333
 dll. </pre><br>  Sehingga ORIGIN * MULTIPLIER = DESTINATION.  Kembangkan algoritme yang mengambil dua nilai unit acak dan mengembalikan faktor konversi di antaranya. </blockquote><br><h2>  Diskusi </h2><br>  Saya suka masalah ini karena memiliki jawaban yang intuitif dan jelas: cukup konversi dari satu unit ke unit lain, lalu ke unit berikutnya, hingga Anda menemukan target!  Saya tidak dapat mengingat satu calon pun yang mengalami masalah ini dan benar-benar bingung bagaimana menyelesaikannya.  Ini cocok dengan persyaratan masalah yang “lebih sederhana”, karena yang sebelumnya biasanya membutuhkan studi dan refleksi yang panjang sebelum setidaknya ditemukan pendekatan dasar untuk solusi. <br><br>  Namun demikian, banyak kandidat gagal menyadari intuisi mereka sebagai solusi yang berhasil tanpa petunjuk yang jelas.  Salah satu keuntungan dari pertanyaan ini adalah ia menguji kemampuan kandidat untuk merumuskan masalah (untuk membuat pembingkaian) sehingga cocok untuk dianalisis dan dikodekan.  Seperti yang akan kita lihat, ada satu ekstensi yang sangat menarik di sini yang membutuhkan lompatan konseptual baru. <br><br>  Untuk konteks, pembingkaian adalah tindakan menerjemahkan masalah dengan solusi yang tidak jelas ke dalam masalah yang setara, di mana solusi disimpulkan dengan cara yang alami.  Jika ini kedengarannya benar-benar abstrak dan tidak bisa ditembus, saya minta maaf, tapi itu benar.  Saya akan menjelaskan apa yang saya maksud ketika saya menyajikan solusi awal untuk masalah ini.  Bagian pertama dari solusi akan menjadi latihan dalam mengembangkan dan menerapkan pengetahuan algoritmik.  Bagian kedua akan menjadi latihan dalam memanipulasi pengetahuan ini untuk sampai pada optimasi baru dan tidak jelas. <br><br><h2>  Bagian 0. Intuisi </h2><br>  Sebelum menggali lebih dalam, mari kita sepenuhnya mengeksplorasi solusi "jelas".  Sebagian besar konversi yang diperlukan sederhana dan mudah.  Setiap orang Amerika yang telah bepergian ke luar Amerika Serikat tahu bahwa sebagian besar dunia menggunakan unit "kilometer" misterius untuk mengukur jarak.  Untuk mengkonversi, Anda hanya perlu mengalikan jumlah mil dengan sekitar 1,6. <br><br>  Kami telah menemukan hal-hal seperti itu hampir sepanjang hidup kami.  Untuk sebagian besar unit, sudah ada konversi yang dihitung sebelumnya, jadi Anda hanya perlu melihatnya di tabel yang sesuai.  Tetapi jika tidak ada konversi langsung (misalnya, dari tahun tangan ke tahun), masuk akal untuk membangun jalur konversi, seperti ditunjukkan di atas: <br><br><ul><li>  <i>1 tangan</i> = <i>4 inci</i> <br></li><li>  <i>4 inci</i> = <i>0,33333 kaki</i> <br></li><li>  <i>0,33333 kaki</i> = <i>6,3125e - 5 mil</i> <br></li><li>  <i>6.3125e - 5 miles</i> = <i>1.0737e - 17 tahun cahaya</i> </li></ul><br>  Itu sangat sederhana, saya baru saja datang dengan transformasi seperti itu menggunakan imajinasi saya dan tabel transformasi standar!  Namun, masih ada beberapa pertanyaan.  Apakah ada cara yang lebih pendek?  Seberapa akurat koefisien tersebut?  Apakah konversi selalu mungkin?  Apakah mungkin mengotomatiskannya?  Sayangnya, di sini pendekatan naif rusak. <br><br><h2>  Bagian 1. Keputusan naif </h2><br>  Sangat menyenangkan bahwa masalah memiliki solusi intuitif, tetapi pada kenyataannya, kesederhanaan ini merupakan hambatan untuk menyelesaikan masalah.  Tidak ada yang lebih sulit daripada mencoba memahami dengan cara baru apa yang sudah Anda pahami - paling tidak karena Anda sering tahu lebih sedikit dari yang Anda pikirkan.  Sebagai ilustrasi, bayangkan Anda datang untuk wawancara - dan Anda memiliki metode intuitif ini di kepala Anda.  Namun dia tidak mengizinkan untuk memecahkan sejumlah masalah penting. <br><br>  Misalnya, bagaimana jika <i>tidak ada konversi</i> ?  Pendekatan yang jelas tidak mengatakan apa-apa, apakah benar-benar mungkin untuk mengkonversi dari satu unit ke unit lainnya.  Jika mereka memberi saya seribu tingkat konversi, akan sangat sulit bagi saya untuk menentukan apakah mungkin secara prinsip.  Jika saya diminta melakukan konversi antara unit <i>pointer</i> dan <i>jab yang</i> tidak dikenal, maka saya tidak tahu harus mulai dari mana.  Bagaimana pendekatan intuitif membantu di sini? <br><br>  Saya harus mengakui bahwa ini adalah semacam skenario yang dibuat-buat, tetapi ada juga yang lebih realistis.  Anda melihat bahwa pernyataan saya tentang masalah hanya mencakup satuan jarak.  Ini dilakukan dengan sengaja.  Bagaimana jika saya meminta sistem untuk mengubah dari inci ke kilogram?  Anda dan saya tahu bahwa ini tidak mungkin karena mereka mengukur tipe yang berbeda, tetapi input tidak mengatakan apa pun tentang “tipe” yang diukur masing-masing unit. <br><br>  Di sinilah perumusan pertanyaan yang cermat memungkinkan kandidat kuat untuk membuktikan diri.  <i>Sebelum</i> mengembangkan algoritma, mereka memikirkan kasus-kasus ekstrim dari sistem.  Dan pernyataan masalah seperti itu dengan sengaja memberi mereka kesempatan untuk bertanya kepada saya apakah kami akan menerjemahkan unit yang berbeda.  Ini bukan masalah besar jika terjadi pada tahap awal, tetapi selalu merupakan pertanda baik ketika seseorang bertanya kepada saya di muka: "Apa yang harus dikembalikan oleh program jika konversi tidak memungkinkan?"  Mengajukan pertanyaan seperti ini memberi saya gambaran tentang kemampuan kandidat sebelum ia menulis setidaknya satu baris kode. <br><br>  <i>Tampilan grafik</i> <br><br>  Jelas, pendekatan naif tidak cocok, jadi kita perlu berpikir tentang bagaimana melakukan konversi seperti itu?  Jawabannya adalah untuk mempertimbangkan satuan sebagai grafik.  Ini adalah lompatan pemahaman pertama yang dibutuhkan untuk menyelesaikan masalah ini. <br><br>  Secara khusus, bayangkan bahwa setiap unit adalah simpul dalam grafik, dan ada tepi dari simpul <code>A</code> ke simpul <code>B</code> jika <code>A</code> dapat dikonversi ke <code>B</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc6/d25/89f/fc6d2589f8a9a411cec0d704e2ad644e.png"><br><br>  Tepi-tepian ditandai dengan tingkat konversi yang dengannya Anda harus mengalikan <code>A</code> untuk mendapatkan <code>B</code> <br><br>  Saya hampir selalu mengharapkan kandidat untuk membuat framing seperti itu, dan jarang memberi petunjuk serius kepadanya.  Saya bisa memaafkan kandidat yang tidak melihat solusi untuk masalah menggunakan set disjoint atau tidak terlalu akrab dengan aljabar linier untuk mewujudkan solusi yang mengurangi untuk kembali ke kekuatan matriks kedekatan, tetapi grafik diajarkan pada kurikulum atau kursus pemrograman.  Jika kandidat tidak memiliki pengetahuan yang sesuai, ini adalah sinyal “tidak ada perekrutan”. <br><br>  <i>Bagaimanapun</i> <br><br>  Representasi grafik mengurangi solusi untuk masalah pencarian grafik klasik.  Secara khusus, dua algoritma berguna di sini: pencarian lebar (BFS) dan pencarian dalam (DFS).  Saat mencari lebar, kami memeriksa node sesuai dengan jaraknya dari titik asal: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d45/4cb/15b/d454cb15b85c4ea9ce32e87623ed4115.png"><br>  <i><font color="gray">Blues yang lebih gelap berarti generasi selanjutnya</font></i> <br><br>  Dan ketika mencari secara mendalam, kami memeriksa node sesuai urutan terjadinya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/f4c/f1a/40bf4cf1ae3d89554505c031c4529559.png"><br><br>  <i><font color="gray">Blues yang lebih gelap juga berarti generasi selanjutnya.</font></i>  <i><font color="gray">Harap perhatikan bahwa kami tidak benar-benar mengunjungi semua situs</font></i> <br><br>  Salah satu algoritma dengan mudah menentukan apakah ada konversi dari satu unit ke unit lain, cukup dengan hanya mencari grafik.  Kami mulai dari unit sumber dan mencari sampai kami menemukan unit tujuan.  Jika Anda tidak dapat menemukan tujuan Anda (seolah-olah mencoba mengonversi inci menjadi kilogram), kami tahu bahwa tidak ada cara. <br><br>  Tapi tunggu, ada yang hilang.  Kami tidak ingin mencari cara, kami ingin menemukan tingkat konversi!  Di sinilah kandidat harus melakukan lompatan: ternyata Anda dapat memodifikasi algoritma pencarian apa pun untuk menghitung tingkat konversi hanya dengan menyimpan status tambahan saat Anda maju.  Di situlah ilustrasi tidak lagi masuk akal, jadi mari selami kode itu. <br><br>  Pertama, Anda perlu menentukan struktur data grafik, jadi kami menggunakan ini: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RateGraph</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, rates)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Initialize the graph from an iterable of (start, end, rate) tuples.'</span></span> self.graph = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> orig, dest, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rates: self.add_conversion(orig, dest, rate) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of the nodes neighboring the given node.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph[node].items() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of all the nodes in the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph.keys()</code> </pre> <br>  Lalu mari kita mulai dari DFS.  Ada banyak cara untuk mengimplementasikannya, tetapi sejauh ini yang paling umum adalah solusi rekursif.  Mari kita mulai dengan ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__dfs_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end, rate_from_origin, visited)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: rate = __dfs_helper(rate_graph, unit, end, rate_from_origin * rate, visited) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __dfs_helper(rate_graph, node, end, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, set())</code> </pre> <br>  Singkatnya, algoritma ini dimulai dengan satu node, iterate atas tetangganya dan segera mengunjungi masing-masing, membuat panggilan rekursif ke fungsi.  Setiap panggilan fungsi pada tumpukan menyimpan status iterasi sendiri, jadi ketika satu kunjungan rekursif dikembalikan, induknya segera melanjutkan iterasi.  Kami menghindari mengunjungi situs yang sama lagi dengan mempertahankan satu set situs yang dikunjungi di semua panggilan.  Kami juga menghitung koefisien dengan menetapkan faktor konversi antara setiap node dan sumber.  Jadi, ketika kita menjumpai node / blok target, kita telah membuat koefisien konversi dari node sumber, dan kita bisa mengembalikannya. <br><br>  Ini adalah implementasi yang bagus, tetapi memiliki dua kelemahan utama.  Pertama, bersifat rekursif.  Jika ternyata jalur yang diinginkan terdiri dari lebih dari seribu lompatan, kita akan terbang dengan kesalahan.  Tentu saja, ini tidak mungkin, tetapi jika ada sesuatu yang tidak dapat diterima untuk layanan jangka panjang, itu adalah kegagalan.  Kedua, bahkan jika kita berhasil menyelesaikannya, jawabannya memiliki beberapa sifat yang tidak diinginkan. <br><br>  Saya sebenarnya sudah memberi petunjuk di awal posting.  Pernahkah Anda memperhatikan bagaimana Google menunjukkan tingkat konversi <code>1.0739e-17</code> , tetapi perhitungan manual saya memberi <code>1.0737e-17</code> ?  Ternyata semua perkalian floating point ini membuat orang sudah berpikir untuk menyebarkan kesalahan.  Ada terlalu banyak nuansa untuk artikel ini, tetapi intinya adalah bahwa Anda perlu meminimalkan perkalian floating point untuk menghindari kesalahan yang menumpuk dan menyebabkan masalah. <br><br>  DFS adalah algoritma pencarian yang bagus.  Jika ada solusi, itu akan menemukannya.  Tetapi dia tidak memiliki properti utama: dia tidak harus menemukan jalan terpendek.  Ini penting bagi kami karena jalur yang lebih pendek berarti lebih sedikit lompatan dan lebih sedikit kesalahan karena perkalian floating point.  Untuk mengatasi masalah, kita beralih ke BFS. <br><br><h2>  Bagian 2. Solusi BFS </h2><br>  Pada tahap ini, jika seorang kandidat berhasil mengimplementasikan solusi DFS rekursif dan berhenti pada itu, saya biasanya memberikan setidaknya rekomendasi yang lemah tentang mempekerjakan kandidat ini.  Dia memahami masalahnya, memilih pembingkaian yang tepat dan menerapkan solusi yang berfungsi.  Ini adalah keputusan yang naif, jadi saya tidak bersikeras mempekerjakannya, tetapi jika dia berhasil dengan baik dengan wawancara lain, saya tidak akan merekomendasikan menolak. <br><br>  Ini layak untuk diulangi: jika ragu, tuliskan solusi naif!  Bahkan jika itu tidak sepenuhnya optimal, keberadaan kode di papan tulis sudah merupakan suatu prestasi, dan seringkali solusi yang tepat dapat ditemukan atas dasar itu.  Saya akan mengatakan berbeda: tidak pernah bekerja untuk apa-apa.  Kemungkinan besar, Anda memikirkan solusi naif, tetapi tidak ingin menawarkannya, karena Anda tahu itu tidak optimal.  Jika Anda siap memberikan solusi terbaik saat ini, itu bagus, tetapi jika tidak, catat kemajuan yang dibuat sebelum beralih ke hal-hal yang lebih kompleks. <br><br>  Mulai sekarang, mari kita bicara tentang peningkatan algoritma.  Kerugian utama dari solusi DFS rekursif adalah bahwa itu adalah rekursif dan tidak meminimalkan jumlah perkalian.  Seperti yang akan segera kita lihat, BFS meminimalkan jumlah perkalian, dan juga sangat sulit untuk mengimplementasikannya secara rekursif.  Sayangnya, kita harus meninggalkan solusi DFA rekursif, karena untuk memperbaikinya kita perlu menulis ulang kode sepenuhnya. <br><br>  Tanpa basa-basi lagi, saya menyajikan pendekatan berulang berdasarkan BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Implementasi ini secara fungsional sangat berbeda dari yang sebelumnya, tetapi jika Anda melihat dari dekat, itu melakukan hal yang sama, dengan satu perubahan signifikan: sementara DFS rekursif menyimpan keadaan rute lebih lanjut dalam panggilan stack, secara efektif mengimplementasikan LIFO stack, solusi berulang menyimpannya dalam antrian FIFO <br><br>  Ini menyiratkan properti "jalur terpendek / jumlah perkalian terkecil".  Kami mengunjungi node dalam urutan di mana mereka terjadi, dan dengan cara ini kami mendapatkan generasi node.  Node pertama menyisipkan tetangganya, dan kemudian kami mengunjungi tetangga ini secara berurutan, menempel tetangga mereka sepanjang waktu dan seterusnya.  Properti jalur terpendek mengikuti dari fakta bahwa node dikunjungi dalam urutan jaraknya dari sumber.  Karena itu, ketika kita menemukan tujuan, kita tahu bahwa tidak ada generasi sebelumnya yang bisa mengarah ke sana. <br><br>  Pada saat ini, kita <i>hampir</i> selesai.  Pertama, Anda perlu menjawab beberapa pertanyaan, dan mereka dipaksa untuk kembali ke perumusan asli masalah. <br><br>  Pertama, hal paling sepele yang harus dilakukan jika unit aslinya tidak ada?  Artinya, kita tidak dapat menemukan simpul dengan nama yang diberikan.  Dalam praktiknya, Anda perlu melakukan beberapa normalisasi string sehingga Pound, Pound dan lb menunjuk ke simpul “pound” yang sama (atau beberapa representasi kanonik lainnya), tetapi ini di luar ruang lingkup pertanyaan kami. <br><br>  Kedua, bagaimana jika tidak ada konversi antara kedua unit?  Ingatlah bahwa dalam data awal hanya ada konversi antar unit, dan itu tidak memberikan indikasi apakah mungkin untuk mendapatkan yang lain dari satu unit tertentu.  Ini bermuara pada fakta bahwa transformasi dan jalur secara langsung setara, jadi jika tidak ada jalur antara dua node, maka tidak ada transformasi.  Dalam praktiknya, Anda berakhir dengan pulau unit yang tidak terkait: satu untuk jarak, satu untuk bobot, satu untuk mata uang, dll. <br><br>  Akhirnya, jika Anda perhatikan dengan seksama pada grafik di atas, ternyata Anda tidak dapat mengkonversi antara tangan dan tahun cahaya dengan solusi ini.  Arah koneksi antara node berarti bahwa tidak ada jalan dari tahun cahaya ke tangan.  Namun, ini cukup mudah untuk diperbaiki, karena transformasi dapat dibalik.  Kami dapat mengubah kode inisialisasi grafik kami sebagai berikut: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph. Note we insert its inverse also.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dest <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[dest] = {} self.graph[dest][orig] = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / rate</code> </pre> <br><h2>  Bagian 3. Evaluasi </h2><br>  Selesai!  Jika kandidat telah mencapai titik ini, maka saya kemungkinan besar akan merekomendasikan dia untuk disewa.  Jika Anda mempelajari ilmu komputer atau mengambil kursus dalam algoritma, Anda dapat bertanya: "Apakah ini benar-benar cukup untuk mendapatkan wawancara dengan orang ini?", Untuk itu saya akan menjawab: "Pada dasarnya, ya." <br><br>  Sebelum Anda memutuskan bahwa pertanyaannya terlalu sederhana, mari kita lihat apa yang harus dilakukan seorang kandidat untuk mencapai titik ini: <br><br><ul><li>  Pahami pertanyaannya <br></li><li>  Membangun jaringan transformasi dalam bentuk grafik <br></li><li>  Pahami bahwa koefisien dapat dibandingkan dengan tepi grafik <br></li><li>  Lihat kemungkinan menggunakan algoritma pencarian untuk mencapai ini. <br></li><li>  Pilih algoritma favorit Anda dan ubah untuk melacak peluang <br></li><li>  Jika dia menerapkan DFS sebagai solusi naif, kenali kelemahannya. <br></li><li>  Terapkan BFS <br></li><li>  Untuk mundur dan mempelajari kasus-kasus ekstrem: <br><ul><li>  Bagaimana jika kita ditanya tentang simpul yang tidak ada? <br></li><li>  Bagaimana jika faktor konversi tidak ada? </li></ul></li><li>  Ketahuilah bahwa transformasi terbalik adalah mungkin dan mungkin perlu </li></ul><br>  Pertanyaan ini lebih mudah dari yang sebelumnya, tetapi juga sulit.  Seperti dalam semua pertanyaan sebelumnya, kandidat harus membuat lompatan mental dari pertanyaan yang dirumuskan secara abstrak ke algoritma atau struktur data yang membuka jalan ke solusi.  Satu-satunya hal adalah bahwa algoritma terakhir kurang canggih daripada masalah lainnya.  Di luar materi algoritmik ini, persyaratan yang sama berlaku, terutama yang berkaitan dengan kasus ekstrim dan kebenaran. <br><br>  "Tapi tunggu!" Anda mungkin bertanya.  - Bukankah Google terobsesi dengan kompleksitas runtime?  Anda bahkan tidak bertanya tentang kompleksitas temporal atau spasial dari masalah ini.  Oh well! "  Anda juga dapat bertanya: "Tunggu sebentar, Anda memberi peringkat" sangat merekomendasikan untuk disewa "?  Bagaimana cara mendapatkannya? "  Pertanyaan yang sangat bagus.  Ini membawa kita ke babak bonus tambahan final kami ... <br><br><h2>  Bagian 4. Apakah mungkin untuk melakukan yang lebih baik? </h2><br>  Pada titik ini, saya ingin memberi selamat kepada kandidat dengan jawaban yang baik dan memperjelas bahwa semuanya adalah bonus.  Ketika tekanan menghilang, kita bisa mulai menciptakan. <br><br>  Jadi apa kesulitan menjalankan BFS?  Dalam kasus terburuk, kita harus mempertimbangkan setiap node dan edge, yang memberikan kompleksitas linier <code>O(N+E)</code> .  Ini di atas kompleksitas yang sama dari konstruksi grafik <code>O(N+E)</code> .  Untuk mesin pencari, ini mungkin bagus: seribu unit ukuran sudah cukup untuk sebagian besar aplikasi yang masuk akal, dan melakukan pencarian memori untuk setiap permintaan bukanlah kelebihan. <br><br>  Namun, seseorang dapat melakukan yang lebih baik.  Untuk memotivasi, pertimbangkan bagaimana kode ini dimasukkan ke dalam string pencarian.  Konversi beberapa unit non-standar sedikit lebih umum, jadi kami akan menghitungnya lagi dan lagi.  Setiap kali pencarian dilakukan, nilai menengah dihitung, dan seterusnya. <br><br>  Sering disarankan untuk hanya men-cache hasil perhitungan.  Setiap kali konversi satuan dihitung, kami selalu dapat menambahkan keunggulan di antara dua konversi tersebut.  Sebagai bonus, kami mendapatkan transformasi terbalik, dan gratis!  Apakah kamu sudah selesai? <br><br>  Memang, ini akan memberi kita waktu pencarian konstan asimptotik, tetapi akan biaya penyimpanan tepi tambahan.  Ini sebenarnya menjadi sangat mahal: seiring waktu, kami akan berusaha untuk grafik yang lengkap, karena semua pasang transformasi secara bertahap dihitung dan disimpan.  Jumlah tepi yang mungkin pada grafik adalah setengah kuadrat dari jumlah node, jadi untuk seribu node kita membutuhkan setengah juta tepi.  Untuk sepuluh ribu node, sekitar lima puluh juta, dll. <br><br>  Melampaui ruang lingkup mesin pencari, untuk grafik sejuta node, kami berjuang untuk setengah triliun tepi.  Jumlah ini tidak masuk akal untuk disimpan, ditambah kami menghabiskan waktu memasukkan tepi ke dalam grafik.  Kita harus berbuat lebih baik. <br><br>  Untungnya, ada cara untuk mencapai waktu yang konstan untuk mencari koefisien, tanpa pertumbuhan ruang kuadratik.  Faktanya, hampir semua yang kita butuhkan ada di bawah hidung kita. <br><br><h2>  Bagian 4. Waktu konstan </h2><br>  Jadi, caching total sebenarnya dekat dengan solusi optimal.  Dalam pendekatan ini, kita (pada akhirnya) mendapatkan tepi di antara semua node, yaitu transformasi kita direduksi menjadi menemukan satu sisi.  Tetapi apakah benar-benar perlu untuk menyimpan konversi dari setiap node ke setiap node?  Bagaimana jika kita hanya menyimpan faktor konversi dari <i>satu</i> node ke yang lainnya? <br><br>  Lihatlah lagi solusi BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Mari kita lihat apa yang terjadi di sini: kita mulai dari simpul sumber, dan untuk setiap simpul yang kita temui, kita menghitung koefisien konversi dari sumber ke simpul ini.  Kemudian, segera setelah kami tiba di tujuan, kami mengembalikan koefisien antara titik awal dan akhir dan membuang koefisien antara. <br><br>  Rasio antara ini adalah kuncinya.  Tetapi bagaimana jika kita tidak membuangnya?  Bagaimana jika kita menuliskannya?  Semua pencarian yang paling kompleks dan tidak dapat dipahami menjadi sederhana: untuk menemukan rasio A ke B, pertama temukan rasio X ke B, kemudian membaginya dengan rasio X ke A, dan Anda selesai!  Secara visual, tampilannya seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/284/a08/b6c/284a08b6cb6ef95af556422fa3c604f3.png"><br>  <i><font color="gray">Perhatikan bahwa antara dua node tidak lebih dari dua sisi</font></i> <br><br>  Ternyata untuk menghitung tabel ini, kita hampir tidak perlu mengubah solusi BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_conversions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conversions_bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, conversions)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() conversions[node] = (start, rate_from_origin) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: to_visit.append((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions conversions = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.get_nodes(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: conversions_bfs(graph, node, conversions) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions</code> </pre> <br>  Struktur transformasi diwakili oleh kamus unit A dalam dua nilai: root untuk komponen terkait unit A dan koefisien konversi antara unit root dan unit A. Karena kita memasukkan unit ke dalam kamus ini pada setiap kunjungan, kita dapat menggunakan ruang kunci dari kamus ini sebagai serangkaian kunjungan alih-alih menggunakan serangkaian kunjungan khusus.  Perhatikan bahwa kami tidak memiliki simpul final, dan alih-alih kami mengulangi simpul tersebut sampai selesai. <br><br>  Di luar BFS ini, ada fungsi pembantu yang beralih di atas node dalam grafik.  Setiap kali bertemu dengan simpul di luar kamus terjemahan, BFS dimulai dari simpul itu.  ,         . <br><br>      ,     ,    : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(conversions, start, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Given a conversion structure, performs a constant-time conversion'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: start_root, start_rate = conversions[start] end_root, end_rate = conversions[end] <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_root != end_root: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end_rate / start_rate</code> </pre> <br>  «  »        .  «  »     :     , ,       BFS,        ,        . ,   . <br><br>  !        <code>O(V+E)</code> ( ,    ),       . ,     ,  ó        ,          .        ,   :   <code>O(V+E)</code> ,        ,      <code>O(V)</code> ,       . <br><br><h2>  Hasil </h2><br>     ,   ,        ,  ,      -              .     -   ,         .   ,     . <br><br>         ( ,  , ,     ),          « ».    ,     :     ,       ,    . <br><br>     .   ,         ,    ,      .   —              .              , ,       Google (  ,    ,    ). <br><br>   ,        . ,    ,       . ,    ,          , ,  -   ,    . <br><br>   .          DFS, ,     ,      .   ,   BFS  DFS, ,    ,          . <br><br>    ,    ,      «»,        .       ,        ,    .       .      ,         .  :   ,  « »  . <br><br><h2>  ,    ! </h2><br>  ,    ,        ,     ,      .     : <br><br> -, :     ,   ,        .  ,     ,    .   ,         - ,  -               .     ,       ,            . <br><br> -,    ,        ,    .       —  :  —  ,    A  B   —    /   .            :  , ,    ,    ,     ,   .      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, permata nyata: beberapa unit dinyatakan sebagai kombinasi dari unit dasar yang berbeda. Misalnya, satu watt didefinisikan dalam sistem SI sebagai kg • m² / s³. Tugas terakhir adalah memperluas sistem ini untuk mendukung konversi antara unit-unit ini, dengan hanya mempertimbangkan definisi unit SI dasar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda memiliki pertanyaan, jangan ragu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menghubungi saya di reddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Kesimpulan </h2><br>        ,  ,      .      :     ,      ,       ,        . ,   ,  ,   ,     :            ,        .   ,      ,  ,           . <br><br> ,     . ,          ,     .       .    ,        ,   .   —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467371/">https://habr.com/ru/post/id467371/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467359/index.html">PVS-Studio pergi ke awan: Azure DevOps</a></li>
<li><a href="../id467361/index.html">Kami lupa tentang delegasi dalam JavaScript. Delegasi acara di bereaksi</a></li>
<li><a href="../id467363/index.html">Menggunakan fungsi kehilangan kustom dan metrik kualitas pembelajaran di Keras</a></li>
<li><a href="../id467365/index.html">Relai pemantauan voltase perumahan</a></li>
<li><a href="../id467369/index.html">RubyRussia 2019. Mikhail Pronyakin: apakah Ruby aman?</a></li>
<li><a href="../id467375/index.html">Manajemen Pengalaman Pelanggan - apa itu?</a></li>
<li><a href="../id467377/index.html">Tiga berturut-turut: 10 laporan teratas dari Mobius 2019 Piter</a></li>
<li><a href="../id467381/index.html">LED bertingkat, lampu pintar, dan lampu untuk 18 rubel</a></li>
<li><a href="../id467383/index.html">"Manajer harus tetap mengkode": wawancara dengan Stephen Chin</a></li>
<li><a href="../id467385/index.html">Pilihan pertanyaan teknis psikologis dan atipikal dari wawancara pengembang Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>