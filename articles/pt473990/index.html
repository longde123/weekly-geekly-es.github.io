<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è≠Ô∏è üì∫ üßëüèΩ‚Äçü§ù‚Äçüßëüèº Aprenda o OpenGL. Li√ß√£o 7.2 - Texto de desenho üë©üèΩ‚Äçü§ù‚Äçüë©üèº üÖ±Ô∏è üòÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em algum momento de sua aventura gr√°fica, voc√™ desejar√° gerar texto atrav√©s do OpenGL. Ao contr√°rio do que voc√™ poderia esperar, obter uma linha simpl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprenda o OpenGL. Li√ß√£o 7.2 - Texto de desenho</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473990/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="imagem" align="left" width="300">  Em algum momento de sua aventura gr√°fica, voc√™ desejar√° gerar texto atrav√©s do OpenGL.  Ao contr√°rio do que voc√™ poderia esperar, obter uma linha simples na tela √© bastante dif√≠cil com uma biblioteca de baixo n√≠vel, como o OpenGL.  Se voc√™ n√£o precisar de mais de 128 caracteres diferentes para desenhar texto, n√£o ser√° dif√≠cil.  As dificuldades surgem quando os caracteres n√£o correspondem √† altura, largura e deslocamento.  Dependendo de onde voc√™ mora, voc√™ pode precisar de mais de 128 caracteres.  Mas e se voc√™ quiser caracteres especiais, matem√°ticos ou musicais?  Assim que voc√™ entender que desenhar texto n√£o √© a tarefa mais f√°cil, voc√™ perceber√° que ele provavelmente n√£o deve pertencer a uma API de n√≠vel inferior como o OpenGL. </p><br><p> Como o OpenGL n√£o fornece nenhum meio para renderizar texto, todas as dificuldades deste caso est√£o sobre n√≥s.  Como n√£o existe um "s√≠mbolo" gr√°fico primitivo, teremos que invent√°-lo.  J√° existem exemplos prontos: desenhe um s√≠mbolo atrav√©s de <code>GL_LINES</code> , crie modelos 3D de s√≠mbolos ou desenhe s√≠mbolos em quadr√¢ngulos planos no espa√ßo tridimensional. </p><br><p>  Na maioria das vezes, os desenvolvedores t√™m <s>pregui√ßa de</s> <s>tomar caf√© e</s> escolher a √∫ltima op√ß√£o.  Desenhar esses quadrados texturizados n√£o √© t√£o dif√≠cil quanto escolher a textura certa.  Neste tutorial, aprenderemos algumas maneiras e escreveremos nosso renderizador de texto avan√ßado, mas flex√≠vel, usando o FreeType. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Conte√∫do</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Parte 1. Introdu√ß√£o</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cria√ß√£o de janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ol√° janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ol√° tri√¢ngulo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Texturas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transforma√ß√µes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sistemas de coordenadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camera</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 2. Ilumina√ß√£o b√°sica</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">No√ß√µes b√°sicas de ilumina√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Materiais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de textura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V√°rias fontes de ilumina√ß√£o</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 3. Baixe modelos 3D</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe de pol√≠gono de malha</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe do modelo 3D</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 4. Recursos avan√ßados do OpenGL</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de profundidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de est√™ncil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mistura de cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Faces de recorte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Buffer de quadros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cart√µes c√∫bicos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manipula√ß√£o avan√ßada de dados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GLSL avan√ßado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shader geom√©trico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instanciamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suaviza√ß√£o</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 5. Ilumina√ß√£o Avan√ßada</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ilumina√ß√£o avan√ßada.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Blinn Fong Model</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Corre√ß√£o gama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cart√µes de sombra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de sombra omnidirecionais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento de paralaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Renderiza√ß√£o adiada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 6. PBR</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz anal√≠tica</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Irradia√ß√£o difusa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exposi√ß√£o especular</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 7. Pr√°tica</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Depura√ß√£o</a> </li><li>  <strong>Renderiza√ß√£o de texto</strong> </li></ol></div></div></div></div><br><h1 id="klassika-rastrovye-shrifty">  Cl√°ssico: Fontes Raster </h1><br><p>  Uma vez <s>na √©poca dos dinossauros, a</s> renderiza√ß√£o de texto inclu√≠a a sele√ß√£o de uma fonte (ou a cria√ß√£o) para o aplicativo e a c√≥pia dos caracteres desejados em uma textura grande chamada fonte de bitmap.  Essa textura cont√©m todos os caracteres necess√°rios em certas partes.  Esses caracteres s√£o chamados de glifos.  Cada glifo tem uma √°rea espec√≠fica de coordenadas de textura associada a ele.  Cada vez que voc√™ desenha um personagem, seleciona um glifo espec√≠fico e desenha apenas a parte desejada em um quadril√°tero plano. </p><br><p><img src="https://habrastorage.org/webt/0q/dd/sm/0qddsmwzcxldp9s0kvohcz2qgea.png"></p><br><p>  Aqui voc√™ pode ver como renderizamos o texto "OpenGL".  Pegamos a fonte de bitmap e amostramos os glifos necess√°rios da textura, selecionando cuidadosamente as coordenadas da textura, que desenharemos no topo de v√°rios quadr√¢ngulos.  Ativando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mesclagem</a> e mantendo o plano de fundo transparente, obtemos uma s√©rie de caracteres na tela.  Essa fonte de bitmap foi gerada usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerador de fontes de bitmap</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Codehead</a> . </p><br><p>  Essa abordagem tem seus pr√≥s e contras.  Essa abordagem possui uma implementa√ß√£o simples, pois as fontes de bitmap j√° s√£o rasterizadas.  No entanto, isso nem sempre √© conveniente.  Se voc√™ precisar de uma fonte diferente, precisar√° gerar uma nova fonte de bitmap.  Al√©m disso, aumentar o tamanho dos caracteres mostrar√° rapidamente bordas pixeladas.  Al√©m disso, as fontes de bitmap geralmente est√£o vinculadas a um pequeno conjunto de caracteres; portanto, os caracteres Unicode provavelmente n√£o ser√£o exibidos. </p><br><p>  Essa t√©cnica era popular h√° pouco tempo (e ainda mant√©m sua popularidade), porque √© muito r√°pida e funciona em qualquer plataforma.  Mas at√© o momento, existem outras abordagens para renderizar texto.  Uma delas √© renderizar fontes TrueType usando o FreeType. </p><br><h1 id="sovremennost-freetype">  Modernidade: FreeType </h1><br><p>  O FreeType √© uma biblioteca que baixa fontes, as processa em bitmaps e fornece suporte para algumas opera√ß√µes relacionadas a fontes.  Essa biblioteca popular √© usada no Mac OS X, Java, Qt, PlayStation, Linux e Android.  A capacidade de carregar fontes TrueType torna essa biblioteca bastante atraente. </p><br><p>  Uma fonte TrueType √© uma cole√ß√£o de glifos definidos n√£o por pixels, mas por f√≥rmulas matem√°ticas.  Como nas imagens vetoriais, uma imagem de fonte rasterizada pode ser gerada com base no tamanho de fonte preferido.  Usando fontes TrueType, voc√™ pode facilmente renderizar glifos de v√°rios tamanhos sem perda de qualidade. </p><br><p>  O FreeType pode ser baixado do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site oficial</a> .  Voc√™ pode compilar o FreeType voc√™ mesmo ou usar vers√µes pr√©-compiladas, se houver, no site.  Lembre-se de vincular seu programa ao <code>freetype.lib</code> e verifique se o compilador sabe onde procurar os arquivos de cabe√ßalho. </p><br><p>  Em seguida, anexe os arquivos de cabe√ßalho corretos: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ft2build.h&gt; #include FT_FREETYPE_H</span></span></span></span></code> </pre> <br><blockquote>  Como o FreeType foi projetado de uma maneira um pouco estranha (no momento em que escrevi o original, deixe-me saber se algo mudou), voc√™ pode colocar seus arquivos de cabe√ßalho apenas na raiz da pasta com os arquivos de cabe√ßalho.  Conectar o FreeType de alguma outra maneira (por exemplo, <code>#include &lt;3rdParty/FreeType/ft2build.h&gt;</code> ) pode provocar um conflito no arquivo de cabe√ßalho. </blockquote><p>  O que o FreeType faz?  Carrega fontes TrueType e gera uma imagem de bitmap para cada glifo e calcula algumas m√©tricas de glifo.  Podemos obter imagens de bitmap para gerar texturas e posicionar cada glifo, dependendo das m√©tricas recebidas. </p><br><p>  Para baixar uma fonte, precisamos inicializar o FreeType e carreg√°-la como face (como o FreeType chama a fonte).  Neste exemplo, carregamos a fonte TrueType <code>arial.ttf</code> , copiada da pasta C: / Windows / Fonts. </p><br><pre> <code class="cpp hljs">FT_Library ft; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Init_FreeType(&amp;ft)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Could not init FreeType Library"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; FT_Face face; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_New_Face(ft, <span class="hljs-string"><span class="hljs-string">"fonts/arial.ttf"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;face)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Failed to load font"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Cada uma dessas fun√ß√µes do FreeType retorna um valor diferente de zero em caso de falha. </p><br><p>  Depois de carregar a <s>fonte da</s> face, precisamos especificar o tamanho da fonte desejado, que extrairemos: </p><br><pre> <code class="cpp hljs">FT_Set_Pixel_Sizes(face, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>);</code> </pre> <br><p>  Esta fun√ß√£o define a largura e a altura do glifo.  Ao definir a largura como 0 (zero), permitimos que o FreeType calcule a largura, dependendo da altura definida. </p><br><p>  O Face FreeType cont√©m uma cole√ß√£o de glifos.  Podemos ativar algum glifo chamando <code>FT_Load_Char</code> .  Aqui tentamos carregar o glifo <code>X</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Load_Char(face, <span class="hljs-string"><span class="hljs-string">'X'</span></span>, FT_LOAD_RENDER)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYTPE: Failed to load Glyph"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Ao definir <code>FT_LOAD_RENDER</code> como um dos sinalizadores de download, pedimos ao FreeType para criar um bitmap de escala de cinza de 8 bits, que podemos obter assim: </p><br><pre> <code class="cpp hljs">face-&gt;glyph-&gt;bitmap;</code> </pre> <br><p>  Os glifos carregados com o FreeType n√£o t√™m o mesmo tamanho que no caso de fontes de bitmap.  Um bitmap gerado com o FreeType √© o tamanho m√≠nimo para um determinado tamanho de fonte e √© suficiente apenas para conter um caractere.  Por exemplo, uma imagem de bitmap de um glifo <code>.</code>  muito menor que o bitmap do glifo <code>X</code>  Por esse motivo, o FreeType tamb√©m baixa algumas m√©tricas que mostram qual tamanho e onde um √∫nico caractere deve estar localizado.  Abaixo est√° uma imagem mostrando quais m√©tricas o FreeType calcula para cada glifo. </p><br><p><img src="https://habrastorage.org/webt/ux/2y/kh/ux2ykhrgznafueqwujrjdqgun9q.png"></p><br><p>  Cada glifo est√° localizado na linha de base (linha horizontal com uma seta).  Alguns est√£o exatamente na linha de base ( <code>X</code> ), outros est√£o abaixo ( <code>g</code> , <code>p</code> ).  Essas m√©tricas determinam com precis√£o os deslocamentos para o posicionamento preciso dos glifos na linha de base, ajustando o tamanho dos glifos e para descobrir quantos pixels voc√™ precisa deixar para desenhar o pr√≥ximo glifo.  A seguir, √© apresentada uma lista das m√©tricas que usaremos: </p><br><ul><li>  <strong>width</strong> : <strong>largura do</strong> glifo em pixels, acesso por <code>face-&gt;glyph-&gt;bitmap.width</code> </li><li>  <strong>height</strong> : <strong>altura do</strong> glifo em pixels, acesso por <code>face-&gt;glyph-&gt;bitmap.rows</code> </li><li>  <strong>bearingX</strong> : deslocamento horizontal do ponto superior esquerdo do glifo em rela√ß√£o √† origem, acesso por <code>face-&gt;glyph-&gt;bitmap_left</code> </li><li>  <strong>BearingY</strong> : deslocamento vertical do ponto superior esquerdo do glifo em rela√ß√£o √† origem, acesso por <code>face-&gt;glyph-&gt;bitmap_top</code> </li><li>  <strong>avan√ßo</strong> : deslocamento horizontal do in√≠cio do pr√≥ximo glifo em 1/64 pixels em rela√ß√£o √† origem, acesso por <code>face-&gt;glyph-&gt;advance.x</code> </li></ul><br><p>  Podemos carregar um glifo de um s√≠mbolo, obter suas m√©tricas e gerar uma textura toda vez que queremos desenh√°-lo na tela, mas criar texturas para cada s√≠mbolo em cada quadro n√£o √© um bom m√©todo.  Melhor salvar os dados gerados em algum lugar e solicit√°-los quando precisarmos.  Definimos uma estrutura conveniente que armazenaremos em <code>std::map</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> {</span></span> GLuint TextureID; <span class="hljs-comment"><span class="hljs-comment">// ID   glm::ivec2 Size; //   glm::ivec2 Bearing; //      GLuint Advance; //       }; std::map&lt;GLchar, Character&gt; Characters;</span></span></code> </pre> <br><p>  Neste artigo, simplificaremos nossa vida e usaremos apenas os primeiros 128 caracteres.  Para cada caractere, geraremos uma textura e salvaremos os dados necess√°rios em uma estrutura do tipo <code>Character</code> , que adicionaremos aos <code>Characters</code> tipo <code>std::map</code> .  Assim, todos os dados necess√°rios para desenhar um personagem s√£o salvos para uso futuro. </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Disable byte-alignment restriction for (GLubyte c = 0; c &lt; 128; c++) { // Load character glyph if (FT_Load_Char(face, c, FT_LOAD_RENDER)) { std::cout &lt;&lt; "ERROR::FREETYTPE: Failed to load Glyph" &lt;&lt; std::endl; continue; } // Generate texture GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D( GL_TEXTURE_2D, 0, GL_RED, face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows, 0, GL_RED, GL_UNSIGNED_BYTE, face-&gt;glyph-&gt;bitmap.buffer ); // Set texture options glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Now store character for later use Character character = { texture, glm::ivec2(face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows), glm::ivec2(face-&gt;glyph-&gt;bitmap_left, face-&gt;glyph-&gt;bitmap_top), face-&gt;glyph-&gt;advance.x }; Characters.insert(std::pair&lt;GLchar, Character&gt;(c, character)); // Characters[c] = character; }</span></span></code> </pre> <br><p>  Dentro do loop, para cada um dos 128 primeiros caracteres, obtemos um glifo, geramos uma textura, definimos suas configura√ß√µes e salvamos as m√©tricas.  √â interessante notar que usamos <code>GL_RED</code> como argumentos para <code>internalFormat</code> e <code>format</code> texturas.  Um bitmap gerado por glifo √© uma imagem em escala de cinza de 8 bits, cada pixel ocupando 1 byte.  Por esse motivo, armazenaremos o buffer de bitmap como o valor da cor da textura.  Isso √© obtido criando uma textura na qual cada byte corresponde ao componente vermelho da cor.  Se usarmos 1 byte para representar cores de textura, n√£o se esque√ßa das limita√ß√µes do OpenGL: </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  O OpenGL exige que todas as texturas tenham um deslocamento de 4 bytes, ou seja,  seu tamanho deve ser m√∫ltiplo de 4 bytes (por exemplo, 8 bytes, 4000 bytes, 2048 bytes) ou (e) eles devem usar 4 bytes por pixel (como no formato RGBA), mas como usamos 1 byte por pixel, eles podem ter diferentes largura.  Ao definir o deslocamento do alinhamento da descompacta√ß√£o (existe uma tradu√ß√£o melhor?) Para 1, eliminamos os erros de deslocamento que podem causar segfaults. </p><br><p>  Al√©m disso, quando terminarmos de trabalhar com a pr√≥pria fonte, limpe os recursos do FreeType: </p><br><pre> <code class="cpp hljs">FT_Done_Face(face); <span class="hljs-comment"><span class="hljs-comment">//     face FT_Done_FreeType(ft); //   FreeType</span></span></code> </pre> <br><h4 id="sheydery">  Shaders </h4><br><p>  Para desenhar glifos, use o seguinte sombreador de v√©rtice: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec4 vertex; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;vec2 pos, vec2 tex_coord&gt; out vec2 TexCoords; uniform mat4 projection; void main() { gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); TexCoords = vertex.zw; }</span></span></span></span></code> </pre> <br><p>  Combinamos a posi√ß√£o do s√≠mbolo e as coordenadas da textura em um <code>vec4</code> .  O shader de v√©rtice calcula o produto das coordenadas com a matriz de proje√ß√£o e transfere as coordenadas da textura para o shader de fragmento: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core in vec2 TexCoords; out vec4 color; uniform sampler2D text; uniform vec3 textColor; void main() { vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); color = vec4(textColor, 1.0) * sampled; }</span></span></code> </pre> <br><p>  O shader de fragmento aceita 2 vari√°veis ‚Äã‚Äãglobais - uma imagem monocrom√°tica do glifo e a cor do pr√≥prio glifo.  Primeiro, amostramos o valor da cor do glifo.  Como os dados da textura s√£o armazenados no componente vermelho da textura, apenas amostramos o componente <code>r</code> como o valor da transpar√™ncia.  Alterando a transpar√™ncia da cor, a cor resultante ser√° transparente para o plano de fundo do glifo e opaca para os pixels reais do glifo.  Tamb√©m multiplicamos as cores RGB pela vari√°vel textColor para alterar a cor do texto. </p><br><p>  Mas, para que nosso mecanismo funcione, voc√™ precisa ativar a mistura: </p><br><pre> <code class="cpp hljs">glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre> <br><p>  Como matriz de proje√ß√£o, teremos uma matriz de proje√ß√£o ortogr√°fica.  Para desenhar texto, de fato, uma matriz de perspectiva n√£o √© necess√°ria e o uso da proje√ß√£o ortogr√°fica tamb√©m nos permite especificar todas as coordenadas de v√©rtices nas coordenadas da tela se definirmos a matriz assim: </p><br><pre> <code class="cpp hljs">glm::mat4 projection = glm::ortho(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">800.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">600.0f</span></span>);</code> </pre> <br><p>  Definimos a parte inferior da matriz como <code>0.0f</code> , a parte superior para a altura da janela.  Como resultado, a coordenada <code>y</code> leva valores da parte inferior da tela ( <code>y = 0</code> ) para a parte superior da tela ( <code>y = 600</code> ).  Isso significa que o ponto <code>(0, 0)</code> indica e o canto inferior esquerdo da tela. </p><br><p>  Em conclus√£o, crie VBO e VAO para desenhar os quadr√¢ngulos.  Aqui reservamos mem√≥ria suficiente no VBO para que possamos atualizar os dados para desenhar caracteres. </p><br><pre> <code class="cpp hljs">GLuint VAO, VBO; glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat) * <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, GL_DYNAMIC_DRAW); glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">0</span></span>); glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat), <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Um quadril√°tero plano requer 6 v√©rtices de 4 n√∫meros de ponto flutuante, portanto reservamos <code>6 * 4 = 24</code> flutua√ß√µes de mem√≥ria.  Como vamos alterar os dados dos v√©rtices com bastante frequ√™ncia, alocamos mem√≥ria usando <code>GL_DYNAMIC_DRAW</code> . </p><br><h4 id="vyvod-stroki-teksta-na-ekran">  Exibir uma linha de texto na tela </h4><br><p>  Para exibir uma linha de texto, extra√≠mos a estrutura de <code>Character</code> correspondente ao s√≠mbolo e calculamos as dimens√µes do quadril√°tero a partir das m√©tricas do s√≠mbolo.  A partir das dimens√µes calculadas do quadril√°tero, <code>glBufferSubData</code> criamos um conjunto de 6 v√©rtices e atualizamos os dados do v√©rtice usando <code>glBufferSubData</code> . </p><br><p>  Por conveni√™ncia, <code>RenderText</code> fun√ß√£o <code>RenderText</code> que desenhe uma sequ√™ncia de caracteres: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader &amp;s, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Activate corresponding render state s.Use(); glUniform3f(glGetUniformLocation(s.Program, "textColor"), color.x, color.y, color.z); glActiveTexture(GL_TEXTURE0); glBindVertexArray(VAO); // Iterate through all characters std::string::const_iterator c; for (c = text.begin(); c != text.end(); c++) { Character ch = Characters[*c]; GLfloat xpos = x + ch.Bearing.x * scale; GLfloat ypos = y - (ch.Size.y - ch.Bearing.y) * scale; GLfloat w = ch.Size.x * scale; GLfloat h = ch.Size.y * scale; // Update VBO for each character GLfloat vertices[6][4] = { { xpos, ypos + h, 0.0, 0.0 }, { xpos, ypos, 0.0, 1.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos, ypos + h, 0.0, 0.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos + w, ypos + h, 1.0, 0.0 } }; // Render glyph texture over quad glBindTexture(GL_TEXTURE_2D, ch.textureID); // Update content of VBO memory glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); glBindBuffer(GL_ARRAY_BUFFER, 0); // Render quad glDrawArrays(GL_TRIANGLES, 0, 6); // Now advance cursors for next glyph (note that advance is number of 1/64 pixels) x += (ch.Advance &gt;&gt; 6) * scale; // Bitshift by 6 to get value in pixels (2^6 = 64) } glBindVertexArray(0); glBindTexture(GL_TEXTURE_2D, 0); }</span></span></code> </pre> <br><p>  O conte√∫do da fun√ß√£o √© relativamente claro: o c√°lculo da origem, tamanhos e v√©rtices do quadril√°tero.  Observe que multiplicamos cada m√©trica por <code>scale</code> .  Depois disso, atualize o VBO e desenhe um quad. </p><br><p>  Esta linha de c√≥digo requer alguma aten√ß√£o: </p><br><pre> <code class="cpp hljs">GLfloat ypos = y - (ch.Size.y - ch.Bearing.y);</code> </pre> <br><p>  Alguns caracteres, como <code>p</code> e <code>g</code> , s√£o desenhados visivelmente abaixo da linha de base, o que significa que o quad deve ser visivelmente mais baixo que o par√¢metro <code>y</code> da fun√ß√£o <code>RenderText</code> .  O deslocamento exato <code>y_offset</code> pode ser expresso a partir de m√©tricas de glifo: </p><br><p><img src="https://habrastorage.org/webt/2m/kp/g2/2mkpg2lb3jrfhl-zt9elefuopek.png"></p><br><p>  Para calcular o deslocamento, precisamos de <s>bra√ßos retos para</s> descobrir a dist√¢ncia em que o s√≠mbolo est√° localizado abaixo da linha de base.  Esta dist√¢ncia √© mostrada pela seta vermelha.  Obviamente, <code>y_offset = bearingY - height</code> e <code>ypos = y + y_offset</code> . </p><br><p>  Se tudo for feito corretamente, voc√™ poder√° exibir o texto na tela assim: </p><br><pre> <code class="cpp hljs">RenderText(shader, <span class="hljs-string"><span class="hljs-string">"This is sample text"</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); RenderText(shader, <span class="hljs-string"><span class="hljs-string">"(C) LearnOpenGL.com"</span></span>, <span class="hljs-number"><span class="hljs-number">540.0f</span></span>, <span class="hljs-number"><span class="hljs-number">570.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.9f</span></span>));</code> </pre> <br><p>  O resultado deve ficar assim: </p><br><p><img src="https://habrastorage.org/webt/dq/xs/uf/dqxsufeshmfga1wyzr1dl8amjes.png"></p><br><p>  Um exemplo de c√≥digo est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> (link para o site do autor original). </p><br><p>  Para entender quais quadr√¢ngulos s√£o desenhados, desative a mesclagem: </p><br><p><img src="https://habrastorage.org/webt/up/uc/fh/upucfh3hztm2du_zx7uc2wtiaby.png"></p><br><p>  A partir desta figura, √© √≥bvio que a maioria dos quadr√¢ngulos est√° no topo de uma linha de base imagin√°ria, embora alguns caracteres, como <code>(</code> e <code>p</code> , tenham sido deslocados para baixo. </p><br><h1 id="chto-zhe-dalee">  O que vem depois? </h1><br><p>  Este artigo mostrou como renderizar fontes TrueType com o FreeType.  Essa abordagem √© flex√≠vel, escal√°vel e eficiente em v√°rias codifica√ß√µes de caracteres.  No entanto, essa abordagem pode ser muito pesada para o seu aplicativo, pois uma textura √© criada para cada personagem.  As fontes de bitmap produtivas s√£o preferidas porque temos uma textura para todos os glifos.  A melhor abordagem √© combinar as duas abordagens e obter o melhor: imediatamente, gere uma fonte raster a partir de glifos baixados usando o FreeType.  Isso salvar√° o renderizador de in√∫meras trocas de texturas e, dependendo do pacote de texturas, aumentar√° o desempenho. </p><br><p>  Mas o FreeType tem mais uma desvantagem: glifos de tamanho fixo, o que significa que, √† medida que o tamanho do glifo renderizado aumenta, podem aparecer etapas na tela e o glifo pode parecer desfocado quando girado.  A Valve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20120815035559/">resolveu</a> (link para o arquivo da web) esse problema h√° v√°rios anos usando campos de dist√¢ncia assinados.  Eles se sa√≠ram muito bem e mostraram isso em aplicativos 3D. </p><br><p>  <strong>PS</strong> : Temos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">telegrama conf</a> para coordena√ß√£o de transfer√™ncias.  Se voc√™ tem um desejo s√©rio de ajudar com a tradu√ß√£o, √© bem-vindo! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt473990/">https://habr.com/ru/post/pt473990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt473980/index.html">Tecnologia e o mundo real: 4 startups que est√£o mudando o futuro do design de interiores</a></li>
<li><a href="../pt473982/index.html">NB-IoT: como funciona? Parte 3: SCEF - uma √∫nica janela de acesso aos servi√ßos do operador</a></li>
<li><a href="../pt473984/index.html">Data Science Digest (outubro de 2019)</a></li>
<li><a href="../pt473986/index.html">‚ÄúMeu sonho √© ver uma pessoa atrav√©s das √°rvores‚Äù - fundadora da Lisa Alert sobre as modernas tecnologias de pesquisa</a></li>
<li><a href="../pt473988/index.html">Otimizando a Distribui√ß√£o do Servidor nos Racks</a></li>
<li><a href="../pt473992/index.html">Vis√£o geral de protocolos modernos em sistemas de automa√ß√£o industrial</a></li>
<li><a href="../pt473994/index.html">Carregamento de script moderno</a></li>
<li><a href="../pt473998/index.html">Holanda, ou l√° e volta</a></li>
<li><a href="../pt474000/index.html">IQBX - projetista eletromec√¢nico para clubes e entusiastas de bricolage [ideia conceitual]</a></li>
<li><a href="../pt474004/index.html">De Norilsk a Riyadh: Um exemplo real para os cart√µes de mem√≥ria microSD UHS-I de temperatura industrial da Kingston</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>