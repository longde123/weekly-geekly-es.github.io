<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏭️ 📺 🧑🏽‍🤝‍🧑🏼 Aprenda o OpenGL. Lição 7.2 - Texto de desenho 👩🏽‍🤝‍👩🏼 🅱️ 😮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em algum momento de sua aventura gráfica, você desejará gerar texto através do OpenGL. Ao contrário do que você poderia esperar, obter uma linha simpl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprenda o OpenGL. Lição 7.2 - Texto de desenho</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473990/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="imagem" align="left" width="300">  Em algum momento de sua aventura gráfica, você desejará gerar texto através do OpenGL.  Ao contrário do que você poderia esperar, obter uma linha simples na tela é bastante difícil com uma biblioteca de baixo nível, como o OpenGL.  Se você não precisar de mais de 128 caracteres diferentes para desenhar texto, não será difícil.  As dificuldades surgem quando os caracteres não correspondem à altura, largura e deslocamento.  Dependendo de onde você mora, você pode precisar de mais de 128 caracteres.  Mas e se você quiser caracteres especiais, matemáticos ou musicais?  Assim que você entender que desenhar texto não é a tarefa mais fácil, você perceberá que ele provavelmente não deve pertencer a uma API de nível inferior como o OpenGL. </p><br><p> Como o OpenGL não fornece nenhum meio para renderizar texto, todas as dificuldades deste caso estão sobre nós.  Como não existe um "símbolo" gráfico primitivo, teremos que inventá-lo.  Já existem exemplos prontos: desenhe um símbolo através de <code>GL_LINES</code> , crie modelos 3D de símbolos ou desenhe símbolos em quadrângulos planos no espaço tridimensional. </p><br><p>  Na maioria das vezes, os desenvolvedores têm <s>preguiça de</s> <s>tomar café e</s> escolher a última opção.  Desenhar esses quadrados texturizados não é tão difícil quanto escolher a textura certa.  Neste tutorial, aprenderemos algumas maneiras e escreveremos nosso renderizador de texto avançado, mas flexível, usando o FreeType. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Conteúdo</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Parte 1. Introdução</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criação de janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Olá janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Olá triângulo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Texturas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transformações</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sistemas de coordenadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camera</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 2. Iluminação básica</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Noções básicas de iluminação</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Materiais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de textura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Várias fontes de iluminação</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 3. Baixe modelos 3D</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe de polígono de malha</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe do modelo 3D</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 4. Recursos avançados do OpenGL</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de profundidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de estêncil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mistura de cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Faces de recorte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Buffer de quadros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cartões cúbicos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manipulação avançada de dados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GLSL avançado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shader geométrico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instanciamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suavização</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 5. Iluminação Avançada</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Iluminação avançada.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Blinn Fong Model</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Correção gama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cartões de sombra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de sombra omnidirecionais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento de paralaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Renderização adiada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 6. PBR</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz analítica</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Irradiação difusa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exposição especular</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 7. Prática</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Depuração</a> </li><li>  <strong>Renderização de texto</strong> </li></ol></div></div></div></div><br><h1 id="klassika-rastrovye-shrifty">  Clássico: Fontes Raster </h1><br><p>  Uma vez <s>na época dos dinossauros, a</s> renderização de texto incluía a seleção de uma fonte (ou a criação) para o aplicativo e a cópia dos caracteres desejados em uma textura grande chamada fonte de bitmap.  Essa textura contém todos os caracteres necessários em certas partes.  Esses caracteres são chamados de glifos.  Cada glifo tem uma área específica de coordenadas de textura associada a ele.  Cada vez que você desenha um personagem, seleciona um glifo específico e desenha apenas a parte desejada em um quadrilátero plano. </p><br><p><img src="https://habrastorage.org/webt/0q/dd/sm/0qddsmwzcxldp9s0kvohcz2qgea.png"></p><br><p>  Aqui você pode ver como renderizamos o texto "OpenGL".  Pegamos a fonte de bitmap e amostramos os glifos necessários da textura, selecionando cuidadosamente as coordenadas da textura, que desenharemos no topo de vários quadrângulos.  Ativando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mesclagem</a> e mantendo o plano de fundo transparente, obtemos uma série de caracteres na tela.  Essa fonte de bitmap foi gerada usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerador de fontes de bitmap</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Codehead</a> . </p><br><p>  Essa abordagem tem seus prós e contras.  Essa abordagem possui uma implementação simples, pois as fontes de bitmap já são rasterizadas.  No entanto, isso nem sempre é conveniente.  Se você precisar de uma fonte diferente, precisará gerar uma nova fonte de bitmap.  Além disso, aumentar o tamanho dos caracteres mostrará rapidamente bordas pixeladas.  Além disso, as fontes de bitmap geralmente estão vinculadas a um pequeno conjunto de caracteres; portanto, os caracteres Unicode provavelmente não serão exibidos. </p><br><p>  Essa técnica era popular há pouco tempo (e ainda mantém sua popularidade), porque é muito rápida e funciona em qualquer plataforma.  Mas até o momento, existem outras abordagens para renderizar texto.  Uma delas é renderizar fontes TrueType usando o FreeType. </p><br><h1 id="sovremennost-freetype">  Modernidade: FreeType </h1><br><p>  O FreeType é uma biblioteca que baixa fontes, as processa em bitmaps e fornece suporte para algumas operações relacionadas a fontes.  Essa biblioteca popular é usada no Mac OS X, Java, Qt, PlayStation, Linux e Android.  A capacidade de carregar fontes TrueType torna essa biblioteca bastante atraente. </p><br><p>  Uma fonte TrueType é uma coleção de glifos definidos não por pixels, mas por fórmulas matemáticas.  Como nas imagens vetoriais, uma imagem de fonte rasterizada pode ser gerada com base no tamanho de fonte preferido.  Usando fontes TrueType, você pode facilmente renderizar glifos de vários tamanhos sem perda de qualidade. </p><br><p>  O FreeType pode ser baixado do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site oficial</a> .  Você pode compilar o FreeType você mesmo ou usar versões pré-compiladas, se houver, no site.  Lembre-se de vincular seu programa ao <code>freetype.lib</code> e verifique se o compilador sabe onde procurar os arquivos de cabeçalho. </p><br><p>  Em seguida, anexe os arquivos de cabeçalho corretos: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ft2build.h&gt; #include FT_FREETYPE_H</span></span></span></span></code> </pre> <br><blockquote>  Como o FreeType foi projetado de uma maneira um pouco estranha (no momento em que escrevi o original, deixe-me saber se algo mudou), você pode colocar seus arquivos de cabeçalho apenas na raiz da pasta com os arquivos de cabeçalho.  Conectar o FreeType de alguma outra maneira (por exemplo, <code>#include &lt;3rdParty/FreeType/ft2build.h&gt;</code> ) pode provocar um conflito no arquivo de cabeçalho. </blockquote><p>  O que o FreeType faz?  Carrega fontes TrueType e gera uma imagem de bitmap para cada glifo e calcula algumas métricas de glifo.  Podemos obter imagens de bitmap para gerar texturas e posicionar cada glifo, dependendo das métricas recebidas. </p><br><p>  Para baixar uma fonte, precisamos inicializar o FreeType e carregá-la como face (como o FreeType chama a fonte).  Neste exemplo, carregamos a fonte TrueType <code>arial.ttf</code> , copiada da pasta C: / Windows / Fonts. </p><br><pre> <code class="cpp hljs">FT_Library ft; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Init_FreeType(&amp;ft)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Could not init FreeType Library"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; FT_Face face; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_New_Face(ft, <span class="hljs-string"><span class="hljs-string">"fonts/arial.ttf"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;face)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Failed to load font"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Cada uma dessas funções do FreeType retorna um valor diferente de zero em caso de falha. </p><br><p>  Depois de carregar a <s>fonte da</s> face, precisamos especificar o tamanho da fonte desejado, que extrairemos: </p><br><pre> <code class="cpp hljs">FT_Set_Pixel_Sizes(face, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>);</code> </pre> <br><p>  Esta função define a largura e a altura do glifo.  Ao definir a largura como 0 (zero), permitimos que o FreeType calcule a largura, dependendo da altura definida. </p><br><p>  O Face FreeType contém uma coleção de glifos.  Podemos ativar algum glifo chamando <code>FT_Load_Char</code> .  Aqui tentamos carregar o glifo <code>X</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Load_Char(face, <span class="hljs-string"><span class="hljs-string">'X'</span></span>, FT_LOAD_RENDER)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYTPE: Failed to load Glyph"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Ao definir <code>FT_LOAD_RENDER</code> como um dos sinalizadores de download, pedimos ao FreeType para criar um bitmap de escala de cinza de 8 bits, que podemos obter assim: </p><br><pre> <code class="cpp hljs">face-&gt;glyph-&gt;bitmap;</code> </pre> <br><p>  Os glifos carregados com o FreeType não têm o mesmo tamanho que no caso de fontes de bitmap.  Um bitmap gerado com o FreeType é o tamanho mínimo para um determinado tamanho de fonte e é suficiente apenas para conter um caractere.  Por exemplo, uma imagem de bitmap de um glifo <code>.</code>  muito menor que o bitmap do glifo <code>X</code>  Por esse motivo, o FreeType também baixa algumas métricas que mostram qual tamanho e onde um único caractere deve estar localizado.  Abaixo está uma imagem mostrando quais métricas o FreeType calcula para cada glifo. </p><br><p><img src="https://habrastorage.org/webt/ux/2y/kh/ux2ykhrgznafueqwujrjdqgun9q.png"></p><br><p>  Cada glifo está localizado na linha de base (linha horizontal com uma seta).  Alguns estão exatamente na linha de base ( <code>X</code> ), outros estão abaixo ( <code>g</code> , <code>p</code> ).  Essas métricas determinam com precisão os deslocamentos para o posicionamento preciso dos glifos na linha de base, ajustando o tamanho dos glifos e para descobrir quantos pixels você precisa deixar para desenhar o próximo glifo.  A seguir, é apresentada uma lista das métricas que usaremos: </p><br><ul><li>  <strong>width</strong> : <strong>largura do</strong> glifo em pixels, acesso por <code>face-&gt;glyph-&gt;bitmap.width</code> </li><li>  <strong>height</strong> : <strong>altura do</strong> glifo em pixels, acesso por <code>face-&gt;glyph-&gt;bitmap.rows</code> </li><li>  <strong>bearingX</strong> : deslocamento horizontal do ponto superior esquerdo do glifo em relação à origem, acesso por <code>face-&gt;glyph-&gt;bitmap_left</code> </li><li>  <strong>BearingY</strong> : deslocamento vertical do ponto superior esquerdo do glifo em relação à origem, acesso por <code>face-&gt;glyph-&gt;bitmap_top</code> </li><li>  <strong>avanço</strong> : deslocamento horizontal do início do próximo glifo em 1/64 pixels em relação à origem, acesso por <code>face-&gt;glyph-&gt;advance.x</code> </li></ul><br><p>  Podemos carregar um glifo de um símbolo, obter suas métricas e gerar uma textura toda vez que queremos desenhá-lo na tela, mas criar texturas para cada símbolo em cada quadro não é um bom método.  Melhor salvar os dados gerados em algum lugar e solicitá-los quando precisarmos.  Definimos uma estrutura conveniente que armazenaremos em <code>std::map</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> {</span></span> GLuint TextureID; <span class="hljs-comment"><span class="hljs-comment">// ID   glm::ivec2 Size; //   glm::ivec2 Bearing; //      GLuint Advance; //       }; std::map&lt;GLchar, Character&gt; Characters;</span></span></code> </pre> <br><p>  Neste artigo, simplificaremos nossa vida e usaremos apenas os primeiros 128 caracteres.  Para cada caractere, geraremos uma textura e salvaremos os dados necessários em uma estrutura do tipo <code>Character</code> , que adicionaremos aos <code>Characters</code> tipo <code>std::map</code> .  Assim, todos os dados necessários para desenhar um personagem são salvos para uso futuro. </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Disable byte-alignment restriction for (GLubyte c = 0; c &lt; 128; c++) { // Load character glyph if (FT_Load_Char(face, c, FT_LOAD_RENDER)) { std::cout &lt;&lt; "ERROR::FREETYTPE: Failed to load Glyph" &lt;&lt; std::endl; continue; } // Generate texture GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D( GL_TEXTURE_2D, 0, GL_RED, face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows, 0, GL_RED, GL_UNSIGNED_BYTE, face-&gt;glyph-&gt;bitmap.buffer ); // Set texture options glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Now store character for later use Character character = { texture, glm::ivec2(face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows), glm::ivec2(face-&gt;glyph-&gt;bitmap_left, face-&gt;glyph-&gt;bitmap_top), face-&gt;glyph-&gt;advance.x }; Characters.insert(std::pair&lt;GLchar, Character&gt;(c, character)); // Characters[c] = character; }</span></span></code> </pre> <br><p>  Dentro do loop, para cada um dos 128 primeiros caracteres, obtemos um glifo, geramos uma textura, definimos suas configurações e salvamos as métricas.  É interessante notar que usamos <code>GL_RED</code> como argumentos para <code>internalFormat</code> e <code>format</code> texturas.  Um bitmap gerado por glifo é uma imagem em escala de cinza de 8 bits, cada pixel ocupando 1 byte.  Por esse motivo, armazenaremos o buffer de bitmap como o valor da cor da textura.  Isso é obtido criando uma textura na qual cada byte corresponde ao componente vermelho da cor.  Se usarmos 1 byte para representar cores de textura, não se esqueça das limitações do OpenGL: </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  O OpenGL exige que todas as texturas tenham um deslocamento de 4 bytes, ou seja,  seu tamanho deve ser múltiplo de 4 bytes (por exemplo, 8 bytes, 4000 bytes, 2048 bytes) ou (e) eles devem usar 4 bytes por pixel (como no formato RGBA), mas como usamos 1 byte por pixel, eles podem ter diferentes largura.  Ao definir o deslocamento do alinhamento da descompactação (existe uma tradução melhor?) Para 1, eliminamos os erros de deslocamento que podem causar segfaults. </p><br><p>  Além disso, quando terminarmos de trabalhar com a própria fonte, limpe os recursos do FreeType: </p><br><pre> <code class="cpp hljs">FT_Done_Face(face); <span class="hljs-comment"><span class="hljs-comment">//     face FT_Done_FreeType(ft); //   FreeType</span></span></code> </pre> <br><h4 id="sheydery">  Shaders </h4><br><p>  Para desenhar glifos, use o seguinte sombreador de vértice: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec4 vertex; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;vec2 pos, vec2 tex_coord&gt; out vec2 TexCoords; uniform mat4 projection; void main() { gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); TexCoords = vertex.zw; }</span></span></span></span></code> </pre> <br><p>  Combinamos a posição do símbolo e as coordenadas da textura em um <code>vec4</code> .  O shader de vértice calcula o produto das coordenadas com a matriz de projeção e transfere as coordenadas da textura para o shader de fragmento: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core in vec2 TexCoords; out vec4 color; uniform sampler2D text; uniform vec3 textColor; void main() { vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); color = vec4(textColor, 1.0) * sampled; }</span></span></code> </pre> <br><p>  O shader de fragmento aceita 2 variáveis ​​globais - uma imagem monocromática do glifo e a cor do próprio glifo.  Primeiro, amostramos o valor da cor do glifo.  Como os dados da textura são armazenados no componente vermelho da textura, apenas amostramos o componente <code>r</code> como o valor da transparência.  Alterando a transparência da cor, a cor resultante será transparente para o plano de fundo do glifo e opaca para os pixels reais do glifo.  Também multiplicamos as cores RGB pela variável textColor para alterar a cor do texto. </p><br><p>  Mas, para que nosso mecanismo funcione, você precisa ativar a mistura: </p><br><pre> <code class="cpp hljs">glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre> <br><p>  Como matriz de projeção, teremos uma matriz de projeção ortográfica.  Para desenhar texto, de fato, uma matriz de perspectiva não é necessária e o uso da projeção ortográfica também nos permite especificar todas as coordenadas de vértices nas coordenadas da tela se definirmos a matriz assim: </p><br><pre> <code class="cpp hljs">glm::mat4 projection = glm::ortho(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">800.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">600.0f</span></span>);</code> </pre> <br><p>  Definimos a parte inferior da matriz como <code>0.0f</code> , a parte superior para a altura da janela.  Como resultado, a coordenada <code>y</code> leva valores da parte inferior da tela ( <code>y = 0</code> ) para a parte superior da tela ( <code>y = 600</code> ).  Isso significa que o ponto <code>(0, 0)</code> indica e o canto inferior esquerdo da tela. </p><br><p>  Em conclusão, crie VBO e VAO para desenhar os quadrângulos.  Aqui reservamos memória suficiente no VBO para que possamos atualizar os dados para desenhar caracteres. </p><br><pre> <code class="cpp hljs">GLuint VAO, VBO; glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat) * <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, GL_DYNAMIC_DRAW); glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">0</span></span>); glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat), <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Um quadrilátero plano requer 6 vértices de 4 números de ponto flutuante, portanto reservamos <code>6 * 4 = 24</code> flutuações de memória.  Como vamos alterar os dados dos vértices com bastante frequência, alocamos memória usando <code>GL_DYNAMIC_DRAW</code> . </p><br><h4 id="vyvod-stroki-teksta-na-ekran">  Exibir uma linha de texto na tela </h4><br><p>  Para exibir uma linha de texto, extraímos a estrutura de <code>Character</code> correspondente ao símbolo e calculamos as dimensões do quadrilátero a partir das métricas do símbolo.  A partir das dimensões calculadas do quadrilátero, <code>glBufferSubData</code> criamos um conjunto de 6 vértices e atualizamos os dados do vértice usando <code>glBufferSubData</code> . </p><br><p>  Por conveniência, <code>RenderText</code> função <code>RenderText</code> que desenhe uma sequência de caracteres: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader &amp;s, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Activate corresponding render state s.Use(); glUniform3f(glGetUniformLocation(s.Program, "textColor"), color.x, color.y, color.z); glActiveTexture(GL_TEXTURE0); glBindVertexArray(VAO); // Iterate through all characters std::string::const_iterator c; for (c = text.begin(); c != text.end(); c++) { Character ch = Characters[*c]; GLfloat xpos = x + ch.Bearing.x * scale; GLfloat ypos = y - (ch.Size.y - ch.Bearing.y) * scale; GLfloat w = ch.Size.x * scale; GLfloat h = ch.Size.y * scale; // Update VBO for each character GLfloat vertices[6][4] = { { xpos, ypos + h, 0.0, 0.0 }, { xpos, ypos, 0.0, 1.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos, ypos + h, 0.0, 0.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos + w, ypos + h, 1.0, 0.0 } }; // Render glyph texture over quad glBindTexture(GL_TEXTURE_2D, ch.textureID); // Update content of VBO memory glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); glBindBuffer(GL_ARRAY_BUFFER, 0); // Render quad glDrawArrays(GL_TRIANGLES, 0, 6); // Now advance cursors for next glyph (note that advance is number of 1/64 pixels) x += (ch.Advance &gt;&gt; 6) * scale; // Bitshift by 6 to get value in pixels (2^6 = 64) } glBindVertexArray(0); glBindTexture(GL_TEXTURE_2D, 0); }</span></span></code> </pre> <br><p>  O conteúdo da função é relativamente claro: o cálculo da origem, tamanhos e vértices do quadrilátero.  Observe que multiplicamos cada métrica por <code>scale</code> .  Depois disso, atualize o VBO e desenhe um quad. </p><br><p>  Esta linha de código requer alguma atenção: </p><br><pre> <code class="cpp hljs">GLfloat ypos = y - (ch.Size.y - ch.Bearing.y);</code> </pre> <br><p>  Alguns caracteres, como <code>p</code> e <code>g</code> , são desenhados visivelmente abaixo da linha de base, o que significa que o quad deve ser visivelmente mais baixo que o parâmetro <code>y</code> da função <code>RenderText</code> .  O deslocamento exato <code>y_offset</code> pode ser expresso a partir de métricas de glifo: </p><br><p><img src="https://habrastorage.org/webt/2m/kp/g2/2mkpg2lb3jrfhl-zt9elefuopek.png"></p><br><p>  Para calcular o deslocamento, precisamos de <s>braços retos para</s> descobrir a distância em que o símbolo está localizado abaixo da linha de base.  Esta distância é mostrada pela seta vermelha.  Obviamente, <code>y_offset = bearingY - height</code> e <code>ypos = y + y_offset</code> . </p><br><p>  Se tudo for feito corretamente, você poderá exibir o texto na tela assim: </p><br><pre> <code class="cpp hljs">RenderText(shader, <span class="hljs-string"><span class="hljs-string">"This is sample text"</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); RenderText(shader, <span class="hljs-string"><span class="hljs-string">"(C) LearnOpenGL.com"</span></span>, <span class="hljs-number"><span class="hljs-number">540.0f</span></span>, <span class="hljs-number"><span class="hljs-number">570.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.9f</span></span>));</code> </pre> <br><p>  O resultado deve ficar assim: </p><br><p><img src="https://habrastorage.org/webt/dq/xs/uf/dqxsufeshmfga1wyzr1dl8amjes.png"></p><br><p>  Um exemplo de código está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> (link para o site do autor original). </p><br><p>  Para entender quais quadrângulos são desenhados, desative a mesclagem: </p><br><p><img src="https://habrastorage.org/webt/up/uc/fh/upucfh3hztm2du_zx7uc2wtiaby.png"></p><br><p>  A partir desta figura, é óbvio que a maioria dos quadrângulos está no topo de uma linha de base imaginária, embora alguns caracteres, como <code>(</code> e <code>p</code> , tenham sido deslocados para baixo. </p><br><h1 id="chto-zhe-dalee">  O que vem depois? </h1><br><p>  Este artigo mostrou como renderizar fontes TrueType com o FreeType.  Essa abordagem é flexível, escalável e eficiente em várias codificações de caracteres.  No entanto, essa abordagem pode ser muito pesada para o seu aplicativo, pois uma textura é criada para cada personagem.  As fontes de bitmap produtivas são preferidas porque temos uma textura para todos os glifos.  A melhor abordagem é combinar as duas abordagens e obter o melhor: imediatamente, gere uma fonte raster a partir de glifos baixados usando o FreeType.  Isso salvará o renderizador de inúmeras trocas de texturas e, dependendo do pacote de texturas, aumentará o desempenho. </p><br><p>  Mas o FreeType tem mais uma desvantagem: glifos de tamanho fixo, o que significa que, à medida que o tamanho do glifo renderizado aumenta, podem aparecer etapas na tela e o glifo pode parecer desfocado quando girado.  A Valve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20120815035559/">resolveu</a> (link para o arquivo da web) esse problema há vários anos usando campos de distância assinados.  Eles se saíram muito bem e mostraram isso em aplicativos 3D. </p><br><p>  <strong>PS</strong> : Temos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">telegrama conf</a> para coordenação de transferências.  Se você tem um desejo sério de ajudar com a tradução, é bem-vindo! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt473990/">https://habr.com/ru/post/pt473990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt473980/index.html">Tecnologia e o mundo real: 4 startups que estão mudando o futuro do design de interiores</a></li>
<li><a href="../pt473982/index.html">NB-IoT: como funciona? Parte 3: SCEF - uma única janela de acesso aos serviços do operador</a></li>
<li><a href="../pt473984/index.html">Data Science Digest (outubro de 2019)</a></li>
<li><a href="../pt473986/index.html">“Meu sonho é ver uma pessoa através das árvores” - fundadora da Lisa Alert sobre as modernas tecnologias de pesquisa</a></li>
<li><a href="../pt473988/index.html">Otimizando a Distribuição do Servidor nos Racks</a></li>
<li><a href="../pt473992/index.html">Visão geral de protocolos modernos em sistemas de automação industrial</a></li>
<li><a href="../pt473994/index.html">Carregamento de script moderno</a></li>
<li><a href="../pt473998/index.html">Holanda, ou lá e volta</a></li>
<li><a href="../pt474000/index.html">IQBX - projetista eletromecânico para clubes e entusiastas de bricolage [ideia conceitual]</a></li>
<li><a href="../pt474004/index.html">De Norilsk a Riyadh: Um exemplo real para os cartões de memória microSD UHS-I de temperatura industrial da Kingston</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>