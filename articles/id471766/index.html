<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧🏿 🏪 💰 Penanganan kesalahan Kotlin / Java: bagaimana melakukannya dengan benar? 📔 🖖 👩🏿‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sumber 


 Penanganan kesalahan dalam pengembangan apa pun memainkan peran penting. Hampir semuanya bisa salah dalam program: pengguna akan memasukkan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penanganan kesalahan Kotlin / Java: bagaimana melakukannya dengan benar?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/471766/"><img src="https://habrastorage.org/webt/hw/w3/mc/hww3mcjps5hwhykuwyzwj8upunu.jpeg"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> </p><br><p>  Penanganan kesalahan dalam pengembangan apa pun memainkan peran penting.  Hampir semuanya bisa salah dalam program: pengguna akan memasukkan data yang salah, atau mereka dapat datang melalui http, atau kami membuat kesalahan saat menulis serialisasi / deserialisasi dan selama pemrosesan program macet dengan kesalahan.  Ya, ini mungkin kehabisan ruang disk. </p><br><div class="spoiler">  <b class="spoiler_title">spoiler</b> <div class="spoiler_text"><p>  ¯_ (ツ) _ / ¯, tidak ada satu cara, dan dalam setiap situasi tertentu Anda harus memilih opsi yang paling sesuai, tetapi ada rekomendasi tentang bagaimana melakukannya dengan lebih baik. </p></div></div><a name="habracut"></a><br><h3 id="predislovie">  Kata Pengantar </h3><br><p>  Sayangnya (atau hanya kehidupan seperti itu?), Daftar ini terus berlanjut.  Pengembang terus-menerus perlu memikirkan fakta bahwa di suatu tempat suatu kesalahan dapat terjadi, dan ada 2 situasi: </p><br><ul><li>  ketika kesalahan yang diharapkan terjadi dalam memanggil fungsi yang telah kami sediakan dan dapat mencoba memproses; </li><li>  ketika kesalahan tak terduga terjadi selama operasi yang tidak kami perkirakan. </li></ul><br><p>  Dan jika kesalahan yang diharapkan setidaknya dilokalkan, maka sisanya dapat terjadi hampir di mana-mana.  Jika kami tidak memproses sesuatu yang penting, maka kami bisa saja crash dengan kesalahan (meskipun perilaku ini tidak cukup dan Anda perlu setidaknya menambahkan pesan ke log kesalahan).  Tetapi jika saat ini pembayaran sedang diproses dan Anda tidak bisa jatuh, tetapi setidaknya Anda perlu mengembalikan respons tentang operasi yang gagal? </p><br><p>  Sebelum kita melihat cara untuk menangani kesalahan, beberapa kata tentang Pengecualian (pengecualian): </p><br><h3 id="exception">  Pengecualian </h3><br><img src="https://habrastorage.org/webt/hn/mx/yz/hnmxyzwyfbelfe32oqi1nyite4o.png"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> </p><br><p> Hierarki pengecualian dijelaskan dengan baik dan Anda dapat menemukan banyak informasi tentangnya, sehingga tidak masuk akal untuk melukisnya di sini.  Apa yang kadang-kadang masih menyebabkan diskusi panas <code>checked</code> dan <code>unchecked</code> kesalahan.  Dan meskipun mayoritas menerima pengecualian yang <code>unchecked</code> sebagai pilihan (di Kotlin tidak ada pengecualian yang <code>checked</code> sama sekali), tidak semua orang setuju dengan ini. </p><br><p>  Pengecualian yang <code>checked</code> benar-benar memiliki niat baik untuk menjadikannya mekanisme penanganan kesalahan yang mudah, tetapi kenyataannya membuat penyesuaiannya, meskipun gagasan untuk memasukkan semua pengecualian yang dapat dilemparkan dari fungsi ini ke dalam tanda tangan dapat dipahami dan logis. </p><br><p>  Mari kita lihat sebuah contoh.  Misalkan kita memiliki fungsi <code>method</code> yang dapat membuang <code>PanicException</code> diperiksa.  Fungsi seperti itu akan terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> PanicException </span></span>{ }</code> </pre> <br><p>  Dari deskripsinya, jelas bahwa dia bisa melempar pengecualian dan hanya ada satu pengecualian.  Apakah terlihat cukup nyaman?  Dan sementara kami memiliki program kecil, itu saja.  Tetapi jika program sedikit lebih besar dan ada lebih banyak fungsi seperti itu, maka beberapa masalah muncul. </p><br><p>  Pengecualian yang diperiksa membutuhkan, dengan spesifikasi, bahwa <strong>semua</strong> pengecualian yang <strong>mungkin</strong> diperiksa (atau nenek moyang yang sama untuk mereka) terdaftar dalam tanda tangan fungsi.  Oleh karena itu, jika kita memiliki rantai panggilan <code>a</code> -&gt; <code>b</code> -&gt; <code>c</code> dan fungsi yang paling bersarang melempar semacam pengecualian, maka itu harus diletakkan untuk semua orang dalam rantai.  Dan jika ada beberapa pengecualian, maka fungsi paling atas dalam tanda tangan harus memiliki deskripsi semuanya. </p><br><p>  Jadi, ketika program menjadi lebih kompleks, pendekatan ini mengarah pada fakta bahwa pengecualian pada fungsi teratas secara bertahap runtuh ke leluhur yang sama dan akhirnya turun ke <code>Exception</code> .  Apa yang ada dalam formulir ini menjadi mirip dengan pengecualian yang <code>unchecked</code> dan meniadakan semua keuntungan dari pengecualian yang diperiksa. </p><br><p>  Dan mengingat bahwa program, sebagai organisme hidup, terus berubah dan berevolusi, hampir tidak mungkin untuk meramalkan sebelumnya apa pengecualian yang mungkin muncul di dalamnya.  Dan akibatnya, situasinya adalah ketika kita menambahkan fungsi baru dengan pengecualian baru, kita harus melalui seluruh rantai penggunaannya dan mengubah tanda tangan semua fungsi.  Setuju, ini bukan tugas yang paling menyenangkan (bahkan mengingat bahwa IDE modern melakukan ini untuk kita). </p><br><p>  Tapi yang terakhir, dan mungkin paku terbesar dalam pengecualian diperiksa "mengusir" lambdas dari Jawa 8. Tidak ada pengecualian diperiksa ¯_ (ツ) _ / ¯ dalam tanda tangan mereka (karena fungsi apa pun dapat disebut dalam lambda, dengan signature), jadi setiap panggilan fungsi dengan pengecualian yang dicentang dari lambda memaksanya untuk dibungkus dengan penerusan pengecualian sebagai tidak dicentang: </p><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).forEach(item -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { functionWithCheckedException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"rethrow"</span></span>, e); } });</code> </pre> <br><p>  Untungnya, dalam spesifikasi JVM tidak ada pengecualian yang diperiksa sama sekali, jadi di Kotlin Anda tidak dapat membungkus apa pun dalam lambda yang sama, tetapi cukup memanggil fungsi yang diinginkan. </p><br><div class="spoiler">  <b class="spoiler_title">meski terkadang ...</b> <div class="spoiler_text"><p>  Meskipun ini kadang-kadang menyebabkan konsekuensi yang tidak terduga, seperti, misalnya, operasi <code>@Transactional</code> dalam <code>Spring Framework</code> , yang "mengharapkan" hanya pengecualian yang tidak <code>unckecked</code> .  Tapi ini lebih merupakan fitur kerangka kerja, dan mungkin perilaku ini di Spring akan berubah dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah github</a> dalam waktu dekat. </p></div></div><br><p>  Pengecualian itu sendiri adalah objek khusus.  Selain fakta bahwa mereka dapat "dilempar" melalui metode, mereka juga mengumpulkan stacktrace saat pembuatan.  Fitur ini kemudian membantu dengan analisis masalah dan mencari kesalahan, tetapi juga dapat menyebabkan beberapa masalah kinerja jika logika aplikasi menjadi sangat terikat dengan pengecualian yang dilemparkan.  Seperti yang ditunjukkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> , menonaktifkan rakitan stacktrace dapat secara signifikan meningkatkan kinerja mereka dalam kasus ini, tetapi Anda harus menggunakan itu hanya dalam kasus luar biasa ketika benar-benar diperlukan! </p><br><h3 id="obrabotka-oshibok">  Menangani kesalahan </h3><br><p>  Hal utama yang harus dilakukan dengan kesalahan "tak terduga" adalah menemukan tempat di mana Anda dapat mencegatnya.  Dalam bahasa JVM, ini bisa berupa titik pembuatan aliran atau titik filter / entri ke metode http, di mana Anda dapat menempatkan try-catch dengan menangani kesalahan yang <code>unchecked</code> .  Jika Anda menggunakan kerangka kerja apa pun, maka kemungkinan besar kerangka kerja itu sudah memiliki kemampuan untuk membuat penangan kesalahan umum, seperti, misalnya, dalam Kerangka Kerja Spring, Anda dapat menggunakan metode dengan penjelasan <code>@ExceptionHandler</code> . </p><br><p>  Anda dapat "meningkatkan" pengecualian ke titik pemrosesan pusat yang tidak ingin kami tangani di tempat tertentu dengan melemparkan pengecualian yang tidak <code>unckecked</code> sama (ketika, misalnya, kami tidak tahu apa yang harus dilakukan di tempat tertentu dan bagaimana menangani kesalahan).  Tetapi metode ini tidak selalu cocok, karena kadang-kadang mungkin diperlukan untuk menangani kesalahan di tempat, dan Anda perlu memeriksa bahwa semua tempat panggilan fungsi diproses dengan benar.  Pertimbangkan cara untuk melakukan ini. </p><br><ol><li><p>  Masih menggunakan pengecualian dan try-catch yang sama: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { sum = calculateSum(a,b); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { sum = -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  Kelemahan utama adalah bahwa kita dapat "lupa" untuk membungkusnya dalam try-catch di tempat panggilan dan melewatkan upaya untuk memprosesnya di tempat, karena pengecualian akan melempar ke titik umum pemrosesan kesalahan.  Di sini kita bisa pergi ke pengecualian <code>checked</code> (untuk Jawa), tetapi kemudian kita akan mendapatkan semua kerugian yang disebutkan di atas.  Pendekatan ini mudah digunakan jika penanganan kesalahan tidak selalu diperlukan, tetapi dalam kasus yang jarang diperlukan. </p><br></li><li><p>  Gunakan kelas yang dimeteraikan sebagai hasil dari panggilan (Kotlin). <br>  Di Kotlin, Anda dapat membatasi jumlah ahli waris kelas, menjadikannya dapat dihitung pada tahap kompilasi - ini memungkinkan kompiler untuk memverifikasi bahwa semua opsi yang mungkin diuraikan dalam kode.  Di Jawa, Anda bisa membuat antarmuka umum dan beberapa keturunan, namun, kehilangan pemeriksaan tingkat kompilasi. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuccessResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>): Result() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExceptionResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exception: Exception): Result() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SuccessResult -&gt; result.value <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ExceptionResult -&gt; { result.exception.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre> <br><p>  Di sini kita mendapatkan sesuatu seperti pendekatan kesalahan <code>golang</code> ketika Anda perlu secara eksplisit memeriksa nilai yang dihasilkan (atau mengabaikan secara eksplisit).  Pendekatannya cukup praktis dan terutama nyaman ketika Anda perlu membuang banyak parameter di setiap situasi.  Kelas <code>Result</code> dapat diperluas dengan berbagai metode yang membuatnya lebih mudah untuk mendapatkan hasilnya dengan pengecualian melempar di atas, jika ada (mis. Kita tidak perlu menangani kesalahan di tempat panggilan).  Kelemahan utama hanya akan membuat benda-benda tak berguna menengah (dan entri yang sedikit lebih verbose), tetapi juga dapat dihapus menggunakan kelas <code>inline</code> (jika satu argumen cukup untuk kita).  dan, sebagai contoh khusus, ada kelas <code>Result</code> dari Kotlin.  Benar, ini hanya untuk penggunaan internal, seperti  di masa depan, implementasinya mungkin sedikit berubah, tetapi jika Anda ingin menggunakannya, Anda dapat menambahkan flag kompilasi <code>-Xallow-result-return-type</code> . </p><br></li><li><p>  Sebagai salah satu dari kemungkinan tipe klaim 2, penggunaan tipe dari pemrograman fungsional <code>Either</code> , yang dapat berupa hasil atau kesalahan.  Tipe itu sendiri dapat berupa kelas <code>sealed</code> atau kelas <code>inline</code> .  Di bawah ini adalah contoh penggunaan implementasi dari perpustakaan <code>arrow</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Left -&gt; { result.a.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Right -&gt; result.b }</code> </pre> <br><p>  <code>Either</code> cocok untuk mereka yang menyukai pendekatan fungsional dan yang suka membangun rantai panggilan. </p><br></li><li><p>  Gunakan <code>Option</code> atau jenis yang dapat dibatalkan dari Kotlin: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"some exception"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>?</code> </pre> <br><p>  Pendekatan ini cocok jika penyebab kesalahan tidak terlalu penting dan ketika itu hanya satu.  Jawaban kosong dianggap sebagai kesalahan dan dilempar lebih tinggi.  Catatan terpendek, tanpa membuat objek tambahan, tetapi pendekatan ini tidak selalu dapat diterapkan. </p><br></li><li><p>  Mirip dengan item 4, hanya menggunakan nilai hardcode sebagai penanda kesalahan: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(“error”) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span></code> </pre> <br><p>  Ini mungkin merupakan pendekatan penanganan kesalahan tertua yang kembali dari <code>C</code> (atau bahkan dari Algol).  Tidak ada overhead, hanya kode yang tidak sepenuhnya jelas (bersama dengan pembatasan pada pilihan hasil), tetapi, tidak seperti paragraf 4, dimungkinkan untuk membuat berbagai kode kesalahan jika diperlukan lebih dari satu pengecualian. </p><br></li></ol><br><h3 id="vyvody">  Kesimpulan </h3><br><p>  Semua pendekatan dapat digabungkan tergantung pada situasinya, dan tidak ada satu pun di antara mereka yang cocok dalam semua kasus. </p><br><p>  Jadi, misalnya, Anda dapat mencapai pendekatan <code>golang</code> untuk kesalahan menggunakan kelas <code>sealed</code> , dan jika tidak nyaman, beralihlah ke kesalahan yang <code>unchecked</code> . </p><br><p>  Atau, di sebagian besar tempat, <code>nullable</code> jenis <code>nullable</code> sebagai penanda bahwa tidak mungkin untuk menghitung nilai atau mendapatkannya dari suatu tempat (misalnya, sebagai indikator bahwa nilai tersebut tidak ditemukan dalam database). </p><br><p>  Dan jika Anda memiliki kode yang berfungsi penuh bersama dengan <code>arrow</code> atau pustaka sejenis lainnya, maka kemungkinan besar yang terbaik adalah menggunakan. </p><br><p>  Adapun http-server, paling mudah untuk meningkatkan semua kesalahan ke titik pusat dan hanya di beberapa tempat menggabungkan pendekatan <code>nullable</code> dengan kelas <code>sealed</code> . </p><br><p>  Saya akan senang melihat di komentar bahwa Anda menggunakan ini, atau mungkin ada metode penanganan kesalahan yang mudah? </p><br><p>  Dan terima kasih kepada semua orang yang membaca sampai akhir! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471766/">https://habr.com/ru/post/id471766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471748/index.html">Optimalisasi farmasi: apa yang kami lakukan dengan matematika</a></li>
<li><a href="../id471750/index.html">Manajemen Akses Privileged sebagai tugas prioritas dalam keamanan informasi (misalnya, Fudo PAM)</a></li>
<li><a href="../id471756/index.html">Bagaimana server dimulai</a></li>
<li><a href="../id471758/index.html">Bagaimana cara menerjemahkan teks ke bahasa lain?</a></li>
<li><a href="../id471760/index.html">Edward Snowden: The Battlefield - Enkripsi</a></li>
<li><a href="../id471770/index.html">Temui Big Data Tools: Spark dan Zeppelin Notebook Support di IntelliJ IDEA</a></li>
<li><a href="../id471772/index.html">Alat untuk meluncurkan dan mengembangkan aplikasi Java, kompilasi, eksekusi pada JVM</a></li>
<li><a href="../id471774/index.html">API Android Camera2 dari teko, bagian 2, menulis video</a></li>
<li><a href="../id471776/index.html">Laravel: jelaskan konsep dasarnya. Bagian Dua: Berlatih</a></li>
<li><a href="../id471778/index.html">Memecah Micosoft Lunix di HackQuest 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>