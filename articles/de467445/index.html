<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìå üçè üåº Schwer fassbare Liste der installierten Windows-Updates üéç ü§± üï•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haben Sie sich jemals gefragt, warum eine Liste der installierten Windows-Updates generiert wird? Und √ºber welche API soll es kommen? Ich werde versuc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schwer fassbare Liste der installierten Windows-Updates</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467445/">  Haben Sie sich jemals gefragt, warum eine Liste der installierten Windows-Updates generiert wird?  Und √ºber welche API soll es kommen?  Ich werde versuchen, in dieser kleinen Studie Antworten auf diese und andere aufkommende Fragen zu geben. <br><br><img src="https://habrastorage.org/webt/bb/rl/zc/bbrlzcws8p-tumczrzauuvx2l7w.jpeg"><br><a name="habracut"></a><br><h2>  Hintergrund oder wie alles begann. </h2><br>  Jedes Jahr findet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in unserem Unternehmen</a> eine Konferenz junger Fachkr√§fte statt, auf der jeder Teilnehmer das Problem einer Abteilung l√∂sen kann (eine Themenliste wird im Voraus vorgeschlagen).  Und die Abteilung f√ºr SPAS (Software- und Hardware-Support) hatte die folgende Aufgabe, die mich interessierte, und es erm√∂glichte mir, wieder zur Programmierung zur√ºckzukehren (leider arbeite ich derzeit in diesem Unternehmen als einfacher Betreiber von NPPS). <br><br>  Bisher wurden f√ºr jedes "TO" mit Hilfe von WSUS alle ver√∂ffentlichten Updates abgerufen und an alle Computer verteilt.  In regelm√§√üigen Abst√§nden erschienen auch TSB (Technical Service Bulletins), die darauf hinwiesen, dass die erforderlichen Updates in Form von isolierten Paketen installiert werden mussten.  Infolgedessen sammeln wir Updates, die in WSUS nicht nachverfolgt werden k√∂nnen, aber nur √ºber das Control Panel im Abschnitt "Installierte Updates" angezeigt werden k√∂nnen. <br><br><br><br><img src="https://habrastorage.org/webt/v6/9f/kb/v69fkb557stfaokhfjpoccmnuma.png" alt="Visuelles Aktualisierungsschema"><br><br>  Es gibt Situationen, in denen die Workstation oder der Server "abst√ºrzt" und Sie sie von einem vor einiger Zeit erstellten Image wiederherstellen m√ºssen.  Bei der Wiederherstellung von einem Image besteht die M√∂glichkeit, dass wir die ben√∂tigten Updates (die in Form von isolierten Paketen geliefert wurden) verlieren, die vor dem Absturz des Computers installiert wurden.  So detailliert wie m√∂glich erkl√§rt, da die Klarstellungen bereits ein Gesch√§ftsgeheimnis sein werden. <br><br>  Aus diesem Grund entstand die Idee, ein Programm zu erstellen, mit dem diese Liste von Aktualisierungen (vorzugsweise <b>remote</b> √ºber das lokale Netzwerk) extrahiert, in eine Datei / Datenbank geschrieben, die aktuelle Liste mit einer bestimmten Vorlage verglichen und √ºber eines der Protokolle - SNMP, OPC - eine Nachricht an das SCADA-System gesendet werden kann. <br><br>  Wie Sie vielleicht aus dem Titel des Artikels erraten haben, hatte ich bereits eine schwierige Aufgabe, die Methode zum Abrufen von Listen auszuw√§hlen.  Wie √ºblich habe ich mich entschlossen, in der Suchmaschine nach dem richtigen zu suchen, Fragen zu speziellen Ressourcen gestellt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> , aus irgendeinem Grund mochte der Stapel√ºberlauf auf Englisch meine Frage nicht und musste gel√∂scht werden), aber alle Antworten ergaben nicht das gew√ºnschte Ergebnis.  Deshalb musste ich es selbst herausfinden, worauf sp√§ter noch eingegangen wird. <br><br><h2>  Konsolenbefehle </h2><br>  Beginnen wir mit einem einfachen und nutzen Sie das, was Windows uns bietet, ohne Tools von Drittanbietern zu verwenden.  Dies kann mit den folgenden Befehlen erfolgen: <br><br><ul><li>  wmic qfe liste </li><li>  systeminfo </li><li>  dism / online / get-packages </li><li>  √ºber PowerShell: <br><br><ul><li>  <b>Holen Sie sich Hotfix</b> </li><li>  <b>Get-SilWindowsUpdate</b> (nur in Server-Editionen verf√ºgbar) </li><li>  <b>Get-WmiObject -Class win32_quickfixengineering</b> - durch Zugriff auf die WMI-Klasse win32_quickfixengineering (√ºber WMI etwas sp√§ter) </li></ul><br></li></ul><br><br>  Sie k√∂nnen die Liste √ºber die grafische Oberfl√§che √ºber das Standardelement der Systemsteuerung "Software" abrufen, aber wir k√∂nnen von dort nichts kopieren.  Jedes Control Panel-Tool wird durch eine .cpl-Datei im Ordner Windows \ System dargestellt.  CPL-Dateien im Windows-Systemordner werden beim Starten der Systemsteuerung automatisch heruntergeladen.  Die Datei Appwiz.cpl ist f√ºr das Programmelement verantwortlich.  Seine Analyse f√ºhrte zu nichts. <br><br>  Die Ausgabe des Konsolenbefehls kann in eine Datei umgeleitet und dann analysiert werden. Dies ist jedoch falsch, plus ein Programmaufruf (nach den Regeln des Sicherheitsrates funktioniert dies nicht) und es besteht keine Frage, ob die Liste remote empfangen werden soll.  Daher schlage ich vor, dass Sie einfach die Befehle aufrufen, die Anzahl der Aktualisierungen in jeder Liste mit der Liste √ºber die Systemsteuerung vergleichen und unsere Untersuchung fortsetzen. <br><br>  Formal k√∂nnen alle Methoden zum Abrufen der Liste der Aktualisierungen in zwei Gruppen unterteilt werden: lokal und Netzwerk. <br><br><img src="https://habrastorage.org/webt/jw/jt/nf/jwjtnfe3m0dqr_cc9q9xybhf1ka.png" alt="Lokale und Netzwerkmethoden zum Abrufen von Informationen"><br><br>  Alle Methoden wurden an sauberen Systemabbildern (Windows 7, 8, Server 2012 R2) mit integrierten Updates getestet. Nach jedem Update √ºber das Update Center von offiziellen Microsoft-Servern wurde eine zus√§tzliche √úberpr√ºfung durchgef√ºhrt.  Lassen Sie uns n√§her auf jeden einzelnen eingehen. <br><br><h2>  WUA </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WUApi</a> (Windows Update Agent-API) - Verwenden der Windows Update Agent-API.  Die naheliegendste Option, deren Name f√ºr sich selbst spricht.  Wir werden daf√ºr die Wuapi.dll-Bibliothek verwenden. <br><blockquote>  Hinweis: Im Folgenden werde ich zur Vereinfachung alle Ergebnisse in die Liste einbetten.  Das mag nicht rational sein, aber dann schien es mir eine gute Idee zu sein. </blockquote><div class="spoiler">  <b class="spoiler_title">Implementierungsbeispiel</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WUApiLib; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listUpdateHistory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//WUApi List&lt;string&gt; result = new List&lt;string&gt;(200); try { UpdateSession uSession = new UpdateSession(); IUpdateSearcher uSearcher = uSession.CreateUpdateSearcher(); uSearcher.Online = false; ISearchResult sResult = uSearcher.Search("IsInstalled=1 And IsHidden=0"); string sw = "   WUApi: " + sResult.Updates.Count; result.Add(sw); foreach (WUApiLib.IUpdate update in sResult.Updates) { result.Add(update.Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre> <br></div></div><br>  Es gibt eine zweite Variante dieser Methode: <b>Update-Sitzung</b> - Empfangen von Informationen durch Herstellen einer Verbindung zur Windows Update Agent-Update-Sitzung (in diesem Fall arbeiten wir nicht direkt mit der Bibliothek). <br><br><div class="spoiler">  <b class="spoiler_title">Implementierungsbeispiel</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sessionlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pc</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    object sess = null; object search = null; object coll = null; try { sess = Activator.CreateInstance(Type.GetTypeFromProgID("Microsoft.Update.Session", pc)); search = (sess as dynamic).CreateUpdateSearcher(); int n = (search as dynamic).GetTotalHistoryCount(); int kol = 0; //coll = (search as dynamic).QueryHistory(1, n); coll = (search as dynamic).QueryHistory(0, n); result.Add("  Update.Session: " + n); foreach (dynamic item in coll as dynamic) { if (item.Operation == 1) result.Add(item.Title); kol++; //Console.WriteLine(": " + kol); } result.Add("  : " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } finally { if (sess != null) Marshal.ReleaseComObject(sess); if (search != null) Marshal.ReleaseComObject(search); if (coll != null) Marshal.ReleaseComObject(coll); } return result; }</span></span></code> </pre><br></div></div><br>  Microsoft schl√§gt die Remote- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendung der API vor</a> . <br><br>  Die Hauptnachteile dieser beiden Methoden bestehen darin, dass Sie keine KB-Fixes finden k√∂nnen, die nicht √ºber Windows Update verteilt werden.  Sie k√∂nnen nur sehen, was durch den Update-Agenten selbst gegangen ist, dh diese Option passt nicht zu uns. <br><br><h2>  DISM </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wartung und Verwaltung von Bereitstellungsimages</a> ist ein Befehlszeilentool, mit dem ein Windows-Image gewartet oder ein Image einer Windows-Vorinstallationsumgebung (Windows PE) vorbereitet werden kann.  Es ist ein Ersatz f√ºr Package Manager (Pkgmgr.exe), PEimg und Intlcfg. <br><br>  Dieses Dienstprogramm wird verwendet, um Updates und Service Packs in das System-Image zu integrieren.  Windows-Updates sind separate Module, die auf verschiedene Arten dargestellt werden k√∂nnen: <br><br><ul><li>  CAB-Dateien (Kabinett) - Archive.  Entwickelt f√ºr die Verteilung und Installation mit Windows Update-Modulen in einem automatisierten Modus. </li><li>  MSU-Dateien (Microsoft Update Standalone Package) - ausf√ºhrbare Dateien.  Entwickelt f√ºr die Verteilung und Installation durch Benutzer selbst im manuellen Modus √ºber den Microsoft Update-Katalog.  Tats√§chlich handelt es sich um eine Paketmenge, die aus CAB-, XML- und TXT-Dateien besteht. </li></ul><br>  Der zuvor erw√§hnte <b>Befehl dism / online / get-packages</b> zeigt grundlegende Informationen zu allen Paketen im wim-Image / aktuellen System an.  Microsoft hat sich um uns gek√ºmmert und bietet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NuGet-Pakete</a> f√ºr die bequeme Verwendung der API an. <br><br><div class="spoiler">  <b class="spoiler_title">Implementierungsbeispiel</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.Dism; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DISMlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">220</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DismApi.Initialize(DismLogLevel.LogErrors); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dismsession = DismApi.OpenOnlineSession(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listupdate = DismApi.GetPackages(dismsession); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ab = listupdate.Count; <span class="hljs-comment"><span class="hljs-comment">//Console.WriteLine("   DISM: " + ab); string sw = "   DISM: " + ab; result.Add(sw); foreach (DismPackage feature in listupdate) { result.Add(feature.PackageName); //result.Add($"[ ] {feature.PackageName}"); //result.Add($"[ ] {feature.InstallTime}"); //result.Add($"[ ] {feature.ReleaseType}"); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  Die Anzahl der Aktualisierungen stimmte mit der Anzahl aus der Liste der Systemsteuerung bis zur ersten Aktualisierung √ºber das Kontrollzentrum √ºberein - danach wurde die Anzahl der Aktualisierungen geringer (214, 209), obwohl sie logischerweise zunehmen sollten.  Ausgabebeispiele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vor dem Aktualisieren</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nach dem Aktualisieren</a> . <br><br>  Was der Grund daf√ºr ist, kann ich nur spekulieren - vielleicht haben einige Updates die vorherigen ersetzt, daher wurde die Anzahl geringer. <br><br>  Wenig sp√§ter stie√ü ich auf ein Dienstprogramm aus dem chinesischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DISM ++</a> , das nicht auf der DISM-API oder der DISM Core-API basiert, aber in den Bibliotheken nicht die Methoden haben, die ich brauche, also habe ich diese Idee aufgegeben und weiter gesucht. <br><br><h2>  WSUS </h2><br>  Windows Server Update Services ( <a href="">WSUS</a> ) ist ein Server zum Aktualisieren von Betriebssystemen und Microsoft-Produkten.  Der Update-Server wird mit der Microsoft-Website synchronisiert und l√§dt Updates herunter, die im Unternehmens-LAN verteilt werden k√∂nnen.  Wieder ein spezielles Tool, das f√ºr die Arbeit mit Updates entwickelt wurde. <br><br>  Wird nur auf Server-Editionen von Windows verteilt, daher wurde der folgende Stand bereitgestellt: <br><br><ul><li>  Das Hauptsystem ist Windows Server 2016. </li><li>  √úber das Hyper-V-Virtualisierungssystem wurden zwei Client-Betriebssysteme bereitgestellt: <br><ul><li>  Windows 8.1 </li><li>  Windows 7 </li></ul><br></li></ul><br>  Alle Systeme sind mit einem einzigen virtuellen lokalen Netzwerk verbunden, jedoch <u>ohne Zugang zum Internet</u> . <br><br><div class="spoiler">  <b class="spoiler_title">Einige Tipps</b> <div class="spoiler_text">  Um dem neuen System keine Festplattenpartition zuzuweisen, verwende ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WinNTSetup</a> und installiere das System auf VHD-Festplatten. Der Bootloader, der mit Windows 7 (Professional / Ultimate-Editionen) beginnt, kann hervorragend von einem Festplatten-Image booten.  Die so erhaltenen Scheiben k√∂nnen sicher in Hyper-V verwendet werden - Sie t√∂ten zwei Fliegen gleichzeitig mit einer Klappe.  Denken Sie daran, vorab eine Kopie des BCD-Repositorys mit dem <b>Befehl bcdedit / export e: \ bcd_backup.bcd zu erstellen</b> . <br><br>  Ich wollte AD nicht f√ºr die Verteilung von Updates konfigurieren, daher habe ich den Pfad zum WSUS-Server einfach in Gruppenrichtlinien registriert: <br><br><img src="https://habrastorage.org/webt/j6/7f/v0/j67fv0mdw8mr8l0m73fowtmm238.png" alt="Einstellungen"><br><br>  Achten Sie unbedingt auf den Port, da ich aufgrund eines Tippfehlers (8350 statt 8530) keine Updates auf Client-Computern erhalten konnte, obwohl alles korrekt ausgef√ºhrt wurde.  Au√üerdem unterscheiden sich die Namen der Elemente in Gruppenrichtlinien unter Windows 7 und Windows 8. <br><br>  Um den Bericht √ºber WSUS zu erhalten, m√ºssen Sie das Paket zus√§tzlich installieren - das System benachrichtigt Sie dar√ºber. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Und jetzt ein kleiner Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      using Microsoft.UpdateServices.Administration; public static List&lt;string&gt; GetWSUSlist(params string[] list) { List&lt;string&gt; result = new List&lt;string&gt;(200); //    string namehost = list[0]; // ,     string = "example1"; string servername = list[1]; //  string = "WIN-E1U41FA6E55"; string Username = list[2]; string Password = list[3]; try { ComputerTargetScope scope = new ComputerTargetScope(); IUpdateServer server = AdminProxy.GetUpdateServer(servername, false, 8530); ComputerTargetCollection targets = server.GetComputerTargets(scope); // Search targets = server.SearchComputerTargets(namehost); // To get only on server FindTarget method IComputerTarget target = FindTarget(targets, namehost); result.Add(" : " + target.FullDomainName); IUpdateSummary summary = target.GetUpdateInstallationSummary(); UpdateScope _updateScope = new UpdateScope(); // See in UpdateInstallationStates all other properties criteria //_updateScope.IncludedInstallationStates = UpdateInstallationStates.Downloaded; UpdateInstallationInfoCollection updatesInfo = target.GetUpdateInstallationInfoPerUpdate(_updateScope); int updateCount = updatesInfo.Count; result.Add(" -   - " + updateCount); foreach (IUpdateInstallationInfo updateInfo in updatesInfo) { result.Add(updateInfo.GetUpdate().Title); } } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; } public static IComputerTarget FindTarget(ComputerTargetCollection coll, string computername) { foreach (IComputerTarget target in coll) { if (target.FullDomainName.Contains(computername.ToLower())) return target; } return null; }</span></span></code> </pre><br></div></div><br>  Da es kein Internet gibt, sieht die Situation mit Updates wie im folgenden Screenshot aus: <br><br><img src="https://habrastorage.org/webt/az/gc/le/azgclepy6kznsibmilm1psoewa8.png"><br><br>  Das Verhalten ist √§hnlich wie bei WUApi - wenn Updates nicht durchlaufen wurden, wissen sie nichts dar√ºber.  Daher funktioniert diese Methode nicht mehr. <br><br><h2>  Wmi </h2><br>  Windows Management Instrumentation ( <b>WMI</b> ) in der w√∂rtlichen √úbersetzung ist ein Windows-Verwaltungs-Toolkit. <br><br>  WMI ist ein von Microsoft implementierter Standard f√ºr die Verwaltung eines Unternehmens <u>√ºber das Internet</u> zur zentralen Verwaltung und √úberwachung verschiedener Teile einer Computerinfrastruktur, auf der eine Windows-Plattform ausgef√ºhrt wird.  WMI ist ein offenes einheitliches System von Zugriffsschnittstellen zu allen Parametern des Betriebssystems, der Ger√§te und Anwendungen, die darin ausgef√ºhrt werden. <br><br>  Mit dieser Methode k√∂nnen Sie Daten sowohl vom lokalen Computer als auch remote im lokalen Netzwerk empfangen.  F√ºr den Zugriff auf WMI-Objekte wird eine bestimmte WMI-Abfragesprache (WQL) verwendet, eine der Varianten von SQL.  Wir erhalten die Liste √ºber die WMI-Klasse <b>win32_quickfixengineering</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Implementierungsbeispiel</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Management; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWMIlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] list</span></span></span><span class="hljs-function">)</span></span> { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ManagementScope Scope; string ComputerName = list[0]; string Username = list[1]; string Password = list[2]; int kol = 0; if (!ComputerName.Equals("localhost", StringComparison.OrdinalIgnoreCase)) { //    ,      //  . ConnectionOptions Conn = new ConnectionOptions(); Conn.Username = Username; Conn.Password = Password; //      ¬´NTLMDOMAIN:¬ª  NTLM  ,       NTLM. Conn.Authority = "ntlmdomain:DOMAIN"; Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), Conn); } else Scope = new ManagementScope(String.Format("\\\\{0}\\root\\CIMV2", ComputerName), null); try { Scope.Connect(); ObjectQuery Query = new ObjectQuery("SELECT * FROM Win32_QuickFixEngineering"); ManagementObjectSearcher Searcher = new ManagementObjectSearcher(Scope, Query); foreach (ManagementObject WmiObject in Searcher.Get()) { result.Add(WmiObject["HotFixID"].ToString()); //Console.WriteLine("{0,-35} {1,-40}", "HotFixID", WmiObject["HotFixID"]);// String //result.Add(); /*result.Add("{0,-17} {1}", " : ", WmiObject["Description"]); result.Add("{0,-17} {1}", ": ", WmiObject["Caption"]); result.Add("{0,-17} {1}", " : ", WmiObject["InstalledOn"]);*/ kol++; } result.Add("  " + kol); } catch (Exception ex) { result.Add("-   : " + ex.Message); } return result; }</span></span></code> </pre><br></div></div><br>  Quantitativ stimmt alles √ºberein (auch nach Aktualisierungen), daher wurde beschlossen, diese Methode zu verwenden.  F√ºr die programmgesteuerte Erstellung von WMI-Anforderungen empfehle ich Ihnen, das folgende Dienstprogramm zu verwenden - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WMI Delphi Code Creator</a> .  Dank ihr habe ich meinen Code etwas anders betrachtet und beschlossen, ein Leerzeichen aus diesem Programm zu verwenden. <br><br><h2>  XML </h2><br>  Die mit der WMI-Methode erhaltenen Daten haben mich nicht aufgehalten, und ich habe mich f√ºr das ‚ÄûSurface Reverse Engineering‚Äú entschieden.  Wir werden das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Process Monitor-</a> Dienstprogramm aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sysinternals Suite-</a> Softwaresammlung verwenden, um Dateien und Registrierungszweige zu identifizieren, die beim Aufrufen der oben aufgef√ºhrten Konsolenbefehle und beim Zugriff auf das Element "Installierte Updates" √ºber die Systemsteuerung verwendet werden. <br><br>  Meine Aufmerksamkeit wurde auf die Datei wuindex.xml im Ordner C: \ Windows \ servicing \ Packages \ gelenkt.  Um es zu analysieren, wurde das folgende Programm geschrieben: <br><br><div class="spoiler">  <b class="spoiler_title">Anwendungsbeispiel f√ºr die Konsole</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Xml; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text.RegularExpressions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">XMLviewer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> writePath = AppDomain.CurrentDomain.BaseDirectory + <span class="hljs-string"><span class="hljs-string">"XML  "</span></span> + Environment.MachineName + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(writePath)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  txt "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" XML .txt ,   "</span></span>); File.Delete(writePath); } <span class="hljs-comment"><span class="hljs-comment">//      KB Regex regex = new Regex(@"KB[0-9]{6,7}"); //Regex(@"(\w{2}\d{6,7}) ?"); //SortedSet    ,     ""     SortedSet&lt;string&gt; spisok = new SortedSet&lt;string&gt;(); XmlDocument xDoc = new XmlDocument(); string path = "C:\\Windows\\servicing\\Packages\\wuindex.xml"; //   xml xDoc.Load(path); int kol = 0; //-  int total = 0; //-    xml int total2 = 0; //-   XmlNodeList name = xDoc.GetElementsByTagName("Mappings"); foreach (XmlNode xnode in name) { //Console.WriteLine(xnode.Name); kol++; XmlNode attr = xnode.Attributes.GetNamedItem("UpdateId"); //Console.WriteLine(attr.Value); foreach (XmlNode childnode in xnode.ChildNodes) { XmlNode childattr = childnode.Attributes.GetNamedItem("Package"); total++; //Console.WriteLine(childattr.Value); MatchCollection matches = regex.Matches(childattr.Value); if (matches.Count &gt; 0) { foreach (Match match in matches) //Console.WriteLine(match.Value); spisok.Add(match.Value); } else { //Console.WriteLine("  "); } } } try { StreamWriter sw = new StreamWriter(writePath); foreach (string element in spisok) { //Console.WriteLine(element); sw.WriteLine(element); total2++; } sw.Close(); } catch (Exception ex) { Console.WriteLine(": " + ex.Message); } //Console.WriteLine("\n"); Console.WriteLine(" : " +kol); Console.WriteLine("    xml: " + total); Console.WriteLine(" KB : " + total2); Console.WriteLine("    ."); Console.Read(); } } }</span></span></code> </pre><br></div></div><br>  Leider ist diese Datei nicht auf allen Systemen zu finden, und das Prinzip ihrer Erzeugung und Aktualisierung ist mir ein R√§tsel geblieben.  Daher passt diese Methode auch hier nicht zu uns. <br><br><h2>  Cbs </h2><br>  Hier kommen wir zu dem, womit all diese Methoden verbunden sind.  Als ich die Analyse der Process Monitor-Protokolle fortsetzte, identifizierte ich die folgenden Ordner und Dateien. <br><br>  Die Datei <b>DataStore.edb im Ordner C: \ Windows \ SoftwareDistribution \ DataStore</b> .  Dies ist eine Datenbank, die den Verlauf aller Aktualisierungen der installierten Windows-Version enth√§lt, einschlie√ülich derjenigen, die nur in der Warteschlange stehen. <br><br>  Das Programm ESEDatabaseView wurde zum Analysieren der Datei DataStore.edb verwendet.  In der Datenbank befindet sich eine tbUpdates-Tabelle, deren Inhalt schwer zu interpretieren ist. <br><br><img src="https://habrastorage.org/webt/n4/1v/b0/n41vb0kmc5axymvp2gd3qax5bek.png" alt="TbUpdates-Tabelle in ESEDatabaseView"><br><br>  Nachdem ich auf den <b>TiWorker.exe-</b> Prozess aufmerksam gemacht wurde, der jedes Mal aufgerufen wurde, wenn ich ein Element in der Systemsteuerung √∂ffnete.  Er "ging" durch viele Ordner, von denen einer mich auf den richtigen Weg f√ºhrte. <br><br>  <b>C: \ Windows \ SoftwareDistribution</b> ist ein Ordner, in dem Windows Update Updates auf einen Computer herunterl√§dt und installiert. Au√üerdem werden Informationen zu allen zuvor installierten Updates gespeichert. <br><br>  WinSxS-Ordner unter <b>C: \ Windows \ winsxs</b> .  Dies ist der Dienstordner des Windows-Betriebssystems, in dem zuvor installierte Versionen von Systemkomponenten gespeichert werden.  Aufgrund des Vorhandenseins ist es bei Bedarf m√∂glich, ein Rollback auf eine √§ltere Version des Updates durchzuf√ºhren. <br><br>  <b>C: \ Windows \ servicing</b> - die Hauptkomponente des gesamten Systems, deren Name <b>Component-Based Servicing (CBS)</b> lautet. <br><br>  CBS ist ein komponentenbasierter Dienst, der Teil von Windows ist und in den Windows Update-Dienst integriert ist.  Im Gegensatz zum <b>FBS-Dienst</b> ( <b>File-Based Servicing)</b> (f√ºr Betriebssysteme vor Windows Vista), bei dem Dateien direkt in den Systemverzeichnissen aktualisiert wurden, f√ºhrte CBS eine ganze Hierarchie von Verzeichnissen und eine ganze Familie (Stapel) von Modulen / Dienstbibliotheken ein. <br><br>  <b>CbsApi.dll</b> ist die <b>Hauptbibliothek</b> f√ºr die CBS-Technologieunterst√ºtzung.  Es gibt keine offenen Methoden, daher konnte ich es nicht direkt verwenden.  Microsoft verwendet TrustedInstaller.exe und TiWorker.exe, um auf die Methoden dieser Bibliothek zuzugreifen, und zeigt bereits √ºber diese Prozesse die ben√∂tigten Daten an.  Datens√§tze werden in <b>C: \ Windows \ Logs \ CBS \ CBS.log verwaltet</b> . <br><br>  Zum Zeitpunkt der Erstellung des Prototyps des Programms (Sie k√∂nnen den Mai 2019 in den Screenshots sehen) gab es keine russischsprachigen Informationen √ºber CBS, aber Ende August gab es einen sehr guten Blog-Artikel - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://datadump.ru/component-based-servicing</a> .  Ein sehr interessanter Artikel, der meine Erfahrung best√§tigte und die notwendigen Informationen sammelte.  Und mehr zum Thema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.outsidethebox.ms/17988/</a> <br><br><h2>  Fazit </h2><br>  Microsoft hat die triviale Aufgabe, eine Liste mit Updates zu erhalten, zu kompliziert gemacht und diesen Prozess nicht ganz offensichtlich gemacht.  All dies geschieht aus Sicherheitsgr√ºnden, jedoch nicht aus Gr√ºnden der Benutzerfreundlichkeit.  Ich stimme dem Autor des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikels zu</a> - Vorhersehbarkeit und Transparenz fehlten beim Erhalt von Updates. <br><br>  Als Ergebnis der Studie wurde das folgende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programm</a> geschrieben, dessen Demonstration in diesem Video zu sehen ist: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SNxReaN4EKY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Pl√§ne hinzuzuf√ºgen: <br><br><ol><li>  Vergleichen der Liste der erforderlichen Aktualisierungen mit der empfangenen; </li><li>  Senden Sie das Ergebnis √ºber SNMP / OPC (wenn jemand Erfahrung hat, teilen Sie es in den Kommentaren mit); </li><li>  Organisieren Sie die Installation der fehlenden "Offline" -Updates aus dem angegebenen Ordner. </li></ol><br>  Wenn Sie mehr Methoden kennen, um nicht nur eine Liste mit Updates, sondern auch zus√§tzlichen Komponenten (Adobe Flash, Acrobat Reader usw.) zu erhalten, oder andere interessante Vorschl√§ge haben, schreiben Sie dar√ºber in den Kommentaren oder in privaten Nachrichten - ich freue mich √ºber Feedback .  Und nehmen Sie an der Umfrage zu diesem Artikel teil - damit ich wei√ü, ob meine Erfahrungen mit dem Habrahabr-Publikum interessant sein werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467445/">https://habr.com/ru/post/de467445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467429/index.html">Habrastatistik: Erkundung der am meisten und am wenigsten besuchten Abschnitte der Website</a></li>
<li><a href="../de467435/index.html">Wir senden Berichte von Veeam Agent Linux per Post oder per Telegramm</a></li>
<li><a href="../de467437/index.html">MVCC in PostgreSQL-1. Isolierung</a></li>
<li><a href="../de467439/index.html">Warum ist Vinyl zur√ºckgekommen und wie h√§ngen Streaming-Dienste damit zusammen?</a></li>
<li><a href="../de467443/index.html">Multimedia Center "Kodi" und Yocto Project</a></li>
<li><a href="../de467449/index.html">Erkennung von Schwachstellen und Bewertung der Resistenz gegen Hackerangriffe von Smartcards und Kryptoprozessoren mit integriertem Schutz</a></li>
<li><a href="../de467453/index.html">L√∂sung des Problems der Nummer 42 mit einem planetaren Supercomputer</a></li>
<li><a href="../de467455/index.html">QBS-Vorlage zum Programmieren von Mikrocontrollern in QtCreator am Beispiel von Milander-Controllern</a></li>
<li><a href="../de467457/index.html">Der Weg von der Operation zum Spieleentwickler oder die ersten Erfahrungen mit der mobilen Entwicklung auf Unity</a></li>
<li><a href="../de467459/index.html">Wie ein Mikrocontroller Daten mit 1,6 Gbit / s lesen kann</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>