<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòû üë∫ ü§±üèº Tecnolog√≠as utilizadas en el analizador de c√≥digo PVS-Studio para buscar errores y vulnerabilidades potenciales üêÇ üë®üèº üßëüèª‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una breve descripci√≥n de las tecnolog√≠as utilizadas en la herramienta PVS-Studio que puede detectar efectivamente una gran cantidad de patrones de err...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tecnolog√≠as utilizadas en el analizador de c√≥digo PVS-Studio para buscar errores y vulnerabilidades potenciales</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430604/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/4fa/337/7a14fa3372efbf1ac176cf551b982a81.png" alt="Tecnolog√≠a y magia"></div><br>  Una breve descripci√≥n de las tecnolog√≠as utilizadas en la herramienta PVS-Studio que puede detectar efectivamente una gran cantidad de patrones de error y vulnerabilidades potenciales.  El art√≠culo describe la implementaci√≥n del analizador para el c√≥digo C y C ++, sin embargo, la informaci√≥n anterior tambi√©n es v√°lida para los m√≥dulos responsables de analizar el c√≥digo C # y Java. <br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  Hay ideas err√≥neas de que los analizadores de c√≥digo est√°tico son programas bastante simples basados ‚Äã‚Äãen la b√∫squeda de patrones de c√≥digo utilizando expresiones regulares.  Esto est√° lejos de la verdad.  Adem√°s, identificar la gran mayor√≠a de los errores utilizando expresiones regulares simplemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no es posible</a> . <br><br>  El error surgi√≥ sobre la base de la experiencia de los programadores al trabajar con algunas herramientas que exist√≠an hace 10-20 a√±os.  El trabajo de las herramientas a menudo se redujo a encontrar patrones peligrosos de c√≥digo y funciones como <i>strcpy</i> , <i>strcat</i> , etc.  Como representante de esta clase de herramientas puede llamarse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RATS</a> . <br><br>  Tales herramientas, aunque podr√≠an ser √∫tiles, generalmente eran est√∫pidas e ineficaces.  Es de aquellos tiempos en que muchos programadores todav√≠a tienen recuerdos de que los analizadores est√°ticos son herramientas muy in√∫tiles que interfieren m√°s con el trabajo que con la ayuda. <br><br>  Pas√≥ el tiempo y los analizadores est√°ticos comenzaron a constituir soluciones complejas que realizan an√°lisis de c√≥digo en profundidad y encuentran errores que permanecen en el c√≥digo incluso despu√©s de una revisi√≥n atenta del c√≥digo.  Desafortunadamente, debido a experiencias negativas pasadas, muchos programadores todav√≠a consideran que la metodolog√≠a de an√°lisis est√°tico es in√∫til y no tienen prisa por introducirla en el proceso de desarrollo. <br><br>  En este art√≠culo intentar√© arreglar un poco la situaci√≥n.  Les pido a los lectores que tomen 15 minutos para familiarizarse con las tecnolog√≠as utilizadas en el analizador de c√≥digo est√°tico PVS-Studio para detectar errores.  Quiz√°s despu√©s de eso eche un vistazo a las herramientas de an√°lisis est√°tico y desee aplicarlas en su trabajo. <br><br><h2>  An√°lisis de flujo de datos </h2><br>  El an√°lisis del flujo de datos le permite encontrar una variedad de errores.  Entre ellos: salir de los l√≠mites de una matriz, p√©rdidas de memoria, condiciones siempre verdaderas / falsas, desreferenciar un puntero nulo, etc. <br><br>  Adem√°s, el an√°lisis de datos se puede usar para buscar situaciones en las que se usan datos no verificados que llegaron al programa desde afuera.  Un atacante puede preparar un conjunto de datos de entrada para que el programa funcione de la manera que lo necesita.  En otras palabras, puede usar el error de control de entrada insuficiente como una vulnerabilidad.  Para buscar el uso de datos no verificados en PVS-Studio, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se ha</a> implementado el diagn√≥stico especializado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V1010</a> y contin√∫a mejorando. <br><br>  El an√°lisis del flujo de datos (An√°lisis de flujo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">datos</a> ) consiste en calcular los posibles valores de las variables en varios puntos de un programa de computadora.  Por ejemplo, si el puntero est√° desreferenciado, y se sabe que en este momento puede ser cero, entonces esto es un error y el analizador est√°tico lo informar√°. <br><br>  Veamos un ejemplo pr√°ctico del uso del an√°lisis de flujo de datos para buscar errores.  Ante nosotros hay una funci√≥n del proyecto Protocol Buffers (protobuf), dise√±ado para verificar la exactitud de la fecha. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDateTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DateTime&amp; time)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.year &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.year &gt; <span class="hljs-number"><span class="hljs-number">9999</span></span> || time.month &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.month &gt; <span class="hljs-number"><span class="hljs-number">12</span></span> || time.day &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.day &gt; <span class="hljs-number"><span class="hljs-number">31</span></span> || time.hour &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.hour &gt; <span class="hljs-number"><span class="hljs-number">23</span></span> || time.minute &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.minute &gt; <span class="hljs-number"><span class="hljs-number">59</span></span> || time.second &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.second &gt; <span class="hljs-number"><span class="hljs-number">59</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month]; } }</code> </pre> <br>  El analizador PVS-Studio detect√≥ dos errores l√≥gicos en la funci√≥n a la vez y muestra los siguientes mensajes: <br><br><ul><li>  V547 / CWE-571 La expresi√≥n 'time.month &lt;= kDaysInMonth [time.month] + 1' siempre es verdadera.  time.cc 83 </li><li>  V547 / CWE-571 La expresi√≥n 'time.month &lt;= kDaysInMonth [time.month]' siempre es verdadera.  time.cc 85 </li></ul><br>  Tenga en cuenta la subexpresi√≥n "time.month &lt;1 ||  tiempo.mes&gt; 12 ".  Si el valor del <i>mes</i> est√° fuera del rango [1..12], entonces la funci√≥n detiene su trabajo.  El analizador toma esto en cuenta y sabe que si la segunda <i>sentencia if</i> comenz√≥ a ejecutarse, el valor del <i>mes</i> se encuentra exactamente en el rango [1..12].  Del mismo modo, conoce el rango de otras variables (a√±o, d√≠a, etc.), pero ahora no nos interesan. <br><br>  Ahora echemos un vistazo a dos operadores id√©nticos para acceder a los elementos de la matriz: <i>kDaysInMonth [time.month]</i> . <br><br>  La matriz se configura de forma est√°tica y el analizador conoce los valores de todos sus elementos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> };</code> </pre> <br>  Como los meses est√°n numerados de 1, el analizador no considera 0 al comienzo de la matriz.  Resulta que un valor en el rango [28..31] se puede extraer de la matriz. <br><br>  Dependiendo de si el a√±o es bisiesto o no, se agrega 1 al n√∫mero de d√≠as, pero esto tampoco es interesante para nosotros ahora.  Las comparaciones en s√≠ mismas son importantes: <br><br><pre> <code class="cpp hljs">time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; time.month &lt;= kDaysInMonth[time.month];</code> </pre> <br>  El rango [1..12] (n√∫mero de mes) se compara con el n√∫mero de d√≠as del mes. <br><br>  Teniendo en cuenta que en el primer caso el mes siempre es febrero ( <i>time.month == 2</i> ), obtenemos que se comparan los siguientes rangos: <br><br><ul><li>  2 &lt;= 29 </li><li>  [1..12] &lt;= [28..31] </li></ul><br>  Como puede ver, el resultado de la comparaci√≥n siempre es cierto, que es lo que advierte el analizador PVS-Studio.  De hecho, el c√≥digo contiene dos errores tipogr√°ficos id√©nticos.  El lado izquierdo de la expresi√≥n debe usar un miembro de la clase de <i>d√≠a</i> , no un <i>mes</i> en absoluto. <br><br>  El c√≥digo correcto deber√≠a ser as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month]; }</code> </pre> <br>  El error discutido aqu√≠ tambi√©n se describi√≥ previamente en el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">31 de febrero</a> ". <br><br><h2>  Ejecuci√≥n simb√≥lica </h2><br>  En la secci√≥n anterior, consideramos un m√©todo en el que el analizador calcula los posibles valores de las variables.  Sin embargo, para encontrar algunos errores, no es necesario conocer los valores de las variables.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejecuci√≥n simb√≥lica</a> significa resolver ecuaciones en forma simb√≥lica. <br><br>  No encontr√© una demostraci√≥n adecuada en nuestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">base de datos de errores</a> , as√≠ que considere un ejemplo de c√≥digo sint√©tico. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == B) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / (A - B); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  El analizador PVS-Studio genera una advertencia V609 / CWE-369 Divide by zero.  Denominador 'A - B' == 0. test.cpp 12 <br><br>  Los valores de las variables <i>A</i> y <i>B son</i> desconocidos para el analizador.  Pero el analizador sabe que en el momento de calcular la expresi√≥n <i>10 / (A - B), las</i> variables <i>A</i> y <i>B</i> son iguales.  Por lo tanto, se producir√° la divisi√≥n por 0. <br><br>  Dije que los valores de <i>A</i> y <i>B son</i> desconocidos.  Para el caso general, esto es cierto.  Sin embargo, si el analizador ve una llamada a la funci√≥n con valores espec√≠ficos de los argumentos reales, lo tendr√° en cuenta.  Considere un ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / X; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) Div(i); }</code> </pre> <br>  El analizador PVS-Studio advierte la divisi√≥n por cero: V609 CWE-628 Divide por cero.  Denominador 'X' == 0. La funci√≥n 'Div' procesa el valor '[0..4]'.  Inspecciona el primer argumento.  Verifique las l√≠neas: 106, 110. consoleapplication2017.cpp 106 <br><br>  Una combinaci√≥n de tecnolog√≠as ya funciona aqu√≠: an√°lisis de flujo de datos, ejecuci√≥n simb√≥lica y anotaci√≥n autom√°tica de m√©todos (discutiremos esta tecnolog√≠a en la siguiente secci√≥n).  El analizador ve que la variable <i>X se</i> usa como divisor en la funci√≥n <i>Div</i> .  En base a esto, se crea autom√°ticamente una anotaci√≥n especial para la funci√≥n <i>Div</i> .  Adem√°s se tiene en cuenta que un rango de valores [0..4] se pasa a la funci√≥n como un argumento <i>X.</i>  El analizador concluye que la divisi√≥n por 0 deber√≠a ocurrir. <br><br><h2>  M√©todo de anotaciones </h2><br>  Nuestro equipo ha anotado miles de funciones y clases proporcionadas en: <br><br><ul><li>  Winapi </li><li>  Biblioteca est√°ndar C </li><li>  biblioteca de plantillas est√°ndar (STL), </li><li>  glibc (biblioteca GNU C) </li><li>  Qt </li><li>  MFC </li><li>  zlib </li><li>  libpng </li><li>  Openssl </li><li>  y as√≠ sucesivamente </li></ul><br>  Todas las funciones se anotan manualmente, lo que le permite establecer muchas caracter√≠sticas que son importantes en t√©rminos de b√∫squeda de errores.  Por ejemplo, se especifica que el tama√±o del b√∫fer pasado a la funci√≥n <i>fread</i> no debe ser inferior al n√∫mero de bytes que se planea leer del archivo.  Tambi√©n se indica la relaci√≥n entre los argumentos segundo, tercero y el valor que la funci√≥n puede devolver.  Todo se ve as√≠: <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d4/a9c/684/4d4a9c6844fcfa694009f2ccace9d436.png" alt="PVS-Studio: marcado de funciones"></div><br>  Gracias a esta anotaci√≥n, el siguiente c√≥digo, que usa la funci√≥n <i>fread</i> , revelar√° inmediatamente dos errores. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = fread(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>, f); buf[i] = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  Advertencias de PVS-Studio: <ul><li>  V512 CWE-119 Una llamada de la funci√≥n 'fread' provocar√° el desbordamiento del b√∫fer 'buf'.  test.cpp 116 </li><li>  V557 CWE-787 Arreglo de arrastre es posible.  El valor del √≠ndice 'i' podr√≠a alcanzar 1000. test.cpp 117 </li></ul><br>  Primero, el analizador multiplic√≥ el segundo y el tercer argumento real y calcul√≥ que la funci√≥n puede leer hasta 1000 bytes de datos.  En este caso, el tama√±o del b√∫fer es de solo 100 bytes y puede desbordarse. <br><br>  En segundo lugar, dado que la funci√≥n puede leer hasta 1000 bytes, el rango de valores posibles de la variable <i>i</i> es [0..1000].  En consecuencia, el acceso a la matriz puede ocurrir en el √≠ndice incorrecto. <br><br>  Veamos otro ejemplo simple de un error, cuya detecci√≥n fue posible gracias al marcado de la funci√≥n <i>memset</i> .  Aqu√≠ hay un fragmento de c√≥digo del proyecto CryEngine V. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableFloatExceptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... CONTEXT ctx; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;ctx, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ctx), <span class="hljs-number"><span class="hljs-number">0</span></span>); .... }</code> </pre> <br>  El analizador PVS-Studio encontr√≥ un error tipogr√°fico: V575 La funci√≥n 'memset' procesa elementos '0'.  Inspeccione el tercer argumento.  crythreadutil_win32.h 294 <br><br>  Confundi√≥ el segundo y tercer argumento de la funci√≥n.  Como resultado, la funci√≥n procesa 0 bytes y no hace nada.  El analizador nota esta anomal√≠a y advierte a los programadores al respecto.  Anteriormente, ya describimos este error en el art√≠culo "La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tan esperada verificaci√≥n de CryEngine V</a> ". <br><br>  El analizador PVS-Studio no se limita a las anotaciones que configuramos manualmente.  Adem√°s, intenta de forma independiente crear anotaciones estudiando los cuerpos de las funciones.  Esto le permite encontrar errores de uso incorrecto de funciones.  Por ejemplo, el analizador recuerda que una funci√≥n puede devolver nullptr.  Si el puntero devuelto por esta funci√≥n se usa sin verificaci√≥n preliminar, el analizador lo advertir√°.  Un ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GlobalInt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (rand() % <span class="hljs-number"><span class="hljs-number">2</span></span>) ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : &amp;GlobalInt; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *Get() = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Advertencia: V522 CWE-690 Puede haber una desreferenciaci√≥n de un puntero nulo potencial 'Get ()'.  test.cpp 129 <br><br>  <b>Nota</b>  Puede abordar la b√∫squeda del error que acaba de examinar de la manera opuesta.  No recuerde nada, y cada vez que se encuentre una llamada a la funci√≥n <i>Get</i> , anal√≠cela conociendo los argumentos reales.  Tal algoritmo te√≥ricamente te permite encontrar m√°s errores, pero tiene una complejidad exponencial.  El tiempo de an√°lisis del programa crece cientos de miles de veces, y consideramos que este enfoque es un callej√≥n sin salida desde un punto de vista pr√°ctico.  En PVS-Studio, estamos desarrollando la direcci√≥n de anotaci√≥n autom√°tica de funciones. <br><br><h2>  Coincidencia de patrones </h2><br>  La tecnolog√≠a que coincide con un patr√≥n, a primera vista, puede parecer una b√∫squeda con expresiones regulares.  De hecho, esto no es as√≠, y todo es mucho m√°s complicado. <br><br>  En primer lugar, como ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dije</a> , las expresiones regulares generalmente no tienen valor.  En segundo lugar, los analizadores no funcionan con l√≠neas de texto, sino con √°rboles de sintaxis, lo que permite reconocer patrones de error m√°s complejos y de alto nivel. <br><br>  Considere dos ejemplos, uno m√°s simple y otro m√°s complejo.  El primer error que encontr√© al verificar el c√≥digo fuente de Android. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TagMonitor::parseTagsToMonitor(String8 tagNames) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mMonitorMutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> end = tagNames.find(<span class="hljs-string"><span class="hljs-string">","</span></span>, idx); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* start = tagNames.lockBuffer(tagNames.size()); start[idx] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... } .... }</code> </pre> <br>  El analizador PVS-Studio reconoce el patr√≥n de error cl√°sico asociado con la concepci√≥n err√≥nea de un programador sobre la prioridad de las operaciones en C ++: V593 / CWE-783 Considere revisar la expresi√≥n del tipo 'A = B! = C'.  La expresi√≥n se calcula de la siguiente manera: 'A = (B! = C)'.  TagMonitor.cpp 50 <br><br>  Eche un vistazo de cerca a esta l√≠nea: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) {</code> </pre> <br>  El programador supone que se realiza una asignaci√≥n al principio, y solo entonces una comparaci√≥n con <i>-1</i> .  De hecho, la comparaci√≥n es lo primero.  Cl√°sico  Este error se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">describe</a> con m√°s detalle en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> dedicado a la verificaci√≥n de Android (consulte el cap√≠tulo "Otros errores"). <br><br>  Ahora considere una opci√≥n de coincidencia de patr√≥n de nivel superior. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: V597 CWE-14 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'chunkBuffer'.  La funci√≥n RtlSecureZeroMemory () debe usarse para borrar los datos privados.  sha1.cpp 189 <br><br>  La esencia del problema es que despu√©s de llenar un b√∫fer con ceros usando la funci√≥n <i>memset</i> , este b√∫fer no se usa en ninguna parte.  Al compilar c√≥digo con indicadores de optimizaci√≥n, el compilador decidir√° que esta llamada de funci√≥n es redundante y la eliminar√°.  Tiene derecho a esto, ya que desde el punto de vista del lenguaje C ++, llamar a una funci√≥n no tiene ning√∫n comportamiento observable en el programa.  Inmediatamente despu√©s de llenar el b√∫fer <i>chunkBuffer</i> , la funci√≥n <i>sha1ProcessChunk</i> finaliza.  Como el b√∫fer se crea en la pila, despu√©s de salir de la funci√≥n, no estar√° disponible para su uso.  Por lo tanto, desde el punto de vista del compilador, no tiene sentido llenarlo con ceros. <br><br>  Como resultado, en alg√∫n lugar de la pila permanecer√°n datos privados, lo que puede generar problemas.  Este tema se trata con m√°s detalle en el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Limpieza segura de datos privados</a> ". <br><br>  Este es un ejemplo de coincidencia de patrones de alto nivel.  Primero, el analizador debe ser consciente de la existencia de esta falla de seguridad, clasificada seg√∫n la Enumeraci√≥n de Debilidad Com√∫n como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CWE-14: Eliminaci√≥n del C√≥digo del Compilador para Borrar Buffers</a> . <br><br>  En segundo lugar, debe encontrar en el c√≥digo todos los lugares donde se crea el b√∫fer en la pila, se <i>limpia con la</i> funci√≥n <i>memset</i> y no se usa en ning√∫n otro lugar. <br><br><h2>  Conclusi√≥n </h2><br>  Como puede ver, el an√°lisis est√°tico es una metodolog√≠a muy interesante y √∫til.  Le permite eliminar una gran cantidad de errores y vulnerabilidades potenciales en las primeras etapas (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SAST</a> ).  Si a√∫n no est√° completamente imbuido de an√°lisis est√°tico, lo invito a leer nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog</a> , donde analizamos regularmente los errores encontrados utilizando PVS-Studio en varios proyectos.  Simplemente no puedes permanecer indiferente. <br><br>  Estaremos encantados de ver a su empresa entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestros clientes</a> y ayudar a que sus aplicaciones sean mejores, m√°s confiables y m√°s seguras. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Si desea compartir este art√≠culo con una audiencia de habla inglesa, utilice el enlace a la traducci√≥n: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tecnolog√≠as utilizadas en el analizador de c√≥digo PVS-Studio para encontrar errores y vulnerabilidades potenciales</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430604/">https://habr.com/ru/post/es430604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430590/index.html">En Alemania, desarroll√≥ los requisitos para enrutadores dom√©sticos</a></li>
<li><a href="../es430592/index.html">Internet del cliente en una m√°quina virtual aislada QEMU que utiliza la tunelizaci√≥n de puertos a trav√©s de un canal SPICE</a></li>
<li><a href="../es430596/index.html">¬øC√≥mo preparar una estrategia de producto? Gu√≠a del gerente de producto</a></li>
<li><a href="../es430600/index.html">Marte: del chocolate a los robots</a></li>
<li><a href="../es430602/index.html">Vulnerabilidades en Etherium Smart Contracts. Ejemplos de c√≥digo</a></li>
<li><a href="../es430606/index.html">Webinar del Grupo IB: "Investigaci√≥n forense de artefactos RDP en Windows"</a></li>
<li><a href="../es430610/index.html">C√≥mo deshacerse de sus dispositivos electr√≥nicos de manera segura</a></li>
<li><a href="../es430612/index.html">C√≥mo en la d√©cada de 1980 la gente descargaba juegos de la radio</a></li>
<li><a href="../es430614/index.html">Black Friday 2018 en Madrobots.</a></li>
<li><a href="../es430616/index.html">Seminario "Pruebas y monitoreo", 27 de noviembre, Mosc√∫</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>