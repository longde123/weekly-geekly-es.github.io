<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♒️ 🔼 ⬅️ Presentación de la versión alfa de instantáneas de volumen en Kubernetes 🤚🏼 🧙 👈🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota perev. : El artículo original fue publicado recientemente en el blog de Kubernetes y fue escrito por empleados de Google y Huawei (Jing Xu, Xing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Presentación de la versión alfa de instantáneas de volumen en Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/426133/"><img src="https://habrastorage.org/webt/ok/pe/iy/okpeiy2vp8v36hzrr-ddpboknyi.png"><br><br>  <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: El artículo original fue publicado recientemente en el blog de Kubernetes y fue escrito por empleados de Google y Huawei (Jing Xu, Xing Yang, Saad Ali), cuya actividad activa ciertamente ha visto en el GitHub del proyecto, si alguna vez ha estado interesado en las características y problemas de K8 relacionados con con almacenamiento de datos</i>  <i>Los ingenieros hablan sobre el propósito de las instantáneas de volumen, sus capacidades actuales y los conceptos básicos para trabajar con ellas.</i> <a name="habracut"></a><br><br>  Kubernetes v1.12 introdujo una versión alfa de soporte para instantáneas para volúmenes.  Esta característica le permite crear y eliminar instantáneas de volúmenes, así como crear nuevos volúmenes a partir de instantáneas utilizando los medios "nativos" del sistema, a través de la API de Kubernetes. <br><br><h2>  ¿Qué es una instantánea? </h2><br>  Muchos sistemas de almacenamiento (como Google Cloud Persistent Disks, Amazon Elastic Block Storage y numerosos sistemas de almacenamiento en las instalaciones) ofrecen la posibilidad de crear una instantánea ("instantánea") para un volumen persistente.  Una instantánea es una copia de un volumen en un momento determinado.  Se puede utilizar para proporcionar un nuevo volumen (ya lleno de datos de una instantánea) o restaurar un volumen existente a un estado anterior (que se presenta en una instantánea). <br><br><h2>  ¿Por qué agregar instantáneas a Kubernetes? </h2><br>  Ya se encuentra disponible una potente abstracción en el sistema de plug-in de volumen de Kubernetes, que automatiza el aprovisionamiento, la conexión y el montaje de almacenamientos de bloques y archivos. <br><br>  Proporcionar todas estas capacidades es parte de los objetivos de tolerancia de carga de trabajo de Kubernetes: Kubernetes busca crear una capa de abstracción entre las aplicaciones que funcionan como sistemas distribuidos y clústeres subyacentes para que las aplicaciones sean independientes del clúster específico en el que se ejecutan, y la implementación de la aplicación no requiere cualquier conocimiento específico del clúster. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes Storage SIG ha</a> identificado las operaciones de instantáneas como capacidades críticas para una variedad de cargas de trabajo con estado.  Por ejemplo, un administrador de base de datos puede querer tomar una instantánea de su base de datos antes de realizar cualquier operación en ella. <br><br>  Habiendo recibido el método estándar para invocar operaciones de instantáneas en la API de Kubernetes, los usuarios de Kubernetes pueden trabajar con ellos sin la necesidad de soluciones alternativas (y la invocación manual de operaciones que son específicas del sistema de almacenamiento).  En cambio, los usuarios tuvieron la oportunidad de integrar operaciones de instantáneas en sus herramientas y políticas con el tranquilo entendimiento de que todo funcionará con cualquier clúster de Kubernetes, independientemente del almacenamiento subyacente. <br><br>  Además, estas primitivas de Kubernetes funcionan como bloques de construcción básicos, abriendo el camino para el desarrollo de características más avanzadas de nivel empresarial para la gestión del almacenamiento, por ejemplo, para protección, replicación y migración de datos. <br><br><h2>  ¿Qué complementos de volumen admiten instantáneas en Kubernetes? </h2><br>  Kubernetes admite tres tipos de complementos de volumen: en árbol, Flex y CSI.  Consulte las <a href="">Preguntas frecuentes sobre</a> el <a href="">complemento de volumen de Kubernetes para</a> obtener más información. <br><br>  Las instantáneas solo son compatibles con los controladores CSI (no son compatibles ni en el árbol ni en Flex).  Para aprovechar esta característica, asegúrese de que el controlador CSI que implementa el soporte de instantáneas esté implementado en el clúster de Kubernetes. <br><br>  En el momento de esta publicación de blog <i>(9 de octubre de 2018 - <b>aprox. Transl.</b> )</i> , Las instantáneas son compatibles con los siguientes controladores CSI: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Disco persistente de la CME</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenSDS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ceph rbd</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Portworx</a> </li></ul><br>  El soporte para instantáneas para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otros controladores</a> está en desarrollo y debería estar disponible pronto.  En la publicación " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interfaz de almacenamiento de contenedores (CSI) para Kubernetes Goes Beta</a> " <i>(y también vea nuestra traducción de la nota " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender la interfaz de almacenamiento de contenedores (en Kubernetes y más)</a> ",</i> se describen más detalles sobre CSI y cómo implementar controladores CSI. <i>- <b>aprox. Transl.</b> )</i> . <br><br><h2>  API de Kubernetes para instantáneas </h2><br>  Para administrar instantáneas, Kubernetes Volume Snapshots presenta tres nuevos objetos API de la misma manera que en la API de volúmenes persistentes de Kubernetes: <br><br><ul><li> <code>VolumeSnapshot</code> <br> <ul><li>  Creado por el usuario de Kubernetes para solicitar una instantánea para el volumen especificado.  Contiene información sobre la operación de la instantánea, como la marca de tiempo para eliminar la instantánea y si está lista para su uso. </li><li>  Al igual que el objeto <code>PersistentVolumeClaim</code> , crear y eliminar este objeto representa el deseo del usuario de crear o eliminar un recurso de clúster (instantánea). </li></ul></li><li> <code>VolumeSnapshotContent</code> <br> <ul><li>  Creado por el controlador CSI cuando la instantánea se creó con éxito.  Contiene información sobre la instantánea, incluida su ID. </li><li>  Al igual que un objeto <code>PersistentVolume</code> , representa un recurso ya atendido por el clúster (instantánea). </li><li>  Al igual que los objetos <code>PersistentVolumeClaim</code> y <code>PersistentVolume</code> , cuando se crea una instantánea, el objeto <code>VolumeSnapshotContent</code> adjunta a la <code>VolumeSnapshot</code> para la que se creó (se utiliza la asignación uno a uno). </li></ul></li><li> <code>VolumeSnapshotClass</code> <br> <ul><li>  Definido por los administradores de clúster para describir qué instantáneas se pueden crear.  Incluye información del conductor, secretos para acceder a instantáneas, etc. </li></ul></li></ul><br>  Es importante tener en cuenta que, a diferencia de los principales objetos de volumen persistente en Kubernetes, estos objetos instantáneos se definen como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CustomResourceDefinitions (CRD)</a> .  El proyecto Kubernetes se aleja gradualmente de los tipos de recursos predefinidos en el Servidor API, acercándose a un modelo en el que el Servidor API es independiente de los objetos API.  Este enfoque le permite reutilizar el servidor API en otros proyectos (además de Kubernetes), y los consumidores (como Kubernetes) pueden establecer los tipos de recursos que necesitan como CRD. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los controladores CSI</a> que admiten instantáneas instalarán automáticamente los CRD necesarios.  Los usuarios finales de Kubernetes solo necesitan verificar que el controlador CSI que admite instantáneas esté implementado en el clúster. <br><br>  Además de estos nuevos objetos, el <code>PersistentVolumeClaim</code> existente <code>PersistentVolumeClaim</code> un nuevo campo <code>DataSource</code> : <br><br><pre> <code class="plaintext hljs">type PersistentVolumeClaimSpec struct { AccessModes []PersistentVolumeAccessMode Selector *metav1.LabelSelector Resources ResourceRequirements VolumeName string StorageClassName *string VolumeMode *PersistentVolumeMode DataSource *TypedLocalObjectReference }</code> </pre> <br>  Este campo (en el estado de versión alfa) le permite llenarlo automáticamente con datos de una instantánea existente al crear un nuevo volumen. <br><br><h2>  Requisitos de la instantánea de Kubernetes </h2><br>  Antes de usar instantáneas de volumen en Kubernetes, debe: <br><br><ul><li>  asegúrese de que el controlador CSI que implementa las instantáneas esté implementado y ejecutándose en el clúster; </li><li>  habilite la función de instantáneas de volumen de Kubernetes a través de la nueva puerta de funciones (deshabilitada por defecto para la versión alfa): <br><ul><li>  establezca el siguiente indicador para el <code>--feature-gates=VolumeSnapshotDataSource=true</code> servidor API: <code>--feature-gates=VolumeSnapshotDataSource=true</code> </li></ul></li></ul><br>  Antes de crear una instantánea, también debe determinar qué controlador CSI usar, lo que se hace creando un objeto <code>VolumeSnapshotClass</code> y especificando el controlador CSI en el campo de la <code>snapshotter</code> .  En el ejemplo de <code>VolumeSnapshotClass</code> continuación, este controlador es <code>com.example.csi-driver</code> .  Cada proveedor de instantáneas requiere al menos un objeto <code>VolumeSnapshotClass</code> .  También es posible definir una <code>VolumeSnapshotClass</code> predeterminada para cada controlador CSI; esto se hace configurando <code>snapshot.storage.kubernetes.io/is-default-class: "true"</code> anotación <code>snapshot.storage.kubernetes.io/is-default-class: "true"</code> en la definición de clase: <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: default-snapclass annotations: snapshot.storage.kubernetes.io/is-default-class: "true" snapshotter: com.example.csi-driver apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: csi-snapclass snapshotter: com.example.csi-driver parameters: fakeSnapshotOption: foo csiSnapshotterSecretName: csi-secret csiSnapshotterSecretNamespace: csi-namespace</code> </pre> <br>  Todos los parámetros requeridos deben establecerse de acuerdo con la documentación del controlador CSI.  En el ejemplo anterior, el parámetro <code>fakeSnapshotOption: foo</code> y todos los secretos mencionados se pasarán al controlador CSI durante la creación y eliminación de la instantánea.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CSI external-snapshotter</a> de forma predeterminada guarda las claves de parámetro <code>csiSnapshotterSecretName</code> y <code>csiSnapshotterSecretNamespace</code> . <br><br>  Finalmente, antes de crear una instantánea, debe crear el volumen a través del controlador CSI y llenarlo con los datos que desea ver allí (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta publicación</a> para obtener detalles sobre cómo usar los volúmenes CSI). <br><br><h2>  Crear una nueva instantánea en Kubernetes </h2><br>  Una vez que el objeto <code>VolumeSnapshotClass</code> definido y es el volumen del que desea eliminar la instantánea, puede realizar esta operación creando el objeto <code>VolumeSnapshot</code> . <br><br>  La fuente de la instantánea está determinada por dos parámetros: <br><br><ul><li>  <code>kind</code> : aquí <code>PersistentVolumeClaim</code> indica <code>PersistentVolumeClaim</code> ; </li><li>  <code>name</code> : el nombre real del objeto de PVC. </li></ul><br>  Se entiende que el espacio de nombres del volumen para el que se crea la instantánea está determinado por el espacio de nombres del objeto <code>VolumeSnapshot</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: new-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass source: name: mypvc kind: PersistentVolumeClaim</code> </pre> <br>  La especificación <code>VolumeSnapshot</code> puede <code>VolumeSnapshot</code> una <code>VolumeSnapshotClass</code> que contiene información sobre qué controlador CSI se utilizará para crear la instantánea.  Como se informó anteriormente, después de crear el objeto <code>VolumeSnapshot</code> el parámetro <code>fakeSnapshotOption: foo</code> y todos los secretos mencionados de <code>VolumeSnapshotClass</code> se pasan al complemento CSI <code>com.example.csi-driver</code> en la llamada <code>CreateSnapshot</code> . <br><br>  En respuesta a dicha solicitud, el controlador CSI toma una instantánea del volumen y luego crea automáticamente un objeto <code>VolumeSnapshotContent</code> que representa la nueva instantánea y vincula este objeto a <code>VolumeSnapshot</code> , <code>VolumeSnapshot</code> listo para usar.  Si el controlador CSI no puede crear una instantánea y devuelve un error, el controlador de la instantánea informa este error en el estado del objeto <code>VolumeSnapshot</code> y <b>no</b> hace nuevos intentos (este comportamiento es diferente de otros controladores en Kubernetes; se implementa para no crear una instantánea en momentos impredecibles) . <br><br>  Si no se especifica la clase de instantánea, external-snapshotter intentará encontrar la clase predeterminada y usarla para la instantánea creada.  En este caso, el controlador CSI señalado por el <code>snapshotter</code> en la clase predeterminada debe corresponder al controlador CSI señalado por el <code>provisioner</code> en la clase de almacenamiento de PVC. <br><br>  Tenga en cuenta que la publicación alfa de instantáneas para Kubernetes no proporciona una garantía de coherencia.  Para garantizar datos completos en una instantánea, es necesario preparar adecuadamente la aplicación (detener la aplicación, congelar el sistema de archivos, etc.) antes de eliminarla. <br><br>  Para <code>VolumeSnapshot</code> que el objeto <code>VolumeSnapshot</code> ha <code>VolumeSnapshot</code> creado y asociado con el <code>VolumeSnapshotContent</code> , puede usar el <code>kubectl describe volumesnapshot</code> : <br><br><ul><li>  <code>Ready</code> debe ser <code>true</code> en <code>Status</code> , lo que indicará que la instantánea de volumen está lista para su uso. </li><li>  El campo <code>Creation Time</code> muestra cuándo se tomó realmente la instantánea. </li><li>  El campo <code>Restore Size</code> es el tamaño de volumen mínimo para restaurar una instantánea. </li><li>  El campo <code>Snapshot Content Name</code> en la especificación apunta al objeto <code>VolumeSnapshotContent</code> creado para esta instantánea. </li></ul><br><h2>  Importar una instantánea existente en Kubernetes </h2><br>  Se puede importar una instantánea existente en Kubernetes creando manualmente un objeto <code>VolumeSnapshotContent</code> que representará esta instantánea.  Dado que <code>VolumeSnapshotContent</code> es un objeto API que no está vinculado a un espacio de nombres, solo el administrador del sistema tiene los derechos para crearlo. <br><br>  Cuando se <code>VolumeSnapshotContent</code> objeto <code>VolumeSnapshotContent</code> , el usuario puede crear otro objeto, <code>VolumeSnapshot</code> , que lo señalará.  El controlador externo de instantáneas marcará la instantánea como lista después de verificar la existencia y la conexión correcta entre los <code>VolumeSnapshotContent</code> <code>VolumeSnapshot</code> y <code>VolumeSnapshotContent</code> .  Una instantánea está lista para usarse en Kubernetes cuando se establece esta conexión. <br><br>  El objeto <code>VolumeSnapshotContent</code> debe crearse con los siguientes campos que representan la instantánea preaprovisionada: <br><br><ul><li>  <code>csiVolumeSnapshotSource</code> : información que identifica una instantánea: <br><ul><li>  <code>snapshotHandle</code> : nombre / identificador de la instantánea.  Campo obligatorio; </li><li>  <code>driver</code> : el controlador CSI solía funcionar con este volumen.  Campo obligatorio  Debe coincidir con el nombre de la <code>snapshotter</code> en el controlador (controlador de instantánea); </li><li>  <code>creationTime</code> y <code>restoreSize</code> : para volúmenes <code>restoreSize</code> , estos campos son opcionales.  El controlador externo de instantáneas las actualizará automáticamente después de crear una instantánea. </li></ul></li><li>  <code>volumeSnapshotRef</code> : puntero al objeto <code>VolumeSnapshot</code> al que se debe adjuntar este objeto (es decir, <code>VolumeSnapshotContent</code> ): <br><ul><li>  <code>name</code> y <code>namespace</code> : el nombre y el espacio de nombres del objeto <code>VolumeSnapshot</code> cuyos contenidos están vinculados; </li><li>  <code>UID</code> : campo opcional (para volúmenes preparados previamente).  El controlador de instantáneas externas actualizará automáticamente este campo después del enlace.  Si el usuario define este campo, debe asegurarse de que coincida con el UID de la instantánea para la que se produce el enlace.  Si no existe dicha correspondencia, el contenido se considera irrelevante (objeto huérfano) y, por lo tanto, el controlador lo eliminará tanto a él como a la instantánea asociada. </li></ul></li><li>  <code>snapshotClassName</code> es un campo opcional.  El controlador externo de instantáneas lo actualizará automáticamente después del enlace. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotContent metadata: name: static-snapshot-content spec: csiVolumeSnapshotSource: driver: com.example.csi-driver snapshotHandle: snapshotcontent-example-id volumeSnapshotRef: kind: VolumeSnapshot name: static-snapshot-demo namespace: demo-namespace</code> </pre> <br>  Se debe crear un objeto <code>VolumeSnapshot</code> para que el usuario pueda trabajar con la instantánea.  En ella: <br><br><ul><li>  <code>snapshotClassName</code> : nombre de la clase de instantánea del volumen.  Campo opcional.  Si se establece, el campo de <code>snapshotter</code> en la clase de instantánea debe coincidir con el nombre del controlador de instantánea.  Si no se establece, el controlador buscará la clase de instantánea predeterminada; </li><li>  <code>snapshotContentName</code> : el nombre del contenido del volumen de la instantánea.  Campo obligatorio para volúmenes preparados previamente. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: static-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass snapshotContentName: static-snapshot-content</code> </pre> <br>  Cuando se crean estos objetos, el controlador de instantáneas los vinculará, establecerá el campo <code>Ready</code> (en <code>Status</code> ) en <code>True</code> , lo que indica que la instantánea está lista para su uso. <br><br><h2>  Preparación de un nuevo volumen a partir de una instantánea en Kubernetes </h2><br>  Para crear un nuevo volumen <code>dataSource</code> previamente con datos del objeto de instantánea, use el nuevo campo <code>dataSource</code> en <code>PersistentVolumeClaim</code> .  Tiene tres parámetros: <br><br><ul><li>  <code>name</code> : nombre del objeto <code>VolumeSnapshot</code> que representa el origen de la instantánea; </li><li>  <code>kind</code> : debe establecerse como <code>VolumeSnapshot</code> ; </li><li>  <code>apiGroup</code> : debe ser <code>snapshot.storage.k8s.io</code> . </li></ul><br>  Se supone que el espacio de nombres de la fuente, <code>VolumeSnapshot</code> , coincide con el espacio de nombres de <code>PersistentVolumeClaim</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc-restore Namespace: demo-namespace spec: storageClassName: csi-storageclass dataSource: name: new-snapshot-demo kind: VolumeSnapshot apiGroup: snapshot.storage.k8s.io accessModes: - ReadWriteOnce resources: requests: storage: 1Gi</code> </pre> <br>  Cuando se crea el objeto <code>PersistentVolumeClaim</code> , llamará al aprovisionamiento del nuevo volumen, rellenado previamente con datos de la instantánea especificada. <br><br><h2>  ¿Cómo agregar compatibilidad con instantáneas a mi controlador CSI si soy un desarrollador de almacenamiento? </h2><br>  Para proporcionar soporte para las instantáneas, se deben agregar capacidades de controlador adicionales al controlador CSI: <code>CREATE_DELETE_SNAPSHOT</code> y <code>LIST_SNAPSHOTS</code> , así como controladores RPC adicionales: <code>CreateSnapshot</code> , <code>DeleteSnapshot</code> , <code>ListSnapshots</code> .  Consulte <a href="">la especificación CSI para más</a> detalles. <br><br>  Aunque Kubernetes proporciona las <a href="">pautas</a> más <a href="">básicas</a> para empaquetar e implementar el Controlador de volumen CSI, existe un <a href="">mecanismo recomendado</a> para implementar un controlador CSI arbitrario en contenedores en Kubernetes para simplificar este proceso. <br><br>  Como parte del proceso de implementación recomendado, el equipo de Kubernetes sugiere utilizar una variedad de contenedores de sidecar (es decir, auxiliares), incluido un contenedor de sidecar con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">snapshotter externo</a> . <br><br>  El mencionado snapshotter externo supervisa los objetos <code>VolumeSnapshot</code> y <code>VolumeSnapshotContent</code> en el Servidor API, invocando las <code>DeleteSnapshot</code> <code>CreateSnapshot</code> y <code>DeleteSnapshot</code> para el punto final CSI.  El contenedor de sidecar con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aprovisionador externo</a> CSI también se ha actualizado para admitir la recuperación de volumen de instantáneas utilizando el nuevo campo PVC <code>dataSource</code> . <br><br>  Para admitir las capacidades de instantáneas, se recomienda a los fabricantes de almacenamiento implementar contenedores de sidecar con un snapshotter externo además de un aprovisionador externo, y colocar el controlador CSI en un <code>StatefulSet</code> , como se muestra en el siguiente diagrama: <br><br><img src="https://habrastorage.org/webt/9e/og/xm/9eogxmximi8i_y-6tlhber-xjts.png"><br><br>  En <a href="">este ejemplo de implementación, hay</a> dos contenedores de sidecar, un aprovisionador externo y un snapshotter externo, y los controladores CSI se implementan con el complemento CSI hostpath dentro del pod StatefulSet.  El CSI hostpath es un complemento de ejemplo que no está diseñado para usarse en producción. <br><br><h2>  ¿Cuáles son las limitaciones de la versión alfa? </h2><br>  La versión alfa de la implementación de la instantánea en Kubernetes tiene las siguientes limitaciones: <br><br><ul><li>  No se admite la reversión de un volumen existente a un estado anterior representado por una instantánea (solo se admite el aprovisionamiento de un nuevo volumen desde una instantánea). </li><li>  La restauración en contexto no es compatible con <code>PersistentVolumeClaim</code> existente de la instantánea: es decir  el aprovisionamiento de un nuevo volumen de la instantánea funciona, pero no actualiza el <code>PersistentVolumeClaim</code> existente para que apunte a un nuevo volumen y el PVC vuelva a un estado anterior (solo se admite el uso de un nuevo volumen creado a partir de una instantánea a través de un nuevo PV / PVC). </li><li>  Las garantías para la coherencia de las instantáneas no van más allá de las garantías proporcionadas por el sistema de almacenamiento (por ejemplo, integridad cuando se descarta). </li></ul><br><h2>  Que sigue </h2><br>  El equipo de Kubernetes planea llevar la implementación de instantáneas para CSI a la versión beta en las versiones 1.13 o 1.14, dependiendo de los comentarios recibidos y la adaptación de la tecnología. <br><br><h2>  ¿Cómo encontrar más detalles? </h2><br>  Consulte la documentación adicional de instantáneas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">k8s.io/docs/concepts/storage/volume-snapshots</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kubernetes-csi.github.io/docs</a> . <br><br><h2>  PD del traductor </h2><br>  Lea también en nuestro blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.12: Resumen de las innovaciones clave</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Entendemos la interfaz de almacenamiento de contenedores (en Kubernetes y no solo)</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rook es un almacén de datos de" autoservicio "para Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nuestra experiencia con Kubernetes en pequeños proyectos</a> " <i>(revisión y video informe)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monitoreo y Kubernetes</a> " <i>(revisión e informe en video)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426133/">https://habr.com/ru/post/es426133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426119/index.html">Antigüedades: Cryptonomicon Iron</a></li>
<li><a href="../es426121/index.html">MC.exe (compilador de mensajes), rc.exe, link.exe para generar .dll para EventMessageFile</a></li>
<li><a href="../es426123/index.html">Aprende OpenGL. Leccion 6.1. PBR o renderizado físicamente correcto. Teoría</a></li>
<li><a href="../es426125/index.html">Carrera de esteroides. Ascensores</a></li>
<li><a href="../es426131/index.html">Descargue la configuración a FPGA a través de USB o desmonte FTDI MPSSE</a></li>
<li><a href="../es426135/index.html">Nube privada para Internet de las cosas</a></li>
<li><a href="../es426137/index.html">Era de la honestidad</a></li>
<li><a href="../es426141/index.html">Red Hat reemplaza Docker con Podman</a></li>
<li><a href="../es426143/index.html">Animación 3D: ¿video o interactivo?</a></li>
<li><a href="../es426145/index.html">Taller de aceptación independiente, 23 de octubre, Moscú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>