<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>鮫뉦잺 游댶 拘勇 Presentaci칩n de la versi칩n alfa de instant치neas de volumen en Kubernetes 游뱈游낖 游븿 游녣游낖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota perev. : El art칤culo original fue publicado recientemente en el blog de Kubernetes y fue escrito por empleados de Google y Huawei (Jing Xu, Xing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Presentaci칩n de la versi칩n alfa de instant치neas de volumen en Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/426133/"><img src="https://habrastorage.org/webt/ok/pe/iy/okpeiy2vp8v36hzrr-ddpboknyi.png"><br><br>  <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: El art칤culo original fue publicado recientemente en el blog de Kubernetes y fue escrito por empleados de Google y Huawei (Jing Xu, Xing Yang, Saad Ali), cuya actividad activa ciertamente ha visto en el GitHub del proyecto, si alguna vez ha estado interesado en las caracter칤sticas y problemas de K8 relacionados con con almacenamiento de datos</i>  <i>Los ingenieros hablan sobre el prop칩sito de las instant치neas de volumen, sus capacidades actuales y los conceptos b치sicos para trabajar con ellas.</i> <a name="habracut"></a><br><br>  Kubernetes v1.12 introdujo una versi칩n alfa de soporte para instant치neas para vol칰menes.  Esta caracter칤stica le permite crear y eliminar instant치neas de vol칰menes, as칤 como crear nuevos vol칰menes a partir de instant치neas utilizando los medios "nativos" del sistema, a trav칠s de la API de Kubernetes. <br><br><h2>  쯈u칠 es una instant치nea? </h2><br>  Muchos sistemas de almacenamiento (como Google Cloud Persistent Disks, Amazon Elastic Block Storage y numerosos sistemas de almacenamiento en las instalaciones) ofrecen la posibilidad de crear una instant치nea ("instant치nea") para un volumen persistente.  Una instant치nea es una copia de un volumen en un momento determinado.  Se puede utilizar para proporcionar un nuevo volumen (ya lleno de datos de una instant치nea) o restaurar un volumen existente a un estado anterior (que se presenta en una instant치nea). <br><br><h2>  쯇or qu칠 agregar instant치neas a Kubernetes? </h2><br>  Ya se encuentra disponible una potente abstracci칩n en el sistema de plug-in de volumen de Kubernetes, que automatiza el aprovisionamiento, la conexi칩n y el montaje de almacenamientos de bloques y archivos. <br><br>  Proporcionar todas estas capacidades es parte de los objetivos de tolerancia de carga de trabajo de Kubernetes: Kubernetes busca crear una capa de abstracci칩n entre las aplicaciones que funcionan como sistemas distribuidos y cl칰steres subyacentes para que las aplicaciones sean independientes del cl칰ster espec칤fico en el que se ejecutan, y la implementaci칩n de la aplicaci칩n no requiere cualquier conocimiento espec칤fico del cl칰ster. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes Storage SIG ha</a> identificado las operaciones de instant치neas como capacidades cr칤ticas para una variedad de cargas de trabajo con estado.  Por ejemplo, un administrador de base de datos puede querer tomar una instant치nea de su base de datos antes de realizar cualquier operaci칩n en ella. <br><br>  Habiendo recibido el m칠todo est치ndar para invocar operaciones de instant치neas en la API de Kubernetes, los usuarios de Kubernetes pueden trabajar con ellos sin la necesidad de soluciones alternativas (y la invocaci칩n manual de operaciones que son espec칤ficas del sistema de almacenamiento).  En cambio, los usuarios tuvieron la oportunidad de integrar operaciones de instant치neas en sus herramientas y pol칤ticas con el tranquilo entendimiento de que todo funcionar치 con cualquier cl칰ster de Kubernetes, independientemente del almacenamiento subyacente. <br><br>  Adem치s, estas primitivas de Kubernetes funcionan como bloques de construcci칩n b치sicos, abriendo el camino para el desarrollo de caracter칤sticas m치s avanzadas de nivel empresarial para la gesti칩n del almacenamiento, por ejemplo, para protecci칩n, replicaci칩n y migraci칩n de datos. <br><br><h2>  쯈u칠 complementos de volumen admiten instant치neas en Kubernetes? </h2><br>  Kubernetes admite tres tipos de complementos de volumen: en 치rbol, Flex y CSI.  Consulte las <a href="">Preguntas frecuentes sobre</a> el <a href="">complemento de volumen de Kubernetes para</a> obtener m치s informaci칩n. <br><br>  Las instant치neas solo son compatibles con los controladores CSI (no son compatibles ni en el 치rbol ni en Flex).  Para aprovechar esta caracter칤stica, aseg칰rese de que el controlador CSI que implementa el soporte de instant치neas est칠 implementado en el cl칰ster de Kubernetes. <br><br>  En el momento de esta publicaci칩n de blog <i>(9 de octubre de 2018 - <b>aprox. Transl.</b> )</i> , Las instant치neas son compatibles con los siguientes controladores CSI: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Disco persistente de la CME</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenSDS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ceph rbd</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Portworx</a> </li></ul><br>  El soporte para instant치neas para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otros controladores</a> est치 en desarrollo y deber칤a estar disponible pronto.  En la publicaci칩n " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interfaz de almacenamiento de contenedores (CSI) para Kubernetes Goes Beta</a> " <i>(y tambi칠n vea nuestra traducci칩n de la nota " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender la interfaz de almacenamiento de contenedores (en Kubernetes y m치s)</a> ",</i> se describen m치s detalles sobre CSI y c칩mo implementar controladores CSI. <i>- <b>aprox. Transl.</b> )</i> . <br><br><h2>  API de Kubernetes para instant치neas </h2><br>  Para administrar instant치neas, Kubernetes Volume Snapshots presenta tres nuevos objetos API de la misma manera que en la API de vol칰menes persistentes de Kubernetes: <br><br><ul><li> <code>VolumeSnapshot</code> <br> <ul><li>  Creado por el usuario de Kubernetes para solicitar una instant치nea para el volumen especificado.  Contiene informaci칩n sobre la operaci칩n de la instant치nea, como la marca de tiempo para eliminar la instant치nea y si est치 lista para su uso. </li><li>  Al igual que el objeto <code>PersistentVolumeClaim</code> , crear y eliminar este objeto representa el deseo del usuario de crear o eliminar un recurso de cl칰ster (instant치nea). </li></ul></li><li> <code>VolumeSnapshotContent</code> <br> <ul><li>  Creado por el controlador CSI cuando la instant치nea se cre칩 con 칠xito.  Contiene informaci칩n sobre la instant치nea, incluida su ID. </li><li>  Al igual que un objeto <code>PersistentVolume</code> , representa un recurso ya atendido por el cl칰ster (instant치nea). </li><li>  Al igual que los objetos <code>PersistentVolumeClaim</code> y <code>PersistentVolume</code> , cuando se crea una instant치nea, el objeto <code>VolumeSnapshotContent</code> adjunta a la <code>VolumeSnapshot</code> para la que se cre칩 (se utiliza la asignaci칩n uno a uno). </li></ul></li><li> <code>VolumeSnapshotClass</code> <br> <ul><li>  Definido por los administradores de cl칰ster para describir qu칠 instant치neas se pueden crear.  Incluye informaci칩n del conductor, secretos para acceder a instant치neas, etc. </li></ul></li></ul><br>  Es importante tener en cuenta que, a diferencia de los principales objetos de volumen persistente en Kubernetes, estos objetos instant치neos se definen como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CustomResourceDefinitions (CRD)</a> .  El proyecto Kubernetes se aleja gradualmente de los tipos de recursos predefinidos en el Servidor API, acerc치ndose a un modelo en el que el Servidor API es independiente de los objetos API.  Este enfoque le permite reutilizar el servidor API en otros proyectos (adem치s de Kubernetes), y los consumidores (como Kubernetes) pueden establecer los tipos de recursos que necesitan como CRD. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los controladores CSI</a> que admiten instant치neas instalar치n autom치ticamente los CRD necesarios.  Los usuarios finales de Kubernetes solo necesitan verificar que el controlador CSI que admite instant치neas est칠 implementado en el cl칰ster. <br><br>  Adem치s de estos nuevos objetos, el <code>PersistentVolumeClaim</code> existente <code>PersistentVolumeClaim</code> un nuevo campo <code>DataSource</code> : <br><br><pre> <code class="plaintext hljs">type PersistentVolumeClaimSpec struct { AccessModes []PersistentVolumeAccessMode Selector *metav1.LabelSelector Resources ResourceRequirements VolumeName string StorageClassName *string VolumeMode *PersistentVolumeMode DataSource *TypedLocalObjectReference }</code> </pre> <br>  Este campo (en el estado de versi칩n alfa) le permite llenarlo autom치ticamente con datos de una instant치nea existente al crear un nuevo volumen. <br><br><h2>  Requisitos de la instant치nea de Kubernetes </h2><br>  Antes de usar instant치neas de volumen en Kubernetes, debe: <br><br><ul><li>  aseg칰rese de que el controlador CSI que implementa las instant치neas est칠 implementado y ejecut치ndose en el cl칰ster; </li><li>  habilite la funci칩n de instant치neas de volumen de Kubernetes a trav칠s de la nueva puerta de funciones (deshabilitada por defecto para la versi칩n alfa): <br><ul><li>  establezca el siguiente indicador para el <code>--feature-gates=VolumeSnapshotDataSource=true</code> servidor API: <code>--feature-gates=VolumeSnapshotDataSource=true</code> </li></ul></li></ul><br>  Antes de crear una instant치nea, tambi칠n debe determinar qu칠 controlador CSI usar, lo que se hace creando un objeto <code>VolumeSnapshotClass</code> y especificando el controlador CSI en el campo de la <code>snapshotter</code> .  En el ejemplo de <code>VolumeSnapshotClass</code> continuaci칩n, este controlador es <code>com.example.csi-driver</code> .  Cada proveedor de instant치neas requiere al menos un objeto <code>VolumeSnapshotClass</code> .  Tambi칠n es posible definir una <code>VolumeSnapshotClass</code> predeterminada para cada controlador CSI; esto se hace configurando <code>snapshot.storage.kubernetes.io/is-default-class: "true"</code> anotaci칩n <code>snapshot.storage.kubernetes.io/is-default-class: "true"</code> en la definici칩n de clase: <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: default-snapclass annotations: snapshot.storage.kubernetes.io/is-default-class: "true" snapshotter: com.example.csi-driver apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: csi-snapclass snapshotter: com.example.csi-driver parameters: fakeSnapshotOption: foo csiSnapshotterSecretName: csi-secret csiSnapshotterSecretNamespace: csi-namespace</code> </pre> <br>  Todos los par치metros requeridos deben establecerse de acuerdo con la documentaci칩n del controlador CSI.  En el ejemplo anterior, el par치metro <code>fakeSnapshotOption: foo</code> y todos los secretos mencionados se pasar치n al controlador CSI durante la creaci칩n y eliminaci칩n de la instant치nea.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CSI external-snapshotter</a> de forma predeterminada guarda las claves de par치metro <code>csiSnapshotterSecretName</code> y <code>csiSnapshotterSecretNamespace</code> . <br><br>  Finalmente, antes de crear una instant치nea, debe crear el volumen a trav칠s del controlador CSI y llenarlo con los datos que desea ver all칤 (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta publicaci칩n</a> para obtener detalles sobre c칩mo usar los vol칰menes CSI). <br><br><h2>  Crear una nueva instant치nea en Kubernetes </h2><br>  Una vez que el objeto <code>VolumeSnapshotClass</code> definido y es el volumen del que desea eliminar la instant치nea, puede realizar esta operaci칩n creando el objeto <code>VolumeSnapshot</code> . <br><br>  La fuente de la instant치nea est치 determinada por dos par치metros: <br><br><ul><li>  <code>kind</code> : aqu칤 <code>PersistentVolumeClaim</code> indica <code>PersistentVolumeClaim</code> ; </li><li>  <code>name</code> : el nombre real del objeto de PVC. </li></ul><br>  Se entiende que el espacio de nombres del volumen para el que se crea la instant치nea est치 determinado por el espacio de nombres del objeto <code>VolumeSnapshot</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: new-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass source: name: mypvc kind: PersistentVolumeClaim</code> </pre> <br>  La especificaci칩n <code>VolumeSnapshot</code> puede <code>VolumeSnapshot</code> una <code>VolumeSnapshotClass</code> que contiene informaci칩n sobre qu칠 controlador CSI se utilizar치 para crear la instant치nea.  Como se inform칩 anteriormente, despu칠s de crear el objeto <code>VolumeSnapshot</code> el par치metro <code>fakeSnapshotOption: foo</code> y todos los secretos mencionados de <code>VolumeSnapshotClass</code> se pasan al complemento CSI <code>com.example.csi-driver</code> en la llamada <code>CreateSnapshot</code> . <br><br>  En respuesta a dicha solicitud, el controlador CSI toma una instant치nea del volumen y luego crea autom치ticamente un objeto <code>VolumeSnapshotContent</code> que representa la nueva instant치nea y vincula este objeto a <code>VolumeSnapshot</code> , <code>VolumeSnapshot</code> listo para usar.  Si el controlador CSI no puede crear una instant치nea y devuelve un error, el controlador de la instant치nea informa este error en el estado del objeto <code>VolumeSnapshot</code> y <b>no</b> hace nuevos intentos (este comportamiento es diferente de otros controladores en Kubernetes; se implementa para no crear una instant치nea en momentos impredecibles) . <br><br>  Si no se especifica la clase de instant치nea, external-snapshotter intentar치 encontrar la clase predeterminada y usarla para la instant치nea creada.  En este caso, el controlador CSI se침alado por el <code>snapshotter</code> en la clase predeterminada debe corresponder al controlador CSI se침alado por el <code>provisioner</code> en la clase de almacenamiento de PVC. <br><br>  Tenga en cuenta que la publicaci칩n alfa de instant치neas para Kubernetes no proporciona una garant칤a de coherencia.  Para garantizar datos completos en una instant치nea, es necesario preparar adecuadamente la aplicaci칩n (detener la aplicaci칩n, congelar el sistema de archivos, etc.) antes de eliminarla. <br><br>  Para <code>VolumeSnapshot</code> que el objeto <code>VolumeSnapshot</code> ha <code>VolumeSnapshot</code> creado y asociado con el <code>VolumeSnapshotContent</code> , puede usar el <code>kubectl describe volumesnapshot</code> : <br><br><ul><li>  <code>Ready</code> debe ser <code>true</code> en <code>Status</code> , lo que indicar치 que la instant치nea de volumen est치 lista para su uso. </li><li>  El campo <code>Creation Time</code> muestra cu치ndo se tom칩 realmente la instant치nea. </li><li>  El campo <code>Restore Size</code> es el tama침o de volumen m칤nimo para restaurar una instant치nea. </li><li>  El campo <code>Snapshot Content Name</code> en la especificaci칩n apunta al objeto <code>VolumeSnapshotContent</code> creado para esta instant치nea. </li></ul><br><h2>  Importar una instant치nea existente en Kubernetes </h2><br>  Se puede importar una instant치nea existente en Kubernetes creando manualmente un objeto <code>VolumeSnapshotContent</code> que representar치 esta instant치nea.  Dado que <code>VolumeSnapshotContent</code> es un objeto API que no est치 vinculado a un espacio de nombres, solo el administrador del sistema tiene los derechos para crearlo. <br><br>  Cuando se <code>VolumeSnapshotContent</code> objeto <code>VolumeSnapshotContent</code> , el usuario puede crear otro objeto, <code>VolumeSnapshot</code> , que lo se침alar치.  El controlador externo de instant치neas marcar치 la instant치nea como lista despu칠s de verificar la existencia y la conexi칩n correcta entre los <code>VolumeSnapshotContent</code> <code>VolumeSnapshot</code> y <code>VolumeSnapshotContent</code> .  Una instant치nea est치 lista para usarse en Kubernetes cuando se establece esta conexi칩n. <br><br>  El objeto <code>VolumeSnapshotContent</code> debe crearse con los siguientes campos que representan la instant치nea preaprovisionada: <br><br><ul><li>  <code>csiVolumeSnapshotSource</code> : informaci칩n que identifica una instant치nea: <br><ul><li>  <code>snapshotHandle</code> : nombre / identificador de la instant치nea.  Campo obligatorio; </li><li>  <code>driver</code> : el controlador CSI sol칤a funcionar con este volumen.  Campo obligatorio  Debe coincidir con el nombre de la <code>snapshotter</code> en el controlador (controlador de instant치nea); </li><li>  <code>creationTime</code> y <code>restoreSize</code> : para vol칰menes <code>restoreSize</code> , estos campos son opcionales.  El controlador externo de instant치neas las actualizar치 autom치ticamente despu칠s de crear una instant치nea. </li></ul></li><li>  <code>volumeSnapshotRef</code> : puntero al objeto <code>VolumeSnapshot</code> al que se debe adjuntar este objeto (es decir, <code>VolumeSnapshotContent</code> ): <br><ul><li>  <code>name</code> y <code>namespace</code> : el nombre y el espacio de nombres del objeto <code>VolumeSnapshot</code> cuyos contenidos est치n vinculados; </li><li>  <code>UID</code> : campo opcional (para vol칰menes preparados previamente).  El controlador de instant치neas externas actualizar치 autom치ticamente este campo despu칠s del enlace.  Si el usuario define este campo, debe asegurarse de que coincida con el UID de la instant치nea para la que se produce el enlace.  Si no existe dicha correspondencia, el contenido se considera irrelevante (objeto hu칠rfano) y, por lo tanto, el controlador lo eliminar치 tanto a 칠l como a la instant치nea asociada. </li></ul></li><li>  <code>snapshotClassName</code> es un campo opcional.  El controlador externo de instant치neas lo actualizar치 autom치ticamente despu칠s del enlace. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotContent metadata: name: static-snapshot-content spec: csiVolumeSnapshotSource: driver: com.example.csi-driver snapshotHandle: snapshotcontent-example-id volumeSnapshotRef: kind: VolumeSnapshot name: static-snapshot-demo namespace: demo-namespace</code> </pre> <br>  Se debe crear un objeto <code>VolumeSnapshot</code> para que el usuario pueda trabajar con la instant치nea.  En ella: <br><br><ul><li>  <code>snapshotClassName</code> : nombre de la clase de instant치nea del volumen.  Campo opcional.  Si se establece, el campo de <code>snapshotter</code> en la clase de instant치nea debe coincidir con el nombre del controlador de instant치nea.  Si no se establece, el controlador buscar치 la clase de instant치nea predeterminada; </li><li>  <code>snapshotContentName</code> : el nombre del contenido del volumen de la instant치nea.  Campo obligatorio para vol칰menes preparados previamente. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: static-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass snapshotContentName: static-snapshot-content</code> </pre> <br>  Cuando se crean estos objetos, el controlador de instant치neas los vincular치, establecer치 el campo <code>Ready</code> (en <code>Status</code> ) en <code>True</code> , lo que indica que la instant치nea est치 lista para su uso. <br><br><h2>  Preparaci칩n de un nuevo volumen a partir de una instant치nea en Kubernetes </h2><br>  Para crear un nuevo volumen <code>dataSource</code> previamente con datos del objeto de instant치nea, use el nuevo campo <code>dataSource</code> en <code>PersistentVolumeClaim</code> .  Tiene tres par치metros: <br><br><ul><li>  <code>name</code> : nombre del objeto <code>VolumeSnapshot</code> que representa el origen de la instant치nea; </li><li>  <code>kind</code> : debe establecerse como <code>VolumeSnapshot</code> ; </li><li>  <code>apiGroup</code> : debe ser <code>snapshot.storage.k8s.io</code> . </li></ul><br>  Se supone que el espacio de nombres de la fuente, <code>VolumeSnapshot</code> , coincide con el espacio de nombres de <code>PersistentVolumeClaim</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc-restore Namespace: demo-namespace spec: storageClassName: csi-storageclass dataSource: name: new-snapshot-demo kind: VolumeSnapshot apiGroup: snapshot.storage.k8s.io accessModes: - ReadWriteOnce resources: requests: storage: 1Gi</code> </pre> <br>  Cuando se crea el objeto <code>PersistentVolumeClaim</code> , llamar치 al aprovisionamiento del nuevo volumen, rellenado previamente con datos de la instant치nea especificada. <br><br><h2>  쮺칩mo agregar compatibilidad con instant치neas a mi controlador CSI si soy un desarrollador de almacenamiento? </h2><br>  Para proporcionar soporte para las instant치neas, se deben agregar capacidades de controlador adicionales al controlador CSI: <code>CREATE_DELETE_SNAPSHOT</code> y <code>LIST_SNAPSHOTS</code> , as칤 como controladores RPC adicionales: <code>CreateSnapshot</code> , <code>DeleteSnapshot</code> , <code>ListSnapshots</code> .  Consulte <a href="">la especificaci칩n CSI para m치s</a> detalles. <br><br>  Aunque Kubernetes proporciona las <a href="">pautas</a> m치s <a href="">b치sicas</a> para empaquetar e implementar el Controlador de volumen CSI, existe un <a href="">mecanismo recomendado</a> para implementar un controlador CSI arbitrario en contenedores en Kubernetes para simplificar este proceso. <br><br>  Como parte del proceso de implementaci칩n recomendado, el equipo de Kubernetes sugiere utilizar una variedad de contenedores de sidecar (es decir, auxiliares), incluido un contenedor de sidecar con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">snapshotter externo</a> . <br><br>  El mencionado snapshotter externo supervisa los objetos <code>VolumeSnapshot</code> y <code>VolumeSnapshotContent</code> en el Servidor API, invocando las <code>DeleteSnapshot</code> <code>CreateSnapshot</code> y <code>DeleteSnapshot</code> para el punto final CSI.  El contenedor de sidecar con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aprovisionador externo</a> CSI tambi칠n se ha actualizado para admitir la recuperaci칩n de volumen de instant치neas utilizando el nuevo campo PVC <code>dataSource</code> . <br><br>  Para admitir las capacidades de instant치neas, se recomienda a los fabricantes de almacenamiento implementar contenedores de sidecar con un snapshotter externo adem치s de un aprovisionador externo, y colocar el controlador CSI en un <code>StatefulSet</code> , como se muestra en el siguiente diagrama: <br><br><img src="https://habrastorage.org/webt/9e/og/xm/9eogxmximi8i_y-6tlhber-xjts.png"><br><br>  En <a href="">este ejemplo de implementaci칩n, hay</a> dos contenedores de sidecar, un aprovisionador externo y un snapshotter externo, y los controladores CSI se implementan con el complemento CSI hostpath dentro del pod StatefulSet.  El CSI hostpath es un complemento de ejemplo que no est치 dise침ado para usarse en producci칩n. <br><br><h2>  쮺u치les son las limitaciones de la versi칩n alfa? </h2><br>  La versi칩n alfa de la implementaci칩n de la instant치nea en Kubernetes tiene las siguientes limitaciones: <br><br><ul><li>  No se admite la reversi칩n de un volumen existente a un estado anterior representado por una instant치nea (solo se admite el aprovisionamiento de un nuevo volumen desde una instant치nea). </li><li>  La restauraci칩n en contexto no es compatible con <code>PersistentVolumeClaim</code> existente de la instant치nea: es decir  el aprovisionamiento de un nuevo volumen de la instant치nea funciona, pero no actualiza el <code>PersistentVolumeClaim</code> existente para que apunte a un nuevo volumen y el PVC vuelva a un estado anterior (solo se admite el uso de un nuevo volumen creado a partir de una instant치nea a trav칠s de un nuevo PV / PVC). </li><li>  Las garant칤as para la coherencia de las instant치neas no van m치s all치 de las garant칤as proporcionadas por el sistema de almacenamiento (por ejemplo, integridad cuando se descarta). </li></ul><br><h2>  Que sigue </h2><br>  El equipo de Kubernetes planea llevar la implementaci칩n de instant치neas para CSI a la versi칩n beta en las versiones 1.13 o 1.14, dependiendo de los comentarios recibidos y la adaptaci칩n de la tecnolog칤a. <br><br><h2>  쮺칩mo encontrar m치s detalles? </h2><br>  Consulte la documentaci칩n adicional de instant치neas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">k8s.io/docs/concepts/storage/volume-snapshots</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kubernetes-csi.github.io/docs</a> . <br><br><h2>  PD del traductor </h2><br>  Lea tambi칠n en nuestro blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.12: Resumen de las innovaciones clave</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Entendemos la interfaz de almacenamiento de contenedores (en Kubernetes y no solo)</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rook es un almac칠n de datos de" autoservicio "para Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nuestra experiencia con Kubernetes en peque침os proyectos</a> " <i>(revisi칩n y video informe)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monitoreo y Kubernetes</a> " <i>(revisi칩n e informe en video)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426133/">https://habr.com/ru/post/es426133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426119/index.html">Antig칲edades: Cryptonomicon Iron</a></li>
<li><a href="../es426121/index.html">MC.exe (compilador de mensajes), rc.exe, link.exe para generar .dll para EventMessageFile</a></li>
<li><a href="../es426123/index.html">Aprende OpenGL. Leccion 6.1. PBR o renderizado f칤sicamente correcto. Teor칤a</a></li>
<li><a href="../es426125/index.html">Carrera de esteroides. Ascensores</a></li>
<li><a href="../es426131/index.html">Descargue la configuraci칩n a FPGA a trav칠s de USB o desmonte FTDI MPSSE</a></li>
<li><a href="../es426135/index.html">Nube privada para Internet de las cosas</a></li>
<li><a href="../es426137/index.html">Era de la honestidad</a></li>
<li><a href="../es426141/index.html">Red Hat reemplaza Docker con Podman</a></li>
<li><a href="../es426143/index.html">Animaci칩n 3D: 쯨ideo o interactivo?</a></li>
<li><a href="../es426145/index.html">Taller de aceptaci칩n independiente, 23 de octubre, Mosc칰</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>