<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐 🈴 🐋 Synet: un marco para lanzar redes neuronales pre-entrenadas en la CPU 🛌🏿 💟 🥓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Hola, queridos Khabrovites! 

 Los últimos dos años de mi trabajo en Synesis han estado estrechamente relacionados con el proceso de cr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Synet: un marco para lanzar redes neuronales pre-entrenadas en la CPU</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471074/"><img src="https://habrastorage.org/webt/gh/jk/rs/ghjkrs4akso0bxg4ijmhxcizzjq.jpeg" alt="mi bici"><br><br><h2>  Introduccion </h2><br>  Hola, queridos Khabrovites! <br><br>  Los últimos dos años de mi trabajo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Synesis</a> han estado estrechamente relacionados con el proceso de creación y desarrollo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Synet</a> , una biblioteca abierta para ejecutar redes neuronales convolucionales previamente capacitadas en la CPU.  En el proceso de este trabajo, tuve que encontrar una serie de puntos interesantes relacionados con la optimización de algoritmos de propagación de señal directa en redes neuronales.  Me parece que una descripción de estos puntos sería muy interesante para los lectores de Habrahabr.  A lo que quiero dedicar una serie de mis artículos.  La duración del ciclo dependerá de su interés en este tema y, por supuesto, de mi capacidad para superar la pereza.  Quiero comenzar el ciclo con una descripción de la <s>bicicleta</s> marco en sí.  Las preguntas de los algoritmos que subyacen se revelarán en artículos posteriores: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Capa de convolución: técnicas de optimización de multiplicación matricial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Capa convolucional: convolución rápida según el método de Shmuel Vinograd</a> </li></ol><br><a name="habracut"></a><br><h2>  Respuestas a preguntas </h2><br>  Antes de comenzar una descripción detallada del marco, intentaré responder de inmediato una serie de preguntas que probablemente tendrán los lectores.  La experiencia sugiere que es mejor hacerlo con anticipación, ya que muchos comienzan a escribir comentarios enojados de inmediato, sin haber leído hasta el final. <br><br>  La primera pregunta que suele surgir en tales casos: <i>¿quién ejecuta redes en procesadores convencionales ahora, cuándo hay aceleradores gráficos y aceleradores de tensor (matriz)?</i> <br>  Responderé que sí, realmente no es aconsejable llevar a cabo la capacitación de redes neuronales en la CPU, pero ejecutar redes neuronales listas para usar es una gran demanda, especialmente si la red es lo suficientemente pequeña.  Las razones para esto pueden ser diferentes, pero las principales: <br><br><ol><li>  Las CPU son más comunes.  No todas las máquinas tienen una GPU, especialmente los servidores. </li><li>  En redes neuronales pequeñas, las ganancias del uso de la GPU son pequeñas y, a veces, completamente ausentes. </li><li>  La participación efectiva de la GPU para acelerar las redes neuronales generalmente requiere una estructura de aplicación significativamente más compleja. </li></ol><br>  La siguiente pregunta posible: <i>¿Por qué usar una solución especializada para iniciar cuando hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Tensorflow</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Caffe</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">MXNet</a> ?</i> <br><br>  Puedes responder lo siguiente: <br><br><ol><li>  Una variedad de marcos no siempre es buena, por lo que si hay varios modelos capacitados en diferentes marcos en un proyecto, entonces tendrá que integrarlos en una solución preparada, lo cual es muy inconveniente. </li><li>  Los marcos clásicos fueron diseñados para entrenar modelos de GPU, ¡y ciertamente son buenos para eso!  Pero para ejecutar modelos entrenados en la CPU, su funcionalidad es redundante y no óptima. </li><li>  La confirmación de la necesidad de una solución especializada es la popularidad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">OpenVINO</a> , un marco de Intel que realiza la misma función. </li></ol><br>  Aquí inmediatamente surge una pregunta lógica sobre la invención de la bicicleta: <i>¿Por qué usar su oficio cuando hay una solución completamente profesional de un líder mundial reconocido?</i> <br>  Mi respuesta es: <br><br><ol><li>  Al comienzo del trabajo en Synet, OpenVINO todavía estaba en su infancia.  Y en verdad, si en ese momento OpenVINO estaba en su estado actual, entonces con un alto grado de probabilidad no me involucraría en mi propio proyecto. </li><li>  Puede adaptar su propio marco a sus necesidades.  Entonces, en mi caso, el requisito principal era el rendimiento máximo de un solo subproceso. </li><li>  Puede proporcionar soporte para una nueva funcionalidad lo más rápido posible si la necesita de repente (por ejemplo, agregue una nueva capa y elimine un error de rendimiento). </li><li>  Fácil de integrar en una solución llave en mano. </li><li>  El funcionamiento de la biblioteca en plataformas que no sean x86 / x86_64, por ejemplo, en ARM. </li></ol><br>  Es probable que los lectores tengan otras preguntas u objeciones, pero aún no puedo predecirlas y, por lo tanto, responderé en los comentarios al artículo.  Mientras tanto, comencemos con una descripción directa de Synet. <br><br><h2>  Descripción breve de Synet </h2><br>  Synet está escrito en <b>C ++</b> y contiene solo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">archivos de encabezado</a> .  Las optimizaciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">específicas de</a> plataforma de bajo nivel se implementan en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Simd</a> , otro proyecto de código abierto dedicado a acelerar el procesamiento de imágenes en una CPU.  Y esta es la única dependencia externa de Synet (se eligió dicho esquema para facilitar la integración de la biblioteca en proyectos de terceros).  Para lanzar redes neuronales, se utilizan modelos de su propio formato interno. <br><br><img src="https://habrastorage.org/webt/rp/bu/rn/rpburnoopqfamvrtyhhcmbp4nnm.png" alt="imagen"><br><br>  La conversión de modelos pre-entrenados al formato interno se lleva a cabo de acuerdo con un esquema de dos pasos: 1) Primero, convierta el modelo al formato del motor de inferencia (bueno <br>  OpenVINO tiene todas las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">herramientas</a> necesarias para esto).  2) Luego, desde esta representación intermedia, convierta directamente al formato interno de Synet. <br><br><img src="https://habrastorage.org/webt/pk/21/td/pk21tdeoswgjtrpnmym-hqby7-k.png" alt="imagen"><br><br>  El modelo Synet contiene dos archivos: 1) * .XML: un archivo con una descripción de la estructura del modelo.  2) * .BIN: un archivo con pesas entrenadas. <br><br><img src="https://habrastorage.org/webt/w-/xa/nr/w-xanrgyr20xe7oxpbdtlavuhua.png" alt="imagen"><br><br><h2>  Ejemplo de Synet </h2><br>  El siguiente es un ejemplo del uso de Synet para detectar caras.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Aquí</a> se toma el modelo original del motor de inferencia. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SYNET_SIMD_LIBRARY_ENABLE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Synet/Network.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Synet/Converters/InferenceEngine.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Simd/SimdDrawing.hpp"</span></span></span><span class="hljs-meta"> typedef Synet::Network</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;float&gt; Net; typedef Synet::View View; typedef Synet::Shape Shape; typedef Synet::Region&lt;float&gt; Region; typedef std::vector&lt;Region&gt; Regions; int main(int argc, char* argv[]) { Synet::ConvertInferenceEngineToSynet("ie_fd.xml", "ie_fd.bin", true, "synet.xml", "synet.bin"); Net net; net.Load("synet.xml", "synet.bin"); net.Reshape(256, 256, 1); Shape shape = net.NchwShape(); View original; original.Load("faces_0.ppm"); View resized(shape[3], shape[2], original.format); Simd::Resize(original, resized, ::SimdResizeMethodArea); net.SetInput(resized, 0.0f, 255.0f); net.Forward(); Regions faces = net.GetRegions(original.width, original.height, 0.5f, 0.5f); uint32_t white = 0xFFFFFFFF; for (size_t i = 0; i &lt; faces.size(); ++i) { const Region &amp; face = faces[i]; ptrdiff_t l = ptrdiff_t(face.x - face.w / 2); ptrdiff_t t = ptrdiff_t(face.y - face.h / 2); ptrdiff_t r = ptrdiff_t(face.x + face.w / 2); ptrdiff_t b = ptrdiff_t(face.y + face.h / 2); Simd::DrawRectangle(original, l, t, r, b, white); } original.Save("annotated_faces_0.ppm"); return 0; }</span></span></span></span></code> </pre> <br>  Como resultado del ejemplo, debería aparecer una imagen con caras anotadas: <br><br><img src="https://habrastorage.org/webt/fm/vt/cd/fmvtcdwcodslghhenbzsd2pjbz8.jpeg" alt="imagen"><br><br>  Ahora tomemos un ejemplo de los pasos: <br><br><ol><li>  Primero, el modelo se convierte del formato del motor de inferencia a Synet: <br><br><pre> <code class="cpp hljs">Synet::ConvertInferenceEngineToSynet(<span class="hljs-string"><span class="hljs-string">"ie_fd.xml"</span></span>, <span class="hljs-string"><span class="hljs-string">"ie_fd.bin"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"synet.xml"</span></span>, <span class="hljs-string"><span class="hljs-string">"synet.bin"</span></span>);</code> </pre><br>  En realidad, este paso se realiza una vez, y luego el modelo ya convertido se usa en todas partes. </li><li>  Descargar modelo convertido: <br><br><pre> <code class="cpp hljs">Net net; net.Load(<span class="hljs-string"><span class="hljs-string">"synet.xml"</span></span>, <span class="hljs-string"><span class="hljs-string">"synet.bin"</span></span>);</code> </pre></li><li>  Un paso opcional para cambiar el tamaño de la imagen de entrada y el lote (naturalmente, el modelo debe admitir cambiar el tamaño de la imagen de entrada): <br><br><pre> <code class="cpp hljs">net.Reshape(<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre></li><li>  Cargar una imagen y llevarla al tamaño de entrada del modelo: <br><br><pre> <code class="cpp hljs">View original; original.Load(<span class="hljs-string"><span class="hljs-string">"faces_0.ppm"</span></span>); <span class="hljs-function"><span class="hljs-function">View </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(net.NchwShape()[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">], net.NchwShape()[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">], original.format)</span></span></span></span>; Simd::Resize(original, resized, ::SimdResizeMethodArea);</code> </pre></li><li>  Cargando imagen en modelo: <br><br><pre> <code class="cpp hljs">net.SetInput(resized, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">255.0f</span></span>);</code> </pre></li><li>  Inicio de la propagación de señal directa en la red: <br><br><pre> <code class="cpp hljs">net.Forward();</code> </pre></li><li>  Obtención de un conjunto de regiones con caras encontradas: <br><br><pre> <code class="cpp hljs">Regions faces = net.GetRegions(original.width, original.height, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre></li></ol><br><h2>  Comparación de rendimiento </h2><br>  Probablemente no sería del todo correcto comparar Synet con los marcos clásicos para el aprendizaje automático, por ejemplo, el motor de inferencia los <a href="" rel="nofollow">omite varias veces en varias pruebas</a> . <br>  Por lo tanto, el siguiente es un ejemplo de comparación del rendimiento de subproceso único del motor de inferencia (un producto de funcionalidad similar) y Synet en una muestra de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">conjunto de modelos abiertos</a> : <br><div class="scrollable-table"><table><tbody><tr><th>  Prueba </th><th>  Descripción </th><th>  i7-6700 3.4GHz 4c / 8t FMA / AVX-2 </th><th>  i9-7900X 3.3GHz 10c / 20t AVX-512 </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">prueba_000</a> </td><td>  Reconocimiento de atributos del vehículo (2.4 MB) </td><td>  1.520 / <font color="red">1.597</font> ms ( <font color="red">-5%</font> ) </td><td>  0,772 / <font color="green">0,690</font> ms ( <font color="green">+ 12%</font> ) </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">prueba_001</a> </td><td>  Reconocimiento de género por edad (8.2 MB) </td><td>  1.659 / 1.418 ms ( <font color="green">+ 17%</font> ) </td><td>  0.988 / <font color="green">0.804</font> ms ( <font color="green">+ 23%</font> ) </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">prueba_002</a> </td><td>  Detección de rostros (4.0 MB) </td><td>  34,26 / <font color="red">43,17</font> ms ( <font color="red">-21%</font> ) </td><td>  26,72 / 24,57 ms ( <font color="green">+ 9%</font> ) </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">test_003f</a> </td><td>  Detección de rostros (2.2 MB) </td><td>  12,63 / <font color="red">14,87</font> ms ( <font color="red">-15%</font> ) </td><td>  8.680 / <font color="red">9.326</font> ms ( <font color="red">-7%</font> ) </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">prueba_004</a> </td><td>  Reconocimiento de matrícula (4.6 MB) </td><td>  <font color="red">4.350</font> / <font color="red">4.871</font> ms ( <font color="red">-11%</font> ) </td><td>  2.838 / 2.432 ms ( <font color="green">+ 17%</font> ) </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">prueba_005</a> </td><td>  Reconocimiento de matrícula (0.7 MB) </td><td>  0.339 / <font color="green">0.260</font> ms ( <font color="green">+ 30%</font> ) </td><td>  0.200 / 0.142 ms ( <font color="green">+ 41%</font> ) </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">prueba_006</a> </td><td>  Reidentificación de rostros (4.2 MB) </td><td>  11,82 / <font color="green">9,052</font> ms ( <font color="green">+ 31%</font> ) </td><td>  8.200 / <font color="green">4.559</font> ms ( <font color="green">+ 80%</font> ) </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">prueba_007</a> </td><td>  Reidentificación de persona (3.1 MB) </td><td>  3.567 / <font color="green">3.402</font> ms ( <font color="green">+ 5%</font> ) </td><td>  <font color="green">2.471</font> / <font color="green">1.679</font> ms ( <font color="green">+ 47%</font> ) </td></tr><tr><th>  Media </th><th></th><th>  + 2% </th><th>  + 25% </th></tr></tbody></table></div><br>  Como se puede ver en la tabla, en estas pruebas en una máquina con soporte para AVX2 (i7-6700), el rendimiento de Synet generalmente corresponde al rendimiento del motor de inferencia (aunque varía mucho de un modelo a otro).  En una máquina con soporte para el AVX-512 (i9-7900X), el rendimiento de Synet es en promedio un 25% más alto que el del motor de inferencia. <br><br>  Todas las mediciones fueron realizadas por la aplicación de prueba, que se encuentra en Synet.  Entonces, si lo desea, los lectores podrán reproducir las pruebas ellos mismos: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> -b master --recurse-submodules -v https://github.com/ermig1979/Synet.git synet <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> synet ./build.sh inference_engine ./test.sh</code> </pre><br><h2>  Ventajas y desventajas. </h2><br>  Comenzaré con los profesionales: <br><br><ol><li>  El proyecto es pequeño, se implementa fácilmente en proyectos de terceros. </li><li>  Muestra un alto rendimiento de subproceso único. </li><li>  Funciona en procesadores móviles (soporta ARM-NEON). </li></ol><br>  Bueno y contras, donde sin ellos: <br><br><ol><li>  No hay soporte para GPU y otros aceleradores especiales. </li><li>  Poca paralelización de una tarea en CPU de varios núcleos. </li><li>  No hay soporte para INT8 (cuantización de pesos). </li></ol><br><h2>  Conclusión </h2><br>  Synet se está utilizando actualmente como parte del proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Kipod</a> , una plataforma basada en la nube para análisis de video.  Quizás tenga otros usuarios, pero eso no es seguro :).  En el futuro, a medida que se desarrolle el proyecto, me gustaría agregarle lo siguiente: <br><br><ol><li>  Soporte para nuevos modelos, capas, algoritmos. </li><li>  Soporte para cálculos enteros en formato INT8 (pesos cuantificados). </li><li>  Soporte informático GPU. </li><li>  Convierte del formato ONNX. </li></ol><br>  Esta lista está lejos de ser completa, y me gustaría complementarla teniendo en cuenta la opinión de la comunidad, por lo tanto, ¡espero sus comentarios!  Para que la herramienta sea útil no solo para nuestra empresa, sino también para una amplia gama de usuarios.  Además, el autor no rechazaría la asistencia de la comunidad en el proceso de desarrollo. <br>  Al describir Synet, que hice en este artículo, deliberadamente no profundicé en los detalles de su implementación interna: hay muchos algoritmos sabrosos bajo el capó, pero me gustaría revelar los detalles de su implementación en los siguientes artículos de la serie: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Capa de convolución: técnicas de optimización de multiplicación matricial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Capa convolucional: convolución rápida según el método de Shmuel Vinograd</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471074/">https://habr.com/ru/post/471074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471054/index.html">Longrid sobre el realismo de la amenaza cuántica para las criptomonedas y los problemas de la "profecía 2027"</a></li>
<li><a href="../471062/index.html">Cómo enseñarle a Alice a administrar su hogar inteligente. Informe Yandex</a></li>
<li><a href="../471066/index.html">¿Cómo se ve el archivo zip y qué podemos hacer al respecto?</a></li>
<li><a href="../471070/index.html">Qué idioma de servidor elegir ... para un desarrollador móvil</a></li>
<li><a href="../471072/index.html">¿Cuántos gramos en Telegram?</a></li>
<li><a href="../471076/index.html">Cómo Matrix creó un legado a prueba de balas</a></li>
<li><a href="../471078/index.html">Chrome bloqueará completamente el contenido mixto</a></li>
<li><a href="../471080/index.html">¿Quién es responsable de la calidad de probar la aplicación? 10 razones para obtener errores en la producción</a></li>
<li><a href="../471084/index.html">Patrones de procedimiento que se pueden usar con fichas</a></li>
<li><a href="../471086/index.html">Generador de portadas de música Python en Blender</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>