<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéπ üëª üë©üèø‚Äçüéì Application Android en m√©moire. Rapport d'optimisation pour Yandex.Luncher üíì üéæ üë©üèæ‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le syst√®me l√©ger Android Go a des exigences accrues pour les applications pr√©install√©es - la taille et la m√©moire utilis√©es. Nous avons √©t√© confront√©s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Application Android en m√©moire. Rapport d'optimisation pour Yandex.Luncher</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/448966/">  Le syst√®me l√©ger Android Go a des exigences accrues pour les applications pr√©install√©es - la taille et la m√©moire utilis√©es.  Nous avons √©t√© confront√©s au d√©fi de r√©pondre √† ces exigences.  Nous avons effectu√© un certain nombre d'optimisations et d√©cid√© de changer s√©rieusement l'architecture de notre shell graphique - Yandex.Luncher.  Le chef de l'√©quipe de d√©veloppement d'applications mobiles Alexander Starchenko a partag√© cette exp√©rience. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N0KQBUZE78E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Je m'appelle Alexander, je suis de Saint-P√©tersbourg, de l'√©quipe qui d√©veloppe Yandex.Loncher et Yandex.Phone.  Aujourd'hui, je vais vous expliquer comment nous avons optimis√© la m√©moire dans Launcher.  Tout d'abord, je vais expliquer bri√®vement ce qu'est le lanceur.  Ensuite, nous discutons des raisons pour lesquelles nous devons optimiser la m√©moire.  Apr√®s cela, nous verrons comment mesurer correctement la m√©moire et en quoi elle consiste.  Passons ensuite √† la pratique.  Je vais parler de la fa√ßon dont nous avons optimis√© la m√©moire dans Launcher et comment nous sommes parvenus √† une solution radicale au probl√®me.  Et √† la fin, je vais parler de la fa√ßon dont nous surveillons l'utilisation de la m√©moire, comment nous la gardons sous contr√¥le. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/xr/t0/xs/xrt0xsqk_pktna1g_ggaf3rd780.jpeg"><br><br>  "Lanceur" ou "Lanceur" - pas si important.  Chez Yandex, nous l'appelions Lanceur, et dans le rapport j'utiliserai le mot "Lanceur". <br><br><img src="https://habrastorage.org/webt/h8/dr/cg/h8drcg1kc0mm6cmr6zxew8g60gs.jpeg"><br><br>  Autre point important: Le lanceur est assez largement distribu√© via des pr√©r√©glages, c'est-√†-dire que lorsque vous achetez un nouveau t√©l√©phone, Yandex.Loncher peut tr√®s souvent se r√©v√©ler √™tre le seul et unique gestionnaire d'applications, le gestionnaire de bureau √† domicile sur votre t√©l√©phone. <br><br>  Maintenant, pour les raisons pour lesquelles nous devons optimiser la m√©moire.  Je vais commencer par notre raison.  En bref, c'est Android Go.  Et maintenant plus longtemps.  Fin 2017, Google a pr√©sent√© Android Oreo et sa version sp√©ciale, l'√©dition Android Oreo Go.  En quoi est-il sp√©cial?  Cette version est con√ßue pour les bas de gamme, pour les t√©l√©phones bon march√© avec jusqu'√† un gigaoctet de RAM.  Quoi d'autre est-elle sp√©ciale?  Pour les applications pr√©install√©es sur cette version d'Android, Google propose des exigences suppl√©mentaires.  En particulier - les exigences pour la consommation de RAM.  En gros, quelque temps apr√®s le lancement, la m√©moire de l'application est supprim√©e et la taille ne doit pas d√©passer 30 √† 50 m√©gaoctets pour Launcher, selon la taille de l'√©cran du t√©l√©phone.  30 sur les plus petits, 50 sur les grands √©crans. <br><br>  Il convient √©galement de noter que Google continue de d√©velopper ce domaine, et il existe d√©j√† une √©dition Android Pie Go. <br><br>  Quelles autres raisons pourrait-il y avoir pour optimiser l'utilisation de la m√©moire?  Tout d'abord, votre application sera moins susceptible de t√©l√©charger.  Deuxi√®mement, il fonctionnera plus rapidement, car il sera moins susceptible de fonctionner sur le garbage collector et la m√©moire sera allou√©e moins souvent.  Les objets suppl√©mentaires ne seront pas cr√©√©s, les vues suppl√©mentaires ne seront pas gonfl√©es, etc. Indirectement, √† en juger par notre exp√©rience, cela entra√Ænera une diminution de la taille apk de votre application.  Tout cela ensemble vous fournira plus d'installations et de meilleures notes sur Google Play. <br><br>  Ok, maintenant nous savons pourquoi optimiser la m√©moire.  Voyons par quels moyens la mesurer et en quoi elle consiste. <br><br><img src="https://habrastorage.org/webt/k5/ne/mc/k5nemcimfyrquzgc_jdeijvo0mq.jpeg"><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien depuis la diapositive</a></sub></sup> </h5><br>  Beaucoup d'entre vous ont probablement vu cette photo.  Il s'agit d'une capture d'√©cran du profil Android Studio, √† partir d'une vue de la m√©moire.  Cet outil est d√©crit de mani√®re suffisamment d√©taill√©e sur developer.android.com.  Beaucoup d'entre vous les ont probablement utilis√©s.  Qui n'a pas utilis√© - essayez. <br><br>  Qu'est-ce qui est bon ici?  C'est toujours √† port√©e de main.  Il est pratique √† utiliser dans le processus de d√©veloppement.  Cependant, il pr√©sente certains inconv√©nients.  Toutes les allocations de votre candidature ne sont pas visibles ici.  Par exemple, les polices t√©l√©charg√©es ne sont pas visibles ici.  De plus, avec l'aide de cet outil, il n'est pas pratique de voir quelles classes sont charg√©es en m√©moire, et vous ne pouvez pas utiliser cet outil en mode automatique, c'est-√†-dire que vous ne pouvez pas configurer une sorte de test automatique bas√© sur le profil Android Studio. <br><br><img src="https://habrastorage.org/webt/-g/hh/gz/-ghhgzcyruqxpu3trjt_ipssimi.jpeg"><h5>  <sup><sub>Liens depuis la diapositive: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxi√®me</a></sub></sup> </h5><br>  L'outil suivant existe depuis le d√©veloppement d'Android dans Eclipse, c'est Memory Analyzer, MAT, pour faire court.  Il est fourni en tant qu'application autonome et est compatible avec les vidages de m√©moire que vous pouvez enregistrer √† partir d'Android Studio. <br><br>  Pour ce faire, vous devrez utiliser un petit utilitaire, un convertisseur professionnel.  Il est livr√© avec l'√©dition Android Go et pr√©sente plusieurs avantages.  Par exemple, il peut cr√©er des chemins vers les racines gs.  Cela nous a beaucoup aid√©s √† voir exactement quelles classes sont charg√©es par Launcher et quand elles sont charg√©es.  Nous n'avons pas pu le faire √† l'aide d'Android Studio Profiler. <br><br><img src="https://habrastorage.org/webt/4r/uj/gz/4rujgzsgzvpcrxk6f5izyljrb8y.jpeg"><br><br>  L'outil suivant est l'utilitaire dumpsys, en particulier dumpsys meminfo.  Vous voyez ici une partie de la sortie de cette commande.  Il fournit une connaissance assez √©lev√©e de la consommation de m√©moire.  Cependant, il pr√©sente certains avantages.  Il est pratique √† utiliser en mode automatique.  Vous pouvez facilement configurer des tests qui appellent simplement cette commande.  Il montre √©galement la m√©moire imm√©diatement pour tous les processus.  Et montre tous les emplacements.  √Ä notre connaissance, Google utilise la valeur de la m√©moire de cet outil dans le processus de test. <br><br>  Prenons un exemple de sortie pour d√©crire bri√®vement en quoi consiste la m√©moire d'application.  Le premier est Java Heap, tous les emplacements de votre code Java et Kotlin.  Habituellement, cette section est suffisamment grande.  Ensuite, le tas natif.  Voici les allocations du code natif.  M√™me si vous n'utilisez pas explicitement le code natif dans votre application, des allocations seront pr√©sentes ici, car de nombreux objets Android - la m√™me vue - allouent de la m√©moire native.  La section suivante est Code.  Tout ce qui concerne le code arrive ici: bytecode, polices.  Le code peut √©galement √™tre assez volumineux si vous utilisez de nombreuses biblioth√®ques tierces non optimis√©es.  Voici la pile logicielle de Java et de code natif, g√©n√©ralement de petite taille.  Vient ensuite la m√©moire graphique.  Cela inclut Surface, les textures, c'est-√†-dire la m√©moire qui se propage entre le CPU et le GPU est utilis√©e pour le rendu.  Vient ensuite la section Private Other.  Cela inclut tout ce qui n'est pas tomb√© dans les sections ci-dessus, tout ce que le syst√®me n'a pas pu disperser sur eux.  Il s'agit g√©n√©ralement d'une sorte d'allocations natives.  Vient ensuite la section Syst√®me, c'est la partie de la m√©moire syst√®me qui est attribu√©e √† votre application. <br><br>  Et √† la fin, nous avons TOTAL, c'est la somme de toutes les sections r√©pertori√©es.  Nous voulons le r√©duire. <br><br><img src="https://habrastorage.org/webt/py/uo/bk/pyuobklgdmuxby3witoq9fltrve.jpeg"><br><br>  Que faut-il savoir d'autre sur la mesure de la m√©moire?  Tout d'abord, notre application ne contr√¥le pas enti√®rement toutes les allocations.  Autrement dit, nous, en tant que d√©veloppeurs, n'avons pas le plein contr√¥le sur le code qui sera t√©l√©charg√©. <br><br>  Ce qui suit.  La m√©moire de l'application peut beaucoup sauter.  Pendant le processus de mesure, vous pouvez observer de fortes diff√©rences dans les lectures.  Cela peut √™tre d√ª au temps n√©cessaire ainsi qu'√† divers sc√©narios.  √Ä cet √©gard, lorsque nous optimisons la m√©moire, l'analysons, il est tr√®s important de le faire dans les m√™mes conditions.  Id√©alement, sur le m√™me appareil.  Encore mieux si vous avez la possibilit√© d'appeler le garbage collector. <br><br>  Super.  Nous savons pourquoi nous devons optimiser la m√©moire, comment la mesurer correctement, en quoi elle consiste.  Passons √† la pratique, et je vais vous dire comment nous avons optimis√© la m√©moire dans Launcher. <br><br><img src="https://habrastorage.org/webt/zy/t3/1q/zyt31qv6xboliaaetsqazvim8bi.jpeg"><br><br>  Telle √©tait la situation au d√©but.  Nous avions trois processus, qui allouaient au total environ 120 m√©gaoctets.  C'est presque quatre fois plus que ce que nous aimerions recevoir. <br><br><img src="https://habrastorage.org/webt/xe/yt/tz/xeyttza29z1cbtkjhtwhanq2owm.jpeg"><br><br>  En ce qui concerne l'allocation du processus principal, il y avait une grande section de tas Java, beaucoup de graphiques, de gros code et un tas natif assez grand. <br><br><img src="https://habrastorage.org/webt/yl/8o/d6/yl8od64p4hs9jorsk5iftlexh-s.jpeg"><br><br>  Tout d'abord, nous avons abord√© le probl√®me assez na√Øvement et avons d√©cid√© de suivre certaines recommandations de Google √† partir de certaines ressources, d'essayer de r√©soudre le probl√®me rapidement.  Nous avons attir√© l'attention sur les m√©thodes synth√©tiques g√©n√©r√©es au cours du processus de compilation.  Nous en avions plus de 2 000.  En quelques heures, nous les avons tous supprim√©s, nous avons supprim√© la m√©moire. <br><br><img src="https://habrastorage.org/webt/-n/k5/sx/-nk5sxehumnmvysfxp79-yjecq0.jpeg"><br><br>  Et ils ont obtenu un gain d'environ un ou deux m√©gaoctets dans la section de code.  Super. <br><br>  Ensuite, nous avons tourn√© notre attention vers l'√©num√©ration.  Comme vous le savez, l'√©num√©ration est une classe.  Et comme Google l'a finalement admis, l'√©num√©ration n'est pas tr√®s efficace en m√©moire.  Nous avons traduit toutes les √©num√©rations en InDef et StringDef.  Ici, vous pouvez m'objecter que ProgArt vous aidera ici.  Mais en fait, ProgArt ne remplacera pas tous les √©num√©rations par des types primitifs.  Il vaut mieux le faire vous-m√™me.  Au fait, nous avions plus de 90 enum, pas mal. <br><br><img src="https://habrastorage.org/webt/cs/na/lo/csnalohjmgwggcngzvyhk3p57wo.jpeg"><br><br>  Cette optimisation a d√©j√† pris des jours, car la plupart devaient √™tre faites manuellement, et nous avons gagn√© environ trois √† six m√©gaoctets dans la section tas de Java. <br><br>  Ensuite, nous avons attir√© l'attention sur la collection.  Nous avons utilis√© des collections Java assez standard, telles que HashMap.  Nous en avions plus de 150, et tous ont √©t√© cr√©√©s au d√©but de Launcher.  Nous les avons remplac√©s par SparseArray, SimpleArrayMap et ArrayMap et avons commenc√© √† cr√©er des collections avec une taille pr√©d√©termin√©e afin que les emplacements vides ne soient pas allou√©s.  Autrement dit, nous transmettons la taille de la collection au constructeur. <br><br><img src="https://habrastorage.org/webt/dl/rt/k9/dlrtk9aikfqhhp1d5mduorrq2wy.jpeg"><br><br>  Cela a √©galement donn√© un certain gain, et cette optimisation nous a √©galement pris des jours, dont la plupart nous l'avons fait manuellement. <br><br>  Ensuite, nous avons pris une mesure plus sp√©cifique.  Nous avons vu que nous avons trois processus.  Comme nous le savons, m√™me un processus vide dans Android prend environ 8 √† 10 m√©gaoctets de m√©moire, beaucoup. <br><br>  Mon coll√®gue Arthur Vasilov a donn√© des d√©tails sur les processus.  Il n'y a pas si longtemps, lors de la conf√©rence Mosdroid, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">son rapport</a> , √©galement sur Android Go. <br><br><img src="https://habrastorage.org/webt/16/i-/z-/16i-z-on0lf0lvdu5vk6fv0yilm.jpeg"><br><br>  Qu'avons-nous eu apr√®s ces optimisations?  Sur l'appareil de test principal, nous avons observ√© une consommation de m√©moire de l'ordre de 80 √† 100 m√©gaoctets, pas assez mauvaise, mais toujours pas suffisante.  Nous avons commenc√© √† mesurer la m√©moire sur d'autres appareils.  Nous avons constat√© que sur des appareils plus rapides, la consommation de m√©moire √©tait beaucoup plus importante.  Il s'est av√©r√© que nous avions de nombreuses initialisations diff√©rentes en attente.  Apr√®s un certain temps, Launcher a gonfl√© certaines vues, lanc√© certaines biblioth√®ques, etc. <br><br><img src="https://habrastorage.org/webt/qh/ql/ci/qhqlcieho2jhn-xhewlehklbg_s.jpeg"><br><br>  Qu'avons-nous fait?  Tout d'abord, nous avons parcouru la vue, toutes les dispositions.  Suppression de toutes les vues gonfl√©es avec une visibilit√© disparue.  Ils les ont mis dans des dispositions distinctes, ont commenc√© √† les gonfler par programme.  Ceux dont nous n'avions pas besoin, nous arr√™tions g√©n√©ralement de gonfler jusqu'au moment o√π l'utilisateur en avait besoin.  Nous avons fait attention √† l'optimisation de l'image.  Nous avons arr√™t√© de charger des images que l'utilisateur ne voit pas pour le moment.  Dans le cas de Launcher, il s'agissait d'images-ic√¥nes d'applications dans la liste compl√®te des applications.  Jusqu'√† son ouverture, nous ne les exp√©dions pas.  Cela nous a donn√© une tr√®s bonne victoire dans la section graphique. <br><br>  Nous avons √©galement v√©rifi√© nos caches d'images en m√©moire.  Il s'est av√©r√© que toutes n'√©taient pas optimales; toutes les images correspondant √† l'√©cran du t√©l√©phone sur lequel Launcher √©tait ex√©cut√© n'√©taient pas stock√©es en m√©moire. <br><br>  Apr√®s cela, nous avons commenc√© √† analyser la section de code et avons remarqu√© que nous avions beaucoup de classes assez lourdes quelque part.  Il s'est av√©r√© que ce sont principalement des classes de biblioth√®que.  Nous avons trouv√© des choses √©tranges dans certaines biblioth√®ques.  L'une des biblioth√®ques a cr√©√© HashMap et dans un initialiseur statique, il l'a obstru√© avec un nombre suffisamment important d'objets. <br><br><img src="https://habrastorage.org/webt/l4/vz/tf/l4vztfbwdffshzw5jf9ltshzjbs.jpeg"><br><br>  Une autre biblioth√®que a √©galement charg√© des fichiers audio dans un bloc statique, qui occupait environ 700 kilo-octets de m√©moire. <br><br><img src="https://habrastorage.org/webt/uz/ku/-p/uzku-pmqzppvtwsdiexoxm3cs6q.jpeg"><br><br>  Nous avons arr√™t√© d'initialiser ces biblioth√®ques, nous avons commenc√© √† travailler avec elles uniquement lorsque ces fonctions sont vraiment n√©cessaires aux utilisateurs.  Toutes ces optimisations ont pris plusieurs semaines.  Nous avons beaucoup test√©, v√©rifi√© que nous n'avons pas introduit de probl√®mes suppl√©mentaires.  Mais nous avons √©galement obtenu une assez bonne victoire, environ 25 sur 40 m√©gaoctets dans les sections Native, Heap, Code et Java Heap. <br><br>  Mais cela ne suffisait pas.  La consommation de m√©moire n'est toujours pas tomb√©e √† 30 m√©gaoctets.  Il semblait que nous avions √©puis√© toutes les options pour quelques optimisations automatiques et s√ªres simples. <br><br>  Nous avons d√©cid√© d'envisager des solutions radicales.  Ici, nous avons vu deux options - la cr√©ation d'une application lite s√©par√©e ou le traitement de l'architecture Launcher et la transition vers une architecture modulaire avec la possibilit√© de construire Launcher sans modules suppl√©mentaires.  La premi√®re option est assez longue et co√ªteuse.  Tr√®s probablement, la cr√©ation d'une telle application se traduira par une application distincte √† part enti√®re pour vous, qui devra √™tre enti√®rement prise en charge et d√©velopp√©e.  D'un autre c√¥t√©, l'option avec une architecture modulaire est √©galement assez ch√®re, assez risqu√©e, mais elle est toujours plus rapide, puisque vous travaillez d√©j√† avec une base de code bien connue, vous avez d√©j√† un ensemble de tests unitaires automatiques, de tests d'int√©gration et de tests manuels cas. <br><br>  Il convient de noter que quelle que soit l'option que vous choisissez, vous devrez en quelque sorte abandonner une partie des fonctionnalit√©s de votre application dans la version pour Android Go.  C'est normal.  Google fait de m√™me dans ses applications Go. <br><br>  En cons√©quence, apr√®s avoir impl√©ment√© une architecture modulaire, nous avons r√©solu de mani√®re fiable nos probl√®mes de m√©moire et commenc√© √† passer des tests m√™me sur des appareils avec un petit √©cran, c'est-√†-dire que nous avons r√©duit la consommation de m√©moire √† 30 m√©gaoctets. <br><br><img src="https://habrastorage.org/webt/jy/n1/hc/jyn1hce7pywfquvccv4w8n1bfl4.jpeg"><br><br>  Un peu sur la surveillance de la m√©moire, sur la fa√ßon dont nous contr√¥lons l'utilisation de la m√©moire.  Tout d'abord, nous mettons en place des analyseurs statiques, le m√™me Lint on error dans les cas o√π nous utilisons enum, cr√©ons des m√©thodes synth√©tiques ou utilisons des collections non optimis√©es. <br><br>  Plus difficile encore.  Nous avons mis en place des tests d'int√©gration automatiques qui ex√©cutent Launcher sur des √©mulateurs et d√©collent apr√®s un certain temps de la consommation de m√©moire.  S'il est tr√®s diff√©rent de la version pr√©c√©dente, des avertissements et des alertes sont d√©clench√©s.  Ensuite, nous commen√ßons √† √©tudier le probl√®me et ne publions pas les modifications qui augmentent l'utilisation de la m√©moire du lanceur. <br><br>  Pour r√©sumer.  Il existe diff√©rents outils pour surveiller la m√©moire, mesurer la m√©moire pour un fonctionnement rapide et efficace.  Il vaut mieux les utiliser tous, car ils ont leurs avantages et leurs inconv√©nients. <br><br>  Les solutions radicales √† architecture modulaire se sont av√©r√©es plus fiables et plus efficaces pour nous.  Nous regrettons de ne pas les avoir pris imm√©diatement.  Mais les √©tapes dont j'ai parl√© au tout d√©but du rapport n'ont pas √©t√© vaines.  Nous avons remarqu√© que la version principale de l'application commen√ßait √† utiliser de mani√®re optimale la m√©moire, pour travailler plus rapidement.  Je vous remercie </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448966/">https://habr.com/ru/post/fr448966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448956/index.html">Col√®re contre le code: programmeurs et n√©gativit√©</a></li>
<li><a href="../fr448958/index.html">Comment Amazon choisit ses offres apparemment al√©atoires de la journ√©e. Et pourquoi les vendeurs les poursuivent-ils</a></li>
<li><a href="../fr448960/index.html">La technologie XR illimit√©e √† l'√®re de l'informatique distribu√©e</a></li>
<li><a href="../fr448962/index.html">L'efficacit√© de l'entonnoir marketing AARRR</a></li>
<li><a href="../fr448964/index.html">Le grille-pain donne aux utilisateurs plus de droits</a></li>
<li><a href="../fr448968/index.html">PHP asynchrone. Pourquoi?</a></li>
<li><a href="../fr448970/index.html">Authentification √† deux facteurs pour SSH</a></li>
<li><a href="../fr448974/index.html">Approche sans serveur pour le d√©veloppement rapide d'un service vid√©o fonctionnel</a></li>
<li><a href="../fr448976/index.html">Les √©v√©nements du printemps de Gamedev au HSE</a></li>
<li><a href="../fr448980/index.html">Notre premier d√©jeuner ensemble: pourquoi et comment nous passons notre journ√©e de test</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>