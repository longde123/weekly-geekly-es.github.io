<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏔️ 🈴 👩🏿‍🚒 Inkrementieren Sie Vektorelemente 🧘🏽 🚅 👍🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In welchem ​​Fall ist das Inkrement von std :: vector- Elementen schneller - wenn sie vom Typ uint8_t oder uint32_t sind ? 

 Um nicht abstrakt zu arg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inkrementieren Sie Vektorelemente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/475636/">  In welchem ​​Fall ist das Inkrement von <i>std :: vector-</i> Elementen schneller - wenn sie vom Typ <i>uint8_t</i> oder <i>uint32_t sind</i> ? <br><br>  Um nicht abstrakt zu argumentieren, betrachten wir zwei spezifische Implementierungen: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector32_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <a name="habracut"></a><br><h2>  Versuchen wir zu raten </h2><br>  Es ist einfach, diese Frage mit dem Benchmark zu beantworten, und etwas später werden wir es tun, aber zuerst werden wir versuchen, sie zu erraten (dies wird als "auf Grundprinzipien basierendes Denken" bezeichnet - es klingt wissenschaftlicher). <br><br>  Zunächst lohnt es sich, eine Frage zu stellen: <i>Wie groß sind diese Vektoren</i> ? <br><br>  Nun, lasst uns eine Nummer auswählen.  Es gebe jeweils 20.000 Elemente. <br><br>  Weiterhin ist bekannt, dass wir den Intel Skylake-Prozessor testen werden - wir werden die Eigenschaften von Additionsbefehlen für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8-Bit-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">32-Bit-</a> Operanden mit direkter Adressierung sehen.  Es stellt sich heraus, dass ihre Hauptanzeigen die gleichen sind: 1 Operation pro Zyklus und eine Verzögerung von 4 Zyklen pro Speicherzugriff (1).  In diesem Fall spielt die Verzögerung keine Rolle, da jede Additionsoperation unabhängig ausgeführt wird, so dass die berechnete Geschwindigkeit 1 Element pro Zyklus beträgt, vorausgesetzt, dass der gesamte Rest der Arbeit an der Schleife parallel ausgeführt wird. <br><br>  Sie können auch feststellen, dass 20.000 Elemente einem 20-KB-Datensatz für die Version mit <i>uint8_t</i> und bis zu 80 KB für die Version mit <i>uint32_t entsprechen</i> .  Im ersten Fall passen sie ideal in den L1-Level-Cache moderner x86-basierter Computer und im zweiten nicht.  Es stellt sich heraus, dass die 8-Bit-Version durch effizientes Caching einen Vorsprung bekommt. <br><br>  Schließlich stellen wir fest, dass unsere Aufgabe dem klassischen Fall der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">automatischen Vektorisierung</a> sehr ähnlich ist: In einer Schleife mit einer bekannten Anzahl von Iterationen wird eine arithmetische Operation für Elemente ausgeführt, die sich nacheinander im Speicher befinden.  In diesem Fall sollte die 8-Bit-Version einen enormen Vorteil gegenüber der 32-Bit-Version haben, da eine Vektoroperation viermal so viele Elemente verarbeitet und Intel-Prozessoren im Allgemeinen Vektoroperationen an Einzelbyte-Elementen mit derselben Geschwindigkeit wie über 32 ausführen. Bit-Elemente. <br><br>  Okay, hör auf zu schimpfen.  Es ist Zeit, sich dem Test zuzuwenden. <br><br><h2>  Benchmark </h2><br>  Ich habe die folgenden Timings für Vektoren mit 20.000 Elementen auf <i>gcc 8</i> und <i>Clang 8-Compilern</i> mit verschiedenen Optimierungsstufen erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l_/6r/k7/l_6rk7tnbeguzjnreatqtggsopg.png"></div><br>  Es stellt sich heraus, dass die Version mit <i>uint32_t</i> mit Ausnahme der Stufe <i>-O1</i> schneller als die Version mit <i>uint8_t</i> ist und in einigen Fällen von Bedeutung ist: 5,4-mal auf gcc auf der Stufe <i>-O3</i> und genau 8-mal auf clang auf beiden Stufen, <i>-O2</i> und <i>- O3</i> .  Ja, das Inkrement von 32-Bit-Ganzzahlen in <i>std :: vector</i> ist bis zu achtmal schneller als das Inkrement von 8-Bit-Ganzzahlen im gängigen Compiler mit Standardoptimierungseinstellungen. <br><br>  Wenden wir uns wie üblich der Assembler-Auflistung zu, in der Hoffnung, dass sie Aufschluss darüber gibt, was gerade passiert. <br><br>  Hier ist eine Auflistung für gcc 8 auf der <i>-O2-</i> Ebene, wobei die 8-Bit-Version „nur“ 1,5-mal langsamer ist als die 32-Bit-Version (2): <br><br>  <b>8-Bit:</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] mov rdx, QWORD PTR [rdi] inc rax mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] sub rcx, rdx cmp rax, rcx jb .L3</code> </pre> <br>  <b>32-Bit:</b> <br><pre> <code class="cpp hljs">.L9: inc DWORD PTR [rax] add rax, <span class="hljs-number"><span class="hljs-number">4</span></span> cmp rax, rdx jne .L9</code> </pre> <br>  Die 32-Bit-Version sieht genauso aus, wie wir es von einer unentwickelten (3) Schleife erwartet hatten: ein Inkrement (4) mit einer Adresse, dann drei Schleifensteuerbefehle: <i>Addiere</i> <i>rax</i> , <i>4 - ein</i> Inkrement der induktiven Variablen (5) und ein paar <i>cmp-</i> und <i>jne-</i> Befehle um die Bedingungen für das Verlassen der Schleife und den bedingten Sprung darauf zu überprüfen.  Alles sieht gut aus - die Bereitstellung würde die Kosten für das Erhöhen des Zählers und das Überprüfen des Zustands kompensieren, und unser Code würde fast die maximal mögliche Geschwindigkeit von 1 Element pro Taktzyklus (6) erreichen, aber für eine Open-Source-Anwendung reicht dies aus.  Und was ist mit der 8-Bit-Version?  Neben dem Befehl <i>inc</i> mit der Adresse werden zwei weitere Befehle zum Lesen aus dem Speicher ausgeführt sowie der <i>Unterbefehl</i> , der aus dem Nichts stammt. <br><br>  Hier ist eine Auflistung mit Kommentaren: <br><br>  <b>8-Bit:</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] ;    v[i] mov rdx, QWORD PTR [rdi] ;  v.begin inc rax ; i++ mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;  v.end sub rcx, rdx ; end - start (.. <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.size()) cmp rax, rcx ; i &lt; size() jb .L3 ; .   i &lt; size()</code> </pre> <br>  Dabei sind <i>vector :: begin</i> und <i>vector :: end</i> die internen Zeiger von <i>std :: vector</i> , mit denen Anfang und Ende der Folge von Elementen innerhalb des dafür ausgewählten Bereichs angegeben werden (7). Dies sind im Wesentlichen dieselben Werte die verwendet werden, um <i>vector :: begin ()</i> und <i>vector :: end ()</i> zu implementieren (obwohl sie von einem anderen Typ sind).  Es stellt sich heraus, dass alle zusätzlichen Befehle nur eine Folge der Berechnung von <i>vector.size () sind</i> .  Es scheint nichts Ungewöhnliches?  Schließlich wird in der 32-Bit-Version natürlich auch <i>size ()</i> berechnet, diese Befehle waren jedoch nicht in dieser Auflistung enthalten.  Die Berechnung von <i>size () fand</i> nur einmal statt - außerhalb der Schleife. <br><br>  Also, was ist los?  Die kurze Antwort lautet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pointer Aliasing</a> .  Ich werde im Folgenden eine ausführliche Antwort geben. <br><br><h2>  Ausführliche Antwort </h2><br>  Der Vektor <i>v wird</i> als Referenz an die Funktion übergeben, die tatsächlich ein maskierter Zeiger ist.  Der Compiler muss zu den Elementen <i>v :: begin</i> und <i>v :: end des</i> Vektors gehen, um seine Größe <i>size ()</i> zu berechnen. In unserem Beispiel wird <i>size ()</i> <i>bei</i> jeder Iteration berechnet.  Der Compiler ist jedoch nicht verpflichtet, den Quellcode blind zu befolgen: Er kann das Ergebnis des Aufrufs der <i>size () -</i> Funktion durchaus außerhalb der Schleife tragen, aber nur dann, wenn er sicher ist, dass sich die Semantik des Programms <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht ändert</a> .  Unter diesem Gesichtspunkt ist das Inkrement <i>v [i] ++</i> die einzige problematische Stelle in der Schleife.  Die Aufzeichnung erfolgt an einer unbekannten Adresse.  Kann eine solche Operation den Wert von size () ändern? <br><br>  Wenn der Datensatz in <i>std :: vector &lt;uint32_t&gt;</i> auftritt (d. H. Durch den Zeiger <i>uint32_t *</i> ), kann er den Wert <i>size ()</i> nicht ändern.  Das Schreiben in Objekte vom Typ <i>uint32_t</i> kann nur Objekte vom Typ <i>uint32_t</i> ändern, und die zur Berechnung von <i>size () verwendeten</i> Zeiger haben einen anderen Typ (8). <br><br>  Im Fall von <i>uint8_t lautet</i> die Antwort zumindest auf gängigen Compilern (9): Ja, theoretisch kann sich der Wert von <b><i>size ()</i></b> <b>ändern</b> , da <i>uint8_t</i> ein Alias ​​für <i>nicht signierte</i> <i>Zeichen</i> und Arrays des Typs " <i>nicht signierte Zeichen"</i> (und " <i>Zeichen"</i> ) ist <i>Alias ​​mit jedem anderen Typ</i> .  Dies bedeutet, dass das Schreiben in <i>uint8_t-Zeiger</i> nach Angaben des Compilers den Inhalt des Speichers unbekannter Herkunft an einer beliebigen Adresse ändern kann (10).  Daher wird davon ausgegangen, dass jede Inkrementierungsoperation <i>v [i] ++</i> den <i>size () -</i> Wert ändern kann und daher gezwungen ist, ihn bei jeder Iteration der Schleife neu zu berechnen. <br><br>  Wir alle wissen, dass das Schreiben in den Speicher, auf den <i>std :: vector</i> zeigt, niemals seine eigene <i>Größe</i> ändert <i>()</i> , da dies bedeuten würde, dass der Vektor selbst irgendwie in seinem eigenen Heap zugeordnet wurde, und das ist praktisch unmöglich und dem Problem von Huhn und Eiern verwandt (11).  Dem Compiler ist dies leider nicht bekannt! <br><br><h2>  Was ist mit dem Rest der Ergebnisse? </h2><br>  Nun, wir haben herausgefunden, warum die Version mit <i>uint8_</i> etwas langsamer ist als die Version von <i>uint32_t</i> auf gcc auf der <i>-O2-</i> Ebene.  Aber warum erklären Sie den enormen Unterschied - bis zu 8-mal - bei clang oder dem gleichen gcc bei <i>-O3</i> ? <br><br>  Hier ist alles einfach: Im Fall von <i>uint32_t kann</i> clang die automatische Vektorisierung von Schleifen durchführen: <br><br><pre> <code class="cpp hljs">.LBB1_6: ; =&gt;This Inner Loop Header: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>], ymm4 vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>], ymm4 add rdi, <span class="hljs-number"><span class="hljs-number">64</span></span> add rsi, <span class="hljs-number"><span class="hljs-number">2</span></span> jne .LBB1_6</code> </pre> <br>  Der Zyklus wurde 8-mal implementiert, und dies ist im Allgemeinen die maximale Leistung, die Sie erhalten können: Ein Vektor (8 Elemente) pro Taktzyklus für den L1-Cache (dies funktioniert nicht mehr, da ein Schreibvorgang pro Taktzyklus begrenzt ist (12)). <br><br>  <i>Die Vektorisierung wird</i> für <i>uint8_t</i> nicht durchgeführt, da sie durch die Notwendigkeit behindert wird, <i>size ()</i> zu berechnen, um die Schleifenbedingung bei jeder Iteration zu überprüfen.  Der Grund für die Verzögerung ist immer noch der gleiche, aber die Verzögerung selbst ist viel größer. <br><br>  Die niedrigsten Timings werden durch die automatische Vektorisierung erklärt: gcc wendet sie nur auf die Ebene <i>-O3</i> an, und clang gilt standardmäßig sowohl für die Ebene <i>-O2 als auch für die</i> Ebene <i>-O3</i> .  Der Compiler -cc level gcc generiert etwas langsameren Code als clang, da er die autovektorisierte Schleife nicht erweitert. <br><br><h2>  Korrigieren Sie die Situation </h2><br>  Wir haben herausgefunden, wo das Problem liegt - wie können wir es beheben? <br><br>  Versuchen wir zunächst eine Möglichkeit, die jedoch nicht funktioniert: Wir schreiben einen idiomatischeren Zyklus, der auf einem Iterator basiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(); i != v.end(); ++i) { (*i)++; }</code> </pre> <br>  Der Code, den <i>gcc</i> auf der Ebene <i>-O2</i> generiert, ist etwas besser als die Option mit <i>size ()</i> : <br><br><pre> <code class="cpp hljs">.L17: add BYTE PTR [rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>], rax jne .L17</code> </pre> <br>  Aus zwei zusätzlichen Leseoperationen wurde eine, da wir nun mit dem Endzeiger des Vektors vergleichen, anstatt <i>size ()</i> neu zu berechnen, wobei der Vektor-Startzeiger vom Endzeiger subtrahiert wird.  Nach der Anzahl der Anweisungen hat dieser Code <i>uint32_t</i> eingeholt, da die zusätzliche Leseoperation mit der Vergleichsoperation zusammengeführt wurde.  Das Problem ist jedoch nicht <i>behoben</i> und die automatische Vektorisierung ist immer noch nicht verfügbar, sodass <i>uint8_t</i> immer noch deutlich hinter <i>uint32_t</i> zurückliegt - mehr als fünfmal auf gcc und clang auf den Ebenen, auf denen die automatische Vektorisierung bereitgestellt wird. <br><br>  Versuchen wir etwas anderes.  Es wird uns nicht wieder gelingen, oder vielmehr, wir werden eine <i>andere</i> unwirksame Methode finden. <br><br>  In dieser Version berechnen wir <i>size ()</i> nur einmal vor der Schleife und setzen das Ergebnis in eine lokale Variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, s = v.size(); i &lt; s; i++) { v[i]++; }</code> </pre> <br>  Es scheint zu funktionieren?  Das Problem war <i>size ()</i> , und jetzt haben wir den Compiler angewiesen, das Ergebnis von <i>size ()</i> an die lokale Variable <i>s</i> am Anfang der Schleife zu übergeben, und die lokalen Variablen schneiden sich, wie Sie wissen, nicht mit anderen Daten.  Wir haben tatsächlich getan, was der Compiler nicht konnte.  Und der Code, den es generiert, ist tatsächlich besser (im Vergleich zum Original): <br><br><pre> <code class="cpp hljs">.L9: mov rdx, QWORD PTR [rdi] add BYTE PTR [rdx+rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp rax, rcx jne .L9</code> </pre> <br>  Es gibt nur eine zusätzliche Leseoperation und keinen <i>Unterbefehl</i> .  Was macht dieser zusätzliche Befehl ( <i>rdx, QWORD PTR [rdi]</i> ), wenn er nicht an der Größenberechnung beteiligt ist?  Es liest den <i>data ()</i> Zeiger von <i>v</i> ! <br><br>  Der Ausdruck <i>v [i]</i> wird als <i>* (v.data () + i)</i> implementiert, und das von <i>data () zurückgegebene</i> <i>Element (</i> und tatsächlich ein regulärer Anfangszeiger) wirft das gleiche Problem auf wie <i>size ()</i> .  Zwar habe ich diesen Vorgang in der Originalversion nicht bemerkt, da er dort "kostenlos" war, da er noch durchgeführt werden musste, um die Größe zu berechnen. <br><br>  Tragen Sie mit ein wenig mehr, wir haben fast eine Lösung gefunden.  Sie müssen nur <i>alle</i> Abhängigkeiten vom Inhalt von <i>std :: vector</i> aus unserer Schleife entfernen.  Der einfachste Weg, dies zu tun, besteht darin, unsere Redewendung mit einem Iterator ein wenig zu ändern: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(), e = v.end(); i != e; ++i) { (*i)++; }</code> </pre> <br>  Jetzt hat sich alles dramatisch geändert (hier vergleichen wir nur Versionen mit <i>uint8_t</i> - in einem speichern wir das Iteratorende in einer lokalen Variablen <i>vor der</i> Schleife, in dem anderen - nein): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lp/pe/xj/lppexj0vgqumpzvblxctc7xkkoa.png"></div><br>  Diese kleine Änderung führte zu einer 20-fachen Geschwindigkeitssteigerung bei Niveaus mit automatischer Vektorisierung.  Außerdem hat der Code mit <i>uint8_t</i> nicht nur den Code mit <i>uint32_t</i> <i>eingeholt</i> - er hat ihn mit gcc <i>-O3</i> fast genau viermal überholt und <i>-O2</i> und <i>-O3 geklirrt</i> , wie wir zu Beginn erwartet hatten, wobei wir uns auf die Vektorisierung <i>gestützt</i> haben: am Ende genau viermal mehr Elemente können durch eine Vektoroperation verarbeitet werden, und wir benötigen viermal weniger Bandbreite - unabhängig von der Cache-Ebene (13). <br><br>  Wenn Sie zu diesem Platz lesen, dann müssen Sie sich die ganze Zeit ausgerufen haben: <br><br>  <i>Aber was ist mit der in C ++ 11 eingeführten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>for-Schleife mit Band-Traversal</i></a> ?</i> <br><br>  Ich beeile mich, Ihnen zu gefallen: es funktioniert!  Dies ist in der Tat syntaktischer Zucker, hinter dem sich unsere Version mit einem Iterator in fast derselben Form verbirgt, in der wir den Endzeiger vor dem Beginn der Schleife in einer lokalen Variablen fixiert haben.  Also ist seine Geschwindigkeit gleich. <br><br>  Wenn wir uns plötzlich entschließen, in alte Höhlenzeiten zurückzukehren und eine C-ähnliche Funktion zu schreiben, würde ein solcher Code genauso gut funktionieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { a[i]++; } }</code> </pre> <br>  Hier werden der Zeiger auf das Array <i>a</i> und die Größenvariable <i>als</i> Wert an die Funktion übergeben, sodass sie nicht wie lokale Variablen durch Schreiben in den Zeiger <i>a</i> (14) geändert werden können.  Die Leistung dieses Codes entspricht der der vorherigen Optionen. <br><br>  Schließlich können Sie auf Compilern, auf denen diese Option verfügbar ist, einen Vektor mit <i>__restrict</i> (15) deklarieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc_restrict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; __restrict v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <br>  Das <i>Schlüsselwort __restrict ist</i> nicht Teil des C ++ - Standards, sondern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seit C99</a> Teil des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C-</a> Standards (als <i>Einschränkung</i> ).  Wenn es als C ++ - Erweiterung im Compiler implementiert ist, folgt es höchstwahrscheinlich der Semantik von C. Natürlich gibt es in C keine Links, sodass Sie den Link zum Vektor mental durch einen Zeiger auf den Vektor ersetzen können. <br><br>  Beachten Sie, dass restricted keine transitiven <i>Eigenschaften hat</i> : Die Aktion des <i>__restrict-Bezeichners</i> , mit der eine Verknüpfung zu <i>std :: vector</i> deklariert wird, gilt nur für die <i>Elemente</i> des Vektors selbst und nicht für die Heap-Region, auf die <i>v.data () verweist</i> .  In unserem Fall ist mehr nicht erforderlich, da es (wie bei lokalen Variablen) ausreicht, den Compiler davon zu überzeugen, dass die Terme selbst, die auf den Anfang und das Ende des Vektors zeigen, sich mit nichts überschneiden.  Die <i>Einschränkungsklausel</i> ist jedoch weiterhin relevant, da das Schreiben über <i>v.data ()</i> möglicherweise weiterhin dazu führt, dass sich andere Objekte in Ihrer Funktion aufgrund von Aliasing ändern. <br><br><h2>  Enttäuschung </h2><br>  Hier kommen wir zum letzten - und sehr enttäuschenden - Schluss.  Tatsache ist, dass alle oben gezeigten Lösungen nur für diesen speziellen Fall anwendbar sind, wenn der Vektor theoretisch mit sich selbst interferieren kann.  Die Lösung bestand darin, die Schleife zu verlassen oder das Ergebnis des Aufrufs von <i>size ()</i> oder <i>end () des</i> Vektors zu isolieren und dem Compiler <i>nicht</i> mitzuteilen, dass das Schreiben in die Vektordaten keine Auswirkungen auf andere Daten hat.  Ein solcher Code ist mit zunehmender Funktionsgröße nur schwer skalierbar. <br><br>  Das Aliasing-Problem ist nicht beseitigt, und die Schreibbefehle können immer noch "überall" abgelegt werden - es gibt einfach keine anderen Daten in dieser Funktion, die betroffen sein könnten ... vorerst.  Sobald ein neuer Code darin erscheint, wird alles wiederholt.  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel aus der Hand</a> .  Wenn Sie in kleinen Schleifen in Arrays von Elementen des Typs <i>uint8_t</i> schreiben, müssen Sie bis zum Ende mit dem Compiler kämpfen (16). <br><br><h2>  Kommentare </h2><br>  Ich freue mich über jede Rückmeldung.  Ich habe noch kein Kommentarsystem (17), daher werden wir wie üblich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Thread auf HackerNews diskutieren</a> . <br><br><ol><li>  Wenn Sie hier auf den Speicher zugreifen, wird verstanden, dass die Kette von Abhängigkeiten den Speicher durchläuft: Schreibbefehle an derselben Adresse sollten den zuletzt dort geschriebenen Wert lesen, daher sind solche Operationen abhängig (in der Praxis wird die Umleitung zum Laden (STLF) verwendet, wenn die Aufzeichnung ausreicht oft).  Abhängigkeiten des Befehls <i>add</i> beim Speicherzugriff können auf andere Weise auftreten, z. B. durch Berechnung der Adresse. In unserem Fall ist dies jedoch irrelevant. </li><li>  Hier ist nur ein kleiner Zyklus dargestellt;  Der Installationscode ist einfach und funktioniert schnell.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laden Sie den Code auf godbolt hoch</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um</a> die vollständige Liste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzuzeigen</a> . </li><li>  Vielleicht sollte man es einfach "minimiert" nennen?  Wie dem auch sei, der gcc-Compiler <i>schleift</i> normalerweise nicht einmal auf den Ebenen <i>-O2</i> und <i>-O3 herum</i> , außer in besonderen Fällen, in denen die Anzahl der Iterationen gering ist und <i>in der Kompilierungsphase bekannt ist</i> .  Aus diesem Grund zeigt gcc im Vergleich zu clang geringere Testergebnisse, spart aber viel an Codegröße.  Sie können <i>gcc zwingen, Loops zu entrollen,</i> indem Sie die <i>Profiloptimierung</i> anwenden oder das <i>Flag -funroll-loops aktivieren</i> . </li><li>  Tatsächlich ist der <i>Befehl inc DWORD PTR [rax]</i> in gcc eine <i>fehlende</i> Optimierung: Es ist fast immer besser, den Befehl <i>add [rax], 1 zu verwenden</i> , da er nur aus 2 kombinierten Mikrooperationen gegenüber 3 für <i>inc besteht</i> .  In diesem Fall beträgt der Unterschied nur etwa 6%. Wenn der Zyklus jedoch geringfügig erweitert würde, so dass nur der Aufzeichnungsvorgang wiederholt würde, wäre der Unterschied signifikanter (eine weitere Erweiterung würde keine Rolle mehr spielen, da wir die Grenze von 1 erreichen würden) Aufzeichnungsvorgang pro Zyklus, der nicht von der Gesamtzahl der Mikrooperationen abhängt). </li><li>  Ich nenne diese Variable <i>induktiv</i> und nicht nur <i>i</i> wie im Quellcode, weil der Compiler die Einheitsoperationen des Inkrements <i>i</i> in 4-Byte-Inkremente des im <i>Rax-</i> Register gespeicherten Zeigers konvertiert und die Schleifenbedingung entsprechend korrigiert hat.  In der ursprünglichen Form adressiert unsere Schleife die Elemente des Vektors und inkrementiert nach dieser Konvertierung den Zeiger / Iterator. Dies ist eine Möglichkeit, <i>die Betriebskosten</i> zu <i>senken</i> . </li><li>  Wenn Sie <i>-funroll-loops</i> aktivieren, <i>beträgt</i> die Geschwindigkeit auf gcc bei einem <i>8-fachen Rollout</i> 1,08 Takte pro Element.  Aber selbst mit diesem Flag wird er die Schleife für die Version mit 8-Bit-Elementen <i>nicht</i> erweitern, sodass die Verzögerung der Geschwindigkeit noch deutlicher wird! </li><li>  Diese Member haben einen <i>privaten</i> Modifizierer und ihre Namen sind implementierungsabhängig, aber in stdlibc ++ heißen sie nicht wirklich <i>start</i> und <i>finish</i> , wie in gcc.  Sie heißen <i>_Vector_base :: _ Vector_impl :: _ M_start</i> und <i>_Vector_base :: _ Vector_impl :: _ M_finish</i> , d.h.  <i>Geben Sie</i> die <i>_Vector_impl-</i> Struktur ein, die ein Mitglied von <i>_M_impl</i> (und die einzige) der <i>_Vector_base-</i> Klasse ist und die wiederum die Basisklasse für <i>std :: vector ist</i> .  Na gut!  Glücklicherweise kann der Compiler mit diesem Stapel von Abstraktionen problemlos umgehen. </li><li>  Der Standard schreibt nicht vor, wie die internen Typen von <i>std :: vector-</i> Elementen lauten sollen, aber in der libstdc ++ - Bibliothek werden sie einfach als <i>Alloc :: pointer</i> (wobei <i>Alloc</i> der <i>Allokator</i> für den Vektor ist) und für das standardmäßige, <i>std :: zugeteilte Objekt</i> einfach als <i>Alloc :: pointer</i> definiert Zeiger vom Typ <i>T *</i> , d.h.  reguläre Zeiger auf ein Objekt - in diesem Fall <i>uint32_t *</i> . </li><li>  Ich mache diese Reservierung aus einem Grund.  Es besteht der Verdacht, dass <i>uint8_t</i> als ein anderer Typ als <i>char</i> , <i>signed char</i> und <i>unsigned char angesehen werden kann</i> .  Da Aliasing mit <i>Zeichentypen</i> funktioniert, gilt dies im Prinzip nicht für <i>uint8_t</i> und sollte sich wie jeder andere Nicht-Zeichentyp verhalten.  Ich kenne jedoch keinen der Compiler, der das glaubt: In allen ist <i>typedef</i> <i>uint8_t</i> ein Alias <i>ohne Vorzeichen</i> , sodass Compiler den Unterschied zwischen ihnen nicht erkennen, auch wenn sie ihn gerne verwenden würden. </li><li>  Mit "unbekannter Herkunft" meine ich hier nur, dass der Compiler nicht weiß, wohin der Inhalt des Speichers zeigt oder wie er erschienen ist.  Dies umfasst beliebige Zeiger, die an die Funktion übergeben werden, sowie globale und statische Variablen.  , ,            ,  ,   ,     (    -     ). ,     <i>malloc</i>  <i>new</i> ,   <i></i>    ,      ,   ,        :  ,      ,       . ,       <i>malloc</i>  <i>new</i> . </li><li>  ,   <i>std::vector</i>  - <i></i> ? ,    <i>std::vector&lt;uint8_t&gt; a</i>     <i></i>  <i>a.data()</i>    <i>placement new</i>       <i>b</i> .   <i>std::swap(a, b)</i> ,       – ,  <i>b</i>      ?       ,     <i>b</i> .       :          -  (,       ),      ,       . </li><li>        8 , ..  32 .     ,   <i>std::vector</i>      . </li><li> -        4 :     ,        ,   – .       : 8-      L1,  32-        –   L2    ,      . </li><li>        ,  –  :        .      ,      ,    «». </li><li>        <i>v[i]</i> ,           . </li><li>     . ,   «» ,          <i>uint8_t</i> .      , ,       ,  <i>uint8_t</i> ,          . ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   clang,      gcc</a> ,     ,    <i>uint8_t</i> . -     <i>gcc</i>          ,   .     ,     , -     <i>__restrict</i> . </li><li>  -  ,       ,      (   Disqus),           (        ),    . </li></ol><br> <i>     .  : Travis Downs. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Incrementing vectors</a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475636/">https://habr.com/ru/post/de475636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475614/index.html">Automatisierung für die Kleinsten. Zweiter Teil. Netzwerkdesign</a></li>
<li><a href="../de475618/index.html">So erstellen Sie einen Smart Python-Vertrag im Ontology-Netzwerk. Teil 2: Speicher-API</a></li>
<li><a href="../de475624/index.html">PHP-Watcher: Ein Tool, das die Entwicklung langlebiger Anwendungen vereinfacht</a></li>
<li><a href="../de475626/index.html">Können Autotests eine Person auf der Suche nach Schwachstellen ersetzen: Interview mit Alexandra Svatikova</a></li>
<li><a href="../de475630/index.html">Knative - eine k8s-basierte Plattform als Service mit serverloser Unterstützung</a></li>
<li><a href="../de475640/index.html">Wenn Sie etwas erstellen, vermeiden Sie den Zeitplan des Managers.</a></li>
<li><a href="../de475642/index.html">Heap-Only-Tupel-Mechanismus in PostgreSQL</a></li>
<li><a href="../de475646/index.html">Yuri Ryabtsev: "Das erste Abfangen einer ballistischen Rakete ist ein Ereignis, das in etwa Gagarins Flug entspricht."</a></li>
<li><a href="../de475652/index.html">Wie wir eine mobile Anwendung auf dem Aurora OS (Sailfish Mobile OS RUS) entwickelt haben</a></li>
<li><a href="../de475654/index.html">„Im ersten Monat hatten drei gesunde Männer Angst, die Turbine einzuschalten“ - so baut Alexei Statsenko ein Jetpack von Grund auf neu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>