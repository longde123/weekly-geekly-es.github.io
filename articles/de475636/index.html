<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèîÔ∏è üà¥ üë©üèø‚Äçüöí Inkrementieren Sie Vektorelemente üßòüèΩ üöÖ üëçüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In welchem ‚Äã‚ÄãFall ist das Inkrement von std :: vector- Elementen schneller - wenn sie vom Typ uint8_t oder uint32_t sind ? 

 Um nicht abstrakt zu arg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inkrementieren Sie Vektorelemente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/475636/">  In welchem ‚Äã‚ÄãFall ist das Inkrement von <i>std :: vector-</i> Elementen schneller - wenn sie vom Typ <i>uint8_t</i> oder <i>uint32_t sind</i> ? <br><br>  Um nicht abstrakt zu argumentieren, betrachten wir zwei spezifische Implementierungen: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector32_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <a name="habracut"></a><br><h2>  Versuchen wir zu raten </h2><br>  Es ist einfach, diese Frage mit dem Benchmark zu beantworten, und etwas sp√§ter werden wir es tun, aber zuerst werden wir versuchen, sie zu erraten (dies wird als "auf Grundprinzipien basierendes Denken" bezeichnet - es klingt wissenschaftlicher). <br><br>  Zun√§chst lohnt es sich, eine Frage zu stellen: <i>Wie gro√ü sind diese Vektoren</i> ? <br><br>  Nun, lasst uns eine Nummer ausw√§hlen.  Es gebe jeweils 20.000 Elemente. <br><br>  Weiterhin ist bekannt, dass wir den Intel Skylake-Prozessor testen werden - wir werden die Eigenschaften von Additionsbefehlen f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8-Bit-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">32-Bit-</a> Operanden mit direkter Adressierung sehen.  Es stellt sich heraus, dass ihre Hauptanzeigen die gleichen sind: 1 Operation pro Zyklus und eine Verz√∂gerung von 4 Zyklen pro Speicherzugriff (1).  In diesem Fall spielt die Verz√∂gerung keine Rolle, da jede Additionsoperation unabh√§ngig ausgef√ºhrt wird, so dass die berechnete Geschwindigkeit 1 Element pro Zyklus betr√§gt, vorausgesetzt, dass der gesamte Rest der Arbeit an der Schleife parallel ausgef√ºhrt wird. <br><br>  Sie k√∂nnen auch feststellen, dass 20.000 Elemente einem 20-KB-Datensatz f√ºr die Version mit <i>uint8_t</i> und bis zu 80 KB f√ºr die Version mit <i>uint32_t entsprechen</i> .  Im ersten Fall passen sie ideal in den L1-Level-Cache moderner x86-basierter Computer und im zweiten nicht.  Es stellt sich heraus, dass die 8-Bit-Version durch effizientes Caching einen Vorsprung bekommt. <br><br>  Schlie√ülich stellen wir fest, dass unsere Aufgabe dem klassischen Fall der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">automatischen Vektorisierung</a> sehr √§hnlich ist: In einer Schleife mit einer bekannten Anzahl von Iterationen wird eine arithmetische Operation f√ºr Elemente ausgef√ºhrt, die sich nacheinander im Speicher befinden.  In diesem Fall sollte die 8-Bit-Version einen enormen Vorteil gegen√ºber der 32-Bit-Version haben, da eine Vektoroperation viermal so viele Elemente verarbeitet und Intel-Prozessoren im Allgemeinen Vektoroperationen an Einzelbyte-Elementen mit derselben Geschwindigkeit wie √ºber 32 ausf√ºhren. Bit-Elemente. <br><br>  Okay, h√∂r auf zu schimpfen.  Es ist Zeit, sich dem Test zuzuwenden. <br><br><h2>  Benchmark </h2><br>  Ich habe die folgenden Timings f√ºr Vektoren mit 20.000 Elementen auf <i>gcc 8</i> und <i>Clang 8-Compilern</i> mit verschiedenen Optimierungsstufen erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l_/6r/k7/l_6rk7tnbeguzjnreatqtggsopg.png"></div><br>  Es stellt sich heraus, dass die Version mit <i>uint32_t</i> mit Ausnahme der Stufe <i>-O1</i> schneller als die Version mit <i>uint8_t</i> ist und in einigen F√§llen von Bedeutung ist: 5,4-mal auf gcc auf der Stufe <i>-O3</i> und genau 8-mal auf clang auf beiden Stufen, <i>-O2</i> und <i>- O3</i> .  Ja, das Inkrement von 32-Bit-Ganzzahlen in <i>std :: vector</i> ist bis zu achtmal schneller als das Inkrement von 8-Bit-Ganzzahlen im g√§ngigen Compiler mit Standardoptimierungseinstellungen. <br><br>  Wenden wir uns wie √ºblich der Assembler-Auflistung zu, in der Hoffnung, dass sie Aufschluss dar√ºber gibt, was gerade passiert. <br><br>  Hier ist eine Auflistung f√ºr gcc 8 auf der <i>-O2-</i> Ebene, wobei die 8-Bit-Version ‚Äûnur‚Äú 1,5-mal langsamer ist als die 32-Bit-Version (2): <br><br>  <b>8-Bit:</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] mov rdx, QWORD PTR [rdi] inc rax mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] sub rcx, rdx cmp rax, rcx jb .L3</code> </pre> <br>  <b>32-Bit:</b> <br><pre> <code class="cpp hljs">.L9: inc DWORD PTR [rax] add rax, <span class="hljs-number"><span class="hljs-number">4</span></span> cmp rax, rdx jne .L9</code> </pre> <br>  Die 32-Bit-Version sieht genauso aus, wie wir es von einer unentwickelten (3) Schleife erwartet hatten: ein Inkrement (4) mit einer Adresse, dann drei Schleifensteuerbefehle: <i>Addiere</i> <i>rax</i> , <i>4 - ein</i> Inkrement der induktiven Variablen (5) und ein paar <i>cmp-</i> und <i>jne-</i> Befehle um die Bedingungen f√ºr das Verlassen der Schleife und den bedingten Sprung darauf zu √ºberpr√ºfen.  Alles sieht gut aus - die Bereitstellung w√ºrde die Kosten f√ºr das Erh√∂hen des Z√§hlers und das √úberpr√ºfen des Zustands kompensieren, und unser Code w√ºrde fast die maximal m√∂gliche Geschwindigkeit von 1 Element pro Taktzyklus (6) erreichen, aber f√ºr eine Open-Source-Anwendung reicht dies aus.  Und was ist mit der 8-Bit-Version?  Neben dem Befehl <i>inc</i> mit der Adresse werden zwei weitere Befehle zum Lesen aus dem Speicher ausgef√ºhrt sowie der <i>Unterbefehl</i> , der aus dem Nichts stammt. <br><br>  Hier ist eine Auflistung mit Kommentaren: <br><br>  <b>8-Bit:</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] ;    v[i] mov rdx, QWORD PTR [rdi] ;  v.begin inc rax ; i++ mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;  v.end sub rcx, rdx ; end - start (.. <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.size()) cmp rax, rcx ; i &lt; size() jb .L3 ; .   i &lt; size()</code> </pre> <br>  Dabei sind <i>vector :: begin</i> und <i>vector :: end</i> die internen Zeiger von <i>std :: vector</i> , mit denen Anfang und Ende der Folge von Elementen innerhalb des daf√ºr ausgew√§hlten Bereichs angegeben werden (7). Dies sind im Wesentlichen dieselben Werte die verwendet werden, um <i>vector :: begin ()</i> und <i>vector :: end ()</i> zu implementieren (obwohl sie von einem anderen Typ sind).  Es stellt sich heraus, dass alle zus√§tzlichen Befehle nur eine Folge der Berechnung von <i>vector.size () sind</i> .  Es scheint nichts Ungew√∂hnliches?  Schlie√ülich wird in der 32-Bit-Version nat√ºrlich auch <i>size ()</i> berechnet, diese Befehle waren jedoch nicht in dieser Auflistung enthalten.  Die Berechnung von <i>size () fand</i> nur einmal statt - au√üerhalb der Schleife. <br><br>  Also, was ist los?  Die kurze Antwort lautet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pointer Aliasing</a> .  Ich werde im Folgenden eine ausf√ºhrliche Antwort geben. <br><br><h2>  Ausf√ºhrliche Antwort </h2><br>  Der Vektor <i>v wird</i> als Referenz an die Funktion √ºbergeben, die tats√§chlich ein maskierter Zeiger ist.  Der Compiler muss zu den Elementen <i>v :: begin</i> und <i>v :: end des</i> Vektors gehen, um seine Gr√∂√üe <i>size ()</i> zu berechnen. In unserem Beispiel wird <i>size ()</i> <i>bei</i> jeder Iteration berechnet.  Der Compiler ist jedoch nicht verpflichtet, den Quellcode blind zu befolgen: Er kann das Ergebnis des Aufrufs der <i>size () -</i> Funktion durchaus au√üerhalb der Schleife tragen, aber nur dann, wenn er sicher ist, dass sich die Semantik des Programms <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht √§ndert</a> .  Unter diesem Gesichtspunkt ist das Inkrement <i>v [i] ++</i> die einzige problematische Stelle in der Schleife.  Die Aufzeichnung erfolgt an einer unbekannten Adresse.  Kann eine solche Operation den Wert von size () √§ndern? <br><br>  Wenn der Datensatz in <i>std :: vector &lt;uint32_t&gt;</i> auftritt (d. H. Durch den Zeiger <i>uint32_t *</i> ), kann er den Wert <i>size ()</i> nicht √§ndern.  Das Schreiben in Objekte vom Typ <i>uint32_t</i> kann nur Objekte vom Typ <i>uint32_t</i> √§ndern, und die zur Berechnung von <i>size () verwendeten</i> Zeiger haben einen anderen Typ (8). <br><br>  Im Fall von <i>uint8_t lautet</i> die Antwort zumindest auf g√§ngigen Compilern (9): Ja, theoretisch kann sich der Wert von <b><i>size ()</i></b> <b>√§ndern</b> , da <i>uint8_t</i> ein Alias ‚Äã‚Äãf√ºr <i>nicht signierte</i> <i>Zeichen</i> und Arrays des Typs " <i>nicht signierte Zeichen"</i> (und " <i>Zeichen"</i> ) ist <i>Alias ‚Äã‚Äãmit jedem anderen Typ</i> .  Dies bedeutet, dass das Schreiben in <i>uint8_t-Zeiger</i> nach Angaben des Compilers den Inhalt des Speichers unbekannter Herkunft an einer beliebigen Adresse √§ndern kann (10).  Daher wird davon ausgegangen, dass jede Inkrementierungsoperation <i>v [i] ++</i> den <i>size () -</i> Wert √§ndern kann und daher gezwungen ist, ihn bei jeder Iteration der Schleife neu zu berechnen. <br><br>  Wir alle wissen, dass das Schreiben in den Speicher, auf den <i>std :: vector</i> zeigt, niemals seine eigene <i>Gr√∂√üe</i> √§ndert <i>()</i> , da dies bedeuten w√ºrde, dass der Vektor selbst irgendwie in seinem eigenen Heap zugeordnet wurde, und das ist praktisch unm√∂glich und dem Problem von Huhn und Eiern verwandt (11).  Dem Compiler ist dies leider nicht bekannt! <br><br><h2>  Was ist mit dem Rest der Ergebnisse? </h2><br>  Nun, wir haben herausgefunden, warum die Version mit <i>uint8_</i> etwas langsamer ist als die Version von <i>uint32_t</i> auf gcc auf der <i>-O2-</i> Ebene.  Aber warum erkl√§ren Sie den enormen Unterschied - bis zu 8-mal - bei clang oder dem gleichen gcc bei <i>-O3</i> ? <br><br>  Hier ist alles einfach: Im Fall von <i>uint32_t kann</i> clang die automatische Vektorisierung von Schleifen durchf√ºhren: <br><br><pre> <code class="cpp hljs">.LBB1_6: ; =&gt;This Inner Loop Header: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>], ymm4 vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>], ymm4 add rdi, <span class="hljs-number"><span class="hljs-number">64</span></span> add rsi, <span class="hljs-number"><span class="hljs-number">2</span></span> jne .LBB1_6</code> </pre> <br>  Der Zyklus wurde 8-mal implementiert, und dies ist im Allgemeinen die maximale Leistung, die Sie erhalten k√∂nnen: Ein Vektor (8 Elemente) pro Taktzyklus f√ºr den L1-Cache (dies funktioniert nicht mehr, da ein Schreibvorgang pro Taktzyklus begrenzt ist (12)). <br><br>  <i>Die Vektorisierung wird</i> f√ºr <i>uint8_t</i> nicht durchgef√ºhrt, da sie durch die Notwendigkeit behindert wird, <i>size ()</i> zu berechnen, um die Schleifenbedingung bei jeder Iteration zu √ºberpr√ºfen.  Der Grund f√ºr die Verz√∂gerung ist immer noch der gleiche, aber die Verz√∂gerung selbst ist viel gr√∂√üer. <br><br>  Die niedrigsten Timings werden durch die automatische Vektorisierung erkl√§rt: gcc wendet sie nur auf die Ebene <i>-O3</i> an, und clang gilt standardm√§√üig sowohl f√ºr die Ebene <i>-O2 als auch f√ºr die</i> Ebene <i>-O3</i> .  Der Compiler -cc level gcc generiert etwas langsameren Code als clang, da er die autovektorisierte Schleife nicht erweitert. <br><br><h2>  Korrigieren Sie die Situation </h2><br>  Wir haben herausgefunden, wo das Problem liegt - wie k√∂nnen wir es beheben? <br><br>  Versuchen wir zun√§chst eine M√∂glichkeit, die jedoch nicht funktioniert: Wir schreiben einen idiomatischeren Zyklus, der auf einem Iterator basiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(); i != v.end(); ++i) { (*i)++; }</code> </pre> <br>  Der Code, den <i>gcc</i> auf der Ebene <i>-O2</i> generiert, ist etwas besser als die Option mit <i>size ()</i> : <br><br><pre> <code class="cpp hljs">.L17: add BYTE PTR [rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>], rax jne .L17</code> </pre> <br>  Aus zwei zus√§tzlichen Leseoperationen wurde eine, da wir nun mit dem Endzeiger des Vektors vergleichen, anstatt <i>size ()</i> neu zu berechnen, wobei der Vektor-Startzeiger vom Endzeiger subtrahiert wird.  Nach der Anzahl der Anweisungen hat dieser Code <i>uint32_t</i> eingeholt, da die zus√§tzliche Leseoperation mit der Vergleichsoperation zusammengef√ºhrt wurde.  Das Problem ist jedoch nicht <i>behoben</i> und die automatische Vektorisierung ist immer noch nicht verf√ºgbar, sodass <i>uint8_t</i> immer noch deutlich hinter <i>uint32_t</i> zur√ºckliegt - mehr als f√ºnfmal auf gcc und clang auf den Ebenen, auf denen die automatische Vektorisierung bereitgestellt wird. <br><br>  Versuchen wir etwas anderes.  Es wird uns nicht wieder gelingen, oder vielmehr, wir werden eine <i>andere</i> unwirksame Methode finden. <br><br>  In dieser Version berechnen wir <i>size ()</i> nur einmal vor der Schleife und setzen das Ergebnis in eine lokale Variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, s = v.size(); i &lt; s; i++) { v[i]++; }</code> </pre> <br>  Es scheint zu funktionieren?  Das Problem war <i>size ()</i> , und jetzt haben wir den Compiler angewiesen, das Ergebnis von <i>size ()</i> an die lokale Variable <i>s</i> am Anfang der Schleife zu √ºbergeben, und die lokalen Variablen schneiden sich, wie Sie wissen, nicht mit anderen Daten.  Wir haben tats√§chlich getan, was der Compiler nicht konnte.  Und der Code, den es generiert, ist tats√§chlich besser (im Vergleich zum Original): <br><br><pre> <code class="cpp hljs">.L9: mov rdx, QWORD PTR [rdi] add BYTE PTR [rdx+rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp rax, rcx jne .L9</code> </pre> <br>  Es gibt nur eine zus√§tzliche Leseoperation und keinen <i>Unterbefehl</i> .  Was macht dieser zus√§tzliche Befehl ( <i>rdx, QWORD PTR [rdi]</i> ), wenn er nicht an der Gr√∂√üenberechnung beteiligt ist?  Es liest den <i>data ()</i> Zeiger von <i>v</i> ! <br><br>  Der Ausdruck <i>v [i]</i> wird als <i>* (v.data () + i)</i> implementiert, und das von <i>data () zur√ºckgegebene</i> <i>Element (</i> und tats√§chlich ein regul√§rer Anfangszeiger) wirft das gleiche Problem auf wie <i>size ()</i> .  Zwar habe ich diesen Vorgang in der Originalversion nicht bemerkt, da er dort "kostenlos" war, da er noch durchgef√ºhrt werden musste, um die Gr√∂√üe zu berechnen. <br><br>  Tragen Sie mit ein wenig mehr, wir haben fast eine L√∂sung gefunden.  Sie m√ºssen nur <i>alle</i> Abh√§ngigkeiten vom Inhalt von <i>std :: vector</i> aus unserer Schleife entfernen.  Der einfachste Weg, dies zu tun, besteht darin, unsere Redewendung mit einem Iterator ein wenig zu √§ndern: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(), e = v.end(); i != e; ++i) { (*i)++; }</code> </pre> <br>  Jetzt hat sich alles dramatisch ge√§ndert (hier vergleichen wir nur Versionen mit <i>uint8_t</i> - in einem speichern wir das Iteratorende in einer lokalen Variablen <i>vor der</i> Schleife, in dem anderen - nein): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lp/pe/xj/lppexj0vgqumpzvblxctc7xkkoa.png"></div><br>  Diese kleine √Ñnderung f√ºhrte zu einer 20-fachen Geschwindigkeitssteigerung bei Niveaus mit automatischer Vektorisierung.  Au√üerdem hat der Code mit <i>uint8_t</i> nicht nur den Code mit <i>uint32_t</i> <i>eingeholt</i> - er hat ihn mit gcc <i>-O3</i> fast genau viermal √ºberholt und <i>-O2</i> und <i>-O3 geklirrt</i> , wie wir zu Beginn erwartet hatten, wobei wir uns auf die Vektorisierung <i>gest√ºtzt</i> haben: am Ende genau viermal mehr Elemente k√∂nnen durch eine Vektoroperation verarbeitet werden, und wir ben√∂tigen viermal weniger Bandbreite - unabh√§ngig von der Cache-Ebene (13). <br><br>  Wenn Sie zu diesem Platz lesen, dann m√ºssen Sie sich die ganze Zeit ausgerufen haben: <br><br>  <i>Aber was ist mit der in C ++ 11 eingef√ºhrten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>for-Schleife mit Band-Traversal</i></a> ?</i> <br><br>  Ich beeile mich, Ihnen zu gefallen: es funktioniert!  Dies ist in der Tat syntaktischer Zucker, hinter dem sich unsere Version mit einem Iterator in fast derselben Form verbirgt, in der wir den Endzeiger vor dem Beginn der Schleife in einer lokalen Variablen fixiert haben.  Also ist seine Geschwindigkeit gleich. <br><br>  Wenn wir uns pl√∂tzlich entschlie√üen, in alte H√∂hlenzeiten zur√ºckzukehren und eine C-√§hnliche Funktion zu schreiben, w√ºrde ein solcher Code genauso gut funktionieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { a[i]++; } }</code> </pre> <br>  Hier werden der Zeiger auf das Array <i>a</i> und die Gr√∂√üenvariable <i>als</i> Wert an die Funktion √ºbergeben, sodass sie nicht wie lokale Variablen durch Schreiben in den Zeiger <i>a</i> (14) ge√§ndert werden k√∂nnen.  Die Leistung dieses Codes entspricht der der vorherigen Optionen. <br><br>  Schlie√ülich k√∂nnen Sie auf Compilern, auf denen diese Option verf√ºgbar ist, einen Vektor mit <i>__restrict</i> (15) deklarieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc_restrict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; __restrict v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <br>  Das <i>Schl√ºsselwort __restrict ist</i> nicht Teil des C ++ - Standards, sondern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seit C99</a> Teil des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C-</a> Standards (als <i>Einschr√§nkung</i> ).  Wenn es als C ++ - Erweiterung im Compiler implementiert ist, folgt es h√∂chstwahrscheinlich der Semantik von C. Nat√ºrlich gibt es in C keine Links, sodass Sie den Link zum Vektor mental durch einen Zeiger auf den Vektor ersetzen k√∂nnen. <br><br>  Beachten Sie, dass restricted keine transitiven <i>Eigenschaften hat</i> : Die Aktion des <i>__restrict-Bezeichners</i> , mit der eine Verkn√ºpfung zu <i>std :: vector</i> deklariert wird, gilt nur f√ºr die <i>Elemente</i> des Vektors selbst und nicht f√ºr die Heap-Region, auf die <i>v.data () verweist</i> .  In unserem Fall ist mehr nicht erforderlich, da es (wie bei lokalen Variablen) ausreicht, den Compiler davon zu √ºberzeugen, dass die Terme selbst, die auf den Anfang und das Ende des Vektors zeigen, sich mit nichts √ºberschneiden.  Die <i>Einschr√§nkungsklausel</i> ist jedoch weiterhin relevant, da das Schreiben √ºber <i>v.data ()</i> m√∂glicherweise weiterhin dazu f√ºhrt, dass sich andere Objekte in Ihrer Funktion aufgrund von Aliasing √§ndern. <br><br><h2>  Entt√§uschung </h2><br>  Hier kommen wir zum letzten - und sehr entt√§uschenden - Schluss.  Tatsache ist, dass alle oben gezeigten L√∂sungen nur f√ºr diesen speziellen Fall anwendbar sind, wenn der Vektor theoretisch mit sich selbst interferieren kann.  Die L√∂sung bestand darin, die Schleife zu verlassen oder das Ergebnis des Aufrufs von <i>size ()</i> oder <i>end () des</i> Vektors zu isolieren und dem Compiler <i>nicht</i> mitzuteilen, dass das Schreiben in die Vektordaten keine Auswirkungen auf andere Daten hat.  Ein solcher Code ist mit zunehmender Funktionsgr√∂√üe nur schwer skalierbar. <br><br>  Das Aliasing-Problem ist nicht beseitigt, und die Schreibbefehle k√∂nnen immer noch "√ºberall" abgelegt werden - es gibt einfach keine anderen Daten in dieser Funktion, die betroffen sein k√∂nnten ... vorerst.  Sobald ein neuer Code darin erscheint, wird alles wiederholt.  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel aus der Hand</a> .  Wenn Sie in kleinen Schleifen in Arrays von Elementen des Typs <i>uint8_t</i> schreiben, m√ºssen Sie bis zum Ende mit dem Compiler k√§mpfen (16). <br><br><h2>  Kommentare </h2><br>  Ich freue mich √ºber jede R√ºckmeldung.  Ich habe noch kein Kommentarsystem (17), daher werden wir wie √ºblich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Thread auf HackerNews diskutieren</a> . <br><br><ol><li>  Wenn Sie hier auf den Speicher zugreifen, wird verstanden, dass die Kette von Abh√§ngigkeiten den Speicher durchl√§uft: Schreibbefehle an derselben Adresse sollten den zuletzt dort geschriebenen Wert lesen, daher sind solche Operationen abh√§ngig (in der Praxis wird die Umleitung zum Laden (STLF) verwendet, wenn die Aufzeichnung ausreicht oft).  Abh√§ngigkeiten des Befehls <i>add</i> beim Speicherzugriff k√∂nnen auf andere Weise auftreten, z. B. durch Berechnung der Adresse. In unserem Fall ist dies jedoch irrelevant. </li><li>  Hier ist nur ein kleiner Zyklus dargestellt;  Der Installationscode ist einfach und funktioniert schnell.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laden Sie den Code auf godbolt hoch</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um</a> die vollst√§ndige Liste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzuzeigen</a> . </li><li>  Vielleicht sollte man es einfach "minimiert" nennen?  Wie dem auch sei, der gcc-Compiler <i>schleift</i> normalerweise nicht einmal auf den Ebenen <i>-O2</i> und <i>-O3 herum</i> , au√üer in besonderen F√§llen, in denen die Anzahl der Iterationen gering ist und <i>in der Kompilierungsphase bekannt ist</i> .  Aus diesem Grund zeigt gcc im Vergleich zu clang geringere Testergebnisse, spart aber viel an Codegr√∂√üe.  Sie k√∂nnen <i>gcc zwingen, Loops zu entrollen,</i> indem Sie die <i>Profiloptimierung</i> anwenden oder das <i>Flag -funroll-loops aktivieren</i> . </li><li>  Tats√§chlich ist der <i>Befehl inc DWORD PTR [rax]</i> in gcc eine <i>fehlende</i> Optimierung: Es ist fast immer besser, den Befehl <i>add [rax], 1 zu verwenden</i> , da er nur aus 2 kombinierten Mikrooperationen gegen√ºber 3 f√ºr <i>inc besteht</i> .  In diesem Fall betr√§gt der Unterschied nur etwa 6%. Wenn der Zyklus jedoch geringf√ºgig erweitert w√ºrde, so dass nur der Aufzeichnungsvorgang wiederholt w√ºrde, w√§re der Unterschied signifikanter (eine weitere Erweiterung w√ºrde keine Rolle mehr spielen, da wir die Grenze von 1 erreichen w√ºrden) Aufzeichnungsvorgang pro Zyklus, der nicht von der Gesamtzahl der Mikrooperationen abh√§ngt). </li><li>  Ich nenne diese Variable <i>induktiv</i> und nicht nur <i>i</i> wie im Quellcode, weil der Compiler die Einheitsoperationen des Inkrements <i>i</i> in 4-Byte-Inkremente des im <i>Rax-</i> Register gespeicherten Zeigers konvertiert und die Schleifenbedingung entsprechend korrigiert hat.  In der urspr√ºnglichen Form adressiert unsere Schleife die Elemente des Vektors und inkrementiert nach dieser Konvertierung den Zeiger / Iterator. Dies ist eine M√∂glichkeit, <i>die Betriebskosten</i> zu <i>senken</i> . </li><li>  Wenn Sie <i>-funroll-loops</i> aktivieren, <i>betr√§gt</i> die Geschwindigkeit auf gcc bei einem <i>8-fachen Rollout</i> 1,08 Takte pro Element.  Aber selbst mit diesem Flag wird er die Schleife f√ºr die Version mit 8-Bit-Elementen <i>nicht</i> erweitern, sodass die Verz√∂gerung der Geschwindigkeit noch deutlicher wird! </li><li>  Diese Member haben einen <i>privaten</i> Modifizierer und ihre Namen sind implementierungsabh√§ngig, aber in stdlibc ++ hei√üen sie nicht wirklich <i>start</i> und <i>finish</i> , wie in gcc.  Sie hei√üen <i>_Vector_base :: _ Vector_impl :: _ M_start</i> und <i>_Vector_base :: _ Vector_impl :: _ M_finish</i> , d.h.  <i>Geben Sie</i> die <i>_Vector_impl-</i> Struktur ein, die ein Mitglied von <i>_M_impl</i> (und die einzige) der <i>_Vector_base-</i> Klasse ist und die wiederum die Basisklasse f√ºr <i>std :: vector ist</i> .  Na gut!  Gl√ºcklicherweise kann der Compiler mit diesem Stapel von Abstraktionen problemlos umgehen. </li><li>  Der Standard schreibt nicht vor, wie die internen Typen von <i>std :: vector-</i> Elementen lauten sollen, aber in der libstdc ++ - Bibliothek werden sie einfach als <i>Alloc :: pointer</i> (wobei <i>Alloc</i> der <i>Allokator</i> f√ºr den Vektor ist) und f√ºr das standardm√§√üige, <i>std :: zugeteilte Objekt</i> einfach als <i>Alloc :: pointer</i> definiert Zeiger vom Typ <i>T *</i> , d.h.  regul√§re Zeiger auf ein Objekt - in diesem Fall <i>uint32_t *</i> . </li><li>  Ich mache diese Reservierung aus einem Grund.  Es besteht der Verdacht, dass <i>uint8_t</i> als ein anderer Typ als <i>char</i> , <i>signed char</i> und <i>unsigned char angesehen werden kann</i> .  Da Aliasing mit <i>Zeichentypen</i> funktioniert, gilt dies im Prinzip nicht f√ºr <i>uint8_t</i> und sollte sich wie jeder andere Nicht-Zeichentyp verhalten.  Ich kenne jedoch keinen der Compiler, der das glaubt: In allen ist <i>typedef</i> <i>uint8_t</i> ein Alias <i>ohne Vorzeichen</i> , sodass Compiler den Unterschied zwischen ihnen nicht erkennen, auch wenn sie ihn gerne verwenden w√ºrden. </li><li>  Mit "unbekannter Herkunft" meine ich hier nur, dass der Compiler nicht wei√ü, wohin der Inhalt des Speichers zeigt oder wie er erschienen ist.  Dies umfasst beliebige Zeiger, die an die Funktion √ºbergeben werden, sowie globale und statische Variablen.  , ,            ,  ,   ,     (    -     ). ,     <i>malloc</i>  <i>new</i> ,   <i></i>    ,      ,   ,        :  ,      ,       . ,       <i>malloc</i>  <i>new</i> . </li><li>  ,   <i>std::vector</i>  - <i></i> ? ,    <i>std::vector&lt;uint8_t&gt; a</i>     <i></i>  <i>a.data()</i>    <i>placement new</i>       <i>b</i> .   <i>std::swap(a, b)</i> ,       ‚Äì ,  <i>b</i>      ?       ,     <i>b</i> .       :          -  (,       ),      ,       . </li><li>        8 , ..  32 .     ,   <i>std::vector</i>      . </li><li> -        4 :     ,        ,   ‚Äì .       : 8-      L1,  32-        ‚Äì   L2    ,      . </li><li>        ,  ‚Äì  :        .      ,      ,    ¬´¬ª. </li><li>        <i>v[i]</i> ,           . </li><li>     . ,   ¬´¬ª ,          <i>uint8_t</i> .      , ,       ,  <i>uint8_t</i> ,          . ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   clang,      gcc</a> ,     ,    <i>uint8_t</i> . -     <i>gcc</i>          ,   .     ,     , -     <i>__restrict</i> . </li><li>  -  ,       ,      (   Disqus),           (        ),    . </li></ol><br> <i>     .  : Travis Downs. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Incrementing vectors</a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475636/">https://habr.com/ru/post/de475636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475614/index.html">Automatisierung f√ºr die Kleinsten. Zweiter Teil. Netzwerkdesign</a></li>
<li><a href="../de475618/index.html">So erstellen Sie einen Smart Python-Vertrag im Ontology-Netzwerk. Teil 2: Speicher-API</a></li>
<li><a href="../de475624/index.html">PHP-Watcher: Ein Tool, das die Entwicklung langlebiger Anwendungen vereinfacht</a></li>
<li><a href="../de475626/index.html">K√∂nnen Autotests eine Person auf der Suche nach Schwachstellen ersetzen: Interview mit Alexandra Svatikova</a></li>
<li><a href="../de475630/index.html">Knative - eine k8s-basierte Plattform als Service mit serverloser Unterst√ºtzung</a></li>
<li><a href="../de475640/index.html">Wenn Sie etwas erstellen, vermeiden Sie den Zeitplan des Managers.</a></li>
<li><a href="../de475642/index.html">Heap-Only-Tupel-Mechanismus in PostgreSQL</a></li>
<li><a href="../de475646/index.html">Yuri Ryabtsev: "Das erste Abfangen einer ballistischen Rakete ist ein Ereignis, das in etwa Gagarins Flug entspricht."</a></li>
<li><a href="../de475652/index.html">Wie wir eine mobile Anwendung auf dem Aurora OS (Sailfish Mobile OS RUS) entwickelt haben</a></li>
<li><a href="../de475654/index.html">‚ÄûIm ersten Monat hatten drei gesunde M√§nner Angst, die Turbine einzuschalten‚Äú - so baut Alexei Statsenko ein Jetpack von Grund auf neu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>