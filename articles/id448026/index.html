<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ­ ğŸ‘©ğŸ½â€ğŸŒ¾ ğŸ™ğŸ½ Proyek Perangkat Lunak dan Evolusi OOP ğŸ‘¼ğŸ¿ ğŸ§›ğŸ½ ğŸ‘¨ğŸ¿â€ğŸš€</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menguasai resep untuk pengembangan proyek perangkat lunak yang efektif, saya mencoba menemukan sendiri alasan yang membuatnya berguna untuk menggunaka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proyek Perangkat Lunak dan Evolusi OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448026/"><p>  Menguasai resep untuk pengembangan proyek perangkat lunak yang efektif, saya mencoba menemukan sendiri alasan yang membuatnya berguna untuk menggunakan prinsip-prinsip pengembangan arsitektur SOLID (artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana tidak memahami prinsip-prinsip pengembangan arsitektur SOLID</a> ). </p><br><p>  Analisis terhadap prinsip-prinsip ini memungkinkan untuk memilih beberapa pola kunci dan elemen dasar yang ada dalam pembangunan.  Mereka memungkinkan kami untuk menggambarkan, memahami dan mengimplementasikan SOLID dalam pekerjaan nyata dengan proyek perangkat lunak. </p><br><p>  Menjadi menarik untuk melakukan analisis penerapan konsep-konsep ini untuk paradigma pemrograman yang diterima secara umum, misalnya, untuk OOP.  Nah, jika hasil karya ini akan bermanfaat bagi Anda. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/291/b01/aa4/291b01aa4949513c726bbf5cb33fad80.jpg" alt="gambar"></p><a name="habracut"></a><br><p>  Saat ini, ada banyak pendekatan untuk desain dan implementasi proyek perangkat lunak selanjutnya.  Yang paling dituntut dalam bekerja dengan proyek perangkat lunak besar adalah: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman struktural</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman fungsional</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman berorientasi objek</a> . </p><br><p>  Bagi saya, menjadi menarik untuk menganalisis penyebab pendekatan desain ini.  Dan dalam proses analisis, penemuan tak terduga adalah fakta bahwa mereka semua secara implisit didasarkan pada premis berikut: </p><br><pre><code class="plaintext hljs">          ,      .</code> </pre> <br><h2 id="razvitie-programmnogo-proekta">  Pengembangan Proyek Perangkat Lunak </h2><br><p>  Apa itu proyek tanpa perlu pengembangan?  Proyek-proyek seperti itu jarang ditemukan dan terutama ditandai dengan pembayaran upah per satuan cepat tanpa kewajiban berikutnya dari pihak programmer, misalnya: </p><br><ul><li>  sebuah proyek kecil yang dapat ditulis dengan satu pendekatan; </li><li>  Sebuah proyek tanpa kode yang rumit secara struktural, dibebani dengan sejumlah besar hubungan; </li><li>  produk perangkat lunak tanpa memerlukan dukungan dan dukungan pengguna. </li></ul><br><p>  Dalam situasi seperti itu, upaya programmer untuk mempertahankan, misalnya, pendekatan berorientasi objek terbuang sia-sia.  Sering terjadi bahwa saya menemukan diri saya dalam pelajaran yang tidak berarti selama pengembangan utilitas konsol satu kali, ketika saya tiba-tiba menyadari bahwa menulis teks kelas 4 di proyek ini menunda saya selama 15 menit dan tidak membawa saya lebih dekat dengan hasilnya.  Yang paling menyedihkan adalah bahwa semua kelas yang hampir tidak ditulis dalam proyek semacam itu dilupakan dan tidak digunakan kembali, yaitu, mereka tidak memfasilitasi pekerjaan kita di masa depan. </p><br><p>  Dalam semua situasi lain, programmer, meminimalkan pekerjaannya, harus mengembangkan proyek yang kompleks secara struktural, yaitu: </p><br><ul><li>  Memperbaiki kesalahan dengan menganalisis kode dan menemukan tempat di mana kesalahan ini dihasilkan. </li><li>  Untuk memperkenalkan fungsionalitas baru, sambil mempertahankan fungsionalitas semua kemampuan yang tersedia sebelumnya.  Dalam melakukannya, gunakan kode yang ada (ditulis dan diuji) dalam pelaksanaan tugas-tugas baru ini. </li><li>  Berikan dukungan dalam menggunakan produk perangkat lunak. </li><li>  Lakukan deskripsi dan koordinasi fungsi semua versi proyek. </li><li>  Simpan semua format data yang digunakan oleh proyek (bahkan ketinggalan jaman) operasional. </li><li>  Dan melakukan banyak tugas lain yang muncul dalam konfrontasi dengan pesaing yang disebabkan oleh perubahan kerangka kerja atau akhir dukungan untuk OS usang ... </li></ul><br><p>  Jika Anda mencari analogi dengan pengembangan proyek perangkat lunak, Anda dapat mengingat evolusi spesies biologis. </p><br><pre> <code class="plaintext hljs">     "".     -       .       -  .</code> </pre> <br><p>  Pekerjaan programmer tidak mudah, tetapi programmer memiliki "pembantu".  Penolong ini tersembunyi di suatu tempat jauh di dalam struktur dunia kita, di mana ada dua fitur: </p><br><ul><li>  kemampuan untuk menulis satu algoritma yang bermanfaat dan menggunakannya untuk banyak tugas serupa, </li><li>  kehadiran banyak tugas serupa dalam solusi mereka. </li></ul><br><p>  Algoritma ini, berguna dalam banyak bidang, akan disebut algoritma <em>universal</em> untuk singkatnya.  Implementasinya untuk bidang aplikasi tertentu dapat disebut spesialisasi, karena proses penyempurnaan algoritma untuk digunakan dalam bidang aplikasi yang sempit mirip dengan spesialisasi evolusi sel dalam organisme hidup. </p><br><p>  Jelas, untuk membuat suatu algoritma, perlu untuk mengidentifikasi fitur yang memastikan penerapan algoritma.  Tanda-tanda ini harus dicari dalam input data dan dalam deskripsi situasi awal (konteks).  Untuk membuat algoritma <em>universal</em> , perlu di setiap bidang subjek, yang memiliki serangkaian tanda data dan situasi, untuk mengidentifikasi tanda-tanda penerapan yang identik untuk semua bidang.  Semua tanda lain yang tidak memberikan penerapan diabaikan oleh algoritma <em>universal</em> .  Memformalkan algoritma <em>universal</em> , kami sampai pada perlunya menggunakan <em>abstraksi</em> - salah satu prinsip terpenting OOP.  Selain itu, OOP dicirikan oleh penekanan hanya pada abstraksi data. </p><br><p>  Di sini saya akan mencoba menulis contoh menggunakan <em>abstraksi</em> dari berbagai bidang. </p><br><table><thead><tr><th>  Abstraksi </th><th>  Algoritma </th><th>  Bidang aplikasi </th></tr></thead><tbody><tr><td>  Bilangan alami </td><td>  Algoritma Perhitungan Kuantitatif </td><td>  Tugas akuntansi untuk nilai ekonomi </td></tr><tr><td>  Karakteristik massa tubuh material </td><td>  Algoritma untuk membandingkan jumlah zat </td><td>  Tugas membandingkan nilai produk yang tidak bertanggung jawab </td></tr><tr><td>  Antarmuka dengan operasi untuk kumpulan elemen: penjelajahan penuh, perbandingan, dan pertukaran posisi </td><td>  Koleksi Sortir Algoritma </td><td>  Pemrograman </td></tr><tr><td>  Antarmuka dari operasi yang sama untuk "simpul akhir" dan "simpul cabang" di pohon </td><td>  Algoritma berdasarkan pola desain Tata Letak </td><td>  Pengembangan proyek perangkat lunak yang kompleks </td></tr><tr><td>  Konsep Kunci "Karyawan" </td><td>  Tulisan di bagian "Kontrak kerja" </td><td>  Kode Perburuhan </td></tr></tbody></table><br><h2 id="stroitelnyy-blok-programmnogo-proekta">  Blok bangunan proyek perangkat lunak </h2><br><p>  Menggunakan berbagai teknik abstraksi, programmer mengimplementasikan algoritma dalam bentuk bagian kode, yang merupakan elemen yang terpisah dan lengkap dari karyanya.  Elemen ini, tergantung pada bahasa pemrograman yang digunakan, dapat berupa fungsi, objek, dan urutan instruksi.  Untuk kenyamanan diskusi lebih lanjut, kami akan menyebut fragmen kode ini dengan kata " <strong>komponen</strong> ". </p><br><p>  <strong>Komponen</strong> - sepotong kode (prosedur, kelas, komponen penempatan, dll.): </p><br><ul><li>  yang mengimplementasikan beberapa algoritma lengkap yang bekerja dalam situasi awal tertentu dan dengan data input tertentu, </li><li>  yang dapat digunakan beberapa kali dalam satu proyek (bahkan lebih baik berkali-kali dalam proyek yang berbeda), </li><li>  semua instruksi yang terletak dekat dan dilihat tanpa perlu operasi pencarian tambahan di lingkungan pengembangan, </li><li>  perubahan yang dilakukan oleh pemrogram relatif independen sehubungan dengan sisa kode. </li></ul><br><h2 id="zakonomernosti-v-razvitii-programmnogo-proekta">  Pola dalam pengembangan proyek perangkat lunak </h2><br><p>  Menggunakan <strong>komponen</strong> istilah, menjadi mungkin untuk merumuskan seperangkat undang-undang sederhana yang ada dalam pengembangan proyek perangkat lunak.  Saya akan menyajikan pola-pola ini dalam bentuk pernyataan berikut, dibagi menjadi 3 kategori. </p><br><ol><li>  Pernyataan yang menggambarkan sifat-sifat suatu <strong>komponen</strong> . <br>  1.1.  <strong>Komponen yang</strong> ditulis dengan benar harus digunakan dan lebih sering beberapa kali. <br>  1.2.  Di setiap tempat di mana <strong>komponen</strong> digunakan, perilaku konstan diharapkan darinya, yang mengarah ke hasil yang berulang. <br>  1.3.  Saat menggunakan <strong>komponen</strong> di beberapa tempat, hasilnya harus memuaskan setiap tempat penggunaan. <br>  1.4.  Perilaku yang tertanam dalam <strong>komponen</strong> menciptakan batasan tempat penggunaan <strong>komponen</strong> ini. <br>  1.5.  Di setiap tempat penggunaan <strong>komponen</strong> , semua batasannya dapat dilibatkan. <br>  1.6.  Setiap perubahan pada <strong>komponen akan</strong> mengubah keterbatasannya dan membutuhkan verifikasi semua tempat penggunaannya, yang menyebabkan programmer membuang waktu. <br>  1.7.  Dianjurkan untuk menulis <strong>komponen</strong> dalam bentuk kode dalam satu contoh, yaitu, perlu untuk menghilangkan duplikasi kode yang sama.  Ini akan mengurangi jumlah pengeditan saat membuat perubahan ke <strong>komponen</strong> . </li><li>  Pernyataan yang menggambarkan pola dalam pelaksanaan tugas baru oleh programmer. <br>  2.1. Dianjurkan untuk memilih opsi untuk mengimplementasikan tugas baru sambil meminimalkan waktu yang dihabiskan oleh programmer. <br>  2.2.  Untuk mengimplementasikan tugas baru, programmer dapat menambahkan <strong>komponen</strong> baru atau mengubah perilaku <strong>komponen</strong> lama. <br>  2.3.  Menambahkan <strong>komponen</strong> pada dasarnya hanya memerlukan pemeriksaan di tempat penggunaan baru, dan menghasilkan waktu minimal untuk programmer. <br>  2.4.  Perubahan perilaku <strong>komponen yang</strong> disebabkan oleh tugas baru, menurut pernyataan [1.6], memerlukan verifikasi di tempat penggunaan baru dan di semua tempat penggunaan lama, yang menghasilkan waktu tambahan untuk pemrogram dibandingkan dengan situasi dalam pernyataan [2.3].  Dalam kasus <strong>komponen yang</strong> diterbitkan <strong>,</strong> ini membutuhkan pekerjaan semua programmer menggunakan <strong>komponen yang</strong> dimodifikasi. </li><li>  Pernyataan yang menggambarkan pola dalam interaksi algoritma <em>universal</em> dan spesialisasi mereka: <br>  3.1.  Ada kesempatan untuk menulis <strong>komponen</strong> <em>dasar</em> (nama ini diperkenalkan dengan analogi dengan kelas dasar dan demi singkatnya kita akan menggunakan kata " <em>basis</em> ").  <em>Basis</em> hanya memenuhi fitur paling penting dari beberapa algoritma <em>universal</em> . <br>  3.2.  Dimungkinkan untuk menulis <strong>komponen -</strong> spesialisasi (selanjutnya untuk singkatnya kita akan menggunakan kata " <em>spesialisasi</em> ").  <em>Spesialisasi</em> melengkapi algoritma <em>universal</em> dari <em>pangkalan</em> , sehingga dapat diterapkan pada area penggunaan tertentu. <br>  3.3.  <em>Basis</em> , sebagai berikut dari pernyataan [3.1], [3.2], memiliki kompleksitas kurang dan pembatasan aplikasi lebih sedikit daripada <em>spesialisasi</em> . <br>  3.4.  Menurut pernyataan [1.7], disarankan untuk mengembangkan <em>spesialisasi</em> tanpa duplikasi kode algoritma <em>universal</em> dari <em>database</em> . <br>  3.5.  Tempat penggunaan <em>database</em> tidak memerlukan verifikasi setelah melakukan perubahan pada <em>spesialisasi yang</em> dibentuk dengan benar. </li></ol><br><h2 id="ponyatiya-obektno-orientirovannogo-programmirovaniya">  Konsep Pemrograman Berorientasi Objek </h2><br><p>  Saya akan mencoba, menggunakan pernyataan di atas, untuk menganalisis konsep dasar pemrograman berorientasi objek.  Analisis ini memotong konsep <em>abstraksi</em> , karena sudah dijelaskan sebelumnya dalam formalisasi metode membangun algoritma <em>universal</em> . </p><br><h3 id="klass-obekt">  Kelas, Obyek </h3><br><p>  Konsep-konsep OOP ini memperkuat kelayakan menggunakan jenis <strong>komponen khusus yang</strong> dijelaskan oleh kombinasi beberapa data internal dan metode untuk bekerja dengan data ini.  Semua pernyataan dari grup [1] dan [2] diterjemahkan ke dalam OOP, di mana <strong>komponen</strong> istilah diganti dengan konsep <em>kelas</em> . </p><br><p>  Pada saat yang sama, pada pandangan pertama, hubungan antara <em>kelas</em> dan <em>objek</em> habis oleh sekelompok pernyataan [3], di mana <em>basis</em> digantikan oleh konsep <em>kelas</em> , dan <em>implementasinya</em> digantikan oleh konsep <em>objek</em> .  Selain itu, <em>implementasinya</em> dinamis, yaitu dapat berubah selama pelaksanaan program. </p><br><h3 id="inkapsulyaciya">  Enkapsulasi </h3><br><p>  Konsep " <em>enkapsulasi</em> " dapat dipertimbangkan dari dua "sisi". </p><br><p>  Sisi pertama dari konsep " <em>enkapsulasi</em> " adalah isolasi <strong>komponen</strong> dari bagian lain dari kode.  Properti ini memungkinkan pemrogram untuk melakukan operasi di area kode yang terletak "tutup" untuk membuat perubahan pada <strong>komponen</strong> .  Yaitu, untuk meminimalkan waktu yang dihabiskan oleh programmer dengan mengecualikan dari pekerjaan pencarian dan analisis elemen-elemen yang berinteraksi secara berbeda dari program.  Sisi ini ditentukan oleh sifat-sifat <strong>komponen</strong> berikut dari definisinya. </p><br><p>  Sisi kedua dari konsep " <em>enkapsulasi</em> " adalah penyembunyian implementasi internal <strong>komponen</strong> .  Penyembunyian ini dimungkinkan dengan menggunakan konsep-konsep <em>dasar</em> dan <em>implementasi yang</em> dijelaskan dalam kelompok pernyataan [3].  Untuk melakukan ini, metode <em>kelas</em> publik diidentifikasi dengan <em>basis</em> , dan metode kelas swasta dan dilindungi diidentifikasi dengan <em>implementasi</em> .  Di tempat-tempat penggunaan, pembatasan yang dibuat oleh <em>basis digunakan</em> , dan oleh karena itu menjadi mungkin untuk membuat perubahan dalam <em>implementasi</em> yang tidak terkait dengan pembatasan <em>dasar</em> .  Dan perubahan <em>implementasi</em> ini tidak perlu diperiksa di tempat-tempat di mana <em>database</em> digunakan [3.5], yang meminimalkan tenaga kerja programmer. </p><br><p>  Patut dicatat bahwa konsep " <em>enkapsulasi</em> " memiliki analogi dalam biologi.  Proses pertama ini mirip dengan fungsi biologis " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sel membran</a> ". </p><br><h3 id="nasledovanie">  Warisan </h3><br><p>  Konsep " <em>warisan</em> " terus memperkuat pentingnya menggunakan kombinasi <em>implementasi</em> <em>basis</em> +.  Untuk ini, dalam kelompok pernyataan [3] perlu untuk mengidentifikasi metode kelas induk dengan <em>basis</em> , dan mengidentifikasi metode kelas penerus dengan <em>implementasi</em> . </p><br><p>  Dalam implementasinya, konsep " <em>pewarisan</em> " memungkinkan penggunaan pernyataan [2.3], yaitu, menggunakan penambahan kode alih-alih mengubah dan menggandakannya.  Dalam hal ini, perlu untuk mengecualikan duplikasi dari algoritma <em>dasar</em> .  Namun, pendekatan yang menggunakan <em>pewarisan</em> untuk mengkhususkan algoritma <em>universal</em> memiliki minus yang signifikan.  Kerugian ini adalah adanya dua <strong>komponen</strong> yang sangat terhubung, yang sulit diubah secara independen.  Hubungan ketergantungan ini dihasilkan oleh hubungan orangtua-anak. </p><br><p>  Ada banyak cara alternatif untuk menggunakan bundel <em>basis</em> + <em>implementasi</em> .  Saya akan memberikan contoh lebih lanjut tentang metode tersebut. </p><br><table><thead><tr><th>  <em>Base</em> </th><th>  <em>Implementasi</em> </th><th>  Bidang aplikasi </th></tr></thead><tbody><tr><td>  Metode kelas publik </td><td>  Metode kelas privat </td><td>  <em>Enkapsulasi</em> </td></tr><tr><td>  Metode yang dilindungi dari kelas induk </td><td>  Metode kelas pewarisan </td><td>  <em>Warisan</em> </td></tr><tr><td>  Antarmuka perpustakaan dinamis </td><td>  Fungsi perpustakaan dinamis </td><td>  <strong>Komponen</strong> = perpustakaan dinamis </td></tr><tr><td>  Metode dan kelas templat (digeneralisasi) (templat, generik) </td><td>  Instantiating templat dengan argumen yang ditentukan </td><td>  Pemrograman umum </td></tr><tr><td>  Metode umum yang menerima delegasi </td><td>  Spesialisasi metode yang menunjukkan prosedur pemrosesan spesifik </td><td>  Prosedur untuk menyortir atau membentuk pohon, menunjukkan metode untuk mengevaluasi urutan elemen </td></tr><tr><td>  Kelas yang memungkinkan interaksi dengan templat Pengunjung </td><td>  Pembentukan "Pengunjung" dengan fungsionalitas yang diperlukan </td><td>  Pola Desain Pengunjung </td></tr><tr><td>  Panel kontrol NPP </td><td>  Perangkat otomatisasi dan peralatan pembangkit listrik tenaga nuklir </td><td>  Penyembunyian kompleksitas sistem dari operator PLTN </td></tr></tbody></table><br><p>  Pada saat yang sama, saya perhatikan bahwa untuk konsep " <em>warisan</em> " dari PLO, orang juga dapat menemukan analogi dalam proses evolusi biologis.  Dalam biologi, istilah " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>hereditas</em></a> " digunakan untuk ini. </p><br><h3 id="polimorfizm">  Polimorfisme </h3><br><p>  Menurut pendapat saya, konsep " <em>polimorfisme</em> " adalah sisi kedua ketika melihat prosedur untuk membuat algoritma <em>universal</em> .  Sisi pertama ( <em>abstraksi</em> ) adalah pandangan dari sudut pandang bagaimana membuat algoritma <em>universal</em> .  Pada saat yang sama, ketika melihat algoritma <em>universal</em> dari sudut pandang pengguna, kami mendapatkan catatan konsep <em>polimorfisme</em> .  Artinya, <em>polimorfisme</em> adalah kemampuan yang berguna dari suatu fungsi ( <strong>komponen</strong> ) untuk memproses data dari berbagai jenis.  Menambahkan konsep ini ke OOP memperkuat kegunaan menggunakan algoritma <em>universal</em> dalam pengembangan proyek perangkat lunak. </p><br><p>  Implementasi polimorfisme dalam berbagai bahasa pemrograman sangat berbeda.  Dalam artikel Wikipedia untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">polimorfisme</a> , tergantung pada implementasinya, ada 4 subtipe: parametrik, inklusi (atau subtipe), overload, tipe casting.  Implementasi ini memiliki perbedaan signifikan, tetapi semuanya disatukan oleh satu tujuan - ini menulis algoritma <em>universal</em> yang tidak perlu diduplikasi untuk <em>spesialisasi</em> spesifiknya. </p><br><p>  Dan kali ini, hampir tanpa kejutan, ia menemukan analogi untuk konsep " <em>polimorfisme</em> " dalam biologi.  Nama istilah biologis ini sepenuhnya sesuai dengan konsep OOP.  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Polimorfisme</em></a> " - kemampuan satu organisme untuk hidup di negara dengan struktur internal yang berbeda atau dalam bentuk eksternal yang berbeda. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Dengan demikian, hampir semua konsep dasar OOP dapat direpresentasikan sebagai seperangkat pernyataan sederhana yang dibentuk atas dasar hukum pengembangan proyek perangkat lunak.  Selain itu, untuk OOP, <strong>komponen</strong> istilah diidentifikasi dengan konsep <em>kelas</em> .  Jika kita memilih arti yang berbeda untuk <strong>komponen</strong> istilah, misalnya, <em>fungsi</em> , maka dimungkinkan untuk merumuskan konsep dasar <em>pemrograman</em> <em>fungsional</em> . </p><br><p>  Dalam proses penulisan artikel, analogi biologis ditemukan untuk konsep yang digunakan dalam pemrograman.  Analogi ini muncul karena kesamaan metode pengembangan produk perangkat lunak dan beberapa proses evolusi biologis. </p><br><p>  IMHO, disarankan untuk mempertimbangkan kedua bidang ilmiah ini bersama-sama.  Dalam hal ini, dimungkinkan untuk melakukan transfer undang-undang dari satu industri ke industri lainnya, dan dengan demikian memastikan pengembangan teknologi informasi dan deskripsi formal proses biologis. </p><br><p>  Terima kasih atas perhatian anda </p><br><h2 id="otzyvy">  Ulasan </h2><br><p>  Saya akan sangat berterima kasih atas umpan balik, saran dan saran, karena mereka membantu saya menyesuaikan arah pengembangan pekerjaan di bidang ini. </p><br><h2 id="ssylki">  Referensi </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori umum tentang algoritma wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel pertama dari seri ini</a> </li></ul><br><p>  Diedit oleh Borisova M.V. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448026/">https://habr.com/ru/post/id448026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448010/index.html">3 minggu dengan Galaxy S10: pro dan kontra</a></li>
<li><a href="../id448016/index.html">Analisis klinis urin di rumah pada strip tes: pro dan kontra</a></li>
<li><a href="../id448018/index.html">Acara digital di Moskow dari 15 April hingga 21 April</a></li>
<li><a href="../id448022/index.html">Kompilator sudut 200-garis</a></li>
<li><a href="../id448024/index.html">Regulator Eropa menentang spanduk kue</a></li>
<li><a href="../id448030/index.html">Tampilan dan optimalisasi output terminal di web</a></li>
<li><a href="../id448032/index.html">Lebih banyak robot: Walmart memperkenalkan ribuan mesin untuk beroperasi di tokonya</a></li>
<li><a href="../id448034/index.html">Cari tugas dalam JIRA (bahasa sederhana). Bagian 1: Pencarian Cepat dan Dasar</a></li>
<li><a href="../id448036/index.html">Impor ke J. Connect dari file daftar pengguna melalui API</a></li>
<li><a href="../id448038/index.html">Fitur baru untuk penulis ekstensi di Visual Studio 2019 v.16.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>