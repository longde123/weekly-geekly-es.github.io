<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüç≥ üöç üìò Lo mejor es enemigo de lo bueno. üóùÔ∏è üßê ü•ï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo es la historia de c√≥mo una vez decidimos mejorar nuestra herramienta interna SelfTester que aplicamos para probar la calidad del analiza...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lo mejor es enemigo de lo bueno.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/466739/"><p><img src="https://habrastorage.org/getpro/habr/post_images/982/355/890/982355890903cccb9e35a693d48d72cf.png" alt="Cuadro 6" align="left"></p>  Este art√≠culo es la historia de c√≥mo una vez decidimos mejorar nuestra herramienta interna SelfTester que aplicamos para probar la calidad del analizador PVS-Studio.  La mejora fue simple y parec√≠a ser √∫til, pero nos meti√≥ en algunos problemas.  M√°s tarde result√≥ que mejor renunciamos a la idea. <br><a name="habracut"></a><br><h2>  Selftester </h2><br>  Desarrollamos y promovemos el analizador de c√≥digo est√°tico PVS-Studio para C, C ++, C # y Java.  Para probar la calidad de nuestro analizador, utilizamos herramientas internas, gen√©ricamente llamadas SelfTester.  Creamos una versi√≥n de SelfTester separada para cada idioma compatible.  Se debe a detalles espec√≠ficos de las pruebas, y es m√°s conveniente.  Por lo tanto, en este momento tenemos tres herramientas internas de SelfTester en nuestra empresa para C \ C ++, C # y Java, respectivamente.  Adem√°s, le contar√© acerca de la versi√≥n de Windows de SelfTester para proyectos de C \ C ++ Visual Studio, llam√°ndolo simplemente SelfTester.  Este probador fue el primero en la l√≠nea de herramientas internas similares, es el m√°s avanzado y complejo de todos. <br><br>  ¬øC√≥mo funciona SelfTester?  La idea es simple: tome un grupo de proyectos de prueba (estamos usando proyectos de c√≥digo abierto reales) y anal√≠celos usando PVS-Studio.  Como resultado, se genera un registro del analizador para cada proyecto.  Este registro se compara con el registro de <i>referencia</i> del mismo proyecto.  Al comparar registros, SelfTester crea un <i>resumen</i> de los registros que se comparan de una manera conveniente para el desarrollador. <br><br>  Despu√©s de estudiar el resumen, un desarrollador concluye acerca de los cambios en el comportamiento del analizador de acuerdo con el n√∫mero y tipo de advertencias, velocidad de trabajo, errores internos del analizador, etc.  Toda esta informaci√≥n es muy importante: le permite saber c√≥mo el analizador hace frente a su trabajo. <br><br>  Seg√∫n el resumen de la comparaci√≥n de registros, un desarrollador introduce cambios en el n√∫cleo del analizador (por ejemplo, al crear una nueva regla de diagn√≥stico) e inmediatamente controla el resultado de sus ediciones.  Si un desarrollador no tiene m√°s problemas para comparar un registro regular, hace una <i>referencia de</i> registro de advertencias <i>actual</i> para un proyecto.  De lo contrario, el trabajo contin√∫a. <br><br>  Entonces, la tarea de SelfTester es trabajar con un grupo de proyectos de prueba (por cierto, hay m√°s de 120 de ellos para C / C ++).  Los proyectos para el grupo se seleccionan en forma de soluciones de Visual Studio.  Esto se hace para verificar adicionalmente el trabajo del analizador en varias versiones de Visual Studio, que son compatibles con el analizador (en este punto, desde Visual Studio 2010 hasta Visual Studio 2019). <br><br>  <i>Nota:</i> adem√°s, separar√© los conceptos <i>soluci√≥n</i> y <i>proyecto</i> , considerando un proyecto como parte de una soluci√≥n. <br><br>  La interfaz de SelfTester tiene el siguiente aspecto: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/627/355/1d0627355eb338938aa789d33aedec83.png" alt="Cuadro 3"></div><br>  A la izquierda hay una lista de soluciones, a la derecha: resultados de una comprobaci√≥n para cada versi√≥n de Visual Studio. <br><br>  Las etiquetas grises "No admitidas" indican que una soluci√≥n no admite una versi√≥n de Visual Studio elegida o que no se convirti√≥ para esta versi√≥n.  Algunas soluciones tienen una configuraci√≥n en un grupo, que indica una versi√≥n espec√≠fica de Visual Studio para una verificaci√≥n.  Si no se especifica una versi√≥n, se actualizar√° una soluci√≥n para todas las versiones posteriores de Visual Studio.  Un ejemplo de dicha soluci√≥n se encuentra en la captura de pantalla: "smart_ptr_check.sln" (se realiza una comprobaci√≥n para todas las versiones de Visual Studio). <br><br>  Una etiqueta verde "OK" indica que una verificaci√≥n regular no ha detectado diferencias con el registro de referencia.  Una etiqueta roja "Diff" indica las diferencias.  Hay que prestar especial atenci√≥n a estas etiquetas.  Despu√©s de hacer clic dos veces en la etiqueta necesaria, la soluci√≥n elegida se abrir√° en una versi√≥n relacionada de Visual Studio.  All√≠ tambi√©n se abrir√° una ventana con un registro de advertencias.  Los botones de control en la parte inferior le permiten volver a ejecutar el an√°lisis de la soluci√≥n seleccionada o de todas, hacer que el registro elegido (o todo a la vez) haga referencia, etc. <br><br>  Los resultados de SelfTester siempre se duplican en el informe html (informe diffs) <br><br>  Adem√°s de la GUI, SelfTester tambi√©n tiene modos automatizados para ejecuciones nocturnas.  Sin embargo, el patr√≥n de uso habitual que el desarrollador repite ejecuta un desarrollador durante la jornada laboral.  Por lo tanto, una de las caracter√≠sticas m√°s importantes de SelfTester es la velocidad de trabajo. <br><br>  Por qu√© importa la velocidad: <br><br><ol><li> El rendimiento de cada paso es crucial en t√©rminos de pruebas nocturnas.  Obviamente, cuanto m√°s r√°pido pasan las pruebas, mejor.  Por el momento, el tiempo de rendimiento promedio de SelfTester supera las 2 horas; </li><li>  Al ejecutar SelfTester durante el d√≠a, un desarrollador tiene que esperar menos por el resultado, lo que aumenta la productividad de su fuerza laboral. </li></ol><br>  Fue la aceleraci√≥n del rendimiento lo que se convirti√≥ en la raz√≥n de los refinamientos esta vez. <br><br><h2>  Multihilo en SelfTester </h2><br>  SelfTester se cre√≥ inicialmente como una aplicaci√≥n multiproceso con la capacidad de probar simult√°neamente varias soluciones.  La √∫nica limitaci√≥n era que no pod√≠a verificar simult√°neamente la misma soluci√≥n para diferentes versiones de Visual Studio, porque muchas soluciones deben actualizarse a ciertas versiones de Visual Studio antes de la prueba.  Durante el curso, los cambios se introducen directamente en los archivos de los proyectos <i>.vcxproj</i> , lo que conduce a errores durante la ejecuci√≥n paralela. <br><br>  Para que el trabajo sea m√°s eficiente, SelfTester utiliza un programador de tareas inteligente para establecer un valor estrictamente limitado de subprocesos paralelos y mantenerlo. <br><br>  El planificador se usa en dos niveles.  El primero es el nivel de <i>soluciones</i> , se utiliza para comenzar a probar la soluci√≥n <i>.sln</i> utilizando la utilidad <i>PVS-Studio_Cmd.exe</i> .  El mismo planificador, pero con otra configuraci√≥n de <i>grado</i> de <i>paralelismo</i> , se utiliza dentro de <i>PVS-Studio_Cmd.exe</i> (en el nivel de prueba de los <i>archivos de</i> origen). <br><br>  El grado de paralelismo es un par√°metro que indica cu√°ntos subprocesos paralelos deben ejecutarse simult√°neamente.  Se eligieron <i>cuatro</i> y <i>ocho</i> valores predeterminados para el grado de paralelismo de las soluciones y el nivel de los archivos, respectivamente.  Por lo tanto, el n√∫mero de subprocesos paralelos en esta implementaci√≥n tiene que ser 32 (4 soluciones probadas simult√°neamente y 8 archivos).  Esta configuraci√≥n nos parece √≥ptima para el trabajo del analizador en un procesador de ocho n√∫cleos. <br><br>  Un desarrollador puede establecer otros valores del grado de paralelismo por s√≠ mismo seg√∫n el rendimiento de su computadora o las tareas actuales.  Si un desarrollador no especifica este par√°metro, el n√∫mero de procesadores l√≥gicos del sistema se elegir√° de manera predeterminada. <br><br>  <i>Nota:</i> supongamos adem√°s que tratamos con el grado predeterminado de paralelismo. <br><br>  El planificador <i>LimitedConcurrencyLevelTaskScheduler</i> se hereda de <i>System.Threading.Tasks.TaskScheduler</i> y se refina para proporcionar el nivel de paralelismo m√°ximo cuando se trabaja en <i>ThreadPool</i> .  Jerarqu√≠a de herencia: <br><br><pre><code class="cs hljs">LimitedConcurrencyLevelTaskScheduler : PausableTaskScheduler { .... } PausableTaskScheduler: TaskScheduler { .... }</code> </pre> <br>  <i>PausableTaskScheduler le</i> permite pausar el rendimiento de la tarea, y adem√°s de esto, <i>LimitedConcurrencyLevelTaskScheduler</i> proporciona control intelectual de la cola de tareas y la programaci√≥n de su rendimiento, teniendo en cuenta el grado de paralelismo, el alcance de las tareas programadas y otros factores.  Se utiliza un planificador cuando se ejecutan tareas de <i>LimitedConcurrencyLevelTaskScheduler</i> . <br><br><h2>  Razones para refinamientos </h2><br>  El proceso descrito anteriormente tiene un inconveniente: no es √≥ptimo cuando se trata de soluciones de diferentes tama√±os.  Y el tama√±o de las soluciones en el grupo de prueba es <i>muy</i> diverso: de 8 KB a 4 GB, el tama√±o de una carpeta con una soluci√≥n y de 1 a varios miles de archivos de c√≥digo fuente en cada uno. <br><br>  El planificador pone las soluciones en la cola simplemente una tras otra, sin ning√∫n componente inteligente.  Perm√≠tame recordarle que, de forma predeterminada, no se pueden probar m√°s de cuatro soluciones simult√°neamente.  Si actualmente se prueban cuatro soluciones grandes (el n√∫mero de archivos en cada una es m√°s de ocho), se supone que trabajamos de manera efectiva porque utilizamos tantos hilos como sea posible (32). <br><br>  Pero imaginemos una situaci√≥n bastante frecuente, cuando se prueban varias soluciones peque√±as.  Por ejemplo, una soluci√≥n es grande y contiene 50 archivos (se utilizar√° un n√∫mero m√°ximo de subprocesos), mientras que otras tres soluciones contienen tres, cuatro, cinco archivos cada una.  En este caso, solo usaremos 20 hilos (8 + 3 + 4 + 5).  Obtenemos una subutilizaci√≥n del tiempo del procesador y un rendimiento general reducido. <br><br>  <i>Nota</i> : de hecho, el cuello de botella suele ser el subsistema de disco, no el procesador. <br><br><h2>  Mejoras </h2><br>  La mejora que es evidente en este caso es la clasificaci√≥n de la lista de soluciones probadas.  Necesitamos obtener un uso √≥ptimo del n√∫mero establecido de subprocesos ejecutados simult√°neamente (32), pasando a proyectos de prueba con el n√∫mero correcto de archivos. <br><br>  Consideremos nuevamente nuestro ejemplo de probar cuatro soluciones con el siguiente n√∫mero de archivos en cada una: 50, 3, 4 y 5. Es probable que la tarea que verifica una soluci√≥n de <i>tres</i> archivos resulte m√°s r√°pida.  Ser√≠a mejor agregar una soluci√≥n con ocho o m√°s archivos en lugar de ella (para usar el m√°ximo de los hilos disponibles para esta soluci√≥n).  De esta manera, utilizaremos 25 hilos a la vez (8 + <b>8</b> + 4 + 5).  No esta mal.  Sin embargo, siete hilos a√∫n no est√°n involucrados.  Y aqu√≠ surge la idea de otro refinamiento, que es eliminar el l√≠mite de cuatro hilos en las soluciones de prueba.  Porque ahora podemos agregar no una, sino varias soluciones, utilizando 32 hilos.  Imaginemos que tenemos dos soluciones m√°s de tres y cuatro archivos cada una.  Agregar estas tareas cerrar√° completamente la "brecha" de los hilos no utilizados, y habr√°32 (8 + 8 + 4 + 5 + <b>3</b> + <b>4</b> ) de ellos. <br><br>  Esperemos que la idea sea clara.  De hecho, la implementaci√≥n de estas mejoras tampoco requiri√≥ mucho esfuerzo.  Todo se hizo en un d√≠a. <br><br>  Necesit√°bamos reelaborar la clase de tarea: heredar de <i>System.Threading.Tasks.Task</i> y asignar el campo "peso".  Utilizamos un algoritmo simple para establecer el peso en una soluci√≥n: si el n√∫mero de archivos es menor que ocho, el peso es igual a este n√∫mero (por ejemplo, 5).  Si el n√∫mero es mayor o igual a ocho, el peso ser√° igual a ocho. <br><br>  Tambi√©n tuvimos que elaborar el planificador: ense√±arle a elegir soluciones con el peso necesario para alcanzar el valor m√°ximo de 32 hilos.  Tambi√©n tuvimos que permitir m√°s de cuatro subprocesos para las pruebas simult√°neas de soluciones. <br><br>  Finalmente, necesit√°bamos un paso preliminar para analizar todas las soluciones en el grupo (evaluaci√≥n usando MSBuild API) para evaluar y establecer el peso de las soluciones (obtener n√∫meros de archivos con c√≥digo fuente). <br><br><h2>  Resultado </h2><br>  Creo que despu√©s de una presentaci√≥n tan larga ya has adivinado que no sali√≥ nada. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91c/6c1/fca/91c6c1fca4017036c0fca83fd2113474.png" alt="Cuadro 12"></div><br>  Sin embargo, es bueno que las mejoras fueran simples y r√°pidas. <br><br>  Aqu√≠ viene esa parte del art√≠culo, donde les voy a contar sobre lo que "nos meti√≥ en muchos problemas" y todas las cosas relacionadas con √©l. <br><br><h2>  Efectos secundarios </h2><br>  Entonces, un resultado negativo tambi√©n es un resultado.  Result√≥ que la cantidad de soluciones grandes en el grupo <i>supera con creces</i> la cantidad de soluciones peque√±as (menos de ocho archivos).  En este caso, estas mejoras no tienen un efecto muy notable, ya que son casi invisibles: probar proyectos peque√±os requiere una cantidad muy peque√±a de tiempo en comparaci√≥n con el tiempo, necesario para proyectos grandes. <br><br>  Sin embargo, decidimos dejar el nuevo refinamiento como "no perturbador" y potencialmente √∫til.  Adem√°s, el conjunto de soluciones de prueba se repone constantemente, por lo que en el futuro, tal vez, la situaci√≥n cambiar√°. <br><br>  Y luego ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdf/906/0ea/bdf9060ea6b9d1ce17ed820acc1468c7.png" alt="Cuadro 5"></div><br>  Uno de los desarrolladores se quej√≥ de la ca√≠da del SelfTester.  Bueno, la vida pasa.  Para evitar que se pierda este error, creamos un incidente interno (ticket) con el nombre "Excepci√≥n al trabajar con SelfTester".  El error ocurri√≥ al evaluar el proyecto.  Aunque una gran cantidad de ventanas con errores indicaron el problema nuevamente en el controlador de errores.  Pero esto fue eliminado r√°pidamente, y durante la semana siguiente nada se estrell√≥.  De repente, otro usuario se quej√≥ de SelfTester.  Nuevamente, el error de una evaluaci√≥n de proyecto: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/1f3/bd5/0fa1f3bd596a2a4bdbbc0f9ace32664c.png" alt="Cuadro 8"></div><br>  Esta vez, la pila conten√≠a mucha informaci√≥n √∫til: el error estaba en formato xml.  Es probable que al manejar el archivo del proyecto <i>Proto_IRC.vcxproj</i> (su representaci√≥n xml) algo le haya sucedido al archivo en s√≠, por eso <i>XmlTextReader</i> no pudo manejarlo. <br><br>  Tener dos errores en un per√≠odo de tiempo bastante corto nos hizo mirar m√°s de cerca el problema.  Adem√°s, como dije anteriormente, SelfTester es muy utilizado por los desarrolladores. <br><br>  Para empezar, analizamos el √∫ltimo accidente.  Es triste decirlo, no encontramos nada sospechoso.  Por si acaso, les pedimos a los desarrolladores (usuarios de SelfTester) que est√©n atentos e informen sobre posibles errores. <br><br>  Punto importante: el c√≥digo err√≥neo se reutiliz√≥ en SelfTester.  Originalmente se us√≥ para evaluar proyectos en el analizador ( <i>PVS-Studio_Cmd.exe</i> ).  Es por eso que la atenci√≥n al problema ha crecido.  Sin embargo, no hubo tales bloqueos en el analizador. <br><br>  Mientras tanto, el ticket sobre problemas con SelfTester se complement√≥ con nuevos errores: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b49/15a/0ae/b4915a0aecc426246419f4a26e62a233.png" alt="Cuadro 9"></div><br>  <i>XmlException</i> nuevamente.  Obviamente, hay hilos competidores en alg√∫n lugar que funcionan con la lectura y escritura de archivos de proyecto.  SelfTester trabaja con proyectos en los siguientes casos: <br><br><ol><li>  Evaluaci√≥n de proyectos en el curso del c√°lculo preliminar de los pesos de las soluciones: un nuevo paso que inicialmente suscit√≥ sospechas; </li><li>  Actualizaci√≥n de proyectos a las versiones necesarias de Visual Studio: se realiza justo antes de la prueba (los proyectos no interfieren) y no debe afectar el proceso de trabajo. </li><li>  Evaluaci√≥n de proyectos durante las pruebas: un mecanismo seguro para subprocesos bien establecido, reutilizado desde <i>PVS-Studio_Cmd.exe</i> ; </li><li>  Restaurar archivos de proyecto (reemplazando archivos <i>.vcxproj</i> modificados con archivos de referencia iniciales) al salir de SelfTester, porque los archivos de proyecto pueden actualizarse a las versiones necesarias de Visual Studio durante el trabajo.  Es un paso final, que no tiene impacto en otros mecanismos. </li></ol><br>  La sospecha recay√≥ en el nuevo c√≥digo agregado para la optimizaci√≥n (c√°lculo de peso).  Pero su investigaci√≥n de c√≥digo mostr√≥ que si un usuario ejecuta el an√°lisis justo despu√©s del inicio de SelfTester, el probador siempre espera correctamente hasta el final de la evaluaci√≥n previa.  Este lugar parec√≠a seguro. <br><br>  Nuevamente, no pudimos identificar la fuente del problema. <br><br><h2>  Dolor </h2><br>  Todo el mes siguiente, SelfTester continu√≥ fallando una y otra vez.  El ticket sigui√≥ llen√°ndose de datos, pero no estaba claro qu√© hacer con estos datos.  La mayor√≠a de los bloqueos tuvieron la misma <i>XmlException.</i>  Ocasionalmente hab√≠a algo m√°s, pero en el mismo c√≥digo reutilizado de <i>PVS-Studio_Cmd.exe</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/fbe/c11/c31fbec1152210e397b6d9d1ffdb5aa6.png" alt="Imagen 1"></div><br>  Tradicionalmente, a las herramientas internas no se les imponen requisitos muy altos, por lo que seguimos desconcertando los errores de SelfTester sobre un principio residual.  De vez en cuando, se involucraban diferentes personas (durante todo el incidente, seis personas trabajaron en el problema, incluidos dos pasantes).  Sin embargo, tuvimos que distraernos con esta tarea. <br><br>  <i>Nuestro primer error</i>  De hecho, en este punto podr√≠amos haber resuelto este problema de una vez por todas.  Como?  Estaba claro que el error fue causado por una nueva optimizaci√≥n.  Despu√©s de todo, antes de que todo funcionara bien, y el c√≥digo reutilizado claramente no puede ser tan malo.  Adem√°s, esta optimizaci√≥n no hab√≠a tra√≠do ning√∫n beneficio.  Entonces, ¬øqu√© hab√≠a que hacer?  <i>Eliminar esta optimizaci√≥n.</i>  Como probablemente entiendas, no se hizo.  Continuamos trabajando en el problema, que creamos nosotros mismos.  Continuamos buscando la respuesta: "¬øC√ìMO?"  ¬øC√≥mo se bloquea?  Parec√≠a estar escrito correctamente. <br><br>  <i>Nuestro segundo error.</i>  <i>Otras personas se involucraron</i> en la soluci√≥n del problema <i>.</i>  Es un error muy, muy grande.  No solo no resolvi√≥ el problema sino que tambi√©n requiri√≥ recursos adicionales desperdiciados.  S√≠, nuevas personas aportaron nuevas ideas, pero llev√≥ mucho tiempo de trabajo implementar (por nada) estas ideas.  En alg√∫n momento, hicimos que nuestros pasantes escribieran programas de prueba que emulaban la evaluaci√≥n de un mismo proyecto en diferentes hilos con modificaci√≥n paralela de un proyecto en otro proyecto.  No sirvi√≥ de nada.  Solo descubrimos que la API de MSBuild era segura para subprocesos en el interior, lo cual ya hemos conocido.  Tambi√©n agregamos el guardado autom√°tico de mini dump cuando ocurre la excepci√≥n <i>XmlException</i> .  Ten√≠amos a alguien que estaba depurando todo esto.  ¬°Pobre chico!  Hubo discusiones, hicimos otras cosas innecesarias. <br><br>  <i>Finalmente, tercer error.</i>  ¬øSabes cu√°nto tiempo ha pasado desde el momento en que ocurri√≥ el problema de SelfTester hasta el punto en que se resolvi√≥?  Bueno, puedes contar contigo mismo.  El boleto se cre√≥ el 17/09/2018 y se cerr√≥ el 20/02/2019.  ¬°Hubo m√°s de 40 comentarios!  Chicos, eso es mucho tiempo!  Nos <i>permitimos</i> estar ocupados durante cinco meses con ESTO.  Al mismo tiempo, est√°bamos ocupados apoyando Visual Studio 2019, agregando el soporte del lenguaje Java, introduciendo el est√°ndar MISRA C / C ++, mejorando el analizador C #, participando activamente en conferencias, escribiendo un mont√≥n de art√≠culos, etc.  Todas estas actividades recibieron menos tiempo de los desarrolladores debido a un error est√∫pido en SelfTester. <br><br>  Amigos, aprendan de nuestros errores y nunca hagan esto.  Nosotros tampoco lo haremos. <br><br>  Eso es todo, ya termin√©. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/a29/f94/3a8a29f94aeed35ddeaec17222a4f990.png" alt="Cuadro 15"></div><br>  Bien, fue una broma, te dir√© cu√°l fue el problema con SelfTester :) <br><br><h2>  Bingo! </h2><br>  Afortunadamente, hab√≠a una persona entre nosotros con una vista clara (mi colega Sergey Vasiliev), que solo mir√≥ el problema desde un √°ngulo muy diferente (y tambi√©n, tuvo un poco de suerte).  ¬øQu√© pasa si est√° bien dentro del SelfTester, pero algo del exterior bloquea los proyectos?  Usualmente no ten√≠amos nada lanzado con SelfTester, en algunos casos controlamos estrictamente el entorno de ejecuci√≥n.  En este caso, este mismo "algo" podr√≠a ser SelfTester, pero una instancia diferente. <br><br>  Al salir de SelfTester, el hilo que restaura los archivos de proyecto a partir de referencias, contin√∫a funcionando durante un tiempo.  En este punto, el probador podr√≠a iniciarse nuevamente.  La protecci√≥n contra las ejecuciones simult√°neas de varias instancias de SelfTester se agreg√≥ <i>m√°s tarde</i> y ahora tiene el siguiente aspecto: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/7bf/437/0a37bf4373e3beb9bbfe2542afb258a0.png" alt="Cuadro 16"></div><br>  Pero en ese momento no lo ten√≠amos. <br><br>  Locos, pero cierto: durante casi seis meses de tormento nadie le prest√≥ atenci√≥n.  Restaurar proyectos a partir de referencias es un procedimiento de fondo bastante r√°pido, pero desafortunadamente no lo suficientemente r√°pido como para no interferir con el relanzamiento de SelfTester.  ¬øY qu√© pasa cuando lo lanzamos?  As√≠ es, calculando el peso de las soluciones.  Un proceso reescribe archivos <i>.vcxproj</i> mientras otro intenta leerlos.  Saluda a <i>XmlException</i> . <br><br>  Sergey descubri√≥ todo esto cuando agreg√≥ la capacidad de cambiar a un conjunto diferente de registros de referencia para el probador.  Se hizo necesario despu√©s de agregar un conjunto de reglas MISRA en el analizador.  Puede cambiar directamente en la interfaz, mientras el usuario ve esta ventana: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/9b0/87d/0a59b087d0e13688ab41a690ed490a3f.png" alt="Cuadro 14"></div><br>  Despu√©s de eso, <i>SelfTester se</i> reinicia.  Y anteriormente, aparentemente, los usuarios de alguna manera emularon el problema ellos mismos, ejecutando el probador nuevamente. <br><br><h2>  Culpabilidad y conclusiones </h2><br>  Por supuesto, eliminamos (es decir, deshabilitamos) la optimizaci√≥n creada anteriormente.  Adem√°s, fue mucho m√°s f√°cil que hacer alg√∫n tipo de sincronizaci√≥n entre reinicios del probador por s√≠ mismo.  Y todo comenz√≥ a funcionar perfectamente, como antes.  Y como medida adicional, agregamos la protecci√≥n anterior contra el lanzamiento simult√°neo del probador. <br><br>  Ya he escrito anteriormente sobre nuestros principales errores al buscar el problema, por lo que basta de autoflagelaci√≥n.  Somos seres humanos, as√≠ que podr√≠amos estar equivocados.  Es importante aprender de sus propios errores y sacar conclusiones.  Las conclusiones de este caso son bastante simples: <br><br><ul><li>  Deber√≠amos monitorear y estimar la complejidad de la tarea; </li><li>  A veces necesitamos parar en alg√∫n momento; </li><li>  Trata de ver el problema m√°s ampliamente.  Con el tiempo, se puede obtener una visi√≥n del t√∫nel del caso, mientras que requiere una nueva perspectiva. </li><li>  No tengas miedo de eliminar el c√≥digo viejo o innecesario. </li></ul><br>  Eso es todo, esta vez definitivamente he terminado.  Gracias por leer hasta el final.  ¬°Te deseo un c√≥digo sin errores! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466739/">https://habr.com/ru/post/466739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466729/index.html">El libro "Miner√≠a de datos. Recuperando informaci√≥n de Facebook, Twitter, LinkedIn, Instagram, GitHub ¬ª</a></li>
<li><a href="../466731/index.html">Extravagancia Se levanta septiembre</a></li>
<li><a href="../466733/index.html">Bienvenido a DINS Java TARDE 18 de septiembre</a></li>
<li><a href="../466735/index.html">Una manera f√°cil de crear una alerta de voz en el sistema de automatizaci√≥n del hogar ("Smart Home")</a></li>
<li><a href="../466737/index.html">Por qu√© fall√≥ la red social de Google+</a></li>
<li><a href="../466741/index.html">Lo mejor es enemigo de lo bueno.</a></li>
<li><a href="../466745/index.html">El primer lugar de trabajo o c√≥mo comenzar a desarrollar API en Node.js</a></li>
<li><a href="../466747/index.html">Desarrolladores de Mitap iOS en Redmadrobot</a></li>
<li><a href="../466753/index.html">Administraci√≥n de red r√°pida y eficiente - Network MACMonitor</a></li>
<li><a href="../466755/index.html">La computadora te har√° sabrosa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>