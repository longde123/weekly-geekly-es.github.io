<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüöí üèπ üèüÔ∏è Panduan Node.js, Bagian 6: Loop Peristiwa, Stack Panggilan, Pengatur Waktu üè∫ üöæ üì∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini, di bagian keenam dari terjemahan manual Node.js, kita akan berbicara tentang loop acara, tumpukan panggilan, fungsi process.nextTick() , dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan Node.js, Bagian 6: Loop Peristiwa, Stack Panggilan, Pengatur Waktu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424553/"> Hari ini, di bagian keenam dari terjemahan manual Node.js, kita akan berbicara tentang loop acara, tumpukan panggilan, fungsi <code>process.nextTick()</code> , dan timer.  Memahami ini dan mekanisme Node.js lainnya adalah salah satu landasan pengembangan aplikasi yang sukses untuk platform ini. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Kami menyarankan Anda untuk membaca] Bagian lain dari siklus ini</b> <div class="spoiler_text">  Bagian 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi Umum dan Memulai</a> <br>  Bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaScript, V8, beberapa trik pengembangan</a> <br>  Bagian 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hosting, REPL, bekerja dengan konsol, modul</a> <br>  Bagian 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm, package.json dan file package-lock.json</a> <br>  Bagian 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm dan npx</a> <br>  Bagian 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">loop acara, tumpukan panggilan, timer</a> <br>  Bagian 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman Asinkron</a> <br>  Bagian 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, Bagian 8: HTTP dan Protokol WebSocket</a> <br>  Bagian 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, bagian 9: bekerja dengan sistem file</a> <br>  Bagian 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, Bagian 10: Modul Standar, Streaming, Database, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF lengkap dari Node.js Guide</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Perulangan acara</font> </h2><br>  Jika Anda ingin memahami bagaimana kode JavaScript dijalankan, Event Loop adalah salah satu konsep paling penting yang perlu Anda pahami.  Di sini kita akan berbicara tentang cara kerja JavaScript dalam mode single-threaded, dan bagaimana fungsi asinkron ditangani. <br><br>  Saya telah mengembangkan JavaScript selama bertahun-tahun, tetapi saya tidak bisa mengatakan bahwa saya benar-benar mengerti cara kerja semuanya, sehingga bisa dikatakan, "di bawah tenda".  Programmer mungkin tidak menyadari seluk-beluk perangkat subsistem internal dari lingkungan di mana ia bekerja.  Tetapi biasanya berguna untuk memiliki setidaknya gambaran umum tentang hal-hal seperti itu. <br><br>  Kode JavaScript yang Anda tulis berjalan dalam mode single-threaded.  Pada titik waktu tertentu, hanya satu tindakan yang dilakukan.  Keterbatasan ini, pada kenyataannya, sangat berguna.  Ini sangat menyederhanakan cara kerja program, menghilangkan kebutuhan programmer untuk memecahkan masalah khusus untuk lingkungan multi-threaded. <br><br>  Faktanya, seorang programmer JS hanya perlu memperhatikan tindakan yang dilakukan kodenya, dan mencoba menghindari situasi yang menyebabkan pemblokiran utas utama.  Misalnya - membuat panggilan jaringan dalam mode sinkron dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">siklus</a> tanpa akhir. <br><br>  Biasanya, browser, di setiap tab yang terbuka, memiliki loop acara sendiri.  Hal ini memungkinkan Anda untuk mengeksekusi kode setiap halaman dalam lingkungan yang terisolasi dan untuk menghindari situasi ketika halaman tertentu, dalam kode yang ada loop tak terbatas atau perhitungan berat dilakukan, mampu "menangguhkan" seluruh browser.  Browser mendukung pekerjaan banyak loop acara yang ada secara bersamaan, digunakan, misalnya, untuk memproses panggilan ke berbagai API.  Selain itu, loop acara eksklusif digunakan untuk mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pekerja web</a> . <br><br>  Hal terpenting yang harus selalu diingat oleh seorang programmer JavaScript adalah kodenya menggunakan loop acara sendiri, sehingga kode tersebut harus ditulis agar loop acara ini tidak diblokir. <br><br><h2>  <font color="#3AC1EF">Kunci Loop Acara</font> </h2><br>  Kode JavaScript apa pun yang membutuhkan terlalu banyak waktu untuk dieksekusi, yaitu, kode yang tidak terlalu lama mengendalikan loop acara, akan memblokir eksekusi kode halaman lainnya.  Ini bahkan mengarah ke pemblokiran pemrosesan peristiwa antarmuka pengguna, yang berarti bahwa pengguna tidak dapat berinteraksi dengan elemen halaman dan bekerja secara normal dengannya, misalnya, untuk menggulir. <br><br>  Hampir semua mekanisme dasar JavaScript I / O bersifat non-blocking.  Ini berlaku untuk browser dan Node.js.  Di antara mekanisme tersebut, misalnya, kita dapat menyebutkan alat untuk melakukan permintaan jaringan yang digunakan di kedua lingkungan klien dan server, dan alat untuk bekerja dengan file Node.js.  Ada metode sinkron untuk melakukan operasi seperti itu, tetapi mereka hanya digunakan dalam kasus khusus.  Itulah sebabnya callback tradisional dan mekanisme yang lebih baru - janji dan konstruk async / menunggu - sangat penting dalam JavaScript. <br><br><h2>  <font color="#3AC1EF">Tumpukan panggilan</font> </h2><br>  Stack JavaScript Call didasarkan pada prinsip LIFO (Last In, First Out - Last In, First Out).  Perulangan acara terus-menerus memeriksa tumpukan panggilan untuk melihat apakah ia memiliki fungsi yang perlu dijalankan.  Jika, ketika mengeksekusi kode, suatu fungsi dipanggil di dalamnya, informasi tentang itu ditambahkan ke tumpukan panggilan dan fungsi ini dieksekusi. <br><br>  Jika bahkan sebelum Anda tidak tertarik pada konsep "tumpukan panggilan", maka jika Anda telah menemukan pesan kesalahan yang menyertakan jejak tumpukan, Anda sudah membayangkan seperti apa bentuknya.  Di sini, misalnya, terlihat seperti ini di browser. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/b9d/9fe/e6fb9d9fe2d481ab7178cb5bcb022454.png"></div><br>  <i><font color="#999999">Pesan kesalahan browser</font></i> <br><br>  Browser, ketika terjadi kesalahan, melaporkan urutan panggilan ke fungsi, informasi tentang yang disimpan dalam tumpukan panggilan, yang memungkinkan Anda menemukan sumber kesalahan dan memahami panggilan mana ke fungsi yang menyebabkan situasi. <br><br>  Sekarang kita telah berbicara tentang loop peristiwa dan tumpukan panggilan secara umum, pertimbangkan contoh yang menggambarkan eksekusi fragmen kode dan bagaimana proses ini terlihat dari sudut pandang loop peristiwa dan tumpukan panggilan. <br><br><h2>  <font color="#3AC1EF">Event Loop dan Call Stack</font> </h2><br>  Berikut adalah kode yang akan kami coba: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) bar() baz() } foo()</code> </pre> <br>  Jika kode ini dieksekusi, berikut ini akan sampai ke konsol: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> bar baz</code> </pre> <br>  Hasil seperti itu sangat diharapkan.  Yaitu, ketika kode ini dijalankan, fungsi <code>foo()</code> pertama kali dipanggil.  Di dalam fungsi ini, pertama-tama kita memanggil fungsi <code>bar()</code> , dan kemudian fungsi <code>baz()</code> .  Pada saat yang sama, tumpukan panggilan selama eksekusi kode ini mengalami perubahan yang ditunjukkan pada gambar berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/6ea/763/c2e6ea7631946a6d0f141416fbdba077.png"></div><br>  <i><font color="#999999">Mengubah status tumpukan panggilan saat menjalankan kode</font></i> <br><br>  Perulangan acara, pada setiap iterasi, memeriksa untuk melihat apakah ada sesuatu di tumpukan panggilan, dan jika demikian, ia melakukannya sampai tumpukan panggilan kosong. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Iterasi loop acara</font></i> <br><br><h2>  <font color="#3AC1EF">Mengantri fungsi</font> </h2><br>  Contoh di atas terlihat cukup biasa, tidak ada yang istimewa tentang itu: JavaScript menemukan kode yang perlu dieksekusi dan menjalankannya secara berurutan.  Kami akan berbicara tentang cara menunda eksekusi fungsi hingga tumpukan panggilan dihapus.  Untuk melakukan ini, konstruksi berikut digunakan: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}), <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Ini memungkinkan Anda untuk menjalankan fungsi yang diteruskan ke fungsi <code>setTimeout()</code> setelah semua fungsi lain yang disebut dalam kode program dieksekusi. <br><br>  Pertimbangkan sebuah contoh: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) baz() } foo()</code> </pre> <br>  Apa yang dicetak kode ini mungkin tampak tidak terduga: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> baz bar</code> </pre> <br>  Ketika kita menjalankan contoh ini, fungsi <code>foo()</code> dipanggil terlebih dahulu.  Di dalamnya, kita memanggil <code>setTimeout()</code> , melewati fungsi ini, sebagai argumen pertama, <code>bar</code> .  Dengan meneruskannya <code>0</code> sebagai argumen kedua, kami memberi tahu sistem bahwa fungsi ini harus dilakukan sesegera mungkin.  Kemudian kita memanggil fungsi <code>baz()</code> . <br><br>  Beginilah tampilan tumpukan panggilan sekarang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a23/8fd/d45/a238fdd4515c24e61f2e297f3c5b9d17.png"></div><br>  <i><font color="#999999">Mengubah status tumpukan panggilan saat menjalankan kode</font></i> <br><br>  Ini adalah urutan di mana fungsi-fungsi dalam program kami sekarang akan dieksekusi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Iterasi loop acara</font></i> <br><br>  Mengapa ini terjadi seperti ini? <br><br><h2>  <font color="#3AC1EF">Antrian acara</font> </h2><br>  Ketika fungsi <code>setTimeout()</code> dipanggil, browser atau platform Node.js memulai timer.  Setelah penghitung waktu bekerja (dalam kasus kami, ini terjadi segera, karena kami mengaturnya ke 0), fungsi panggilan balik dilewatkan ke <code>setTimeout()</code> masuk ke dalam Antrian Acara. <br><br>  Antrian acara, ketika datang ke browser, termasuk peristiwa yang diprakarsai oleh pengguna - peristiwa yang disebabkan oleh klik mouse pada elemen halaman, peristiwa yang dipicu ketika data dimasukkan dari keyboard.  Penangan <code>onload</code> DOM seperti <code>onload</code> , fungsi yang dipanggil saat menerima jawaban untuk permintaan asinkron untuk memuat data, ada di sana.  Di sini mereka menunggu giliran mereka untuk memproses. <br><br>  Perulangan acara memberikan prioritas pada apa yang ada di tumpukan panggilan.  Pertama, ia melakukan semua yang berhasil ditemukannya di stack, dan setelah stack kosong, ia melanjutkan untuk memproses apa yang ada di antrian acara. <br><br>  Kita tidak perlu menunggu sampai fungsi seperti <code>setTimeout()</code> selesai bekerja, karena fungsi yang sama disediakan oleh browser dan mereka menggunakan stream mereka sendiri.  Jadi, misalnya, mengatur timer selama 2 detik menggunakan fungsi <code>setTimeout()</code> , Anda seharusnya tidak, setelah menghentikan eksekusi kode lain, tunggu selama 2 detik ini, karena timer bekerja di luar kode Anda. <br><br><h2>  <font color="#3AC1EF">Antrian Pekerjaan ES6</font> </h2><br>  ECMAScript 2015 (ES6) memperkenalkan konsep Job Queue, yang digunakan oleh janji-janji (mereka juga muncul dalam ES6).  Berkat antrian pekerjaan, hasil dari mengeksekusi fungsi asinkron dapat digunakan secepat mungkin, tanpa perlu menunggu tumpukan panggilan dihapus. <br><br>  Jika janji diselesaikan sebelum akhir fungsi saat ini, kode yang sesuai akan dieksekusi segera setelah fungsi saat ini selesai. <br><br>  Saya menemukan analogi yang menarik untuk apa yang kita bicarakan.  Ini dapat dibandingkan dengan roller coaster di taman hiburan.  Setelah Anda menaiki bukit dan ingin melakukannya lagi, Anda mengambil tiket dan masuk ke dalam barisan.  Inilah cara kerja antrian acara.  Tetapi antrian pekerjaan terlihat berbeda.  Konsep ini mirip dengan tiket diskon, yang memberi Anda hak untuk melakukan perjalanan berikutnya segera setelah Anda menyelesaikan yang sebelumnya. <br><br>  Perhatikan contoh berikut: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span>   resolve(<span class="hljs-string"><span class="hljs-string">'should be right after baz, before bar'</span></span>) ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resolve)) baz() } foo()</code> </pre> <br>  Inilah yang akan menjadi output setelah eksekusi: <br><br><pre> <code class="hljs pgsql">foo baz should be right <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> baz, <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> bar bar</code> </pre> <br>  Apa yang dapat Anda lihat di sini menunjukkan perbedaan serius antara janji (dan async / wait construct, yang didasarkan pada mereka) dan fungsi asinkron tradisional, yang pelaksanaannya diatur menggunakan <code>setTimeout()</code> atau API lain dari platform yang digunakan. <br><br><h2>  <font color="#3AC1EF">process.nextTick ()</font> </h2><br>  Metode <code>process.nextTick()</code> berinteraksi dengan loop peristiwa dengan cara khusus.  Kutu adalah satu siklus penuh peristiwa.  Melewati fungsi ke metode <code>process.nextTick()</code> , kami memberi tahu sistem bahwa fungsi ini perlu dipanggil setelah iterasi saat ini dari loop acara selesai, sebelum yang berikutnya dimulai.  Menggunakan metode ini terlihat seperti ini: <br><br><pre> <code class="hljs javascript">process.nextTick(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// -  })</span></span></code> </pre> <br>  Misalkan loop acara sibuk mengeksekusi kode untuk fungsi saat ini.  Ketika operasi ini selesai, mesin JavaScript akan menjalankan semua fungsi yang diteruskan ke <code>process.nextTick()</code> selama operasi sebelumnya.  Dengan menggunakan mekanisme ini, kami berusaha untuk memastikan bahwa fungsi tertentu dijalankan secara tidak sinkron (setelah fungsi saat ini), tetapi sesegera mungkin, tanpa menempatkannya dalam antrian. <br><br>  Misalnya, jika Anda menggunakan konstruksi <code>setTimeout(() =&gt; {}, 0)</code> , fungsi akan dieksekusi pada iterasi berikutnya dari loop acara, yaitu, jauh lebih lambat daripada ketika <code>process.nextTick()</code> digunakan dalam situasi yang sama.  Metode ini harus digunakan ketika perlu untuk memastikan eksekusi beberapa kode pada awal iterasi berikutnya dari loop acara. <br><br><h2>  <font color="#3AC1EF">setImmediate ()</font> </h2><br>  Fungsi lain yang disediakan oleh Node.js untuk eksekusi kode asinkron adalah <code>setImmediate()</code> .  Berikut cara menggunakannya: <br><br><pre> <code class="hljs javascript">setImmediate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  Fungsi panggilan balik yang dilewatkan ke <code>setImmediate()</code> akan dieksekusi pada iterasi berikutnya dari loop acara. <br><br>  Bagaimana <code>setImmediate()</code> berbeda dari <code>setTimeout(() =&gt; {}, 0)</code> (yaitu, dari timer yang harus bekerja sesegera mungkin) dan dari <code>process.nextTick()</code> ? <br><br>  Fungsi yang diteruskan ke <code>process.nextTick()</code> akan dieksekusi setelah iterasi saat ini dari loop acara telah selesai.  Artinya, fungsi seperti itu akan selalu dieksekusi sebelum fungsi yang eksekusinya dijadwalkan menggunakan <code>setTimeout()</code> atau <code>setImmediate()</code> . <br><br>  Memanggil fungsi <code>setTimeout()</code> dengan penundaan set 0 ms sangat mirip dengan memanggil <code>setImmediate()</code> .  Urutan pelaksanaan fungsi yang ditransfer ke mereka tergantung pada berbagai faktor, tetapi dalam kedua kasus panggilan balik akan dipanggil pada iterasi berikutnya dari loop acara. <br><br><h2>  <font color="#3AC1EF">Pengatur waktu</font> </h2><br>  Kami telah berbicara tentang fungsi <code>setTimeout()</code> , yang memungkinkan Anda untuk menjadwalkan panggilan ke panggilan balik yang dilaluinya.  Mari kita luangkan waktu untuk menjelaskan lebih rinci fitur-fiturnya dan mempertimbangkan fungsi lain, <code>setInterval()</code> , mirip dengan itu.  Dalam Node.js, fungsi untuk bekerja dengan timer termasuk dalam modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">timer</a> , tetapi Anda dapat menggunakannya tanpa menghubungkan modul ini ke dalam kode, karena itu bersifat global. <br><br><h3>  <font color="#3AC1EF">‚ñç fungsi setTimeout ()</font> </h3><br>  Ingatlah bahwa ketika Anda memanggil fungsi <code>setTimeout()</code> , ia menerima panggilan balik dan waktu, dalam milidetik, setelah itu panggilan balik akan dipanggil.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">50</span></span>  }, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br>  Di sini kita meneruskan <code>setTimeout()</code> fungsi baru yang segera dijelaskan, tetapi di sini kita dapat menggunakan fungsi yang ada dengan meneruskan <code>setTimeout()</code> nama dan seperangkat parameter untuk menjalankannya.  Ini terlihat seperti ini: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstParam, secondParam</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } //   2  setTimeout(myFunction, 2000, firstParam, secondParam)</span></span></code> </pre> <br>  Fungsi <code>setTimeout()</code> mengembalikan pengidentifikasi waktu.  Biasanya tidak digunakan, tetapi Anda dapat menyimpannya dan, jika perlu, menghapus timer jika panggilan balik yang dijadwalkan tidak lagi diperlukan: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      2  }, 2000) //  ,       clearTimeout(id)</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Zero delay</font> </h3><br>  Di bagian sebelumnya, kami menggunakan <code>setTimeout()</code> , meneruskannya, sebagai waktu setelah itu diperlukan untuk memanggil panggilan balik, <code>0</code> .  Ini berarti bahwa panggilan balik akan dipanggil sesegera mungkin, tetapi setelah menyelesaikan fungsi saat ini: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'after '</span></span>) }, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' before '</span></span>)</code> </pre> <br>  Kode tersebut akan menampilkan yang berikut: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span></code> </pre> <br>  Teknik ini sangat berguna dalam situasi ketika, ketika melakukan tugas komputasi yang berat, saya tidak ingin memblokir utas utama, memungkinkan fungsi lain dieksekusi, memecah tugas-tugas ini menjadi beberapa tahap, dieksekusi sebagai panggilan <code>setTimeout()</code> . <br><br>  Jika kita mengingat fungsi <code>setImmediate()</code> , maka itu adalah standar di Node.js, yang tidak dapat dikatakan tentang browser (ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diterapkan</a> di IE dan Edge, tetapi tidak pada yang lain). <br><br><h3>  <font color="#3AC1EF">‚ñç fungsi setInterval ()</font> </h3><br>  Fungsi <code>setInterval()</code> mirip dengan <code>setTimeout()</code> , tetapi ada perbedaan di antara mereka.  Alih-alih mengeksekusi callback yang diteruskan sekali, <code>setInterval()</code> akan secara berkala, dengan interval yang ditentukan, panggil callback ini.  Ini akan berlanjut, idealnya, sampai saat ketika programmer secara eksplisit menghentikan proses ini.  Berikut cara menggunakan fitur ini: <br><br><pre> <code class="hljs javascript">setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  Panggilan balik yang dilewatkan ke fungsi yang ditunjukkan di atas akan dipanggil setiap 2 detik.  Untuk memberikan kemungkinan menghentikan proses ini, Anda perlu mengembalikan pengidentifikasi waktu dengan <code>setInterval()</code> dan menggunakan perintah <code>clearInterval()</code> : <br><br><pre> <code class="hljs lisp">const id = setInterval(() =&gt; { //   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) clearInterval(<span class="hljs-name"><span class="hljs-name">id</span></span>)</code> </pre> <br>  Teknik umum adalah memanggil <code>clearInterval()</code> di dalam callback yang diteruskan ke <code>setInterval()</code> ketika kondisi tertentu terpenuhi.  Misalnya, kode berikut akan dijalankan secara berkala hingga properti <code>App.somethingIWait</code> untuk <code>arrived</code> : <br><br><pre> <code class="hljs lisp">const interval = setInterval(<span class="hljs-name"><span class="hljs-name">function</span></span>() { if (<span class="hljs-name"><span class="hljs-name">App</span></span>.somethingIWait === 'arrived') {   clearInterval(<span class="hljs-name"><span class="hljs-name">interval</span></span>)   //    -  ,   -    } }, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Pengaturan rekursif setTimeout ()</font> </h3><br>  Fungsi <code>setInterval()</code> akan memanggil panggilan balik yang dilaluinya setiap <code>n</code> milidetik, tanpa khawatir apakah panggilan balik ini selesai setelah panggilan sebelumnya. <br><br>  Jika setiap panggilan ke panggilan balik ini selalu membutuhkan waktu yang sama kurang dari <code>n</code> , maka tidak ada masalah yang muncul di sini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f0/66d/192/2f066d192a047c90e90f45d69a66002e.png"></div><br>  <i><font color="#999999">Disebut callback secara berkala, setiap sesi eksekusi membutuhkan waktu yang sama, termasuk dalam interval antar panggilan</font></i> <br><br>  Mungkin butuh waktu berbeda untuk menyelesaikan panggilan balik, yang masih kurang dari <code>n</code> .  Jika, misalnya, kita berbicara tentang melakukan operasi jaringan tertentu, maka situasi ini sangat diharapkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/7e7/fb2/73c7e7fb2a0a687c0f84707e5f1e13e1.png"></div><br>  <i><font color="#999999">Disebut callback secara berkala, setiap sesi pelaksanaannya membutuhkan waktu yang berbeda, jatuh di antara panggilan</font></i> <br><br>  Saat menggunakan <code>setInterval()</code> , situasi dapat muncul ketika panggilan balik mengambil lebih dari <code>n</code> , yang mengarah ke panggilan berikutnya selesai sebelum yang sebelumnya selesai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/007/220/41a00722099daaf6012792aeeb1ccd93.png"></div><br>  <i><font color="#999999">Disebut callback secara berkala, setiap sesi membutuhkan waktu yang berbeda, yang terkadang tidak sesuai dengan interval antar panggilan</font></i> <br><br>  Untuk menghindari situasi ini, Anda dapat menggunakan teknik pengaturan pengatur waktu rekursif menggunakan <code>setTimeout()</code> .  Intinya adalah bahwa panggilan panggil berikutnya direncanakan setelah selesainya panggilan sebelumnya: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    setTimeout(myFunction, 1000) } setTimeout( myFunction() }, 1000)</span></span></code> </pre> <br>  Dengan pendekatan ini, skenario berikut dapat diimplementasikan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3dc/4ec/442/3dc4ec4427764f48e8d68e00f409cebd.png"></div><br>  <i><font color="#999999">Panggilan rekursif ke setTimeout () untuk menjadwalkan eksekusi panggilan balik</font></i> <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Hari ini kita berbicara tentang mekanisme internal Node.js, seperti loop acara, tumpukan panggilan, dan membahas bekerja dengan timer yang memungkinkan Anda untuk menjadwalkan eksekusi kode.  Lain kali kita akan mempelajari topik pemrograman asinkron. <br><br>  <b>Pembaca yang budiman!</b>  Pernahkah Anda mengalami situasi ketika Anda harus menggunakan process.nextTick ()? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424553/">https://habr.com/ru/post/id424553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424537/index.html">Sberbank meluncurkan operator sendiri SberMobile</a></li>
<li><a href="../id424539/index.html">Java 11: baru dalam String</a></li>
<li><a href="../id424541/index.html">Kisah kegagalan UGJ 2018: cara membuat game yang tidak disukai siapa pun (jangan lakukan itu!)</a></li>
<li><a href="../id424543/index.html">Java 11 / JDK 11: Ketersediaan Umum</a></li>
<li><a href="../id424551/index.html">Hangat dan tabung: lima balalaika tentang teknologi audio magnetik</a></li>
<li><a href="../id424555/index.html">Manual Node.js, Bagian 7: Pemrograman Asinkron</a></li>
<li><a href="../id424557/index.html">Panduan Node.js, Bagian 8: Protokol HTTP dan WebSocket</a></li>
<li><a href="../id424559/index.html">Big Data resistance 1 atau Joe yang sulit dipahami. Anonimitas internet, anti-deteksi, anti-pelacakan untuk anti-Anda dan anti-us</a></li>
<li><a href="../id424563/index.html">Langsung menuju detail percakapan ke orang asing</a></li>
<li><a href="../id424565/index.html">Tinjauan umum: Pemindaian 3D dari bangunan real estat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>