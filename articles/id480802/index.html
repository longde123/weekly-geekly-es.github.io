<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👺 🌊 🤾🏾 Rekayasa Kekacauan, Bagian 3: Metode dan Alat 👩🏽‍🌾 💆🏾 🍈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita menjadi apa yang kita lihat. Pertama kita membentuk alat, lalu alat membentuk kita. 

 —Marshal McLuhan 

 Saya ingin mengucapkan terima kasih da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rekayasa Kekacauan, Bagian 3: Metode dan Alat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/480802/"><p><img src="https://habrastorage.org/webt/bj/bo/hr/bjbohri48f3n_qtsbswegzbyw5y.jpeg"></p><br><blockquote>  Kita menjadi apa yang kita lihat.  Pertama kita membentuk alat, lalu alat membentuk kita. <br><br>  —Marshal McLuhan </blockquote><p> <em>Saya ingin mengucapkan terima kasih dan terima kasih kepada teman baik saya <a href="https://medium.com/%40094459">Ricardo Sueiras</a> atas ulasannya, kontribusi dan untuk tidak membiarkan saya meninggalkan artikel ini belum selesai.</em>  <em>Ricardo, kamu hanya legenda!</em> </p><br><p>  Penting untuk diingat bahwa chaos engineering bukanlah saat Anda melepaskan monyet dan memasuki kegagalan tanpa pandang bulu.  Rekayasa kekacauan adalah <a href="https://en.wikipedia.org/wiki/Scientific_method">teknik</a> eksperimen <a href="https://en.wikipedia.org/wiki/Scientific_method">formal yang</a> terdefinisi dengan baik. </p><a name="habracut"></a><br><blockquote>  "Rekayasa kekacauan melibatkan pengamatan yang cermat, skeptisisme yang parah tentang objek pengamatan, karena asumsi kognitif mengubah interpretasi hasil. Teknik ini melibatkan perumusan hipotesis melalui induksi berdasarkan pengamatan yang sama; pengujian eksperimental dan pengukuran berdasarkan kesimpulan yang dibuat dari hipotesis yang sama; penyesuaian atau penolakan hipotesis berdasarkan hasil eksperimen " <br><br>  —Wikipedia </blockquote><p>  Rekayasa kekacauan dimulai dengan memahami keadaan stabil dari sistem yang Anda hadapi, kemudian merumuskan hipotesis, dan akhirnya sebuah eksperimen yang menegaskan hal itu, membantu meningkatkan margin keamanan sistem. </p><br><p><img src="https://habrastorage.org/webt/gq/yq/jc/gqyqjcysfguozpispkjletc21ik.png"><br>  <em>Tahapan Rekayasa Kekacauan</em> </p><br><p>  Pada bagian <a href="https://medium.com/%40adhorn/chaos-engineering-ab0cc9fbd12a">pertama dari serangkaian artikel,</a> saya memperkenalkan chaos engineering dan mendiskusikan setiap langkah metodologi yang dijelaskan di atas. </p><br><p>  Pada bagian <a href="https://medium.com/%40adhorn/chaos-engineering-part-2-b9c78a9f3dde">kedua</a> , saya memeriksa bidang-bidang di mana Anda perlu berinvestasi ketika merancang eksperimen tentang rekayasa kekacauan, dan bagaimana memilih hipotesis yang tepat. </p><br><p>  Pada bagian ketiga ini, saya akan fokus pada percobaan itu sendiri dan menyajikan pilihan alat dan metode yang mencakup berbagai kegagalan. </p><br><p>  Daftar ini tidak lengkap, tetapi untuk memulainya, dan untuk memberikan makanan untuk dipikirkan, itu sudah cukup. </p><br><h2 id="vvedenie-otkaza---chto-eto-i-dlya-chego-nuzhno">  Pengenalan kegagalan - untuk apa dan untuk apa? </h2><br><p>  Kegagalan digunakan untuk memverifikasi bahwa respons sistem memenuhi spesifikasi dalam kondisi beban normal.  Untuk pertama kalinya teknik ini digunakan ketika <a href="https://ieeexplore.ieee.org/document/780999/">kegagalan diperkenalkan pada tingkat "besi"</a> - pada tingkat kontak, dengan mengubah sinyal listrik pada perangkat. </p><br><p>  Dalam pemrograman, pengenalan kegagalan membantu meningkatkan stabilitas sistem perangkat lunak dan memungkinkan Anda untuk mengoreksi kelemahan dalam perlawanan terhadap potensi kegagalan dalam sistem.  Ini disebut troubleshooting.  Ini juga membantu untuk menilai kerusakan akibat kegagalan - mis.  radius kerusakan, bahkan sebelum kegagalan terjadi di lingkungan produksi.  Ini disebut prediksi kesalahan. </p><br><p>  Pengenalan kegagalan memiliki beberapa manfaat utama, membantu: </p><br><ul><li>  Memahami dan mempraktikkan respons terhadap kecelakaan dan insiden. </li><li>  memahami efek dari kegagalan nyata. </li><li>  memahami efektivitas dan keterbatasan mekanisme toleransi kesalahan. </li><li>  menghilangkan kesalahan desain dan mendeteksi titik kegagalan umum. </li><li>  memahami dan meningkatkan kemampuan pengamatan sistem. </li><li>  memahami radius kegagalan kegagalan dan mempersempitnya. </li><li>  memahami penyebaran kesalahan antar komponen sistem. </li></ul><br><h3 id="kategorii-vvedeniya-otkazov">  Kategori Kegagalan </h3><br><p>  Ada 5 kategori pengenalan kegagalan: pada tingkat (1) sumber daya;  (2) jaringan dan dependensi;  (3) aplikasi, proses, dan layanan;  (4) infrastruktur;  dan (5) tingkat manusia **. </p><br><p>  Selanjutnya, saya akan memeriksa masing-masing kategori dan memberikan contoh memperkenalkan kegagalan untuk masing-masing kategori.  Saya juga akan mempertimbangkan contoh memperkenalkan kegagalan dan instrumen orkestrasi all-in-one. </p><br><blockquote>  ** Penting!  Dalam posting ini saya tidak menyentuh pengenalan kegagalan di tingkat manusia, tetapi saya akan mempertimbangkannya sebagai berikut. </blockquote><br><h2 id="1---vvedenie-otkaza-na-urovne-resursa-aka-nehvatka-resursov">  1 - Pengenalan kegagalan di tingkat sumber daya, alias kurangnya sumber daya. </h2><br><p>  Ya, teknologi cloud telah mengajarkan kita bahwa sumber daya hampir tidak terbatas, tetapi saya segera mengecewakan Anda: mereka tidak terbatas.  Mesin virtual, wadah, fungsi, dll.  - terlepas dari abstraksi, sumber daya akhirnya berakhir.  Melampaui batas yang diijinkan, kehabisan sumber daya maksimum disebut kelelahan. </p><br><p><img src="https://habrastorage.org/webt/ri/54/nn/ri54nnmprlvjvug3f395w6ohofk.png"></p><br><p>  Kurangnya sumber daya meniru <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">penolakan</a> serangan <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">layanan</a> , tetapi bukan serangan biasa, untuk menyusup ke server yang dimaksud.  Pengenalan kegagalan ini mungkin tersebar luas, karena, mungkin, tidak sulit untuk digunakan. </p><br><h3 id="istoschaya-resursy-cpu-pamyati-i-vvodavyvoda">  Menguras sumber daya CPU, memori, dan I / O </h3><br><p>  Salah satu alat favorit saya adalah <a href="https://www.mankier.com/1/stress-ng">stress-ng,</a> korespondensi <a href="https://directory.fsf.org/wiki/Stress">alat pengujian stres</a> asli <a href="https://directory.fsf.org/wiki/Stress">, yang ditulis oleh Amos Waterland</a> . </p><br><p>  Dengan stress-ng, kesalahan dapat dimasukkan dengan memuat berbagai subsistem fisik komputer, serta mengendalikan antarmuka inti sistem menggunakan tes stres.  Tes stres berikut tersedia: CPU, cache CPU, perangkat, I / O, interupsi, sistem file, memori, jaringan, OS, pipa, penjadwal, dan VM.  <a href="https://www.mankier.com/1/stress-ng">Halaman manual</a> menyertakan deskripsi lengkap dari semua tes stres yang tersedia, dan hanya ada 220 di antaranya! </p><br><p>  Di bawah ini adalah beberapa contoh praktis tentang bagaimana menggunakan stres: </p><br><p> Beban pada CPU <code>matrixprod</code> memberikan campuran operasi yang tepat dengan memori, cache dan floating point.  Ini mungkin.  Cara terbaik untuk menghangatkan CPU dengan baik. </p><br><pre> <code class="plaintext hljs">❯ stress-ng —-cpu 0 --cpu-method matrixprod -t 60s</code> </pre> <br><p>  Beban <code>iomix-bytes</code> menulis N-byte untuk setiap <code>iomix</code> handler <code>iomix</code> ;  Standarnya adalah 1 GB dan ideal untuk melakukan tes stres I / O.  Dalam contoh ini, saya akan mengatur 80% ruang kosong pada sistem file. </p><br><pre> <code class="plaintext hljs">❯ stress-ng --iomix 1 --iomix-bytes 80% -t 60s</code> </pre> <br><p>  <code>vm-bytes</code> bagus untuk tes stres memori.  Dalam contoh ini, stress-ng menjalankan 9 stress test dari memori virtual, yang secara bersamaan mengkonsumsi 90% dari memori yang tersedia per jam.  Dengan demikian, setiap pengujian rambut menghabiskan 10% dari memori yang tersedia. </p><br><pre> <code class="plaintext hljs">❯ stress-ng --vm 9 --vm-bytes 90% -t 60s</code> </pre> <br><h3 id="nehvatka-diskovogo-prostranstva-na-zhestkih-diskah">  Ruang diska pada hard drive </h3><br><p>  <code>dd</code> adalah utilitas baris perintah yang dikompilasi untuk mengonversi dan menyalin file.  Namun, <code>dd</code> dapat membaca dan / atau menulis dari file-file perangkat khusus seperti <code>/dev/zero</code> dan <code>/dev/random</code> untuk tugas-tugas seperti mencadangkan sektor boot dari hard disk dan mendapatkan sejumlah data acak yang tetap.  Dengan demikian, ini dapat digunakan untuk memperkenalkan kegagalan pada server dan mensimulasikan overflow disk.  Apakah file log Anda membanjiri server dan menjatuhkan aplikasi?  Jadi, <code>dd</code> akan membantu - dan itu akan menyakitkan! </p><br><p>  <strong>Gunakan <code>dd</code> dengan sangat hati-hati.</strong>  <strong>Masukkan perintah yang salah - dan data pada hard akan dihapus, dihancurkan atau ditimpa!</strong> </p><br><pre> <code class="plaintext hljs">❯ dd if=/dev/urandom of=/burn bs=1M count=65536 iflag=fullblock &amp;</code> </pre> <br><h3 id="podtormazhivanie-api-prilozheniy">  Perlambatan API Aplikasi </h3><br><p>  Kinerja, ketahanan, dan skalabilitas API sangat penting.  API sangat penting untuk membangun aplikasi dan mengembangkan bisnis Anda. </p><br><p>  Pengujian beban adalah cara yang bagus untuk menguji aplikasi Anda sebelum mulai diproduksi.  Ini juga merupakan metode beban stres yang keren, karena sering mengungkapkan pengecualian dan batasan yang, dalam keadaan lain, akan tetap tidak terlihat sebelum bertemu dengan lalu lintas nyata. </p><br><p>  <a href="https://github.com/wg/wrk"><code>wrk</code></a> adalah alat pembandingan HTTP yang memberikan tekanan signifikan pada sistem.  Saya terutama ingin menguji pemeriksaan aksesibilitas API, terutama ketika menyangkut <a href="https://medium.com/%40adhorn/patterns-for-resilient-architecture-part-3-16e8601c488e">pemeriksaan kinerja</a> , karena mereka mengungkapkan banyak hal mengenai keputusan desain di tingkat kode pengembang: bagaimana cara cache dikonfigurasikan?  Bagaimana batas kecepatan diterapkan?  Apakah sistem memprioritaskan pemeriksaan kesehatan terkait penyeimbang beban? </p><br><p>  Di sinilah untuk memulai: </p><br><pre> <code class="plaintext hljs">❯ wrk -t12 -c400 -d20s http://127.0.0.1/api/health</code> </pre> <br><p>  Perintah ini memulai 12 utas dan membuat 400 koneksi HTTP terbuka selama 20 detik. </p><br><h2 id="2---vvedenie-otkazov-na-urovne-seti-i-zavisimostey">  2 - Memperkenalkan kegagalan dan ketergantungan tingkat jaringan </h2><br><p>  Buku <a href="http://wiki.c2.com/%3FPeterDeutsch">Peter Deutsch</a> , <a href="http://eightfallaciesofdistributedcomputing/">The Eight Fallacy of Distributed Computing,</a> adalah kumpulan asumsi yang dibuat pengembang saat merancang sistem terdistribusi.  Dan kemudian jawabannya terbang dalam bentuk tidak dapat diaksesnya, dan Anda harus mengulang semuanya.  Asumsi yang keliru ini adalah: </p><br><ul><li>  Jaringannya andal. </li><li>  Penundaannya adalah 0. </li><li>  Bandwidth tidak terbatas. </li><li>  Jaringan aman. </li><li>  Topologi tidak berubah. </li><li>  Hanya ada satu administrator. </li><li>  Biaya transfer 0. </li><li>  Jaringannya homogen. </li></ul><br><p>  Daftar ini adalah titik awal yang baik untuk memilih failover jika Anda menguji untuk melihat apakah sistem terdistribusi Anda dapat menangani kegagalan jaringan. <br>  Memperkenalkan latensi jaringan, kehilangan, dan pemadaman </p><br><h3 id="vvedenie-zaderzhki-poteri-ili-obryva-seti">  Memperkenalkan latensi jaringan, kehilangan atau gangguan </h3><br><p>  <code>tc</code> ( <a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html">traffic control</a> ) adalah alat baris perintah Linux yang digunakan untuk mengkonfigurasi penjadwal batch kernel Linux.  Ini mendefinisikan bagaimana paket-paket di-antri untuk pengiriman dan penerimaan di antarmuka jaringan.  Operasi termasuk antrian, definisi kebijakan, klasifikasi, perencanaan, pembentukan, dan kerugian. </p><br><p>  <code>tc</code> dapat digunakan untuk mensimulasikan penundaan dan kehilangan paket untuk aplikasi UDP atau TCP atau untuk membatasi penggunaan bandwidth layanan tertentu - untuk mensimulasikan kondisi lalu lintas Internet. </p><br><p>  <strong>- Pengenalan penundaan 100 ms</strong> </p><br><pre> <code class="plaintext hljs">#Start ❯ tc qdisc add dev etho root netem delay 100ms #Stop ❯ tc qdisc del dev etho root netem delay 100ms</code> </pre> <br><p>  <strong>- Pengenalan penundaan 100 ms dengan delta 50 ms</strong> </p><br><pre> <code class="plaintext hljs">#Start ❯ tc qdisc add dev eth0 root netem delay 100ms 50ms #Stop ❯ tc qdisc del dev eth0 root netem delay 100ms 50ms</code> </pre> <br><p>  <strong>- kerusakan 5% dari paket jaringan</strong> </p><br><pre> <code class="plaintext hljs">#Start ❯ tc qdisc add dev eth0 root netem corrupt 5% #Stop ❯ tc qdisc del dev eth0 root netem corrupt 5%</code> </pre> <br><p>  <strong>- Paket loss 7% dengan korelasi 25 persen</strong> </p><br><pre> <code class="plaintext hljs">#Start ❯ tc qdisc add dev eth0 root netem loss 7% 25% #Stop ❯ tc qdisc del dev eth0 root netem loss 7% 25%</code> </pre> <br><blockquote>  <strong>Penting!</strong>  7% sudah cukup untuk aplikasi TCP tidak turun. </blockquote><br><h3 id="igraya-s-etchosts---staticheskoy-tablicey-poiska-dlya-imen-uzlov">  Bermain dengan "/ etc / hosts" - tabel pencarian statis untuk nama host </h3><br><p>  <code>/etc/hosts</code> adalah file teks sederhana yang mengaitkan alamat IP dengan nama host, satu baris setiap kali.  Setiap node memerlukan satu baris yang berisi informasi berikut: </p><br><pre> <code class="plaintext hljs">IP_address canonical_hostname [aliases...]</code> </pre> <br><p><img src="https://habrastorage.org/webt/mx/po/lo/mxpoloqghh2ou_bphgifo69ydba.png"></p><br><p>  File host adalah salah satu dari beberapa sistem yang mengakses node jaringan pada jaringan komputer dan menerjemahkan nama host yang dipahami orang ke alamat IP.  Dan ya, Anda dapat menebaknya: berkat itu, mudah untuk menipu komputer.  Berikut ini beberapa contohnya: </p><br><p>  <strong>- Blokir akses ke DynamoDB API untuk instance EC2</strong> </p><br><pre> <code class="plaintext hljs">#Start # make copy of /etc/hosts to /etc/host.back ❯ cp /etc/hosts /etc/hosts.back ❯ echo "127.0.0.1 dynamodb.us-east-1.amazonaws.com" &gt;&gt; /etc/hosts ❯ echo "127.0.0.1 dynamodb.us-east-2.amazonaws.com" &gt;&gt; /etc/hosts ❯ echo "127.0.0.1 dynamodb.us-west-1.amazonaws.com" &gt;&gt; /etc/hosts ❯ echo "127.0.0.1 dynamodb.us-west-2.amazonaws.com" &gt;&gt; /etc/hosts ❯ echo "127.0.0.1 dynamodb.eu-west-1.amazonaws.com" &gt;&gt; /etc/hosts ❯ echo "127.0.0.1 dynamodb.eu-north-1.amazonaws.com" &gt;&gt; /etc/hosts #Stop # copy back the old version /etc/hosts ❯ cp /etc/hosts.back /etc/hosts</code> </pre> <br><p>  <strong>- Blokir akses ke API EC2 dari instance EC2</strong> </p><br><pre> <code class="plaintext hljs">#Start # make copy of /etc/hosts to /etc/host.back ❯ cp /etc/hosts /etc/hosts.back ❯ echo "127.0.0.1 ec2.us-east-1.amazonaws.com" &gt;&gt; /etc/hosts ❯ echo "127.0.0.1 ec2.us-east-2.amazonaws.com" &gt;&gt; /etc/hosts ❯ echo "127.0.0.1 ec2.us-west-1.amazonaws.com" &gt;&gt; /etc/hosts ❯ echo "127.0.0.1 ec2.us-west-2.amazonaws.com" &gt;&gt; /etc/hosts ❯ echo "127.0.0.1 ec2.eu-west-1.amazonaws.com" &gt;&gt; /etc/hosts ❯ echo "127.0.0.1 ec2.eu-north-1.amazonaws.com" &gt;&gt; /etc/hosts #Stop # copy back the old version /etc/hosts ❯ cp /etc/hosts.back /etc/hosts</code> </pre> <br><p>  Tonton langsung: pertama, API EC2 tersedia dan <code>ec2 describe-instances</code> berhasil kembali. </p><br><p><img src="https://habrastorage.org/webt/f9/oy/bc/f9oybcnf8l9s8ov4m7bzulyx6as.png"></p><br><p>  Setelah saya menambahkan <code>127.0.01 ec2.eu-west-1.amazonaws.com</code> ke <code>/etc/hosts</code> , dan panggilan EC2 API turun. </p><br><p><img src="https://habrastorage.org/webt/lj/6v/_y/lj6v_y8w7yfhnk9h8izd2gtj2aw.png"></p><br><p>  Tentu saja, ini berfungsi untuk semua API AWS. </p><br><h2 id="rasskazal-by-ya-vam-anekdot-pro-dns">  Saya akan menceritakan lelucon tentang DNS ... </h2><br><p><img src="https://habrastorage.org/webt/dq/mo/ps/dqmopsts1wl0pfntxgvwoqgcwby.gif"></p><br><h3 id="no-boyus-do-vas-doydet-tolko-na-vtorye-sutki-v-smysle-cherez-24-chasa">  ... tapi, saya khawatir, itu hanya akan sampai pada hari kedua.  Maksudku, setelah 24 jam. </h3><br><p>  Pada 21 Oktober 2016, karena <a href="https://en.wikipedia.org/wiki/2016_Dyn_cyberattack">serangan DDoS Dyn,</a> sejumlah platform dan layanan yang layak di Eropa dan Amerika Utara tidak tersedia.  Menurut <a href="https://www.thousandeyes.com/resources/2018-global-dns-performance-benchmark-report">laporan ThousandEyes pada kinerja DNS di seluruh dunia pada tahun 2018</a> , 60% dari perusahaan dan penyedia SaaS masih mengandalkan satu sumber penyedia DNS dan, dengan demikian, menjadi rentan terhadap kegagalan DNS.  Dan karena tidak akan ada Internet tanpa DNS, akan bagus untuk mensimulasikan kegagalan DNS untuk mengevaluasi ketahanan Anda terhadap kegagalan DNS berikutnya. </p><br><p>  <strong>Blackholing</strong> adalah metode di mana mereka secara tradisional mengurangi kerusakan <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">serangan DDoS</a> .  Lalu lintas jaringan yang buruk dialihkan ke lubang hitam dan dibuang untuk membatalkan.  Versi <code>/dev/null</code> untuk bekerja di jaringan :-) Anda dapat menggunakannya untuk mensimulasikan hilangnya lalu lintas jaringan atau protokol dari <a href="https://en.wikipedia.org/wiki/Domain_Name_System">DNS yang</a> sama, katakanlah. </p><br><p>  Untuk tugas ini, Anda memerlukan alat <a href="https://linux.die.net/man/8/iptables"><code>iptables</code></a> , yang digunakan untuk mengkonfigurasi, memelihara dan memverifikasi paket IP di kernel Linux. </p><br><p>  Untuk mendapatkan lalu lintas DNS melalui lubang hitam, coba ini: </p><br><pre> <code class="plaintext hljs">#Start ❯ iptables -A INPUT -p tcp -m tcp --dport 53 -j DROP ❯ iptables -A INPUT -p udp -m udp --dport 53 -j DROP #Stop ❯ iptables -D INPUT -p tcp -m tcp --dport 53 -j DROP ❯ iptables -D INPUT -p udp -m udp --dport 53 -j DROP</code> </pre> <br><h3 id="vvedenie-otkazov-s-ispolzovaniem-toxiproxy">  Pengenalan kegagalan menggunakan Toxiproxy. </h3><br><p>  Alat-alat Linux seperti <code>tc</code> dan <code>iptables</code> satu - tetapi bukan satu-satunya - masalah serius.  Mereka memerlukan izin root untuk menjalankan, dan ini menciptakan masalah untuk beberapa organisasi dan lingkungan.  Mohon cinta dan budi - <strong>Toxiproxy</strong> ! </p><br><p>  <a href="https://github.com/shopify/toxiproxy">Toxiproxy</a> adalah proksi TCP open source yang dikembangkan <a href="https://engineering.shopify.com/">oleh tim insinyur Shopify</a> .  Ini membantu mensimulasikan kondisi jaringan dan sistem yang kacau atau sistem nyata.  Tempatkan di antara berbagai komponen arsitektur seperti yang ditunjukkan di bawah ini. </p><br><p><img src="https://habrastorage.org/webt/9u/k6/w-/9uk6w-tyk0jk6n1jgdg8awf0oyo.png"></p><br><p>  Itu dibuat khusus untuk pengujian, CI, dan lingkungan pengembangan, dan memperkenalkan kebingungan yang telah ditentukan atau acak yang dikendalikan melalui pengaturan.  Toxiproxy menggunakan <a href="https://github.com/shopify/toxiproxy"><strong>racun</strong></a> untuk memanipulasi hubungan antara klien dan kode pengembang, dan itu dapat dikonfigurasi melalui <a href="&amp;xid=17259,15700002,15700022,15700186,15700190,15700259,15700271&amp;usg=ALkJrhjaiX6ryXNZcTDOdOy_n6uv0g5UoA#">API HTTP</a> .  Dan baginya dalam kit ada racun yang cukup untuk memulai. </p><br><p>  Contoh berikut menunjukkan bagaimana Toxiproxy bekerja dengan kode klien toksik dengan memperkenalkan penundaan 1000 ms dalam koneksi antara klien Redis saya, redis-cli, dan Redis itu sendiri. </p><br><p><img src="https://habrastorage.org/webt/vg/zg/gf/vgzggft6l5n0eywx2gn__njbc08.png"></p><br><p>  Toxiproxy telah berhasil digunakan oleh Shopify di semua lingkungan produksi dan pengembangan sejak Oktober 2014.  Informasi lebih lanjut ada di <a href="https://shopifyengineering.myshopify.com/blogs/engineering/building-and-testing-resilient-ruby-on-rails-applications">blog</a> mereka. </p><br><h2 id="3---vvedenie-otkazov-na-urovne-prilozheniya-processa-i-servisa">  3 - Pengenalan kegagalan pada tingkat aplikasi, proses dan layanan </h2><br><p>  Perangkat lunak sedang jatuh.  Ini fakta.  Dan apa yang kamu lakukan?  Haruskah saya masuk melalui SSH di server dan memulai kembali proses yang gagal?  Sistem kontrol proses menyediakan fungsi kontrol keadaan atau keadaan perubahan tipe mulai, berhenti, restart.  Sistem kontrol biasanya digunakan untuk memastikan kontrol proses yang stabil.  <a href="https://en.wikipedia.org/wiki/Systemd"><code>systemd</code></a> hanyalah alat seperti itu, menyediakan batu bata kontrol proses dasar untuk Linux.  <a href="http://supervisord.org/introduction.html"><code>Supervisord</code></a> menawarkan kontrol beberapa proses pada sistem operasi seperti UNIX. </p><br><p>  Saat Anda menggunakan aplikasi, Anda harus menggunakan alat ini.  Ini tentu praktik yang baik untuk menguji kerusakan dari membunuh proses kritis.  Pastikan Anda menerima peringatan dan proses memulai ulang secara otomatis. </p><br><p>  <strong>- bunuh proses Java</strong> </p><br><pre> <code class="plaintext hljs">❯ pkill -KILL -f java #Alternative ❯ pkill -f 'java -jar'</code> </pre> <br><p>  <strong>- bunuh proses Python</strong> </p><br><pre> <code class="plaintext hljs">❯ pkill -KILL -f python</code> </pre> <br><p>  Tentu saja, Anda dapat menggunakan perintah <code>pkill</code> untuk membunuh beberapa proses lain yang berjalan pada sistem. </p><br><h2 id="vvedenie-otkazov-bazy-dannyh">  Memperkenalkan Kegagalan Database </h2><br><p>  Jika ada pesan kegagalan yang operator tidak suka menerima, maka ini adalah pesan yang terkait dengan kegagalan basis data.  Data sepadan dengan bobotnya dalam emas, dan karenanya, setiap kali basis data macet, risiko kehilangan data pelanggan meningkat. </p><br><p><img src="https://habrastorage.org/webt/3c/lz/ye/3clzye5agj95ocxbo0vyorq2opc.png"><br>  <em>Ini akan menjadi perawatan yang mudah.</em>  <em>Dan-dan-dan-dan-dan-begitu ... semuanya telah jatuh</em> </p><br><p>  Terkadang kemampuan untuk memulihkan data dan membawa database ke dalam kondisi kerja secepat mungkin menentukan masa depan perusahaan.  Sayangnya, itu juga tidak selalu mudah untuk mempersiapkan berbagai mode kegagalan database - dan banyak dari mereka akan muncul hanya di lingkungan produksi. </p><br><p>  Namun, jika Anda menggunakan <a href="https://aws.amazon.com/rds/aurora/">Amazon Aurora</a> , Anda bisa menguji ketahanan cluster database Amazon Aurora untuk kegagalan menggunakan <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/AuroraMySQL.Managing.FaultInjectionQueries.html">permintaan failover</a> . </p><br><h3 id="vvedenie-otkaza-amazon-aurora">  Amazon Aurora Crash Pendahuluan </h3><br><p>  Permintaan kegagalan dikeluarkan sebagai perintah SQL ke instance Amazon Aurora dan memungkinkan Anda untuk menjadwalkan simulasi dari salah satu peristiwa berikut: </p><br><ul><li>  Gagal menulis contoh DB. </li><li>  Replika Aurora. </li><li>  Kerusakan disk. </li><li>  Disk overload. </li></ul><br><p>  Saat mengirim permintaan untuk kegagalan, Anda juga harus menentukan jumlah waktu selama peristiwa kegagalan akan disimulasikan. </p><br><p>  <strong>- Penyebab Kegagalan Amazon Aurora Instance:</strong> </p><br><pre> <code class="plaintext hljs">ALTER SYSTEM CRASH [ INSTANCE | DISPATCHER | NODE ];</code> </pre> <br><p>  <strong>- mensimulasikan kegagalan Aurora Replica:</strong> </p><br><pre> <code class="plaintext hljs">ALTER SYSTEM SIMULATE percentage PERCENT READ REPLICA FAILURE [ TO ALL | TO "replica name" ] FOR INTERVAL quantity { YEAR | QUARTER | MONTH | WEEK | DAY | HOUR | MINUTE | SECOND };</code> </pre> <br><p>  <strong>- mensimulasikan kegagalan disk untuk kelompok basis data Aurora:</strong> </p><br><pre> <code class="plaintext hljs">ALTER SYSTEM SIMULATE percentage PERCENT DISK FAILURE [ IN DISK index | NODE index ] FOR INTERVAL quantity { YEAR | QUARTER | MONTH | WEEK | DAY | HOUR | MINUTE | SECOND };</code> </pre> <br><p>  <strong>- mensimulasikan kegagalan disk untuk kelompok basis data Aurora:</strong> </p><br><pre> <code class="plaintext hljs">ALTER SYSTEM SIMULATE percentage PERCENT DISK CONGESTION BETWEEN minimum AND maximum MILLISECONDS [ IN DISK index | NODE index ] FOR INTERVAL quantity { YEAR | QUARTER | MONTH | WEEK | DAY | HOUR | MINUTE | SECOND };</code> </pre> <br><h2 id="otkazy-v-mire-besservernyh-prilozheniy">  Kecelakaan di dunia aplikasi tanpa server </h2><br><p>  Kegagalan bisa menjadi tantangan nyata jika Anda menggunakan komponen tanpa server, karena layanan tanpa server seperti AWS Lambda tidak secara bawaan mendukung failover. </p><br><h3 id="vvedenie-otkazov-v-funkcii-lambda">  Memperkenalkan Kegagalan Lambda </h3><br><p>  Untuk memahami masalah ini, saya menulis <a href="https://github.com/adhorn/aws-lambda-chaos-injection">perpustakaan python kecil</a> dan <a href="https://github.com/adhorn/aws-lambda-layer-chaos-injection">lapisan lambda</a> - untuk memperkenalkan kegagalan pada <a href="https://aws.amazon.com/lambda/">AWS Lambda</a> .  Saat ini, keduanya mendukung penundaan, kesalahan, pengecualian, dan pengenalan kode kesalahan HTTP.  Kegagalan dicapai dengan mengkonfigurasi <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html">AWS SSM Parameter Store</a> sebagai berikut: </p><br><pre> <code class="plaintext hljs">{ "isEnabled": true, "delay": 400, "error_code": 404, "exception_msg": "I really failed seriously", "rate": 1 }</code> </pre> <br><p>  Anda dapat menambahkan dekorator python ke fungsi handler untuk memperkenalkan kegagalan. </p><br><p>  <strong>- melempar pengecualian:</strong> </p><br><pre> <code class="plaintext hljs">@inject_exception def handler_with_exception(event, context): return { 'statusCode': 200, 'body': 'Hello from Lambda!' } &gt;&gt;&gt; handler_with_exception('foo', 'bar') Injecting exception_type &lt;class "Exception"&gt; with message I really failed seriously a rate of 1 corrupting now Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/.../chaos_lambda.py", line 316, in wrapper raise _exception_type(_exception_msg) Exception: I really failed seriously</code> </pre> <br><p>  <strong>- masukkan kode kesalahan "HTTP tidak valid":</strong> </p><br><pre> <code class="plaintext hljs">@inject_statuscode def handler_with_statuscode(event, context): return { 'statusCode': 200, 'body': 'Hello from Lambda!' } &gt;&gt;&gt; handler_with_statuscode('foo', 'bar') Injecting Error 404 at a rate of 1 corrupting now {'statusCode': 404, 'body': 'Hello from Lambda!'}</code> </pre> <br><p>  <strong>- masukkan penundaan:</strong> </p><br><pre> <code class="plaintext hljs">@inject_delay def handler_with_delay(event, context): return { 'statusCode': 200, 'body': 'Hello from Lambda!' } &gt;&gt;&gt; handler_with_delay('foo', 'bar') Injecting 400 of delay with a rate of 1 Added 402.20ms to handler_with_delay {'statusCode': 200, 'body': 'Hello from Lambda!'}</code> </pre> <br><p>  Klik di <a href="https://github.com/adhorn/aws-lambda-chaos-injection">sini</a> untuk mempelajari lebih lanjut tentang perpustakaan python ini. </p><br><h3 id="vvedenie-otkaza-v-ispolnenie-lambda-cherez-ogranichenie-parallelizma">  Memperkenalkan Kegagalan Lambda Melalui Batasan Concurrency </h3><br><p>  Lambda secara default, untuk alasan keamanan, menyesuaikan eksekusi paralel dari semua fungsi di wilayah tertentu per akun.  Eksekusi paralel mengacu pada beberapa eksekusi kode fungsi yang terjadi setiap saat.  Mereka digunakan untuk skala panggilan fungsi ke permintaan masuk.  Tapi itu bisa berfungsi untuk tujuan yang berlawanan: menghentikan eksekusi Lambda. </p><br><pre> <code class="plaintext hljs">❯ aws lambda put-function-concurrency --function-name &lt;value&gt; --reserved-concurrent-executions 0</code> </pre> <br><p>  Perintah ini akan mengurangi concurrency menjadi nol, menyebabkan kegagalan kueri dengan kesalahan seperti "pengereman" - DTC <code>429</code> . </p><br><h3 id="thundra---trassirovka-besservernyh-peredach">  Thundra - jejak transmisi tanpa server </h3><br><p>  <a href="https://www.thundra.io/"><strong>Thundra</strong></a> adalah alat pemantauan aplikasi tanpa server yang memiliki kemampuan <a href="https://www.thundra.io/"><strong>bawaan</strong></a> untuk menyuntikkan kegagalan ke dalam aplikasi tanpa server.  Dia membuat <a href="https://docs.thundra.io/docs/python-span-listeners">pembungkus pembungkus</a> untuk memperkenalkan kegagalan seperti "tidak ada penangan kesalahan" untuk operasi dengan DynamoDB, "tidak ada kesalahan netralisasi" untuk sumber data, atau "tidak ada batas waktu dalam permintaan HTTP keluar".  Saya belum mencobanya sendiri, tetapi dalam <a href="https://blog.thundra.io/chaos-test-your-lambda-functions-with-thundra">posting</a> ini untuk kepengarangan <a href="https://twitter.com/theburningmonk">Yan Chui</a> dan dalam <a href="https://www.youtube.com/watch%3Fv%3DTpoN1wm2bok">video yang luar biasa</a> ini <a href="https://www.youtube.com/watch%3Fv%3DTpoN1wm2bok">oleh</a> <a href="https://twitter.com/mavi888uy">Marsha Villalba,</a> prosesnya dijelaskan dengan baik.  Itu terlihat menjanjikan. </p><br><p>  Dan dalam kesimpulan bagian tentang aplikasi tanpa server, saya akan mengatakan bahwa Yan Chui memiliki <a href="https://hackernoon.com/how-can-we-apply-the-principles-of-chaos-engineering-to-aws-lambda-80f87e3237e2">artikel yang bagus</a> tentang kesulitan rekayasa kekacauan dalam kaitannya dengan aplikasi tanpa server.  Saya merekomendasikan semua orang untuk membacanya. </p><br><h2 id="4---vvedenie-otkazov-na-urovne-infrastruktury">  4 - Pengenalan kegagalan di tingkat infrastruktur </h2><br><p>  Semuanya dimulai dengan pengenalan kegagalan di tingkat infrastruktur - untuk <a href="https://medium.com/%40adhorn/chaos-engineering-ab0cc9fbd12a">Amazon dan Netflix.</a>  Pengenalan kegagalan pada tingkat infrastruktur - dari memutuskan seluruh pusat data hingga menghentikan secara acak - mungkin yang paling mudah untuk diterapkan. </p><br><p>  Dan, tentu saja, contoh " <a href="https://github.com/Netflix/chaosmonkey">monyet kekacauan</a> " muncul di benak pertama. </p><br><h3 id="ostanovka-instansov-ec2-vybrannyh-sluchayno-v-nekotoroy-zone-dostupnosti">  Menghentikan instance EC2 yang dipilih secara acak di zona ketersediaan tertentu. </h3><br><p>  Dalam masa pertumbuhannya, Netflix ingin memperkenalkan aturan arsitektur yang tangguh.  Dia mengerahkan "chaos monkey" sebagai salah satu aplikasi AWS pertama yang menginstal microservices stateless berskala - dalam arti bahwa setiap instance dapat dihancurkan atau diganti secara otomatis tanpa menyebabkan hilangnya status sama sekali.  The Chaos Monkey memastikan bahwa tidak ada yang melanggar aturan ini. </p><br><p>  Skenario berikutnya - mirip dengan "monyet kekacauan" - adalah untuk menghentikan setiap kejadian secara acak, di zona ketersediaan khusus dalam wilayah yang sama. </p><br><pre> <code class="plaintext hljs">❯ stop_random_instance(az="eu-west-1a", tag_name="chaos", tag_value="chaos-ready", region="eu-west-1")</code> </pre> <br><pre> <code class="plaintext hljs">import boto3 import random REGION = 'eu-west-1' def stop_random_instance(az, tag_name, tag_value, region=REGION): ''' &gt;&gt;&gt; stop_random_instance(az="eu-west-1a", tag_name='chaos', tag_value="chaos-ready", region='eu-west-1') ['i-0ddce3c81bc836560'] ''' ec2 = boto3.client("ec2", region_name=region) paginator = ec2.get_paginator('describe_instances') pages = paginator.paginate( Filters=[ { "Name": "availability-zone", "Values": [ az ] }, { "Name": "tag:" + tag_name, "Values": [ tag_value ] } ] ) instance_list = [] for page in pages: for reservation in page['Reservations']: for instance in reservation['Instances']: instance_list.append(instance['InstanceId']) print("Going to stop any of these instances", instance_list) selected_instance = random.choice(instance_list) print("Randomly selected", selected_instance) response = ec2.stop_instances(InstanceIds=[selected_instance]) return response</code> </pre> <br><p>  Apakah Anda <code>tag_name</code> <code>tag_value</code> dan <code>tag_value</code> ?  Hal-hal kecil seperti itu akan mencegah kegagalan contoh yang salah.  # tanpa belajar </p><br><p><img src="https://habrastorage.org/webt/fj/a3/uq/fja3uq8zoomlzrr4zomp1ycnh3k.jpeg"><br>  <em>Dan ya ... restart basis data - bagus [bukan, bukan itu contoh]</em> </p><br><h2 id="5---vvedenie-otkazov-i-instrumenty-orkestracii-tipa-vse-v-odnom">  5 - Pengenalan kegagalan dan alat orkestrasi all-in-one </h2><br><p>  Kemungkinan Anda tersesat dalam banyak alat.  Untungnya, ada beberapa perkenalan penolakan dan alat orkestrasi yang mencakup sebagian besar dari mereka dan mudah digunakan. </p><br><h3 id="chaos-toolkit">  Kekacauan toolkit </h3><br><p>  Salah satu alat favorit saya adalah <a href="https://github.com/chaostoolkit">Chaos Toolkit</a> , platform rekayasa kekacauan open source yang secara komersial didukung oleh tim <a href="https://chaosiq.io/">ChaosIQ yang</a> hebat.  Berikut adalah beberapa di antaranya: <a href="https://twitter.com/russmiles">Russ Miles</a> , <a href="https://twitter.com/lawouach">Sylvain Helleguarch</a> dan <a href="https://twitter.com/mperrien">Marc Parrien</a> . </p><br><p>  Chaos Toolkit mendefinisikan API deklaratif dan dapat diperluas untuk melakukan eksperimen rekayasa kekacauan dengan mudah.  Ini termasuk driver untuk AWS, Google Cloud Engine, Microsoft Azure, Cloud Foundry, Humino, Prometheus, dan GREMLIN. </p><br><p>  Ekstensi adalah serangkaian pemeriksaan dan tindakan yang digunakan untuk eksperimen sebagai berikut: kami menghentikan instance yang dipilih secara acak di zona ketersediaan tertentu jika <code>tag-key</code> berisi <code>chaos-ready</code> . </p><br><pre> <code class="plaintext hljs">{ "version": "1.0.0", "title": "What is the impact of randomly terminating an instance in an AZ", "description": "terminating EC2 instance at random should not impact my app from running", "tags": ["ec2"], "configuration": { "aws_region": "eu-west-1" }, "steady-state-hypothesis": { "title": "more than 0 instance in region", "probes": [ { "provider": { "module": "chaosaws.ec2.probes", "type": "python", "func": "count_instances", "arguments": { "filters": [ { "Name": "availability-zone", "Values": ["eu-west-1c"] } ] } }, "type": "probe", "name": "count-instances", "tolerance": [0, 1] } ] }, "method": [ { "type": "action", "name": "stop-random-instance", "provider": { "type": "python", "module": "chaosaws.ec2.actions", "func": "stop_instance", "arguments": { "az": "eu-west-1c" }, "filters": [ { "Name": "tag-key", "Values": ["chaos-ready"] } ] }, "pauses": { "after": 60 } } ], "rollbacks": [ { "type": "action", "name": "start-all-instances", "provider": { "type": "python", "module": "chaosaws.ec2.actions", "func": "start_instances", "arguments": { "az": "eu-west-1c" }, "filters": [ { "Name": "tag-key", "Values": ["chaos-ready"] } ] } } ] }</code> </pre> <br><p>  Melakukan percobaan di atas sederhana: </p><br><pre> <code class="plaintext hljs">❯ chaos run experiment_aws_random_instance.json</code> </pre> <br><p><img src="https://habrastorage.org/webt/0l/tb/qz/0ltbqz2b-ppule8qm6xxn0jb6p4.png"></p><br><p>  Kekuatan dari Chaos Toolkit adalah, pertama, ini adalah open source dan dapat disesuaikan dengan kebutuhan Anda.  Kedua, sangat cocok dengan pipa CI / CD dan mendukung pengujian kekacauan terus menerus. </p><br><p>  Kelemahan dari Chaos Toolkit adalah butuh waktu untuk menguasainya.  Selain itu, tidak ada eksperimen yang sudah jadi di dalamnya, jadi Anda harus menulis sendiri.  Namun, saya akrab dengan tim di ChaosIQ, yang bekerja tanpa lelah, memahami tugas ini. </p><br><h3 id="gremlin">  GREMLIN </h3><br><p>  Favorit saya yang lain adalah GREMLIN.  Ini berisi serangkaian mode komprehensif untuk memperkenalkan kegagalan dalam alat sederhana dengan antarmuka pengguna yang intuitif.  Kekacauan Seperti Layanan. </p><br><p>  GREMLIN mendukung pengenalan kegagalan pada level <a href="https://www.gremlin.com/docs/infrastructure-layer/attacks/">sumber daya, jaringan dan kueri</a> , memungkinkan Anda untuk bereksperimen dengan cepat dengan seluruh sistem, termasuk  dengan perangkat keras, berbagai penyedia cloud, lingkungan kemas, termasuk Kubernetes, aplikasi dan, sampai batas tertentu, aplikasi tanpa server. </p><br><p>  Plus bonus - orang-orang dari <a href="https://twitter.com/GremlinInc">GREMLIN adalah</a> orang hebat yang menulis konten hebat untuk <a href="https://www.gremlin.com/blog/">blog</a> dan selalu siap membantu!  Berikut adalah beberapa di antaranya: <a href="https://twitter.com/callmeforni">Matthew</a> , <a href="https://twitter.com/KoltonAndrus">Colton</a> , <a href="https://twitter.com/tammybutow">Tammy</a> , <a href="https://twitter.com/richburroughs">Rich</a> , <a href="https://twitter.com/Ana_M_Medina">Ana</a> dan <a href="https://twitter.com/HoReaL">HML</a> . </p><br><p>  GREMLIN tidak memiliki tempat untuk digunakan: </p><br><p>  Pertama masuk ke aplikasi GREMLIN dan pilih "Buat Serangan". </p><br><p><img src="https://habrastorage.org/webt/xw/cv/m9/xwcvm9psqdr8uottkvc2nt4kexi.png"></p><br><p>  Tetapkan tujuan - contoh. </p><br><p><img src="https://habrastorage.org/webt/v_/2v/u7/v_2vu75wvlrzgdem88t2ml0rggu.png"></p><br><p>  Pilih jenis kegagalan yang ingin Anda perkenalkan, dan mungkin kekacauan mulai! </p><br><p><img src="https://habrastorage.org/webt/bx/oq/ox/bxoqoxv4vvxlayqtbtwpgkxd_yw.png"></p><br><p>  Saya harus mengakui bahwa saya selalu menyukai GREMLIN: dengan itu, percobaan pada rekayasa kekacauan secara intuitif sederhana. </p><br><p>   <a href="https://www.gremlin.com/pricing/"> </a> —    ,          .      .  , Gremlin-  daemon    ,   ,      . </p><br><h3 id="run-command-ot-aws-system-manager"> Run Command  AWS System Manager </h3><br><p>  <a href="https://aws.amazon.com/blogs/aws/new-ec2-run-command-remote-instance-management-at-scale/">Run command    EC2</a> ,   2015 ,       .           —   2,      <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-managedinstances.html"> </a> .       ,       ,   Systems Manager. </p><br><p> Run Command    DevOps   ad-hoc  ,      . </p><br><p>   ,  Run Command            ,        Windows,       -. </p><br><p>       <a href="https://medium.com/%40adhorn/injecting-chaos-to-amazon-ec2-using-amazon-system-manager-ca95ee7878f5">    AWS System Manager</a>   <a href="https://github.com/adhorn/chaos-ssm-documents">  </a>    .  — ! </p><br><h2 id="zakruglyaemsya"> ! </h2><br><p>     ,          . </p><br><p> 1 — - —    ,     -   .  .          —    , —     , ,    .   ,     !    <a href="https://twitter.com/ovhall"> </a> : </p><br><blockquote> "  .      ". <br> — ,    - Amazon Prime Video </blockquote><p> 2 —    , ,        .                ,        -. </p><br><p> 3 —        ,        ,    . </p><br><p> 4 — , , ,     . ,  - —        ,     . </p><br><p>    , , ,    . ,    . ,     ,       :-) </p><br><p> —  </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480802/">https://habr.com/ru/post/id480802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480792/index.html">Rekayasa Hadiah</a></li>
<li><a href="../id480794/index.html">Sedikit tentang kasus khusus implementasi algoritma pencarian pintu terbuka</a></li>
<li><a href="../id480796/index.html">Pemrogram Schrodinger, devops dan kucing</a></li>
<li><a href="../id480798/index.html">C ++ Russia Piter 2019 melaporkan ulasan</a></li>
<li><a href="../id480800/index.html">Mencari penguji pekerjaan? Bersiaplah untuk menunjukkan keterampilan pengembang</a></li>
<li><a href="../id480804/index.html">Memilih sistem desain 3D yang sempurna</a></li>
<li><a href="../id480806/index.html">5 Alasan Utama Mengapa Saya Menyukai Properti CSS Khusus</a></li>
<li><a href="../id480808/index.html">Frontend Odnoklassniki baru: meluncurkan React in Java. Bagian I</a></li>
<li><a href="../id480810/index.html">Bagaimana cara mempersiapkan transformasi digital? Hancurkan bisnis Anda sebelumnya</a></li>
<li><a href="../id480812/index.html">Nvidia RTX - Teknologi penelusuran sinar waktu nyata akhirnya muncul di SOLIDWORKS Visualize</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>