<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèº ‚úíÔ∏è üíî Arduin et LED, ou comment mettre √† niveau le designer pour enfants ‚ò¶Ô∏è üí§ üôÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mon fils s'est fermement ¬´accroch√©¬ª au constructeur magn√©tique Magformers . Apr√®s avoir parcouru une s√©rie de Fixiks o√π le m√™me constructeur √©tait en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduin et LED, ou comment mettre √† niveau le designer pour enfants</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435198/"><img src="https://habrastorage.org/webt/wp/c4/ox/wpc4oxeubxh_dsoa07dy5wfccoa.jpeg"><br><br>  Mon fils s'est fermement ¬´accroch√©¬ª au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constructeur magn√©tique Magformers</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apr√®s</a> avoir parcouru une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©rie de Fixiks o√π le m√™me constructeur √©tait en vedette, l'</a> enfant a demand√©: ¬´Papa, pourquoi les fixics ont-ils des d√©tails qui brillent, mais pas nous?¬ª. <br><br>  Il s'est av√©r√© qu'il y a vraiment un ¬´Magformers Neon LED Set¬ª, o√π en plus des blocs de construction habituels, il y a aussi un √©l√©ment avec une LED.  √âtant donn√© qu'√† cette √©poque, nous avions d√©j√† rassembl√© toute une bo√Æte d'aimants de toutes les formes et tailles possibles (quant √† moi, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">magformers chinois ne</a> sont pas inf√©rieurs √† l'original du tout), je ne voulais pas acheter un autre ensemble juste pour le plaisir d'une ampoule.  De plus, cet ensemble co√ªte beaucoup plus cher qu'un similaire sans r√©tro-√©clairage. <br><br>  Ayant estim√© qu'il n'y avait que quelques dollars dans les composants, dont la plupart √©taient d√©j√† en place, j'ai d√©cid√© de r√©cup√©rer ma morgulka.  Oui, et avec des effets que l'original n'avait pas. <br><br>  Sous le chat, vous trouverez l'option d'un clignotant sur l'ATTiny85 et le panneau LED sur les LED WS8212.  Je vais parler des circuits, de la fa√ßon dont j'ai aliment√© tout cela √† partir de la batterie, ainsi que des probl√®mes √©vidents que j'ai ratiss√©s en cours de route.  Je parlerai √©galement en d√©tail de la composante logicielle du projet. <br><a name="habracut"></a><br><h2>  Premiers pas </h2><br>  Il me semblait que la lueur sur une LED r√©guli√®re (m√™me RGB) est ennuyeuse et banale.  Mais ressentir quelque chose comme WS8212 semblait int√©ressant.  Sur ebee, des LED individuelles et des matrices jusqu'√† 16x16 ont √©t√© propos√©es.  Apr√®s avoir achet√© plusieurs modules diff√©rents, j'ai opt√© pour une matrice 4x4.  Il y a beaucoup de LED pour se livrer √† divers effets visuels, tandis que le module est de taille comparable √† la fen√™tre du bloc carr√© du concepteur. <br><br><img src="https://habrastorage.org/webt/f8/wj/kv/f8wjkvhcyj5zvrzyp81xb0zslu4.jpeg"><br><br>  Pour contr√¥ler la matrice LED, une seule broche du microcontr√¥leur suffit, donc m√™me l'arduino nano ressemble √† un buste (en plus, il ne rentrera pas dans le bo√Ætier).  Mais le clone digispark sur le contr√¥leur ATTiny85 s'est av√©r√© √™tre juste - il n'a pas beaucoup de m√©moire et de broches, mais plus que suffisant pour le clignotant LED.  Le module s'int√®gre parfaitement avec l'IDE Arduino et dispose d'un chargeur de d√©marrage USB √† bord, donc la programmation de ce module est tr√®s simple et confortable.  J'ai longtemps voulu l'essayer. <br><br>  Commenc√© avec le sch√©ma le plus simple. <br><br><img src="https://habrastorage.org/webt/-8/yx/5b/-8yx5b02f2dxtqaps1tw6aoj_io.png"><br><br>  Sous cette forme, il a √©t√© possible de d√©boguer rapidement tous les algorithmes de lueur / clignotement (√† leur sujet ci-dessous).  Mais un jouet filaire n'est pas le cas - vous devez penser √† la puissance de la batterie.  De plus, afin de ne pas faire faillite sur les piles √† doigts (qui d'ailleurs ne rentrent pas dans l'enveloppe), il a √©t√© d√©cid√© d'utiliser du lithium.  Et comme il existe une batterie au lithium, vous devez r√©fl√©chir √† la mani√®re de la charger.  Dans les poubelles, nous venons de trouver un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contr√¥leur de charge ¬´populaire¬ª sur la puce TP4056</a> achet√©e √† l'occasion. <br><br>  Mais cela n'a pas fonctionn√© tout de suite.  Le circuit du module Digispark ATTiny85 n'est pas tr√®s con√ßu pour cela - il y a soit une alimentation USB, mais ensuite l'alimentation est fournie directement au microcontr√¥leur (via le bus +5), ou √† partir de l'entr√©e VIN, mais ensuite l'alimentation passe par le stabilisateur lin√©aire 7805. Option lorsque le module de charge au lithium ins√©r√© dans l'espace entre le connecteur USB et le microcontr√¥leur n'est pas fourni.  J'ai d√ª modifier un peu le circuit et supprimer les d√©tails suppl√©mentaires. <br><br><img src="https://habrastorage.org/webt/99/ta/ab/99taabsud7cdoakqixa8ah4ee0y.png"><br><br>  Ainsi, l'alimentation USB est maintenant fournie √† la broche VIN, puis passe √† l'entr√©e du chargeur.  La sortie du chargeur (en fait, la batterie est connect√©e directement) revient dans la carte via le pied 5V.  Et bien qu'il y ait en fait de 3 √† 4,2 V (tension de la batterie), cela est tout √† fait normal - la plage de tension de fonctionnement du microcontr√¥leur est de 1,8 √† 5,5 V.  Et m√™me le module LED fonctionne normalement √† partir de 2,7 V, bien qu'en dessous de 3,2 V, la LED bleue manque un peu et les couleurs ¬´flottent¬ª un peu en jaune. <br><br>  Afin d'√©conomiser de l'√©nergie, la LED D2 toujours allum√©e a √©galement disparu.  Le sch√©ma g√©n√©ral ressemble maintenant √† ceci <br><br><img src="https://habrastorage.org/webt/pr/d_/fq/prd_fqhsjwulccuuw-1aissl52k.png"><br><br>  Il serait possible d'alimenter le circuit via le connecteur USB du chargeur, mais la possibilit√© de t√©l√©charger le firmware via le connecteur USB de la carte contr√¥leur serait perdue.  Il serait possible de laisser deux connecteurs USB √† des fins diverses - l'un pour la charge, l'autre pour le firmware, mais c'est en quelque sorte faux. <br><br>  J'ai achet√© une batterie de taille 6x25x35 sur ebay, mais elle s'est av√©r√©e soit d√©fectueuse, soit je l'ai tu√©e avec un court-circuit ou un courant de charge important (par d√©faut, le courant de charge est r√©gl√© sur 1A et vous devez souder une r√©sistance pour r√©duire le courant).  Dans tous les cas, lorsque la charge √©tait connect√©e, m√™me √† 10 mA, la tension sur la batterie est tomb√©e √† 1V.  Au moment des tests, je suis pass√© √† une batterie LiPo √† moiti√© morte d'un petit quadricopt√®re.  Un peu plus tard, j'ai command√© la batterie √† un autre vendeur et elle s'est av√©r√©e bonne. <br><br>  En principe, il serait possible de s'arr√™ter √† cela, de souder les fils de connexion et de pousser doucement tout dans une sorte de bo√Ætier, mais j'ai d√©cid√© de mesurer la consommation du circuit.  Et puis j'ai pleur√©.  Eh bien, en √©tat de marche (lorsque les ampoules brillent au maximum), cette chose mange jusqu'√† 130mA, donc au repos, la consommation est sup√©rieure √† 25mA!  C'est-√†-dire  ce clignotant mange ma batterie 600mAh en moins d'une journ√©e! <br><br>  Il s'est av√©r√© qu'environ 10 mA consomment des LED.  M√™me s'ils ne s'allument pas, un microcontr√¥leur fonctionne toujours dans chacun d'eux et attend une commande.  C'est-√†-dire  Vous devez trouver un circuit de mise hors tension pour les LED. <br><br>  Les 15 mA restants sont consomm√©s par le microcontr√¥leur.  Oui, il peut √™tre mis au lit et selon la fiche technique, la consommation sera mesur√©e par des microamp√®res, mais en fait il n'a pas √©t√© possible d'obtenir moins de 1 mA.  J'ai √©teint l'ADC et traduit les broches en entr√©e.  Il semble que quelque part dans le circuit il y ait une sorte de fuite, mais ma modeste connaissance de l'√©lectronique ne suffit pas pour la trouver et la comprendre. <br><br><h2>  Nous compliquons le sch√©ma </h2><br>  Ensuite, je me suis souvenu d'avoir achet√© une puce PT1502 pour un test.  Cette puce est un contr√¥leur de charge de batterie au lithium complet avec une alimentation avec plusieurs entr√©es de contr√¥le.  La seule difficult√© est que le microcircuit est livr√© dans un bo√Ætier QFN20 4x4 mm et n√©cessite un cerclage.  Souder cela √† la maison est difficile, mais possible.  Les frais sont difficiles pour un LUT r√©gulier et doivent √™tre command√©s aupr√®s des Chinois.  Mais nous n'avons pas peur des difficult√©s, non? <br><br>  Dans plusieurs encadr√©s, le sch√©ma peut √™tre d√©crit comme suit. <br><br><img src="https://habrastorage.org/webt/t9/c5/rg/t9c5rgauskpsz1momglwordnf0o.png"><br><br>  √Ä l'√©tat √©teint, le contr√¥leur et les voyants ne sont pas aliment√©s.  L'appareil dispose d'un bouton `` Power '' qui allume le clignotant (il change √©galement de mode).  La LED brille, disons, une minute, et s'il n'y a pas d'activit√© de l'utilisateur (personne n'appuie sur un bouton), l'appareil s'√©teint.  C'est-√†-dire  Il ne va pas simplement s'endormir, mais il se coupe automatiquement par le signal Power Hold.  Et il √©teint tout √† la fois - √† la fois le microcontr√¥leur et les LED.  La fonctionnalit√© de mise sous tension et hors tension est impl√©ment√©e √† l'int√©rieur de la puce PT1502 <br><br>  Il ne reste plus qu'√† dessiner un sch√©ma de circuit et √† faire un circuit imprim√©.  Les circuits sont, pour la plupart, li√©s √† la fiche technique PT1502, ainsi qu'au module Digispark ATTiny85.  Le microcircuit du contr√¥leur de puissance PT1502 est fonctionnellement divis√© en plusieurs parties, il est donc divis√© en blocs dans le circuit. <br><br><img src="https://habrastorage.org/webt/fc/s6/qu/fcs6qu4zqgfja5p4hjacywrds8k.png"><br><br>  Il s'agit en fait d'un contr√¥leur de charge de batterie au lithium avec son propre faisceau.  La LED1 indique l'√©tat de charge - allum√©e, puis la charge est allum√©e.  La r√©sistance R6 r√®gle le courant de charge √† 470mA.  Puisque j'ai une batterie de 600mAh, en principe, vous pouvez augmenter le courant et mettre une r√©sistance √† 780-800 Ohms jusqu'√† 600mA.  Cependant, je ne suis pas s√ªr de la qualit√© sp√©ciale de ma batterie - il vaut mieux charger plus lentement, mais cela durera plus longtemps. <br><br>  Envisagez un plan d'alimentation <br><br><img src="https://habrastorage.org/webt/z1/rb/_a/z1rb_a2zu2a95pvxzk629o1tsjm.png"><br><br>  Le bouton SW1 d√©marre tout le syst√®me - la puce PT1502 se r√©veille puis d√©marre toutes les sources d'alimentation (dont elle en a 3).  Lorsque l'alimentation est install√©e, le microcircuit d√©marre le microcontr√¥leur en lib√©rant le signal RESET.  Pour faciliter le d√©bogage, j'ai √©galement ajout√© un bouton de r√©initialisation distinct. <br><br>  Le signal HOLD est utilis√© pour √©teindre l'ensemble du syst√®me.  Lorsque le microcontr√¥leur d√©marre, il doit r√©gler l'unit√© sur cette ligne.  Lorsqu'il est temps d'arrondir, le microcontr√¥leur met √† z√©ro sur la ligne HOLD et la puce d'alimentation PT1502 arr√™te toutes les sources d'alimentation. <br><br>  Il serait possible de suivre la charge faible de la batterie en utilisant la sortie BAT_LOW, mais dans cet article, je l'ai not√© - vous n'avez pas besoin d'enregistrer de donn√©es et rien n'explosera si vous ne remarquez pas une batterie morte √† temps.  Meurt tellement meurt.  Mais juste au cas o√π, le conseil d'administration a fourni le contact pour cette entreprise. <br><br>  Revenons au bouton SW1 pendant une seconde.  J'ai d√©cid√© de ne pas faire 2 boutons s√©par√©s pour allumer et contr√¥ler.  Par cons√©quent, le m√™me bouton est √©galement connect√© √† l'ATTiny85 et pendant le fonctionnement, il commute les modes de clignotement.  Les valeurs du diviseur R7-R8 sont s√©lectionn√©es de mani√®re √† ne pas br√ªler le port du microcontr√¥leur PB2.  Pour toutes les plages de tension de batterie (3,3 - 4,2 V), la tension sera fournie au pied du contr√¥leur dans les limites sp√©cifi√©es de la fiche technique (0,7 * VCC - VCC + 0,5 V) <br><br>  Consid√©rez une source d'alimentation <br><br><img src="https://habrastorage.org/webt/u1/3q/kf/u13qkfyn6g7gffo_qb8j9licy4w.png"><br><br>  Il s'agit d'un convertisseur DC-DC puls√©.  La tension de sortie est r√©gl√©e par les r√©sistances R10-R11 et, selon la formule de la fiche technique, est r√©gl√©e sur 3,3 V.  Tout le reste est un simple cerclage. <br><br>  Pour de bon, une telle source d'alimentation tromp√©e n'est pas vraiment n√©cessaire - il serait possible d'alimenter le microcontr√¥leur en g√©n√©ral directement √† partir de la batterie.  C'est juste que cette source est d√©j√† impl√©ment√©e dans la puce PT1502 et qu'elle peut s'allumer / s'√©teindre lorsque nous en avons besoin - pourquoi ne pas l'utiliser? <br><br><img src="https://habrastorage.org/webt/ad/8w/0z/ad8w0zewrcux0hdetprifertqss.png"><br><br>  La puce poss√®de √©galement 2 stabilisateurs lin√©aires, mais je ne les utiliserai pas.  Malheureusement, comme il s'est av√©r√©, il est toujours n√©cessaire de fournir la tension d'entr√©e √† cette source, sinon le microcircuit pense que la puissance n'est pas encore suffisamment stable et ne d√©marre pas le microcontr√¥leur (cette connaissance m'a √©t√© donn√©e par une semaine de soudure de la carte de test dans les deux sens - je ne pouvais pas comprendre pourquoi cela ne fonctionnait pas) ) <br><br>  Passons √† la partie logique. <br><br><img src="https://habrastorage.org/webt/sq/su/xj/sqsuxjeblb7507pz8ej2h1t3yui.png"><br><br>  Le c√¢ble USB est rod√© de la carte Digispark inchang√©.  Cela est n√©cessaire pour coordonner la tension USB (qui fonctionne √† 3,3 V) et les signaux du microcontr√¥leur (qui, dans l'original, est aliment√© par 5 V).  √âtant donn√© que dans mon cas, le microcontr√¥leur est √©galement aliment√© par 3,3 V, le circuit pourrait √™tre simplifi√©, mais juste au cas o√π, j'ai divorc√© du circuit d'origine sur la carte. <br><br><img src="https://habrastorage.org/webt/qe/q8/xr/qeq8xr1bwr-ux0jnsk5na1p6eaw.png"><br><br>  Il n'y a rien d'int√©ressant dans la liaison du microcontr√¥leur. <br><br>  La touche finale est le connecteur <br><br><img src="https://habrastorage.org/webt/ic/vt/ey/icvtey-cwulcyqozyphkmglv-0m.png"><br><br>  En fait, je me suis procur√© une telle carte de d√©bogage sur ATTiny85 avec prise en charge USB et un contr√¥leur d'alimentation avec une batterie au lithium.  Par cons√©quent, je ne me suis pas limit√© √† la sortie de la ligne sur la LED.  Au lieu de cela, j'ai apport√© toutes les lignes du microcontr√¥leur au peigne - en m√™me temps, il est pratique de se connecter au programmateur. <br><br>  Et que presque toutes les lignes soient li√©es de mani√®re rigide √† une certaine fonctionnalit√© (PB1 - Ligne de maintien, PB2 - bouton d'alimentation, PB3 / PB4 - USB, PB5 - R√©initialisation) √† l'avenir, il sera possible de contourner certaines limites.  Par exemple, ne soudez pas le c√¢ble USB et ne lib√©rez pas les lignes PB3 / PB4.  Ou, par exemple, refusez une r√©initialisation et rel√¢chez PB5.  En attendant, seul PB0 reste libre - et connectez-y notre LED. <br><br>  Nous passons au conseil d'administration.  √âtant donn√© les limites de la taille de la carte en 40x40 mm, le nombre de composants et le bo√Ætier QFN20 de la puce PT1502, je n'ai m√™me pas envisag√© la fabrication de la carte √† la maison.  Par cons√©quent, j'ai imm√©diatement commenc√© √† reproduire la planche √† deux couches la plus compacte.  Voil√† ce que j'ai <br><br><img src="https://habrastorage.org/webt/yt/6q/wh/yt6qwhfd9zkia64yyejpjx9litu.png"><br><br>  Pour la facilit√© d'utilisation, au verso j'ai sign√© toutes les fonctions de sortie possibles (j'ai eu l'id√©e de la carte Digispark) <br><br><img src="https://habrastorage.org/webt/q-/on/8t/q-on8tdmxq_bvht8egr5ilipb4s.png"><br><br>  J'ai command√© la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">carte</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JLCPCB</a> .  Pour √™tre honn√™te, je ne suis pas tr√®s satisfait de la qualit√© - si vous soudez la puce plusieurs fois, le masque pr√®s des petits contacts du PT1502 est un peu trouble.  Eh bien, de petites inscriptions flottaient un peu.  Cependant, si tout est soud√© la premi√®re fois, alors les normes. <br><br>  Pour souder QFN20, vous avez besoin d'un fer √† souder, tout le reste peut √™tre soud√© avec un certain fer √† souder avec une certaine comp√©tence.  Voici √† quoi ressemble la carte soud√©e <br><br><img src="https://habrastorage.org/webt/ct/km/4g/ctkm4gs_myfjjfeoukwn4ijuuc4.jpeg"><br><br><h2>  Logement </h2><br>  Il est temps de passer √† la coque.  Je l'ai imprim√© sur une imprimante 3D.  Conception sans fioritures - bo√Æte et bouton.  Des crochets sp√©ciaux sont fournis sur la bo√Æte pour installer la luciole dans le module carr√© standard du concepteur. <br><br><img src="https://habrastorage.org/webt/g9/bz/yd/g9bzydcnm7bwonoo6rhe-1hby7k.png"><br><br>  La carte principale et la batterie vivent dans le bo√Ætier. <br><br><img src="https://habrastorage.org/webt/zp/4u/x-/zp4ux-vaqurrmg9yqe3jb3jkry8.jpeg"><br><br><img src="https://habrastorage.org/webt/4f/oa/dw/4foadwyytzwav_lfiyvqrl5lcxs.jpeg"><br><br>  Le panneau LED est mont√© sur le couvercle, qui √† son tour est viss√© sur la bo√Æte principale avec des vis <br><br>  Au d√©but, j'ai pens√© √† visser le panneau LED au couvercle avec des vis, mais √† la fin je l'ai simplement coll√© sur un ruban adh√©sif double face.  Il s'est av√©r√© comme √ßa <br><br><img src="https://habrastorage.org/webt/vy/ks/y2/vyksy2ccuvrwcrjmxgvzolhlia0.jpeg"><br><br>  Sous cette forme, l'appareil peut d√©j√† √™tre utilis√©, mais il a toujours l'air laid - il n'y a pas assez de diffuseur. <br><br>  J'ai essay√© de faire la premi√®re version du diffuseur en utilisant la technologie de r√©tr√©cissement des bouteilles en PET avec un s√®che-cheveux de construction (aper√ßu des mod√®les d'avion). <br><br>  Donc, vous avez d'abord besoin d'un blanc.  Je l'ai fabriqu√© √† partir de gypse, que j'ai vers√© sous une forme que j'ai imprim√©e sur une imprimante 3D.  Dans la premi√®re version, la forme √©tait monobloc et je n'ai jamais pu en retirer le disque moul√©.  Par cons√©quent, j'ai d√ª cr√©er un formulaire en deux parties. <br><br><img src="https://habrastorage.org/webt/gb/x0/0i/gbx00iokd8ea_lfquvmbbfebed4.jpeg"><br><br>  L'id√©e de la m√©thode est la suivante.  Vous mettez une bouteille de yaourt pour b√©b√© sur un blanc et vous l‚Äôassoyez avec un s√®che-cheveux de construction.  Voici juste le rapatriement de 20 r√©cipients diff√©rents sous un lait diff√©rent. Je n'ai jamais r√©ussi √† mettre cette chose joliment, sans plis ni bulles.  Apparemment, vous devez cl√¥turer une sorte d'installation sous vide et asseoir une feuille de plastique.  En g√©n√©ral, cela s'est av√©r√© trop difficile pour un tel engin. <br><br>  Apr√®s avoir grommel√© √† travers les gophers, j'ai trouv√© une paire de m√®tres de sonde en plastique transparent Verbatim PET.  J'ai d√©cid√© d'essayer le diffuseur juste pour imprimer.  Et bien qu'√† l'entr√©e de l'imprimante, le plastique semble limpide, la vraie partie est terne.  Cela est probablement d√ª √† la structure interne, comme  les calques ne remplissent pas compl√®tement le volume mais se chevauchent avec des lacunes et des lacunes.  De plus, si vous essayez de traiter la pi√®ce avec du papier de verre pour une surface plus lisse, nous obtenons encore plus de nattes.  Cependant, c'est exactement ce dont j'avais besoin. <br><br>  J'√©tais trop paresseux pour me soucier du support pour le diffuseur, alors je l'ai ajout√© √† la colle chaude.  Donc, ma conception est maintenant conditionnellement pliable.  Je pourrais √™tre confondu avec l'invention d'une sorte de loquets, mais j'ai d√©j√† manqu√© de sonde en plastique transparent.  Alors laissez-le fondre. <br><br><img src="https://habrastorage.org/webt/xb/vy/49/xbvy49czm3mqdgjrexvvrcsm25m.jpeg"><br><br><img src="https://habrastorage.org/webt/fz/tx/tx/fztxtxljbgq0uwqnhlne0-mvcdc.jpeg"><br><br><h2>  Firmware </h2><br>  Pour les clignotants LED, vous n'avez pas besoin de plonger particuli√®rement dans la p√©riph√©rie du microcontr√¥leur - quelques fonctions pour travailler avec GPIO suffisent.  Mais puisque le module est ancr√© √† la plate-forme Arduino, alors pourquoi ne pas en profiter? <br><br>  Tout d'abord, quelques d√©finitions et constantes <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Number of total LEDs on the board. Mine has 4x4 LEDs #define NUM_HW_PIXELS 16 // Pin number where LED data pin is attached #define DATA_PIN 0 // Pin number where mode switch button is attached #define BUTTON_PIN 2 // Power Enabled pin #define POWER_EN_PIN 1 // Max brightness (dimming the light for debugging) #define MAX_VAL 255</span></span></code> </pre> <br>  Cela d√©termine le nombre de pixels dans ma matrice, les num√©ros de broches et la luminosit√© maximale des LED (lors du d√©bogage, il √©tait pratique de le r√©gler √† 50 afin qu'il ne me aveugle pas les yeux) <br><br>  Les LED de ma matrice sont dispos√©es d'une mani√®re plut√¥t non √©vidente - un zigzag.  Par cons√©quent, pour diff√©rents effets, j'ai d√ª renum√©roter. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// LED indexes for different patterns uint8_t circleLEDIndexes[] = {0, 1, 2, 3, 4, 11, 12, 13, 14, 15, 8, 7}; uint8_t beaconLEDIndexes[] = {6, 5, 10, 9}; uint8_t policeLEDIndexes[] = {7, 6, 10, 11, 4, 5, 9, 8};</span></span></code> </pre> <br>  Pour contr√¥ler les LED, je n'ai pas r√©invent√© la roue et j'ai pris une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®que pr√™te √† l'emploi pour travailler avec les LED WS8211</a> .  L'interface de la biblioth√®que est l√©g√®rement blanchie.  Certaines fonctions auxiliaires (par exemple, la conversion de HSV en RVB) sont √©galement rest√©es bloqu√©es. <br><br>  Tout d'abord, la carte et la biblioth√®que WS8211 doivent √™tre initialis√©es. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Driver Ai_WS2811 ws2811; void setup() { // Set up power pinMode(POWER_EN_PIN, OUTPUT); digitalWrite(POWER_EN_PIN, HIGH); // initialize LED data pin pinMode(LED_PIN, OUTPUT); // Initialize button pin pinMode(BUTTON_PIN, INPUT); // Initialize WS8211 library static CRGB ledsBuf[NUM_HW_PIXELS]; ws2811.init(DATA_PIN, NUM_HW_PIXELS, ledsBuf); // Set the watchdog timer to 2 sec wdt_enable(WDTO_2S); }</span></span></code> </pre> <br>  Tout d'abord, vous devez r√©gler le signal POWER HOLD sur l'unit√© - ce sera un signal √† la puce PT1502 que le microcontr√¥leur s'est enroul√© et fonctionne correctement.  Le microcircuit, √† son tour, fournira r√©guli√®rement de l'√©lectricit√© au microcontr√¥leur et aux DEL tant que le signal HOLD est r√©gl√© sur l'unit√©. <br><br>  Ensuite, les pieds pour contr√¥ler la LED sur la sortie et les boutons sur l'entr√©e sont configur√©s.  Apr√®s cela, vous pouvez initialiser la biblioth√®que WS8211. <br><br>  Comme il s'agit d'un appareil assez autonome, on ne peut pas permettre au microcontr√¥leur de rester dans un √©tat incompr√©hensible et d'avaler toute la batterie.  Pour ce faire, je lance la minuterie de surveillance pendant 2 secondes.  La minuterie red√©marrera dans la boucle de programme principale. <br><br>  Vous devez maintenant d√©finir quelques fonctions auxiliaires.  La biblioth√®que WS8211 stocke un tampon avec les valeurs de couleur de chaque LED.  Travailler directement avec le tampon n'est pas tr√®s pratique, car j'ai √©crit une fonction simple pour √©crire des valeurs RVB sur une LED sp√©cifique <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRgb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> g, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ CRGB * leds = ws2811.getRGBData(); leds[led_idx].r = r; leds[led_idx].g = g; leds[led_idx].b = b; }</code> </pre> <br>  Mais dans la plupart des cas, dans le mod√®le de couleurs RVB, le comptage des couleurs n'est pas tr√®s pratique, voire impossible.  Par exemple, lorsque vous dessinez tout type d'arc-en-ciel, il est plus pratique de travailler avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le mod√®le de couleur HSV</a> .  La couleur de chaque pixel est d√©finie par la valeur du ton de couleur et de la luminosit√©.  La saturation est omise pour plus de simplicit√© (le maximum est utilis√©).  Les valeurs de teinte sont r√©duites √† une plage de 0 √† 255 (au lieu de la norme de 0 √† 359). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * HVS to RGB conversion (simplified to the range 0-255) **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> brightness)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//this is the algorithm to convert from RGB to HSV double r = 0; double g = 0; double b = 0; double hf = hue/42.6; // Not /60 as range is _not_ 0-360 int i=(int)floor(hue/42.6); double f = hue/42.6 - i; double qv = 1 - f; double tv = f; switch (i) { case 0: r = 1; g = tv; break; case 1: r = qv; g = 1; break; case 2: g = 1; b = tv; break; case 3: g = qv; b = 1; break; case 4: r = tv; b = 1; break; case 5: r = 1; b = qv; break; } brightness = constrain(brightness, 0, MAX_VAL); setRgb(led_idx, constrain(brightness*r, 0, MAX_VAL), constrain(brightness*g, 0, MAX_VAL), constrain(brightness*b, 0, MAX_VAL) ); }</span></span></code> </pre><br>  La fonction est tir√©e de la biblioth√®que Ai_WS8211 et l√©g√®rement archiv√©e.  Dans la version originale de cette fonction de la biblioth√®que, il y avait quelques bugs √† cause desquels la couleur sur les arcs-en-ciel montrait avec des secousses. <br><br>  Passons √† l'impl√©mentation de divers effets.  Chaque fonction est appel√©e √† partir de la boucle principale pour dessiner un ¬´cadre¬ª.  √âtant donn√© que chaque effet fonctionne avec diff√©rents param√®tres entre les appels, ils sont stock√©s dans des variables statiques. <br><br>  C'est l'effet le plus simple - toutes les LED sont remplies d'une seule couleur, qui change en douceur. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> hue = <span class="hljs-number"><span class="hljs-number">0</span></span>; hue++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, hue, MAX_VAL); ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  L'effet suivant est plus int√©ressant - il affiche un arc-en-ciel le long du contour de la matrice, et les couleurs de l'arc-en-ciel se d√©placent progressivement dans un cercle. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slidingRainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hue = (pos + led*<span class="hljs-number"><span class="hljs-number">256</span></span>/ARRAY_SIZE(circleLEDIndexes)) % <span class="hljs-number"><span class="hljs-number">256</span></span>; setHue(circleLEDIndexes[led], hue, MAX_VAL); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br>  Et cet effet remplit toute la matrice d'une couleur al√©atoire, qui s'allume d'abord en douceur, puis s'√©teint √©galement en douceur. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomColorsFadeInOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> color = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !goesUp) { color = rand() % <span class="hljs-number"><span class="hljs-number">256</span></span>; goesUp = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == MAX_VAL &amp;&amp; goesUp) { goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, color, curLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(goesUp) curLevel++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> curLevel--; ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre><br>  Le groupe d'effets suivant dessine diff√©rentes balises clignotantes.  Ainsi, par exemple, un enfant aime construire un bulldozer avec des aimants et un clignotant orange y sera tr√®s utile. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orangeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ORANGE_HUE = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos+=<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(circleLEDIndexes), <span class="hljs-number"><span class="hljs-number">70</span></span>); setHue(circleLEDIndexes[led], ORANGE_HUE, brightness); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Techniquement, l'effet ressemble √† un point brillant qui se d√©place le long de la matrice.  Mais pour la rendre belle, les LED voisines s'estompent progressivement √† mesure que vous vous √©loignez du point principal.  Par cons√©quent, j'avais besoin d'une fonction qui calcule cette m√™me luminosit√©. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brightnessByPos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ledPos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(pos - ledPos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(diff &gt; <span class="hljs-number"><span class="hljs-number">127</span></span>) diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>-diff); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = MAX_VAL - constrain(MAX_VAL*diff/delta, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brightness; }</code> </pre><br>  Pos est une certaine position conditionnelle du point lumineux de luminosit√©, mapp√©e sur une plage de bouclage de 0 √† 255.  ledPos est la position de la LED (affich√©e sur la m√™me plage) dont vous devez calculer la luminosit√©.  Si la diff√©rence de position est sup√©rieure √† delta, la LED ne s'allume pas et plus la position est proche, plus elle brille. <br><br>  Ou, par exemple, une lumi√®re clignotante rouge-bleu de la police <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">policeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RED_HUE = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BLUE_HUE = <span class="hljs-number"><span class="hljs-number">170</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(policeLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ledPos = led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(policeLEDIndexes); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], RED_HUE, brightness); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(brightness == <span class="hljs-number"><span class="hljs-number">0</span></span>) { brightness = brightnessByPos((pos+<span class="hljs-number"><span class="hljs-number">100</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], BLUE_HUE, brightness); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Puisque nous parlons de voitures, le feu de circulation n'est pas un probl√®me √† mettre en place. <br><br>  Ce sont des fonctions qui incluent divers feux de circulation √† diff√©rentes positions. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearPixels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;NUM_HW_PIXELS; i++) { setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) setRgb(i, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yellowTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">4</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; i++) setRgb(i, MAX_VAL, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greenTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">8</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; i++) setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); }</code> </pre> <br>  Il est temps de le faire revivre.  Le feu de circulation fonctionne selon un programme sp√©cial d√©fini dans une sorte de bytecode.  La plaque d√©crit le mode et la dur√©e pendant laquelle ce mode doit √™tre activ√©. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TRAFFIC_LIGHTS { NONE, RED, YELLOW, GREEN }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trafficLightState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> state; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> duration; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> trafficLightState trafficLightStates[] = { {NONE, <span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// clear yellow {RED, 7000}, // red {YELLOW, 2000}, // red + yellow {NONE, 1}, // clear red+yellow {GREEN, 7000}, // green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 1}, // clear green {YELLOW, 2000}, // yellow };</span></span></code> </pre> <br>  En fait, la fonction qui traite tout <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curStateIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> curStateTimeStamp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Switch to a new state when time comes if(millis() - curStateTimeStamp &gt; (unsigned long)trafficLightStates[curStateIdx].duration) { curStateIdx++; curStateIdx %= ARRAY_SIZE(trafficLightStates); curStateTimeStamp = millis(); } switch(trafficLightStates[curStateIdx].state) { case NONE: clearPixels(); ws2811.sendLedData(); break; case RED: redTrafficLights(); break; case YELLOW: yellowTrafficLights(); break; case GREEN: greenTrafficLights(); break; default: break; } // Just waiting delay(10); }</span></span></code> </pre><br>  Apr√®s avoir atteint l'intervalle de temps sp√©cifi√©, le prochain mode de feu de circulation est allum√© et le compte √† rebours recommence. <br><br>  Le dernier effet sur lequel mon imagination √©tait suffisante, ce sont les ast√©risques.  5 LED al√©atoires s'allument √† une luminosit√© al√©atoire, puis s'√©teignent en douceur.  Si une √©toile s'√©teint, une autre dans un endroit al√©atoire s'allume. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> numleds = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ledIndexes[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> maxVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;numleds; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ledIndexes[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = rand() % (NUM_HW_PIXELS+<span class="hljs-number"><span class="hljs-number">1</span></span>); CRGB * leds = ws2811.getRGBData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(leds[led].r == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ledIndexes[i] = led; maxVal[i] = rand() % (MAX_VAL<span class="hljs-number"><span class="hljs-number">-1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; curVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = ledIndexes[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] &lt; maxVal[i]) curVal[i]++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == maxVal[i]) maxVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span> || --curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) ledIndexes[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; setRgb(led<span class="hljs-number"><span class="hljs-number">-1</span></span>, curVal[i], curVal[i], curVal[i]); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  Quelque part ici, un insecte mal√©fique s'est introduit.  Parfois, les √©toiles s'illuminent fortement, ou vice versa s'√©teignent brusquement.  Mais pour √™tre honn√™te, j'√©tais trop paresseux pour le comprendre - cela semble tout √† fait normal. <br><br>  Il est temps de penser √† √©conomiser la batterie.  J'ai d√©j√† donn√© les valeurs de consommation de tout cela.  Si vous ne pensez pas √† couper l'alimentation, les LED mangeront la batterie en quelques heures.  Cette fonction est responsable de la mise hors tension apr√®s 90 secondes d'inactivit√©.  Au d√©part, c'√©tait 60 secondes, mais avec un vrai jeu, cela ne suffisait pas et 2 minutes √©taient en quelque sorte longues. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutdownOnTimeOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resetTimer = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(periodStartTime == <span class="hljs-number"><span class="hljs-number">0</span></span> || resetTimer) { periodStartTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(millis() - periodStartTime &gt;= <span class="hljs-number"><span class="hljs-number">90000U</span></span>L) { periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; shutDown(); } }</code> </pre> <br>  En fait, la mise hors tension se produit comme suit. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clearPixels(); ws2811.sendLedData(); wdt_disable(); digitalWrite(POWER_EN_PIN, LOW); <span class="hljs-comment"><span class="hljs-comment">// No power after this point while(true) ; }</span></span></code> </pre> <br>  Si l'utilisateur appuie sur les boutons, la minuterie est r√©initialis√©e.  Une fois le temps d√©fini √©coul√©, la fonction remet le signal HOLD √† z√©ro, ce qui correspond √† une commande PT1502 pour couper l'alimentation.  Le chien de garde, en passant, doit √©galement √™tre arr√™t√©, sinon apr√®s 2 secondes, il r√©veillera le syst√®me et remettra sous tension. <br><br>  Enfin, la boucle principale qui d√©marre tout <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// List of pointers to functions that serve different modes void (*Modes[])() = { rainbow, slidingRainbow, orangeBeacon, policeBeacon, trafficLights, stars, randomColorsFadeInOut }; void loop() { static uint8_t mode = eeprom_read_byte( (uint8_t*) 10 ); static bool waitingForBtnUp = false; static long btnPressTimeStamp; // Button switches mode if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; !waitingForBtnUp) { delay(20); if(digitalRead(BUTTON_PIN) == HIGH) { mode++; mode %= ARRAY_SIZE(Modes); // num modes clearPixels(); ws2811.sendLedData(); delay(1); eeprom_write_byte( (uint8_t*) 10, mode ); waitingForBtnUp = true; btnPressTimeStamp = millis(); shutdownOnTimeOut(true); } } // Shut down on long press over 5s if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; waitingForBtnUp &amp;&amp; millis() - btnPressTimeStamp &gt; 5000) shutDown(); // Detect button release if(digitalRead(BUTTON_PIN) == LOW &amp;&amp; waitingForBtnUp) waitingForBtnUp = false; // display LEDs according to current mode Modes[mode](); // pong shutdown timer shutdownOnTimeOut(); // Yes, we still alive wdt_reset(); }</span></span></code> </pre><br>  Appuyez sur le bouton pour changer de mode et r√©initialiser la minuterie d'arr√™t automatique.  Selon le mode actuel, l'une des fonctions d'effet de la liste Modes est lanc√©e.  √Ä chaque cycle, le chien de garde est √©galement r√©initialis√©. <br><br>  Si un enfant, par exemple, jouait dans une voiture de police et qu'apr√®s 1,5 minute le voyant d'urgence s'est √©teint, il est fort probable qu'apr√®s un deuxi√®me allumage, le fils voudra continuer √† jouer dans la voiture de police.  Pour ce faire, le mode s√©lectionn√© est enregistr√© en EEPROM (la cellule num√©ro 10 est s√©lectionn√©e dans le bulldozer). <br><br>  Voici une vid√©o qui montre comment tout cela fonctionne. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5MLX1hc8Jz4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Bootloader </h2><br>  Presque tout est pr√™t.  Mais il y a encore une chose qui doit √™tre d√©pos√©e - un chargeur de d√©marrage.  Le fait est que le chargeur de d√©marrage standard ne nous convient pas. <br><br>  Tout d'abord, lorsque vous allumez l'appareil, il attend aussi longtemps que 6 secondes - peut-√™tre que le firmware commencera √† couler dedans.  Ce n'est qu'apr√®s le transfert de cette commande vers le firmware principal.  Ceci est pratique au stade du d√©veloppement, mais sera g√™nant pour le p√©riph√©rique fini. <br><br>  Et deuxi√®mement, le chargeur de d√©marrage standard ne sait rien de la puce PT1502, ce qui serait bien de donner un signal HOLD.  Sans ce signal, le microcircuit pense que le microcontr√¥leur n'a pas d√©marr√© ou, au contraire, veut s'√©teindre.  Et si c'est le cas, apr√®s quelques millisecondes, le PT1502 coupera l'alimentation de tout le circuit. <br><br>  L'avantage de r√©soudre les deux probl√®mes n'est pas difficile.  Le digispark ATTiny85 utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le chargeur de d√©marrage du micronoyau</a> .  Ce chargeur de d√©marrage est assez facile √† classer pour nos besoins.  Il suffit de corriger les d√©finitions correspondantes dans le fichier de configuration. <br><br>  Tout d'abord, j'ai copi√© la configuration standard du micrologiciel \ configuration \ t85_default dans mon propre r√©pertoire et y ai d√©j√† apport√© toutes les modifications.  Ce sera donc le cas pour lequel il est facile de revenir au chargeur de d√©marrage d'origine. <br><br>  Dans le fichier bootloaderconfig.h, vous avez le choix de la mani√®re d'entrer dans le chargeur de d√©marrage.  D'apr√®s ce qui est propos√©, rien ne nous convient, mais l'option la plus proche est ENTRY_JUMPER.  Dans cette option, le chargeur de d√©marrage n'est accessible que si un certain niveau appara√Æt sur une broche sp√©cifique (le cavalier est ferm√© sur la carte). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENTRYMODE ENTRY_JUMPER</span></span></code> </pre> <br>  Nous n'avons pas de cavalier, mais il y a un bouton au pied du PB2.  Laissez le chargeur de d√©marrage entrer si le bouton est maintenu enfonc√© pendant 5-7 secondes √† la mise sous tension.  Mais si enfonc√© et rel√¢ch√©, la transition vers le firmware principal se produit imm√©diatement. <br><br>  Nous devons d√©finir 3 fonctions - initialisation, d√©sinitialisation et v√©rifier s'il est temps d'entrer dans le chargeur de d√©marrage.  Dans l'original, ils sont tous simples et mis en ≈ìuvre avec des macros.  Seuls les 2 premiers seront simples <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOLD_PIN PB1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PIN PB2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PORT PORTB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_DDR DDRB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_INP PINB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderInit() {JUMPER_DDR &amp;= ~_BV(JUMPER_PIN); JUMPER_DDR |= _BV(HOLD_PIN); JUMPER_PORT &amp;= ~_BV(JUMPER_PIN); JUMPER_PORT |= _BV(HOLD_PIN); _delay_ms(1);} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderExit() {;}</span></span></code> </pre> <br>  bootLoaderInit () configure la broche du bouton (JUMPER_PIN) √† l'entr√©e et d√©sactive la suspension.  Nous avons d√©j√† un pull-up sur la planche, et au sol, et lorsque vous appuyez sur un bouton de la broche, au contraire, il y en aura un.  Dans le m√™me temps, vous pouvez imm√©diatement configurer le signal HOLD pour qu'il soit √©mis et r√©gler l'unit√© sur celui-ci ... <br><br>  Pour une explication de l'arithm√©tique des bits, par exemple, allez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , et une compr√©hension des registres de configuration GPIO dans les contr√¥leurs AVR peut √™tre glan√©e, par exemple, √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partir d'ici</a> . <br><br>  La fonction bootLoaderExit () est vide car  la configuration expos√©e est tout √† fait appropri√©e pour la transition ult√©rieure vers le firmware principal <br><br>  La fonction bootLoaderStartCondition (), qui est responsable de la saisie du chargeur de d√©marrage au format macro, n'a pas sa place et est donc devenue une fonction √† part enti√®re <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __ASSEMBLER__ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Bootloader condition is to hold the button for 5 seconds inline unsigned char bootLoaderStartCondition() { long int i; for(i=0; i&lt;10000000; i++) if( !(JUMPER_INP &amp; _BV(JUMPER_PIN))) return 0; return 1; } #endif</span></span></span></span></code> </pre> <br>  La fonction en quelques secondes (en fait environ 6-7) v√©rifie l'√©tat du bouton.  Si le bouton a √©t√© rel√¢ch√© plus t√¥t, nous n'avons pas besoin d'entrer dans le chargeur de d√©marrage.  Patient et persistant sont autoris√©s sur le chargeur de d√©marrage. <br><br>  Il s'est av√©r√© que le fichier bootloaderconfig.h est impliqu√© dans la compilation des fichiers assembleur et le code de ce fichier provoque des erreurs.  J'ai d√ª mettre la fonction dans le bloc #ifndef __ASSEMBLER__ <br><br>  Un autre param√®tre que j'ai modifi√© indique au chargeur de d√©marrage quoi faire s'il n'est pas connect√© √† l'USB - quittez apr√®s une seconde.  Le fait est que lors de l'effraction, le fils a souvent appuy√© sur le bouton et est accidentellement entr√© dans le chargeur de d√©marrage.  Je ne sais pas comment c'est miraculeux, mais si le chargeur de d√©marrage n'a pas vu la connexion USB, il pourrait accidentellement √©craser certaines pages de la m√©moire.  Par cons√©quent, s'il n'y a pas de connexion, nous quitterons simplement le programme principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Define bootloader timeout value. * * The bootloader will only time out if a user program was loaded. * * AUTO_EXIT_NO_USB_MS The bootloader will exit after this delay if no USB is connected. * Set to 0 to disable * Adds ~6 bytes. * (This will wait for an USB SE0 reset from the host) * * All values are approx. in milliseconds */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AUTO_EXIT_NO_USB_MS 1000</span></span></code> </pre> <br>  Nous compilons ... et nous obtenons une erreur indiquant que le code ne rentre pas dans l'espace du chargeur de d√©marrage qui lui est allou√©.  Comme la m√©moire flash dans le contr√¥leur est tr√®s petite, le chargeur de d√©marrage est serr√© au maximum afin de laisser plus d'espace pour le programme principal.  Mais cela est facilement r√©solu dans le fichier Makefile.inc en suivant les instructions. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hexadecimal address for bootloader section to begin. To calculate the best value: # - make clean; make main.hex; ### output will list data: 2124 (or something like that) # - for the size of your device (8kb = 1024 * 8 = 8192) subtract above value 2124... = 6068 # - How many pages in is that? 6068 / 64 (tiny85 page size in bytes) = 94.8125 # - round that down to 94 - our new bootloader address is 94 * 64 = 6016, in hex = 1780 BOOTLOADER_ADDRESS = 1940</span></span></code> </pre> <br>  Ensuite, je viens de r√©duire l'adresse de d√©marrage du chargeur de d√©marrage √† une page (64 octets), augmentant ainsi l'espace du chargeur de d√©marrage. <br><br>  Sinon, la compilation et le t√©l√©chargement du chargeur de d√©marrage √† l'aide du programmateur USBAsp n'√©taient pas un probl√®me. <br><br><h2>  Conclusion </h2><br>  C'√©tait un moyen tr√®s int√©ressant de passer d'un prototype sur une maquette √† un appareil fini.  Cela ressemble √† un clignotant ordinaire d'une le√ßon d'arduino, mais en fait, dans le processus de travail, j'ai d√ª r√©soudre tout un tas de probl√®mes int√©ressants - voici la lutte avec la consommation, le choix de la base de l'√©l√©ment et la conception de l'√©tui, et en pensant au firmware avec le chargeur de d√©marrage.  J'esp√®re sinc√®rement que mon exp√©rience sera utile √† quelqu'un. <br><br>  Cela aurait-il pu √™tre plus facile?  Bien s√ªr que vous le pouvez.  Je pense que tout pourrait √™tre fait avec un transistor.  Malheureusement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> j'ai lu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> apr√®s avoir soud√© la carte.  Je verrais l'article plus t√¥t - je ferais tout sur le m√™me TP4056 populaire - il est plus facile de le souder.  Quoi qu'il en soit, le convertisseur DC-DC, qui est √† l'int√©rieur du PT1502 dans cet appareil, pour de bon, n'est pas n√©cessaire.  Cependant, une √©tude pratique du microcircuit PT1502 m'est utile pour mon autre projet, ainsi que la capacit√© de souder des microcircuits dans le bo√Ætier QFN20. <br><br>  Enfin, voici les liens vers mon projet: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code du micrologiciel</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Circuit et carte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mod√®le de bo√Ætier et diffuseur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mod√®les STL pr√™ts pour l'impression</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435198/">https://habr.com/ru/post/fr435198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435184/index.html">L'intelligence artificielle apprise √† d√©tecter la maladie d'Alzheimer dans le cerveau 6 ans avant le diagnostic</a></li>
<li><a href="../fr435186/index.html">Rolls-Royce d√©veloppe l'avion √©lectrique le plus rapide du monde</a></li>
<li><a href="../fr435190/index.html">Google a r√©ussi √† se retirer de la taxe de 22,7 milliards de dollars via l'Irlande et les Bermudes</a></li>
<li><a href="../fr435194/index.html">Simplifiez la r√©daction du CV d'un d√©veloppeur</a></li>
<li><a href="../fr435196/index.html">Les chercheurs r√©ussissent ReCAPTCHA en utilisant les services Google</a></li>
<li><a href="../fr435202/index.html">Nous √©crivons notre langage de programmation, partie 1: nous √©crivons un langage VM</a></li>
<li><a href="../fr435204/index.html">R√©ception pour les d√©veloppeurs pour surmonter la procrastination</a></li>
<li><a href="../fr435206/index.html">L'Europe approuve la directive sur le droit d'auteur - pourquoi les plateformes de streaming s'opposent</a></li>
<li><a href="../fr435208/index.html">Internet des objets ... qui pleurent pour une bonne UI / UX</a></li>
<li><a href="../fr435210/index.html">Le travail de Xamarin avec le SDK C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>