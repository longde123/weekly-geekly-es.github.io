<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏼 ✒️ 💔 Arduin et LED, ou comment mettre à niveau le designer pour enfants ☦️ 💤 🙄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mon fils s'est fermement «accroché» au constructeur magnétique Magformers . Après avoir parcouru une série de Fixiks où le même constructeur était en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduin et LED, ou comment mettre à niveau le designer pour enfants</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435198/"><img src="https://habrastorage.org/webt/wp/c4/ox/wpc4oxeubxh_dsoa07dy5wfccoa.jpeg"><br><br>  Mon fils s'est fermement «accroché» au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constructeur magnétique Magformers</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Après</a> avoir parcouru une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">série de Fixiks où le même constructeur était en vedette, l'</a> enfant a demandé: «Papa, pourquoi les fixics ont-ils des détails qui brillent, mais pas nous?». <br><br>  Il s'est avéré qu'il y a vraiment un «Magformers Neon LED Set», où en plus des blocs de construction habituels, il y a aussi un élément avec une LED.  Étant donné qu'à cette époque, nous avions déjà rassemblé toute une boîte d'aimants de toutes les formes et tailles possibles (quant à moi, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">magformers chinois ne</a> sont pas inférieurs à l'original du tout), je ne voulais pas acheter un autre ensemble juste pour le plaisir d'une ampoule.  De plus, cet ensemble coûte beaucoup plus cher qu'un similaire sans rétro-éclairage. <br><br>  Ayant estimé qu'il n'y avait que quelques dollars dans les composants, dont la plupart étaient déjà en place, j'ai décidé de récupérer ma morgulka.  Oui, et avec des effets que l'original n'avait pas. <br><br>  Sous le chat, vous trouverez l'option d'un clignotant sur l'ATTiny85 et le panneau LED sur les LED WS8212.  Je vais parler des circuits, de la façon dont j'ai alimenté tout cela à partir de la batterie, ainsi que des problèmes évidents que j'ai ratissés en cours de route.  Je parlerai également en détail de la composante logicielle du projet. <br><a name="habracut"></a><br><h2>  Premiers pas </h2><br>  Il me semblait que la lueur sur une LED régulière (même RGB) est ennuyeuse et banale.  Mais ressentir quelque chose comme WS8212 semblait intéressant.  Sur ebee, des LED individuelles et des matrices jusqu'à 16x16 ont été proposées.  Après avoir acheté plusieurs modules différents, j'ai opté pour une matrice 4x4.  Il y a beaucoup de LED pour se livrer à divers effets visuels, tandis que le module est de taille comparable à la fenêtre du bloc carré du concepteur. <br><br><img src="https://habrastorage.org/webt/f8/wj/kv/f8wjkvhcyj5zvrzyp81xb0zslu4.jpeg"><br><br>  Pour contrôler la matrice LED, une seule broche du microcontrôleur suffit, donc même l'arduino nano ressemble à un buste (en plus, il ne rentrera pas dans le boîtier).  Mais le clone digispark sur le contrôleur ATTiny85 s'est avéré être juste - il n'a pas beaucoup de mémoire et de broches, mais plus que suffisant pour le clignotant LED.  Le module s'intègre parfaitement avec l'IDE Arduino et dispose d'un chargeur de démarrage USB à bord, donc la programmation de ce module est très simple et confortable.  J'ai longtemps voulu l'essayer. <br><br>  Commencé avec le schéma le plus simple. <br><br><img src="https://habrastorage.org/webt/-8/yx/5b/-8yx5b02f2dxtqaps1tw6aoj_io.png"><br><br>  Sous cette forme, il a été possible de déboguer rapidement tous les algorithmes de lueur / clignotement (à leur sujet ci-dessous).  Mais un jouet filaire n'est pas le cas - vous devez penser à la puissance de la batterie.  De plus, afin de ne pas faire faillite sur les piles à doigts (qui d'ailleurs ne rentrent pas dans l'enveloppe), il a été décidé d'utiliser du lithium.  Et comme il existe une batterie au lithium, vous devez réfléchir à la manière de la charger.  Dans les poubelles, nous venons de trouver un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôleur de charge «populaire» sur la puce TP4056</a> achetée à l'occasion. <br><br>  Mais cela n'a pas fonctionné tout de suite.  Le circuit du module Digispark ATTiny85 n'est pas très conçu pour cela - il y a soit une alimentation USB, mais ensuite l'alimentation est fournie directement au microcontrôleur (via le bus +5), ou à partir de l'entrée VIN, mais ensuite l'alimentation passe par le stabilisateur linéaire 7805. Option lorsque le module de charge au lithium inséré dans l'espace entre le connecteur USB et le microcontrôleur n'est pas fourni.  J'ai dû modifier un peu le circuit et supprimer les détails supplémentaires. <br><br><img src="https://habrastorage.org/webt/99/ta/ab/99taabsud7cdoakqixa8ah4ee0y.png"><br><br>  Ainsi, l'alimentation USB est maintenant fournie à la broche VIN, puis passe à l'entrée du chargeur.  La sortie du chargeur (en fait, la batterie est connectée directement) revient dans la carte via le pied 5V.  Et bien qu'il y ait en fait de 3 à 4,2 V (tension de la batterie), cela est tout à fait normal - la plage de tension de fonctionnement du microcontrôleur est de 1,8 à 5,5 V.  Et même le module LED fonctionne normalement à partir de 2,7 V, bien qu'en dessous de 3,2 V, la LED bleue manque un peu et les couleurs «flottent» un peu en jaune. <br><br>  Afin d'économiser de l'énergie, la LED D2 toujours allumée a également disparu.  Le schéma général ressemble maintenant à ceci <br><br><img src="https://habrastorage.org/webt/pr/d_/fq/prd_fqhsjwulccuuw-1aissl52k.png"><br><br>  Il serait possible d'alimenter le circuit via le connecteur USB du chargeur, mais la possibilité de télécharger le firmware via le connecteur USB de la carte contrôleur serait perdue.  Il serait possible de laisser deux connecteurs USB à des fins diverses - l'un pour la charge, l'autre pour le firmware, mais c'est en quelque sorte faux. <br><br>  J'ai acheté une batterie de taille 6x25x35 sur ebay, mais elle s'est avérée soit défectueuse, soit je l'ai tuée avec un court-circuit ou un courant de charge important (par défaut, le courant de charge est réglé sur 1A et vous devez souder une résistance pour réduire le courant).  Dans tous les cas, lorsque la charge était connectée, même à 10 mA, la tension sur la batterie est tombée à 1V.  Au moment des tests, je suis passé à une batterie LiPo à moitié morte d'un petit quadricoptère.  Un peu plus tard, j'ai commandé la batterie à un autre vendeur et elle s'est avérée bonne. <br><br>  En principe, il serait possible de s'arrêter à cela, de souder les fils de connexion et de pousser doucement tout dans une sorte de boîtier, mais j'ai décidé de mesurer la consommation du circuit.  Et puis j'ai pleuré.  Eh bien, en état de marche (lorsque les ampoules brillent au maximum), cette chose mange jusqu'à 130mA, donc au repos, la consommation est supérieure à 25mA!  C'est-à-dire  ce clignotant mange ma batterie 600mAh en moins d'une journée! <br><br>  Il s'est avéré qu'environ 10 mA consomment des LED.  Même s'ils ne s'allument pas, un microcontrôleur fonctionne toujours dans chacun d'eux et attend une commande.  C'est-à-dire  Vous devez trouver un circuit de mise hors tension pour les LED. <br><br>  Les 15 mA restants sont consommés par le microcontrôleur.  Oui, il peut être mis au lit et selon la fiche technique, la consommation sera mesurée par des microampères, mais en fait il n'a pas été possible d'obtenir moins de 1 mA.  J'ai éteint l'ADC et traduit les broches en entrée.  Il semble que quelque part dans le circuit il y ait une sorte de fuite, mais ma modeste connaissance de l'électronique ne suffit pas pour la trouver et la comprendre. <br><br><h2>  Nous compliquons le schéma </h2><br>  Ensuite, je me suis souvenu d'avoir acheté une puce PT1502 pour un test.  Cette puce est un contrôleur de charge de batterie au lithium complet avec une alimentation avec plusieurs entrées de contrôle.  La seule difficulté est que le microcircuit est livré dans un boîtier QFN20 4x4 mm et nécessite un cerclage.  Souder cela à la maison est difficile, mais possible.  Les frais sont difficiles pour un LUT régulier et doivent être commandés auprès des Chinois.  Mais nous n'avons pas peur des difficultés, non? <br><br>  Dans plusieurs encadrés, le schéma peut être décrit comme suit. <br><br><img src="https://habrastorage.org/webt/t9/c5/rg/t9c5rgauskpsz1momglwordnf0o.png"><br><br>  À l'état éteint, le contrôleur et les voyants ne sont pas alimentés.  L'appareil dispose d'un bouton `` Power '' qui allume le clignotant (il change également de mode).  La LED brille, disons, une minute, et s'il n'y a pas d'activité de l'utilisateur (personne n'appuie sur un bouton), l'appareil s'éteint.  C'est-à-dire  Il ne va pas simplement s'endormir, mais il se coupe automatiquement par le signal Power Hold.  Et il éteint tout à la fois - à la fois le microcontrôleur et les LED.  La fonctionnalité de mise sous tension et hors tension est implémentée à l'intérieur de la puce PT1502 <br><br>  Il ne reste plus qu'à dessiner un schéma de circuit et à faire un circuit imprimé.  Les circuits sont, pour la plupart, liés à la fiche technique PT1502, ainsi qu'au module Digispark ATTiny85.  Le microcircuit du contrôleur de puissance PT1502 est fonctionnellement divisé en plusieurs parties, il est donc divisé en blocs dans le circuit. <br><br><img src="https://habrastorage.org/webt/fc/s6/qu/fcs6qu4zqgfja5p4hjacywrds8k.png"><br><br>  Il s'agit en fait d'un contrôleur de charge de batterie au lithium avec son propre faisceau.  La LED1 indique l'état de charge - allumée, puis la charge est allumée.  La résistance R6 règle le courant de charge à 470mA.  Puisque j'ai une batterie de 600mAh, en principe, vous pouvez augmenter le courant et mettre une résistance à 780-800 Ohms jusqu'à 600mA.  Cependant, je ne suis pas sûr de la qualité spéciale de ma batterie - il vaut mieux charger plus lentement, mais cela durera plus longtemps. <br><br>  Envisagez un plan d'alimentation <br><br><img src="https://habrastorage.org/webt/z1/rb/_a/z1rb_a2zu2a95pvxzk629o1tsjm.png"><br><br>  Le bouton SW1 démarre tout le système - la puce PT1502 se réveille puis démarre toutes les sources d'alimentation (dont elle en a 3).  Lorsque l'alimentation est installée, le microcircuit démarre le microcontrôleur en libérant le signal RESET.  Pour faciliter le débogage, j'ai également ajouté un bouton de réinitialisation distinct. <br><br>  Le signal HOLD est utilisé pour éteindre l'ensemble du système.  Lorsque le microcontrôleur démarre, il doit régler l'unité sur cette ligne.  Lorsqu'il est temps d'arrondir, le microcontrôleur met à zéro sur la ligne HOLD et la puce d'alimentation PT1502 arrête toutes les sources d'alimentation. <br><br>  Il serait possible de suivre la charge faible de la batterie en utilisant la sortie BAT_LOW, mais dans cet article, je l'ai noté - vous n'avez pas besoin d'enregistrer de données et rien n'explosera si vous ne remarquez pas une batterie morte à temps.  Meurt tellement meurt.  Mais juste au cas où, le conseil d'administration a fourni le contact pour cette entreprise. <br><br>  Revenons au bouton SW1 pendant une seconde.  J'ai décidé de ne pas faire 2 boutons séparés pour allumer et contrôler.  Par conséquent, le même bouton est également connecté à l'ATTiny85 et pendant le fonctionnement, il commute les modes de clignotement.  Les valeurs du diviseur R7-R8 sont sélectionnées de manière à ne pas brûler le port du microcontrôleur PB2.  Pour toutes les plages de tension de batterie (3,3 - 4,2 V), la tension sera fournie au pied du contrôleur dans les limites spécifiées de la fiche technique (0,7 * VCC - VCC + 0,5 V) <br><br>  Considérez une source d'alimentation <br><br><img src="https://habrastorage.org/webt/u1/3q/kf/u13qkfyn6g7gffo_qb8j9licy4w.png"><br><br>  Il s'agit d'un convertisseur DC-DC pulsé.  La tension de sortie est réglée par les résistances R10-R11 et, selon la formule de la fiche technique, est réglée sur 3,3 V.  Tout le reste est un simple cerclage. <br><br>  Pour de bon, une telle source d'alimentation trompée n'est pas vraiment nécessaire - il serait possible d'alimenter le microcontrôleur en général directement à partir de la batterie.  C'est juste que cette source est déjà implémentée dans la puce PT1502 et qu'elle peut s'allumer / s'éteindre lorsque nous en avons besoin - pourquoi ne pas l'utiliser? <br><br><img src="https://habrastorage.org/webt/ad/8w/0z/ad8w0zewrcux0hdetprifertqss.png"><br><br>  La puce possède également 2 stabilisateurs linéaires, mais je ne les utiliserai pas.  Malheureusement, comme il s'est avéré, il est toujours nécessaire de fournir la tension d'entrée à cette source, sinon le microcircuit pense que la puissance n'est pas encore suffisamment stable et ne démarre pas le microcontrôleur (cette connaissance m'a été donnée par une semaine de soudure de la carte de test dans les deux sens - je ne pouvais pas comprendre pourquoi cela ne fonctionnait pas) ) <br><br>  Passons à la partie logique. <br><br><img src="https://habrastorage.org/webt/sq/su/xj/sqsuxjeblb7507pz8ej2h1t3yui.png"><br><br>  Le câble USB est rodé de la carte Digispark inchangé.  Cela est nécessaire pour coordonner la tension USB (qui fonctionne à 3,3 V) et les signaux du microcontrôleur (qui, dans l'original, est alimenté par 5 V).  Étant donné que dans mon cas, le microcontrôleur est également alimenté par 3,3 V, le circuit pourrait être simplifié, mais juste au cas où, j'ai divorcé du circuit d'origine sur la carte. <br><br><img src="https://habrastorage.org/webt/qe/q8/xr/qeq8xr1bwr-ux0jnsk5na1p6eaw.png"><br><br>  Il n'y a rien d'intéressant dans la liaison du microcontrôleur. <br><br>  La touche finale est le connecteur <br><br><img src="https://habrastorage.org/webt/ic/vt/ey/icvtey-cwulcyqozyphkmglv-0m.png"><br><br>  En fait, je me suis procuré une telle carte de débogage sur ATTiny85 avec prise en charge USB et un contrôleur d'alimentation avec une batterie au lithium.  Par conséquent, je ne me suis pas limité à la sortie de la ligne sur la LED.  Au lieu de cela, j'ai apporté toutes les lignes du microcontrôleur au peigne - en même temps, il est pratique de se connecter au programmateur. <br><br>  Et que presque toutes les lignes soient liées de manière rigide à une certaine fonctionnalité (PB1 - Ligne de maintien, PB2 - bouton d'alimentation, PB3 / PB4 - USB, PB5 - Réinitialisation) à l'avenir, il sera possible de contourner certaines limites.  Par exemple, ne soudez pas le câble USB et ne libérez pas les lignes PB3 / PB4.  Ou, par exemple, refusez une réinitialisation et relâchez PB5.  En attendant, seul PB0 reste libre - et connectez-y notre LED. <br><br>  Nous passons au conseil d'administration.  Étant donné les limites de la taille de la carte en 40x40 mm, le nombre de composants et le boîtier QFN20 de la puce PT1502, je n'ai même pas envisagé la fabrication de la carte à la maison.  Par conséquent, j'ai immédiatement commencé à reproduire la planche à deux couches la plus compacte.  Voilà ce que j'ai <br><br><img src="https://habrastorage.org/webt/yt/6q/wh/yt6qwhfd9zkia64yyejpjx9litu.png"><br><br>  Pour la facilité d'utilisation, au verso j'ai signé toutes les fonctions de sortie possibles (j'ai eu l'idée de la carte Digispark) <br><br><img src="https://habrastorage.org/webt/q-/on/8t/q-on8tdmxq_bvht8egr5ilipb4s.png"><br><br>  J'ai commandé la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">carte</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JLCPCB</a> .  Pour être honnête, je ne suis pas très satisfait de la qualité - si vous soudez la puce plusieurs fois, le masque près des petits contacts du PT1502 est un peu trouble.  Eh bien, de petites inscriptions flottaient un peu.  Cependant, si tout est soudé la première fois, alors les normes. <br><br>  Pour souder QFN20, vous avez besoin d'un fer à souder, tout le reste peut être soudé avec un certain fer à souder avec une certaine compétence.  Voici à quoi ressemble la carte soudée <br><br><img src="https://habrastorage.org/webt/ct/km/4g/ctkm4gs_myfjjfeoukwn4ijuuc4.jpeg"><br><br><h2>  Logement </h2><br>  Il est temps de passer à la coque.  Je l'ai imprimé sur une imprimante 3D.  Conception sans fioritures - boîte et bouton.  Des crochets spéciaux sont fournis sur la boîte pour installer la luciole dans le module carré standard du concepteur. <br><br><img src="https://habrastorage.org/webt/g9/bz/yd/g9bzydcnm7bwonoo6rhe-1hby7k.png"><br><br>  La carte principale et la batterie vivent dans le boîtier. <br><br><img src="https://habrastorage.org/webt/zp/4u/x-/zp4ux-vaqurrmg9yqe3jb3jkry8.jpeg"><br><br><img src="https://habrastorage.org/webt/4f/oa/dw/4foadwyytzwav_lfiyvqrl5lcxs.jpeg"><br><br>  Le panneau LED est monté sur le couvercle, qui à son tour est vissé sur la boîte principale avec des vis <br><br>  Au début, j'ai pensé à visser le panneau LED au couvercle avec des vis, mais à la fin je l'ai simplement collé sur un ruban adhésif double face.  Il s'est avéré comme ça <br><br><img src="https://habrastorage.org/webt/vy/ks/y2/vyksy2ccuvrwcrjmxgvzolhlia0.jpeg"><br><br>  Sous cette forme, l'appareil peut déjà être utilisé, mais il a toujours l'air laid - il n'y a pas assez de diffuseur. <br><br>  J'ai essayé de faire la première version du diffuseur en utilisant la technologie de rétrécissement des bouteilles en PET avec un sèche-cheveux de construction (aperçu des modèles d'avion). <br><br>  Donc, vous avez d'abord besoin d'un blanc.  Je l'ai fabriqué à partir de gypse, que j'ai versé sous une forme que j'ai imprimée sur une imprimante 3D.  Dans la première version, la forme était monobloc et je n'ai jamais pu en retirer le disque moulé.  Par conséquent, j'ai dû créer un formulaire en deux parties. <br><br><img src="https://habrastorage.org/webt/gb/x0/0i/gbx00iokd8ea_lfquvmbbfebed4.jpeg"><br><br>  L'idée de la méthode est la suivante.  Vous mettez une bouteille de yaourt pour bébé sur un blanc et vous l’assoyez avec un sèche-cheveux de construction.  Voici juste le rapatriement de 20 récipients différents sous un lait différent. Je n'ai jamais réussi à mettre cette chose joliment, sans plis ni bulles.  Apparemment, vous devez clôturer une sorte d'installation sous vide et asseoir une feuille de plastique.  En général, cela s'est avéré trop difficile pour un tel engin. <br><br>  Après avoir grommelé à travers les gophers, j'ai trouvé une paire de mètres de sonde en plastique transparent Verbatim PET.  J'ai décidé d'essayer le diffuseur juste pour imprimer.  Et bien qu'à l'entrée de l'imprimante, le plastique semble limpide, la vraie partie est terne.  Cela est probablement dû à la structure interne, comme  les calques ne remplissent pas complètement le volume mais se chevauchent avec des lacunes et des lacunes.  De plus, si vous essayez de traiter la pièce avec du papier de verre pour une surface plus lisse, nous obtenons encore plus de nattes.  Cependant, c'est exactement ce dont j'avais besoin. <br><br>  J'étais trop paresseux pour me soucier du support pour le diffuseur, alors je l'ai ajouté à la colle chaude.  Donc, ma conception est maintenant conditionnellement pliable.  Je pourrais être confondu avec l'invention d'une sorte de loquets, mais j'ai déjà manqué de sonde en plastique transparent.  Alors laissez-le fondre. <br><br><img src="https://habrastorage.org/webt/xb/vy/49/xbvy49czm3mqdgjrexvvrcsm25m.jpeg"><br><br><img src="https://habrastorage.org/webt/fz/tx/tx/fztxtxljbgq0uwqnhlne0-mvcdc.jpeg"><br><br><h2>  Firmware </h2><br>  Pour les clignotants LED, vous n'avez pas besoin de plonger particulièrement dans la périphérie du microcontrôleur - quelques fonctions pour travailler avec GPIO suffisent.  Mais puisque le module est ancré à la plate-forme Arduino, alors pourquoi ne pas en profiter? <br><br>  Tout d'abord, quelques définitions et constantes <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Number of total LEDs on the board. Mine has 4x4 LEDs #define NUM_HW_PIXELS 16 // Pin number where LED data pin is attached #define DATA_PIN 0 // Pin number where mode switch button is attached #define BUTTON_PIN 2 // Power Enabled pin #define POWER_EN_PIN 1 // Max brightness (dimming the light for debugging) #define MAX_VAL 255</span></span></code> </pre> <br>  Cela détermine le nombre de pixels dans ma matrice, les numéros de broches et la luminosité maximale des LED (lors du débogage, il était pratique de le régler à 50 afin qu'il ne me aveugle pas les yeux) <br><br>  Les LED de ma matrice sont disposées d'une manière plutôt non évidente - un zigzag.  Par conséquent, pour différents effets, j'ai dû renuméroter. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// LED indexes for different patterns uint8_t circleLEDIndexes[] = {0, 1, 2, 3, 4, 11, 12, 13, 14, 15, 8, 7}; uint8_t beaconLEDIndexes[] = {6, 5, 10, 9}; uint8_t policeLEDIndexes[] = {7, 6, 10, 11, 4, 5, 9, 8};</span></span></code> </pre> <br>  Pour contrôler les LED, je n'ai pas réinventé la roue et j'ai pris une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque prête à l'emploi pour travailler avec les LED WS8211</a> .  L'interface de la bibliothèque est légèrement blanchie.  Certaines fonctions auxiliaires (par exemple, la conversion de HSV en RVB) sont également restées bloquées. <br><br>  Tout d'abord, la carte et la bibliothèque WS8211 doivent être initialisées. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Driver Ai_WS2811 ws2811; void setup() { // Set up power pinMode(POWER_EN_PIN, OUTPUT); digitalWrite(POWER_EN_PIN, HIGH); // initialize LED data pin pinMode(LED_PIN, OUTPUT); // Initialize button pin pinMode(BUTTON_PIN, INPUT); // Initialize WS8211 library static CRGB ledsBuf[NUM_HW_PIXELS]; ws2811.init(DATA_PIN, NUM_HW_PIXELS, ledsBuf); // Set the watchdog timer to 2 sec wdt_enable(WDTO_2S); }</span></span></code> </pre> <br>  Tout d'abord, vous devez régler le signal POWER HOLD sur l'unité - ce sera un signal à la puce PT1502 que le microcontrôleur s'est enroulé et fonctionne correctement.  Le microcircuit, à son tour, fournira régulièrement de l'électricité au microcontrôleur et aux DEL tant que le signal HOLD est réglé sur l'unité. <br><br>  Ensuite, les pieds pour contrôler la LED sur la sortie et les boutons sur l'entrée sont configurés.  Après cela, vous pouvez initialiser la bibliothèque WS8211. <br><br>  Comme il s'agit d'un appareil assez autonome, on ne peut pas permettre au microcontrôleur de rester dans un état incompréhensible et d'avaler toute la batterie.  Pour ce faire, je lance la minuterie de surveillance pendant 2 secondes.  La minuterie redémarrera dans la boucle de programme principale. <br><br>  Vous devez maintenant définir quelques fonctions auxiliaires.  La bibliothèque WS8211 stocke un tampon avec les valeurs de couleur de chaque LED.  Travailler directement avec le tampon n'est pas très pratique, car j'ai écrit une fonction simple pour écrire des valeurs RVB sur une LED spécifique <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRgb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> g, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ CRGB * leds = ws2811.getRGBData(); leds[led_idx].r = r; leds[led_idx].g = g; leds[led_idx].b = b; }</code> </pre> <br>  Mais dans la plupart des cas, dans le modèle de couleurs RVB, le comptage des couleurs n'est pas très pratique, voire impossible.  Par exemple, lorsque vous dessinez tout type d'arc-en-ciel, il est plus pratique de travailler avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le modèle de couleur HSV</a> .  La couleur de chaque pixel est définie par la valeur du ton de couleur et de la luminosité.  La saturation est omise pour plus de simplicité (le maximum est utilisé).  Les valeurs de teinte sont réduites à une plage de 0 à 255 (au lieu de la norme de 0 à 359). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * HVS to RGB conversion (simplified to the range 0-255) **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> brightness)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//this is the algorithm to convert from RGB to HSV double r = 0; double g = 0; double b = 0; double hf = hue/42.6; // Not /60 as range is _not_ 0-360 int i=(int)floor(hue/42.6); double f = hue/42.6 - i; double qv = 1 - f; double tv = f; switch (i) { case 0: r = 1; g = tv; break; case 1: r = qv; g = 1; break; case 2: g = 1; b = tv; break; case 3: g = qv; b = 1; break; case 4: r = tv; b = 1; break; case 5: r = 1; b = qv; break; } brightness = constrain(brightness, 0, MAX_VAL); setRgb(led_idx, constrain(brightness*r, 0, MAX_VAL), constrain(brightness*g, 0, MAX_VAL), constrain(brightness*b, 0, MAX_VAL) ); }</span></span></code> </pre><br>  La fonction est tirée de la bibliothèque Ai_WS8211 et légèrement archivée.  Dans la version originale de cette fonction de la bibliothèque, il y avait quelques bugs à cause desquels la couleur sur les arcs-en-ciel montrait avec des secousses. <br><br>  Passons à l'implémentation de divers effets.  Chaque fonction est appelée à partir de la boucle principale pour dessiner un «cadre».  Étant donné que chaque effet fonctionne avec différents paramètres entre les appels, ils sont stockés dans des variables statiques. <br><br>  C'est l'effet le plus simple - toutes les LED sont remplies d'une seule couleur, qui change en douceur. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> hue = <span class="hljs-number"><span class="hljs-number">0</span></span>; hue++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, hue, MAX_VAL); ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  L'effet suivant est plus intéressant - il affiche un arc-en-ciel le long du contour de la matrice, et les couleurs de l'arc-en-ciel se déplacent progressivement dans un cercle. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slidingRainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hue = (pos + led*<span class="hljs-number"><span class="hljs-number">256</span></span>/ARRAY_SIZE(circleLEDIndexes)) % <span class="hljs-number"><span class="hljs-number">256</span></span>; setHue(circleLEDIndexes[led], hue, MAX_VAL); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br>  Et cet effet remplit toute la matrice d'une couleur aléatoire, qui s'allume d'abord en douceur, puis s'éteint également en douceur. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomColorsFadeInOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> color = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !goesUp) { color = rand() % <span class="hljs-number"><span class="hljs-number">256</span></span>; goesUp = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == MAX_VAL &amp;&amp; goesUp) { goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, color, curLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(goesUp) curLevel++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> curLevel--; ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre><br>  Le groupe d'effets suivant dessine différentes balises clignotantes.  Ainsi, par exemple, un enfant aime construire un bulldozer avec des aimants et un clignotant orange y sera très utile. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orangeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ORANGE_HUE = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos+=<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(circleLEDIndexes), <span class="hljs-number"><span class="hljs-number">70</span></span>); setHue(circleLEDIndexes[led], ORANGE_HUE, brightness); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Techniquement, l'effet ressemble à un point brillant qui se déplace le long de la matrice.  Mais pour la rendre belle, les LED voisines s'estompent progressivement à mesure que vous vous éloignez du point principal.  Par conséquent, j'avais besoin d'une fonction qui calcule cette même luminosité. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brightnessByPos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ledPos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(pos - ledPos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(diff &gt; <span class="hljs-number"><span class="hljs-number">127</span></span>) diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>-diff); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = MAX_VAL - constrain(MAX_VAL*diff/delta, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brightness; }</code> </pre><br>  Pos est une certaine position conditionnelle du point lumineux de luminosité, mappée sur une plage de bouclage de 0 à 255.  ledPos est la position de la LED (affichée sur la même plage) dont vous devez calculer la luminosité.  Si la différence de position est supérieure à delta, la LED ne s'allume pas et plus la position est proche, plus elle brille. <br><br>  Ou, par exemple, une lumière clignotante rouge-bleu de la police <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">policeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RED_HUE = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BLUE_HUE = <span class="hljs-number"><span class="hljs-number">170</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(policeLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ledPos = led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(policeLEDIndexes); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], RED_HUE, brightness); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(brightness == <span class="hljs-number"><span class="hljs-number">0</span></span>) { brightness = brightnessByPos((pos+<span class="hljs-number"><span class="hljs-number">100</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], BLUE_HUE, brightness); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Puisque nous parlons de voitures, le feu de circulation n'est pas un problème à mettre en place. <br><br>  Ce sont des fonctions qui incluent divers feux de circulation à différentes positions. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearPixels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;NUM_HW_PIXELS; i++) { setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) setRgb(i, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yellowTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">4</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; i++) setRgb(i, MAX_VAL, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greenTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">8</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; i++) setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); }</code> </pre> <br>  Il est temps de le faire revivre.  Le feu de circulation fonctionne selon un programme spécial défini dans une sorte de bytecode.  La plaque décrit le mode et la durée pendant laquelle ce mode doit être activé. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TRAFFIC_LIGHTS { NONE, RED, YELLOW, GREEN }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trafficLightState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> state; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> duration; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> trafficLightState trafficLightStates[] = { {NONE, <span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// clear yellow {RED, 7000}, // red {YELLOW, 2000}, // red + yellow {NONE, 1}, // clear red+yellow {GREEN, 7000}, // green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 1}, // clear green {YELLOW, 2000}, // yellow };</span></span></code> </pre> <br>  En fait, la fonction qui traite tout <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curStateIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> curStateTimeStamp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Switch to a new state when time comes if(millis() - curStateTimeStamp &gt; (unsigned long)trafficLightStates[curStateIdx].duration) { curStateIdx++; curStateIdx %= ARRAY_SIZE(trafficLightStates); curStateTimeStamp = millis(); } switch(trafficLightStates[curStateIdx].state) { case NONE: clearPixels(); ws2811.sendLedData(); break; case RED: redTrafficLights(); break; case YELLOW: yellowTrafficLights(); break; case GREEN: greenTrafficLights(); break; default: break; } // Just waiting delay(10); }</span></span></code> </pre><br>  Après avoir atteint l'intervalle de temps spécifié, le prochain mode de feu de circulation est allumé et le compte à rebours recommence. <br><br>  Le dernier effet sur lequel mon imagination était suffisante, ce sont les astérisques.  5 LED aléatoires s'allument à une luminosité aléatoire, puis s'éteignent en douceur.  Si une étoile s'éteint, une autre dans un endroit aléatoire s'allume. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> numleds = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ledIndexes[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> maxVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;numleds; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ledIndexes[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = rand() % (NUM_HW_PIXELS+<span class="hljs-number"><span class="hljs-number">1</span></span>); CRGB * leds = ws2811.getRGBData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(leds[led].r == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ledIndexes[i] = led; maxVal[i] = rand() % (MAX_VAL<span class="hljs-number"><span class="hljs-number">-1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; curVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = ledIndexes[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] &lt; maxVal[i]) curVal[i]++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == maxVal[i]) maxVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span> || --curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) ledIndexes[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; setRgb(led<span class="hljs-number"><span class="hljs-number">-1</span></span>, curVal[i], curVal[i], curVal[i]); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  Quelque part ici, un insecte maléfique s'est introduit.  Parfois, les étoiles s'illuminent fortement, ou vice versa s'éteignent brusquement.  Mais pour être honnête, j'étais trop paresseux pour le comprendre - cela semble tout à fait normal. <br><br>  Il est temps de penser à économiser la batterie.  J'ai déjà donné les valeurs de consommation de tout cela.  Si vous ne pensez pas à couper l'alimentation, les LED mangeront la batterie en quelques heures.  Cette fonction est responsable de la mise hors tension après 90 secondes d'inactivité.  Au départ, c'était 60 secondes, mais avec un vrai jeu, cela ne suffisait pas et 2 minutes étaient en quelque sorte longues. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutdownOnTimeOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resetTimer = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(periodStartTime == <span class="hljs-number"><span class="hljs-number">0</span></span> || resetTimer) { periodStartTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(millis() - periodStartTime &gt;= <span class="hljs-number"><span class="hljs-number">90000U</span></span>L) { periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; shutDown(); } }</code> </pre> <br>  En fait, la mise hors tension se produit comme suit. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clearPixels(); ws2811.sendLedData(); wdt_disable(); digitalWrite(POWER_EN_PIN, LOW); <span class="hljs-comment"><span class="hljs-comment">// No power after this point while(true) ; }</span></span></code> </pre> <br>  Si l'utilisateur appuie sur les boutons, la minuterie est réinitialisée.  Une fois le temps défini écoulé, la fonction remet le signal HOLD à zéro, ce qui correspond à une commande PT1502 pour couper l'alimentation.  Le chien de garde, en passant, doit également être arrêté, sinon après 2 secondes, il réveillera le système et remettra sous tension. <br><br>  Enfin, la boucle principale qui démarre tout <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// List of pointers to functions that serve different modes void (*Modes[])() = { rainbow, slidingRainbow, orangeBeacon, policeBeacon, trafficLights, stars, randomColorsFadeInOut }; void loop() { static uint8_t mode = eeprom_read_byte( (uint8_t*) 10 ); static bool waitingForBtnUp = false; static long btnPressTimeStamp; // Button switches mode if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; !waitingForBtnUp) { delay(20); if(digitalRead(BUTTON_PIN) == HIGH) { mode++; mode %= ARRAY_SIZE(Modes); // num modes clearPixels(); ws2811.sendLedData(); delay(1); eeprom_write_byte( (uint8_t*) 10, mode ); waitingForBtnUp = true; btnPressTimeStamp = millis(); shutdownOnTimeOut(true); } } // Shut down on long press over 5s if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; waitingForBtnUp &amp;&amp; millis() - btnPressTimeStamp &gt; 5000) shutDown(); // Detect button release if(digitalRead(BUTTON_PIN) == LOW &amp;&amp; waitingForBtnUp) waitingForBtnUp = false; // display LEDs according to current mode Modes[mode](); // pong shutdown timer shutdownOnTimeOut(); // Yes, we still alive wdt_reset(); }</span></span></code> </pre><br>  Appuyez sur le bouton pour changer de mode et réinitialiser la minuterie d'arrêt automatique.  Selon le mode actuel, l'une des fonctions d'effet de la liste Modes est lancée.  À chaque cycle, le chien de garde est également réinitialisé. <br><br>  Si un enfant, par exemple, jouait dans une voiture de police et qu'après 1,5 minute le voyant d'urgence s'est éteint, il est fort probable qu'après un deuxième allumage, le fils voudra continuer à jouer dans la voiture de police.  Pour ce faire, le mode sélectionné est enregistré en EEPROM (la cellule numéro 10 est sélectionnée dans le bulldozer). <br><br>  Voici une vidéo qui montre comment tout cela fonctionne. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5MLX1hc8Jz4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Bootloader </h2><br>  Presque tout est prêt.  Mais il y a encore une chose qui doit être déposée - un chargeur de démarrage.  Le fait est que le chargeur de démarrage standard ne nous convient pas. <br><br>  Tout d'abord, lorsque vous allumez l'appareil, il attend aussi longtemps que 6 secondes - peut-être que le firmware commencera à couler dedans.  Ce n'est qu'après le transfert de cette commande vers le firmware principal.  Ceci est pratique au stade du développement, mais sera gênant pour le périphérique fini. <br><br>  Et deuxièmement, le chargeur de démarrage standard ne sait rien de la puce PT1502, ce qui serait bien de donner un signal HOLD.  Sans ce signal, le microcircuit pense que le microcontrôleur n'a pas démarré ou, au contraire, veut s'éteindre.  Et si c'est le cas, après quelques millisecondes, le PT1502 coupera l'alimentation de tout le circuit. <br><br>  L'avantage de résoudre les deux problèmes n'est pas difficile.  Le digispark ATTiny85 utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le chargeur de démarrage du micronoyau</a> .  Ce chargeur de démarrage est assez facile à classer pour nos besoins.  Il suffit de corriger les définitions correspondantes dans le fichier de configuration. <br><br>  Tout d'abord, j'ai copié la configuration standard du micrologiciel \ configuration \ t85_default dans mon propre répertoire et y ai déjà apporté toutes les modifications.  Ce sera donc le cas pour lequel il est facile de revenir au chargeur de démarrage d'origine. <br><br>  Dans le fichier bootloaderconfig.h, vous avez le choix de la manière d'entrer dans le chargeur de démarrage.  D'après ce qui est proposé, rien ne nous convient, mais l'option la plus proche est ENTRY_JUMPER.  Dans cette option, le chargeur de démarrage n'est accessible que si un certain niveau apparaît sur une broche spécifique (le cavalier est fermé sur la carte). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENTRYMODE ENTRY_JUMPER</span></span></code> </pre> <br>  Nous n'avons pas de cavalier, mais il y a un bouton au pied du PB2.  Laissez le chargeur de démarrage entrer si le bouton est maintenu enfoncé pendant 5-7 secondes à la mise sous tension.  Mais si enfoncé et relâché, la transition vers le firmware principal se produit immédiatement. <br><br>  Nous devons définir 3 fonctions - initialisation, désinitialisation et vérifier s'il est temps d'entrer dans le chargeur de démarrage.  Dans l'original, ils sont tous simples et mis en œuvre avec des macros.  Seuls les 2 premiers seront simples <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOLD_PIN PB1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PIN PB2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PORT PORTB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_DDR DDRB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_INP PINB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderInit() {JUMPER_DDR &amp;= ~_BV(JUMPER_PIN); JUMPER_DDR |= _BV(HOLD_PIN); JUMPER_PORT &amp;= ~_BV(JUMPER_PIN); JUMPER_PORT |= _BV(HOLD_PIN); _delay_ms(1);} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderExit() {;}</span></span></code> </pre> <br>  bootLoaderInit () configure la broche du bouton (JUMPER_PIN) à l'entrée et désactive la suspension.  Nous avons déjà un pull-up sur la planche, et au sol, et lorsque vous appuyez sur un bouton de la broche, au contraire, il y en aura un.  Dans le même temps, vous pouvez immédiatement configurer le signal HOLD pour qu'il soit émis et régler l'unité sur celui-ci ... <br><br>  Pour une explication de l'arithmétique des bits, par exemple, allez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , et une compréhension des registres de configuration GPIO dans les contrôleurs AVR peut être glanée, par exemple, à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partir d'ici</a> . <br><br>  La fonction bootLoaderExit () est vide car  la configuration exposée est tout à fait appropriée pour la transition ultérieure vers le firmware principal <br><br>  La fonction bootLoaderStartCondition (), qui est responsable de la saisie du chargeur de démarrage au format macro, n'a pas sa place et est donc devenue une fonction à part entière <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __ASSEMBLER__ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Bootloader condition is to hold the button for 5 seconds inline unsigned char bootLoaderStartCondition() { long int i; for(i=0; i&lt;10000000; i++) if( !(JUMPER_INP &amp; _BV(JUMPER_PIN))) return 0; return 1; } #endif</span></span></span></span></code> </pre> <br>  La fonction en quelques secondes (en fait environ 6-7) vérifie l'état du bouton.  Si le bouton a été relâché plus tôt, nous n'avons pas besoin d'entrer dans le chargeur de démarrage.  Patient et persistant sont autorisés sur le chargeur de démarrage. <br><br>  Il s'est avéré que le fichier bootloaderconfig.h est impliqué dans la compilation des fichiers assembleur et le code de ce fichier provoque des erreurs.  J'ai dû mettre la fonction dans le bloc #ifndef __ASSEMBLER__ <br><br>  Un autre paramètre que j'ai modifié indique au chargeur de démarrage quoi faire s'il n'est pas connecté à l'USB - quittez après une seconde.  Le fait est que lors de l'effraction, le fils a souvent appuyé sur le bouton et est accidentellement entré dans le chargeur de démarrage.  Je ne sais pas comment c'est miraculeux, mais si le chargeur de démarrage n'a pas vu la connexion USB, il pourrait accidentellement écraser certaines pages de la mémoire.  Par conséquent, s'il n'y a pas de connexion, nous quitterons simplement le programme principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Define bootloader timeout value. * * The bootloader will only time out if a user program was loaded. * * AUTO_EXIT_NO_USB_MS The bootloader will exit after this delay if no USB is connected. * Set to 0 to disable * Adds ~6 bytes. * (This will wait for an USB SE0 reset from the host) * * All values are approx. in milliseconds */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AUTO_EXIT_NO_USB_MS 1000</span></span></code> </pre> <br>  Nous compilons ... et nous obtenons une erreur indiquant que le code ne rentre pas dans l'espace du chargeur de démarrage qui lui est alloué.  Comme la mémoire flash dans le contrôleur est très petite, le chargeur de démarrage est serré au maximum afin de laisser plus d'espace pour le programme principal.  Mais cela est facilement résolu dans le fichier Makefile.inc en suivant les instructions. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hexadecimal address for bootloader section to begin. To calculate the best value: # - make clean; make main.hex; ### output will list data: 2124 (or something like that) # - for the size of your device (8kb = 1024 * 8 = 8192) subtract above value 2124... = 6068 # - How many pages in is that? 6068 / 64 (tiny85 page size in bytes) = 94.8125 # - round that down to 94 - our new bootloader address is 94 * 64 = 6016, in hex = 1780 BOOTLOADER_ADDRESS = 1940</span></span></code> </pre> <br>  Ensuite, je viens de réduire l'adresse de démarrage du chargeur de démarrage à une page (64 octets), augmentant ainsi l'espace du chargeur de démarrage. <br><br>  Sinon, la compilation et le téléchargement du chargeur de démarrage à l'aide du programmateur USBAsp n'étaient pas un problème. <br><br><h2>  Conclusion </h2><br>  C'était un moyen très intéressant de passer d'un prototype sur une maquette à un appareil fini.  Cela ressemble à un clignotant ordinaire d'une leçon d'arduino, mais en fait, dans le processus de travail, j'ai dû résoudre tout un tas de problèmes intéressants - voici la lutte avec la consommation, le choix de la base de l'élément et la conception de l'étui, et en pensant au firmware avec le chargeur de démarrage.  J'espère sincèrement que mon expérience sera utile à quelqu'un. <br><br>  Cela aurait-il pu être plus facile?  Bien sûr que vous le pouvez.  Je pense que tout pourrait être fait avec un transistor.  Malheureusement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> j'ai lu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> après avoir soudé la carte.  Je verrais l'article plus tôt - je ferais tout sur le même TP4056 populaire - il est plus facile de le souder.  Quoi qu'il en soit, le convertisseur DC-DC, qui est à l'intérieur du PT1502 dans cet appareil, pour de bon, n'est pas nécessaire.  Cependant, une étude pratique du microcircuit PT1502 m'est utile pour mon autre projet, ainsi que la capacité de souder des microcircuits dans le boîtier QFN20. <br><br>  Enfin, voici les liens vers mon projet: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code du micrologiciel</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Circuit et carte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèle de boîtier et diffuseur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèles STL prêts pour l'impression</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435198/">https://habr.com/ru/post/fr435198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435184/index.html">L'intelligence artificielle apprise à détecter la maladie d'Alzheimer dans le cerveau 6 ans avant le diagnostic</a></li>
<li><a href="../fr435186/index.html">Rolls-Royce développe l'avion électrique le plus rapide du monde</a></li>
<li><a href="../fr435190/index.html">Google a réussi à se retirer de la taxe de 22,7 milliards de dollars via l'Irlande et les Bermudes</a></li>
<li><a href="../fr435194/index.html">Simplifiez la rédaction du CV d'un développeur</a></li>
<li><a href="../fr435196/index.html">Les chercheurs réussissent ReCAPTCHA en utilisant les services Google</a></li>
<li><a href="../fr435202/index.html">Nous écrivons notre langage de programmation, partie 1: nous écrivons un langage VM</a></li>
<li><a href="../fr435204/index.html">Réception pour les développeurs pour surmonter la procrastination</a></li>
<li><a href="../fr435206/index.html">L'Europe approuve la directive sur le droit d'auteur - pourquoi les plateformes de streaming s'opposent</a></li>
<li><a href="../fr435208/index.html">Internet des objets ... qui pleurent pour une bonne UI / UX</a></li>
<li><a href="../fr435210/index.html">Le travail de Xamarin avec le SDK C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>