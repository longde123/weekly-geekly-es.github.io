<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍤 🏐 🚣🏿 不要陷入过早优化的陷阱 🕺🏿 🚚 🕕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="唐纳德·克努斯（Donald Knuth）曾说过后来变得著名的话：“真正的问题是程序员（而不是他们需要的地方，而不是他们的需要）花费太多时间来关注效率。 过早的优化是编程中所有弊端（或至少其中大多数弊端）的根源。” 

  

 该材料的作者（我们今天将要翻译的翻译版）想谈谈他曾经如何陷入过早优化的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>不要陷入过早优化的陷阱</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/465809/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">唐纳德·克努斯（Donald Knuth）</a>曾说过后来变得著名的话：“真正的问题是程序员（而不是他们需要的地方，而不是他们的需要）花费太多时间来关注效率。 过早的优化是编程中所有弊端（或至少其中大多数弊端）的根源。” <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ps/qf/uj/psqfujg9tiki8nv85hrvqqwpyfy.jpeg"></a> <br><br> 该材料的作者（我们今天将要翻译的翻译版）想谈谈他曾经如何陷入过早优化的陷阱，以及他如何从自己的痛苦经历中了解到过早优化是万恶之源。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">游戏竞技场在线</font> </h2><br> 几年前，我从事网络游戏GeoArena Online（然后我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出售了</a> ，新所有者将其发布在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">geoarena.io上</a> ）。 这是一种“最后的幸存者”风格的多人游戏。 在那里，玩家控制了飞船，与另一位玩家一对一作战。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/a9d/bcc/f49a9dbcc8d59ab914ce355de6231696.png"></div><br>  <i><font color="#999999">游戏竞技场在线</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/259/3b0/346/2593b03467d1c05d04b3b23022e131c6.png"></div><br>  <i><font color="#999999">游戏竞技场在线</font></i> <br><br> 动态世界充满了粒子和特效，需要大量的计算资源。 结果，某些旧计算机上的游戏在特别紧张的时刻“减速”。 我是一个对生产力问题无动于衷的人，很感兴趣地解决了这个问题。 我问自己：“如何加快GeoArena客户端JavaScript的速度。” <br><br><h2>  <font color="#3AC1EF">Fast.js库</font> </h2><br> 在Internet上搜索了一下之后，我发现了<a href="">fast.js</a>库。 这是“微优化的集合，旨在简化非常快速的JavaScript程序的开发”。 内置标准方法（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Array.prototype.forEach（））</a>的更快实现的可用性加速了该库。 <br><br> 我发现这非常有趣。  GeoArena使用了许多数组，并对数组执行了许多操作，因此使用fast.js可以很好地帮助我加快游戏速度。  <code>forEach()</code>性能研究的以下结果包含在fastme.js的<a href="">README中</a> 。 <br><br><pre> <code class="javascript hljs">Native .forEach() vs fast.forEach() (<span class="hljs-number"><span class="hljs-number">10</span></span> items)  ✓ <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>::forEach() x <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">557</span></span>,<span class="hljs-number"><span class="hljs-number">082</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.37</span></span>% (<span class="hljs-number"><span class="hljs-number">97</span></span> runs sampled)  ✓ fast.forEach() x <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">799</span></span>,<span class="hljs-number"><span class="hljs-number">272</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.41</span></span>% (<span class="hljs-number"><span class="hljs-number">97</span></span> runs sampled)  Result: fast.js is <span class="hljs-number"><span class="hljs-number">2.83</span></span>% faster than <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>::forEach().</code> </pre> <br> 在某些外部库中实现的方法如何比其标准版本更快？ 事实是，这里有一个窍门（这些窍门随处可见）。 该库仅适用于处理稀疏数组。 <br><br> 这是此类数组的几个简单示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  -  :   1  . const sparse1 = [0, , 1]; console.log(sparse1.length); // 3 //  -   const sparse2 = []; // ...   - .   0 - 4    . sparse2[5] = 0; console.log(sparse2.length); // 6</span></span></code> </pre> <br> 为了理解为什么该库不能与稀疏数组一起正常工作，我研究了其源代码。 事实证明，fast.js中的<code>forEach()</code>实现基于for循环。  <code>forEach()</code>方法的快速实现如下所示： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     . function fastForEach(array, f) {  for (let i = 0; i &lt; array.length; i++) {    f(array[i], i, array);  } } const sparseArray = [1, , 2]; const print = x =&gt; console.log(x); fastForEach(sparseArray, print); //  print() 3 . sparseArray.forEach(print); //  print()  2 .</span></span></code> </pre> <br> 调用<code>fastForEach()</code>方法将<code>fastForEach()</code>三个值： <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br> 调用<code>sparseArray.forEach()</code>仅得出两个值的结论： <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br> 这种差异是由于以下事实：有关使用回调函数的JS规范表明， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不应在远程或未初始化的数组索引</a> （也称为“空洞”） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上调用</a>此类函数。  <code>fastForEach()</code>实现未检查数组是否有孔。 这导致速度的提高，但要以稀疏阵列的正确工作为代价。 这对我来说是完美的，因为GeoArena中没有使用稀疏数组。 <br><br> 此时，我应该对fast.js进行快速测试。 我应该安装该库，将<code>Array</code>对象的标准方法更改为fast.js的方法，然后测试游戏的性能。 但是，相反，我朝着完全不同的方向前进。 <br><br><h2>  <font color="#3AC1EF">我的开发称为fast.js</font> </h2><br> 生活在我里面的躁狂完美主义者想从优化游戏性能中榨取一切。 在我看来，fast.js库根本不是一个足够好的解决方案，因为它的使用暗含了对其方法的调用。 然后我想：“如果仅通过在代码中嵌入这些方法的新的，更快的实现来替换数组的标准方法，该怎么办？ 那将节省我对库方法调用的需求。” <br><br> 正是这个想法使我想到了一个巧妙的想法，那就是创建一个编译器，我大胆地将其称为<a href="">faster.js</a> 。 我计划使用它代替fast.js。 例如，这是源代码片段： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const arr = [1, 2, 3]; const results = arr.map(e =&gt; 2 * e);</span></span></code> </pre> <br>  fast.js编译器会将这段代码转换为以下代码-更快，但看起来更糟： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      faster.js const arr = [1, 2, 3]; const results = new Array(arr.length); const _f = (e =&gt; 2 * e); for (let _i = 0; _i &lt; arr.length; _i++) {  results[_i] = _f(arr[_i], _i, arr); }</span></span></code> </pre> <br>  fast.js的创建是由fast.js所基于的相同思想所促成的。 即，由于拒绝支持稀疏数组，我们正在讨论性能的微观优化。 <br><br> 乍一看，fast.js在我看来是一个非常成功的开发。 这是来自fast.js性能研究的一些结果： <br><br><pre> <code class="javascript hljs">  array-filter large    ✓ native x <span class="hljs-number"><span class="hljs-number">232</span></span>,<span class="hljs-number"><span class="hljs-number">063</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.36</span></span>% (<span class="hljs-number"><span class="hljs-number">58</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">083</span></span>,<span class="hljs-number"><span class="hljs-number">695</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.58</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">367.0</span></span>% faster (<span class="hljs-number"><span class="hljs-number">3.386</span></span>μs) than native  array-map large    ✓ native x <span class="hljs-number"><span class="hljs-number">223</span></span>,<span class="hljs-number"><span class="hljs-number">896</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">1.10</span></span>% (<span class="hljs-number"><span class="hljs-number">58</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">726</span></span>,<span class="hljs-number"><span class="hljs-number">376</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">1.13</span></span>% (<span class="hljs-number"><span class="hljs-number">60</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">671.1</span></span>% faster (<span class="hljs-number"><span class="hljs-number">3.887</span></span>μs) than native  array-reduce large    ✓ native x <span class="hljs-number"><span class="hljs-number">268</span></span>,<span class="hljs-number"><span class="hljs-number">919</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.41</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">621</span></span>,<span class="hljs-number"><span class="hljs-number">540</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.80</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">503.0</span></span>% faster (<span class="hljs-number"><span class="hljs-number">3.102</span></span>μs) than native  array-reduceRight large    ✓ native x <span class="hljs-number"><span class="hljs-number">68</span></span>,<span class="hljs-number"><span class="hljs-number">671</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">0.92</span></span>% (<span class="hljs-number"><span class="hljs-number">53</span></span> runs sampled)    ✓ faster.js x <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">571</span></span>,<span class="hljs-number"><span class="hljs-number">918</span></span> ops/sec ±<span class="hljs-number"><span class="hljs-number">1.16</span></span>% (<span class="hljs-number"><span class="hljs-number">57</span></span> runs sampled) faster.js is <span class="hljs-number"><span class="hljs-number">2189.1</span></span>% faster (<span class="hljs-number"><span class="hljs-number">13.926</span></span>μs) than native</code> </pre> <br> 完整的测试结果可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 它们位于15英寸MacBook Pro 2018的Node v8.16.1中。 <br><br> 我的开发是否比标准实施快2000％？ 毫无疑问，如此大幅提高生产率可以对任何计划产生最大的积极影响。 对不对 <br> 不，不是真的。 <br><br> 考虑一个简单的例子。 <br><br><ul><li> 想象一下，平均GeoArena游戏需要5,000毫秒（ms）的计算。 </li><li>  fast.js编译器将数组方法的执行速度平均提高了10倍（这是一个近似估计，而且，它被高估了；在大多数实际应用中，甚至没有两倍的加速）。 </li></ul><br> 这是我们真正感兴趣的问题：“这5000毫秒中的哪一部分花在了数组方法的实现上？”。 <br><br> 假设一半。 也就是说，在数组方法上花费了2500毫秒，其余2500毫秒用于其他所有方法。 如果是这样，那么使用faster.js将大大提高性能。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd3/1fb/d74/cd31fbd7429d4ce60636a7031c657ac2.png"></div><br>  <i><font color="#999999">条件示例：程序的执行时间大大减少</font></i> <br><br> 结果表明，总计算时间减少了45％。 <br><br> 不幸的是，所有这些论点离现实都非常非常遥远。 当然，GeoArena使用许多数组方法。 但是，不同任务的代码执行时间的实际分配类似于以下内容。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/7b8/2ff/2ae7b82ffd8c59c1632f7bab32d2b7fc.png"></div><br>  <i><font color="#999999">严酷的现实</font></i> <br><br> 可悲的是，我能说什么。 <br><br> 这正是Donald Knuth警告的错误。 我没有将精力投入应有的应用，并且在值得做的事情上也没有做。 <br><br> 在这里，简单的数学开始发挥作用。 如果某件事仅占用程序执行时间的1％，那么在最佳情况下对其进行优化只会使生产力提高1％。 <br><br> 这正是唐纳德·克努思（Donald Knuth）说的“不需要的地方”时所想到的。 而且，如果您考虑“需要什么”，那么事实证明这些是代表性能瓶颈的程序部分。 这些是对程序的整体性能做出重大贡献的代码段。 在这里，“生产率”的概念被广泛地使用。 它可能包括程序的运行时，其编译代码的大小以及其他内容。 在程序中对性能产生重大影响的部分，将其提高10％比在一些小事情上将其提高100％更好。 <br><br> 克努特还谈到“不必在必要时”施加努力。 这样做的重点是仅在必要时才需要优化某些内容。 当然，我有充分的理由考虑优化。 但是请记住，我开始开发fast.js，而在那之前我甚至没有尝试过在GeoArena中测试fast.js库？ 在我的游戏中测试fast.js花费的时间可以节省我数周的工作。 希望您不要陷入我陷入的陷阱。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 如果您有兴趣尝试使用fast.js，可以看一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这个</a>演示。 您得到的结果取决于您的设备和浏览器。 例如，这里是15英寸MacBook Pro 2018的Chrome 76发生的情况。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08d/7f9/05c/08d7f905cc232d83c0b17a9107d2abd5.png"></div><br>  <i><font color="#999999">Faster.js测试结果</font></i> <br><br> 您可能有兴趣了解在GeoArena中使用fast.js的实际结果。 我在游戏还属于我的时候（如我所说，我卖了），进行了一些基础研究。 结果，结果如下： <br><br><ul><li> 使用faster.js可将典型游戏中主要游戏周期的执行速度提高约1％。 </li><li> 由于使用了fast.js，因此游戏包的大小增加了0.3％。 这稍微减慢了游戏页面的加载速度。 由于fast.js将标准短代码转换为更快但更长的代码，因此捆绑包的大小有所增加。 </li></ul><br> 通常，faster.js有其优点和缺点，但是我的开发对GeoArena的性能没有太大影响。 如果我想先使用fast.js测试游戏，那我早就了解了。 <br><br> 愿我的故事对您发出警告。 <br><br>  <b>亲爱的读者们！</b> 您是否陷入过早优化的陷阱？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN465809/">https://habr.com/ru/post/zh-CN465809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN465797/index.html">遗传算法（或者客户永远是王者-常常是傻瓜）</a></li>
<li><a href="../zh-CN465801/index.html">食品设计文摘，2019年8月</a></li>
<li><a href="../zh-CN465803/index.html">建立Go项目的Maven方法</a></li>
<li><a href="../zh-CN465805/index.html">Gigatron-不含处理器的自制微型计算机</a></li>
<li><a href="../zh-CN465807/index.html">流行的JavaScript库如何开始在终端上展示广告的故事</a></li>
<li><a href="../zh-CN465811/index.html">编写简洁的React代码的14条技巧。 第一部分</a></li>
<li><a href="../zh-CN465813/index.html">编写简洁的React代码的14条技巧。 第二部分</a></li>
<li><a href="../zh-CN465815/index.html">科学家们培育了神经细胞簇，并将其送到国际空间站</a></li>
<li><a href="../zh-CN465817/index.html">不适如何帮助我们改善开发过程。</a></li>
<li><a href="../zh-CN465819/index.html">理想的局域网</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>