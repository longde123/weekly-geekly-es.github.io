<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❄️ 👨🏽‍⚕️ 👩🏿‍🏭 Refactorisation d'un programme sur Go: accélération de 23 fois 🏇 🤳🏻 🐯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut Je m'appelle Marco, je travaille pour Badoo au département Platform. Nous avons beaucoup de choses écrites dans Go, et souvent elles sont essent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Refactorisation d'un programme sur Go: accélération de 23 fois</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/415919/"><img src="https://habrastorage.org/webt/fw/oq/ji/fwoqjijc84e50kqfhpyzqfl-oay.jpeg"><br><br>  <i>Salut</i>  <i>Je m'appelle Marco, je travaille pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Badoo</a> au département Platform.</i>  <i>Nous avons beaucoup de choses écrites dans Go, et souvent elles sont essentielles aux performances du système.</i>  <i>C'est pourquoi je vous propose aujourd'hui la traduction d'un article que j'ai beaucoup aimé et qui, je suis sûr, vous sera très utile.</i>  <i>L'auteur montre pas à pas comment il a abordé les problèmes de performances et comment ils les ont résolus.</i>  <i>Y compris vous vous familiariserez avec les riches outils disponibles dans Go pour un tel travail.</i>  <i>Bonne lecture!</i> <br><br>  Il y a quelques semaines, j'ai lu l'article « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bon code contre mauvais code dans Go</a> », où l'auteur, étape par étape, démontre la refactorisation d'une application réelle qui résout de vrais problèmes commerciaux.  Il se concentre sur la transformation du «mauvais code» en «bon code»: plus idiomatique, plus compréhensible, utilisant pleinement les spécificités de Go.  Mais l'auteur a également souligné l'importance des performances de l'application en question.  La curiosité m'a fait un bond: essayons de l'accélérer! <br><a name="habracut"></a><br>  Le programme, grosso modo, lit le fichier d’entrée, l’analyse ligne par ligne et remplit les objets en mémoire. <br><br><img src="https://habrastorage.org/webt/q0/ar/rr/q0arrrwx11e7qz627mj4ttz1r7y.png"><br><br>  L'auteur a non seulement publié le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code source sur GitHub</a> , mais a également écrit une référence.  C’est une excellente idée.  En fait, l'auteur a invité tout le monde à jouer avec le code et à essayer de l'accélérer.  Pour reproduire les résultats de l'auteur, utilisez la commande suivante: <br><br><pre><code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=.</code> </pre> <br><img src="https://habrastorage.org/webt/jw/x2/6w/jwx26wyngj_sqokfhrbk-3u3yeo.png"><br>  <i>μs par appel (moins - mieux)</i> <br><br>  Il s'avère que sur mon ordinateur, le «bon code» est 16% plus rapide.  Pouvons-nous l'accélérer? <br><br>  D'après mon expérience, il existe une corrélation entre la qualité du code et les performances.  Si vous avez réussi à refactoriser le code, à le rendre plus propre et moins connecté, vous l'avez probablement rendu plus rapide car il est devenu moins encombré (et il n'y a plus d'instructions inutiles qui ont été précédemment exécutées en vain).  Peut-être pendant la refactorisation vous avez remarqué des opportunités d'optimisation, ou maintenant vous avez juste la possibilité de les faire.  Mais d'un autre côté, si vous voulez rendre le code encore plus productif, vous devez probablement vous éloigner de la simplicité et ajouter divers hacks.  Vous économisez vraiment des millisecondes, mais la qualité du code en souffrira: il deviendra plus difficile de le lire et d'en parler, il deviendra plus fragile et flexible. <br><br><img src="https://habrastorage.org/webt/c9/lz/zd/c9lzzdc9yi73nsxn6cm93vwbvei.gif"><br>  <i>Nous escaladons la montagne de la Simplicité, puis en redescendons</i> <br><br>  C'est un compromis: jusqu'où êtes-vous prêt à aller? <br><br>  Pour hiérarchiser correctement les travaux sur l'accélération, la stratégie optimale consiste à trouver des goulots d'étranglement et à se concentrer sur eux.  Pour ce faire, utilisez les outils de profilage.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pprof</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trace</a> sont vos amis: <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -cpuprofile cpu.prof $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool pprof -svg cpu.prof &gt; cpu.svg</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/dc/j4/vf/dcj4vfmpccf5k2gjyxumvbtxj-k.png"></a> <br>  <i>Un graphique assez grand de l'utilisation du processeur (cliquez pour SVG)</i> <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -trace trace.out $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool trace trace.out</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/dd/tf/pk/ddtfpkssk98xhs_6o2ncqbxkucq.png"></a> <br>  <i>Tracé arc-en-ciel: beaucoup de petites tâches (cliquez pour ouvrir, fonctionne uniquement dans Google Chrome)</i> <br><br>  Le traçage confirme que tous les cœurs de processeur sont occupés (lignes inférieures à 0, 1, etc.) et, à première vue, c'est bien.  Mais elle montre également des milliers de «calculs» de petites couleurs et plusieurs zones vides où les noyaux étaient inactifs.  Zoomons: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/h3/-w/qe/h3-wqeqyb3xiiwyyvott4cwywg4.png"></a> <br>  <i>"Fenêtre" en 3 ms (cliquez pour ouvrir, fonctionne uniquement dans Google Chrome)</i> <br><br>  Chaque cœur est inactif pendant un certain temps, et il "saute" entre les micro-tâches tout le temps.  Il semble que la granularité de ces tâches n'est pas très optimale, ce qui conduit à un grand nombre de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">changements</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contexte</a> et à une concurrence due à la synchronisation. <br><br>  Voyons ce que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">détecteur de vol</a> nous dit.  Y a-t-il des problèmes d'accès synchrone aux données (s'il y en a, nous avons des problèmes bien plus importants que les performances)? <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -race PASS</code> </pre> <br>  Super!  Tout est correct.  Aucun vol trouvé.  Les fonctions de test et les fonctions de référence sont des fonctions différentes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voir la documentation</a> ), mais ici, elles appellent la même fonction <i>ParseAdexpMessage</i> , donc ce que nous avons vérifié pour les vols de données par des tests est correct. <br><br>  Le modèle compétitif dans la «bonne» version consiste à traiter chaque ligne du fichier d'entrée dans une goroutine distincte (pour utiliser tous les cœurs).  L'intuition de l'auteur a bien fonctionné ici, car les goroutins ont la réputation de fonctionnalités faciles et bon marché.  Mais combien gagnons-nous grâce à l'exécution parallèle?  Comparons avec le même code mais sans utiliser de goroutines (supprimez simplement le mot go qui vient avant l'appel de la fonction): <br><br><img src="https://habrastorage.org/webt/up/1q/0f/up1q0fy6bggo-62uevoioyo0huq.png"><br><img src="https://habrastorage.org/webt/ae/v3/go/aev3gocqbxle0pa3_lmeeyyczrg.png"><br><br>  Oups, il semble que le code soit devenu plus rapide sans utiliser la concurrence.  Cela signifie que le surcoût (non nul) pour le lancement de goroutines dépasse le temps que nous avons gagné en utilisant plusieurs cœurs en même temps.  La prochaine étape naturelle devrait être de supprimer la surcharge (non nulle) pour utiliser les canaux pour envoyer les résultats.  Remplaçons-le par une tranche régulière: <br><br><img src="https://habrastorage.org/webt/p_/sm/dl/p_smdl6hi439zezi4dygfvuyvtc.png"><br>  <i>μs par appel (moins c'est mieux)</i> <br><br>  Nous avons obtenu une accélération d'environ 40% par rapport à la «bonne» version, simplifiant le code et supprimant la concurrence ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diff</a> ). <br><br><img src="https://habrastorage.org/webt/qr/in/pi/qrinpifpqvwgdb65z1yflyywjhg.png"><br>  <i>Avec un goroutine, un seul cœur fonctionne à la fois</i> <br><br>  Voyons maintenant les fonctions chaudes dans le graphique pprof: <br><br> <a href=""><img src="https://habrastorage.org/webt/89/sd/bk/89sdbk8fhme8ixv37a2hmnxpj54.png"></a> <br>  <i>Recherche de goulots d'étranglement</i> <br><br>  La référence de la version actuelle (fonctionnement séquentiel, tranches) passe 86% du temps à analyser les messages, ce qui est normal.  Mais nous remarquerons rapidement que 43% du temps est consacré à l'utilisation des expressions régulières et de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(* Regexp) .FindAll</a> . <br><br>  Malgré le fait que les expressions régulières sont un moyen pratique et flexible d'obtenir des données à partir de texte brut, elles présentent des inconvénients, notamment l'utilisation d'un grand nombre de ressources, d'un processeur et de la mémoire.  Ils sont un outil puissant, mais leur utilisation est souvent inutile. <br><br>  Dans notre programme, un modèle <br><br><pre> <code class="go hljs">patternSubfield = <span class="hljs-string"><span class="hljs-string">"-.[^-]*"</span></span></code> </pre> <br>  Il est principalement destiné à mettre en évidence des commandes commençant par un tiret (-), et il peut y en avoir plusieurs sur la ligne.  Cela, après avoir tiré un peu de code, peut être fait en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bytes.Split</a> .  Adaptons le code ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commit</a> ) pour changer les expressions régulières en Split: <br><br><img src="https://habrastorage.org/webt/ks/8l/s2/ks8ls2upltp-tnqnpinp2tauqkc.png"><br>  <i>μs par appel (moins</i> c'est <i>mieux)</i> <br><br>  Ouah!  Code 40% plus productif!  Le graphique de consommation du processeur ressemble maintenant à ceci: <br><br> <a href=""><img src="https://habrastorage.org/webt/be/ux/dy/beuxdy132ncb8resbitn2gndy1a.png"></a> <br><br>  Plus de temps perdu sur les expressions régulières.  Une partie importante de celui-ci (40%) va à l'allocation de mémoire de cinq fonctions différentes.  Fait intéressant, maintenant 21% du temps est consacré à la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octets.Trim</a> : <br><br><img src="https://habrastorage.org/webt/8f/if/md/8fifmdma-hteqqu_p85umbyo1ly.png"><br>  <i>Cette fonctionnalité m'intrigue.</i>  <i>Que pouvons-nous faire ici?</i> <i><br><br></i>  <i>bytes.Trim</i> attend une chaîne avec des caractères qu'il "coupe" comme argument, mais comme cette chaîne, nous passons une chaîne avec un seul caractère - un espace.  Ceci est juste un exemple de la façon dont vous pouvez obtenir une accélération en raison de la complexité: créons notre fonction d'ajustement au lieu de la fonction standard.  Notre fonction de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">découpage</a> personnalisée fonctionnera avec un seul octet au lieu d'une ligne entière: <br><br><img src="https://habrastorage.org/webt/xs/cv/np/xscvnpnpkjo9ml4yq8chimeimv4.png"><br><img src="https://habrastorage.org/webt/h-/is/7x/h-is7xreexvfn_s537mdqtdkmrc.png"><br>  <i>μs par appel (moins c'est mieux)</i> <br><br>  Hourra, encore 20% de coupure!  La version actuelle est quatre fois plus rapide que la «mauvaise» originale et n'utilise en même temps qu'un seul cœur.  Pas mal! <br><br><hr><br><br>  Plus tôt, nous avons abandonné la compétitivité au niveau du traitement en ligne, mais je soutiens que l'accélération peut être obtenue en utilisant la compétitivité à un niveau supérieur.  Par exemple, le traitement de 6 000 fichiers (6 000 messages) est plus rapide sur mon ordinateur si chaque fichier est traité dans son propre goroutine: <br><br><img src="https://habrastorage.org/webt/r0/lf/oo/r0lfoof3kljocawz0tjcmogrww4.png"><br>  <i>μs par appel (moins c'est mieux; le violet est une solution compétitive)</i> <br><br>  Le gain est de 66% (c'est-à-dire une accélération trois fois).  C'est bien, mais pas très, étant donné que les 12 cœurs de processeur que j'ai sont utilisés.  Cela peut signifier que le nouveau code optimisé qui traite tout le fichier est toujours une «petite tâche», pour laquelle les frais généraux pour la création de goroutines et le coût de la synchronisation ne sont pas négligeables.  Il est intéressant de noter que l'augmentation du nombre de messages de 6 000 à 120 000 n'a aucun effet sur la version monothread et réduit les performances de la version «un goroutine par message».  En effet, malgré le fait que la création d'une telle quantité de goroutines soit possible et parfois utile, elle apporte sa propre surcharge dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">zone de</a> runtime- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sheduler</a> . <br><br>  Nous pouvons réduire davantage le temps d'exécution (pas de 12 fois, mais quand même) en créant seulement quelques travailleurs.  Par exemple, 12 goroutines à longue durée de vie, dont chacune traitera une partie des messages: <br><br><img src="https://habrastorage.org/webt/re/v2/wf/rev2wf-q7cfgvhxsfj15n30l6xa.png"><br>  <i>μs par appel (moins c'est mieux; le violet est une solution compétitive)</i> <br><br>  Cette option réduit le temps d'exécution de 79% par rapport à la version à un seul thread.  Notez que cette stratégie n'a de sens que si vous avez de nombreux fichiers à traiter. <br><br>  L'utilisation optimale de tous les cœurs de processeur consiste à utiliser plusieurs goroutines, chacune d'elles traitant une quantité importante de données sans aucune interaction ni synchronisation avant la fin du travail. <br><br>  Habituellement, ils prennent autant de processus (goroutine) que les cœurs du processeur, mais ce n'est pas toujours la meilleure option: tout dépend de la tâche spécifique.  Par exemple, si vous lisez quelque chose dans le système de fichiers ou faites beaucoup d'appels réseau, alors pour obtenir plus de performances, vous devez utiliser plus de goroutines que vos cœurs. <br><br><img src="https://habrastorage.org/webt/gd/m-/ic/gdm-icxpy5qq_n2fw5-zru20gu4.png"><br>  <i>μs par appel (moins c'est mieux; le violet est une solution compétitive)</i> <br><br>  Nous sommes arrivés au point où l'analyse des performances est difficile à augmenter avec certains changements localisés.  Le runtime est dominé par le temps d'allocation de mémoire et de récupération de place.  Cela semble logique car les fonctions de gestion de la mémoire sont plutôt lentes.  La poursuite de l'optimisation des processus associés aux allocations reste un devoir pour les lecteurs. <br><br><hr><br><br>  L'utilisation d'autres algorithmes peut également entraîner un gain de performances important. <br><br>  Ici, je me suis inspiré d'une conférence de Lexical Scanning in Go de Rob Pike, <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HxaD_trXwRE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  pour créer un lexer personnalisé ( <a href="">source</a> ) et un analyseur personnalisé ( <a href="">source</a> ).  Ce code n'est pas encore prêt (je ne traite pas un tas de cas d'angle), il est moins clair que l'algorithme d'origine, et parfois il est difficile d'écrire la bonne gestion des erreurs.  Mais elle est petite et 30% plus rapide que la version la plus optimisée. <br><br><img src="https://habrastorage.org/webt/ey/c3/n7/eyc3n7fnc1lu_szlyn2fnn0lzti.png"><br>  <i>μs par appel (moins c'est mieux; le violet est une solution compétitive)</i> <br><br>  Oui  En conséquence, nous avons obtenu une accélération de 23 fois par rapport au code source. <br><br><hr><br><br>  C'est tout pour aujourd'hui.  J'espère que vous avez apprécié cette aventure.  Voici quelques notes et conclusions: <br><br><ul><li>  La productivité peut être améliorée à différents niveaux d'abstraction, en utilisant différentes techniques, et le gain est souvent augmenté. <br></li><li>  Le réglage doit commencer par des abstractions de haut niveau: structures de données, algorithmes, découplage correct des modules.  Reprenez les abstractions de bas niveau plus tard: E / S, traitement par lots, compétitivité, utilisation de la bibliothèque standard, utilisation de la mémoire, allocation de mémoire. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'</a> analyse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Big O</a> est très importante, mais n'est généralement pas l'outil le plus approprié pour accélérer un programme. <br></li><li>  La rédaction de repères est un travail difficile.  Utilisez le profilage et les repères pour trouver les goulots d'étranglement et mieux comprendre ce qui se passe dans le programme.  Gardez à l'esprit que les résultats de référence ne sont pas les mêmes que ceux que vos utilisateurs connaîtront dans le travail réel. <br></li><li>  Heureusement, un ensemble d'outils ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bench</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pprof</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trace</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Race Detector</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cover</a> ) rend la recherche sur les performances du code abordable et intéressante. <br></li><li>  Écrire de bons tests pertinents n'est pas une tâche banale.  Mais ils sont sacrément importants de ne pas aller dans la nature.  Vous pouvez refactoriser, en étant sûr que le code reste correct. <br></li><li>  Arrêtez-vous et demandez-vous à quelle vitesse est «assez rapide».  Ne perdez pas votre temps à optimiser un script unique.  N'oubliez pas que l'optimisation n'est pas gratuite: le temps de l'ingénieur, la complexité, les bugs et la dette technique. <br></li><li>  Réfléchissez bien avant de compliquer le code. <br></li><li>  Les algorithmes de complexité <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ω</a> (n²) et plus sont généralement trop chers. <br></li><li>  Les algorithmes de complexité O (n) ou O (n log n) et inférieurs sont généralement corrects. <br></li><li>  Divers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">facteurs cachés</a> ne peuvent être ignorés.  Par exemple, toutes les améliorations de l'article ont été apportées en réduisant ces facteurs et non en modifiant la classe de complexité de l'algorithme. <br></li><li>  Les E / S sont souvent un goulot d'étranglement: requêtes réseau, requêtes de base de données, système de fichiers. <br></li><li>  Les expressions régulières sont souvent trop chères et inutiles. <br></li><li>  Les allocations de mémoire sont plus chères que les calculs. <br></li><li>  Un objet alloué sur la pile est moins cher qu'un objet alloué sur le tas. <br></li><li>  Les tranches sont utiles comme alternative aux mouvements de mémoire coûteux. <br></li><li>  Les chaînes sont efficaces en lecture seule (y compris le redimensionnement).  Dans tous les autres cas, [] octets sont plus efficaces. <br></li><li>  Il est très important que les données que vous traitez soient proches (caches du processeur). <br></li><li>  La compétitivité et le parallélisme sont très utiles, mais difficiles à préparer. <br></li><li>  Lorsque vous creusez profondément et bas, souvenez-vous du «plancher de verre» que vous ne voulez pas pénétrer dans Go.  Si vos mains vous démangent d'essayer les instructions d'assembleur, les instructions SIMD, vous devrez peut-être utiliser Go uniquement pour le prototypage, puis basculer vers un langage de niveau inférieur pour obtenir un contrôle total du matériel et toutes les nanosecondes! <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415919/">https://habr.com/ru/post/fr415919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415909/index.html">Extension Web multi-navigateur pour les scripts personnalisés Partie 2</a></li>
<li><a href="../fr415911/index.html">Accès à un index de tableau inexistant</a></li>
<li><a href="../fr415913/index.html">Réchauffez-vous pour ceux qui peuvent en Python</a></li>
<li><a href="../fr415915/index.html">Pratique sévère: quel type de sans fil avons-nous pour les hôteliers</a></li>
<li><a href="../fr415917/index.html">La "loi du printemps" est entrée en vigueur: quelle est la prochaine étape?</a></li>
<li><a href="../fr415923/index.html">L'unité est-elle lente? Attention LINQ</a></li>
<li><a href="../fr415925/index.html">Technologie de blockchain anonyme brevetée MasterCard</a></li>
<li><a href="../fr415927/index.html">Lampe industrielle Breeze 50</a></li>
<li><a href="../fr415929/index.html">Optimisation de l'architecture de l'intelligence artificielle: la course commence</a></li>
<li><a href="../fr415933/index.html">Comment construire une architecture IIoT à faire soi-même</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>