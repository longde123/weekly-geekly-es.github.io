<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèª üë©üèº‚Äçüé® üö∂üèº React Token Auth ‚õ∞Ô∏è üé∑ üóùÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Problemm 


 Die Autorisierung ist eines der ersten Probleme, mit denen Entwickler beim Starten eines neuen Projekts konfrontiert sind. Und eine der h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>React Token Auth</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485764/"><p><img src="https://habrastorage.org/webt/v-/ss/kz/v-sskznfybocplele4iiabbdl44.png"></p><br><h2 id="problem">  Problemm </h2><br><p> Die Autorisierung ist eines der ersten Probleme, mit denen Entwickler beim Starten eines neuen Projekts konfrontiert sind.  Und eine der h√§ufigsten Arten der Autorisierung (aus meiner Erfahrung) ist die tokenbasierte Autorisierung (normalerweise mit JWT). </p><br><p>  Aus meiner Sicht sieht dieser Artikel aus wie "das, was ich vor zwei Wochen lesen wollte".  Mein Ziel war es, minimalistischen und wiederverwendbaren Code mit einer sauberen und √ºbersichtlichen Oberfl√§che zu schreiben.  Ich hatte die n√§chsten Anforderungen f√ºr meine Implementierung des Authentifizierungsmanagements: </p><br><ul><li>  Token sollten lokal aufbewahrt werden </li><li>  Token sollten beim Neuladen der Seite wiederhergestellt werden </li><li>  Das Zugriffstoken sollte in den Netzwerkanforderungen √ºbergeben werden </li><li>  Nach Ablauf sollte das Zugriffstoken durch ein Aktualisierungstoken aktualisiert werden, wenn das letzte angezeigt wird </li><li>  Reaktionskomponenten sollten Zugriff auf die Authentifizierungsinformationen haben, um die entsprechende Benutzeroberfl√§che zu rendern </li><li>  Die L√∂sung sollte mit Pure React hergestellt werden (ohne Redux, Thunk, etc ..) </li></ul><a name="habracut"></a><br><p>  F√ºr mich war eine der herausforderndsten Fragen: </p><br><ul><li>  So bleiben Sie synchron Reagieren Sie auf den Status der Komponenten und die lokalen Speicherdaten? </li><li>  So erhalten Sie das Token in Fetch, ohne es durch den gesamten Elementbaum zu f√ºhren (insbesondere, wenn Sie dieses Fetch beispielsweise sp√§ter in Thunk-Aktionen verwenden m√∂chten) </li></ul><br><p> Aber lassen Sie uns die Probleme Schritt f√ºr Schritt l√∂sen.  Zun√§chst erstellen wir einen <code>token provider</code> zum Speichern von Token und zum Abh√∂ren von √Ñnderungen.  Danach erstellen wir einen <code>auth provider</code> , der den <code>auth provider</code> tats√§chlich umschlie√üt, um Hooks f√ºr React-Komponenten zu erstellen, Steroide abzurufen und einige zus√§tzliche Methoden.  Und am Ende werden wir uns ansehen, wie diese L√∂sung im Projekt verwendet wird. </p><br><h2 id="i-just-wanna-npm-install--and-go-production">  Ich m√∂chte nur <code>npm install ...</code> und in Produktion gehen </h2><br><p>  Ich habe bereits das Paket zusammengestellt, das alle unten beschriebenen (und ein bisschen mehr) enth√§lt.  Sie m√ºssen es nur mit dem folgenden Befehl installieren: </p><br><pre> <code class="plaintext hljs">npm install react-token-auth</code> </pre> <br><p>  Und folgen Sie den Beispielen im GitHub-Repository " <a href="https://github.com/obabichev/react-token-auth" rel="nofollow">react-token-auth"</a> . </p><br><h2 id="solution">  L√∂sung </h2><br><p>  Bevor ich das Problem l√∂se, gehe ich davon aus, dass es ein Backend gibt, das ein Objekt mit Zugriffs- und Aktualisierungstoken zur√ºckgibt.  Jedes Token hat ein <code>JWT</code> Format.  Ein solches Objekt k√∂nnte so aussehen: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"accessToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"refreshToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> }</code> </pre> <br><p>  Tats√§chlich ist die Struktur des Token-Objekts f√ºr uns nicht kritisch.  Im einfachsten Fall kann es sich um eine Zeichenfolge mit einem unbegrenzten Zugriffstoken handeln.  Wir m√∂chten jedoch untersuchen, wie Sie mit einer Situation umgehen, in der zwei Token vorhanden sind, von denen einer m√∂glicherweise abl√§uft und der zweite m√∂glicherweise zum Aktualisieren des ersten verwendet wird. </p><br><h3 id="jwt">  Jwt </h3><br><p>  Wenn Sie nicht wissen, was das JWT-Token ist, gehen <a href="https://jwt.io/" rel="nofollow">Sie</a> am besten zu <a href="https://jwt.io/" rel="nofollow">jwt.io</a> und sehen Sie sich an, wie es funktioniert.  Jetzt ist es wichtig, dass das JWT-Token codierte Informationen (im <code>Base64</code> Format) √ºber den Benutzer enth√§lt, mit denen er auf dem Server authentifiziert werden kann. </p><br><p>  Normalerweise enth√§lt das JWT-Token 3 Teile, die durch Punkte unterteilt sind und wie folgt aussehen: </p><br><p> <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjIsImV4cCI6MTUxNjIzOTAyMn0.yOZC0rjfSopcpJ-d3BWE8-BkoLR_SCqPdJpq8Wn-1Mc</code> </p> <br><p>  Wenn wir den mittleren Teil ( <code>eyJu...Mn0</code> ) dieses Tokens dekodieren, erhalten wir den n√§chsten JSON: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"iat"</span></span>: <span class="hljs-number"><span class="hljs-number">1516239022</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exp"</span></span>: <span class="hljs-number"><span class="hljs-number">1516239022</span></span> }</code> </pre> <br><p>  Mit diesen Informationen k√∂nnen wir das Ablaufdatum des Tokens ermitteln. </p><br><h3 id="token-provider">  Token-Anbieter </h3><br><p>  Wie bereits erw√§hnt, erstellen wir zun√§chst den Token-Provider.  Der Token-Anbieter arbeitet direkt mit dem lokalen Speicher und allen √Ñnderungen des Tokens, die wir dadurch vornehmen.  Es wird uns erm√∂glichen, √Ñnderungen von √ºberall zu h√∂ren und die H√∂rer sofort √ºber √Ñnderungen zu informieren (aber etwas sp√§ter).  Die Schnittstelle des Providers wird die folgenden Methoden haben: </p><br><ul><li>  <code>getToken()</code> zum <code>getToken()</code> des aktuellen Tokens (wird beim Abrufen verwendet) </li><li>  <code>setToken()</code> zum Setzen des Tokens nach dem Anmelden, Abmelden oder Registrieren </li><li>  <code>isLoggedIn()</code> , um zu √ºberpr√ºfen, ob der Benutzer angemeldet ist </li><li>  <code>subscribe()</code> , um dem Provider eine Funktion zu geben, die nach jeder Token√§nderung aufgerufen werden soll </li><li>  <code>unsubscribe()</code> , um den Abonnenten zu entfernen </li></ul><br><p>  Die Funktion <code>createTokenProvider()</code> erstellt eine Instanz des Token-Providers mit der beschriebenen Schnittstelle: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createTokenProvider = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Implementation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { getToken, isLoggedIn, setToken, subscribe, unsubscribe, }; };</code> </pre> <br><p>  Der gesamte n√§chste Code sollte sich in der Funktion createTokenProvider befinden. </p><br><p>  Beginnen wir mit der Erstellung einer Variablen zum Speichern von Token und zum Wiederherstellen der Daten aus dem lokalen Speicher (um sicherzustellen, dass die Sitzung nach dem erneuten Laden der Seite nicht verloren geht): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _token: { <span class="hljs-attr"><span class="hljs-attr">accessToken</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">refreshToken</span></span>: string } = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(localStorage.getItem(<span class="hljs-string"><span class="hljs-string">'REACT_TOKEN_AUTH'</span></span>) || <span class="hljs-string"><span class="hljs-string">''</span></span>) || <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br><p>  Jetzt m√ºssen wir einige zus√§tzliche Funktionen erstellen, um mit JWT-Token arbeiten zu k√∂nnen.  Im Moment sieht das JWT-Token wie eine magische Zeichenfolge aus, aber es ist keine gro√üe Sache, es zu analysieren und zu versuchen, das Ablaufdatum zu extrahieren.  Die Funktion <code>getExpirationDate()</code> nimmt ein JWT-Token als Parameter und gibt bei Erfolg einen Zeitstempel f√ºr das Ablaufdatum zur√ºck (oder <code>null</code> bei einem Fehler): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getExpirationDate = (jwtToken?: string): number | <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">null</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!jwtToken) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> jwt = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(atob(jwtToken.split(<span class="hljs-string"><span class="hljs-string">'.'</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-comment"><span class="hljs-comment">// multiply by 1000 to convert seconds into milliseconds return jwt &amp;&amp; jwt.exp &amp;&amp; jwt.exp * 1000 || null; };</span></span></code> </pre> <br><p>  Und eine weitere util-Funktion <code>isExpired()</code> pr√ºft, ob der Zeitstempel abgelaufen ist.  Diese Funktion gibt true zur√ºck, wenn der angegebene <code>Date.now()</code> kleiner als <code>Date.now()</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isExpired = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp?: number</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!exp) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; exp; };</code> </pre> <br><p>  Zeit zum Erstellen der ersten Funktion der Token-Provider-Schnittstelle.  Die Funktion <code>getToken()</code> sollte das Token zur√ºckgeben und bei Bedarf aktualisieren.  Diese Funktion sollte <code>async</code> da m√∂glicherweise eine Netzwerkanforderung zum Aktualisieren des Tokens gesendet wird. </p><br><p>  Mit den zuvor erstellten Funktionen k√∂nnen wir √ºberpr√ºfen, ob die Zugriffstoken abgelaufen sind oder nicht ( <code>isExpired(getExpirationDate(_token.accessToken))</code> ).  Und im ersten Fall eine Anforderung zum Aktualisieren des Tokens.  Danach k√∂nnen wir Tokens speichern (mit der noch nicht implementierten Funktion <code>setToken()</code> ).  Und schlie√ülich k√∂nnen wir das Zugriffstoken zur√ºckgeben: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getToken = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isExpired(getExpirationDate(_token.accessToken))) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> updatedToken = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'/update-token'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: _token.refreshToken }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r.json()); setToken(updatedToken); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _token &amp;&amp; _token.accessToken; };</code> </pre> <br><p>  Die Funktion <code>isLoggedIn()</code> ist einfach: Sie gibt true zur√ºck, wenn <code>_tokens</code> nicht <code>null</code> und pr√ºft nicht, ob das Zugriffstoken <code>_tokens</code> ist (in diesem Fall wissen wir nicht, ob das <code>_tokens</code> ist, bis es beim <code>_tokens</code> Tokens fehlschl√§gt. In der Regel ist dies jedoch ausreichend , und lassen Sie uns die Funktion isLoggedIn synchron halten): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isLoggedIn = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!_token; };</code> </pre> <br><p>  Ich denke, es ist ein guter Zeitpunkt, um Funktionen f√ºr die Verwaltung von Beobachtern zu erstellen.  Wir werden etwas √Ñhnliches wie das <a href="https://en.wikipedia.org/wiki/Observer_pattern" rel="nofollow">Observer-Muster</a> implementieren und zun√§chst ein Array erstellen, in dem alle unsere Beobachter gespeichert werden.  Wir erwarten, dass jedes Element in diesem Array die Funktion ist, die wir nach jeder √Ñnderung von Token aufrufen sollten: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> observers: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">isLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; = [];</code> </pre> <br><p>  Jetzt k√∂nnen wir Methoden <code>subscribe()</code> und <code>unsubscribe()</code> erstellen.  Der erste f√ºgt dem etwas fr√ºher erstellten Array einen neuen Beobachter hinzu, der zweite entfernt den Beobachter aus der Liste. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscribe = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer: (isLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) =&gt; { observers.push(observer); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unsubscribe = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer: (isLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) =&gt; { observers = observers.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_observer</span></span></span><span class="hljs-function"> =&gt;</span></span> _observer !== observer); };</code> </pre> <br><p>  Sie k√∂nnen bereits auf der Oberfl√§che der Funktionen <code>subscribe()</code> und <code>unsubscribe()</code> dass wir nur die Tatsache an Beobachter senden, dass der Benutzer angemeldet ist.  Im Allgemeinen k√∂nnen Sie jedoch alles senden, was Sie m√∂chten (das gesamte Token, die Ablaufzeit usw.).  F√ºr unsere Zwecke wird es jedoch ausreichen, eine Boolesche Flagge zu senden. </p><br><p>  Lassen Sie uns eine kleine util-Funktion notify <code>notify()</code> erstellen, die dieses Flag entgegennimmt und an alle Beobachter sendet: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> notify = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isLogged = isLoggedIn(); observers.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> observer(isLogged)); };</code> </pre> <br><p>  Und zu <code>setToken()</code> Letzt m√ºssen wir noch das <code>setToken()</code> implementieren.  Der Zweck dieser Funktion ist das Speichern von Tokens im lokalen Speicher (oder das Bereinigen des lokalen Speichers, wenn das Token leer ist) und das Benachrichtigen von Beobachtern √ºber √Ñnderungen.  Also, ich sehe das Ziel, ich gehe zum Ziel. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> setToken = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">token: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _token</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token) { localStorage.setItem(<span class="hljs-string"><span class="hljs-string">'REACT_TOKEN_AUTH'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(token)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { localStorage.removeItem(<span class="hljs-string"><span class="hljs-string">'REACT_TOKEN_AUTH'</span></span>); } _token = token; notify(); };</code> </pre> <br><p>  Stellen Sie sicher, dass Sie mich schon gl√ºcklicher gemacht haben, wenn Sie an diesen Punkt im Artikel gekommen sind und ihn n√ºtzlich fanden.  Hier beenden wir mit dem Token-Provider.  Sie k√∂nnen sich Ihren Code ansehen, damit spielen und pr√ºfen, ob er funktioniert.  Dar√ºber hinaus werden wir im n√§chsten Teil weitere abstrakte Funktionen erstellen, die in jeder React-Anwendung bereits n√ºtzlich sind. </p><br><h3 id="auth-provider">  Authentifizierungsanbieter </h3><br><p>  Erstellen wir eine neue Klasse von Objekten, die wir als Auth-Provider aufrufen.  Die Schnittstelle enth√§lt 4 Methoden: hook <code>useAuth()</code> , um den aktuellen Status von der React-Komponente zu erhalten, <code>authFetch()</code> , um Anforderungen an das Netzwerk mit dem tats√§chlichen Token und den Methoden <code>login()</code> und <code>authFetch()</code> zu <code>authFetch()</code> , die Proxy-Aufrufe an die Methode <code>setToken()</code> des Token-Anbieters (in diesem Fall haben wir nur einen Einstiegspunkt f√ºr die gesamte erstellte Funktionalit√§t, und der Rest des Codes muss nichts √ºber das Vorhandensein des Token-Anbieters wissen).  Nach wie vor gehen wir vom Funktionsersteller aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createAuthProvider = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Implementation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { useAuth, authFetch, login, logout } };</code> </pre> <br><p>  Wenn wir einen Token-Provider verwenden m√∂chten, m√ºssen wir zun√§chst eine Instanz davon erstellen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenProvider = createTokenProvider();</code> </pre> <br><p>  Die Methoden <code>login()</code> und <code>logout()</code> √ºbergeben das Token einfach an den Token-Provider.  Ich habe diese Methoden nur aus Gr√ºnden der expliziten Bedeutung getrennt (tats√§chlich werden durch das √úbergeben von empty / null Token Daten aus dem lokalen Speicher entfernt): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> login: <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> tokenProvider.setToken = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newTokens</span></span></span><span class="hljs-function">) =&gt;</span></span> { tokenProvider.setToken(newTokens); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logout = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { tokenProvider.setToken(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); };</code> </pre> <br><p>  Der n√§chste Schritt ist die Abruffunktion.  Nach meiner Vorstellung sollte diese Funktion genau die gleiche Schnittstelle haben wie der urspr√ºngliche Abruf und dasselbe Format zur√ºckgeben, aber Zugriffstoken f√ºr jede Anforderung einspeisen. </p><br><p>  Die Fetch-Funktion sollte zwei Argumente haben: request info (normalerweise URL) und request init (ein Objekt mit Methode, Body, Headern usw.);  und gibt Versprechen f√ºr die Antwort zur√ºck: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> authFetch = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (input: RequestInfo, init?: RequestInit): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;Response&gt; =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> tokenProvider.getToken(); init = init || {}; init.headers = { ...init.headers, <span class="hljs-attr"><span class="hljs-attr">Authorization</span></span>: <span class="hljs-string"><span class="hljs-string">`Bearer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${token}</span></span></span><span class="hljs-string">`</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(input, init); };</code> </pre> <br><p>  Innerhalb der Funktion haben wir zwei Dinge gemacht: ein Token vom Token-Provider per Anweisung <code>await tokenProvider.getToken();</code>  ( <code>getToken</code> enth√§lt bereits die Logik zum Aktualisieren des Tokens nach Ablauf) und zum Einf√ºgen dieses Tokens in den <code>Authorization</code> Header durch die Zeile <code>Authorization: 'Bearer ${token}'</code> .  Danach geben wir einfach fetch mit aktualisierten Argumenten zur√ºck. </p><br><p>  So k√∂nnen wir bereits den Authentifizierungsanbieter verwenden, um Token zu speichern und sie vom Abruf zu verwenden.  Das letzte Problem ist, dass wir nicht auf die Token√§nderungen unserer Komponenten reagieren k√∂nnen.  Zeit, es zu l√∂sen. </p><br><p>  Wie ich bereits sagte, erstellen wir einen Hook <code>useAuth()</code> , der der Komponente Informationen liefert, <code>useAuth()</code> der Benutzer angemeldet ist oder nicht.  Dazu verwenden wir hook <code>useState()</code> , um diese Informationen zu <code>useState()</code> .  Dies ist n√ºtzlich, da √Ñnderungen in diesem Status dazu f√ºhren, dass Komponenten, die diesen Hook verwenden, erneut gerendert werden. </p><br><p>  Und wir haben bereits alles vorbereitet, um √Ñnderungen im lokalen Speicher abh√∂ren zu k√∂nnen.  Eine gebr√§uchliche Methode, um √Ñnderungen im System mit Hooks abzuh√∂ren, ist der Hook <code>useEffect()</code> .  Dieser Hook ben√∂tigt zwei Argumente: Funktion und Liste der Abh√§ngigkeiten.  Die Funktion wird nach dem ersten Aufruf von <code>useEffect</code> und nach √Ñnderungen in der Liste der Abh√§ngigkeiten neu gestartet.  In dieser Funktion k√∂nnen wir √Ñnderungen im lokalen Speicher abh√∂ren.  Aber was wichtig ist, k√∂nnen wir von dieser Funktion zur√ºckkehren ... neue Funktion und diese neue Funktion wird entweder vor dem Neustart der ersten oder nach dem Abmelden der Komponente ausgel√∂st.  In der neuen Funktion k√∂nnen wir das Abh√∂ren der √Ñnderungen einstellen und React garantiert, dass diese Funktion ausgel√∂st wird (zumindest, wenn w√§hrend dieses Vorgangs keine Ausnahme auftritt).  H√∂rt sich etwas kompliziert an, aber sehen Sie sich den Code an: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> useAuth = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [isLogged, setIsLogged] = useState(tokenProvider.isLoggedIn()); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listener = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newIsLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> { setIsLogged(newIsLogged); }; tokenProvider.subscribe(listener); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { tokenProvider.unsubscribe(listener); }; }, []); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [isLogged] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> isLogged]; };</code> </pre> <br><p>  Und das ist alles.  Wir haben gerade einen kompakten und wiederverwendbaren Token-Authentifizierungsspeicher mit einer √ºbersichtlichen API erstellt.  Im n√§chsten Teil werden wir uns einige Anwendungsbeispiele ansehen. </p><br><h2 id="usage">  Verwendung </h2><br><p>  Um das zu verwenden, was wir oben implementiert haben, m√ºssen wir eine Instanz des Authentifizierungsanbieters erstellen.  Es gibt uns Zugriff auf die Funktionen <code>useAuth()</code> , <code>authFetch()</code> , <code>login()</code> <code>useAuth()</code> , <code>authFetch()</code> , die sich auf dasselbe Token im lokalen Speicher beziehen (im Allgemeinen hindert nichts Sie daran, unterschiedliche Instanzen des Authentifizierungsanbieters f√ºr verschiedene Token zu erstellen, Sie m√ºssen jedoch den Schl√ºssel parametrisieren, den Sie zum Speichern von Daten im lokalen Speicher verwenden. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {useAuth, authFetch, login, logout} = createAuthProvider();</code> </pre> <br><h3 id="login-form">  Anmeldeformular </h3><br><p>  Jetzt k√∂nnen wir die Funktionen nutzen, die wir haben.  Beginnen wir mit der Anmeldeformularkomponente.  Diese Komponente sollte Eingaben f√ºr die Anmeldeinformationen des Benutzers bereitstellen und im internen Status speichern.  Nach dem Absenden m√ºssen wir eine Anfrage mit den Zugangsdaten senden, um Token zu erhalten. Hier k√∂nnen wir die Funktion <code>login()</code> , um empfangene Token zu speichern: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LoginComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [credentials, setCredentials] = useState({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{target: {name, value}}: ChangeEvent&lt;HTMLInputElement&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> { setCredentials({...credentials, [name]: value}) }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onSubmit = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event?: React.FormEvent</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event) { event.preventDefault(); } fetch(<span class="hljs-string"><span class="hljs-string">'/login'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(credentials) }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">token</span></span></span><span class="hljs-function"> =&gt;</span></span> login(token)) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;form onSubmit={onSubmit}&gt; &lt;input name="name" value={credentials.name} onChange={onChange}/&gt; &lt;input name="password" value={credentials.password} onChange={onChange}/&gt; &lt;/form&gt; };</code> </pre> <br><p>  Und das ist alles, es ist alles, was wir brauchen, um den Token zu speichern.  Danach, wenn ein Token empfangen wird, m√ºssen wir keine zus√§tzlichen Anstrengungen unternehmen, um es zum Abrufen oder in Komponenten zu bringen, da es bereits innerhalb des Authentifizierungsanbieters implementiert ist. </p><br><p>  Anmeldeformular ist √§hnlich, es gibt nur Unterschiede in der Anzahl und den Namen der Eingabefelder, daher werde ich es hier weglassen. </p><br><h3 id="router">  Router </h3><br><p>  Wir k√∂nnen das Routing auch √ºber den Authentifizierungsanbieter implementieren.  Angenommen, wir haben zwei Routenpakete: eines f√ºr den registrierten Benutzer und eines f√ºr den nicht registrierten Benutzer.  Um sie aufzuteilen, m√ºssen wir √ºberpr√ºfen, ob wir ein Token im lokalen Speicher haben oder nicht. Hier k√∂nnen wir hook <code>useAuth()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Router = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [logged] = useAuth(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;BrowserRouter&gt; &lt;Switch&gt; {!logged &amp;&amp; &lt;&gt; &lt;Route path="/register" component={Register}/&gt; &lt;Route path="/login" component={Login}/&gt; &lt;Redirect to="/login"/&gt; &lt;/&gt;} {logged &amp;&amp; &lt;&gt; &lt;Route path="/dashboard" component={Dashboard} exact/&gt; &lt;Redirect to="/dashboard"/&gt; &lt;/&gt;} &lt;/Switch&gt; &lt;/BrowserRouter&gt;; };</code> </pre> <br><p>  Und das Sch√∂ne daran, dass es nach √Ñnderungen im lokalen Speicher erneut <code>useAuth</code> wird, da <code>useAuth</code> ein Abonnement f√ºr diese √Ñnderungen hat. </p><br><h3 id="fetch-requests">  Abrufen von Anforderungen </h3><br><p>  Und dann k√∂nnen wir mit <code>authFetch</code> Daten durch das Token <code>authFetch</code> .  Es hat die gleiche Schnittstelle wie fetch. Wenn Sie fetch also bereits im Code verwenden, k√∂nnen Sie es einfach durch <code>authFetch</code> ersetzen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dashboard = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [posts, setPosts] = useState([]); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { authFetch(<span class="hljs-string"><span class="hljs-string">'/posts'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_posts</span></span></span><span class="hljs-function"> =&gt;</span></span> setPosts(_posts)) }, []); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {posts.map(post =&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{post.id}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {post.message} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> };</code> </pre> <br><h2 id="summary">  Zusammenfassung </h2><br><p>  Wir haben es geschafft.  Es war eine interessante Reise, aber es hat auch das Ende (vielleicht sogar gl√ºcklich). </p><br><p>  Wir begannen mit dem Verst√§ndnis von Problemen beim Speichern von Autorisierungstoken.  Anschlie√üend haben wir eine L√∂sung implementiert und uns schlie√ülich die Beispiele f√ºr die Verwendung in der React-Anwendung angesehen. </p><br><p>  Wie ich bereits sagte, finden Sie meine Implementierung auf GitHub in der Bibliothek.  Es l√∂st ein etwas allgemeineres Problem und macht keine Annahmen √ºber die Struktur des Objekts mit Token oder √ºber das Aktualisieren des Tokens. Daher m√ºssen Sie einige zus√§tzliche Argumente angeben.  Die Idee der L√∂sung ist jedoch dieselbe und das Repository enth√§lt auch Anweisungen zu deren Verwendung. </p><br><p>  Hier kann ich mich f√ºr das Lesen des Artikels bedanken und ich hoffe, es war hilfreich f√ºr Sie. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485764/">https://habr.com/ru/post/de485764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485742/index.html">Wie wir das Adressverzeichnis von Rostelecom erstellt haben</a></li>
<li><a href="../de485744/index.html">Intelligenz - die F√§higkeit eines Objekts, sein Verhalten an die Umgebung anzupassen, um zu erhalten (zu √ºberleben)</a></li>
<li><a href="../de485746/index.html">4. Plattform f√§hrt vom verwendeten Server ab</a></li>
<li><a href="../de485748/index.html">Optionale Verkettung, Vereinigung mit Null und wie sie unsere Herangehensweise beim Schreiben von Code √§ndern</a></li>
<li><a href="../de485760/index.html">Erweiterungen in Kotlin. Gef√§hrlicher Atavismus oder n√ºtzliches Werkzeug?</a></li>
<li><a href="../de485766/index.html">F√ºtterungsregeln</a></li>
<li><a href="../de485768/index.html">2020 Web-Trends sind es wert, ausprobiert zu werden</a></li>
<li><a href="../de485770/index.html">Falsche Polemik</a></li>
<li><a href="../de485772/index.html">Vom Desktop zum virtuellen Rechenzentrum - wie wir zur Virtualisierung gekommen sind</a></li>
<li><a href="../de485776/index.html">√úberall in der Geographie: Navigation und geod√§tische Aufgaben in verschiedenen Sprachen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>