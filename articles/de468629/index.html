<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏻 💤 🥧 Wie ich einen Filter erstellt habe, der das Bild auch nach einer Million Läufen nicht beschädigt - Teil 2 🤶🏾 💅🏽 📅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil dieses Beitrags habe ich darüber gesprochen, wie die wiederholte Verwendung von Standard-Halfpel-Filtern zu verzerrten Bildern führt, u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ich einen Filter erstellt habe, der das Bild auch nach einer Million Läufen nicht beschädigt - Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468629/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" alt="Bild"></div><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil</a> dieses Beitrags habe ich darüber gesprochen, wie die wiederholte Verwendung von Standard-Halfpel-Filtern zu verzerrten Bildern führt, und dann einen neuen Filter gezeigt, bei dem dieses Problem nicht auftritt. <br><br>  Es war etwas verschwommener und das würde nicht jedem passen.  Es war jedoch besser als seine Alternativen - tatsächlich wurde dieser Filter in der Originalversion von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bink 2 verwendet</a> .  Aufgrund der ständigen Arbeitsbelastung gelang es mir nie wieder, zu ihm zurückzukehren und ihn genauer zu untersuchen. <br><br>  Aber jetzt, da ich <i>die</i> Zeit gefunden habe, zu diesem Filter zurückzukehren und einen Artikel darüber zu schreiben, sollte ich endlich die Frage stellen: Gibt es einen <i>weniger unscharfen</i> Filter, der immer noch die Eigenschaft „unendliche Stabilität“ beibehält? <br><br>  Spoiler-Warnung: Die richtige Antwort lautet "wahrscheinlich nicht" und "definitiv da".  Bevor wir jedoch herausfinden, warum es zwei Antworten auf diese Frage gibt und was sie bedeuten, sollten wir den Prüfstand besser vorbereiten. <br><a name="habracut"></a><br><h2>  Offset-Einstellung </h2><br>  Als ich anfänglich an diesem Problem arbeitete, hatte ich keine Ahnung, wonach ich suchte.  Ich wusste nicht einmal, dass <i>es</i> so etwas wie einen „unendlich stabilen“ Halbpel-Filter gibt, also habe ich bei seiner Suche kein System erstellt.  Ich war nur auf der Suche nach etwas, das den „vielen“ Filteriterationen ohne Bildverzerrung standhält.  Alle Bilder aus dem ersten Teil spiegeln diese Methode wider: Das Bild wird jeweils um ein halbes Pixel von rechts nach links verschoben. Wenn Sie den Filter also 100 Mal anwenden, wird das resultierende Bild um 50 Pixel verschoben. <br><br>  Jetzt, da wir wissen, wonach wir <i>tatsächlich</i> suchen, können wir etwas genauer sein.  Wenn Sie den Halfpel-Filter zweimal anwenden, verschieben wir das Bild genau um ein Pixel.  Das heißt, wenn wir <i>das Bild</i> einfach <i>um ein Pixel zurück verschieben</i> , bleibt es im selben Raum.  Dank dessen sieht der Test viel schöner aus, da wir dann den Filter nicht nur beliebig oft anwenden können, ohne befürchten zu müssen, dass das Bild vom Bildschirm "wegkriecht", sondern auch den <i>Unterschied des</i> Bildes zu früheren Versionen und zum Original feststellen können. <br><br>  Dadurch können wir die Filter automatisch testen.  Wir wenden den Filter einfach viele Male an und sehen eines von zwei Dingen: entweder Konvergenz zu einem unveränderten Bild, was darauf hinweist, dass der Filter unendlich stabil ist, oder eine signifikant große Abweichung vom Originalbild, was darauf hinweist, dass der Filter „defekt“ ist.  Für diese Tests habe ich den durchschnittlichen Fehler pro Kanal 64 (von 255) oder den maximalen Fehler auf einem der Kanäle bis zum vollen 255 als "signifikant groß" gewählt. Wenn eine dieser Bedingungen zutrifft, gehen wir davon aus, dass der Filter "kaputt" ist. ". <br><br><h2>  Testen Sie die Filter aus dem ersten Teil erneut </h2><br>  Jetzt verstehen wir besser, wie diese Filter getestet werden. Schauen wir uns also die Filter aus dem ersten Teil genauer an.  Beginnen wir mit einem Bilinear, was natürlich nicht sehr interessant ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/35a/e35/f0235ae35bdf31c9a6ed17f168681836.png" width="1016" height="284"></div><br>  Dies ist ein Bild nach 244 Iterationen.  Wie zu erwarten, "bricht" das Bild aufgrund der konstanten Mittelung der Pixel allmählich.  Aber auch es erreicht allmählich die Grenze des durchschnittlichen Fehlers. <br><br>  Hier ist h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91e/cb8/54b/91ecb854b5c9339b41d803a256176c31.png" width="1016" height="284"></div><br>  Um das Bild zu brechen, reichen ihm 78 Iterationen.  Der HEVC-Filter mit 8 Samples verhält sich etwas besser, bricht aber nach 150 Iterationen immer noch: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/d72/f5a/0add72f5ab060248be682d182abffd92.png" width="1016" height="284"></div><br>  Lanczos mit 6 Proben bricht nach 166 Iterationen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" width="1016" height="284"></div><br>  Das sind alle unsere kaputten Filter.  Alles was bleibt ist mein ganzzahliger Filter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/048/7be/511/0487be5114581255d15aa6f61c03d872.png" width="1016" height="284"></div><br>  Wie erwartet war er <i>nicht der</i> einzige <i>, der</i> brach.  Nach 208 Iterationen konvergiert es zu einem unendlich stabilen Bild. <br><br>  Was wir hier wissen, ist bemerkenswert: Zumindest für eine Vielzahl von Testbildern ist dieser Filter <i>unendlich stabil</i> , dh er erzeugt niemals ein Artefakt, egal wie oft er verwendet wird. <br><br>  Dies bringt uns zurück zu der ursprünglichen Frage: Ist er wirklich der Beste?  Und Sie kennen die Antworten bereits, denn am Anfang des Artikels habe ich auch geschrieben: „wahrscheinlich nicht“ und „definitiv ja“. <br><br>  Schauen wir uns zuerst den Teil „wahrscheinlich nicht“ an. <br><br><h2>  Ganzzahlige Filter </h2><br>  Im ersten Teil des Beitrags erwähnte ich, dass der Filterkern, den ich fand, "der beste der erkannten" war, und dies ist seine Besonderheit.  Und hier ist die Funktion: <br><br>  Als ich nach diesem Filter suchte, suchte ich <i>tatsächlich</i> nicht nach dem <i>besten</i> Filter.  Ich suchte nach dem besten Filter <i>, der mit einer sehr kleinen Anzahl von ganzzahligen Verschiebungen, Additionen und Subtraktionen ausgedrückt werden kann</i> .  Es mag seltsam erscheinen, aber nehmen Sie sich Zeit. <br><br>  Sie haben vielleicht bemerkt, dass ich die Koeffizienten von h.264, HEVC und dem bilinearen Filter sowie meinen Filter als ganzzahlige Zähler über ganzzahlige Nenner wie folgt notiert habe: <br><br><pre><code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Aber im Fall von Fenster-Sinc habe ich anders gehandelt und es so geschrieben: <br><br><pre> <code class="cpp hljs">LanczosKernel[] = {<span class="hljs-number"><span class="hljs-number">0.02446</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.02446</span></span>};</code> </pre> <br>  Der Grund dafür ist, dass Fenster-Sinc tatsächlich aus einer kontinuierlichen mathematischen Funktion abgeleitet wird, die nichts mit gewöhnlichen ganzzahligen Brüchen zu tun hat.  Bei Verwendung dieses Filters werden Gleitkommazahlen (so genau wie möglich) verwendet, die den Werten der sinc-Funktion entsprechen.  Wenn Sie sich bemühen, sie genau anzuwenden, sollten Sie sie nicht auf gewöhnliche Brüche runden, da dies zu einem Fehler führt. <br><br>  Videocodecs können es sich traditionell nicht leisten, solche Vorgänge auszuführen.  Gleitkommaoperationen bei so „schweren“ Aufgaben wie der Bewegungskompensation sind bei Geräten mit geringem Stromverbrauch oder Spezialgeräten einfach nicht möglich.  Dies gilt <i>insbesondere</i> dann, wenn es sich um Codecs nach Industriestandard handelt, die auf einer Vielzahl von Geräten ausgeführt werden sollten, einschließlich kostengünstiger, kostengünstiger eingebetteter Chips. <br><br>  Selbst wenn Sie sie auf der CPU ausführen, basieren moderne Befehlssätze auf SIMD, dh Ganzzahloperationen auf der CPU können immer noch schneller ausgeführt werden: Sie können zwei 16-Bit-Ganzzahlen in den Raum eines 32-Bit-Gleitkommas einfügen, wodurch sich die Leistung von Operationen im Wesentlichen verdoppelt. Wenn wir also die genaue Anzahl der Zyklen pro Operation berücksichtigen, ist ein Gleitkomma nicht immer die schnellste Option. <br><br>  Jetzt sehen Sie, warum diese Funktion wichtig war.  Da ich nur einfache 16-Bit-Ganzzahloperationen benötigte, suchte ich nach den Kerneln, die als kleine Ganzzahlen über Teilern in der Potenz von zwei bis 64 und nicht mehr ausgedrückt werden können.  Dies ist ein viel begrenzterer Satz von Filtern als wenn ich <i>einen</i> Satz von 6 Gleitkommakoeffizienten in Betracht ziehen <i>würde</i> . <br><br>  In ähnlicher Weise habe ich aus Effizienzgründen keine <i>andere</i> Anzahl von Proben berücksichtigt.  Die einzige Option war 6 oder weniger, daher habe ich nicht einmal Versionen mit 8 oder 10 Beispielen getestet. <br><br>  So kamen wir zur ersten Antwort: "wahrscheinlich nicht."  Wenn wir diese Einschränkungen einhalten, werden wir höchstwahrscheinlich keinen besseren Filter finden, der unendlich oft ohne Verschlechterung angewendet werden kann.  Der Filterkern aus dem ersten Teil ist <i>wahrscheinlich der</i> beste, den wir finden können, obwohl ich zugeben muss, dass ich ihn nicht erschöpfend beweisen kann. <br><br>  Aber was ist, wenn wir <i>uns nicht</i> an solche Beschränkungen halten müssen? <br><br><h2>  Gleitkomma-Version </h2><br>  Wenn wir die Einschränkungen für die Originalversion von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bink 2</a> (die mittlerweile ziemlich veraltet ist - seitdem wurden viele Revisionen veröffentlicht) aufheben und beliebige Gleitkommakoeffizienten verwenden, wie stark können die Ergebnisse dann verbessert werden? <br><br>  Nun, da wir wissen, dass sich mein ganzzahliger Kernel niemals verschlechtert und wir wissen, dass Lanczos eine Schärfe aufweist, diese sich jedoch verschlechtert, ist es logisch, dass wir einen Ort <i>zwischen</i> zwei Koeffizientensätzen finden können, an dem die Verschlechterung beginnt.  Also habe ich ein Programm geschrieben, das mir geholfen hat, diesen bestimmten Punkt zu finden, und hier ist der Kernel, den ich gefunden habe: <br><br><pre> <code class="cpp hljs">MyFloatKernel6[] = {<span class="hljs-number"><span class="hljs-number">0.027617</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.027617</span></span>};</code> </pre> <br>  Dieser Kernel benötigt 272 Iterationen, um zu konvergieren, aber er ist unendlich stabil und sieht <i>viel</i> schärfer aus als mein ganzzahliger Filter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/855/81c/e4885581cec995e7aabc0a845ac92868.png" width="1016" height="284"></div><br>  Tatsächlich ist es vom Original kaum zu unterscheiden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Fast ... aber nicht ganz.  Wenn Sie genau hinschauen, können Sie in kontrastreichen Bereichen immer noch Unschärfe und Dämpfung feststellen.  Der einfachste Weg, dies zu sehen, ist im Auge eines orangefarbenen "Dinosauriers" und in hellen Lichtbereichen hinter Bambus. <br><br>  Das heißt, ein Gleitkommafilter mit 6 Abtastwerten ist definitiv besser, aber nicht perfekt.  Kann es noch verbessert werden? <br><br><h2>  Filterbreite erhöhen </h2><br>  Anfangs wurde ein Filter mit 6 Proben aus den gleichen Gründen wie Brüche mit kleinen ganzen Zahlen ausgewählt: Ich suchte nach einem äußerst effizienten Filter.  Aber jetzt forschen wir und sind bereits zu Gleitkommazahlen übergegangen. Warum also nicht einen breiteren Filter in Betracht ziehen? <br><br>  Durch die Kombination unseres 6-Sample-Integer-Filters mit dem 6-Sample-Lanczos haben wir einen sehr guten Filter erhalten.  Warum kombinieren wir es nicht mit den Lanczos mit 8 Stichproben? <br><br>  Der Lanczos mit 8 Stichproben sieht folgendermaßen aus: <br><br><pre> <code class="cpp hljs">Lanczos8[] = {<span class="hljs-number"><span class="hljs-number">-0.01263</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.01263</span></span>};</code> </pre> <br>  Wie der Lanczos mit 6 Stichproben ist er sehr instabil und kollabiert nach 178 Iterationen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c5/38f/1c6/2c538f1c656fbd96798b8e3a82205c11.png" width="1016" height="284"></div><br>  Wenn wir nach einem besseren Filter zwischen einem 6-Sample-Integer-Filter und einem 8-Sample-Lanczos suchen, finden wir diesen bemerkenswerten 8-Sample-Filter: <br><br><pre> <code class="cpp hljs">MyFloatKernel8[] = {<span class="hljs-number"><span class="hljs-number">-0.010547</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.010547</span></span>};</code> </pre> <br>  Als unendlich stabiler Filter arbeitet er erstaunlich gut.  Es konvergiert nach 202 Iterationen (Konvergenz ist schneller als meine beiden Filter) und ähnelt so sehr dem Original, dass es schwierig ist zu erkennen, welcher von ihnen welcher ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" width="1016" height="284"></div><br>  Hier ist noch einmal das Original als Referenz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Im Vergleich zu meinem ursprünglichen Ganzzahlfilter gibt es eine signifikante Verbesserung. <br><br><h2>  Wie funktionieren unendlich stabile Filter? </h2><br>  Ich wollte diesen Beitrag so etwas beenden: <br><br>  "Ich weiß nicht genau, wie das alles funktioniert.  In anderen Bereichen, in denen ich mit den unendlich anwendbaren Transformationen gearbeitet habe, weiß ich, wie Grenzmathematik durchgeführt und nützliche Analysen erstellt werden.  Zunächst geht es um die Analyse der Grenzfläche für Unterteilungsflächen, bei der die Eigenwerte und Eigenvektoren der Unterteilungsmatrix berechnet werden, wonach die Grenze bis zu einem unendlichen Grad genommen werden kann.  Ich habe jedoch keine Erfahrung mit der Durchführung einer solchen Analyse für Halfpel-Filter, da diese Pixel nicht an Ort und Stelle belassen, sondern seitwärts verschieben. " <br><br>  Das war mein Plan.  Aber zwischen dem Schreiben des ersten und zweiten Teils schickte ich die Ergebnisse des verbesserten Filters an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fabien Giessen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Charles Bloom</a> .  Es ist nicht überraschend, dass <i>sie</i> die Mathematik kannten, die für die analytische Untersuchung dieses Problems erforderlich ist.  Es stellte sich heraus, dass es für Filter tatsächlich eine Analyse von Eigenwerten und Vektoren gibt, aber das funktioniert nicht ganz so. <br><br>  Aber es <i>kann</i> leicht ausgeführt werden - tatsächlich ist es als trivialer Ein-Schritt-Prozess in CAM-Programme integriert, und wir können die Eigenwerte für Filter wirklich betrachten.  Er gibt uns keine vollständigen Antworten, da hier die Tatsache des <i>Rundens</i> (oder Abschneidens) auf 8 Bit (oder 10 Bit oder 12 Bit) nach jeder Filterung wichtig ist, da das Abschneiden die Methode der Fehlerakkumulation im Vergleich zur unendlich genauen Algebra beeinflusst. <br><br>  Da dies überhaupt nicht mein Fachgebiet ist, kann ich mir leider nicht einmal einen genauen Überblick über diese Analyse verschaffen.  Ich fragte Fabien und Charles, ob sie Posts mit den guten Informationen schreiben könnten, die sie mir per E-Mail geschickt hatten (beide haben technische Blogs - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Ryg-Blog</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cbloom Rants</a> ), und Fabien schrieb eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgezeichnete Artikelserie über die mathematischen Grundlagen stabiler Filter</a> .  Wenn Sie an der theoretischen Struktur meiner beiden Beiträge interessiert sind, empfehle ich Ihnen, diese Reihe zu lesen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468629/">https://habr.com/ru/post/de468629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468615/index.html">Die Top 10 Sprachen für die App-Lokalisierung</a></li>
<li><a href="../de468621/index.html">Wir übersetzen das Heimnetzwerk in DoH oder einen weiteren Klick auf die Filternase</a></li>
<li><a href="../de468623/index.html">Ich möchte Bewertungen zu Habr</a></li>
<li><a href="../de468625/index.html">Serverlos: 15% langsamer und achtmal teurer</a></li>
<li><a href="../de468627/index.html">ADAM-6200 E / A-Module</a></li>
<li><a href="../de468631/index.html">Testen von Flatteranwendungen. Starten Sie</a></li>
<li><a href="../de468635/index.html">Übergangsmetall-Dichalkogenide: Enthüllung der Geheimnisse des WS2-Kristallwachstums</a></li>
<li><a href="../de468637/index.html">Umgang mit großen Datenmengen in Pandas. Wir arbeiten mit der FIAS-Datenbank unter Verwendung von Python und 8 GB Speicher</a></li>
<li><a href="../de468639/index.html">Was ist neu in Webkonsolen 2019</a></li>
<li><a href="../de468641/index.html">Tutorial zum Erstellen einer Blockchain-Lösung in Hyperledger Composer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>