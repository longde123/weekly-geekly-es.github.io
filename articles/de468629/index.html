<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèª üí§ ü•ß Wie ich einen Filter erstellt habe, der das Bild auch nach einer Million L√§ufen nicht besch√§digt - Teil 2 ü§∂üèæ üíÖüèΩ üìÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil dieses Beitrags habe ich dar√ºber gesprochen, wie die wiederholte Verwendung von Standard-Halfpel-Filtern zu verzerrten Bildern f√ºhrt, u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ich einen Filter erstellt habe, der das Bild auch nach einer Million L√§ufen nicht besch√§digt - Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468629/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" alt="Bild"></div><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil</a> dieses Beitrags habe ich dar√ºber gesprochen, wie die wiederholte Verwendung von Standard-Halfpel-Filtern zu verzerrten Bildern f√ºhrt, und dann einen neuen Filter gezeigt, bei dem dieses Problem nicht auftritt. <br><br>  Es war etwas verschwommener und das w√ºrde nicht jedem passen.  Es war jedoch besser als seine Alternativen - tats√§chlich wurde dieser Filter in der Originalversion von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bink 2 verwendet</a> .  Aufgrund der st√§ndigen Arbeitsbelastung gelang es mir nie wieder, zu ihm zur√ºckzukehren und ihn genauer zu untersuchen. <br><br>  Aber jetzt, da ich <i>die</i> Zeit gefunden habe, zu diesem Filter zur√ºckzukehren und einen Artikel dar√ºber zu schreiben, sollte ich endlich die Frage stellen: Gibt es einen <i>weniger unscharfen</i> Filter, der immer noch die Eigenschaft ‚Äûunendliche Stabilit√§t‚Äú beibeh√§lt? <br><br>  Spoiler-Warnung: Die richtige Antwort lautet "wahrscheinlich nicht" und "definitiv da".  Bevor wir jedoch herausfinden, warum es zwei Antworten auf diese Frage gibt und was sie bedeuten, sollten wir den Pr√ºfstand besser vorbereiten. <br><a name="habracut"></a><br><h2>  Offset-Einstellung </h2><br>  Als ich anf√§nglich an diesem Problem arbeitete, hatte ich keine Ahnung, wonach ich suchte.  Ich wusste nicht einmal, dass <i>es</i> so etwas wie einen ‚Äûunendlich stabilen‚Äú Halbpel-Filter gibt, also habe ich bei seiner Suche kein System erstellt.  Ich war nur auf der Suche nach etwas, das den ‚Äûvielen‚Äú Filteriterationen ohne Bildverzerrung standh√§lt.  Alle Bilder aus dem ersten Teil spiegeln diese Methode wider: Das Bild wird jeweils um ein halbes Pixel von rechts nach links verschoben. Wenn Sie den Filter also 100 Mal anwenden, wird das resultierende Bild um 50 Pixel verschoben. <br><br>  Jetzt, da wir wissen, wonach wir <i>tats√§chlich</i> suchen, k√∂nnen wir etwas genauer sein.  Wenn Sie den Halfpel-Filter zweimal anwenden, verschieben wir das Bild genau um ein Pixel.  Das hei√üt, wenn wir <i>das Bild</i> einfach <i>um ein Pixel zur√ºck verschieben</i> , bleibt es im selben Raum.  Dank dessen sieht der Test viel sch√∂ner aus, da wir dann den Filter nicht nur beliebig oft anwenden k√∂nnen, ohne bef√ºrchten zu m√ºssen, dass das Bild vom Bildschirm "wegkriecht", sondern auch den <i>Unterschied des</i> Bildes zu fr√ºheren Versionen und zum Original feststellen k√∂nnen. <br><br>  Dadurch k√∂nnen wir die Filter automatisch testen.  Wir wenden den Filter einfach viele Male an und sehen eines von zwei Dingen: entweder Konvergenz zu einem unver√§nderten Bild, was darauf hinweist, dass der Filter unendlich stabil ist, oder eine signifikant gro√üe Abweichung vom Originalbild, was darauf hinweist, dass der Filter ‚Äûdefekt‚Äú ist.  F√ºr diese Tests habe ich den durchschnittlichen Fehler pro Kanal 64 (von 255) oder den maximalen Fehler auf einem der Kan√§le bis zum vollen 255 als "signifikant gro√ü" gew√§hlt. Wenn eine dieser Bedingungen zutrifft, gehen wir davon aus, dass der Filter "kaputt" ist. ". <br><br><h2>  Testen Sie die Filter aus dem ersten Teil erneut </h2><br>  Jetzt verstehen wir besser, wie diese Filter getestet werden. Schauen wir uns also die Filter aus dem ersten Teil genauer an.  Beginnen wir mit einem Bilinear, was nat√ºrlich nicht sehr interessant ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/35a/e35/f0235ae35bdf31c9a6ed17f168681836.png" width="1016" height="284"></div><br>  Dies ist ein Bild nach 244 Iterationen.  Wie zu erwarten, "bricht" das Bild aufgrund der konstanten Mittelung der Pixel allm√§hlich.  Aber auch es erreicht allm√§hlich die Grenze des durchschnittlichen Fehlers. <br><br>  Hier ist h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91e/cb8/54b/91ecb854b5c9339b41d803a256176c31.png" width="1016" height="284"></div><br>  Um das Bild zu brechen, reichen ihm 78 Iterationen.  Der HEVC-Filter mit 8 Samples verh√§lt sich etwas besser, bricht aber nach 150 Iterationen immer noch: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/d72/f5a/0add72f5ab060248be682d182abffd92.png" width="1016" height="284"></div><br>  Lanczos mit 6 Proben bricht nach 166 Iterationen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" width="1016" height="284"></div><br>  Das sind alle unsere kaputten Filter.  Alles was bleibt ist mein ganzzahliger Filter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/048/7be/511/0487be5114581255d15aa6f61c03d872.png" width="1016" height="284"></div><br>  Wie erwartet war er <i>nicht der</i> einzige <i>, der</i> brach.  Nach 208 Iterationen konvergiert es zu einem unendlich stabilen Bild. <br><br>  Was wir hier wissen, ist bemerkenswert: Zumindest f√ºr eine Vielzahl von Testbildern ist dieser Filter <i>unendlich stabil</i> , dh er erzeugt niemals ein Artefakt, egal wie oft er verwendet wird. <br><br>  Dies bringt uns zur√ºck zu der urspr√ºnglichen Frage: Ist er wirklich der Beste?  Und Sie kennen die Antworten bereits, denn am Anfang des Artikels habe ich auch geschrieben: ‚Äûwahrscheinlich nicht‚Äú und ‚Äûdefinitiv ja‚Äú. <br><br>  Schauen wir uns zuerst den Teil ‚Äûwahrscheinlich nicht‚Äú an. <br><br><h2>  Ganzzahlige Filter </h2><br>  Im ersten Teil des Beitrags erw√§hnte ich, dass der Filterkern, den ich fand, "der beste der erkannten" war, und dies ist seine Besonderheit.  Und hier ist die Funktion: <br><br>  Als ich nach diesem Filter suchte, suchte ich <i>tats√§chlich</i> nicht nach dem <i>besten</i> Filter.  Ich suchte nach dem besten Filter <i>, der mit einer sehr kleinen Anzahl von ganzzahligen Verschiebungen, Additionen und Subtraktionen ausgedr√ºckt werden kann</i> .  Es mag seltsam erscheinen, aber nehmen Sie sich Zeit. <br><br>  Sie haben vielleicht bemerkt, dass ich die Koeffizienten von h.264, HEVC und dem bilinearen Filter sowie meinen Filter als ganzzahlige Z√§hler √ºber ganzzahlige Nenner wie folgt notiert habe: <br><br><pre><code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Aber im Fall von Fenster-Sinc habe ich anders gehandelt und es so geschrieben: <br><br><pre> <code class="cpp hljs">LanczosKernel[] = {<span class="hljs-number"><span class="hljs-number">0.02446</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.02446</span></span>};</code> </pre> <br>  Der Grund daf√ºr ist, dass Fenster-Sinc tats√§chlich aus einer kontinuierlichen mathematischen Funktion abgeleitet wird, die nichts mit gew√∂hnlichen ganzzahligen Br√ºchen zu tun hat.  Bei Verwendung dieses Filters werden Gleitkommazahlen (so genau wie m√∂glich) verwendet, die den Werten der sinc-Funktion entsprechen.  Wenn Sie sich bem√ºhen, sie genau anzuwenden, sollten Sie sie nicht auf gew√∂hnliche Br√ºche runden, da dies zu einem Fehler f√ºhrt. <br><br>  Videocodecs k√∂nnen es sich traditionell nicht leisten, solche Vorg√§nge auszuf√ºhren.  Gleitkommaoperationen bei so ‚Äûschweren‚Äú Aufgaben wie der Bewegungskompensation sind bei Ger√§ten mit geringem Stromverbrauch oder Spezialger√§ten einfach nicht m√∂glich.  Dies gilt <i>insbesondere</i> dann, wenn es sich um Codecs nach Industriestandard handelt, die auf einer Vielzahl von Ger√§ten ausgef√ºhrt werden sollten, einschlie√ülich kosteng√ºnstiger, kosteng√ºnstiger eingebetteter Chips. <br><br>  Selbst wenn Sie sie auf der CPU ausf√ºhren, basieren moderne Befehlss√§tze auf SIMD, dh Ganzzahloperationen auf der CPU k√∂nnen immer noch schneller ausgef√ºhrt werden: Sie k√∂nnen zwei 16-Bit-Ganzzahlen in den Raum eines 32-Bit-Gleitkommas einf√ºgen, wodurch sich die Leistung von Operationen im Wesentlichen verdoppelt. Wenn wir also die genaue Anzahl der Zyklen pro Operation ber√ºcksichtigen, ist ein Gleitkomma nicht immer die schnellste Option. <br><br>  Jetzt sehen Sie, warum diese Funktion wichtig war.  Da ich nur einfache 16-Bit-Ganzzahloperationen ben√∂tigte, suchte ich nach den Kerneln, die als kleine Ganzzahlen √ºber Teilern in der Potenz von zwei bis 64 und nicht mehr ausgedr√ºckt werden k√∂nnen.  Dies ist ein viel begrenzterer Satz von Filtern als wenn ich <i>einen</i> Satz von 6 Gleitkommakoeffizienten in Betracht ziehen <i>w√ºrde</i> . <br><br>  In √§hnlicher Weise habe ich aus Effizienzgr√ºnden keine <i>andere</i> Anzahl von Proben ber√ºcksichtigt.  Die einzige Option war 6 oder weniger, daher habe ich nicht einmal Versionen mit 8 oder 10 Beispielen getestet. <br><br>  So kamen wir zur ersten Antwort: "wahrscheinlich nicht."  Wenn wir diese Einschr√§nkungen einhalten, werden wir h√∂chstwahrscheinlich keinen besseren Filter finden, der unendlich oft ohne Verschlechterung angewendet werden kann.  Der Filterkern aus dem ersten Teil ist <i>wahrscheinlich der</i> beste, den wir finden k√∂nnen, obwohl ich zugeben muss, dass ich ihn nicht ersch√∂pfend beweisen kann. <br><br>  Aber was ist, wenn wir <i>uns nicht</i> an solche Beschr√§nkungen halten m√ºssen? <br><br><h2>  Gleitkomma-Version </h2><br>  Wenn wir die Einschr√§nkungen f√ºr die Originalversion von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bink 2</a> (die mittlerweile ziemlich veraltet ist - seitdem wurden viele Revisionen ver√∂ffentlicht) aufheben und beliebige Gleitkommakoeffizienten verwenden, wie stark k√∂nnen die Ergebnisse dann verbessert werden? <br><br>  Nun, da wir wissen, dass sich mein ganzzahliger Kernel niemals verschlechtert und wir wissen, dass Lanczos eine Sch√§rfe aufweist, diese sich jedoch verschlechtert, ist es logisch, dass wir einen Ort <i>zwischen</i> zwei Koeffizientens√§tzen finden k√∂nnen, an dem die Verschlechterung beginnt.  Also habe ich ein Programm geschrieben, das mir geholfen hat, diesen bestimmten Punkt zu finden, und hier ist der Kernel, den ich gefunden habe: <br><br><pre> <code class="cpp hljs">MyFloatKernel6[] = {<span class="hljs-number"><span class="hljs-number">0.027617</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.027617</span></span>};</code> </pre> <br>  Dieser Kernel ben√∂tigt 272 Iterationen, um zu konvergieren, aber er ist unendlich stabil und sieht <i>viel</i> sch√§rfer aus als mein ganzzahliger Filter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/855/81c/e4885581cec995e7aabc0a845ac92868.png" width="1016" height="284"></div><br>  Tats√§chlich ist es vom Original kaum zu unterscheiden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Fast ... aber nicht ganz.  Wenn Sie genau hinschauen, k√∂nnen Sie in kontrastreichen Bereichen immer noch Unsch√§rfe und D√§mpfung feststellen.  Der einfachste Weg, dies zu sehen, ist im Auge eines orangefarbenen "Dinosauriers" und in hellen Lichtbereichen hinter Bambus. <br><br>  Das hei√üt, ein Gleitkommafilter mit 6 Abtastwerten ist definitiv besser, aber nicht perfekt.  Kann es noch verbessert werden? <br><br><h2>  Filterbreite erh√∂hen </h2><br>  Anfangs wurde ein Filter mit 6 Proben aus den gleichen Gr√ºnden wie Br√ºche mit kleinen ganzen Zahlen ausgew√§hlt: Ich suchte nach einem √§u√üerst effizienten Filter.  Aber jetzt forschen wir und sind bereits zu Gleitkommazahlen √ºbergegangen. Warum also nicht einen breiteren Filter in Betracht ziehen? <br><br>  Durch die Kombination unseres 6-Sample-Integer-Filters mit dem 6-Sample-Lanczos haben wir einen sehr guten Filter erhalten.  Warum kombinieren wir es nicht mit den Lanczos mit 8 Stichproben? <br><br>  Der Lanczos mit 8 Stichproben sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs">Lanczos8[] = {<span class="hljs-number"><span class="hljs-number">-0.01263</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.01263</span></span>};</code> </pre> <br>  Wie der Lanczos mit 6 Stichproben ist er sehr instabil und kollabiert nach 178 Iterationen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c5/38f/1c6/2c538f1c656fbd96798b8e3a82205c11.png" width="1016" height="284"></div><br>  Wenn wir nach einem besseren Filter zwischen einem 6-Sample-Integer-Filter und einem 8-Sample-Lanczos suchen, finden wir diesen bemerkenswerten 8-Sample-Filter: <br><br><pre> <code class="cpp hljs">MyFloatKernel8[] = {<span class="hljs-number"><span class="hljs-number">-0.010547</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.010547</span></span>};</code> </pre> <br>  Als unendlich stabiler Filter arbeitet er erstaunlich gut.  Es konvergiert nach 202 Iterationen (Konvergenz ist schneller als meine beiden Filter) und √§hnelt so sehr dem Original, dass es schwierig ist zu erkennen, welcher von ihnen welcher ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" width="1016" height="284"></div><br>  Hier ist noch einmal das Original als Referenz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Im Vergleich zu meinem urspr√ºnglichen Ganzzahlfilter gibt es eine signifikante Verbesserung. <br><br><h2>  Wie funktionieren unendlich stabile Filter? </h2><br>  Ich wollte diesen Beitrag so etwas beenden: <br><br>  "Ich wei√ü nicht genau, wie das alles funktioniert.  In anderen Bereichen, in denen ich mit den unendlich anwendbaren Transformationen gearbeitet habe, wei√ü ich, wie Grenzmathematik durchgef√ºhrt und n√ºtzliche Analysen erstellt werden.  Zun√§chst geht es um die Analyse der Grenzfl√§che f√ºr Unterteilungsfl√§chen, bei der die Eigenwerte und Eigenvektoren der Unterteilungsmatrix berechnet werden, wonach die Grenze bis zu einem unendlichen Grad genommen werden kann.  Ich habe jedoch keine Erfahrung mit der Durchf√ºhrung einer solchen Analyse f√ºr Halfpel-Filter, da diese Pixel nicht an Ort und Stelle belassen, sondern seitw√§rts verschieben. " <br><br>  Das war mein Plan.  Aber zwischen dem Schreiben des ersten und zweiten Teils schickte ich die Ergebnisse des verbesserten Filters an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fabien Giessen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Charles Bloom</a> .  Es ist nicht √ºberraschend, dass <i>sie</i> die Mathematik kannten, die f√ºr die analytische Untersuchung dieses Problems erforderlich ist.  Es stellte sich heraus, dass es f√ºr Filter tats√§chlich eine Analyse von Eigenwerten und Vektoren gibt, aber das funktioniert nicht ganz so. <br><br>  Aber es <i>kann</i> leicht ausgef√ºhrt werden - tats√§chlich ist es als trivialer Ein-Schritt-Prozess in CAM-Programme integriert, und wir k√∂nnen die Eigenwerte f√ºr Filter wirklich betrachten.  Er gibt uns keine vollst√§ndigen Antworten, da hier die Tatsache des <i>Rundens</i> (oder Abschneidens) auf 8 Bit (oder 10 Bit oder 12 Bit) nach jeder Filterung wichtig ist, da das Abschneiden die Methode der Fehlerakkumulation im Vergleich zur unendlich genauen Algebra beeinflusst. <br><br>  Da dies √ºberhaupt nicht mein Fachgebiet ist, kann ich mir leider nicht einmal einen genauen √úberblick √ºber diese Analyse verschaffen.  Ich fragte Fabien und Charles, ob sie Posts mit den guten Informationen schreiben k√∂nnten, die sie mir per E-Mail geschickt hatten (beide haben technische Blogs - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Ryg-Blog</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cbloom Rants</a> ), und Fabien schrieb eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgezeichnete Artikelserie √ºber die mathematischen Grundlagen stabiler Filter</a> .  Wenn Sie an der theoretischen Struktur meiner beiden Beitr√§ge interessiert sind, empfehle ich Ihnen, diese Reihe zu lesen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468629/">https://habr.com/ru/post/de468629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468615/index.html">Die Top 10 Sprachen f√ºr die App-Lokalisierung</a></li>
<li><a href="../de468621/index.html">Wir √ºbersetzen das Heimnetzwerk in DoH oder einen weiteren Klick auf die Filternase</a></li>
<li><a href="../de468623/index.html">Ich m√∂chte Bewertungen zu Habr</a></li>
<li><a href="../de468625/index.html">Serverlos: 15% langsamer und achtmal teurer</a></li>
<li><a href="../de468627/index.html">ADAM-6200 E / A-Module</a></li>
<li><a href="../de468631/index.html">Testen von Flatteranwendungen. Starten Sie</a></li>
<li><a href="../de468635/index.html">√úbergangsmetall-Dichalkogenide: Enth√ºllung der Geheimnisse des WS2-Kristallwachstums</a></li>
<li><a href="../de468637/index.html">Umgang mit gro√üen Datenmengen in Pandas. Wir arbeiten mit der FIAS-Datenbank unter Verwendung von Python und 8 GB Speicher</a></li>
<li><a href="../de468639/index.html">Was ist neu in Webkonsolen 2019</a></li>
<li><a href="../de468641/index.html">Tutorial zum Erstellen einer Blockchain-L√∂sung in Hyperledger Composer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>