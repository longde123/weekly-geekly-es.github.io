<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî≥ ü§öüèæ ü§î Besprechungsraum LÃ∂iÃ∂tÃ∂tÃ∂lÃ∂eÃ∂ Helfer v 2 üõí üòÇ üôÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden die Entwicklungsphasen der mobilen Meeting Room Helper-Anwendung ausf√ºhrlich beschrieben: von der Idee bis zur Ver√∂ffentlichu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Besprechungsraum LÃ∂iÃ∂tÃ∂tÃ∂lÃ∂eÃ∂ Helfer v 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/457960/">  In diesem Artikel werden die Entwicklungsphasen der mobilen Meeting Room Helper-Anwendung ausf√ºhrlich beschrieben: von der Idee bis zur Ver√∂ffentlichung.  Die Anwendung ist in Kotlin geschrieben und basiert auf einer vereinfachten MVVM-Architektur ohne Datenbindung.  Der UI-Teil wird mithilfe von LiveData-Objekten aktualisiert.  Die Gr√ºnde f√ºr die Verweigerung der Datenbindung werden detailliert und erl√§utert.  Die Architektur verwendet eine Reihe interessanter L√∂sungen, die es erm√∂glichen, das Programm logisch in kleine Dateien aufzuteilen, was letztendlich die Codeunterst√ºtzung vereinfacht. <br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><img src="https://habrastorage.org/webt/ii/at/pf/iiatpf_m3syq_8mzu08bkaqiy4u.jpeg"><br><a name="habracut"></a><br><h2>  Projektbeschreibung </h2><br>  Vor 3 Jahren kam in unserem Unternehmen die Idee auf, ein kleines Projekt zur sofortigen Buchung von Tagungsr√§umen zu entwickeln.  Die meisten Personalmanager und Arcadia bevorzugen es, den Outlook-Kalender f√ºr solche Zwecke zu verwenden, aber was ist mit dem Rest? <br><br>  Ich werde 2 Beispiele aus dem Leben des Entwicklers geben <br><br><ol><li>  <i>Jedes Team hat regelm√§√üig den spontanen Wunsch, eine schnelle Rallye f√ºr 5-10 Minuten abzuhalten.</i>  <i>Dieser Wunsch kann Entwickler in jeder Ecke des B√ºros √ºberholen, und um Kollegen in ihrer Umgebung nicht abzulenken, suchen sie (Entwickler und nicht nur) nach einem freien Gespr√§ch.</i>  <i>Bei der Migration von Raum zu Raum (in unserem B√ºro sind die Besprechungsr√§ume in einer Reihe angeordnet) √ºberpr√ºfen die Kollegen sorgf√§ltig, welcher der R√§ume derzeit frei ist.</i>  <i>Infolgedessen lenken sie Kollegen im Inneren ab.</i>  <i>Solche Leute waren und werden es immer sein, auch wenn die Dreharbeiten in der Unternehmenscharta wegen Unterbrechung der Rallye beendet sind.</i>  <i>Wer verstanden hat, wird verstehen.</i> </li><li>  <i>Und hier ist ein anderer Fall.</i>  <i>Sie haben gerade den Speisesaal verlassen und gehen zu sich selbst, aber hier f√§ngt Sie Ihr Kollege (oder Manager) aus einer anderen Abteilung ab.</i>  <i>Er m√∂chte Ihnen etwas Dringendes sagen, und f√ºr diese Zwecke ben√∂tigen Sie einen Besprechungsraum.</i>  <i>Gem√§√ü den Vorschriften m√ºssen Sie zuerst ein Zimmer (von Ihrem Telefon oder Computer) buchen und erst dann belegen.</i>  <i>Es ist gut, wenn Sie ein Mobiltelefon mit mobilem Outlook haben.</i>  <i>Und wenn nicht?</i>  <i>Zur√ºck zum Computer, dann wieder zum Besprechungsraum zur√ºckkehren?</i>  <i>Um jeden Mitarbeiter zu zwingen, Outlook Express auf das Telefon zu setzen und sicherzustellen, dass jeder die Telefone mit sich f√ºhrt?</i>  <i>Dies sind nicht unsere Methoden.</i> </li></ol><br>  Deshalb wurde vor 2,5 Jahren jeder Tagungsraum mit einem eigenen Tablet ausgestattet: <br><br><img src="https://habrastorage.org/webt/kp/2i/ao/kp2iao0nromcb1wa-iewgzxurw0.png"><br><br>  F√ºr dieses Projekt hat mein Kollege die erste Version der Anwendung entwickelt: Meeting Room Little Helper ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier k√∂nnen Sie dar√ºber lesen</a> ).  MRLH, das eine Reservierung buchen, eine Reservierung stornieren und erneuern durfte, zeigte den Status der verbleibenden Gespr√§che an.  Das Erkennen der Identit√§t eines Mitarbeiters (mithilfe des Microsoft Face API-Clouddiensts und unserer internen Analyseger√§te) ist zu einem innovativen ‚ÄûTrick‚Äú geworden.  Die Bewerbung erwies sich als solide und diente dem Unternehmen 2,5 Jahre lang treu. <br><br>  Aber die Zeit verging ... Neue Ideen erschienen.  Ich wollte etwas Frisches, und so beschlossen wir, die Anwendung neu zu schreiben. <br><br><h3>  Technische Aufgabe </h3><br>  Wie so oft - aber leider nicht immer - begann die Entwicklung mit der Erstellung technischer Spezifikationen.  Zuerst haben wir die Leute angerufen, die am h√§ufigsten Tablets f√ºr Reservierungen verwenden.  Es war einfach so, dass sie vor allem von HRs und Managern abh√§ngig waren, die zuvor ausschlie√ülich Outlook verwendet hatten.  Von ihnen erhielten wir das folgende Feedback (aus den Anforderungen geht sofort hervor, wonach die Personalabteilung und die Manager gefragt haben): <br><br><ul><li>  Sie m√ºssen die M√∂glichkeit hinzuf√ºgen, einen beliebigen Besprechungsraum von einem beliebigen Tablet aus zu buchen (zuvor konnten Sie auf jedem Tablet nur Ihren Raum buchen). </li><li>  Es w√§re cool, sich den Zeitplan der Kundgebungen f√ºr ein ganzt√§giges Treffen anzusehen (idealerweise f√ºr jeden Tag). </li><li>  Der gesamte Entwicklungszyklus muss in kurzer Zeit (f√ºr 6-7 Wochen) durchgef√ºhrt werden. </li></ul><br>  Mit den Kundenw√ºnschen ist alles klar, aber was ist mit den technischen Anforderungen und der Zukunft?  F√ºgen Sie der Entwicklergilde einige Anforderungen f√ºr das Projekt hinzu: <br><br><ul><li>  Das System sollte sowohl mit vorhandenen als auch mit neuen Tablets funktionieren. </li><li>  Skalierbarkeit des Systems - ab 50 Konversationen (dies sollte f√ºr die meisten Kunden mit einem Spielraum ausreichen, wenn das System mit der Replikation beginnt); </li><li>  Beibehaltung der vorherigen Funktionalit√§t (die erste Version der Anwendung verwendete die Java-API f√ºr die Kommunikation mit Outlook-Diensten, und wir planten, sie durch eine spezielle Microsoft Graph-API zu ersetzen, sodass es wichtig war, die Funktionalit√§t nicht zu verlieren); </li><li>  Minimierung des Energieverbrauchs (Tablets werden von einer externen Batterie gespeist, da das Business Center das Bohren seiner W√§nde zum Verlegen unserer Dr√§hte nicht zulie√ü); </li><li>  neues UX / UI-Design, das alle Innovationen ergonomisch widerspiegelt. </li></ul><br>  Insgesamt 8 Punkte.  Die Anforderungen sind ziemlich fair.  Zus√§tzlich legen wir die allgemeinen Entwicklungsregeln fest: <br><br><ul><li>  Verwenden Sie nur fortschrittliche Technologien (dies erm√∂glicht es dem Team, sich als Spezialisten zu entwickeln und nicht an einem Ort zu stagnieren, w√§hrend die Projektunterst√ºtzung in absehbarer Zukunft vereinfacht wird). </li><li>  Befolgen Sie die Best Practices, aber halten Sie sie nicht blind f√ºr selbstverst√§ndlich  Die Hauptregel eines jeden Profis (und eines Entwicklers, der danach strebt) ist, alles kritisch zu bewerten. </li><li>  Schreiben von sauberem und ordentlichem Code (dies ist m√∂glicherweise am schwierigsten, wenn Sie versuchen, Innovation und enge Entwicklungszeit zu kombinieren). </li></ul><br>  Ein Anfang wurde gemacht.  Es ist wie immer begeistert!  Mal sehen, was als n√§chstes passiert. <br><br><h3>  Design </h3><br>  Vom UX-Designer entwickeltes Anwendungsdesign: <br><br><img src="https://habrastorage.org/webt/gm/n9/eo/gmn9eox4exzhczkq0zdbkiwrgt8.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Dies ist der Hauptbildschirm.  Es wird die meiste Zeit angezeigt.  Alle notwendigen Informationen finden Sie hier ergonomisch: <br><br><ul><li>  den Namen des Raumes und seine Nummer; </li><li>  aktueller Status; </li><li>  Zeit bis zum n√§chsten Treffen (oder bis zu seinem Ende); </li><li>  den Status der verbleibenden R√§ume am unteren Bildschirmrand. </li></ul><br>  Bitte beachten Sie: Auf dem Zifferblatt werden nur 12 Stunden angezeigt  Das System ist auf die Anforderungen des Unternehmens konfiguriert (Arcadia-Tablets funktionieren von 8 bis 20 Uhr, werden automatisch ein- und ausgeschaltet). <br><br><img src="https://habrastorage.org/webt/cg/r_/92/cgr_9220jaeqzpjtu4godm1vojw.gif"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Um ein Zimmer zu buchen, rufen Sie einfach das Buchungsfenster an und geben Sie die Dauer der Rallye an.  Die Schritte zum Buchen der verbleibenden Zimmer sind √§hnlich. Sie beginnen erst mit einem Klick auf das Zimmersymbol. <br><br><img src="https://habrastorage.org/webt/d7/qr/wm/d7qrwmogkdzvjtdea0y80vjlti4.jpeg"><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Wenn Sie eine Besprechung f√ºr eine bestimmte Zeit planen m√∂chten, wechseln Sie zur n√§chsten Registerkarte in der Liste der Besprechungen, die heute im Besprechungsraum stattfinden, und klicken Sie auf Freizeit.  Weiter ist alles wie im ersten Fall. <br><br>  Der vollst√§ndige √úbergangsbaum sollte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><img src="https://habrastorage.org/webt/p8/ex/lb/p8exlbbiuflfbasflet3vsepzdu.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Versuchen wir es kompetent umzusetzen. <br><br><h3>  Technologie-Stack </h3><br>  Entwicklungstechniken entwickeln sich ziemlich schnell und √§ndern sich.  F√ºr weitere 2 Jahre war Java die offizielle Android-Entwicklungssprache.  Jeder schrieb in Java und verwendete Datenbindung.  Nun, so scheint es mir, bewegen wir uns in Richtung reaktiver Programmierung und Kotlin.  Java ist eine gro√üartige Sprache, weist jedoch einige M√§ngel auf, verglichen mit dem, was Kotlin und AndroidX zu bieten haben.  Kotlin und AndroidX k√∂nnen die Verwendung der Datenbindung auf ein Minimum reduzieren, wenn nicht sogar vollst√§ndig ausschlie√üen.  Im Folgenden werde ich versuchen, meinen Standpunkt zu erl√§utern. <br><br><h4>  Kotlin </h4><br>  Ich denke, viele Android-Entwickler sind bereits zu Kotlin gewechselt, und deshalb werden sie mir zustimmen, dass das Schreiben eines neuen Android-Projekts im Jahr 2019 in einer anderen Sprache als Kotlin dem Kampf gegen das Meer gleicht.  Nat√ºrlich k√∂nnen Sie streiten, aber was ist mit Flutter und Dart?  Was ist mit C ++, C # und sogar Cordova?  Worauf ich antworten werde: Die Wahl liegt immer bei Ihnen. <br><br>  480 v  Der persische K√∂nig Xerxes befahl seinen Soldaten, das Meer zu √ºberqueren, um einen Teil seiner Armee w√§hrend eines Sturms zu zerst√∂ren. F√ºnf Jahrhunderte sp√§ter erkl√§rte der r√∂mische Kaiser Caligula Poseidon den Krieg.  Geschmackssache.  F√ºr 9 von 10 ist Kotlin gut, aber f√ºr 10 kann es schlecht sein.  Es h√§ngt alles von Ihnen ab, von Ihren W√ºnschen und Bestrebungen. <br><br>  Kotlin ist meine Wahl.  Die Sprache ist einfach und sch√∂n.  Das Schreiben darauf ist einfach und angenehm, und vor allem muss nicht zu viel geschrieben werden: Datenklasse, Objekt, optionaler Setter und Getter, einfache Lambda-Ausdr√ºcke und Erweiterungsfunktionen.  Dies ist nur ein winziger Teil dessen, was diese Sprache zu bieten hat.  Wenn Sie noch nicht zu Kotlin gewechselt sind, k√∂nnen Sie loslegen!  Im Abschnitt mit √úbung werde ich einige der Vorteile der Sprache demonstrieren (es ist kein Werbeangebot). <br><br><h4>  Model-View-ViewModel </h4><br>  MVVM ist derzeit die empfohlene Anwendungsarchitektur von Google.  W√§hrend der Entwicklung werden wir uns an dieses spezielle Muster halten, es jedoch nicht vollst√§ndig einhalten, da MVVM die Verwendung der Datenbindung empfiehlt, wir es jedoch ablehnen. <br><br>  <i><b>Vorteile von MVVM</b></i> <br><br><ul><li>  <i>Differenzierung von Gesch√§ftslogik und Benutzeroberfl√§che.</i>  Bei der korrekten Implementierung von MVVM sollte in ViewModel kein einziger Android-Import vorhanden sein, au√üer f√ºr LiveData-Objekte aus AndroidX- oder Jetpack-Paketen.  Bei ordnungsgem√§√üer Verwendung bleiben alle UI-Arbeiten automatisch in Fragmenten und Aktivit√§ten.  Ist das nicht toll? </li><li>  <i>Der Einkapselungsgrad wird gepumpt.</i>  Es wird einfacher sein, als Team zu arbeiten: Jetzt k√∂nnen Sie alle auf einem Bildschirm zusammenarbeiten und sich nicht gegenseitig st√∂ren.  W√§hrend ein Entwickler mit dem Bildschirm arbeitet, kann ein anderer ein ViewModel erstellen und ein dritter kann Abfragen in das Repository schreiben. </li><li>  <i>MVVM wirkt sich positiv auf das Schreiben von Unit-Tests aus.</i>  Dieser Punkt folgt aus dem vorherigen.  Wenn alle Klassen und Methoden f√ºr die Arbeit mit der Benutzeroberfl√§che gekapselt sind, k√∂nnen sie problemlos getestet werden. </li><li>  <i>Eine nat√ºrliche L√∂sung mit Bildschirmrotation.</i>  Egal wie seltsam es auch klingen mag, diese Funktion wird beim √úbergang zu MVVM automatisch erfasst (da die Daten im ViewModel gespeichert sind).  Wenn Sie die recht beliebten Anwendungen (VK, Telegramm, Sberbank-Online und Aviasales) √ºberpr√ºfen, stellt sich heraus, dass genau die H√§lfte von ihnen den Bildschirm nicht drehen kann.  Was mich als Benutzer dieser Anwendungen √ºberrascht und missversteht. </li></ul><br>  <i><b>Warum ist MVVM gef√§hrlich?</b></i> <br><br><ul><li>  <i>Speicherverlust.</i>  Dieser gef√§hrliche Fehler tritt auf, wenn Sie gegen die Gesetze zur Verwendung von LiveData und Observer versto√üen.  Wir werden diesen Fehler im √úbungsabschnitt ausf√ºhrlich untersuchen. </li><li>  <i>Weitl√§ufiges ViewModel.</i>  Wenn Sie versuchen, die gesamte Gesch√§ftslogik in das ViewModel zu integrieren, erhalten Sie einen unlesbaren Code.  Der Ausweg aus dieser Situation kann darin bestehen, das ViewModel in eine Hierarchie aufzuteilen oder Pr√§sentatoren zu verwenden.  Genau das habe ich getan. </li></ul><br>  <i><b>Regeln f√ºr die Arbeit mit MVVM</b></i> <br><br>  Beginnen wir mit den meisten Fehlern und gehen wir zu den weniger Fehlern: <br><br><ul><li>  Der Anfragetext sollte sich nicht in ViewModel befinden (nur im Repository). </li><li>  LiveData-Objekte werden im ViewModel definiert, sie werfen sich nicht in das Repository, weil  Anforderungen im Repository werden mit Rx-Java (oder Coroutinen) verarbeitet. </li><li>  Alle Verarbeitungsfunktionen sollten in Klassen und Dateien von Drittanbietern ("Pr√§sentatoren") verschoben werden, um das ViewModel nicht zu √ºberladen und nicht vom Wesen abzulenken. </li></ul><br><h4>  Livedata </h4><br><blockquote>  LiveData ist eine beobachtbare Datenhalterklasse.  Im Gegensatz zu einem regul√§ren Observable ist LiveData lebenszyklusabh√§ngig, dh es ber√ºcksichtigt den Lebenszyklus anderer App-Komponenten wie Aktivit√§ten, Fragmente oder Dienste.  Diese Kenntnis stellt sicher, dass LiveData nur Beobachter von App-Komponenten aktualisiert, die sich in einem aktiven Lebenszyklus befinden. </blockquote>  <i>Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">developer.android.com/topic/libraries/architecture/livedata</a></i> <br><br>  Aus der Definition kann eine einfache Schlussfolgerung gezogen werden: LiveData ist ein zuverl√§ssiges reaktives Programmierwerkzeug.  Wir werden es verwenden, um den UI-Teil ohne Datenbindung zu aktualisieren.  Warum so? <br><br>  Die Struktur der XML-Dateien erm√∂glicht keine pr√§zise Verteilung der aus &lt;data&gt; ... &lt;/ data&gt; erhaltenen Daten.  Wenn bei kleinen Dateien alles klar ist, was ist dann mit gro√üen Dateien?  Was tun mit komplexen Bildschirmen, mehreren Einschlie√üen und √úbergeben mehrerer Felder?  Modelle √ºberall verwenden?  Steife Feldbindungen bekommen?  Und wenn das Feld formatiert werden soll, Methoden aus Java-Paketen aufrufen?  Dies macht den Code hoffnungslos und vollst√§ndig Spaghetti.  √úberhaupt nicht das, was MVVM versprochen hat. <br><br>  Durch das Ablehnen der Datenbindung werden √Ñnderungen am UI-Teil transparent.  Alle Aktualisierungen erfolgen direkt im Beobachter.  Weil  Da der Kolin-Code pr√§zise und klar ist, werden wir keine Probleme mit aufgebl√§hten Beobachtern bekommen.  Das Schreiben und Verwalten von Code wird einfacher.  XML-Dateien werden nur f√ºr das Design verwendet - keine Eigenschaft im Inneren. <br><br>  Die Datenbindung ist ein leistungsstarkes Werkzeug.  Es eignet sich hervorragend zum L√∂sen einiger Probleme und harmoniert gut mit Java, aber mit Kotlin ... Bei Kotlin ist die Datenbindung in den meisten F√§llen nur rudiment√§r.  Die Datenbindung verkompliziert nur den Code und bietet keine Wettbewerbsvorteile. <br><br>  In Java hatten Sie die Wahl: Verwenden Sie entweder die Datenbindung oder schreiben Sie viel h√§sslichen Code.  In Kotlin k√∂nnen Sie direkt auf Ansichtselemente zugreifen, indem Sie findViewById () sowie dessen Eigenschaft umgehen.  Zum Beispiel: <br><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Instead of TextView textView = findViewById&lt;TextView&gt;(R.id.textView) textView.text = "Hello, world!" textView.visibility = View.VISIBLE</span></span></code> </pre> <br>  Es stellt sich eine logische Frage: Warum sollten Sie sich mit Gartenmodellen in XML-Dateien besch√§ftigen, Java-Methoden in XML-Dateien aufrufen und die Logik des XML-Teils √ºberladen, wenn all dies vermieden werden kann? <br><br><h4>  Coroutinen anstelle von Thread () und Rx-Java </h4><br>  Coroutinen sind unglaublich leicht und einfach zu bedienen.  Sie sind ideal f√ºr die meisten einfachen asynchronen Aufgaben: Verarbeiten von Abfrageergebnissen, Aktualisieren der Benutzeroberfl√§che usw. <br><br>  Coroutinen k√∂nnen Thread () und Rx-Java effektiv ersetzen, wenn keine hohe Leistung erforderlich ist, weil  Sie bezahlen f√ºr Leichtigkeit mit Geschwindigkeit.  Rx-Java ist zweifellos funktionaler, f√ºr einfache Aufgaben sind jedoch nicht alle Ressourcen erforderlich. <br><br><h4>  Microsoft und der Rest </h4><br>  F√ºr die Arbeit mit Outlook-Diensten wird die Microsoft Graph-API verwendet.  Mit den entsprechenden Berechtigungen erhalten Sie alle erforderlichen Informationen zu Mitarbeitern, R√§umen und Event-Ahs (Besprechungen).  Zur Gesichtserkennung wird der Microsoft Face API-Clouddienst verwendet. <br><br>  Mit Blick auf die Zukunft werde ich sagen, dass zur L√∂sung des Skalierbarkeitsproblems Firebase-Cloud-Speicher verwendet wurde.  Dies wird unten diskutiert. <br><br><h2>  Architektur </h2><br><h3>  Skalierbarkeitsprobleme </h3><br>  Es ist ziemlich schwierig, das System vollst√§ndig oder teilweise skalierbar zu machen.  Dies ist besonders schwierig, wenn die erste Version der Anwendung nicht skalierbar war und die zweite Version skalierbar sein sollte.  Die Anwendung v1 hat gleichzeitig Anfragen an alle R√§ume gesendet.  Jedes der Tablets hat regelm√§√üig Anforderungen an den Server gesendet, um alle Daten zu aktualisieren.  Gleichzeitig haben sich die Ger√§te nicht miteinander synchronisiert, weil  Das Projekt hat einfach keinen eigenen Server. <br><br>  Wenn wir denselben Weg gehen und N Anforderungen von jedem der N Tablets senden, werden wir nat√ºrlich irgendwann entweder die Microsoft Graph-API umkippen oder unser System einfrieren lassen. <br><br>  Es w√§re logisch, eine Client-Server-L√∂sung zu verwenden, bei der der Server das Diagramm abfragt, Daten sammelt und auf Anfrage Informationen f√ºr die Tablets bereitstellt. Hier trifft uns jedoch die Realit√§t.  Das Projektteam besteht aus 2 Personen (Android-Entwickler und -Designer).  Sie m√ºssen die Frist von 7 Wochen einhalten und das Backend wird nicht zur Verf√ºgung gestellt, weil  Skalierung ist eine Anforderung des Entwicklers.  Das hei√üt aber nicht, dass die Idee aufgegeben werden muss? <br><br>  Die wahrscheinlich einzig richtige L√∂sung in dieser Situation ist die Verwendung von Cloud-Speicher.  Firebase ersetzt den Server und fungiert als Puffer.  Dann stellt sich Folgendes heraus: <i>Jedes Tablet fragt nur seine Adresse √ºber die Microsoft Graph-API ab und synchronisiert bei Bedarf Daten im Cloud-Speicher, von wo aus sie von anderen Ger√§ten gelesen werden k√∂nnen.</i> <br><br>  Der Vorteil dieser Implementierung ist eine schnelle Reaktion, weil  Firebase arbeitet im Echtzeitmodus.  Wir werden die Anzahl der Anfragen, die N-mal an den Server gesendet werden, reduzieren, was bedeutet, dass das Ger√§t etwas l√§nger im Akkubetrieb arbeitet.  Aus finanzieller Sicht ist das Projekt nicht im Preis gestiegen, weil  F√ºr dieses Projekt reicht die kostenlose Version von Firebase mit mehreren Reserven aus: 1 GB Speicher, 10.000 Autorisierungen pro Monat und 100 Verbindungen gleichzeitig.  Zu den Nachteilen k√∂nnte die Abh√§ngigkeit von einem Framework eines Drittanbieters geh√∂ren, aber Firebase schafft Vertrauen in uns, weil  Es ist ein stabiles Produkt, das von Google gepflegt und entwickelt wird. <br><br>  Die Grundidee des neuen Systems lautete wie folgt: N Tablets und eine Cloud-Plattform f√ºr die Echtzeit-Datensynchronisation.  Beginnen wir mit dem Entwerfen der Anwendung. <br><br><h4>  LiveData im Repository </h4><br>  Es scheint, dass ich k√ºrzlich die Regeln f√ºr gute Form festgelegt habe und sofort gegen eine von ihnen versto√üe.  Im Gegensatz zur empfohlenen Verwendung von LiveData im ViewModel werden in diesem Projekt LiveData-Objekte im Repository initialisiert und alle Repositorys als Singleton deklariert.  Warum so? <br><br>  Eine √§hnliche L√∂sung ist mit dem Anwendungsmodus verbunden.  Tabletten sind von 8 bis 20 Uhr ge√∂ffnet.  W√§hrend dieser ganzen Zeit wurde nur der Meeting Room Helper auf ihnen gestartet.  Infolgedessen k√∂nnen und sollten viele Objekte langlebig sein (aus diesem Grund sind alle Repositorys als Singleton konzipiert). <br><br>  Im Laufe der Arbeit wird der UI-Inhalt regelm√§√üig gewechselt, was wiederum die Erstellung und Neuerstellung von ViewModel-Objekten beinhaltet.  Wenn Sie LiveData im ViewModel verwenden, wird f√ºr jedes erstellte Fragment ein eigenes ViewModel mit einer Reihe angegebener LiveData-Objekte erstellt.  Wenn zwei √§hnliche Fragmente gleichzeitig mit unterschiedlichem ViewModel und einem gemeinsamen Base-ViewModel auf dem Bildschirm angezeigt werden, werden w√§hrend der Initialisierung LiveData-Objekte aus dem Base-ViewModel dupliziert.  In Zukunft werden diese Duplikate Speicherplatz beanspruchen, bis sie vom "Garbage Collector" zerst√∂rt werden.  Weil  Wenn wir bereits ein Repository in Form eines Singletons haben und die Kosten f√ºr die Neuerstellung von Bildschirmen minimieren m√∂chten, ist es ratsam, LiveData-Objekte in ein Singleton-Repository zu √ºbertragen, um ViewModel-Objekte zu vereinfachen und die Anwendung zu beschleunigen. <br><br>  Dies bedeutet nat√ºrlich nicht, dass Sie alle LiveData vom ViewModel in das Repository √ºbertragen m√ºssen, aber Sie sollten dieses Problem sorgf√§ltiger angehen und Ihre Wahl bewusst treffen.  Der Nachteil dieses Ansatzes ist die Zunahme der Anzahl langlebiger Objekte, weil  Alle Repositorys sind als Singleton definiert und in jedem von ihnen werden LiveData-Objekte gespeichert.  In einem bestimmten Fall ist Meeting Room Helper jedoch kein Minus, weil  Die Anwendung wird den ganzen Tag ohne Unterbrechung ausgef√ºhrt, ohne den Kontext zu anderen Anwendungen zu wechseln. <br><br><h4>  Resultierende Architektur </h4><br><img src="https://habrastorage.org/webt/yf/db/uo/yfdbuo8--ygtmrgxsybvuiuyeme.png"><br><br><ul><li>  Alle Anforderungen werden in Repositorys ausgef√ºhrt.  Alle Repositorys (im Meeting Room Helper gibt es 11 davon) sind als Singleton konzipiert.  Sie sind nach Art der zur√ºckgegebenen Objekte unterteilt und hinter den Fassaden versteckt. </li><li>  Die Gesch√§ftslogik befindet sich im ViewModel.  Dank der Verwendung von "Presenters" betrug die Gesamtgr√∂√üe aller ViewModel (es gibt 6 im Projekt) weniger als 120 Zeilen. </li><li>  Aktivit√§t und Fragment sind nur beim √Ñndern des UI-Teils mithilfe von Observer und LiveData beteiligt, die vom ViewModel zur√ºckgegeben werden. </li><li>  Funktionen zum Verarbeiten und Generieren von Daten werden im "Presenter" gespeichert.  Aktiv genutzte Berechtigungsfunktionen von Kotlin f√ºr die Datenverarbeitung. </li></ul><br>  Die Hintergrundlogik wurde in Intent-Service verschoben: <br><br><ul><li>  Event-Update-Service.  Dienst, der f√ºr die Synchronisierung der Daten des aktuellen Raums in der Firebase- und Graph-API verantwortlich ist. </li><li>  User-Recognize-Service.  L√§uft nur auf dem Master-Tablet.  Verantwortlich f√ºr das Hinzuf√ºgen neuer Mitarbeiter zum System.  √úberpr√ºft eine Liste bereits geschulter Personen mit einer Liste aus Active Directory.  Wenn neue Personen angezeigt werden, f√ºgt der Dienst sie der Face-API hinzu und schult das neuronale Netzwerk neu.  Nach Abschluss des Vorgangs wird es ausgeschaltet.  Es beginnt mit dem Start der Anwendung. </li><li>  Der Online-Benachrichtigungsdienst benachrichtigt andere Tablets, dass dieses Tablet funktioniert, d. H.  Die externe Batterie ist nicht ersch√∂pft.  Es funktioniert √ºber Firebase. </li></ul><br>  Das Ergebnis war eine im Hinblick auf die Verteilung der Verantwortlichkeiten recht flexible und korrekte Architektur, die alle Anforderungen der modernen Entwicklung erf√ºllt.  Wenn wir in Zukunft die Microsoft Graph-API, Firebase oder ein anderes Modul aufgeben, k√∂nnen diese problemlos durch neue ersetzt werden, ohne den Rest der Anwendung zu beeintr√§chtigen.  Das Vorhandensein eines umfangreichen Systems von ‚ÄûPr√§sentatoren‚Äú erm√∂glichte es, alle Datenverarbeitungsfunktionen √ºber den Kern hinaus zu √ºbernehmen.  Infolgedessen ist die Architektur kristallklar geworden, was ein gro√ües Plus ist.  Das Problem eines √ºberwucherten ViewModel ist vollst√§ndig verschwunden. <br><br>  Im Folgenden werde ich ein Beispiel f√ºr das h√§ufig verwendete Bundle in einer entwickelten Anwendung geben. <br><br><h3>  √úbe.  Updates ansehen </h3><br>  Abh√§ngig vom Status des Besprechungsraums zeigt das Zifferblatt eine der folgenden Bedingungen an: <br><br><img src="https://habrastorage.org/webt/sa/o2/to/sao2towzwxh0qqlp1gvxd_s2qjg.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Dar√ºber hinaus befinden sich tempor√§re Rallye-B√∂gen entlang des Umrisses des Zifferblatts, und die Mitte z√§hlt bis zum Ende des Meetings oder bis zum Beginn der n√§chsten Rallye herunter.  All dies erledigt die von uns entwickelte Canvas-Bibliothek.  Wenn sich das Raster der Besprechungen ge√§ndert hat, m√ºssen wir die Daten in der Bibliothek aktualisieren. <br><br>  Da LiveData in Repositories angek√ºndigt wird, ist es am logischsten, mit ihnen zu beginnen. <br><br><h4>  Repositories </h4><br>  <i>FirebaseRoomRepository</i> - eine Klasse, die f√ºr das Senden und Verarbeiten von Anforderungen in Firebase im Zusammenhang mit dem Raummodell verantwortlich ist. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. object FirebaseRoomRepository { private val database = FirebaseFactory.database val rooms: MutableList&lt;Room&gt; = ArrayList() // 2. var currentRoom: MutableLiveData&lt;Room?&gt; = MutableLiveData() val onlineStatus: MediatorLiveData&lt;HashMap&lt;String, Boolean&gt;&gt; = MediatorLiveData() var otherRooms: MutableLiveData&lt;List&lt;Room&gt;&gt; = MutableLiveData() var ownRoom: MutableLiveData&lt;Room&gt; = MutableLiveData() // 3. private val roomsListener = object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { updateRooms(dataSnapshot) } override fun onCancelled(error: DatabaseError) {} } init { // 4. database.getReference(ROOMS_CURRENT_STATES) .addValueEventListener(roomsListener) } // 5. private fun updateRooms(dataSnapshot: DataSnapshot) { rooms.updateRooms(dataSnapshot) otherRooms.updateOtherRooms(rooms) ownRoom.updateOwnRoom(rooms) currentRoom.updateCurrentRoom(rooms, ownRoom) } }</span></span></code> </pre><br>  Um dies zu demonstrieren, wurde der Initialisierungscode der Listener-Firebase leicht vereinfacht (die Funktion zum erneuten Verbinden wurde entfernt).  Werfen wir einen Blick auf die Punkte, die hier geschehen: <br><br><ol><li>  Das Repository ist als Singleton konzipiert (in Kotlin reicht es aus, das Schl√ºsselwort class durch object zu ersetzen). </li><li>  Initialisierung von LiveData-Objekten; </li><li>  ValueEventListener wird als Variable deklariert, um zu vermeiden, dass bei erneuter Verbindung eine anonyme Klasse neu erstellt wird (denken Sie daran, ich habe die Initialisierung vereinfacht, indem ich bei erneuter Verbindung die erneute Verbindung entfernt habe). </li><li>  Initialisierung von ValueEventListener (wenn sich die Daten in Firebase √§ndern, f√ºhrt der Listener die Daten in LiveData-Objekten sofort aus und aktualisiert sie); </li><li>  Aktualisierungen von LiveData-Objekten. </li></ol><br>  Die Funktionen selbst werden in eine separate FirebaseRoomRepositoryPresenter-Datei verschoben und als Erweiterungsfunktionen dekoriert. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> MutableLiveData</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;List&lt;Room&gt;</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateOtherRooms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rooms: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MutableList</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Room</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.postValue(rooms.filter { !it.isOwnRoom() }) }</code> </pre><br>  <i>Beispiel f√ºr eine Erweiterungsfunktion aus FirebaseRoomRepositoryPresenter</i> <br><br>  F√ºr ein allgemeines Verst√§ndnis des Bildes werde ich auch eine Auflistung des Raumobjekts geben. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. data class Room(var number: String = "", var nickName: String = "", var email: String? = null, var imgSmall: String? = null, var imgOffline: String? = null, var imgFree: String? = null, var imgWait: String? = null, var imgBusy: String? = null, var events: List&lt;Event.Short&gt; = emptyList()) // 2.</span></span></code> </pre><br><ol><li>  Datenklasse.  Dieser Modifikator generiert automatisch die Methoden toString (), HashCode () und same () und √ºberschreibt sie.  Sie m√ºssen sie nicht mehr selbst neu definieren. </li><li>  Die Ereignisliste aus dem Raumobjekt.  Diese Liste ist erforderlich, um die Daten in der W√§hlbibliothek zu aktualisieren. </li></ol><br>  Alle Repositories-Klassen sind hinter der Fassadenklasse versteckt. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Repository { <span class="hljs-comment"><span class="hljs-comment">// 1. private val firebaseRoomRepository = FirebaseRoomRepository // ......... /** * Rooms queries */ fun getOtherRooms() = firebaseRoomRepository.otherRooms fun getOwnRoom() = firebaseRoomRepository.ownRoom fun getAllRooms() = firebaseRoomRepository.rooms // 2. fun getCurrentRoom() = firebaseRoomRepository.currentRoom //   // ....... }</span></span></code> </pre><br><ol><li>  Oben sehen Sie eine Liste aller verwendeten Repository-Klassen und Fassaden der zweiten Ebene.  Dies vereinfacht das allgemeine Verst√§ndnis des Codes und zeigt eine Liste aller verbundenen Repository-Klassen. </li><li>  Eine Liste von Methoden, die Verweise auf LiveData-Objekte aus dem FirebaseRoomRepository zur√ºckgeben.  Kotlins Setter und Getter sind optional, sodass Sie sie nicht unn√∂tig schreiben m√ºssen. </li></ol><br>  Mit einer solchen Organisation k√∂nnen Sie bequem 20 bis 30 Anforderungen in ein Root-Repository einf√ºgen.  Wenn Ihre Anwendung mehr Anforderungen hat, m√ºssen Sie die Grundfassade in zwei oder mehr teilen. <br><br><h4>  ViewModel </h4><br>  BaseViewModel ist das Basis-ViewModel, von dem alle ViewModels geerbt werden.  Es enth√§lt ein einzelnes currentRoom-Objekt, das universell verwendet wird. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. open class BaseViewModel : ViewModel() { // 2. fun getCurrentRoom() = Repository.getCurrentRoom() }</span></span></code> </pre><br><ol><li>  Der offene Marker bedeutet, dass Sie von der Klasse erben k√∂nnen.  Standardm√§√üig sind in Kotlin alle Klassen und Methoden endg√ºltig, d. H.  Klassen k√∂nnen nicht vererbt und Methoden nicht neu definiert werden.  Dies dient zum Schutz vor versehentlichen inkompatiblen Versions√§nderungen.  Ich werde ein Beispiel geben. <br><br>  <i>Sie entwickeln eine neue Version der Bibliothek.</i>  <i>Aus dem einen oder anderen Grund entscheiden Sie sich irgendwann, die Klasse umzubenennen oder die Signatur einer Methode zu √§ndern.</i>  <i>Durch √Ñndern haben Sie versehentlich eine Versionsinkompatibilit√§t erstellt.</i>  <i>Ups ... Wenn Sie wahrscheinlich gewusst h√§tten, dass die Methode von jemandem √ºberschrieben werden k√∂nnte und die Klasse geerbt wurde, w√§ren Sie wahrscheinlich genauer gewesen und h√§tten sich kaum in den Fu√ü geschossen.</i>  <i>Zu diesem Zweck wird in Kotlin standardm√§√üig alles als endg√ºltig deklariert, und zum Abbrechen gibt es einen "offenen" Modifikator.</i> <br></li><li>  Die Methode getCurrentRoom () gibt einen Link zum LiveData-Objekt des aktuellen Raums aus dem Repository zur√ºck, der wiederum aus dem FirebaseRoomRepository stammt.  Wenn diese Methode aufgerufen wird, gibt das Room-Objekt alle Informationen zum Raum zur√ºck, einschlie√ülich einer Liste von Ereignissen. </li></ol><br>  Um Daten von einem Format in ein anderes zu konvertieren, verwenden wir die Transformation.  Erstellen Sie dazu ein <i>MainFragmentViewModel</i> und erben Sie es von <i>BaseViewModel</i> . <br><br>  <i>MainFragmentViewModel</i> ist eine von BaseViewModel <i>abgeleitete</i> Klasse.  Dieses ViewModel wird nur in MainFragment verwendet. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. class MainFragmentViewModel: BaseViewModel () { // 2. var currentRoomEvents = Transformations.switchMap(getCurrentRoom()) { val events: MutableLiveData&lt;List&lt;Event.Short&gt;&gt; = MutableLiveData() // some business logic events.postValue(it?.eventsList) events } // 3. val currentRoomEvents2 = MediatorLiveData&lt;List&lt;Event.Short&gt;&gt;().apply { addSource(getCurrentRoom()) { room -&gt; // some business logic postValue(room?.eventsList) } } }</span></span></code> </pre><br><ol><li>  Beachten Sie das Fehlen des Modifikators open.  Dies bedeutet, dass niemand von der Klasse erbt. </li><li>  currentRoomEvents - Ein Objekt, das mithilfe der Transformation erhalten wurde.  Sobald sich das Objekt des aktuellen Raums √§ndert, wird die Transformation durchgef√ºhrt und das Objekt currentRoomEvents aktualisiert. </li><li>  MediatorLiveData.  Das Ergebnis ist identisch mit der Transformation (als Referenz gezeigt). </li></ol><br>  Die erste Option wird verwendet, um Daten von einem Typ in einen anderen zu konvertieren, was wir brauchten, und die zweite Option wird ben√∂tigt, um eine Gesch√§ftslogik auszuf√ºhren.  Eine Datenkonvertierung findet jedoch nicht statt.  Denken Sie daran, dass der Android-Import in ViewModel nicht g√ºltig ist.  Daher starte ich von hier aus zus√§tzliche Anfragen oder starte die Dienste nach Bedarf neu. <br><br>  <b>Wichtiger Hinweis!</b>  Damit die Transformation oder der Mediator funktioniert, muss jemand von einem Fragment oder einer Aktivit√§t abonniert werden.  Andernfalls wird der Code nicht ausgef√ºhrt, weil  Niemand wird ein Ergebnis erwarten (dies sind Beobachterobjekte). <br><br><h4>  Mainfragment </h4><br>  Der letzte Schritt bei der Konvertierung von Daten in Ergebnisse.  MainFragment enth√§lt eine W√§hlbibliothek und einen View-Pager am unteren Bildschirmrand. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseFragment</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// 1. private lateinit var viewModel: MainFragmentViewModel // 2. private val currentRoomObserver = Observer&lt;List&lt;Event.Short&gt;&gt; { clockView.updateArcs(it) } override fun onAttach(context: Context?) { super.onAttach(context) // 3. viewModel = ViewModelProviders.of(this).get(MainFragmentViewModel::class.java) } override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { return inflater.inflate(R.layout.fragment_main, container, false) } override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) // 4. viewModel.currentRoomEvents.observe(viewLifecycleOwner, currentRoomObserver) } }</span></span></code> </pre><br><ol><li>  Initialisierung von MainFragmentViewModel.  Der Modifikator lateinit gibt an, dass wir versprechen, dieses Objekt sp√§ter zu initialisieren, bevor wir es verwenden.  Kotlin versucht, den Programmierer vor falschem Schreiben von Code zu sch√ºtzen, daher m√ºssen wir entweder sofort sagen, dass das Objekt null sein kann, oder lateinit setzen.  In diesem Fall muss das ViewModel vom Objekt initialisiert werden. </li><li>  Beobachter-Listener, um das Zifferblatt zu aktualisieren. </li><li>  ViewModel initialisieren.  Bitte beachten Sie, dass dies unmittelbar nach dem Anh√§ngen des Fragments an die Aktivit√§t geschieht. </li><li>  Nachdem die Aktivit√§t erstellt wurde, abonnieren wir √Ñnderungen am currentRoomEvents-Objekt.  Bitte beachten Sie, dass ich nicht den Fragmentlebenszyklus (this) abonniere, sondern das viewLifecycleOwner-Objekt.  Tatsache ist, dass in der Support-Bibliothek 28.0.0 und AndroidX 1.0.0 ein Fehler festgestellt wurde, als der Beobachter "abgemeldet" wurde.  Um dieses Problem zu l√∂sen, wurde ein Patch in Form von viewLifecycleOwner ver√∂ffentlicht, und Google empfiehlt, ihn zu abonnieren.  Dies behebt das Problem des Zombie-Beobachters, wenn das Fragment gestorben ist und der Beobachter weiter arbeitet.  Wenn Sie dies weiterhin verwenden, m√ºssen Sie es durch viewLifecycleOwner ersetzen. </li></ol><br>  Daher m√∂chte ich die Einfachheit und Sch√∂nheit von MVVM und LiveData ohne Datenbindung demonstrieren.  Bitte beachten Sie, dass ich in diesem Projekt gegen die allgemein akzeptierte Regel versto√üe, indem ich LiveData aufgrund der Besonderheiten des Projekts in das Repository stelle.  Wenn wir sie jedoch in das ViewModel verschieben, bleibt das Gesamtbild unver√§ndert. <br><br>  Als Kirsche auf einem Kuchen habe ich f√ºr Sie ein kurzes Video mit einer Demonstration vorbereitet (Namen werden gem√§√ü den Sicherheitsanforderungen verschmiert, ich entschuldige mich): <br><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E9zUc0vaGck" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Zusammenfassung </h3><br>  Infolge der Anwendung im ersten Monat wurden einige Fehler bei der Anzeige von Cross-Rallyes aufgedeckt (mit Outlook k√∂nnen Sie mehrere Ereignisse gleichzeitig erstellen, w√§hrend unser System dies nicht tut).  Jetzt arbeitet das System seit 3 ‚Äã‚ÄãMonaten.  Fehler oder Ausf√§lle werden nicht beobachtet. <br><br>  PS Danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">jericho_code</a> f√ºr den Kommentar.  In Kotlin k√∂nnen und sollten Sie List &lt;&gt; im Modell mit emptyList () initialisieren, dann wird kein zus√§tzliches Objekt erstellt. <br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> events: List&lt;Event.<span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>&gt; = emptyList() <span class="hljs-comment"><span class="hljs-comment">//      EmptyList var events: List&lt;Event.Short&gt; = ArrayList() //   </span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457960/">https://habr.com/ru/post/de457960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457948/index.html">Brettspiele, bei denen man sich den Kopf zerschlagen muss</a></li>
<li><a href="../de457952/index.html">Wie Prozessoren entworfen und hergestellt werden: Chipherstellung</a></li>
<li><a href="../de457954/index.html">Warum Swift ein gro√ües Ereignis im Deep Learning werden kann</a></li>
<li><a href="../de457956/index.html">So w√§hlen Sie die Aufbewahrung, ohne sich in den Fu√ü zu schie√üen</a></li>
<li><a href="../de457958/index.html">Alltag MT_FREE: Mehrere Geschichten √ºber den Einfluss von Diensten Dritter auf die Arbeit von √∂ffentlichem WLAN</a></li>
<li><a href="../de457962/index.html">Wie bei der Thrash-Architektur und dem Mangel an F√§higkeiten in Scrum haben wir komponenten√ºbergreifende Teams erstellt</a></li>
<li><a href="../de457964/index.html">Echte Virtualit√§t: Workstations ++</a></li>
<li><a href="../de457966/index.html">‚ÄûIch w√ºrde eine spezielle IT-Zone im S√ºden Russlands er√∂ffnen‚Äú - 10 Fragen an Programmierer Nr. 11. Neue Saison</a></li>
<li><a href="../de457968/index.html">Parallelen, die sich √ºberschneiden - das Kommunikationsministerium hat √ºber Nacht Milliarden an Budgets verbrannt</a></li>
<li><a href="../de457970/index.html">Linter in Go. Wie man sie kocht. Denis Isaev</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>