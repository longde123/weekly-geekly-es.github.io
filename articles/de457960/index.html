<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔳 🤚🏾 🤔 Besprechungsraum L̶i̶t̶t̶l̶e̶ Helfer v 2 🛒 😂 🙂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden die Entwicklungsphasen der mobilen Meeting Room Helper-Anwendung ausführlich beschrieben: von der Idee bis zur Veröffentlichu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Besprechungsraum L̶i̶t̶t̶l̶e̶ Helfer v 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/457960/">  In diesem Artikel werden die Entwicklungsphasen der mobilen Meeting Room Helper-Anwendung ausführlich beschrieben: von der Idee bis zur Veröffentlichung.  Die Anwendung ist in Kotlin geschrieben und basiert auf einer vereinfachten MVVM-Architektur ohne Datenbindung.  Der UI-Teil wird mithilfe von LiveData-Objekten aktualisiert.  Die Gründe für die Verweigerung der Datenbindung werden detailliert und erläutert.  Die Architektur verwendet eine Reihe interessanter Lösungen, die es ermöglichen, das Programm logisch in kleine Dateien aufzuteilen, was letztendlich die Codeunterstützung vereinfacht. <br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><img src="https://habrastorage.org/webt/ii/at/pf/iiatpf_m3syq_8mzu08bkaqiy4u.jpeg"><br><a name="habracut"></a><br><h2>  Projektbeschreibung </h2><br>  Vor 3 Jahren kam in unserem Unternehmen die Idee auf, ein kleines Projekt zur sofortigen Buchung von Tagungsräumen zu entwickeln.  Die meisten Personalmanager und Arcadia bevorzugen es, den Outlook-Kalender für solche Zwecke zu verwenden, aber was ist mit dem Rest? <br><br>  Ich werde 2 Beispiele aus dem Leben des Entwicklers geben <br><br><ol><li>  <i>Jedes Team hat regelmäßig den spontanen Wunsch, eine schnelle Rallye für 5-10 Minuten abzuhalten.</i>  <i>Dieser Wunsch kann Entwickler in jeder Ecke des Büros überholen, und um Kollegen in ihrer Umgebung nicht abzulenken, suchen sie (Entwickler und nicht nur) nach einem freien Gespräch.</i>  <i>Bei der Migration von Raum zu Raum (in unserem Büro sind die Besprechungsräume in einer Reihe angeordnet) überprüfen die Kollegen sorgfältig, welcher der Räume derzeit frei ist.</i>  <i>Infolgedessen lenken sie Kollegen im Inneren ab.</i>  <i>Solche Leute waren und werden es immer sein, auch wenn die Dreharbeiten in der Unternehmenscharta wegen Unterbrechung der Rallye beendet sind.</i>  <i>Wer verstanden hat, wird verstehen.</i> </li><li>  <i>Und hier ist ein anderer Fall.</i>  <i>Sie haben gerade den Speisesaal verlassen und gehen zu sich selbst, aber hier fängt Sie Ihr Kollege (oder Manager) aus einer anderen Abteilung ab.</i>  <i>Er möchte Ihnen etwas Dringendes sagen, und für diese Zwecke benötigen Sie einen Besprechungsraum.</i>  <i>Gemäß den Vorschriften müssen Sie zuerst ein Zimmer (von Ihrem Telefon oder Computer) buchen und erst dann belegen.</i>  <i>Es ist gut, wenn Sie ein Mobiltelefon mit mobilem Outlook haben.</i>  <i>Und wenn nicht?</i>  <i>Zurück zum Computer, dann wieder zum Besprechungsraum zurückkehren?</i>  <i>Um jeden Mitarbeiter zu zwingen, Outlook Express auf das Telefon zu setzen und sicherzustellen, dass jeder die Telefone mit sich führt?</i>  <i>Dies sind nicht unsere Methoden.</i> </li></ol><br>  Deshalb wurde vor 2,5 Jahren jeder Tagungsraum mit einem eigenen Tablet ausgestattet: <br><br><img src="https://habrastorage.org/webt/kp/2i/ao/kp2iao0nromcb1wa-iewgzxurw0.png"><br><br>  Für dieses Projekt hat mein Kollege die erste Version der Anwendung entwickelt: Meeting Room Little Helper ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier können Sie darüber lesen</a> ).  MRLH, das eine Reservierung buchen, eine Reservierung stornieren und erneuern durfte, zeigte den Status der verbleibenden Gespräche an.  Das Erkennen der Identität eines Mitarbeiters (mithilfe des Microsoft Face API-Clouddiensts und unserer internen Analysegeräte) ist zu einem innovativen „Trick“ geworden.  Die Bewerbung erwies sich als solide und diente dem Unternehmen 2,5 Jahre lang treu. <br><br>  Aber die Zeit verging ... Neue Ideen erschienen.  Ich wollte etwas Frisches, und so beschlossen wir, die Anwendung neu zu schreiben. <br><br><h3>  Technische Aufgabe </h3><br>  Wie so oft - aber leider nicht immer - begann die Entwicklung mit der Erstellung technischer Spezifikationen.  Zuerst haben wir die Leute angerufen, die am häufigsten Tablets für Reservierungen verwenden.  Es war einfach so, dass sie vor allem von HRs und Managern abhängig waren, die zuvor ausschließlich Outlook verwendet hatten.  Von ihnen erhielten wir das folgende Feedback (aus den Anforderungen geht sofort hervor, wonach die Personalabteilung und die Manager gefragt haben): <br><br><ul><li>  Sie müssen die Möglichkeit hinzufügen, einen beliebigen Besprechungsraum von einem beliebigen Tablet aus zu buchen (zuvor konnten Sie auf jedem Tablet nur Ihren Raum buchen). </li><li>  Es wäre cool, sich den Zeitplan der Kundgebungen für ein ganztägiges Treffen anzusehen (idealerweise für jeden Tag). </li><li>  Der gesamte Entwicklungszyklus muss in kurzer Zeit (für 6-7 Wochen) durchgeführt werden. </li></ul><br>  Mit den Kundenwünschen ist alles klar, aber was ist mit den technischen Anforderungen und der Zukunft?  Fügen Sie der Entwicklergilde einige Anforderungen für das Projekt hinzu: <br><br><ul><li>  Das System sollte sowohl mit vorhandenen als auch mit neuen Tablets funktionieren. </li><li>  Skalierbarkeit des Systems - ab 50 Konversationen (dies sollte für die meisten Kunden mit einem Spielraum ausreichen, wenn das System mit der Replikation beginnt); </li><li>  Beibehaltung der vorherigen Funktionalität (die erste Version der Anwendung verwendete die Java-API für die Kommunikation mit Outlook-Diensten, und wir planten, sie durch eine spezielle Microsoft Graph-API zu ersetzen, sodass es wichtig war, die Funktionalität nicht zu verlieren); </li><li>  Minimierung des Energieverbrauchs (Tablets werden von einer externen Batterie gespeist, da das Business Center das Bohren seiner Wände zum Verlegen unserer Drähte nicht zuließ); </li><li>  neues UX / UI-Design, das alle Innovationen ergonomisch widerspiegelt. </li></ul><br>  Insgesamt 8 Punkte.  Die Anforderungen sind ziemlich fair.  Zusätzlich legen wir die allgemeinen Entwicklungsregeln fest: <br><br><ul><li>  Verwenden Sie nur fortschrittliche Technologien (dies ermöglicht es dem Team, sich als Spezialisten zu entwickeln und nicht an einem Ort zu stagnieren, während die Projektunterstützung in absehbarer Zukunft vereinfacht wird). </li><li>  Befolgen Sie die Best Practices, aber halten Sie sie nicht blind für selbstverständlich  Die Hauptregel eines jeden Profis (und eines Entwicklers, der danach strebt) ist, alles kritisch zu bewerten. </li><li>  Schreiben von sauberem und ordentlichem Code (dies ist möglicherweise am schwierigsten, wenn Sie versuchen, Innovation und enge Entwicklungszeit zu kombinieren). </li></ul><br>  Ein Anfang wurde gemacht.  Es ist wie immer begeistert!  Mal sehen, was als nächstes passiert. <br><br><h3>  Design </h3><br>  Vom UX-Designer entwickeltes Anwendungsdesign: <br><br><img src="https://habrastorage.org/webt/gm/n9/eo/gmn9eox4exzhczkq0zdbkiwrgt8.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Dies ist der Hauptbildschirm.  Es wird die meiste Zeit angezeigt.  Alle notwendigen Informationen finden Sie hier ergonomisch: <br><br><ul><li>  den Namen des Raumes und seine Nummer; </li><li>  aktueller Status; </li><li>  Zeit bis zum nächsten Treffen (oder bis zu seinem Ende); </li><li>  den Status der verbleibenden Räume am unteren Bildschirmrand. </li></ul><br>  Bitte beachten Sie: Auf dem Zifferblatt werden nur 12 Stunden angezeigt  Das System ist auf die Anforderungen des Unternehmens konfiguriert (Arcadia-Tablets funktionieren von 8 bis 20 Uhr, werden automatisch ein- und ausgeschaltet). <br><br><img src="https://habrastorage.org/webt/cg/r_/92/cgr_9220jaeqzpjtu4godm1vojw.gif"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Um ein Zimmer zu buchen, rufen Sie einfach das Buchungsfenster an und geben Sie die Dauer der Rallye an.  Die Schritte zum Buchen der verbleibenden Zimmer sind ähnlich. Sie beginnen erst mit einem Klick auf das Zimmersymbol. <br><br><img src="https://habrastorage.org/webt/d7/qr/wm/d7qrwmogkdzvjtdea0y80vjlti4.jpeg"><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Wenn Sie eine Besprechung für eine bestimmte Zeit planen möchten, wechseln Sie zur nächsten Registerkarte in der Liste der Besprechungen, die heute im Besprechungsraum stattfinden, und klicken Sie auf Freizeit.  Weiter ist alles wie im ersten Fall. <br><br>  Der vollständige Übergangsbaum sollte ungefähr so ​​aussehen: <br><br><img src="https://habrastorage.org/webt/p8/ex/lb/p8exlbbiuflfbasflet3vsepzdu.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Versuchen wir es kompetent umzusetzen. <br><br><h3>  Technologie-Stack </h3><br>  Entwicklungstechniken entwickeln sich ziemlich schnell und ändern sich.  Für weitere 2 Jahre war Java die offizielle Android-Entwicklungssprache.  Jeder schrieb in Java und verwendete Datenbindung.  Nun, so scheint es mir, bewegen wir uns in Richtung reaktiver Programmierung und Kotlin.  Java ist eine großartige Sprache, weist jedoch einige Mängel auf, verglichen mit dem, was Kotlin und AndroidX zu bieten haben.  Kotlin und AndroidX können die Verwendung der Datenbindung auf ein Minimum reduzieren, wenn nicht sogar vollständig ausschließen.  Im Folgenden werde ich versuchen, meinen Standpunkt zu erläutern. <br><br><h4>  Kotlin </h4><br>  Ich denke, viele Android-Entwickler sind bereits zu Kotlin gewechselt, und deshalb werden sie mir zustimmen, dass das Schreiben eines neuen Android-Projekts im Jahr 2019 in einer anderen Sprache als Kotlin dem Kampf gegen das Meer gleicht.  Natürlich können Sie streiten, aber was ist mit Flutter und Dart?  Was ist mit C ++, C # und sogar Cordova?  Worauf ich antworten werde: Die Wahl liegt immer bei Ihnen. <br><br>  480 v  Der persische König Xerxes befahl seinen Soldaten, das Meer zu überqueren, um einen Teil seiner Armee während eines Sturms zu zerstören. Fünf Jahrhunderte später erklärte der römische Kaiser Caligula Poseidon den Krieg.  Geschmackssache.  Für 9 von 10 ist Kotlin gut, aber für 10 kann es schlecht sein.  Es hängt alles von Ihnen ab, von Ihren Wünschen und Bestrebungen. <br><br>  Kotlin ist meine Wahl.  Die Sprache ist einfach und schön.  Das Schreiben darauf ist einfach und angenehm, und vor allem muss nicht zu viel geschrieben werden: Datenklasse, Objekt, optionaler Setter und Getter, einfache Lambda-Ausdrücke und Erweiterungsfunktionen.  Dies ist nur ein winziger Teil dessen, was diese Sprache zu bieten hat.  Wenn Sie noch nicht zu Kotlin gewechselt sind, können Sie loslegen!  Im Abschnitt mit Übung werde ich einige der Vorteile der Sprache demonstrieren (es ist kein Werbeangebot). <br><br><h4>  Model-View-ViewModel </h4><br>  MVVM ist derzeit die empfohlene Anwendungsarchitektur von Google.  Während der Entwicklung werden wir uns an dieses spezielle Muster halten, es jedoch nicht vollständig einhalten, da MVVM die Verwendung der Datenbindung empfiehlt, wir es jedoch ablehnen. <br><br>  <i><b>Vorteile von MVVM</b></i> <br><br><ul><li>  <i>Differenzierung von Geschäftslogik und Benutzeroberfläche.</i>  Bei der korrekten Implementierung von MVVM sollte in ViewModel kein einziger Android-Import vorhanden sein, außer für LiveData-Objekte aus AndroidX- oder Jetpack-Paketen.  Bei ordnungsgemäßer Verwendung bleiben alle UI-Arbeiten automatisch in Fragmenten und Aktivitäten.  Ist das nicht toll? </li><li>  <i>Der Einkapselungsgrad wird gepumpt.</i>  Es wird einfacher sein, als Team zu arbeiten: Jetzt können Sie alle auf einem Bildschirm zusammenarbeiten und sich nicht gegenseitig stören.  Während ein Entwickler mit dem Bildschirm arbeitet, kann ein anderer ein ViewModel erstellen und ein dritter kann Abfragen in das Repository schreiben. </li><li>  <i>MVVM wirkt sich positiv auf das Schreiben von Unit-Tests aus.</i>  Dieser Punkt folgt aus dem vorherigen.  Wenn alle Klassen und Methoden für die Arbeit mit der Benutzeroberfläche gekapselt sind, können sie problemlos getestet werden. </li><li>  <i>Eine natürliche Lösung mit Bildschirmrotation.</i>  Egal wie seltsam es auch klingen mag, diese Funktion wird beim Übergang zu MVVM automatisch erfasst (da die Daten im ViewModel gespeichert sind).  Wenn Sie die recht beliebten Anwendungen (VK, Telegramm, Sberbank-Online und Aviasales) überprüfen, stellt sich heraus, dass genau die Hälfte von ihnen den Bildschirm nicht drehen kann.  Was mich als Benutzer dieser Anwendungen überrascht und missversteht. </li></ul><br>  <i><b>Warum ist MVVM gefährlich?</b></i> <br><br><ul><li>  <i>Speicherverlust.</i>  Dieser gefährliche Fehler tritt auf, wenn Sie gegen die Gesetze zur Verwendung von LiveData und Observer verstoßen.  Wir werden diesen Fehler im Übungsabschnitt ausführlich untersuchen. </li><li>  <i>Weitläufiges ViewModel.</i>  Wenn Sie versuchen, die gesamte Geschäftslogik in das ViewModel zu integrieren, erhalten Sie einen unlesbaren Code.  Der Ausweg aus dieser Situation kann darin bestehen, das ViewModel in eine Hierarchie aufzuteilen oder Präsentatoren zu verwenden.  Genau das habe ich getan. </li></ul><br>  <i><b>Regeln für die Arbeit mit MVVM</b></i> <br><br>  Beginnen wir mit den meisten Fehlern und gehen wir zu den weniger Fehlern: <br><br><ul><li>  Der Anfragetext sollte sich nicht in ViewModel befinden (nur im Repository). </li><li>  LiveData-Objekte werden im ViewModel definiert, sie werfen sich nicht in das Repository, weil  Anforderungen im Repository werden mit Rx-Java (oder Coroutinen) verarbeitet. </li><li>  Alle Verarbeitungsfunktionen sollten in Klassen und Dateien von Drittanbietern ("Präsentatoren") verschoben werden, um das ViewModel nicht zu überladen und nicht vom Wesen abzulenken. </li></ul><br><h4>  Livedata </h4><br><blockquote>  LiveData ist eine beobachtbare Datenhalterklasse.  Im Gegensatz zu einem regulären Observable ist LiveData lebenszyklusabhängig, dh es berücksichtigt den Lebenszyklus anderer App-Komponenten wie Aktivitäten, Fragmente oder Dienste.  Diese Kenntnis stellt sicher, dass LiveData nur Beobachter von App-Komponenten aktualisiert, die sich in einem aktiven Lebenszyklus befinden. </blockquote>  <i>Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">developer.android.com/topic/libraries/architecture/livedata</a></i> <br><br>  Aus der Definition kann eine einfache Schlussfolgerung gezogen werden: LiveData ist ein zuverlässiges reaktives Programmierwerkzeug.  Wir werden es verwenden, um den UI-Teil ohne Datenbindung zu aktualisieren.  Warum so? <br><br>  Die Struktur der XML-Dateien ermöglicht keine präzise Verteilung der aus &lt;data&gt; ... &lt;/ data&gt; erhaltenen Daten.  Wenn bei kleinen Dateien alles klar ist, was ist dann mit großen Dateien?  Was tun mit komplexen Bildschirmen, mehreren Einschließen und Übergeben mehrerer Felder?  Modelle überall verwenden?  Steife Feldbindungen bekommen?  Und wenn das Feld formatiert werden soll, Methoden aus Java-Paketen aufrufen?  Dies macht den Code hoffnungslos und vollständig Spaghetti.  Überhaupt nicht das, was MVVM versprochen hat. <br><br>  Durch das Ablehnen der Datenbindung werden Änderungen am UI-Teil transparent.  Alle Aktualisierungen erfolgen direkt im Beobachter.  Weil  Da der Kolin-Code präzise und klar ist, werden wir keine Probleme mit aufgeblähten Beobachtern bekommen.  Das Schreiben und Verwalten von Code wird einfacher.  XML-Dateien werden nur für das Design verwendet - keine Eigenschaft im Inneren. <br><br>  Die Datenbindung ist ein leistungsstarkes Werkzeug.  Es eignet sich hervorragend zum Lösen einiger Probleme und harmoniert gut mit Java, aber mit Kotlin ... Bei Kotlin ist die Datenbindung in den meisten Fällen nur rudimentär.  Die Datenbindung verkompliziert nur den Code und bietet keine Wettbewerbsvorteile. <br><br>  In Java hatten Sie die Wahl: Verwenden Sie entweder die Datenbindung oder schreiben Sie viel hässlichen Code.  In Kotlin können Sie direkt auf Ansichtselemente zugreifen, indem Sie findViewById () sowie dessen Eigenschaft umgehen.  Zum Beispiel: <br><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Instead of TextView textView = findViewById&lt;TextView&gt;(R.id.textView) textView.text = "Hello, world!" textView.visibility = View.VISIBLE</span></span></code> </pre> <br>  Es stellt sich eine logische Frage: Warum sollten Sie sich mit Gartenmodellen in XML-Dateien beschäftigen, Java-Methoden in XML-Dateien aufrufen und die Logik des XML-Teils überladen, wenn all dies vermieden werden kann? <br><br><h4>  Coroutinen anstelle von Thread () und Rx-Java </h4><br>  Coroutinen sind unglaublich leicht und einfach zu bedienen.  Sie sind ideal für die meisten einfachen asynchronen Aufgaben: Verarbeiten von Abfrageergebnissen, Aktualisieren der Benutzeroberfläche usw. <br><br>  Coroutinen können Thread () und Rx-Java effektiv ersetzen, wenn keine hohe Leistung erforderlich ist, weil  Sie bezahlen für Leichtigkeit mit Geschwindigkeit.  Rx-Java ist zweifellos funktionaler, für einfache Aufgaben sind jedoch nicht alle Ressourcen erforderlich. <br><br><h4>  Microsoft und der Rest </h4><br>  Für die Arbeit mit Outlook-Diensten wird die Microsoft Graph-API verwendet.  Mit den entsprechenden Berechtigungen erhalten Sie alle erforderlichen Informationen zu Mitarbeitern, Räumen und Event-Ahs (Besprechungen).  Zur Gesichtserkennung wird der Microsoft Face API-Clouddienst verwendet. <br><br>  Mit Blick auf die Zukunft werde ich sagen, dass zur Lösung des Skalierbarkeitsproblems Firebase-Cloud-Speicher verwendet wurde.  Dies wird unten diskutiert. <br><br><h2>  Architektur </h2><br><h3>  Skalierbarkeitsprobleme </h3><br>  Es ist ziemlich schwierig, das System vollständig oder teilweise skalierbar zu machen.  Dies ist besonders schwierig, wenn die erste Version der Anwendung nicht skalierbar war und die zweite Version skalierbar sein sollte.  Die Anwendung v1 hat gleichzeitig Anfragen an alle Räume gesendet.  Jedes der Tablets hat regelmäßig Anforderungen an den Server gesendet, um alle Daten zu aktualisieren.  Gleichzeitig haben sich die Geräte nicht miteinander synchronisiert, weil  Das Projekt hat einfach keinen eigenen Server. <br><br>  Wenn wir denselben Weg gehen und N Anforderungen von jedem der N Tablets senden, werden wir natürlich irgendwann entweder die Microsoft Graph-API umkippen oder unser System einfrieren lassen. <br><br>  Es wäre logisch, eine Client-Server-Lösung zu verwenden, bei der der Server das Diagramm abfragt, Daten sammelt und auf Anfrage Informationen für die Tablets bereitstellt. Hier trifft uns jedoch die Realität.  Das Projektteam besteht aus 2 Personen (Android-Entwickler und -Designer).  Sie müssen die Frist von 7 Wochen einhalten und das Backend wird nicht zur Verfügung gestellt, weil  Skalierung ist eine Anforderung des Entwicklers.  Das heißt aber nicht, dass die Idee aufgegeben werden muss? <br><br>  Die wahrscheinlich einzig richtige Lösung in dieser Situation ist die Verwendung von Cloud-Speicher.  Firebase ersetzt den Server und fungiert als Puffer.  Dann stellt sich Folgendes heraus: <i>Jedes Tablet fragt nur seine Adresse über die Microsoft Graph-API ab und synchronisiert bei Bedarf Daten im Cloud-Speicher, von wo aus sie von anderen Geräten gelesen werden können.</i> <br><br>  Der Vorteil dieser Implementierung ist eine schnelle Reaktion, weil  Firebase arbeitet im Echtzeitmodus.  Wir werden die Anzahl der Anfragen, die N-mal an den Server gesendet werden, reduzieren, was bedeutet, dass das Gerät etwas länger im Akkubetrieb arbeitet.  Aus finanzieller Sicht ist das Projekt nicht im Preis gestiegen, weil  Für dieses Projekt reicht die kostenlose Version von Firebase mit mehreren Reserven aus: 1 GB Speicher, 10.000 Autorisierungen pro Monat und 100 Verbindungen gleichzeitig.  Zu den Nachteilen könnte die Abhängigkeit von einem Framework eines Drittanbieters gehören, aber Firebase schafft Vertrauen in uns, weil  Es ist ein stabiles Produkt, das von Google gepflegt und entwickelt wird. <br><br>  Die Grundidee des neuen Systems lautete wie folgt: N Tablets und eine Cloud-Plattform für die Echtzeit-Datensynchronisation.  Beginnen wir mit dem Entwerfen der Anwendung. <br><br><h4>  LiveData im Repository </h4><br>  Es scheint, dass ich kürzlich die Regeln für gute Form festgelegt habe und sofort gegen eine von ihnen verstoße.  Im Gegensatz zur empfohlenen Verwendung von LiveData im ViewModel werden in diesem Projekt LiveData-Objekte im Repository initialisiert und alle Repositorys als Singleton deklariert.  Warum so? <br><br>  Eine ähnliche Lösung ist mit dem Anwendungsmodus verbunden.  Tabletten sind von 8 bis 20 Uhr geöffnet.  Während dieser ganzen Zeit wurde nur der Meeting Room Helper auf ihnen gestartet.  Infolgedessen können und sollten viele Objekte langlebig sein (aus diesem Grund sind alle Repositorys als Singleton konzipiert). <br><br>  Im Laufe der Arbeit wird der UI-Inhalt regelmäßig gewechselt, was wiederum die Erstellung und Neuerstellung von ViewModel-Objekten beinhaltet.  Wenn Sie LiveData im ViewModel verwenden, wird für jedes erstellte Fragment ein eigenes ViewModel mit einer Reihe angegebener LiveData-Objekte erstellt.  Wenn zwei ähnliche Fragmente gleichzeitig mit unterschiedlichem ViewModel und einem gemeinsamen Base-ViewModel auf dem Bildschirm angezeigt werden, werden während der Initialisierung LiveData-Objekte aus dem Base-ViewModel dupliziert.  In Zukunft werden diese Duplikate Speicherplatz beanspruchen, bis sie vom "Garbage Collector" zerstört werden.  Weil  Wenn wir bereits ein Repository in Form eines Singletons haben und die Kosten für die Neuerstellung von Bildschirmen minimieren möchten, ist es ratsam, LiveData-Objekte in ein Singleton-Repository zu übertragen, um ViewModel-Objekte zu vereinfachen und die Anwendung zu beschleunigen. <br><br>  Dies bedeutet natürlich nicht, dass Sie alle LiveData vom ViewModel in das Repository übertragen müssen, aber Sie sollten dieses Problem sorgfältiger angehen und Ihre Wahl bewusst treffen.  Der Nachteil dieses Ansatzes ist die Zunahme der Anzahl langlebiger Objekte, weil  Alle Repositorys sind als Singleton definiert und in jedem von ihnen werden LiveData-Objekte gespeichert.  In einem bestimmten Fall ist Meeting Room Helper jedoch kein Minus, weil  Die Anwendung wird den ganzen Tag ohne Unterbrechung ausgeführt, ohne den Kontext zu anderen Anwendungen zu wechseln. <br><br><h4>  Resultierende Architektur </h4><br><img src="https://habrastorage.org/webt/yf/db/uo/yfdbuo8--ygtmrgxsybvuiuyeme.png"><br><br><ul><li>  Alle Anforderungen werden in Repositorys ausgeführt.  Alle Repositorys (im Meeting Room Helper gibt es 11 davon) sind als Singleton konzipiert.  Sie sind nach Art der zurückgegebenen Objekte unterteilt und hinter den Fassaden versteckt. </li><li>  Die Geschäftslogik befindet sich im ViewModel.  Dank der Verwendung von "Presenters" betrug die Gesamtgröße aller ViewModel (es gibt 6 im Projekt) weniger als 120 Zeilen. </li><li>  Aktivität und Fragment sind nur beim Ändern des UI-Teils mithilfe von Observer und LiveData beteiligt, die vom ViewModel zurückgegeben werden. </li><li>  Funktionen zum Verarbeiten und Generieren von Daten werden im "Presenter" gespeichert.  Aktiv genutzte Berechtigungsfunktionen von Kotlin für die Datenverarbeitung. </li></ul><br>  Die Hintergrundlogik wurde in Intent-Service verschoben: <br><br><ul><li>  Event-Update-Service.  Dienst, der für die Synchronisierung der Daten des aktuellen Raums in der Firebase- und Graph-API verantwortlich ist. </li><li>  User-Recognize-Service.  Läuft nur auf dem Master-Tablet.  Verantwortlich für das Hinzufügen neuer Mitarbeiter zum System.  Überprüft eine Liste bereits geschulter Personen mit einer Liste aus Active Directory.  Wenn neue Personen angezeigt werden, fügt der Dienst sie der Face-API hinzu und schult das neuronale Netzwerk neu.  Nach Abschluss des Vorgangs wird es ausgeschaltet.  Es beginnt mit dem Start der Anwendung. </li><li>  Der Online-Benachrichtigungsdienst benachrichtigt andere Tablets, dass dieses Tablet funktioniert, d. H.  Die externe Batterie ist nicht erschöpft.  Es funktioniert über Firebase. </li></ul><br>  Das Ergebnis war eine im Hinblick auf die Verteilung der Verantwortlichkeiten recht flexible und korrekte Architektur, die alle Anforderungen der modernen Entwicklung erfüllt.  Wenn wir in Zukunft die Microsoft Graph-API, Firebase oder ein anderes Modul aufgeben, können diese problemlos durch neue ersetzt werden, ohne den Rest der Anwendung zu beeinträchtigen.  Das Vorhandensein eines umfangreichen Systems von „Präsentatoren“ ermöglichte es, alle Datenverarbeitungsfunktionen über den Kern hinaus zu übernehmen.  Infolgedessen ist die Architektur kristallklar geworden, was ein großes Plus ist.  Das Problem eines überwucherten ViewModel ist vollständig verschwunden. <br><br>  Im Folgenden werde ich ein Beispiel für das häufig verwendete Bundle in einer entwickelten Anwendung geben. <br><br><h3>  Übe.  Updates ansehen </h3><br>  Abhängig vom Status des Besprechungsraums zeigt das Zifferblatt eine der folgenden Bedingungen an: <br><br><img src="https://habrastorage.org/webt/sa/o2/to/sao2towzwxh0qqlp1gvxd_s2qjg.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Darüber hinaus befinden sich temporäre Rallye-Bögen entlang des Umrisses des Zifferblatts, und die Mitte zählt bis zum Ende des Meetings oder bis zum Beginn der nächsten Rallye herunter.  All dies erledigt die von uns entwickelte Canvas-Bibliothek.  Wenn sich das Raster der Besprechungen geändert hat, müssen wir die Daten in der Bibliothek aktualisieren. <br><br>  Da LiveData in Repositories angekündigt wird, ist es am logischsten, mit ihnen zu beginnen. <br><br><h4>  Repositories </h4><br>  <i>FirebaseRoomRepository</i> - eine Klasse, die für das Senden und Verarbeiten von Anforderungen in Firebase im Zusammenhang mit dem Raummodell verantwortlich ist. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. object FirebaseRoomRepository { private val database = FirebaseFactory.database val rooms: MutableList&lt;Room&gt; = ArrayList() // 2. var currentRoom: MutableLiveData&lt;Room?&gt; = MutableLiveData() val onlineStatus: MediatorLiveData&lt;HashMap&lt;String, Boolean&gt;&gt; = MediatorLiveData() var otherRooms: MutableLiveData&lt;List&lt;Room&gt;&gt; = MutableLiveData() var ownRoom: MutableLiveData&lt;Room&gt; = MutableLiveData() // 3. private val roomsListener = object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { updateRooms(dataSnapshot) } override fun onCancelled(error: DatabaseError) {} } init { // 4. database.getReference(ROOMS_CURRENT_STATES) .addValueEventListener(roomsListener) } // 5. private fun updateRooms(dataSnapshot: DataSnapshot) { rooms.updateRooms(dataSnapshot) otherRooms.updateOtherRooms(rooms) ownRoom.updateOwnRoom(rooms) currentRoom.updateCurrentRoom(rooms, ownRoom) } }</span></span></code> </pre><br>  Um dies zu demonstrieren, wurde der Initialisierungscode der Listener-Firebase leicht vereinfacht (die Funktion zum erneuten Verbinden wurde entfernt).  Werfen wir einen Blick auf die Punkte, die hier geschehen: <br><br><ol><li>  Das Repository ist als Singleton konzipiert (in Kotlin reicht es aus, das Schlüsselwort class durch object zu ersetzen). </li><li>  Initialisierung von LiveData-Objekten; </li><li>  ValueEventListener wird als Variable deklariert, um zu vermeiden, dass bei erneuter Verbindung eine anonyme Klasse neu erstellt wird (denken Sie daran, ich habe die Initialisierung vereinfacht, indem ich bei erneuter Verbindung die erneute Verbindung entfernt habe). </li><li>  Initialisierung von ValueEventListener (wenn sich die Daten in Firebase ändern, führt der Listener die Daten in LiveData-Objekten sofort aus und aktualisiert sie); </li><li>  Aktualisierungen von LiveData-Objekten. </li></ol><br>  Die Funktionen selbst werden in eine separate FirebaseRoomRepositoryPresenter-Datei verschoben und als Erweiterungsfunktionen dekoriert. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> MutableLiveData</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;List&lt;Room&gt;</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateOtherRooms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rooms: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MutableList</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Room</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.postValue(rooms.filter { !it.isOwnRoom() }) }</code> </pre><br>  <i>Beispiel für eine Erweiterungsfunktion aus FirebaseRoomRepositoryPresenter</i> <br><br>  Für ein allgemeines Verständnis des Bildes werde ich auch eine Auflistung des Raumobjekts geben. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. data class Room(var number: String = "", var nickName: String = "", var email: String? = null, var imgSmall: String? = null, var imgOffline: String? = null, var imgFree: String? = null, var imgWait: String? = null, var imgBusy: String? = null, var events: List&lt;Event.Short&gt; = emptyList()) // 2.</span></span></code> </pre><br><ol><li>  Datenklasse.  Dieser Modifikator generiert automatisch die Methoden toString (), HashCode () und same () und überschreibt sie.  Sie müssen sie nicht mehr selbst neu definieren. </li><li>  Die Ereignisliste aus dem Raumobjekt.  Diese Liste ist erforderlich, um die Daten in der Wählbibliothek zu aktualisieren. </li></ol><br>  Alle Repositories-Klassen sind hinter der Fassadenklasse versteckt. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Repository { <span class="hljs-comment"><span class="hljs-comment">// 1. private val firebaseRoomRepository = FirebaseRoomRepository // ......... /** * Rooms queries */ fun getOtherRooms() = firebaseRoomRepository.otherRooms fun getOwnRoom() = firebaseRoomRepository.ownRoom fun getAllRooms() = firebaseRoomRepository.rooms // 2. fun getCurrentRoom() = firebaseRoomRepository.currentRoom //   // ....... }</span></span></code> </pre><br><ol><li>  Oben sehen Sie eine Liste aller verwendeten Repository-Klassen und Fassaden der zweiten Ebene.  Dies vereinfacht das allgemeine Verständnis des Codes und zeigt eine Liste aller verbundenen Repository-Klassen. </li><li>  Eine Liste von Methoden, die Verweise auf LiveData-Objekte aus dem FirebaseRoomRepository zurückgeben.  Kotlins Setter und Getter sind optional, sodass Sie sie nicht unnötig schreiben müssen. </li></ol><br>  Mit einer solchen Organisation können Sie bequem 20 bis 30 Anforderungen in ein Root-Repository einfügen.  Wenn Ihre Anwendung mehr Anforderungen hat, müssen Sie die Grundfassade in zwei oder mehr teilen. <br><br><h4>  ViewModel </h4><br>  BaseViewModel ist das Basis-ViewModel, von dem alle ViewModels geerbt werden.  Es enthält ein einzelnes currentRoom-Objekt, das universell verwendet wird. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. open class BaseViewModel : ViewModel() { // 2. fun getCurrentRoom() = Repository.getCurrentRoom() }</span></span></code> </pre><br><ol><li>  Der offene Marker bedeutet, dass Sie von der Klasse erben können.  Standardmäßig sind in Kotlin alle Klassen und Methoden endgültig, d. H.  Klassen können nicht vererbt und Methoden nicht neu definiert werden.  Dies dient zum Schutz vor versehentlichen inkompatiblen Versionsänderungen.  Ich werde ein Beispiel geben. <br><br>  <i>Sie entwickeln eine neue Version der Bibliothek.</i>  <i>Aus dem einen oder anderen Grund entscheiden Sie sich irgendwann, die Klasse umzubenennen oder die Signatur einer Methode zu ändern.</i>  <i>Durch Ändern haben Sie versehentlich eine Versionsinkompatibilität erstellt.</i>  <i>Ups ... Wenn Sie wahrscheinlich gewusst hätten, dass die Methode von jemandem überschrieben werden könnte und die Klasse geerbt wurde, wären Sie wahrscheinlich genauer gewesen und hätten sich kaum in den Fuß geschossen.</i>  <i>Zu diesem Zweck wird in Kotlin standardmäßig alles als endgültig deklariert, und zum Abbrechen gibt es einen "offenen" Modifikator.</i> <br></li><li>  Die Methode getCurrentRoom () gibt einen Link zum LiveData-Objekt des aktuellen Raums aus dem Repository zurück, der wiederum aus dem FirebaseRoomRepository stammt.  Wenn diese Methode aufgerufen wird, gibt das Room-Objekt alle Informationen zum Raum zurück, einschließlich einer Liste von Ereignissen. </li></ol><br>  Um Daten von einem Format in ein anderes zu konvertieren, verwenden wir die Transformation.  Erstellen Sie dazu ein <i>MainFragmentViewModel</i> und erben Sie es von <i>BaseViewModel</i> . <br><br>  <i>MainFragmentViewModel</i> ist eine von BaseViewModel <i>abgeleitete</i> Klasse.  Dieses ViewModel wird nur in MainFragment verwendet. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. class MainFragmentViewModel: BaseViewModel () { // 2. var currentRoomEvents = Transformations.switchMap(getCurrentRoom()) { val events: MutableLiveData&lt;List&lt;Event.Short&gt;&gt; = MutableLiveData() // some business logic events.postValue(it?.eventsList) events } // 3. val currentRoomEvents2 = MediatorLiveData&lt;List&lt;Event.Short&gt;&gt;().apply { addSource(getCurrentRoom()) { room -&gt; // some business logic postValue(room?.eventsList) } } }</span></span></code> </pre><br><ol><li>  Beachten Sie das Fehlen des Modifikators open.  Dies bedeutet, dass niemand von der Klasse erbt. </li><li>  currentRoomEvents - Ein Objekt, das mithilfe der Transformation erhalten wurde.  Sobald sich das Objekt des aktuellen Raums ändert, wird die Transformation durchgeführt und das Objekt currentRoomEvents aktualisiert. </li><li>  MediatorLiveData.  Das Ergebnis ist identisch mit der Transformation (als Referenz gezeigt). </li></ol><br>  Die erste Option wird verwendet, um Daten von einem Typ in einen anderen zu konvertieren, was wir brauchten, und die zweite Option wird benötigt, um eine Geschäftslogik auszuführen.  Eine Datenkonvertierung findet jedoch nicht statt.  Denken Sie daran, dass der Android-Import in ViewModel nicht gültig ist.  Daher starte ich von hier aus zusätzliche Anfragen oder starte die Dienste nach Bedarf neu. <br><br>  <b>Wichtiger Hinweis!</b>  Damit die Transformation oder der Mediator funktioniert, muss jemand von einem Fragment oder einer Aktivität abonniert werden.  Andernfalls wird der Code nicht ausgeführt, weil  Niemand wird ein Ergebnis erwarten (dies sind Beobachterobjekte). <br><br><h4>  Mainfragment </h4><br>  Der letzte Schritt bei der Konvertierung von Daten in Ergebnisse.  MainFragment enthält eine Wählbibliothek und einen View-Pager am unteren Bildschirmrand. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseFragment</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// 1. private lateinit var viewModel: MainFragmentViewModel // 2. private val currentRoomObserver = Observer&lt;List&lt;Event.Short&gt;&gt; { clockView.updateArcs(it) } override fun onAttach(context: Context?) { super.onAttach(context) // 3. viewModel = ViewModelProviders.of(this).get(MainFragmentViewModel::class.java) } override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { return inflater.inflate(R.layout.fragment_main, container, false) } override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) // 4. viewModel.currentRoomEvents.observe(viewLifecycleOwner, currentRoomObserver) } }</span></span></code> </pre><br><ol><li>  Initialisierung von MainFragmentViewModel.  Der Modifikator lateinit gibt an, dass wir versprechen, dieses Objekt später zu initialisieren, bevor wir es verwenden.  Kotlin versucht, den Programmierer vor falschem Schreiben von Code zu schützen, daher müssen wir entweder sofort sagen, dass das Objekt null sein kann, oder lateinit setzen.  In diesem Fall muss das ViewModel vom Objekt initialisiert werden. </li><li>  Beobachter-Listener, um das Zifferblatt zu aktualisieren. </li><li>  ViewModel initialisieren.  Bitte beachten Sie, dass dies unmittelbar nach dem Anhängen des Fragments an die Aktivität geschieht. </li><li>  Nachdem die Aktivität erstellt wurde, abonnieren wir Änderungen am currentRoomEvents-Objekt.  Bitte beachten Sie, dass ich nicht den Fragmentlebenszyklus (this) abonniere, sondern das viewLifecycleOwner-Objekt.  Tatsache ist, dass in der Support-Bibliothek 28.0.0 und AndroidX 1.0.0 ein Fehler festgestellt wurde, als der Beobachter "abgemeldet" wurde.  Um dieses Problem zu lösen, wurde ein Patch in Form von viewLifecycleOwner veröffentlicht, und Google empfiehlt, ihn zu abonnieren.  Dies behebt das Problem des Zombie-Beobachters, wenn das Fragment gestorben ist und der Beobachter weiter arbeitet.  Wenn Sie dies weiterhin verwenden, müssen Sie es durch viewLifecycleOwner ersetzen. </li></ol><br>  Daher möchte ich die Einfachheit und Schönheit von MVVM und LiveData ohne Datenbindung demonstrieren.  Bitte beachten Sie, dass ich in diesem Projekt gegen die allgemein akzeptierte Regel verstoße, indem ich LiveData aufgrund der Besonderheiten des Projekts in das Repository stelle.  Wenn wir sie jedoch in das ViewModel verschieben, bleibt das Gesamtbild unverändert. <br><br>  Als Kirsche auf einem Kuchen habe ich für Sie ein kurzes Video mit einer Demonstration vorbereitet (Namen werden gemäß den Sicherheitsanforderungen verschmiert, ich entschuldige mich): <br><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E9zUc0vaGck" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Zusammenfassung </h3><br>  Infolge der Anwendung im ersten Monat wurden einige Fehler bei der Anzeige von Cross-Rallyes aufgedeckt (mit Outlook können Sie mehrere Ereignisse gleichzeitig erstellen, während unser System dies nicht tut).  Jetzt arbeitet das System seit 3 ​​Monaten.  Fehler oder Ausfälle werden nicht beobachtet. <br><br>  PS Danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">jericho_code</a> für den Kommentar.  In Kotlin können und sollten Sie List &lt;&gt; im Modell mit emptyList () initialisieren, dann wird kein zusätzliches Objekt erstellt. <br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> events: List&lt;Event.<span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>&gt; = emptyList() <span class="hljs-comment"><span class="hljs-comment">//      EmptyList var events: List&lt;Event.Short&gt; = ArrayList() //   </span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457960/">https://habr.com/ru/post/de457960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457948/index.html">Brettspiele, bei denen man sich den Kopf zerschlagen muss</a></li>
<li><a href="../de457952/index.html">Wie Prozessoren entworfen und hergestellt werden: Chipherstellung</a></li>
<li><a href="../de457954/index.html">Warum Swift ein großes Ereignis im Deep Learning werden kann</a></li>
<li><a href="../de457956/index.html">So wählen Sie die Aufbewahrung, ohne sich in den Fuß zu schießen</a></li>
<li><a href="../de457958/index.html">Alltag MT_FREE: Mehrere Geschichten über den Einfluss von Diensten Dritter auf die Arbeit von öffentlichem WLAN</a></li>
<li><a href="../de457962/index.html">Wie bei der Thrash-Architektur und dem Mangel an Fähigkeiten in Scrum haben wir komponentenübergreifende Teams erstellt</a></li>
<li><a href="../de457964/index.html">Echte Virtualität: Workstations ++</a></li>
<li><a href="../de457966/index.html">„Ich würde eine spezielle IT-Zone im Süden Russlands eröffnen“ - 10 Fragen an Programmierer Nr. 11. Neue Saison</a></li>
<li><a href="../de457968/index.html">Parallelen, die sich überschneiden - das Kommunikationsministerium hat über Nacht Milliarden an Budgets verbrannt</a></li>
<li><a href="../de457970/index.html">Linter in Go. Wie man sie kocht. Denis Isaev</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>