<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛐 🦗 👩🏾‍🏭 我们在Rust上编写一个操作系统。 实现页面内存（新） 🎰 🚝 🏡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我们将探讨如何在我们的核心中实现页面内存支持。 首先，我们将研究各种方法，以便物理页表的框架可用于内核，并讨论它们的优缺点。 然后，我们实现地址转换功能和创建新映射的功能。 

 该系列文章在GitHub上发布 。 如果您有任何疑问或问题，请在此处打开相应的票证。 本文的所有来源都在此线程...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们在Rust上编写一个操作系统。 实现页面内存（新）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445618/"> 在本文中，我们将探讨如何在我们的核心中实现页面内存支持。 首先，我们将研究各种方法，以便物理页表的框架可用于内核，并讨论它们的优缺点。 然后，我们实现地址转换功能和创建新映射的功能。 <br><br> 该系列文章在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布</a> 。 如果您有任何疑问或问题，请在此处打开相应的票证。 本文的所有来源都<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此线程中</a> 。 <br><br>  <i><b>关于分页的另一篇文章？</b></i> <i><br></i>  <i>如果遵循此周期，则在一月底您会看到文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“页面内存：高级”</a> 。</i>  <i>但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我因</a>递归页表<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">而受到批评</a> 。</i>  <i>因此，我决定使用另一种访问框架的方法来重写文章。</i> <br><a name="habracut"></a><br>  <i>这是一个新选项。</i>  <i>本文仍然说明了递归页表的工作方式，但是我们使用了一个更简单，更强大的实现。</i>  <i>我们不会删除前一篇文章，但会将其标记为过时的并且不会更新。</i> <i><br><br></i>  <i>希望您喜欢新的选择！</i> <br><br><h1> 目录内容 </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引言</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">依赖关系更新</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">访问页表</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">身份映射</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">固定偏移图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完整的物理内存映射</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">临时展示</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">递归页表</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引导加载程序支持</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开机资讯</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">入口点宏</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实作</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">访问页表</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">地址翻译</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用MappedPageTable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建一个新的映射</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选框</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">总结</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">接下来是什么？</a> </li></ul><br><a name="1"></a><h1> 引言 </h1><br> 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中，</a>我们了解了分页内存的原理以及<code>x86_64</code>上的四级页表如何<code>x86_64</code> 。 我们还发现加载器已经为内核设置了页表层次结构，因此内核在虚拟地址上运行。 这会提高安全性，因为对内存的未授权访问会导致页面错误，而不是随机更改物理内存。 <br><br> 最终文章无法从我们的内核访问页表，因为它们存储在物理内存中，并且内核已经在虚拟地址上运行。 在这里，我们继续该主题，并探索用于从内核访问页表框架的不同选项。 我们将讨论它们各自的优缺点，然后为我们的核心选择适当的选项。 <br><br> 需要引导加载程序支持，因此我们将首先对其进行配置。 然后，我们实现了一个功能，该功能贯穿页表的整个层次结构，以便将虚拟地址转换为物理地址。 最后，我们将学习如何在页表中创建新的映射，以及如何找到未使用的内存帧来创建新表。 <br><br><a name="1_1"></a><h3> 依赖关系更新 </h3><br> 本文要求您在依赖项中注册0.4.0或更高版本的<code>bootloader</code>以及0.5.2或更高版本的<code>x86_64</code> 。 您可以在<code>Cargo.toml</code>更新依赖<code>Cargo.toml</code> ： <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = "0.4.0" x86_64 = "0.5.2"</code> </pre> <br> 有关这些版本的更改，请参见<a href="">bootloader日志</a>和<a href="">x86_64日志</a> 。 <br><br><a name="2"></a><h1> 访问页表 </h1><br> 从内核访问页表并不像看起来那样容易。 要了解此问题，请再看看上一篇文章中的四级表层次结构： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br> 重要的是每个页面条目都存储下一张表的<i>物理</i>地址。 这避免了这些地址的转换，从而降低了性能并容易导致无限循环。 <br><br> 问题是我们不能直接从内核访问物理地址，因为它也可以在虚拟地址上工作。 例如，当我们访问地址<code>4 KiB</code> ，我们将访问<i>虚拟</i>地址<code>4 KiB</code> ，而不是存储第4级页面表的<i>物理</i>地址。 如果我们要访问<code>4 KiB</code>的物理地址，则需要使用一些虚拟地址，将其转换为虚拟地址。 <br><br> 因此，要访问页表的框架，您需要将一些虚拟页面映射到这些框架。 有多种创建此类映射的方法。 <br><br><a name="2_1"></a><h3> 身份映射 </h3><br> 一个简单的解决方案是<b>所有页表的显示相同</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br> 在此示例中，我们看到相同的帧显示。 页表的物理地址同时是有效的虚拟地址，因此我们可以轻松地从寄存器CR3开始访问所有级别的页表。 <br><br> 但是，这种方法会使虚拟地址空间变得混乱，并使得很难找到较大的连续区域的空闲内存。 假设我们要在上图中创建一个1000 KiB虚拟内存区域，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在memory中显示一个文件</a> 。 我们不能从<code>28 KiB</code>区域开始，因为它位于已经占用的页面<code>1004  KiB</code> 。 因此，您将不得不进一步寻找，直到找到合适的大片段，例如<code>1008  KiB</code> 。 存在与分段存储器相同的碎片问题。 <br><br> 另外，新页表的创建要复杂得多，因为我们需要找到尚未使用相应页的物理框架。 例如，对于我们的文件，我们保留了1000 KiB的<i>虚拟</i>内存区域，从地址<code>1008  KiB</code> 。 现在，我们不能再使用物理地址在<code>1000  KiB</code>和<code>2008  KiB</code>之间的任何帧，因为它不能显示相同。 <br><br><a name="2_2"></a><h3> 固定偏移图 </h3><br> 为避免虚拟地址空间混乱，可以将页表显示在<b>单独的存储区中</b> 。 因此，我们无需标识映射，而是在虚拟地址空间中映射具有固定偏移量的帧。 例如，偏移量可以是10 TiB： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/c8a/5ea/f4ac8a5ea64fd215de176248b5f74e20.svg"><br><br> 通过完全分配此虚拟内存范围来显示页表，我们避免了显示相同的问题。 仅当虚拟地址空间远大于物理内存的大小时，才可以保留如此大的虚拟地址空间区域。 在<code>x86_64</code>这不是问题，因为48位地址空间为256 TiB。 <br><br> 但是这种方法的缺点是，在创建每个页表时，您需要创建一个新的映射。 另外，它不允许访问其他地址空间中的表，这在创建新进程时很有用。 <br><br><a name="2_3"></a><h3> 完整的物理内存映射 </h3><br> 我们可以通过<b>显示所有物理内存</b>而不仅仅是页面表框架来解决这些问题： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/3cf/7df/c393cf7df76515739e1d9274160c4b5d.svg"><br><br> 这种方法允许内核访问任意物理内存，包括其他地址空间的页表框架。 保留一定范围的虚拟内存，大小与以前相同，但是其中没有剩余的不匹配页面。 <br><br> 这种方法的缺点是需要额外的页表来显示物理内存。 这些页表应存储在某个位置，以便它们使用一些物理内存，这在具有少量RAM的设备上可能是个问题。 <br><br> 但是，在x86_64上，我们可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">巨大的</a> 2个MiB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">页面</a>来显示，而不是使用默认大小4 KiB。 因此，要显示32 GiB的物理内存，每页表仅需要132 KiB：仅一个第三级表和32个第二级表。 由于它们在动态转换缓冲区（TLB）中使用的条目较少，因此也可以更有效地缓存大量页面。 <br><br><a name="2_4"></a><h3> 临时展示 </h3><br> 对于物理内存很少的设备，仅在需要访问它们时才可以<b>临时显示页表</b> 。 对于临时比较，只需要第一级表的相同显示即可： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00a/3ab/5ce/00a3ab5ce85057d3679a48379d3d2297.svg"></div><br><br> 在此图中，级别1表管理虚拟地址空间的前2个MiB。 这是可能的，因为从CR3寄存器通过级别4、3和2的表中的空条目进行访问。索引为<code>8</code>的记录将<code>32 KiB</code>的虚拟页转换为<code>32 KiB</code>的物理帧，从而识别1级表本身。在图中用水平箭头表示。 <br><br> 通过写入相同映射的1级表，我们的内核最多可以创建511次时间比较（512减去身份映射所需的记录）。 在上面的示例中，内核创建了两个时间比较： <br><br><ul><li> 将1级表中的空条目映射到<code>24 KiB</code>处的帧。 这将在<code>0 KiB</code>处创建虚拟页面到由虚线箭头指示的页面级别2表的物理帧的临时映射。 </li><li> 将第1级表的第9条记录与<code>4 KiB</code>的帧相匹配。 这将在<code>36 KiB</code>处创建虚拟页面到由虚线箭头指示的页面级别4表的物理框架的临时映射。 </li></ul><br> 现在，内核可以通过写入从<code>0 KiB</code>开始的页面访问2级表，并通过写入从<code>33 KiB</code>开始的页面访问4级表。 <br><br> 因此，使用临时映射访问页表的任意框架包括以下操作： <br><br><ul><li> 在相同显示的1级表中找到一个免费条目。 <br></li><li> 将此条目映射到我们要访问的页表的物理框架。 <br></li><li> 通过与条目关联的虚拟页面访问此框架。 <br></li><li> 将记录重新设置为未使用，从而删除临时映射。 </li></ul><br> 使用这种方法，虚拟地址空间保持干净，因为经常使用相同的512个虚拟页面。 缺点是麻烦，特别是因为新的比较可能需要更改表的多个级别，也就是说，我们需要重复上述过程几次。 <br><br><a name="2_5"></a><h3> 递归页表 </h3><br> 另一个根本不需要附加页表的有趣方法是<b>递归匹配</b> 。 <br><br> 这个想法是将一些记录从第四级表转换成它本身。 因此，我们实际上保留了虚拟地址空间的一部分，并将所有当前和将来的表框架映射到该空间。 <br><br> 让我们看一个例子，以了解这一切如何工作： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br> 与本文开头的示例唯一的不同是，在第4级表中具有索引<code>511</code>的附加记录被映射到位于该表本身中的物理帧<code>4 KiB</code> 。 <br><br> 当CPU继续执行该记录时，它不会引用3级表，而是再次引用4级表，这类似于调用自身的递归函数。 重要的是，处理器必须假定4级表中的​​每个条目都指向3级表，所以现在将4级表视为3级表，因为x86_64中所有级别的表都具有相同的结构，所以这种方法有效。 <br><br> 通过在开始实际转换之前跟踪一次或多次递归记录，我们可以有效地减少处理器经历的级别数。 例如，如果我们跟踪一次递归记录，然后转到3级表，则处理器认为3级表是2级表，接着，他将2级表视为1级表，并将1级表视为已映射物理内存中的帧。 这意味着我们现在可以读写页面1级表，因为处理器认为这是一个映射的帧。 下图显示了这种转换的五个步骤： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br> 同样，在开始转换之前，我们可以跟踪两次递归项以减少传递给两个级别的数量： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br> 让我们逐步完成此过程。 首先，CPU跟踪4级表中的​​递归条目，并认为它已到达3级表，然后再次跟踪递归记录，并认为它已达到2级。但实际上，它仍处于4级，然后CPU转到了新地址。进入第3层表，但认为它已经在第1层表中。最后，在第2层表的下一个入口点，处理器认为它已经访问了物理内存帧。 这使我们可以读写2级表。 <br><br> 还访问了3级和4级表。要访问3级表，我们遵循三遍递归记录：处理器认为它已经在1级表中，并且在下一步中我们达到3级，CPU将其视为映射帧。 要访问4级表本身，我们只需遵循递归记录四次，直到处理器将4级表本身作为映射帧处理（下图中的蓝色）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br> 起初很难理解这个概念，但实际上它运作良好。 <br><br><h4> 地址计算 </h4><br> 因此，我们可以通过遵循一次或多次递归记录来访问所有级别的表。 由于四级表中的索引是直接从虚拟地址派生的，因此必须为此方法创建特殊的虚拟地址。 我们记得，页表索引是从地址中提取的，如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br> 假设我们要访问显示特定页面的1级表。 如上所述，您需要遍历一次递归记录，然后遍历第四，第三和第二级的索引。 为此，我们将所有地址块向右移动一个块，并将递归记录的索引设置为4级初始索引的位置： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br> 要访问此页面的2级表，我们将所有索引块向右移动两个块，并将递归索引设置为两个源块的位置：4级和3级： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br> 要访问3级表，我们进行了相同的操作，我们只需要向右移动三个地址块即可。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br> 最后，要访问4级表，请将所有内容向右移动四个块。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br> 现在，您可以计算所有四个级别的页表的虚拟地址。 我们甚至可以通过将其索引乘以8（即页表项的大小）来计算精确指向特定页表项的地址。 <br><br> 下表显示了用于访问各种类型帧的地址的结构： <br><br><table><thead><tr><th> 的虚拟地址 </th><th> 地址结构（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">八进制</a> ） </th></tr></thead><tbody><tr><td> 页数 </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td> 进入1级表 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td> 在2级表中输入 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td> 在3级表中输入 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td> 进入第4级表格 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br> 在这里， <code></code>是4级索引， <code></code>是3级， <code></code>是2级， <code>DDD</code>是所显示帧的1级索引， <code>EEEE</code>是其偏移量。  <code>RRR</code>是递归记录的索引。 索引（三位数）通过乘以8（页表项的大小）而转换为偏移量（四位数）。 使用此偏移量，结果地址直接指向相应的页表条目。 <br><br>  <code>SSSS</code>是带符号数字的扩展位，也就是说，它们都是位47的副本。这是对x86_64体系结构中有效地址的特殊要求，我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章</a>中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已经</a>讨论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">过</a> 。 <br><br> 地址是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">八进制的</a> ，因为每个八进制字符代表三位，这使您可以清楚地区分不同级别的表的9位索引。 在每个字符代表四个位的十六进制系统中，这是不可能的。 <br><br><h4> 防锈码 </h4><br> 您可以使用位运算在Rust代码中构造这样的地址： <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// the virtual address whose corresponding page tables you want to access let addr: usize = […]; let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12);</span></span></code> </pre> <br> 该代码假定递归匹配索引为<code>0o777</code> （511）的最后4级记录的递归映射。 当前情况并非如此，因此代码尚无法使用。 请参见下文，了解如何告知加载程序设置递归映射。 <br><br> 作为手动执行按位操作的替代方法，可以使用<code>x86_64</code>板条箱的<code>RecursivePageTable</code>类型，该类型为各种表操作提供安全的抽象。 例如，以下代码显示了如何将虚拟地址转换为其相应的物理地址： <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. let level_4_table_addr = […]; let level_4_table_ptr = level_4_table_addr as *mut PageTable; let recursive_page_table = unsafe { let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap(); } /// Retrieve the physical address for the given virtual address let addr: u64 = […] let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset()))</span></span></code> </pre> <br> 同样，此代码需要正确的递归映射。 使用此映射，将像第一个代码示例一样计算丢失的<code>level_4_table_addr</code> 。 <br><br><hr><br> 递归映射是一种有趣的方法，它显示了通过单个表进行匹配的强大程度。 它相对容易实现，只需要最少的设置（只需一个递归项），因此这对于第一个实验是一个不错的选择。 <br><br> 但这有一些缺点： <br><br><ul><li> 大量的虚拟内存（512 GiB）。 在较大的48位地址空间中，这不是问题，但可能导致次优缓存行为。 <br></li><li> 它可以轻松地仅访问当前活动的地址空间。 通过更改递归项，仍然可以访问其他地址空间，但是切换需要临时匹配。 我们在上一篇（过时的）文章中介绍了如何执行此操作。 <br></li><li> 它在很大程度上取决于x86页表格式，并且可能无法在其他体系结构上使用。 </li></ul><br><a name="3"></a><h1> 引导加载程序支持 </h1><br> 上述所有方法都需要更改页表和相应的设置。 例如，要映射物理内存相同或递归地映射第四级表的记录。 问题在于，如果不访问页表，就无法进行这些设置。 <br><br> 因此，我需要引导加载程序的帮助。 他可以访问页表，因此可以创建我们需要的任何显示。 在当前的实现中， <code>bootloader</code>板条箱使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">货物功能</a>支持上述两种方法： <br><br><ul><li>  <code>map_physical_memory</code>函数将完整的物理内存映射到虚拟地址空间中的某个位置。 因此，内核可以获得对所有物理内存的访问权，并且可以采用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">显示完整物理内存的方法</a> 。 <br></li><li> 使用<code>recursive_page_table</code>函数，加载程序以递归方式显示第四级页表条目。 这允许内核根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“递归页表”一节中</a>描述的方法工作。 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于我们的内核，我们选择第一个选项，因为它是一种简单，独立于平台且功能更强大的方法（它还可以访问其他框架，而不仅仅是页面表）。</font><font style="vertical-align: inherit;">为了获得引导加载程序的支持，请将函数添加到其依赖项中</font></font><code>map_physical_memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = { version = "0.4.0", features = ["map_physical_memory"]}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果启用此功能，则引导加载程序会将整个物理内存映射到一些未使用的虚拟地址范围。</font><font style="vertical-align: inherit;">为了将一定范围的虚拟地址传递给内核，引导加载程序会传递</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引导信息</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的结构</font><font style="vertical-align: inherit;">。</font></font><br><br><a name="3_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 开机资讯 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">箱子</font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BootInfo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的结构，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">并将</font></a><font style="vertical-align: inherit;">所有信息传递给内核。</font><font style="vertical-align: inherit;">该结构仍在最终确定中，因此当升级到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与semver不兼容的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将来版本时，可能会出现一些故障</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当前，该结构具有两个字段：</font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该字段</font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供了可用物理内存的概述。</font><font style="vertical-align: inherit;">它告诉内核系统上有多少物理内存可用，以及哪些内存区域为VGA等设备保留。</font><font style="vertical-align: inherit;">可以从BIOS或UEFI固件中请求存储卡，但只能在启动过程的开始阶段。</font><font style="vertical-align: inherit;">由于这个原因，加载程序必须提供它，因为这样内核将不再能够接收此信息。</font><font style="vertical-align: inherit;">本文稍后将提供存储卡。</font></font><br></li><li> <code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">报告物理内存映射的虚拟起始地址。</font><font style="vertical-align: inherit;">将此偏移量添加到物理地址，我们得到相应的虚拟地址。</font><font style="vertical-align: inherit;">这样就可以从内核访问任意物理内存。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加载程序将结构</font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为</font></font><code>&amp;'static BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">的参数</font><font style="vertical-align: inherit;">传递</font><font style="vertical-align: inherit;">给</font><font style="vertical-align: inherit;">内核</font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">添加：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 指定正确的参数类型很重要，因为编译器不知道我们的入口点函数的正确签名类型。 </font></font><br><br><a name="3_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 入口点宏 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于功能</font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是从加载程序外部调用的，因此不会检查功能的签名。这意味着我们可以让它接受任意参数而不会出现编译错误，但这将导致崩溃或导致未定义的运行时行为。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了确保入口点功能始终具有正确的签名，包装箱</font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供了一个macro </font></font><code>entry_point</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们使用以下宏重写函数：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您不再需要使用入口点，</font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者</font></font><code>no_mangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为宏为我们定义了较低级别的实际入口点</font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该函数</font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在已成为完全正常的Rust函数，因此我们可以为其选择任意名称。</font><font style="vertical-align: inherit;">重要的是它是按类型检查的，因此，如果您使用了错误的签名，例如，通过添加参数或更改其类型，则会发生编译错误</font></font><br><br><a name="4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 实作 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以访问物理内存了，我们终于可以开始系统的实现了。</font><font style="vertical-align: inherit;">首先，考虑运行内核的当前活动页表。</font><font style="vertical-align: inherit;">在第二步中，创建一个转换函数，该函数返回该虚拟地址映射到的物理地址。</font><font style="vertical-align: inherit;">在最后一步，我们将尝试修改页表以创建新的映射。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，在代码中创建一个新模块</font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于模块，创建一个空文件</font></font><code>src/memory.rs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><a name="4_1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 访问页表 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一篇文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的末尾</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">，</font></a><font style="vertical-align: inherit;">我们试图查看内核可以运行的页面表，但是无法访问register指向的物理帧</font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。现在我们可以从这里继续工作：该函数</font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将返回一个链接到第四级活动页面的表：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::PageTable; /// Returns a mutable reference to the active level 4 table. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable { use x86_64::{registers::control::Cr3, VirtAddr}; let (level_4_table_frame, _) = Cr3::read(); let phys = level_4_table_frame.start_address(); let virt = VirtAddr::new(phys.as_u64() + physical_memory_offset); let page_table_ptr: *mut PageTable = virt.as_mut_ptr(); &amp;mut *page_table_ptr // unsafe }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我们从寄存器中读取第4级活动表的物理帧</font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后我们获取其物理起始地址，并通过添加将其转换为虚拟地址</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。最后，我们在原始指针变换地址</font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的方法</font></font><code>as_mut_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后从它的不安全链接创建</font></font><code>&amp;mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们</font></font><code>&amp;mut</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而是</font><font style="vertical-align: inherit;">创建链接</font></font><code>&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为在本文后面，我们将修改这些页表。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处无需插入不安全的块，因为Rust将整个身体</font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视为一个大的不安全的块。这增加了风险，因为有可能在前面的行中意外引入不安全的操作。这也使检测不安全操作变得困难。已经创建</font><font style="vertical-align: inherit;">了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来修改Rust的这种行为。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以使用此函数输出第四级表的记录：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::active_level_4_table; let l4_table = unsafe { active_level_4_table(boot_info.physical_memory_offset) }; for (i, entry) in l4_table.iter().enumerate() { if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); } } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传入结构的相应字段</font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后，我们使用一个函数</font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来迭代页表条目，并使用组合器</font><font style="vertical-align: inherit;">为每个元素</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">enumerate</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加索引</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。仅显示非空条目，因为所有512个条目均无法显示在屏幕上。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在运行代码时，我们看到以下结果：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a33/def/50d/a33def50db528880395b665882aabe75.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们看到了一些非空记录，它们映射到各种第三级表。使用这么多内存区域是因为内核代码，内核堆栈，物理内存转换和引导信息需要单独的区域。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要浏览页面表并查看第三级表，我们可以再次将显示的框架转换为虚拟地址：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in the for loop in src/main.rs use x86_64::{structures::paging::PageTable, VirtAddr}; if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); // get the physical address from the entry and convert it let phys = entry.frame().unwrap().start_address(); let virt = phys.as_u64() + boot_info.physical_memory_offset; let ptr = VirtAddr::new(virt).as_mut_ptr(); let l3_table: &amp;PageTable = unsafe { &amp;*ptr }; // print non-empty entries of the level 3 table for (i, entry) in l3_table.iter().enumerate() { if !entry.is_unused() { println!(" L3 Entry {}: {:?}", i, entry); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">若要查看第二级和第一级的表，请分别重复此过程以获取第三级和第二级的记录。</font><font style="vertical-align: inherit;">您可以想象，代码量增长非常快，因此我们将不会发布完整清单。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手动遍历表很有趣，因为它有助于了解处理器如何转换地址。</font><font style="vertical-align: inherit;">但是通常我们只希望为特定的虚拟地址显示一个物理地址，因此让我们为此创建一个功能。</font></font><br><br><a name="4_2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 地址翻译 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要将虚拟地址转换为物理地址，我们必须遍历四级页面表，直到到达映射的帧。</font><font style="vertical-align: inherit;">让我们创建一个执行此地址转换的函数：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::{PhysAddr, VirtAddr}; /// Translates the given virtual address to the mapped physical address, or /// `None` if the address is not mapped. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. pub unsafe fn translate_addr(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { translate_addr_inner(addr, physical_memory_offset) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用安全功能</font></font><code>translate_addr_inner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来限制不安全代码的数量。如上所述，Rust将整个身体</font></font><code>unsafe fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视为不安全的大障碍。通过调用一个安全功能，我们再次使每个操作都明确</font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊的内部功能具有实际功能：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// Private function that is called by `translate_addr`. /// /// This function is safe to limit the scope of `unsafe` because Rust treats /// the whole body of unsafe functions as an unsafe block. This function must /// only be reachable through `unsafe fn` from outside of this module. fn translate_addr_inner(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { use x86_64::structures::paging::page_table::FrameError; use x86_64::registers::control::Cr3; // read the active level 4 frame from the CR3 register let (level_4_table_frame, _) = Cr3::read(); let table_indexes = [ addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index() ]; let mut frame = level_4_table_frame; // traverse the multi-level page table for &amp;index in &amp;table_indexes { // convert the frame into a page table reference let virt = frame.start_address().as_u64() + physical_memory_offset; let table_ptr: *const PageTable = VirtAddr::new(virt).as_ptr(); let table = unsafe {&amp;*table_ptr}; // read the page table entry and update `frame` let entry = &amp;table[index]; frame = match entry.frame() { Ok(frame) =&gt; frame, Err(FrameError::FrameNotPresent) =&gt; return None, Err(FrameError::HugeFrame) =&gt; panic!("huge pages not supported"), }; } // calculate the physical address by adding the page offset Some(frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们没有</font><font style="vertical-align: inherit;">重用函数，而是</font><font style="vertical-align: inherit;">从寄存器重新读取了第四级框架</font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为这简化了原型的实现。不用担心，我们会尽快改善解决方案。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该结构</font></font><code>VirtAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经提供了用于计算四级页面表中的索引的方法。我们将这些索引存储在一个小的数组中，因为它允许您循环访问所有表</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在循环之外，我们记得访问的最后一帧以稍后计算物理地址。</font></font><code>frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在迭代过程中指向页表的框架，并在最后一次迭代后（即，通过1级记录后）指向关联的框架。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在循环内部，我们再次应用</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将框架转换为页表链接。然后，我们读取当前页表的记录，并使用该函数</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>PageTableEntry::frame</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检索匹配的框架。如果记录未映射到框架，则返回</font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果记录显示2 MiB或1 GiB的巨大页面，那么到目前为止，我们将感到恐慌。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，让我们在某些地址检查翻译功能：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; use x86_64::VirtAddr; let addresses = [ // the identity-mapped vga buffer page 0xb8000, // some code page 0x20010a, // some stack page 0x57ac_001f_fe48, // virtual address mapped to physical address 0 boot_info.physical_memory_offset, ]; for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); let phys = unsafe { translate_addr(virt, boot_info.physical_memory_offset) }; println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行代码时，将得到以下结果：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0b/e32/db8/a0be32db8b6353452f9d40d7b1d350ad.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按预期，通过相同的映射，地址将</font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换为相同的物理地址。</font><font style="vertical-align: inherit;">代码页和堆栈页被转换为任意物理地址，这取决于加载程序如何为我们的内核创建初始映射。</font><font style="vertical-align: inherit;">映射</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应指向物理地址</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但会失败，因为转换会使用大量页面来提高效率。</font><font style="vertical-align: inherit;">引导加载程序的未来版本可能会对内核和堆栈页面应用相同的优化。</font></font><br><br><a name="4_3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用MappedPageTable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚拟地址到物理地址的转换是OS内核的典型任务，因此，包装箱</font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为其提供了抽象。</font><font style="vertical-align: inherit;">它已经支持大页面和除之外的其他几个功能，</font></font><code>translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们使用它而不是在自己的实现中添加对大页面的支持。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象的基础是两个特征，它们定义了页表的各种翻译功能：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该特征</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供了可在页面上使用的功能。</font><font style="vertical-align: inherit;">例如，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>translate_page</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将该页面转换为相同大小的框架，并</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在表中创建新的映射。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该特征</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MapperAllSizes</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味着适用</font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">于所有页面大小。</font><font style="vertical-align: inherit;">此外，它还提供了适用于不同大小的页面（包括</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>translate_addr</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或常规）的功能</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>translate</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特性仅定义接口，但不提供任何实现。</font><font style="vertical-align: inherit;">现在，板条箱</font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供了两种实现特征的类型：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MappedPageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>RecursivePageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">第一个要求页表的每一帧都显示在某个位置（例如，带有偏移量）。</font><font style="vertical-align: inherit;">如果第四级的表递归显示，则可以使用第二种类型。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已将所有物理内存映射到</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此您可以使用MappedPageTable类型。</font><font style="vertical-align: inherit;">要初始化它，请</font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在模块中</font><font style="vertical-align: inherit;">创建一个新函数</font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::structures::paging::{PhysFrame, MapperAllSizes, MappedPageTable}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::PhysAddr; <span class="hljs-comment"><span class="hljs-comment">/// Initialize a new MappedPageTable. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn init(physical_memory_offset: u64) -&gt; impl MapperAllSizes { let level_4_table = active_level_4_table(physical_memory_offset); let phys_to_virt = move |frame: PhysFrame| -&gt; *mut PageTable { let phys = frame.start_address().as_u64(); let virt = VirtAddr::new(phys + physical_memory_offset); virt.as_mut_ptr() }; MappedPageTable::new(level_4_table, phys_to_virt) } // make private unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable {…}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不能直接</font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从函数</font><font style="vertical-align: inherit;">返回</font><font style="vertical-align: inherit;">，因为它是闭包类型所共有的。我们将通过语法构造解决这个问题</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>impl Trait</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。另一个优点是，您可以随后将内核切换到</font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不更改函数的签名。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该函数</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MappedPageTable::new</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要两个参数：到第4级页表的可变链接，以及</font></font><code>phys_to_virt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将物理帧转换为页表指针</font><font style="vertical-align: inherit;">的闭包</font></font><code>*mut PageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。对于第一个参数，我们可以重用该函数</font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。对于第二个，我们创建一个</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于执行转换</font><font style="vertical-align: inherit;">的闭包</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们也将其</font></font><code>active_level_4_table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设为私有函数，因为从现在开始只能调用它</font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用方法</font></font><code>MapperAllSizes::translate_addr</code><font style="vertical-align: inherit;"></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了</font><font style="vertical-align: inherit;">我们自己的功能</font><font style="vertical-align: inherit;">，我们只需要更改以下几行</font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS // new: different imports use blog_os::memory; use x86_64::{structures::paging::MapperAllSizes, VirtAddr}; // new: initialize a mapper let mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let addresses = […]; // same as before for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); // new: use the `mapper.translate_addr` method let phys = mapper.translate_addr(virt); println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始之后，我们看到的翻译结果与以前相同，但是现在只有大的页面也可以使用：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/5ed/d9c/51d5edd9c004e1238b321dee51fdf8b3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如预期的那样，虚拟地址已</font></font><code>physical_memory_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换为物理地址</font></font><code>0x0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用type的转换功能</font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们无需实现对大页面的支持。</font><font style="vertical-align: inherit;">我们还可以访问其他页面功能，例如</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一部分中将使用的</font><font style="vertical-align: inherit;">功能</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在此阶段，我们不再需要该功能</font></font><code>memory::translate_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以根据</font><font style="vertical-align: inherit;">需要将其</font><font style="vertical-align: inherit;">删除。</font></font><br><br><a name="4_4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建一个新的映射 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们仅查看页表，但未进行任何更改。</font><font style="vertical-align: inherit;">让我们为以前未显示的页面创建一个新的映射。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trait中</font><font style="vertical-align: inherit;">的函数</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此首先我们将考虑该函数。</font><font style="vertical-align: inherit;">该文档说它需要四个参数：我们要显示的页面；</font><font style="vertical-align: inherit;">页面应映射到的框架。</font><font style="vertical-align: inherit;">用于写页表和框架分配器的标志集</font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">帧分配器是必需的，因为映射此页面可能需要创建其他表，这些表需要将未使用的帧作为备份存储。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 功能介绍 </font></font><code>create_example_mapping</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们实现的第一步是创建一个新功能</font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将该页面映射到</font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VGA文本缓冲区</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">物理帧。我们选择此框架是因为它可以轻松检查显示是否正确创建：我们只需要写到最近显示的页面，然后查看它是否出现在屏幕上。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该函数</font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如下所示：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Page, Size4KiB, Mapper, FrameAllocator}; /// Creates an example mapping for the given page to frame `0xb8000`. pub fn create_example_mapping( page: Page, mapper: &amp;mut impl Mapper&lt;Size4KiB&gt;, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { mapper.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了页面</font></font><code>page</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要关联的函数需要一个实例</font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。类型</font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现</font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法提供</font><font style="vertical-align: inherit;">的特征</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。通用参数是</font></font><code>Size4KiB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必需的，因为特征</font><font style="vertical-align: inherit;">对于</font><font style="vertical-align: inherit;">trait </font></font><code>Mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PageSize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以同时使用标准4 KiB页面和2 MiB和1 GiB的大页面。我们只想创建4个KiB页面，所以我们可以使用它</font></font><code>Mapper&lt;Size4KiB&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替require </font></font><code>MapperAllSizes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了进行比较，请设置标志</font></font><code>PRESENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为所有有效条目都是必需的，并设置标志</font></font><code>WRITABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以使显示的页面可写。挑战赛</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不安全：您可以使用无效的参数违反内存安全性，因此必须使用block </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有关所有可能的标志的列表，请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一篇文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的“页面表格式”部分</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该函数</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能会失败，因此返回</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Result</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于这只是不可靠代码的示例，因此我们仅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>expect</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在发生错误时</font><font style="vertical-align: inherit;">使用它</font><font style="vertical-align: inherit;">来恐慌。</font><font style="vertical-align: inherit;">如果成功，函数将返回一个类型</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MapperFlush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该类型</font><font style="vertical-align: inherit;">提供了一种使用方法从动态转换缓冲区（TLB）清除最近显示的页面的简便方法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>flush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">像</font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这种类型将[ </font></font><code>#[must_use]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">] </font><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">应用于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们意外忘记使用它，则发出警告</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 虚构的 </font></font><code>FrameAllocator</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要呼叫</font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您必须先创建</font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如上所述，创建新显示的复杂性取决于我们要显示的虚拟页面。</font><font style="vertical-align: inherit;">在最简单的情况下，该页面的1级表已经存在，我们只需要创建一条记录。</font><font style="vertical-align: inherit;">在最困难的情况下，页面位于尚未创建第3级的内存区域中，因此首先您必须创建第3、2和1级的页表。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从一个简单的案例开始，并假定您不需要创建新的页表。</font><font style="vertical-align: inherit;">始终返回的帧分配器足以满足此要求</font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们创建了这样的</font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示功能以进行测试：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，您需要找到一个无需创建新页面表即可显示的页面。加载程序被加载到虚拟地址空间的第一个兆字节中，因此我们知道该区域有一个有效的1级表，例如，我们可以选择该存储区中任何未使用的页面，例如address处的页面</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了测试该功能，我们首先显示page </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后显示内存的内容：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory; use x86_64::{structures::paging::Page, VirtAddr}; let mut mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let mut frame_allocator = memory::EmptyFrameAllocator; // map a previously unmapped page let page = Page::containing_address(VirtAddr::new(0x1000)); memory::create_example_mapping(page, &amp;mut mapper, &amp;mut frame_allocator); // write the string `New!` to the screen through the new mapping let page_ptr: *mut u64 = page.start_address().as_mut_ptr(); unsafe { page_ptr.offset(400).write_volatile(0x_f021_f077_f065_f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我们为中的页面创建一个映射</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，调用一个</font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有到实例</font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">的可变链接</font><font style="vertical-align: inherit;">的函数</font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这会将页面映射</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到VGA文本缓冲区框架，因此我们应该在屏幕上看到那里写的内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后将页面转换为原始指针，并将值写入offset </font></font><code>400</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们不会写到页面顶部，因为VGA缓冲区的第一行直接从屏幕上移出，如下所示</font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。输入</font></font><code>0x_f021_f077_f065_f04e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与字符串</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ New！”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相对应</font><font style="vertical-align: inherit;">的值</font><i><font style="vertical-align: inherit;">。</font></i><font style="vertical-align: inherit;">在白色背景上。正如我们在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ VGA文本模式”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一文中所了解的那样</font><font style="vertical-align: inherit;">，写入VGA缓冲区必须是易失的，因此我们使用了该方法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>write_volatile</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我们在QEMU中运行代码时，我们看到以下结果：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/248/1a0/4cf2481a07f40c681954ff4954dce866.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入页面后</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，题为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ New！”。</font></font></i>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们已经在页表中成功创建了新的映射。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该排序规则很有效，因为已经有1级的排序表</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当我们尝试映射尚不存在1级表的页面时，该函数</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">失败，因为它试图从中分配帧</font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以创建新表。</font><font style="vertical-align: inherit;">我们看到这种情况是在尝试显示页面</font></font><code>0xdeadbeaf000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font><font style="vertical-align: inherit;">显示页面时发生</font><font style="vertical-align: inherit;">的</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果启动此操作，则会出现以下错误消息，导致出现紧急情况： </font></font><br><br><pre> <code class="plaintext hljs">panicked at 'map_to failed: FrameAllocationFailed', /…/result.rs:999:5</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要显示尚无页面级别1表的页面，您需要创建正确的表</font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，您如何知道哪些帧是空闲的以及多少物理内存可用？</font></font><br><br><a name="4_5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 选框 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于新的页表，您需要创建正确的框架分配器。</font><font style="vertical-align: inherit;">让我们从通用骨架开始：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"></font><code>frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以使用任意帧迭代器初始化</font><font style="vertical-align: inherit;">该字段</font><font style="vertical-align: inherit;">。这使您可以简单地将调用委派给</font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Iterator::next</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于初始化，我们</font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引导加载程序传输</font><font style="vertical-align: inherit;">的存储卡</font><font style="vertical-align: inherit;">作为该结构的一部分</font></font><code>BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引导信息部分</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所述，存储卡由BIOS / UEFI固件提供。仅在引导过程的开始就可以请求它，因此引导加载程序已经调用了必要的功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储卡由一系列结构组成，这些结构</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含每个存储区的起始地址，长度和类型（例如，未使用，保留等）。通过创建一个从未使用的区域生成帧的迭代器，我们可以创建一个有效的迭代器</font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化</font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生在一个新函数中</font></font><code>init_frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此函数使用组合器将初始映射</font></font><code>MemoryMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换为使用的物理帧的迭代器：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我们调用</font></font><code>iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将存储卡转换为迭代器的方法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MemoryRegion</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后，我们使用该方法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>filter</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跳过保留或不可访问的区域。</font><font style="vertical-align: inherit;">加载程序会为其创建的所有映射更新存储卡，因此内核使用的帧（代码，数据或堆栈）或用于存储有关引导的信息已标记为</font></font><code>InUse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或类似。</font><font style="vertical-align: inherit;">因此，我们可以确定</font></font><code>Usable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有在</font><font style="vertical-align: inherit;">其他地方</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">框架</font><font style="vertical-align: inherit;">。</font></font><br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>map</code></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">range</a>  Rust         . <br></li><li>    :         <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>step_by</code></a> .  4096  (= 4 ) —   ,      .      ,         .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>flat_map</code></a>  <code>map</code> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，您可以改变我们的功能</font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来发送一个副本</font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是</font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这次地址映射成功了，我们再次看到黑色和白色的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ New！”。</font></font></i>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在幕后，该方法</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建丢失的页表，如下所示：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从发送的帧中选择一个未使用的帧</font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 零帧创建一个新的空页表。 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将更高级别的表条目映射到此框架。 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 转到表的下一级。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管我们的功能</font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是示例代码，但是我们现在可以为任意页面创建新的映射。</font><font style="vertical-align: inherit;">在以后的文章中，这对于分配内存和实现多线程很有必要。</font></font><br><br><a name="5"></a><h1> 总结 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中，我们了解了访问页表物理框架的各种方法，包括身份映射，映射完整的物理内存，临时映射和递归页表。我们选择显示完整的物理内存作为一种简单而强大的方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们无法访问页面表而无法从内核映射物理内存，因此需要引导加载程序支持。货架</font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过附加的货物功能创建必要的映射。它将必要的信息作为</font></font><code>&amp;BootInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入口点函数</font><font style="vertical-align: inherit;">的参数传递给内核</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于我们的实现，我们首先手动浏览页面表，创建翻译功能，然后使用</font></font><code>MappedPageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包装箱</font><font style="vertical-align: inherit;">类型</font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们还学习了如何在页表中创建新映射，以及如何</font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在引导加载程序传输的存储卡上</font><font style="vertical-align: inherit;">创建新映射</font><font style="vertical-align: inherit;">。</font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 接下来是什么？ </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下一篇文章中，我们将为内核创建一个堆内存区域，这将使我们能够</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配内存</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并使用不同</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的集合</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN445618/">https://habr.com/ru/post/zh-CN445618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN445596/index.html">Kubernetes提示和技巧：NGINX Ingress中的个性化错误页面</a></li>
<li><a href="../zh-CN445600/index.html">[民意测验]主持人，他们错了吗</a></li>
<li><a href="../zh-CN445602/index.html">PHP Russia 2019：第一个联赛语言的“舞台”</a></li>
<li><a href="../zh-CN445608/index.html">游戏结束：分析人士报告，游戏领域的DDoS攻击数量有所增加</a></li>
<li><a href="../zh-CN445612/index.html">基于drbd + ocfs2的小型Web集群的集群存储</a></li>
<li><a href="../zh-CN445620/index.html">UX编写器做什么？</a></li>
<li><a href="../zh-CN445622/index.html">Java 12的新功能：Teeing收集器</a></li>
<li><a href="../zh-CN445626/index.html">兔子洞有多深？ CLRium＃5：垃圾收集器</a></li>
<li><a href="../zh-CN445632/index.html">从Python剧院海报的解析器到Telegram机器人。 第二部分</a></li>
<li><a href="../zh-CN445638/index.html">车库现代艺术博物馆的盲人实习</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>