<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏾 🌴 🥑 Kubernetes: Solusi Proyek Pribadi yang Luar Biasa Terjangkau 👩‍🏭 🈳 ✌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo rekan! 

 Pada bulan Januari, kami akhirnya memiliki buku yang sudah lama ditunggu-tunggu tentang Kubernetes. Pidato tentang “Mastering Kubernete...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes: Solusi Proyek Pribadi yang Luar Biasa Terjangkau</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/433192/">  Halo rekan! <br><br>  Pada bulan Januari, kami akhirnya memiliki buku yang sudah lama ditunggu-tunggu tentang Kubernetes.  Pidato tentang “Mastering Kubernetes 2nd edition” oleh Gigi Saifan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mp/6r/pc/mp6rpcu9hby7scugehhegmzmtrs.jpeg"></div><br>  Kami tidak berani menerbitkan buku di Kubernetes sekitar setahun yang lalu, karena pada saat itu teknologinya tampak seperti kapal penempur bagi perusahaan-perusahaan besar.  Namun, situasinya berubah, untuk mendukung yang kami sarankan membaca artikel besar oleh Caleb Doxsey, yang, omong-omong, menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku</a> tentang bahasa Go.  Argumen Mr. Doxy sangat menarik, dan kami berharap setelah membacanya Anda benar-benar ingin mencoba Kubernetes dalam praktik. <br><a name="habracut"></a><br>  Saya menghabiskan beberapa bulan di awal tahun ini untuk studi mendalam tentang Kubernetes: Saya membutuhkannya untuk satu proyek kerja.  Kubernetes adalah teknologi komprehensif untuk manajemen infrastruktur, ia "mencakup segalanya, bahkan baterai."  Kubernetes memecahkan sejumlah masalah yang akan Anda hadapi ketika berkembang untuk perusahaan besar.  Namun, keyakinan bahwa Kubernetes adalah teknologi yang terlalu canggih yang hanya relevan untuk mengelola sekelompok besar mesin direplikasi.  Diduga, beban operasional ketika bekerja dengan Kubernetes begitu besar sehingga penggunaannya untuk infrastruktur kecil, di mana mesin tidak masuk ke lusinan, adalah meriam yang menembaki burung gereja. <br>  Saya membiarkan diri saya tidak setuju dengan ini.  Kubernetes juga bagus untuk proyek-proyek kecil, dan hari ini Anda sudah dapat membeli cluster Kubernetes Anda sendiri dengan harga kurang dari <b>$ 5</b> per bulan. <br><br>  <b>Sepatah kata untuk membela Kubernetes</b> <br><br>  Di bawah ini saya akan menunjukkan kepada Anda cara mengatur cluster Kubernet Anda sendiri, tetapi pertama-tama coba jelaskan mengapa Kubernet harus digunakan dalam proyek-proyek kecil: <br><br>  <i>Kubernetes menyeluruh</i> <br><br>  Ya, pada pandangan pertama, Kubernetes sepertinya solusi yang agak berlebihan.  Tampaknya lebih mudah untuk mendapatkan dan mendapatkan mesin virtual dan tidak mengkonfigurasi aplikasi Anda sendiri sebagai layanan, mengapa tidak?  Memilih jalur ini, Anda harus memutuskan beberapa solusi, khususnya: <br><br><ol><li>  Bagaimana cara menyebarkan aplikasi?  Hanya rsync ke server? </li><li>  Bagaimana dengan dependensi?  Jika Anda bekerja dengan Python atau Ruby, Anda harus menginstalnya di server.  Apakah Anda akan menjalankan perintah secara manual? </li><li>  Bagaimana Anda akan meluncurkan aplikasi?  Cukup jalankan biner di latar belakang dan kemudian nohup itu?  Ini mungkin tidak terlalu baik, jadi jika Anda mengatur aplikasi sebagai layanan, Anda harus belajar systemd? </li><li>  Bagaimana Anda akan menangani operasi banyak aplikasi ketika mereka semua memiliki nama domain atau jalur http yang berbeda?  (Anda mungkin perlu mengkonfigurasi haproxy atau nginx untuk ini) </li><li>  Misalkan Anda telah memperbarui aplikasi Anda.  Lalu bagaimana Anda akan meluncurkan perubahan?  Hentikan layanan, gunakan kode, restart layanan?  Bagaimana cara menghindari downtime? </li><li>  Bagaimana jika Anda mengunci penyebaran?  Ada peluang untuk mundur?  (Direktori symlink ...? Skrip sederhana ini tampaknya tidak lagi sederhana) </li><li>  Apakah aplikasi Anda menggunakan layanan lain, misalnya, redis?  Bagaimana cara mengkonfigurasi semua layanan ini? </li></ol><br>  Kubernetes memecahkan semua masalah ini.  Secara alami, mereka semua diselesaikan dengan cara lain, di antaranya ada opsi yang lebih baik untuk Kubernet;  Namun, betapa jauh lebih baik untuk tidak memikirkan semua ini sama sekali dan fokus pada pengembangan aplikasi. <br><br>  <i>Kubernetes bisa diandalkan</i> <br><br>  Satu server akan selalu macet.  Ya, ini jarang, mungkin setahun sekali, tetapi setelah kejadian seperti itu sakit kepala yang sebenarnya dimulai: bagaimana mengembalikan semuanya ke kondisi kerja.  Ini terutama benar jika Anda mengkonfigurasi sendiri seluruh konfigurasi secara manual.  Ingat semua tim yang berlari terakhir kali?  Apakah Anda ingat apa yang berhasil di server?  Saya ingat satu kutipan dari bashorg: <br><blockquote>  erno: Hmm.  Kehilangan komputer ... serius, _lost_.  Dia menjawab, bekerja dengan baik, saya tidak akan tahu ke mana dia pergi di apartemen. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bash.org/?5273</a> </blockquote>  Hal yang persis sama terjadi pada saya baru-baru ini di blog saya sendiri.  Saya hanya perlu memperbarui tautannya, tetapi saya benar-benar lupa bagaimana cara menyebarkan blog.  Tiba-tiba, perbaikan sepuluh menit berubah menjadi pekerjaan sepanjang akhir pekan. <br><br>  Kubernetes menggunakan format <b>deskriptif</b> , jadi Anda selalu tahu hal-hal apa, kapan dan di mana seharusnya dijalankan;  Selain itu, semua komponen sistem yang Anda gunakan jauh lebih jelas terlihat.  Selain itu, di bidang kontrol, kegagalan simpul ditangani dengan hati-hati, dan perapian secara otomatis didistribusikan.  Saat bekerja dengan layanan yang tidak mempertahankan status, misalnya, dengan aplikasi web, Anda mungkin bisa melupakan kegagalan sama sekali. <br><br>  <i>Mempelajari Kubernetes tidak lebih sulit daripada alternatif</i> <br><br>  Kubernetes tidak mengikuti model Unix.  Itu tidak cocok dengan ekosistem alat.  Dia bukan salah satu dari keputusan itu yang "melakukan hanya satu hal dan melakukannya dengan baik."  Kubernetes adalah solusi komprehensif untuk banyak masalah, dapat menggantikan berbagai trik dan alat yang sudah biasa digunakan pengembang. <br><br>  Kubernetes memiliki terminologi sendiri, alatnya sendiri, paradigma penanganan servernya sendiri, yang berbeda secara signifikan dari pendekatan unix tradisional.  Ketika Anda menavigasi sistem ini, banyak fitur Kubernetes mungkin tampak acak dan rumit, bahkan mungkin kejam.  Saya kira ada alasan bagus mengapa kompleksitas ini muncul, tetapi di sini saya tidak mengatakan bahwa Kubernetes sederhana dan sederhana untuk dipahami;  Saya mengatakan bahwa pengetahuan Kubernetes cukup untuk membuat dan mendukung infrastruktur apa pun. <br><br>  Ini bukan untuk mengatakan bahwa administrator sistem memiliki latar belakang yang cukup di unix.  Sebagai contoh, setelah lulus dari perguruan tinggi, saya bekerja selama 5 tahun di ekosistem Windows.  Saya dapat mengatakan bahwa pekerjaan pertama saya di startup di mana saya perlu berurusan dengan linux membutuhkan transformasi yang sulit.  Saya tidak tahu perintah untuk memori; Saya tidak terbiasa menggunakan baris perintah untuk hampir semua kesempatan.  Butuh beberapa saat untuk belajar bagaimana bekerja dengan platform baru (walaupun pada saat itu saya sudah memiliki pengalaman pemrograman), tetapi saya ingat dengan jelas betapa saya sangat menderita. <br><br>  Dengan Kubernetes, Anda dapat memulai semua pekerjaan dari awal.  Di Kubernetes, Anda dapat dengan mudah menyediakan layanan bahkan tanpa koneksi SSH ke server.  Anda tidak harus belajar systemd;  tidak perlu memahami runlevel atau mengetahui perintah mana yang digunakan: <code>groupadd</code> atau <code>addgroup</code> ;  Anda tidak perlu belajar menangani <code>ps</code> atau, Tuhan melarang, vim.  Semua materi ini bermanfaat dan penting, tidak ada yang hilang di mana pun.  Saya sangat menghormati sysadmin yang dapat bekerja melalui lingkungan unix apa pun.  Tetapi bagaimana kerennya jika para pengembang dapat secara produktif memperoleh semua sumber daya seperti itu tanpa mempelajari seluk-beluk administrasi seperti itu? <br><br>  Benarkah ini: <br><br><pre> <code class="plaintext hljs">[Unit] Description=The NGINX HTTP and reverse proxy server After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=/run/nginx.pid ExecStartPre=/usr/sbin/nginx -t ExecStart=/usr/sbin/nginx ExecReload=/usr/sbin/nginx -s reload ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target</code> </pre> <br>  Jauh lebih sulit dari ini? <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: my-nginx spec: selector: matchLabels: run: my-nginx replicas: 1 template: metadata: labels: run: my-nginx spec: containers: - name: my-nginx image: nginx ports: - containerPort: 80</code> </pre> <br>  Dan ini masih merupakan kasus yang relatif baik.  Jika Anda mengelola infrastruktur 100% dari jarak jauh, Anda tidak akan dapat memberikan dukungan server manual.  Untuk melakukan ini, Anda memerlukan beberapa jenis alat: ansible, garam, koki, boneka, dll.  Secara alami, untuk menguasai Kubernet dan bekerja secara efektif dengannya, Anda perlu belajar banyak, tetapi ini tidak lebih sulit daripada berurusan dengan alternatif. <br><br>  <b>Sumber terbuka Kubernetes</b> <br><br>  Di era popularitas besar teknologi tanpa server, Kubernetes terkenal karena kemandiriannya dari pemasok tertentu.  Setidaknya ada 3 penyedia Kubernetes yang populer dan mudah dikelola (Google, Amazon, Microsoft) yang tidak akan hilang dalam waktu dekat.  Ada juga banyak perusahaan yang berhasil mengelola kelompok Kubernet mereka sendiri, dan setiap hari jumlah perusahaan tersebut berlipat ganda.  Hari ini, bekerja dengan Kubernetes sejak hari pertama adalah solusi yang jelas bagi kebanyakan startup. <br>  Kubernetes, sebagai proyek open source, didokumentasikan dengan baik, stabil dan populer, dan setiap masalah dapat diselesaikan dengan sedetail mungkin pada stackoverflow.  Tentu saja, Kubernetes memiliki bug dan tantangan teknisnya sendiri, tetapi saya jamin: ada orang-orang di dunia yang mengasah Kubernet dengan keterampilan luar biasa.  Pekerjaan mereka adalah dividen Anda;  dalam beberapa tahun ke depan, teknologi ini hanya akan ditingkatkan. <br><br>  <b>Skala Kubernetes</b> <br><br>  Salah satu tantangan yang terkait dengan mendukung infrastruktur adalah ini: teknik yang berguna ketika menggunakan sistem kecil jarang berhasil mereproduksi dalam sistem yang lebih besar.  Jelas mudah untuk mengikat SCP-file biner ke server, matikan proses dan restart jika Anda hanya memiliki satu server.  Tetapi, ketika Anda perlu mendukung beberapa server dan secara simultan memantaunya, tugas seperti itu ternyata menjadi sangat sulit.  Itu sebabnya Anda tidak dapat melakukannya tanpa alat seperti koki atau boneka ketika mengelola infrastruktur seperti itu. <br><br>  Namun, jika Anda memilih alat yang salah, lama-kelamaan alat itu akan mengarahkan Anda ke sudut.  Tiba-tiba ternyata chef-server terkemuka tidak dapat mengatasi beban 1000-server, penyebaran biru-hijau tidak sesuai dengan model Anda, dan dibutuhkan berjam-jam untuk menyelesaikan tugas capistrano.  Ketika infrastruktur mencapai ukuran tertentu, Anda akan dipaksa untuk merobohkan semua yang telah dilakukan dan memulai kembali.  Betapa hebatnya jika Anda bisa keluar dari roda tupai abadi ini dengan infrastruktur dan beralih ke teknologi yang akan berkembang sesuai dengan kebutuhan Anda? <br><br>  Kubernetes sangat mirip dengan database SQL.  SQL adalah produk bertahun-tahun pelajaran sulit tentang penyimpanan data dan permintaan yang efisien.  Mungkin, Anda tidak akan pernah membutuhkan sepersepuluh dari fitur-fitur yang disediakan dalam database SQL yang valid.  Anda bahkan mungkin dapat merancang sistem yang lebih efisien, dengan mengandalkan basis data Anda sendiri.  Tetapi dalam sebagian besar situasi, database SQL tidak hanya akan memenuhi semua kebutuhan Anda, tetapi juga akan secara dramatis memperluas kemampuan Anda untuk dengan cepat mengeluarkan solusi yang sudah jadi.  Skema dan pengindeksan SQL jauh lebih mudah digunakan daripada struktur data berbasis file asli, karena struktur data asli hampir pasti akan menjadi usang ketika produk Anda tumbuh dan berkembang seiring waktu.  Tetapi database SQL kemungkinan akan bertahan dari refactoring yang tidak terhindarkan. <br><br>  Kubernetes juga akan bertahan.  Mungkin proyek sampingan Anda tidak akan pernah tumbuh ke skala seperti itu di mana masalahnya hanya dapat diselesaikan dengan menggunakan alat Kubernetes, tetapi Kubernetes benar-benar memiliki semua alat untuk masalah apa pun, dan keterampilan yang akan Anda peroleh ketika berhadapan dengan toolkit ini dapat berubah menjadi tak ternilai dalam proyek masa depan. <br><br>  <b>Bangun kluster Kubernet Anda sendiri</b> <br><br>  Jadi, saya percaya bahwa disarankan untuk menggunakan Kubernetes dalam proyek-proyek kecil, tetapi hanya jika membuat cluster keluar sederhana dan murah.  Ternyata keduanya dapat dicapai.  Ada penyedia yang dikelola Kubernetes yang menangani sendiri seluruh kekacauan, mendukung bidang kontrol host Kubernet.  Dan perang dumping baru-baru ini di lingkungan infrastruktur cloud telah menyebabkan penurunan luar biasa dalam biaya layanan tersebut. <br>  Kami akan menganalisis kasus berikutnya menggunakan mesin Kubernetes dari Google (GKE) sebagai contoh, namun, Anda juga dapat melihat penawaran dari Amazon (EKS) atau Microsoft (AKS) jika Google tidak cocok untuk Anda.  Untuk membangun kluster Kubernet Anda sendiri, kami membutuhkan: <br><br><ul><li>  Nama domain (~ $ 10 / tahun, tergantung pada domain) </li><li>  Hosting Cloudflare DNS (gratis) </li><li>  GKE Kubernetes Tiga-Node Cluster (~ $ 5 / bulan) </li><li>  Aplikasi web diunggah sebagai wadah buruh pelabuhan ke Google Container Registry (GCR) (gratis) </li><li>  Sejumlah file yaml untuk konfigurasi Kubernetes </li></ul><br>  Untuk penghematan tambahan, kami akan mencoba melakukannya tanpa pengontrol input Google.  Sebagai gantinya, kami akan menggunakan Nginx pada setiap node sebagai daemon dan membuat operator kami sendiri yang akan menyinkronkan alamat IP eksternal dari node yang berfungsi dengan Cloudflare. <br><br>  <b>Konfigurasi Google</b> <br><br>  Pertama, buka console.cloud.google.com dan buat proyek, jika Anda belum melakukannya.  Anda juga perlu membuat akun penagihan.  Kemudian, melalui menu hamburger, buka halaman Kubernetes dan buat sebuah cluster baru.  Inilah yang perlu Anda lakukan selanjutnya: <br><br><ul><li>  Pilih Zonal untuk jenis lokasi. </li><li>  Saya menunjukkan lokasi saya sebagai kami-central1-a </li><li>  Pilih versi kubernet Anda </li><li>  Buat kumpulan 3 node menggunakan tipe instance termurah (f1-micro). </li><li>  Untuk kumpulan node ini, pada layar "lanjutan", atur ukuran disk boot menjadi 10GB, aktifkan node yang diekstrusi (lebih murah), aktifkan pembaruan otomatis dan perawatan otomatis. </li><li>  Di bawah kumpulan node, Anda akan menemukan sejumlah opsi tambahan.  Kami ingin menonaktifkan load balancing HTTP (load balancing dalam GCP mahal), dan juga menonaktifkan semua fasilitas yang terkait dengan StackDriver (itu juga bisa mahal dan, dalam pengalaman saya, tidak terlalu dapat diandalkan).  Matikan juga panel indikator kubernetes. </li></ul><br>  Setelah memasukkan semua opsi ini, Anda dapat melanjutkan ke langkah berikutnya: membuat sebuah cluster.  Berikut cara menghematnya: <br><br><ul><li>  Pesawat kontrol Kubernetes: gratis, karena Google tidak membebankan biaya pada host node </li><li>  Kubernetes node kerja: $ 5.04 / bulan, sebagai aturan, 3 micro-node akan dikenakan biaya $ 11.65 / bulan, dan setelah membuat mereka ramai, kami akan mengurangi tarif ini menjadi $ 7.67 / bulan, dan pada "Selalu Gratis" - menjadi $ 5.04. </li><li>  Biaya penyimpanan: gratis.  Kami mendapatkan ruang disk permanen 30GB gratis, jadi di atas kami memilih ukuran 10GB. </li><li>  Biaya penyeimbangan beban: gratis, kami mematikan penyeimbangan muatan HTTP, karena hanya dibutuhkan kami $ 18 / bulan.  Alih-alih, jalankan proxy HTTP kami sendiri di setiap node dan arahkan DNS ke IP publik. </li><li>  Biaya jaringan: gratis, fungsi jalan keluar tetap gratis hingga Anda memilih 1GB per bulan.  (Selanjutnya, setiap gigabyte berikutnya harganya 8 sen) </li></ul><br>  Jadi kami membuat kluster Kubernetes dengan 3 node, harganya sama dengan satu-satunya mesin Digital Ocean. <br><br>  Selain mengkonfigurasi GKE, Anda juga perlu mengonfigurasi beberapa aturan firewall sehingga Anda dapat mencapai port HTTP host kami dari dunia luar.  Temukan entri Jaringan VPC di menu hamburger, lalu buka Aturan Firewall dan tambahkan aturan untuk port TCP 80 dan 443, dengan kisaran alamat IP 0.0.0.0/0. <br><br><img src="https://habrastorage.org/webt/if/ag/gz/ifaggzw5xpzfosqf_lxon8bqsdo.jpeg"><br><br>  Aturan firewall <br><br>  <b>Pengaturan lokal</b> <br><br>  Jadi, kami mengangkat dan memulai cluster, dan sekarang mari kita konfigurasikan.  Instal alat <code>gcloud</code> mengikuti instruksi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud.google.com/sdk/docs</a> .  Setelah menginstalnya, Anda dapat melanjutkan ke konfigurasi dengan melakukan ini: <br><br><pre> <code class="plaintext hljs">gcloud auth login</code> </pre> <br>  Tentu saja, Anda masih harus menginstal buruh pelabuhan, dan kemudian mengikatnya ke GCR, sehingga Anda dapat mengirim kontainer: <br><br><pre> <code class="plaintext hljs">gcloud auth configure-docker</code> </pre> <br>  Anda juga dapat menginstal dan mengkonfigurasi <code>kubectl</code> dengan mengikuti instruksi yang diuraikan di sini. <br><br>  Sederhana: <br><br><pre> <code class="plaintext hljs">gcloud components install kubectl gcloud config set project PROJECT_ID gcloud config set compute/zone COMPUTE_ZONE gcloud container clusters get-credentials CLUSTER_NAME</code> </pre> <br>  Ngomong-ngomong, itu hanya dongeng bahwa semua toolkit ini berfungsi pada Windows, OSX atau Linux.  Sebagai orang yang terkadang melakukan hal seperti itu di Windows, saya akui ini kejutan yang menyenangkan. <br><br>  <b>Pembuatan Aplikasi Web</b> <br><br>  Aplikasi web dapat ditulis dalam bahasa pemrograman apa pun.  Wadah memungkinkan Anda untuk mengabstraksi yang khusus.  Kita harus membuat aplikasi HTTP yang mendengarkan di port.  Saya lebih suka Go untuk tujuan seperti itu, tetapi untuk perubahan kami akan mencoba kristal.  Buat file <code>main.cr</code> : <br><br><pre> <code class="plaintext hljs"># crystal-www-example/main.cr require "http/server" Signal::INT.trap do exit end server = HTTP::Server.new do |context| context.response.content_type = "text/plain" context.response.print "Hello world from crystal-www-example! The time is #{Time.now}" end server.bind_tcp("0.0.0.0", 8080) puts "Listening on http://0.0.0.0:8080" server.listen</code> </pre> <br>  Kami juga membutuhkan Dockerfile: <br><br><pre> <code class="plaintext hljs"># crystal-www-example/Dockerfile FROM crystallang/crystal:0.26.1 as builder COPY main.cr main.cr RUN crystal build -o /bin/crystal-www-example main.cr --release ENTRYPOINT [ "/bin/crystal-www-example" ]</code> </pre> <br>  Untuk membangun dan menguji aplikasi kami, jalankan: <br><br><pre> <code class="plaintext hljs">docker build -t gcr.io/PROJECT_ID/crystal-www-example:latest . docker run -p 8080:8080 gcr.io/PROJECT_ID/crystal-www-example:latest</code> </pre> <br>  Dan kemudian pergi ke browser di localhost: 8080.  Setelah menetapkan mekanisme ini, kami dapat mengirim aplikasi ke GCR dengan menjalankan: <br><br><pre> <code class="plaintext hljs">docker push gcr.io/PROJECT_ID/crystal-www-example:latest</code> </pre> <br>  <b>Konfigurasikan Kubernet</b> <br><br>  Konfigurasi Kubernet saya ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Untuk contoh ini, kita harus membuat beberapa file yaml di mana berbagai layanan kita akan disajikan, dan kemudian jalankan kubectl untuk mengkonfigurasi mereka di cluster.  Konfigurasi Kubernetes bersifat deskriptif, dan semua file yaml ini memberi tahu Kubernetes status apa yang ingin kita dapatkan.  Dalam arti luas, inilah yang akan kita lakukan: <br><br><ul><li>  Buat Penyebaran dan Layanan untuk aplikasi web crystal-www-example kami </li><li>  Buat Set Daemon (set layanan) dan Peta Konfigurasi (peta konfigurasi) untuk nginx </li><li>  Kami meluncurkan aplikasi kami sendiri untuk menyinkronkan node IP dengan Cloudflare untuk DNS </li></ul><br>  <b>Konfigurasi aplikasi web</b> <br><br>  Pertama, mari konfigurasikan aplikasi web kami: (pastikan untuk mengganti <code>PROJECT_ID</code> dengan id proyek Anda) <br><br><pre> <code class="plaintext hljs"># kubernetes-config/crystal-www-example.yaml apiVersion: apps/v1 kind: Deployment metadata: name: crystal-www-example labels: app: crystal-www-example spec: replicas: 1 selector: matchLabels: app: crystal-www-example template: metadata: labels: app: crystal-www-example spec: containers: - name: crystal-www-example image: gcr.io/PROJECT_ID/crystal-www-example:latest ports: - containerPort: 8080 --- kind: Service apiVersion: v1 metadata: name: crystal-www-example spec: selector: app: crystal-www-example ports: - protocol: TCP port: 8080 targetPort: 8080</code> </pre> <br>  Ini menciptakan Penempatan (konfigurasi diperluas), yang menurutnya Kubernetes harus membuat satu wadah (buruh pelabuhan kami akan bekerja di sana) dan layanan yang akan kami gunakan untuk menemukan layanan di cluster kami.  Untuk menerapkan konfigurasi ini, jalankan (dari direktori <code>kubernetes-config</code> ): <br><br><pre> <code class="plaintext hljs">kubectl apply -f</code> </pre> <br>  Anda dapat mengujinya seperti ini: <br><br><pre> <code class="plaintext hljs">kubectl get pod #     : # crystal-www-example-698bbb44c5-l9hj9 1/1 Running 0 5m</code> </pre> <br><br>  Kami juga dapat membuat API proxy untuk akses: <br><br><pre> <code class="plaintext hljs">kubectl proxy</code> </pre> <br>  Dan kemudian pergi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">localhost</a> : 8001 / api / v1 / namespaces / default / services / crystal-www-example / proxy / <br><br>  <b>Konfigurasi NGINX</b> <br><br>  Biasanya, ketika bekerja dengan layanan HTTP, Kubernetes menggunakan pengontrol input.  Sayangnya, penyeimbang beban HTTP Google terlalu mahal, jadi kami tidak akan menggunakannya, tetapi gunakan proxy HTTP kami sendiri dan konfigurasikan secara manual (kedengarannya menakutkan, tetapi kenyataannya sangat sederhana). <br><br>  Untuk melakukan ini, gunakan Daemon Set dan Config Map.  Daemon Set adalah aplikasi yang berjalan di setiap node.  Config Map pada prinsipnya adalah file kecil yang bisa kita pasang dalam sebuah wadah;  file ini akan menyimpan konfigurasi nginx. <br>  File yaml terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: DaemonSet metadata: name: nginx labels: app: nginx spec: selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: hostNetwork: true dnsPolicy: ClusterFirstWithHostNet containers: - image: nginx:1.15.3-alpine name: nginx ports: - name: http containerPort: 80 hostPort: 80 volumeMounts: - name: "config" mountPath: "/etc/nginx" volumes: - name: config configMap: name: nginx-conf --- apiVersion: v1 kind: ConfigMap metadata: name: nginx-conf data: nginx.conf: | worker_processes 1; error_log /dev/stdout info; events { worker_connections 10; } http { access_log /dev/stdout; server { listen 80; location / { proxy_pass http://crystal-www-example.default.svc.cluster.local:8080; } } }</code> </pre> <br>  Ini adalah bagaimana kami memasang file nginx.conf dari kartu konfigurasi di wadah nginx.  Kami juga menetapkan nilai untuk dua bidang lagi: <code>hostNetwork: true</code> , sehingga Anda dapat mengikat port host dan <code>dnsPolicy: ClusterFirstWithHostNet</code> nginx dari luar dan <code>dnsPolicy: ClusterFirstWithHostNet</code> sehingga Anda dapat mengakses layanan di dalam cluster.  Jika ini tidak dilakukan, maka kita akan mendapatkan konfigurasi yang sepenuhnya standar. <br><br>  Terapkan ekspresi ini dan Anda dapat mengakses nginx melalui ip publik dari node Anda. <br><br>  Inilah cara Anda dapat memverifikasi ini: <br><br><pre> <code class="plaintext hljs">kubectl get node -o yaml # look for: # - address: ... # type: ExternalIP</code> </pre><br>  Jadi sekarang aplikasi web kami dapat diakses dari Internet.  Masih muncul dengan nama yang indah untuk aplikasi. <br><br>  <b>Koneksi DNS</b> <br><br>  Diperlukan untuk menetapkan 3 A catatan DNS untuk node cluster kami: <br><br><img src="https://habrastorage.org/webt/1l/0t/xx/1l0txxf6dye-lyuxpbndghsw_ta.png"><br><br>  Entri dalam UI Cloudflare <br><br>  Kemudian tambahkan catatan CNAME untuk menunjuk ke catatan A ini.  (mis. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.example.com</a> CNAME untuk kubernetes.example.com).  Ini dapat dilakukan secara manual, tetapi lebih baik - secara otomatis, sehingga jika kita perlu skala atau mengganti node dalam catatan DNS, informasi ini juga diperbarui secara otomatis. <br><br>  Saya pikir contoh ini juga menggambarkan dengan baik bagaimana Anda dapat mendelegasikan sebagian pekerjaan Anda ke Kubernetes, dan tidak mencoba untuk mengatasinya.  Kubernetes memahami skrip dan memiliki API yang kuat, dan Anda dapat mengisi ruang yang ada dengan komponen Anda sendiri, yang tidak begitu sulit untuk ditulis.  Untuk melakukan ini, saya membuat aplikasi kecil di Go, tersedia di alamat ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubernetes-cloudflare-sync</a> . <br><br>  Untuk memulai, saya membuat informan: <br><br><pre> <code class="go hljs">factory := informers.NewSharedInformerFactory(client, time.Minute) lister := factory.Core().V1().Nodes().Lister() informer := factory.Core().V1().Nodes().Informer() informer.AddEventHandler(cache.ResourceEventHandlerFuncs{ AddFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, UpdateFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oldObj, newObj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, DeleteFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, }) informer.Run(stop)</code> </pre> <br>  Ini akan memanggil fungsi sinkronisasi ulang saya setiap kali ada perubahan.  Lalu saya menyinkronkan API menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cloudflare API</a> , sesuatu seperti ini: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ips []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, node := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> nodes { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, addr := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> node.Status.Addresses { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr.Type == core_v1.NodeExternalIP { ips = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(ips, addr.Address) } } } sort.Strings(ips) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, ip := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ips { api.CreateDNSRecord(zoneID, cloudflare.DNSRecord{ Type: <span class="hljs-string"><span class="hljs-string">"A"</span></span>, Name: options.DNSName, Content: ip, TTL: <span class="hljs-number"><span class="hljs-number">120</span></span>, Proxied: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }) }</code> </pre> <br>  Kemudian, seperti halnya aplikasi web kami, kami meluncurkan aplikasi ini di Kubernetes sebagai Penyebaran: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: kubernetes-cloudflare-sync labels: app: kubernetes-cloudflare-sync spec: replicas: 1 selector: matchLabels: app: kubernetes-cloudflare-sync template: metadata: labels: app: kubernetes-cloudflare-sync spec: serviceAccountName: kubernetes-cloudflare-sync containers: - name: kubernetes-cloudflare-sync image: gcr.io/PROJECT_ID/kubernetes-cloudflare-sync args: - --dns-name=kubernetes.example.com env: - name: CF_API_KEY valueFrom: secretKeyRef: name: cloudflare key: api-key - name: CF_API_EMAIL valueFrom: secretKeyRef: name: cloudflare key: email</code> </pre> <br>  Kami perlu membuat rahasia Kubernetes dengan menentukan kunci <code>cloudflare api</code> dan alamat surat: <br><br><pre> <code class="plaintext hljs">kubectl create secret generic cloudflare --from-literal=email='EMAIL' --from-literal=api-key='API_KEY'</code> </pre> <br>  Kami juga perlu membuat akun layanan (memberikan akses Penempatan kami ke API Kubernetes untuk mengambil node).  Jalankan pertama (terutama untuk GKE): <br><br><pre> <code class="plaintext hljs">kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin --user YOUR_EMAIL_ADDRESS_HERE</code> </pre> <br><br>  Dan kemudian berlaku: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: ServiceAccount metadata: name: kubernetes-cloudflare-sync --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: kubernetes-cloudflare-sync rules: - apiGroups: [""] resources: ["nodes"] verbs: ["list", "watch"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: kubernetes-cloudflare-sync-viewer roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: kubernetes-cloudflare-sync subjects: - kind: ServiceAccount name: kubernetes-cloudflare-sync namespace: default</code> </pre> <br>  Bekerja dengan RBAC agak membosankan, tapi saya harap semuanya jelas di sini.  Ketika konfigurasi sudah siap, dan aplikasi kami bekerja dengan Cloudflare, aplikasi ini dapat diperbarui dengan perubahan apa pun di node. <br><br>  <b>Kesimpulan</b> <br><br>  Kubernetes ditakdirkan untuk menjadi teknologi unggulan untuk mengelola sistem besar. ,   Kubernetes     ,    Kubernetes    ,    Kubernetes   ,      Kubernetes   . <br><br>    ,  Kubernetes       :      ,  .       –   ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433192/">https://habr.com/ru/post/id433192/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433180/index.html">Memecahkan masalah tipe data di Ruby atau Membuat data kembali dapat diandalkan</a></li>
<li><a href="../id433182/index.html">Apakah mungkin untuk melatih agen untuk perdagangan di pasar saham dengan bala bantuan? Implementasi bahasa R</a></li>
<li><a href="../id433184/index.html">ASP.NET Core 2.2 dirilis. Apa yang baru? (2 dari 3)</a></li>
<li><a href="../id433186/index.html">Tidak cukup hanya dengan menghitung poligon untuk mengoptimalkan model 3D</a></li>
<li><a href="../id433188/index.html">Negara Duma memperkenalkan RUU tentang pekerjaan otonom Runet</a></li>
<li><a href="../id433194/index.html">Lampu malam yang dijadwalkan</a></li>
<li><a href="../id433196/index.html">Panduan Hadiah Tahun Baru</a></li>
<li><a href="../id433198/index.html">10 dolar untuk hosting: 20 tahun yang lalu dan hari ini</a></li>
<li><a href="../id433202/index.html">Memilih arsitektur solusi untuk pasar jasa pengiriman</a></li>
<li><a href="../id433204/index.html">Bagaimana cara mempelajari pengembangan Java? Pengalaman siswa GeekUniversity Nikita Chernetsov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>