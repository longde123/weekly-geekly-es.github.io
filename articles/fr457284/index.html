<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèø üë®üèª üïë WBOIT en OpenGL: transparence sans tri üçö üõåüèæ üßóüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous parlerons de ¬´Transparence pond√©r√©e ind√©pendante de l'ordre m√©lang√©¬ª (ci-apr√®s WBOIT) - la technique d√©crite dans JCGT en 2013 ( lien ). 

 Lorsq...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WBOIT en OpenGL: transparence sans tri</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457284/">  Nous parlerons de ¬´Transparence pond√©r√©e ind√©pendante de l'ordre m√©lang√©¬ª (ci-apr√®s WBOIT) - la technique d√©crite dans JCGT en 2013 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> ). <br><a name="habracut"></a><br>  Lorsque plusieurs objets transparents apparaissent √† l'√©cran, la couleur du pixel d√©pend de celui qui est le plus proche de l'observateur.  Voici une formule de m√©lange de couleurs bien connue pour ce cas: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{near}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{far}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(1)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation"><span class="noError" style="display: inline-block;" aria-hidden="true">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ begin {matrix} C = C_ {near} \ alpha + C_ {far} (1- \ alpha) && (1) \ end {matrix} </script></p><br>  L'ordre de la disposition des fragments est important pour lui: la couleur du fragment proche et son opacit√© sont not√©es C <sub>pr√®s</sub> et <i>Œ±</i> , et la couleur r√©sultante de tous les fragments qui se trouvent derri√®re lui est not√©e C <sub>loin</sub> .  L'opacit√© est une propri√©t√© qui prend des valeurs de 0 √† 1, o√π 0 signifie que l'objet est si transparent qu'il n'est pas visible et 1 - qu'il est si opaque que rien n'est visible <i>derri√®re lui</i> . <br><br>  Pour utiliser cette formule, vous devez d'abord trier les fragments par profondeur.  Imaginez combien de maux de t√™te cela implique!  En g√©n√©ral, le tri doit √™tre effectu√© dans chaque trame.  Si vous triez des objets, certains objets de forme complexe devront √™tre coup√©s en morceaux et tri√©s en fonction de la profondeur des pi√®ces coup√©es (en particulier, pour les surfaces qui se croisent, cela devra certainement √™tre fait).  Si vous triez les fragments, le tri se fera dans les shaders.  Cette approche est appel√©e ¬´Transparence ind√©pendante de l'ordre¬ª (OIT), et elle utilise une liste li√©e stock√©e dans la m√©moire de la carte vid√©o.  Il est presque irr√©aliste de pr√©voir la quantit√© de m√©moire √† allouer √† cette liste.  Et s'il n'y a pas assez de m√©moire, des artefacts appara√Ætront √† l'√©cran. <br><br>  Heureusement pour ceux qui peuvent contr√¥ler combien d'objets translucides sont plac√©s sur la sc√®ne et o√π ils sont les uns par rapport aux autres.  Mais si vous faites de la CAO, vous aurez autant d'objets transparents que l'utilisateur le souhaite et ils seront localis√©s de mani√®re al√©atoire. <br><br>  Vous comprenez maintenant le d√©sir de certaines personnes de simplifier leur vie et de trouver une formule pour m√©langer les couleurs qui ne n√©cessite pas de tri.  Une telle formule se trouve dans l'article auquel j'ai fait r√©f√©rence au d√©but.  Il y a m√™me plusieurs formules l√†-bas, mais la meilleure selon les auteurs (et √† mon avis aussi) est celle-ci: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i))&amp;#xA0;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(2)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation"><span class="noError" style="display: inline-block;" aria-hidden="true">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}} (1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i)) + C_0 \ prod_ {i = 1} ^ {n} (1- \ alpha_i) && (2) \ end {matrix} </script></p><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br>  Dans la capture d'√©cran, il y a des groupes de triangles translucides situ√©s en quatre couches de profondeur.  √Ä gauche, ils sont rendus en utilisant la technique WBOIT.  √Ä droite, une image obtenue √† l'aide de la formule (1), m√©lange classique de couleurs, en tenant compte de l'ordre de la disposition des fragments.  Ensuite, je l'appellerai CODB (m√©lange classique d√©pendant de l'ordre). <br><br>  Avant de commencer le rendu des objets transparents, nous devons rendre tous les objets opaques.  Apr√®s cela, les objets transparents sont rendus avec un test de profondeur, mais sans √©crire dans le tampon de profondeur (cela se fait comme ceci: <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ).  C'est-√†-dire, c'est ce qui se passe √† un point avec certaines coordonn√©es d'√©cran (x, y): les fragments transparents qui sont plus proches que l'opaque passent le test de profondeur, quelle que soit leur position en profondeur par rapport aux fragments transparents d√©j√† dessin√©s, et les fragments transparents qui apparaissent plus loin opaques, ne r√©ussissent pas le test de profondeur et, par cons√©quent, sont jet√©s. <br><br>  C <sub>0</sub> dans la formule (2) est la couleur d'un fragment opaque, au-dessus duquel sont dessin√©s des fragments transparents, dont nous avons n morceaux, indiqu√©s par les indices 1 √† n.  C <sub>i</sub> est la couleur du i-√®me fragment transparent, <i>Œ± <sub>i</sub></i> est son opacit√©. <br><br>  Si vous regardez attentivement, la formule (2) est un peu comme la formule (1).  Si vous imaginez que <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  Est C <sub>pr√®s</sub> , C <sub>0</sub> est C <sub>loin</sub> et <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100">  - c'est <i>Œ±</i> , alors ce sera la 1√®re formule, une √† une.  Et vraiment <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  - c'est la moyenne pond√©r√©e des couleurs des fragments transparents (le centre de masse est d√©termin√© en m√©canique par la m√™me formule), ce sera la couleur du fragment C le plus proche <sub>pr√®s</sub> .  C <sub>0</sub> est la couleur du fragment opaque situ√© derri√®re tous les fragments, pour lequel nous avons calcul√© cette moyenne pond√©r√©e, et elle passera pour C <sub>loin</sub> .  Autrement dit, nous avons remplac√© tous les fragments transparents par un fragment ¬´moyenn√©¬ª et appliqu√© la formule standard pour m√©langer les couleurs - formule (1).  Quelle est cette formule astucieuse pour <i>Œ±</i> que les auteurs de l'article original nous proposent? <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.233ex" height="2.901ex" viewBox="0 -832 14738.9 1249" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMAIN-31" x="1124" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMAIN-28" x="9204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMAIN-31" x="9594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMAIN-2212" x="10316" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-61" x="11567" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-6C" x="12097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-70" x="12395" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-68" x="12899" y="0"></use><g transform="translate(13475,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhj1PkSPjT6lnhY127KJq2xc15Qe5w#MJMAIN-29" x="14349" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i) </script></p><br>  Il s'agit d'une fonction scalaire dans un espace √† n dimensions. Rappelons donc l'analyse diff√©rentielle des fonctions de plusieurs variables.  √âtant donn√© que tous les <i>Œ± <sub>i</sub></i> appartiennent √† la plage de 0 √† 1, la d√©riv√©e partielle par rapport √† l'une des variables sera toujours une constante non n√©gative.  Cela signifie que l'opacit√© du fragment ¬´moyen¬ª augmente avec l'augmentation de l'opacit√© de n'importe lequel des fragments transparents, et c'est exactement ce dont nous avons besoin.  De plus, il augmente lin√©airement. <br><br>  Si l'opacit√© d'un fragment est de 0, alors elle n'est pas visible du tout, elle n'affecte pas la couleur r√©sultante. <br><br>  Si l'opacit√© d'au moins un fragment est 1, alors <i>Œ±</i> est 1. Autrement dit, le fragment opaque devient invisible, ce qui est g√©n√©ralement bon.  Seuls les fragments transparents situ√©s derri√®re le fragment avec opacit√© = 1 brillent encore √† travers lui et affectent la couleur r√©sultante: <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br>  Ici, un triangle orange se trouve au-dessus, vert en dessous, et gris et cyan sous vert, et tout cela sur un fond noir.  Opacit√© bleue = 1, tous les autres - 0,5.  L'image de droite est ce qu'elle devrait √™tre.  Comme vous pouvez le voir, WBOIT a l'air d√©go√ªtant.  Le seul endroit o√π la couleur orange normale appara√Æt est le bord du triangle vert, entour√© d'une ligne blanche opaque.  Comme je viens de le dire, un fragment opaque est invisible si l'opacit√© du fragment transparent est 1. <br><br>  C'est encore mieux vu ici: <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br>  Le triangle orange a une opacit√© de 1, le vert avec la transparence d√©sactiv√©e est simplement dessin√© avec les objets opaques.  Il semble que le triangle VERT brille √† travers ORANGE √† travers le triangle orange. <br><br>  Pour que l'image soit d√©cente, le plus simple est de ne pas attribuer une opacit√© √©lev√©e aux objets.  Dans mon projet de travail, je n'autorise pas la d√©finition d'opacit√© sup√©rieure √† 0,5.  Il s'agit de CAO 3D, dans lequel les objets sont dessin√©s sch√©matiquement, et un r√©alisme sp√©cial n'est pas n√©cessaire, une telle restriction est donc autoris√©e ici. <br><br>  Avec des valeurs d'opacit√© faibles, les images de gauche et de droite se ressemblent presque: <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br>  Et avec haut, ils diff√®rent sensiblement: <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br>  Voici √† quoi ressemble un poly√®dre transparent: <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br>  Le poly√®dre a des faces horizontales orange lat√©rales et vertes.  Malheureusement, vous ne comprendrez pas cela √† premi√®re vue, c'est-√†-dire  l'image ne semble pas convaincante.  L√† o√π il y a un mur orange devant, vous avez besoin de plus que l'orange, et o√π le vert est plus que vert.  Il sera beaucoup mieux de dessiner des visages dans une seule couleur: <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3>  WBOIT bas√© sur la profondeur </h3><br>  Afin de compenser en quelque sorte le manque de tri par profondeur, les auteurs de l'article ont propos√© plusieurs options pour ajouter de la profondeur √† la formule (2).  Cela rend la mise en ≈ìuvre plus difficile et le r√©sultat moins pr√©visible et d√©pend des caract√©ristiques d'une sc√®ne tridimensionnelle particuli√®re.  Je ne me suis pas plong√© dans ce sujet, alors peu importe - je propose de lire l'article. <br><br>  On fait valoir que WBOIT est parfois capable de quelque chose que la transparence du tri classique ne peut pas.  Par exemple, vous dessinez la fum√©e comme un syst√®me de particules utilisant seulement deux particules - avec de la fum√©e fonc√©e et claire.  Lorsqu'une particule passe √† travers une autre, le m√©lange de couleurs classique avec le tri donne un r√©sultat moche - la couleur de la fum√©e de la lumi√®re devient fortement sombre.  L'article dit que le WBOIT sensible √† la profondeur permet une transition en douceur et semble plus cr√©dible.  On peut en dire autant de la mod√©lisation de la fourrure et des cheveux sous forme de tubes fins. <br><br><h3>  Code </h3><br>  Maintenant, comment impl√©menter la formule (2) sur OpenGL.  L'exemple de code se trouve sur Github ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> ), et la plupart des images de l'article sont de l√†.  Vous pouvez collecter et jouer avec mes triangles.  Le framework Qt est utilis√©. <br><br>  Pour ceux qui commencent tout juste √† √©tudier le rendu des objets transparents, je recommande ces deux articles: <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprenez OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le√ßon 4.3 - M√©langer les couleurs</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Algorithme de transparence ind√©pendant de l'ordre utilisant des listes li√©es sur Direct3D 11 et OpenGL 4</a> <br><br>  Le second, cependant, n'est pas si important pour comprendre ce mat√©riel, mais le premier est une lecture incontournable. <br><br>  Pour calculer la formule (2), nous avons besoin de 2 tampons d'image suppl√©mentaires, 3 textures multi-√©chantillons et un tampon de rendu, dans lequel nous allons √©crire la profondeur.  Dans la premi√®re texture - colorTextureNT (NT signifie non transparent) - nous rendrons des objets opaques.  Il a le type GL_RGB10_A2.  La deuxi√®me texture (colorTexture) sera de type GL_RGBA16F;  dans les 3 premiers composants de cette texture, nous √©crirons ce morceau de formule (2): <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70">  dans le quatri√®me - <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50">  .  Une autre texture de type GL_R16 (alphaTexture) contiendra <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  . <br><br>  Vous devez d'abord cr√©er ces objets pour obtenir leurs identifiants depuis OpenGL: <br><br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br>  Comme je l'ai dit, le framework Qt est utilis√© ici, et tous les appels OpenGL passent par un objet de type QOpenGLFunctions_4_5_Core, qui est toujours appel√© f pour moi. <br><br>  Vous devez maintenant allouer de la m√©moire: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br>  Et configurez les tampons d'image: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br>  Lors de la deuxi√®me √©tape de rendu, la sortie du fragment shader ira √† deux textures √† la fois, et cela doit √™tre explicitement sp√©cifi√© √† l'aide de glDrawBuffers. <br><br>  La plupart de ce code est ex√©cut√© une fois, au d√©marrage du programme.  Le code qui alloue de la m√©moire aux textures et aux tampons de rendu est appel√© chaque fois que la fen√™tre est redimensionn√©e.  Vient ensuite le code de rendu, qui est appel√© chaque fois que la fen√™tre est redessin√©e. <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ...   ...</span></span></code> </pre> <br>  Nous venons de dessiner tous les objets opaques sur la texture colorTextureNT et d'√©crire les profondeurs dans le tampon de rendu.  Avant d'utiliser le m√™me tampon de rendu √† l'√©tape suivante du dessin, vous devez vous assurer que toutes les profondeurs des objets opaques y sont d√©j√† √©crites.  Pour cela, GL_FRAMEBUFFER_BARRIER_BIT est utilis√©.  Apr√®s avoir rendu les objets transparents, nous appelons la fonction ApplyTextures (), qui lancera la derni√®re √©tape du rendu, dans laquelle le fragment shader lira les donn√©es des textures colorTextureNT, colorTexture et alphaTexture pour appliquer la formule (2).  Les textures auraient d√ª √™tre enti√®rement √©crites d'ici l√†, donc avant d'appeler ApplyTextures (), nous utilisons GL_TEXTURE_FETCH_BARRIER_BIT. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ...   ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO est le framebuffer √† travers lequel nous affichons l'image.  Dans la plupart des cas, c'est 0, mais dans Qt c'est QOpenGLWidget :: defaultFramebufferObject (). <br><br>  Chaque fois que le fragment shader est appel√©, nous aurons des informations sur la couleur et l'opacit√© du fragment actuel.  Mais √† la sortie dans la texture colorTexture nous voulons obtenir la somme (et dans la texture alphaTexture le produit) de certaines fonctions de ces quantit√©s.  Le m√©lange est utilis√© pour cela.  De plus, puisque pour la premi√®re texture nous calculons la somme, et pour la seconde - le produit, les param√®tres de fusion (glBlendFunc et glBlendEquation) pour chaque pi√®ce jointe doivent √™tre d√©finis s√©par√©ment. <br><br>  Voici le contenu de la fonction PrepareToTransparentRendering (): <br><br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br>  Et le contenu de la fonction CleanupAfterTransparentRendering (): <br><br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br>  Dans mon fragment shader, l'opacit√© est indiqu√©e par la lettre w.  Le produit de la couleur par w et w lui-m√™me est √©mis vers un param√®tre de sortie et 1 - w vers un autre.  Pour chaque param√®tre de sortie, un qualificatif de disposition est d√©fini sous la forme ¬´location = X¬ª, o√π X est l'index de l'√©l√©ment dans le tableau de pi√®ces jointes, que nous avons transmis √† glDrawBuffers dans la 3e liste (en particulier, le param√®tre de sortie avec location = 0 est envoy√© √† la texture li√©e √† GL_COLOR_ATTACHMENT0 et le param√®tre avec location = 1 - dans la texture attach√©e √† GL_COLOR_ATTACHMENT1).  Les m√™mes nombres sont utilis√©s dans les fonctions glBlendFunci et glBlendEquationi pour indiquer le num√©ro de pi√®ce jointe pour lequel nous avons d√©fini les param√®tres de fusion. <br><br>  Fragment Shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br>  Dans la fonction ApplyTextures (), nous dessinons simplement un rectangle sur toute la fen√™tre.  Le fragment shader demande des donn√©es de toutes les textures que nous avons cr√©√©es, en utilisant les coordonn√©es d'√©cran actuelles comme coordonn√©es de texture et le num√©ro d'√©chantillon actuel (gl_SampleID) comme num√©ro d'√©chantillon dans la texture multi-√©chantillon.  L'utilisation de la variable gl_SampleID dans le shader active automatiquement le mode lorsque le fragment shader est appel√© une fois pour chaque √©chantillon (dans des conditions normales, il est appel√© une fois pour le pixel entier, et le r√©sultat est √©crit sur tous les √©chantillons qui √©taient √† l'int√©rieur de la primitive). <br><br>  Il n'y a rien de remarquable dans le vertex shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br>  Fragment Shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br>  Et enfin, le contenu de la fonction ApplyTextures (): <br><br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Eh bien, ce serait bien de lib√©rer les ressources OpenGL apr√®s la fin.  J'ai ce code appel√© dans le destructeur de mon widget OpenGL: <br><br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457284/">https://habr.com/ru/post/fr457284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457262/index.html">Analyse des qualifications du championnat de programmation chez les d√©veloppeurs backend</a></li>
<li><a href="../fr457266/index.html">Crise agile. Que faire</a></li>
<li><a href="../fr457270/index.html">Prisma-CMS comme moteur de cr√©ation rapide de MVP</a></li>
<li><a href="../fr457276/index.html">Sept menaces de robots contre votre site</a></li>
<li><a href="../fr457282/index.html">"La mort de Dieu" ou l'effondrement des lois g√©n√©ralement accept√©es pour la constitution d'√©quipes informatiques et la cr√©ation de syst√®mes informatiques au 21e si√®cle</a></li>
<li><a href="../fr457286/index.html">La solution des t√¢ches WorldSkills du module R√©seau dans la comp√©tence de "CCA". Partie 1 - Configuration de base</a></li>
<li><a href="../fr457288/index.html">Station de travail cryptographique bas√©e sur les jetons PKCS # 11. Signature √©lectronique. 2e partie</a></li>
<li><a href="../fr457290/index.html">Conf√©rence DEFCON 25. Garry Kasparov. "La derni√®re bataille du cerveau." 2e partie</a></li>
<li><a href="../fr457292/index.html">WBOIT en OpenGL: transparence sans tri</a></li>
<li><a href="../fr457294/index.html">"Live high" ou mon histoire de la procrastination √† l'auto-d√©veloppement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>