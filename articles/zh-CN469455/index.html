<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💙 🚮 🌤️ 从Nginx迁移到Envoy代理 🕵🏼 ☂️ 👞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我引起您注意该帖子的翻译： 从Nginx迁移到Envoy Proxy 。 


 Envoy是为单个服务和应用程序设计的高性能分布式代理服务器（用C ++编写），它还是通信总线和为大型微服务“服务网格”体系结构设计的“通用数据平面”。 在创建它时，考虑了在开发诸如NGINX，HAProxy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从Nginx迁移到Envoy代理</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469455/"><p> 哈Ha！ 我引起您注意该帖子的翻译： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从Nginx迁移到Envoy Proxy</a> 。 </p><br><p>  Envoy是为单个服务和应用程序设计的高性能分布式代理服务器（用C ++编写），它还是通信总线和为大型微服务“服务网格”体系结构设计的“通用数据平面”。 在创建它时，考虑了在开发诸如NGINX，HAProxy，硬件负载平衡器和云负载平衡器之类的服务器期间出现的问题的解决方案。  Envoy与每个应用程序一起使用并抽象化网络，无论平台如何，都提供通用功能。 当基础结构中的所有办公室流量都通过Envoy网格时，可以通过一致的可观察性可视化问题区域，调整整体性能，并在特定位置添加基本功能，这很容易。 </p><br><h2 id="vozmozhnosti"> 可能性 </h2><br><ul><li>进程外架构：envoy是一台独立的高性能服务器，消耗少量RAM。 它可以与任何应用程序语言或框架结合使用。 </li><li> 支持http / 2和grpc：envoy对入站和出站连接提供了对http / 2和grpc的一流支持。 这是从http / 1.1到http / 2的透明代理。 </li><li> 先进的负载平衡：envoy支持先进的负载平衡功能，包括自动重试，断路，全局速度限制，影子请求，局部区域负载平衡等。 </li><li> 配置管理API：envoy提供了一个健壮的API，用于动态管理其配置。 </li><li> 可观察性：深入的L7流量可观察性，对mongodb，dynamodb和许多其他应用程序的分布式跟踪和可观察性的内置支持。 </li></ul><a name="habracut"></a><br><h2 id="shag-1---primer-konfiga-nginx"> 第1步-示例NGINX配置 </h2><br><p> 该脚本基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NGINX Wiki中</a>的完整示例，使用了一个特别创建的<em>nginx.conf</em>文件。 您可以通过打开<em>nginx.conf</em>在编辑器中查看配置 </p><br><p> 源nginx配置 </p><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">user</span></span> www www; <span class="hljs-attribute"><span class="hljs-attribute">pid</span></span> /var/run/nginx.pid; <span class="hljs-attribute"><span class="hljs-attribute">worker_processes</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-section"><span class="hljs-section">events</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">worker_connections</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span>; } <span class="hljs-section"><span class="hljs-section">http</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gzip</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_min_length</span></span> <span class="hljs-number"><span class="hljs-number">1100</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_buffers</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8k</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_types</span></span> text/plain; <span class="hljs-attribute"><span class="hljs-attribute">log_format</span></span> main <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_addr</span></span></span><span class="hljs-string"> - </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_user</span></span></span><span class="hljs-string"> [</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time_local</span></span></span><span class="hljs-string">] '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request</span></span></span><span class="hljs-string">" </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$status</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$bytes_sent</span></span></span><span class="hljs-string"> '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_referer</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_user_agent</span></span></span><span class="hljs-string">" '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$gzip_ratio</span></span></span><span class="hljs-string">"'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">log_format</span></span> download <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_addr</span></span></span><span class="hljs-string"> - </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_user</span></span></span><span class="hljs-string"> [</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time_local</span></span></span><span class="hljs-string">] '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request</span></span></span><span class="hljs-string">" </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$status</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$bytes_sent</span></span></span><span class="hljs-string"> '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_referer</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_user_agent</span></span></span><span class="hljs-string">" '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_range</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$sent_http_content_range</span></span></span><span class="hljs-string">"'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> targetCluster { 172.18.0.3:80; 172.18.0.4:80; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> one.example.com www.one.example.com; <span class="hljs-attribute"><span class="hljs-attribute">access_log</span></span> /var/log/nginx.access_log main; <span class="hljs-attribute"><span class="hljs-attribute">error_log</span></span> /var/log/nginx.error_log <span class="hljs-literal"><span class="hljs-literal">info</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://targetCluster/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_redirect</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; } } }</code> </pre> <br><p>  NGINX配置通常具有三个关键元素： </p><br><ol><li> 配置NGINX服务器，日志结构和Gzip功能。 这在所有情况下都是全局确定的。 </li><li> 将NGINX配置为在端口8080上接受对<em>one.example.com</em>主机的请求。 </li><li> 设置目标位置，以及如何处理URL不同部分的流量。 </li></ol><br><p> 并非所有配置都将应用于Envoy代理，并且您不需要配置某些设置。  Envoy代理具有<strong>四种</strong>支持NGINX提供的基础结构的<strong>关键类型</strong> 。 核心是： </p><br><ul><li>  <strong>侦听器：</strong>他们确定Envoy代理如何接受传入的请求。  Envoy代理当前仅支持基于TCP的侦听器。 建立连接后，会将其传输到一组过滤器进行处理。 </li><li>  <strong>过滤器：</strong>它们是可以处理传入和传出数据的流水线体系结构的一部分。 此功能包括过滤器，例如Gzip，可在将数据发送到客户端之前先对其进行压缩。 </li><li>  <strong>路由器：</strong>它们将流量重定向到所需的目的地（定义为群集）。 </li><li>  <strong>群集：</strong>它们定义流量和配置设置的端点。 </li></ul><br><p> 我们将使用这四个组件来创建Envoy代理配置，以匹配特定的NGINX配置。  Envoy的目标是使用API​​和动态配置。 在这种情况下，基本配置将使用NGINX的静态硬编码参数。 </p><br><h2 id="shag-2---konfiguraciya-nginx"> 第2步-配置NGINX </h2><br><p>  <em>nginx.conf</em>的第一部分定义了一些需要配置的内部NGINX组件。 </p><br><h4 id="worker-connections-rabochie-soedineniya"> 工人连接 </h4><br><p> 下面的配置确定工作流程和连接的数量。 这表明NGINX将如何扩展以满足需求。 </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">worker_processes</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-section"><span class="hljs-section">events</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">worker_connections</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span>; }</code> </pre> <br><p>  Envoy代理以不同的方式管理工作流程和连接。 </p><br><p>  Envoy为系统中的每个硬件线程创建一个工作流。 每个工作线程运行一个非阻塞事件循环，该循环负责 </p><br><ol><li> 倾听每个听众 </li><li> 接受新的连接 </li><li> 为连接创建过滤器集 </li><li> 在连接的整个生命周期内处理所有I / O操作。 </li></ol><br><p> 所有进一步的连接处理都将在工作流中得到完全处理，包括任何转发行为。 </p><br><p> 对于Envoy中的每个工作流程，池中都有一个连接。 因此，HTTP / 2连接池一次仅为每个外部主机建立一个连接；如果有四个工作线程，则处于稳定状态的每个外部主机将有四个HTTP / 2连接。 通过将所有内容存储在一个工作流中，几乎所有代码都可以编写而无需锁定，就好像它们是单线程的一样。 如果分配了不必要的工作流，则可能导致内存的非合理使用，大量空闲连接的创建以及返回到池中的连接数量的减少。 </p><br><p> 有关更多信息，请访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Envoy代理博客</a> 。 </p><br><h4 id="konfiguraciya-http">  HTTP配置 </h4><br><p> 以下NGINX配置块定义了HTTP设置，例如： </p><br><ul><li> 支持哪些MIME类型 </li><li> 默认超时 </li><li>  Gzip配置 </li></ul><br><p> 您可以使用Envoy代理中的过滤器配置这些方面，我们将在后面讨论。 </p><br><h2 id="shag-3---konfiguraciya-server"> 第3步-服务器配置 </h2><br><p> 在HTTP配置块中，NGINX配置指示您侦听端口8080并响应对域<em>one.example.com</em>和<em>www.one.example.com的</em>传入请求。 </p><br><pre> <code class="nginx hljs"> <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> one.example.com www.one.example.com;</code> </pre> <br><p> 在Envoy内部，由监听器控制。 </p><br><h4 id="slushateli-envoy"> 特使听众 </h4><br><p> 使用Envoy代理最重要的方面是识别侦听器。 您需要创建一个配置文件，该文件描述您要如何运行Envoy实例。 </p><br><p> 下面的代码片段将创建一个新的侦听器并将其与端口8080关联。配置告诉Envoy代理它应将哪些端口绑定到传入请求。 </p><br><p>  Envoy代理对其配置使用YAML表示法。 要熟悉此符号，请参见此处的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a> 。 </p><br><pre> <code class="plaintext hljs">Copy to Editorstatic_resources: listeners: - name: listener_0 address: socket_address: { address: 0.0.0.0, port_value: 8080 }</code> </pre> <br><p> 不需要定义<em>server_name</em> ，因为Envoy代理过滤器可以处理此问题。 </p><br><h2 id="shag-4---konfiguraciya-mestopolozheniya"> 第4步-位置配置 </h2><br><p> 当请求到达NGINX时，位置块确定如何处理以及将流量定向到何处。 在以下片段中，到站点的所有流量都传输到名为<em>targetCluster的</em>上游群集（译者注：上游通常是应用程序服务器）。 上游群集定义应处理请求的节点。 我们将在下一步中对此进行讨论。 </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://targetCluster/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_redirect</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; }</code> </pre> <br><p> 在Envoy，过滤器会执行此操作。 </p><br><h4 id="envoy-filters"> 使节过滤器 </h4><br><p> 对于静态配置，过滤器确定如何处理传入的请求。 在这种情况下，我们在上一步中设置与<em>server_names</em>匹配的过滤器。 当到达的请求对应于特定的域和路由时，流量将路由到群集。 这等效于NGINX上游配置。 </p><br><pre> <code class="plaintext hljs">Copy to Editor filter_chains: - filters: - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: backend domains: - "one.example.com" - "www.one.example.com" routes: - match: prefix: "/" route: cluster: targetCluster http_filters: - name: envoy.router</code> </pre> <br><p> 名称<em>envoy.http_connection_manager</em>是Envoy代理中的内置过滤器。 其他过滤器包括<em>Redis</em> ， <em>Mongo</em> ， <em>TCP</em> 。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>找到完整列表。 </p><br><p> 有关其他负载平衡策略的更多信息，请访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Envoy文档</a> 。 </p><br><h2 id="step-5---proxy-and-upstream-configuration"> 步骤5-代理和上游配置 </h2><br><p> 在NGINX中，上游配置定义了将处理流量的目标服务器集。 在这种情况下，分配了两个群集。 </p><br><pre> <code class="nginx hljs"> <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> targetCluster { 172.18.0.3:80; 172.18.0.4:80; }</code> </pre> <br><p> 在Envoy中，它是集群管理的。 </p><br><h4 id="envoy-clusters"> 特使群 </h4><br><p> 上游的等效项定义为群集。 在这种情况下，将确定将为流量提供服务的主机。 一种访问主机的方法（例如超时）被定义为群集配置。 这使您可以更准确地控制延迟和负载平衡等方面的粒度。 </p><br><pre> <code class="plaintext hljs">Copy to Editor clusters: - name: targetCluster connect_timeout: 0.25s type: STRICT_DNS dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN hosts: [ { socket_address: { address: 172.18.0.3, port_value: 80 }}, { socket_address: { address: 172.18.0.4, port_value: 80 }} ]</code> </pre> <br><p> 使用<em>STRICT_DNS</em>服务<em>发现时，</em> Envoy将连续且异步地解析指定的DNS目标。 由于DNS而返回的每个IP地址都将被视为上游群集中的显式主机。 这意味着，如果请求返回两个IP地址，Envoy将假定群集中有两个主机，并且两个主机都必须进行负载平衡。 如果从结果中删除了主机，则Envoy会假定它不再存在，并将从任何现有的连接池中选择流量。 </p><br><p> 有关更多信息，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Envoy代理文档</a> 。 </p><br><h2 id="shag-6---dostup-k-zhurnalu-i-oshibki"> 第6步-日志访问和错误 </h2><br><p> 最终配置是注册。  Envoy Proxy不会将错误日志传输到磁盘，而是使用基于云的方法。 所有应用程序日志都显示在<em>stdout</em>和<em>stderr中</em> 。 </p><br><p> 用户发出请求时，访问日志是可选的，默认情况下处于禁用状态。 要为HTTP请求启用访问日志，请为HTTP连接管理器启用<em>access_log</em>配置。 该路径可以是设备（例如<em>stdout）</em> ，也可以是磁盘上的文件，具体取决于您的要求。 </p><br><p> 以下配置会将所有访问日志重定向到<em>stdout</em> （译者注-stdout是在docker内部使用envoy所必需的。如果在不使用docker的情况下使用，请用常规日志文件的路径替换/ dev / stdout）。 将代码段复制到连接管理器的配置部分： </p><br><pre> <code class="plaintext hljs">Copy to Clipboardaccess_log: - name: envoy.file_access_log config: path: "/dev/stdout"</code> </pre> <br><p> 结果应如下所示： </p><br><pre> <code class="plaintext hljs"> - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http access_log: - name: envoy.file_access_log config: path: "/dev/stdout" route_config:</code> </pre> <br><p> 默认情况下，Envoy的格式字符串包含HTTP请求的详细信息： </p><br><pre> <code class="plaintext hljs">[%START_TIME%] "%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%" %RESPONSE_CODE% %RESPONSE_FLAGS% %BYTES_RECEIVED% %BYTES_SENT% %DURATION% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% "%REQ(X-FORWARDED-FOR)%" "%REQ(USER-AGENT)%" "%REQ(X-REQUEST-ID)%" "%REQ(:AUTHORITY)%" "%UPSTREAM_HOST%"\n</code> </pre> <br><p> 此格式字符串的结果： </p><br><pre> <code class="bash hljs">[2018-11-23T04:51:00.281Z] <span class="hljs-string"><span class="hljs-string">"GET / HTTP/1.1"</span></span> 200 - 0 58 4 1 <span class="hljs-string"><span class="hljs-string">"-"</span></span> <span class="hljs-string"><span class="hljs-string">"curl/7.47.0"</span></span> <span class="hljs-string"><span class="hljs-string">"f21ebd42-6770-4aa5-88d4-e56118165a7d"</span></span> <span class="hljs-string"><span class="hljs-string">"one.example.com"</span></span> <span class="hljs-string"><span class="hljs-string">"172.18.0.4:80"</span></span></code> </pre> <br><p> 可以通过设置格式字段来自定义输出内容。 例如： </p><br><pre> <code class="plaintext hljs">access_log: - name: envoy.file_access_log config: path: "/dev/stdout" format: "[%START_TIME%] "%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%" %RESPONSE_CODE% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% "%REQ(X-REQUEST-ID)%" "%REQ(:AUTHORITY)%" "%UPSTREAM_HOST%"\n"</code> </pre> <br><p> 通过设置<em>json_format</em>字段，日志字符串也可以JSON格式输出。 例如： </p><br><pre> <code class="plaintext hljs">access_log: - name: envoy.file_access_log config: path: "/dev/stdout" json_format: {"protocol": "%PROTOCOL%", "duration": "%DURATION%", "request_method": "%REQ(:METHOD)%"}</code> </pre> <br><p> 有关特使注册技术的更多信息，请访问 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.envoyproxy.io/docs/envoy/latest/configuration/access_log#config-access-log-format-dictionaries</a> </p><br><p> 记录并不是获得使用Envoy Proxy的唯一方法。 它具有用于跟踪和指标的内置高级功能。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">跟踪文档中</a>或通过“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交互式跟踪脚本”</a>找到更多信息。 </p><br><h2 id="shag-7---zapusk"> 第7步-启动 </h2><br><p> 现在，您已将配置从NGINX转移到Envoy代理。 最后一步是运行Envoy代理实例进行测试。 </p><br><h4 id="zapusk-ot-polzovatelya"> 从用户运行 </h4><br><p> 在NGINX配置的顶部，线路<em>用户www www</em> ;。 表示已以低特权用户身份启动NGINX，以增强安全性。 </p><br><p>  Envoy Proxy采用基于云的方法来管理谁拥有流程。 通过容器运行Envoy代理时，可以指定特权级别低的用户。 </p><br><h4 id="zapusk-envoy-proxy"> 启动特使代理 </h4><br><p> 下面的命令将通过主机上的Docker容器启动Envoy代理。 此命令使Envoy能够通过端口80侦听传入的请求。但是，如侦听器配置中所示，Envoy代理通过端口8080侦听传入的通信。这使该进程可以低特权用户身份运行。 </p><br><pre> <code class="bash hljs">docker run --name proxy1 -p 80:8080 --user 1000:1000 -v /root/envoy.yaml:/etc/envoy/envoy.yaml envoyproxy/envoy</code> </pre> <br><h4 id="testirovanie"> 测试中 </h4><br><p> 使用代理运行，现在可以进行测试并进行处理。 以下cURL命令使用代理配置中定义的主机头发出请求。 </p><br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">"Host: one.example.com"</span></span> localhost -i</code> </pre> <br><p>  HTTP请求将导致错误<em>503</em> 。 这是由于以下事实：上游连接不起作用并且不可用。 因此，Envoy代理对该请求没有任何可用的目标目的地。 以下命令将启动一系列与为Envoy定义的配置相匹配的HTTP服务。 </p><br><pre> <code class="bash hljs">docker run -d katacoda/docker-http-server; docker run -d katacoda/docker-http-server;</code> </pre> <br><p> 有了可用的服务，Envoy可以成功地将流量代理到其目的地。 </p><br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">"Host: one.example.com"</span></span> localhost -i</code> </pre> <br><p> 您应该看到一个响应，指示哪个Docker容器已经处理了请求。 在Envoy代理日志中，您还应该看到显示的访问字符串。 </p><br><h4 id="dopolnitelnye-zagolovki-otveta-http-http-response"> 其他HTTP响应标头 </h4><br><p> 您将在实际请求的响应标头中看到其他HTTP标头。 标头显示上游主机花费在处理请求上的时间。 以毫秒为单位。 如果客户端希望确定服务时间（相对于网络延迟），这将很有用。 </p><br><pre> <code class="plaintext hljs">x-envoy-upstream-service-time: 0 server: envoy</code> </pre> <br><h2 id="itogovyy-konfig"> 最终配置 </h2><br><pre> <code class="plaintext hljs">static_resources: listeners: - name: listener_0 address: socket_address: { address: 0.0.0.0, port_value: 8080 } filter_chains: - filters: - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: backend domains: - "one.example.com" - "www.one.example.com" routes: - match: prefix: "/" route: cluster: targetCluster http_filters: - name: envoy.router clusters: - name: targetCluster connect_timeout: 0.25s type: STRICT_DNS dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN hosts: [ { socket_address: { address: 172.18.0.3, port_value: 80 }}, { socket_address: { address: 172.18.0.4, port_value: 80 }} ] admin: access_log_path: /tmp/admin_access.log address: socket_address: { address: 0.0.0.0, port_value: 9090 }</code> </pre> <br><h2 id="dopolnitelnaya-informaciya-ot-perevodchika"> 翻译人员提供的其他信息 </h2><br><p> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.getenvoy.io/</a>上找到Envoy代理安装说明。 </p><br><p> 默认情况下，rpm中没有systemd服务配置。 </p><br><p> 添加系统服务配置/etc/systemd/system/envoy.service： </p><br><pre> <code class="bash hljs">[Unit] Description=Envoy Proxy Documentation=https://www.envoyproxy.io/ After=network-online.target Requires=envoy-auth-server.service Wants=nginx.service [Service] User=root Restart=on-failure ExecStart=/usr/bin/envoy --config-path /etc/envoy/config.yaml [Install] WantedBy=multi-user.target</code> </pre> <br><p> 您需要创建目录/ etc / envoy /，并将config.yaml配置放在此处。 </p><br><p> 通过特使代理进行电报聊天： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//t.me/envoyproxy_ru</a> </p><br><p>  Envoy代理不支持静态内容分发。 那么谁可以投票支持功能： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/envoyproxy/envoy/issues/378</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN469455/">https://habr.com/ru/post/zh-CN469455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN469445/index.html">AngularConnect 2019概述。第2部分</a></li>
<li><a href="../zh-CN469447/index.html">人工智能从一个奇妙的想法到科学产业的道路</a></li>
<li><a href="../zh-CN469449/index.html">EV SSL证书：死后还有生命吗？</a></li>
<li><a href="../zh-CN469451/index.html">零哲学</a></li>
<li><a href="../zh-CN469453/index.html">多项目模式下的分布式团队管理（审阅和视频报告）</a></li>
<li><a href="../zh-CN469457/index.html">盛会的去向</a></li>
<li><a href="../zh-CN469459/index.html">在智慧城市中连接物联网设备</a></li>
<li><a href="../zh-CN469461/index.html">“献给星星”：反宇宙的“今日启示录”</a></li>
<li><a href="../zh-CN469463/index.html">自然语言处理的趋势和预测</a></li>
<li><a href="../zh-CN469465/index.html">现代C ++中的初始化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>