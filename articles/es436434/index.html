<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìü üçù üë®üèΩ‚Äçüíª PVS-Studio para Java üßúüèΩ üßê ‚ÜôÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la s√©ptima versi√≥n del analizador est√°tico PVS-Studio, agregamos soporte para el lenguaje Java. Es hora de hablar un poco sobre c√≥mo comenzamos a b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio para Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/436434/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/2ca/ccd/8592caccdc92ac430645bd487d7b5284.png" alt="PVS-Studio para Java"></div><br>  En la s√©ptima versi√≥n del analizador est√°tico PVS-Studio, agregamos soporte para el lenguaje Java.  Es hora de hablar un poco sobre c√≥mo comenzamos a brindar soporte para el lenguaje Java, qu√© hicimos y qu√© planes futuros.  Y, por supuesto, el art√≠culo mostrar√° las primeras pruebas del analizador en proyectos abiertos. <br><a name="habracut"></a><br><h2>  PVS-Studio </h2><br>  Para los desarrolladores de Java que no han o√≠do hablar de la herramienta PVS-Studio antes, les dar√© una breve descripci√≥n. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio</a> es una herramienta para detectar errores y vulnerabilidades potenciales en el c√≥digo fuente de programas escritos en C, C ++, C # y Java.  Se ejecuta en Windows, Linux y macOS. <br><br>  PVS-Studio realiza un an√°lisis de c√≥digo est√°tico y genera un informe que ayuda al programador a encontrar y corregir defectos.  Para aquellos que est√©n interesados ‚Äã‚Äãen c√≥mo exactamente PVS-Studio est√° buscando errores, les sugiero que lean el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tecnolog√≠as utilizadas en el analizador de c√≥digo PVS-Studio para encontrar errores y vulnerabilidades potenciales</a> ". <br><br><h2>  Inicio </h2><br>  Podr√≠a presentar una historia inteligente, ya que hemos estado pensando durante dos a√±os sobre qu√© pr√≥ximo idioma admitir en PVS-Studio.  El hecho de que Java es una opci√≥n razonable basada en la gran popularidad de este lenguaje, etc. <br><br>  Sin embargo, como sucede en la vida, todo se decidi√≥ no mediante un an√°lisis en profundidad, sino mediante un experimento :).  S√≠, est√°bamos pensando en qu√© direcci√≥n deber√≠a desarrollarse m√°s el analizador PVS-Studio.  Se consideraron lenguajes de programaci√≥n como: Java, PHP, Python, JavaScript, IBM RPG.  Y est√°bamos inclinados al lenguaje Java, pero la elecci√≥n final a√∫n no se ha hecho.  Aquellos cuyos ojos est√°n atrapados en un RPG de IBM desconocido, me refiero a esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nota aqu√≠</a> , de la que todo se aclarar√°. <br><br>  A finales de 2017, el colega Egor Bredikhin analiz√≥ qu√© bibliotecas preparadas para analizar el c√≥digo (en otras palabras, analizadores) est√°n disponibles para nuevas direcciones que nos interesan.  Y me encontr√© con varios proyectos para analizar el c√≥digo Java.  Basado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Spoon</a> , r√°pidamente logr√≥ hacer un prototipo de analizador con un par de diagn√≥sticos.  Adem√°s, qued√≥ claro que podemos usar algunos mecanismos del analizador C ++ con la ayuda de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SWIG</a> en el analizador Java.  Observamos lo que sucedi√≥ y nos dimos cuenta de que nuestro pr√≥ximo analizador ser√≠a para Java. <br><br>  Gracias a Egor por su trabajo emprendedor y activo realizado por √©l en el analizador de Java.  El desarrollo se describe en el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo de un nuevo analizador est√°tico: PVS-Studio Java</a> ". <br><br><h2>  Competidores? </h2><br>  Existen muchos analizadores de c√≥digo est√°tico gratuitos y comerciales para Java en el mundo.  No tiene sentido enumerarlos a todos en el art√≠culo, y solo dejo un enlace a " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lista de herramientas para el an√°lisis de c√≥digo est√°tico</a> " (consulte la secci√≥n Java y Multi-idioma). <br><br>  Sin embargo, s√© que, en primer lugar, se nos preguntar√° sobre IntelliJ IDEA, FindBugs y SonarQube (SonarJava). <br><br>  <b>IDEA IntelliJ</b> <br><br>  IntelliJ IDEA tiene incorporado un analizador de c√≥digo est√°tico muy potente.  Adem√°s, el analizador se est√° desarrollando y sus autores est√°n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">monitoreando de</a> cerca nuestras actividades.  Con IntelliJ IDEA seremos los m√°s dif√≠ciles.  No podremos superar IntelliJ IDEA en capacidades de diagn√≥stico, al menos por ahora.  Por lo tanto, intentaremos concentrarnos en nuestras otras ventajas. <br><br>  El an√°lisis est√°tico en IntelliJ IDEA es, en primer lugar, uno de los chips del entorno de desarrollo, que le impone ciertas restricciones.  Somos libres en lo que podemos hacer con nuestro analizador.  Por ejemplo, podemos adaptar r√°pidamente el analizador a las necesidades espec√≠ficas del cliente.  El soporte r√°pido y profundo es nuestra ventaja competitiva.  Nuestros clientes se comunican directamente con los programadores que desarrollan una parte particular de PVS-Studio. <br><br>  PVS-Studio tiene muchas posibilidades para integrarlo en el ciclo de desarrollo de grandes proyectos antiguos.  Esta es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">integraci√≥n con SonarQube</a> .  Esta es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">supresi√≥n masiva de los</a> mensajes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del</a> analizador, que le permite comenzar a usar inmediatamente el analizador en un proyecto grande para rastrear errores solo en c√≥digo nuevo o modificado.  PVS-Studio est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">integrado</a> en el proceso de integraci√≥n continua.  Creo que estas y otras caracter√≠sticas ayudar√°n a nuestro analizador a encontrar un lugar bajo el sol en el mundo de Java. <br><br>  <b>Findbugs</b> <br><br>  El proyecto FindBugs est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">abandonado</a> .  Pero debe recordarse por la raz√≥n de que este es quiz√°s el analizador est√°tico gratuito m√°s conocido del c√≥digo Java. <br><br>  El sucesor de FindBugs es el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SpotBugs</a> .  Sin embargo, es menos popular, y lo que le suceder√° a√∫n no est√° del todo claro. <br><br>  En general, creemos que aunque FindBugs fue y sigue siendo extremadamente popular, y tambi√©n un analizador gratuito, no debemos pensar en ello.  Este proyecto es silenciosamente una cosa del pasado. <br><br>  PD: Por cierto, ahora PVS-Studio tambi√©n se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usar de forma gratuita</a> cuando se trabaja con proyectos abiertos. <br><br>  <b>SonarQube (SonarJava)</b> <br><br>  Creemos que no competimos con SonarQube, sino que lo complementamos.  PVS-Studio se integra con SonarQube, que permite a los desarrolladores encontrar m√°s errores y vulnerabilidades potenciales en sus proyectos.  C√≥mo integrar la herramienta PVS-Studio y otros analizadores en SonarQube, hablamos regularmente en clases magistrales que realizamos en varias conferencias ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a> ). <br><br><h2>  C√≥mo iniciar PVS-Studio para Java </h2><br>  Hemos puesto a disposici√≥n de los usuarios las formas m√°s populares de integrar el analizador en el sistema de ensamblaje: <br><br><ul><li>  Plugin para Maven; </li><li>  Plugin para Gradle; </li><li>  Plugin para IntelliJ IDEA </li></ul><br>  En la etapa de prueba, conocimos a muchos usuarios que tienen sistemas de ensamblaje autoescritos, especialmente en el desarrollo m√≥vil.  Les gust√≥ la capacidad de ejecutar el analizador directamente, enumerando las fuentes y classpath. <br><br>  Puede encontrar informaci√≥n detallada sobre todos los m√©todos para iniciar el analizador en la p√°gina de documentaci√≥n " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo iniciar PVS-Studio Java</a> ". <br><br>  No pod√≠amos ignorar la plataforma de control de calidad del c√≥digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SonarQube</a> , tan popular entre los desarrolladores de Java, por lo que agregamos compatibilidad con el lenguaje Java a nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complemento SonarQube</a> . <br><br><h2>  Planes adicionales </h2><br>  Tenemos muchas ideas que necesitan m√°s estudio, pero algunos planes espec√≠ficos para cualquiera de nuestros analizadores se ven as√≠: <br><br><ul><li>  Creaci√≥n de nuevos diagn√≥sticos y refinamiento de los existentes; </li><li>  Desarrollo de an√°lisis de flujo de datos; </li><li>  Mejora de la fiabilidad y la usabilidad. </li></ul><br>  Podemos encontrar tiempo para adaptar el complemento IntelliJ IDEA para CLion.  Hola C ++ a los desarrolladores que leen sobre el analizador de Java :-) <br><br><h2>  Ejemplos de errores encontrados en proyectos de c√≥digo abierto </h2><br>  No ser√© yo si no muestro ning√∫n error encontrado usando el nuevo analizador en el art√≠culo.  Podr√≠amos tomar un gran proyecto Java de c√≥digo abierto y escribir un art√≠culo cl√°sico con an√°lisis de errores, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solemos hacer</a> . <br><br>  Sin embargo, inmediatamente preveo las preguntas de si podemos encontrar algo en proyectos como IntelliJ IDEA, FindBugs, etc.  Por lo tanto, simplemente no tengo una salida, y comenzar√© precisamente con estos proyectos.  Entonces, decid√≠ revisar y escribir r√°pidamente algunos ejemplos interesantes de errores de los siguientes proyectos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IntelliJ IDEA Community Edition</a> .  Creo que no hay necesidad de explicar por qu√© se eligi√≥ este proyecto :). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SpotBugs</a>  Como escrib√≠ anteriormente, el proyecto FindBugs no se est√° desarrollando.  As√≠ que eche un vistazo al proyecto SpotBugs, que es el sucesor de FindBugs.  SpotBugs es un analizador de c√≥digo Java est√°tico cl√°sico. </li><li>  Algunos de los proyectos de SonarSource, que desarrolla software para el control continuo de la calidad del c√≥digo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Echa un</a> vistazo a los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyectos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SonarQube</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SonarJava</a> . </li></ul><br>  Escribir sobre errores en estos proyectos es una tarea dif√≠cil.  El hecho es que estos proyectos son de muy alta calidad.  En realidad, esto no es sorprendente.  Como muestran nuestras observaciones, el c√≥digo de los analizadores est√°ticos siempre se prueba y verifica con otras herramientas. <br><br>  A pesar de todo esto, tengo que comenzar con estos mismos proyectos.  No tendr√© una segunda oportunidad de escribir algo sobre ellos.  Estoy seguro de que despu√©s del lanzamiento de PVS-Studio para Java, los desarrolladores de estos proyectos pondr√°n en servicio PVS-Studio y comenzar√°n a usarlo para verificaciones regulares o al menos peri√≥dicas de su c√≥digo.  Por ejemplo, s√© que Tagir Valeyev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">lany</a> ), uno de los desarrolladores de JetBrains, que se dedica al analizador de c√≥digo est√°tico IntelliJ IDEA, ya est√° jugando con la versi√≥n Beta de PVS-Studio en el momento en que escribo el art√≠culo.  Ya nos ha escrito unas 15 cartas con informes de errores y recomendaciones.  Gracias Tagir! <br><br>  Afortunadamente, no necesito encontrar tantos errores como sea posible en un proyecto en particular.  Ahora mi tarea es mostrar que el analizador PVS-Studio para Java no apareci√≥ en vano y podr√° reponer la l√≠nea de otras herramientas dise√±adas para mejorar la calidad del c√≥digo.  Ech√© un vistazo a los informes del analizador y escrib√≠ algunos errores que me parecieron interesantes.  Siempre que fue posible, trat√© de escribir errores de varios tipos.  Veamos que pas√≥. <br><br><h3>  IntelliJ IDEA Integer Division </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSentenceCapitalization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; words = StringUtil.split(value, <span class="hljs-string"><span class="hljs-string">" "</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capitalized = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capitalized / words.size() &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allow reasonable amount of // capitalized words }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: V6011 [CWE-682] El literal '0.2' del tipo 'doble' se compara con un valor del tipo 'int'.  TitleCapitalizationInspection.java 169 <br><br>  Seg√∫n lo previsto, una funci√≥n deber√≠a ser verdadera si menos del 20% de las palabras comienzan con may√∫scula.  De hecho, la comprobaci√≥n no funciona, ya que se produce la divisi√≥n de enteros.  Como resultado de la divisi√≥n, solo se pueden obtener dos valores: 0 o 1. <br><br>  La funci√≥n devolver√° un valor falso solo si todas las palabras comienzan con una letra may√∫scula.  En todos los dem√°s casos, la divisi√≥n producir√° 0 y la funci√≥n devolver√° el valor verdadero. <br><br><h3>  IntelliJ IDEA Ciclo sospechoso </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPreviousIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> current)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = myPainter.getErrorStripeCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= current &amp;&amp; current &lt; count) { current--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int layer = getLayer(index); if (layer &gt; foundLayer) { foundIndex = index; foundLayer = layer; } } .... }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: V6007 [CWE-571] La expresi√≥n 'index&gt; = 0' siempre es verdadera.  Updater.java 184 <br><br>  Primero, observe la condici√≥n <i>(0 &lt;= actual &amp;&amp; actual &lt;cuenta)</i> .  Solo se ejecuta si el valor de la variable de <i>conteo</i> es mayor que 0. <br><br>  Ahora mira el bucle: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++)</code> </pre> <br>  El <i>√≠ndice</i> variable <i>se</i> inicializa mediante la expresi√≥n <i>count - 1</i> .  Como la variable de <i>conteo</i> es mayor que 0, el valor inicial de la variable de <i>√≠ndice</i> siempre es mayor o igual que 0. Resulta que el ciclo se ejecutar√° hasta que la variable de <i>√≠ndice se</i> desborde. <br><br>  Lo m√°s probable es que esto sea solo un error tipogr√°fico y el incremento no debe ejecutarse, sino la disminuci√≥n de la variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index--)</code> </pre> <br><h3>  IDEA IntelliJ, copiar y pegar </h3><br><pre> <code class="cpp hljs">@NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String BEFORE_STR_OLD = <span class="hljs-string"><span class="hljs-string">"before:"</span></span>; @NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String AFTER_STR_OLD = <span class="hljs-string"><span class="hljs-string">"after:"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBeforeOrAfterKeyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, boolean trimKeyword)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (trimKeyword ? LoadingOrder.BEFORE_STR.trim() : LoadingOrder.BEFORE_STR).equalsIgnoreCase(str) || (trimKeyword ? LoadingOrder.AFTER_STR.trim() : LoadingOrder.AFTER_STR).equalsIgnoreCase(str) || LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str); // &lt;= }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: V6001 [CWE-570] Hay subexpresiones id√©nticas 'LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase (str)' a la izquierda y a la derecha de '||'  operador  L√≠neas de verificaci√≥n: 127, 128. ExtensionOrderConverter.java 127 <br><br>  Buen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">efecto</a> antiguo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de la √∫ltima l√≠nea</a> .  El programador se apresur√≥ y, al multiplicar una l√≠nea de c√≥digo, olvid√≥ arreglarlo.  Como resultado, el doble de la cadena <i>str se</i> compara con <i>BEFORE_STR_OLD</i> .  Lo m√°s probable es que una de las comparaciones sea con <i>AFTER_STR_OLD</i> . <br><br><h3>  IntelliJ IDEA typo </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, final Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\''</span></span>) &amp;&amp; !StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name = <span class="hljs-string"><span class="hljs-string">"\""</span></span> + name; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'"'</span></span>) &amp;&amp; !StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; } .... }</code> </pre> <br>  Advertencia de PVS-Studio: V6001 [CWE-571] Hay subexpresiones id√©nticas '! StringUtil.endsWithChar (nombre,' "')' a la izquierda y a la derecha del operador '&amp;&amp;'. JsonNamesValidator.java 27 <br><br>  Este fragmento de c√≥digo verifica que el nombre est√© entre comillas simples o dobles.  Si este no es el caso, las comillas dobles se agregan autom√°ticamente. <br><br>  Debido a un error tipogr√°fico, el final del nombre solo se verifica para las comillas dobles.  Como resultado, el nombre tomado entre comillas simples no se procesar√° correctamente. <br><br>  Nombre <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span></code> </pre> <br>  debido a la adici√≥n de comillas dobles adicionales se convertir√° en: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><h3>  IntelliJ IDEA, protecci√≥n de desbordamiento de matriz incorrecta </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = offset; i &lt; endOffset; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = text.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; i &lt; endOffset &amp;&amp; text.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; startTag != null &amp;&amp; CharArrayUtil.regionMatches(text, i + <span class="hljs-number"><span class="hljs-number">2</span></span>, endOffset, startTag)) { endTagStartOffset = i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  Advertencia de PVS-Studio: V6007 [CWE-571] La expresi√≥n 'i &lt;endOffset' siempre es verdadera.  EnterAfterJavadocTagHandler.java 183 <br><br>  La subexpresi√≥n <i>i &lt;endOffset</i> en la condici√≥n de la <i>instrucci√≥n if</i> no tiene sentido.  La variable <i>i</i> siempre es menor que <i>endOffset</i> , como se deduce de la condici√≥n para ejecutar el bucle. <br><br>  Lo m√°s probable es que el programador quisiera protegerse para no salirse de la l√≠nea al llamar a funciones: <br><br><ul><li>  text.charAt (i + 1) </li><li>  CharArrayUtil.regionMatches (texto, i + 2, endOffset, startTag) </li></ul><br>  En este caso, la subexpresi√≥n para verificar el √≠ndice deber√≠a ser as√≠: <i>i &lt;endOffset - 2</i> . <br><br><h3>  IntelliJ IDEA Repeat Check </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateWarningMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buffer.append(<span class="hljs-string"><span class="hljs-string">" "</span></span>).append( IdeBundle.message(<span class="hljs-string"><span class="hljs-string">"prompt.delete.and"</span></span>)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } } .... }</code> </pre> <br>  Advertencia de PVS-Studio: V6007 [CWE-571] La expresi√≥n 'buffer.length ()&gt; 0' siempre es verdadera.  DeleteUtil.java 62 <br><br>  Esto puede ser un c√≥digo redundante inofensivo o un error grave. <br><br>  Si una verificaci√≥n duplicada apareci√≥ por casualidad, por ejemplo, durante la refactorizaci√≥n, entonces no hay nada de malo en eso.  La segunda verificaci√≥n simplemente se puede eliminar. <br><br>  Pero otro escenario es posible.  La segunda verificaci√≥n debe ser completamente diferente y el c√≥digo no se comporta como se esperaba.  Entonces esto es un verdadero error. <br><br>  <b>Nota</b>  Por cierto, hay muchas comprobaciones redundantes diferentes.  Adem√°s, a menudo se ve que esto no es un error.  Sin embargo, los mensajes del analizador tampoco se pueden llamar falsos positivos.  Para aclarar, aqu√≠ hay un ejemplo, tambi√©n tomado de IntelliJ IDEA: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMultiline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ String text = element.getText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); }</code> </pre> <br>  El analizador dice que la funci√≥n <i>text.contains ("\ r \ n")</i> siempre devuelve falso.  De hecho, si no se encuentran el s√≠mbolo "\ n" y "\ r", entonces no tiene sentido buscar "\ r \ n".  Esto no es un error, y el c√≥digo es malo solo porque funciona un poco m√°s lento, realizando una b√∫squeda sin sentido de una subcadena. <br><br>  C√≥mo lidiar con dicho c√≥digo, en cada caso, corresponde a los programadores decidir.  Al escribir art√≠culos, por regla general, simplemente no presto atenci√≥n a dicho c√≥digo. <br><br><h3>  IDEA IntelliJ, algo est√° mal </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... @NonNls final String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == null || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-string"><span class="hljs-string">'0'</span></span>; }</code> </pre> <br>  Advertencia de PVS-Studio: V6007 [CWE-570] La expresi√≥n '"0" .equals (texto)' siempre es falsa.  ConvertIntegerToDecimalPredicate.java 46 <br><br>  Este c√≥digo definitivamente contiene un error l√≥gico.  Pero me resulta dif√≠cil decir qu√© quer√≠a comprobar el programador y c√≥mo corregir el defecto.  Por lo tanto, aqu√≠ solo se√±alar√© una verificaci√≥n sin sentido. <br><br>  Al principio, se verifica que la cadena debe contener al menos dos caracteres.  Si no es as√≠, la funci√≥n devuelve <i>falso</i> . <br><br>  La siguiente es una comprobaci√≥n de <i>"0" .equals (texto)</i> .  No tiene sentido, ya que una cadena no puede contener solo un car√°cter. <br><br>  En general, algo est√° mal aqu√≠ y el c√≥digo debe repararse. <br><br><h3>  SpotBugs (sucesor de FindBugs), error de l√≠mite de iteraci√≥n </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getXMLType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@WillNotClose InputStream in)</span></span></span><span class="hljs-function"> throws IOException </span></span>{ .... String s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { s = r.readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == null) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Matcher m = tag.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.find()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Didn't find xml tag"</span></span>); .... }</code> </pre> <br>  Advertencia de PVS-Studio: V6007 [CWE-571] La expresi√≥n 'cuenta &lt;4' siempre es verdadera.  Util.java 394 <br><br>  Seg√∫n lo planeado, la b√∫squeda de la etiqueta xml debe llevarse a cabo solo en las primeras cuatro l√≠neas del archivo.  Pero debido al hecho de que olvidaron aumentar el <i>recuento</i> variable, se leer√° todo el archivo. <br><br>  En primer lugar, esto puede resultar una operaci√≥n muy lenta y, en segundo lugar, en el medio del archivo, se puede encontrar algo que se interpretar√° como una etiqueta xml, pero no ser√° as√≠. <br><br><h3>  SpotBugs (sucesor de FindBugs), sobrescribiendo valores </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportBug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = LOW_PRIORITY; String pattern = <span class="hljs-string"><span class="hljs-string">"NS_NON_SHORT_CIRCUIT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawDangerOld) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawNullTestVeryOld) { priority = HIGH_PRIORITY; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } if (sawMethodCallOld || sawNumericTestVeryOld &amp;&amp; sawArrayDangerOld) { priority = HIGH_PRIORITY; // &lt;= pattern = "NS_DANGEROUS_NON_SHORT_CIRCUIT"; } else { priority = NORMAL_PRIORITY; // &lt;= } } bugAccumulator.accumulateBug( new BugInstance(this, pattern, priority).addClassAndMethod(this), this); }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: V6021 [CWE-563] El valor se asigna a la variable 'prioridad' pero no se utiliza.  FindNonShortCircuit.java 197 <br><br>  El valor de la variable de <i>prioridad</i> se establece dependiendo del valor de la variable <i>sawNullTestVeryOld</i> .  Sin embargo, esto no juega ning√∫n papel.  Adem√°s, a la variable de <i>prioridad</i> se le asignar√° un valor diferente en cualquier caso.  Un error obvio en la l√≥gica de la funci√≥n. <br><br><h3>  SonarQube, Copy-Paste </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuleDto</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleDefinitionDto definition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleMetadataDto metadata; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } .... }</code> </pre> <br>  PVS-Studio: V6032 Es extra√±o que el cuerpo del m√©todo 'setUpdatedAtFromDefinition' sea completamente equivalente al cuerpo de otro m√©todo 'setUpdatedAtFromMetadata'.  L√≠neas de verificaci√≥n: 396, 405. RuleDto.java 396 <br><br>  El m√©todo <i>setUpdatedAtFromMetadata</i> usa el campo de <i>definici√≥n</i> .  Lo m√°s probable es que se use el campo de <i>metadatos</i> .  Esto es muy similar a las consecuencias del fallido Copy-Paste. <br><br><h3>  SonarJava, duplicados en inicializaci√≥n de mapa </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Map&lt;JavaPunctuator, Tree.Kind&gt; assignmentOperators = Maps.newEnumMap(JavaPunctuator.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KindMaps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... }</code> </pre> <br>  Advertencia de PVS-Studio: V6033 [CWE-462] Ya se ha agregado un elemento con la misma clave 'JavaPunctuator.PLUSEQU'.  L√≠neas de verificaci√≥n: 104, 100. KindMaps.java 104 <br><br>  El mismo par clave-valor se coloca dos veces en la tarjeta.  Lo m√°s probable es que esto haya sido desatento, y de hecho no hay ning√∫n error real.  Sin embargo, en cualquier caso, es necesario verificar este c√≥digo, ya que es posible que haya olvidado agregar alg√∫n otro par. <br><br><h2>  Conclusi√≥n </h2><br>  ¬øPero qu√© conclusi√≥n puede haber?  ¬°Invito a todos, sin demora, a descargar PVS-Studio e intentar probar sus proyectos de trabajo en Java!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descargar PVS-Studio</a> . <br><br>  Gracias a todos por su atenci√≥n.  Espero que pronto deleitemos a los lectores con una serie de art√≠culos dedicados a verificar varios proyectos Java abiertos. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Si desea compartir este art√≠culo con una audiencia de habla inglesa, utilice el enlace a la traducci√≥n: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio para Java</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436434/">https://habr.com/ru/post/es436434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436424/index.html">Peque√±as criaturas, grandes hechos: el papel de los cortadores de hojas en el efecto invernadero de los neotr√≥picos</a></li>
<li><a href="../es436426/index.html">Pausa la aplicaci√≥n si se pierde la conexi√≥n de red</a></li>
<li><a href="../es436428/index.html">¬øPor qu√© animamos a la programaci√≥n deportiva?</a></li>
<li><a href="../es436430/index.html">Confesi√≥n de un graf√≥mano</a></li>
<li><a href="../es436432/index.html">SAP: ¬øQu√© necesitas para comenzar a aprender SAPUI5?</a></li>
<li><a href="../es436436/index.html">El CERN planea construir un nuevo acelerador con una longitud de t√∫nel de 100 km.</a></li>
<li><a href="../es436438/index.html">Roscosmos llam√≥ a las posibles razones de la p√©rdida de comunicaci√≥n con el observatorio orbital Spektr-R</a></li>
<li><a href="../es436440/index.html">Gotta Go Fast: Building for Speed ‚Äã‚Äãen iOS. Parte 2</a></li>
<li><a href="../es436442/index.html">Una cabeza es buena y dos son mejores, o empareje la programaci√≥n en acci√≥n</a></li>
<li><a href="../es436444/index.html">Despliegue invisible de una aplicaci√≥n monol√≠tica en producci√≥n en AWS. Experiencia personal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>