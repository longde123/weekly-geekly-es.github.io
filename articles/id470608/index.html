<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈂️ 💇🏻 ☔️ Optimasi UI Unity 💂🏼 ☄️ 🌗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini membahas optimalisasi elemen-UI proyek yang dibuat di Unity. Berdasarkan informasi dari dokumentasi resmi dan pengalaman pribadi, saya men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimasi UI Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/470608/"><p><img src="https://habrastorage.org/webt/zc/iw/5s/zciw5sbh_cn-pp5gmmxwu5rznm0.png" alt="gambar"></p><br><p>  Artikel ini membahas optimalisasi elemen-UI proyek yang dibuat di Unity.  Berdasarkan informasi dari dokumentasi resmi dan pengalaman pribadi, saya mencoba menjelaskan dengan jelas prinsip-prinsip pengoperasian elemen UI.  Juga di sini Anda akan menemukan tips praktis yang akan membantu meningkatkan kinerja proyek Anda sehubungan dengan antarmuka pengguna. </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terminologi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rendering UI kesatuan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mendesain ulang antarmuka pengguna</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Meshing</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tips Optimalisasi UI Umum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bekerja dengan teks dan pengoptimalannya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sprite Atlases</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ringkas metode pengoptimalan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> </li></ul><br><h3 id="anchorthermsanchorterminologiya"><a name="therms"></a>  Terminologi </h3><br><p> <strong>Elemen UI</strong> adalah semua elemen di Unity yang terkait dengan pembuatan antarmuka pengguna.  Ini termasuk, misalnya: tombol, teks, gambar, menu drop-down, dll. <br>  <strong>Kanvas (kanvas)</strong> - elemen dasar dari UI, yang merupakan wadah untuk sisa elemen. <br>  <strong>Mesh</strong> - satu set parameter yang menggambarkan model 3D. <br>  <strong>Quad</strong> adalah mesh yang merupakan quadrangle. <br>  <strong>Batching</strong> - menggabungkan objek mesh menjadi satu mesh besar untuk rendering lebih cepat. <br>  <strong>Draw-call</strong> - perintah untuk menggambar dari mesin ke API grafik (misalnya, OpenGL atau Direct3D). <br>  <strong>Antrian transparan</strong> - antrian untuk merender objek transparan. <br>  <strong>Alpha blending</strong> (Alpha blending) - sebuah algoritma untuk pencampuran piksel pada saluran alpha untuk mendapatkan gambar dengan transparansi. <br>  <strong>Atlas</strong> adalah jenis sumber daya yang menggabungkan beberapa tekstur menjadi satu. </p><br><h3 id="anchorenteranchorvvodnaya"><a name="enter"></a>  Pendahuluan </h3><br><p>  Dalam optimasi UI, tidak ada aturan universal yang berfungsi dalam situasi apa pun.  Semuanya bermuara pada menemukan keseimbangan antara biaya batching dan jumlah panggilan draw.  Empat masalah utama dapat dibedakan: </p><br><ul><li>  Memuat GPU terlalu tinggi (kelebihan beban di render); </li><li>  terlalu banyak beban CPU saat membangun kembali kanvas; </li><li>  terlalu banyak elemen yang berubah yang mengarah pada pembangunan kembali kanvas; </li><li>  Beban CPU terlalu besar untuk pembuatan mesh (biasanya terkait dengan teks). </li></ul><br><h3 id="anchordrawanchorotrisovka-unity-ui"><a name="draw"></a>  Rendering UI kesatuan </h3><br><p>  Elemen dasar dari antarmuka pengguna Unity adalah kanvas.  Ia bertanggung jawab untuk membuat, menyortir, dan merender elemen-elemen antarmuka anak.  Semua elemen UI harus anak-anak dari kanvas apa pun, jika tidak mereka tidak akan ditampilkan dalam permainan. <br><img src="https://habrastorage.org/webt/_o/tl/ym/_otlymxpp3b04alh9902hx3w9fu.png" alt="gambar"><br>  Rendering terjadi dari objek terjauh ke terjauh dari kamera <strong>(back-to-front)</strong> dalam <strong>antrian Transparan</strong> dengan alpha blending. </p><br><p>  Secara terpisah, harus dicatat bahwa transparansi elemen UI <strong>TIDAK</strong> mempengaruhi kinerja.  Bahkan jika elemen seluruhnya terdiri dari piksel "buram", itu masih akan dirender menggunakan alpha blending. </p><br><p>  Penting juga untuk dipahami bahwa saat merender, semua piksel dari semua elemen aktif diproses.  Itu tidak tergantung pada apakah mereka terlihat, diblokir oleh benda lain atau bahkan sepenuhnya transparan. </p><br><h3 id="anchorrebuildanchorperestroenie-interfeysa-polzovatelya"><a name="rebuild"></a>  Mendesain ulang antarmuka pengguna </h3><br><p>  Mendesain ulang antarmuka pengguna adalah proses multi-langkah, termasuk membangun jerat dari setiap elemen UI, dan mencoba untuk menambal jerat ini untuk meminimalkan jumlah <strong>panggilan draw</strong> . </p><br><p>  Pembangunan kembali berlangsung dalam empat tahap: </p><br><ol><li>  Struktur elemen dianalisis. </li><li>  Jerat semua elemen aktif, termasuk elemen dengan nol transparansi, dibangun kembali. </li><li>  Membangun kembali material untuk mesh elemen meshing. </li><li>  Semua elemen digambar sesuai urutannya. </li></ol><br><p>  Kanvas yang dibangun kembali di-cache dan digunakan kembali sampai salah satu elemen di kanvas ditandai sebagai diubah. <br>  Objek <strong>kotor</strong> ditandai yang telah diaktifkan atau dinonaktifkan;  yang telah mengubah material, posisi, skala, rotasi;  nilai teks dari komponen teks telah berubah;  penugasan kembali orang tua, dll. </p><br><p>  Dalam kasus ini, pembangunan kembali kanvas mengandung setidaknya satu elemen yang diubah.  Benar, ini hanya berlaku untuk kanvas tempat elemen berada.  Artinya, perubahan elemen dalam kanvas anak tidak memengaruhi elemen induk. </p><br><p>  Semakin banyak elemen dalam kanvas, semakin besar biaya menganalisis dan menyortir objek. </p><br><h3 id="anchorbatchanchorbatching-meshey"><a name="batch"></a>  Meshing </h3><br><p>  Menggabungkan jerat, atau batching, membantu mengurangi beban pada GPU dengan mengurangi jumlah panggilan draw.  Selama proses batching, jerat diurutkan berdasarkan kedalaman dan diperiksa untuk tumpang tindih.  Ketika melewati dari elemen yang jauh ke elemen dekat (atau dari elemen atas ke yang lebih rendah dalam hierarki), objek dengan bahan atau tekstur yang sama digabungkan menjadi satu jala di dalam kanvas yang sama.  Untuk ini, tidak boleh ada benda dengan bahan lain di antara mereka.  Selain itu, benda dengan bahan lain tidak boleh tumpang tindih dengan benda yang dipanggang secara keseluruhan.  Operasi batching adalah multi-threaded, kinerjanya sangat bervariasi tergantung pada jumlah core dalam prosesor. </p><br><p>  Teks mungkin bergetar dengan teks lain jika mereka memiliki font yang sama.  Tidak masalah jika pengaturan dan gaya font sama atau berbeda.  Jika font berbeda, maka teks tidak akan bergulir. </p><br><p>  Juga harus diingat bahwa teks dapat tumpang tindih objek dengan wadah keseluruhan, dan tumpang tindih seperti itu dapat dengan mudah dilewati. <br><img src="https://habrastorage.org/webt/hp/25/q6/hp25q6lnrkta2lfzglksyejea34.png" alt="gambar"></p><br><p>  Pertimbangkan sebuah contoh.  Ada tiga objek A, B, dan C yang diatur dalam hierarki dengan cara ini: <br><img src="https://habrastorage.org/webt/iq/s-/7e/iqs-7ev081f2-yspnchyfhu7ejy.png" alt="gambar"><br><img src="https://habrastorage.org/webt/-x/xi/4o/-xxi4olr9aexg7rk2sic-4vntrw.png" alt="gambar"><br>  Pada gambar di sebelah kiri, objek A dan C akan digabung, karena  memiliki bahan yang sama dan tidak bersinggungan dengan objek B. Pada gambar di sebelah kanan, objek A dan C tidak akan digabungkan, karena  ada persimpangan dengan objek B. </p><br><h3 id="anchorcommonanchorobschie-sovety-po-optimizacii-ui"><a name="common"></a>  Tips Optimalisasi UI Umum </h3><br><p>  Sebelum Anda memulai pengoptimalan, Anda disarankan menggunakan UI profil.  Ini akan membantu mengidentifikasi hambatan yang menyebabkan hilangnya kinerja (jika ada).  Untuk membuat profil, ada banyak alat, baik bawaan untuk Unity (Unity Profiler), dan yang pihak ketiga.  Tetapi kami tidak akan membahas masalah profil UI dalam artikel ini. </p><br><p>  Berikut adalah beberapa saran untuk mengoptimalkan UI Anda di Unity: </p><br><ol><li>  Matikan benda yang tak terlihat.  Jika sebuah elemen tumpang tindih oleh elemen buram, maka Anda harus menonaktifkan GameObject atau induk GameObject dari elemen yang tumpang tindih.  Pada saat yang sama, elemen antarmuka dengan alpha yang diatur ke 0 akan tetap digambar.  Untuk objek seperti itu, Anda harus mengaktifkan Cull Transparent Mesh di komponen Canvas Renderer atau cukup menonaktifkan objek yang tidak terlihat. <br><img src="https://habrastorage.org/webt/gq/mf/hb/gqmfhb92x6wbpjgs3imcclryb8m.png" alt="gambar"></li><li>  Nonaktifkan objek dunia yang disembunyikan oleh antarmuka buram.  Jika antarmuka tidak mencakup seluruh dunia, Anda dapat menyimpannya di Tekstur Render, dan mematikan kamera dunia. </li><li>  Minimalkan jumlah piksel untuk menggambar.  Gabungkan sebanyak mungkin gambar menjadi satu.  Sebagai contoh, masuk akal untuk membuat tombol sebagai sprite tunggal, daripada memisahkan layer dengan latar belakang, goresan, badan tombol, dll.  Ini akan mengurangi fleksibilitas bekerja dengan elemen-elemen tersebut dan dapat menyebabkan penyumbatan sumber daya, sehingga kompromi harus dicari. <br><img src="https://habrastorage.org/webt/sh/o8/q-/sho8q-hlftycczgnzevncmx1hoa.png" alt="gambar"></li><li>  Hindari elemen kosong yang hanya berfungsi untuk mengatur struktur (jangan gunakan elemen sebagai nama "folder" dalam hierarki dokumen). </li><li>  Hindari menyilangkan benda yang tidak bisa dipanggang satu sama lain.  Jika memungkinkan, yang terbaik adalah mengubah posisi dalam hierarki, ukuran wadah, atau posisi elemen yang tumpang tindih dan non-caking. </li><li>  Gunakan kanvas terpisah atau bersarang untuk elemen dinamis.  Jadi Anda meminimalkan biaya penyortiran dan membangun kembali struktur kanvas yang mengandung sejumlah besar elemen.  Kanvas bersarang lebih nyaman, karena  mewarisi pengaturan kanvas induk.  Pada saat yang sama, ketika mengubah kanvas induk, semua yang bersarang juga akan dibangun kembali.  Ini cukup jarang, tetapi itu terjadi (misalnya, ketika mengubah resolusi layar).  Perlu diingat bahwa objek dari kanvas yang berbeda atau kanvas bersarang TIDAK dipanggang untuk rendering bersama.  Dianjurkan untuk membagi kanvas sesuai dengan keteraturan memperbarui elemen.  Elemen statis perlu ditempatkan di kanvas yang terpisah, maka mereka akan digambar hanya sekali.  Jika ada elemen yang terus berubah, maka lebih baik menggabungkannya di kanvas lain, karena  mereka masih akan saling membangun kembali.  Mengubah objek juga dapat dibagi menjadi beberapa kanvas berdasarkan kecepatan refresh.  Misalnya, elemen yang diperbarui setiap bingkai ditempatkan di satu kanvas, dan elemen diperbarui lebih jarang di yang lain. </li><li>  Menonaktifkan Pixel Perfect akan secara signifikan meningkatkan produktivitas.  Ini terutama berlaku untuk objek yang terus diperbarui dengan sejumlah besar elemen (misalnya, menggulir inventaris). <br><img src="https://habrastorage.org/webt/0d/zg/xi/0dzgxi_azqoacbfsdarrgr7nejo.png" alt="gambar"><br>  Kanvas itu <br><img src="https://habrastorage.org/webt/jv/qt/31/jvqt315ookagmhaiftexsaguz0g.png" alt="gambar"><br>  Kanvas bersarang </li><li>  Jika Anda perlu menonaktifkan kanvas, jangan nonaktifkan objek yang <strong>memuatnya</strong> (melalui fungsi <strong>SetActive</strong> ).  Lain kali Anda mengaktifkan elemen kanvas ini ditandai sebagai diubah, dan semua elemen dibangun kembali.  Lebih baik mematikan komponen kanvas itu sendiri, maka seluruh struktur dan data yang dipanggang tidak akan berubah dan saat berikutnya Anda menghidupkan komponen kanvas, mereka baru saja mulai menggambar. <br><img src="https://habrastorage.org/webt/pr/qo/-s/prqo-stitn0evgzxrddr54ncqwk.png"></li><li>  Untuk kanvas dengan <strong>Ruang Layar - Kamera</strong> atau <strong>Ruang Dunia</strong> dipilih dalam parameter <strong>Mode Render</strong> , selalu instal kamera.  Jika Anda tidak menginstalnya, maka sistem antarmuka pengguna di setiap frame akan mencari melalui <strong>Object.FindObjectWithTag</strong> untuk menemukan <strong>Camera.main</strong> , dan ini akan mempengaruhi kinerja. </li><li>  Agar tidak membuat beberapa tekstur yang identik, Anda dapat membuatnya dalam nuansa abu-abu dan “mengecatnya” melalui komponen Image dengan memilih warna yang diinginkan. <br><img src="https://habrastorage.org/webt/o7/tj/jr/o7tjjrk1hyt5a1rqbukrw-upsh0.png"></li><li>  Biarkan bendera <strong>Target Raycast</strong> hanya pada item yang membutuhkan acara masukan, dan hapus sisanya.  Secara default, <strong>target Raycast</strong> diaktifkan pada banyak elemen (Gambar, Teks, dll.).  Ini menyulitkan dan memperlambat kerja komponen <strong>Raycaster</strong> , yang menangani input event di Unity UI.  Saat mengklik atau merekam, ia akan menelusuri seluruh hierarki elemen dan mencari semua komponen grafis dengan <strong>set</strong> bendera <strong>Target Raycast,</strong> lalu memeriksanya untuk kemungkinan peristiwa input dan, setelah melewati pemeriksaan dengan sukses, menambahkannya ke daftar klik.  Setelah itu, daftar hit diurutkan berdasarkan kedalaman, objek di luar layar dibuang.  Sebagai hasilnya, ia memberikan daftar hit terakhir. <br>  Di Unity UI, banyak komponen (Gambar, Teks, dll.) <strong>Memiliki</strong> bendera <strong>Target Raycast</strong> . </li></ol><br><p><img src="https://habrastorage.org/webt/vp/k8/ce/vpk8cecf2dr_svrostszl-hkeeo.png" alt="gambar"><br>  <strong>Target Raycast</strong> pada komponen gambar. </p><br><p><img src="https://habrastorage.org/webt/lx/z9/3o/lxz93oxpurdfign10vwpuf8mnv0.png" alt="gambar"><br>  <strong>TextMeshPro</strong> menyembunyikannya di tab <strong>Pengaturan Ekstra</strong> . </p><br><p><img src="https://habrastorage.org/webt/k_/63/09/k_6309bflccv61qqzc9g_rpu3u4.png" alt="gambar"><br>  Untuk <strong>TextMeshPro,</strong> Anda dapat mengatur pengaturan <strong>Target Raycast</strong> default di <strong>Pengaturan Player -&gt; TextMest Pro -&gt; Pengaturan -&gt; Aktifkan Target Raycast</strong> . </p><br><p>  Elemen diuji ketika: </p><br><ul><li>  Target Raycast diaktifkan </li><li>  elemen itu sendiri dihidupkan dan diaktifkan; </li><li>  titik penyisipan berada di persimpangan dengan RectTransform. </li></ul><br><p>  Masuk akal juga untuk menghapus bendera Target Raycast dari anak-anak jika objek root sudah memilikinya dan benar-benar tumpang tindih anak-anak dengan geometri.  Misalnya, tombol UI Unity standar. </p><br><img src="https://habrastorage.org/webt/q7/6i/cz/q76iczyqwjxw6slf9ji6bgu1vqa.png"><br><p>  Gambar sepenuhnya tumpang tindih teks dengan bentuknya, dalam hal ini, Anda dapat menghapus <strong>Target Raycast</strong> dari komponen teks. </p><br><img src="https://habrastorage.org/webt/vf/oy/la/vfoylaklhkozlwt0dzboxd8r5vy.png"><br><p>  Jika semua elemen kanvas tidak menunggu peristiwa input, maka Anda dapat menghapus komponen <strong>Graphic Raycaster</strong> dari kanvas / kanvas bersarang. </p><br><h3 id="anchortextanchorrabota-s-tekstom-i-ego-optimizaciya"><a name="text"></a>  Bekerja dengan teks dan pengoptimalannya </h3><br><p>  Teks dalam antarmuka Unity terdiri dari kisi-kisi di mana setiap simbol dibuat quad-nya sendiri.  Mesh dibangun kembali setiap kali nilai teks berubah.  Rebuild juga terjadi jika komponen teks atau induknya dimatikan dan dihidupkan lagi. </p><br><p>  Secara default, font di Unity ditambahkan sebagai dinamis.  Untuk setiap font dinamis yang digunakan dalam komponen teks di atas panggung, sebuah atlas dibuat.  Hanya karakter yang digunakan yang termasuk dalam atlas ini.  Misalnya, jika bidang teks berisi teks "Teks Baru", maka atlas yang dibuat untuknya akan berisi karakter "N", "e", "w", "T", "x" dan "t".  Untuk setiap karakter yang berbeda dalam ukuran atau gaya, representasi akan dibuat di atlas. </p><br><img src="https://habrastorage.org/webt/ze/pw/jx/zepwjxjnaa7nk2qxvenmvt3flc4.png"><br><p>  Teks di atas panggung </p><br><img src="https://habrastorage.org/webt/d0/1j/un/d01jun9sehx1lhs6wdrfwhyfn8q.png"><br><p>  Atlas font </p><br><p>  Jika selama pelaksanaan program konten dari komponen teks berubah dan ada karakter yang tidak ada di atlas, seluruh atlas akan dibangun kembali.  Jika ada ruang kosong di tekstur atlas, maka simbol yang diperlukan akan ditambahkan di sana.  Pada saat yang sama, karakter yang sedang tidak digunakan tidak akan dihapus.  Jika tidak ada cukup ruang di atlas untuk karakter baru, ukurannya akan digandakan dan diisi lagi berdasarkan karakter yang digunakan dalam komponen teks aktif. </p><br><p>  Jika jumlah karakter yang ditentukan secara ketat diatur untuk proyek, misalnya, hanya alfabet Latin, maka layak menggunakan font statis yang disimpan secara permanen dalam memori.  Jika proyek Anda memungkinkan sejumlah besar karakter, lebih baik memikirkan font dinamis. <br>  Anda juga dapat meningkatkan kinerja dengan mengganti komponen teks dengan sprite.  Misalnya, angka-angka yang muncul dalam permainan (skor) dapat dibuat menggunakan sprite dari satu atlas yang hanya berisi sekumpulan karakter yang diperlukan.  Dalam hal ini, tidak akan ada biaya untuk membangun kembali kanvas dan atlas font. </p><br><p>  Penggunaan font fallback, terdaftar di bidang <strong>Nama Font</strong> di pengaturan font, meningkatkan memori yang digunakan.  Ini terutama terlihat dalam font piktografik. </p><br><p>  Tidak disarankan untuk menggunakan <strong>Paling Cocok</strong> , karena  opsi ini menyebabkan meluapnya atlas dengan cepat dan menyebabkan restrukturisasi. <br>  <strong>Paling cocok</strong> mengabaikan pengaturan ukuran font dan mencoba menyesuaikan teks ke dalam persegi panjang garis besar komponen teks. </p><br><p>  Sekarang <strong>beberapa</strong> kata tentang <strong>TextMeshPro (TMP)</strong> , pengganti populer untuk komponen teks Unity standar.  TextMeshPro juga membangun kembali kisi-kisinya setiap kali nilai teks berubah.  Namun, teks TMP tidak menggunakan font dinamis.  Untuk itu, atlas font dibuat terlebih dahulu, yang mencakup semua karakter yang diperlukan.  Jika untuk beberapa teks di tempat kejadian tidak ada karakter dalam font yang ditetapkan untuk komponennya, maka TMP mulai mencari dalam font cadangan.  Jika tidak ada apa-apa di sana, maka TMP akan mencoba menemukan karakter ini di semua font yang diunduh. </p><br><p>  <strong>Best Fit in</strong> <strong>TMP</strong> tidak menciptakan masalah seperti komponen teks biasa, sehingga dapat digunakan. </p><br><p>  Sejumlah besar font dengan pelokalan berbeda atau font font besar dapat memakan banyak memori.  Oleh karena itu, lebih baik menggunakan preload hanya font yang diperlukan untuk pelokalan tertentu. </p><br><p>  <strong>World Space</strong> merekomendasikan penggunaan <strong>TextMeshPro</strong> sebagai ganti <strong>TextMeshProUGUI</strong> . <br>  <strong>TextMeshProUGUI</strong> digunakan dalam kanvas. </p><br><h3 id="anchoratlasanchoratlasy-spraytov"><a name="atlas"></a>  Sprite Atlases </h3><br><p>  <strong>Atlas Sprite</strong> adalah jenis sumber daya yang menggabungkan beberapa tekstur menjadi satu.  Mereka memungkinkan Anda untuk mengurangi jumlah undian ( <strong>menarik panggilan</strong> ) dan meningkatkan produktivitas. </p><br><p>  Penciptaan Atlas. <br>  Buat sebuah atlas: <strong>Aset&gt; Buat&gt; Sprite Atlas</strong> . <br>  Pilih atlas dan letakkan sprite yang diperlukan di <strong>Objects for Packing</strong> . <br><img src="https://habrastorage.org/webt/bs/dl/8n/bsdl8nc2krqqx0hj7kwdckcatzc.png" alt="gambar"><br>  Klik <strong>Pack Preview</strong> untuk mempratinjau atlas. <br><img src="https://habrastorage.org/webt/z2/ct/l1/z2ctl1uykvlwq_xelfoc3gezmdc.png" alt="gambar"><br>  Ingatlah bahwa meskipun satu atau lebih sprite dari atlas digunakan di tempat kejadian, atlas akan tetap dimuat secara keseluruhan.  Oleh karena itu, tidak masuk akal untuk mencoba menanamkan semua gambar dalam satu atlas raksasa, yang pada perangkat dengan RAM kecil dapat mengambil bagian yang nyata.  Lebih baik membobol beberapa atlas yang lebih kecil, misalnya atlas antarmuka pengguna menu game dan atlas antarmuka mode permainan. </p><br><p>  Hindari ruang kosong besar di atlas, agar tidak menempati ruang memori berlebih.  Untuk melakukan ini, Anda dapat mengubah ukuran atlas atau menambahkan gambar tambahan untuk mengisi ruang kosong sebanyak mungkin. <br><img src="https://habrastorage.org/webt/vc/4n/f5/vc4nf5zljiikgjg83qau04b022q.png" alt="gambar"><br><img src="https://habrastorage.org/webt/r7/k2/w0/r7k2w0csvrfxsevgjw2nop0_zb8.png" alt="gambar"><br>  Untuk gambar yang tidak ada di atlas, Anda harus memilih pengaturan yang benar. <br>  Untuk setiap format kompresi, ada persyaratan yang akan digunakan secara efisien.  Persyaratan gambar yang paling umum: </p><br><ul><li>  lebar dan tinggi harus merupakan kelipatan dari kekuatan dua; </li><li>  lebar dan tinggi harus kelipatan 4; </li><li>  kedua paragraf sebelumnya bersama-sama. <br>  Jika tidak, tekstur tidak akan dikompresi dan biaya memori perangkat tambahan akan terjadi. </li></ul><br><p>  Saat memilih format kompresi, Unity akan memberi tahu Anda jika ada persyaratan untuk format yang dipilih tidak terpenuhi. <br><img src="https://habrastorage.org/webt/_s/tq/0c/_stq0cqnfhbnoczd2yrqm0d1iic.png" alt="gambar"></p><br><p>  Juga jangan lupa bahwa formatnya berbeda dari perangkat target.  Untuk informasi dan rekomendasi lebih lanjut tentang format, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> : </p><br><h3 id="anchorresumeanchorrezyumiruem-sposoby-optimizacii"><a name="resume"></a>  Ringkas metode pengoptimalan </h3><br><ul><li>  Nonaktifkan objek yang tidak terlihat dan transparan </li><li>  Minimalkan jumlah item </li><li>  Hindari menyilangkan benda yang tidak bisa dipanggang satu sama lain </li><li>  Bagikan item berdasarkan kanvas berdasarkan kecepatan refresh </li><li>  Untuk kanvas dengan elemen yang sering diperbarui, nonaktifkan Pixel Perfect </li><li>  Nonaktifkan Target Raycast pada item yang tidak dapat diklik </li><li>  Hapus komponen Graphic Raycaster pada kanvas yang semua elemennya tidak dapat diklik </li><li>  Untuk komponen teks biasa, jangan gunakan Paling Cocok </li><li>  Untuk TextMeshPro In World Space, gunakan TextMeshPro sebagai ganti TextMeshProUGUI.  TextMeshProUGUI digunakan di kanvas </li><li>  Atur kamera dalam pengaturan kanvas, jika perlu </li><li>  Nonaktifkan kanvas dengan menonaktifkan komponen kanvas </li><li>  Gunakan sprite grayscale dan mewarnai pengaturan komponen gambar </li><li>  Gunakan atlas sprite </li><li>  Gunakan ukuran dan format kompresi yang benar untuk tekstur yang tidak ada di atlas </li></ul><br><h3 id="anchorlinksanchoristochniki"><a name="links"></a>  Sumber: </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi Optimalisasi Unity UI Komprehensif</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber resmi lain tentang topik ini berisi informasi dalam bentuk yang lebih ringkas.</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kertas Putih Atlas</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi Tambahan tentang Format Kompresi Tekstur</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470608/">https://habr.com/ru/post/id470608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470596/index.html">Fitur Q dan KDB + pada contoh layanan real-time</a></li>
<li><a href="../id470598/index.html">Buku "Jawa Modern. Ekspresi Lambda, Streaming, dan Pemrograman Fungsional ”</a></li>
<li><a href="../id470600/index.html">Tentang konsol noVNC aman, penskalaan di Kubernetes, Haproxy di Ostrovka, dan karya admin dengan programmer</a></li>
<li><a href="../id470602/index.html">Seperti apa metro Moskow di dunia tiga dimensi</a></li>
<li><a href="../id470604/index.html">Kecepatan pemuatan situs dalam e-commerce: analisis 48 toko online top di Rusia</a></li>
<li><a href="../id470610/index.html">Suatu hari dalam kehidupan seorang pengembang</a></li>
<li><a href="../id470612/index.html">Apa yang ditunjukkan voltmeter, atau soket matematika</a></li>
<li><a href="../id470614/index.html">Bagaimana grafik NES diatur?</a></li>
<li><a href="../id470616/index.html">Solusi baru untuk paradoks Fermi (mengapa kita sendirian di alam semesta)</a></li>
<li><a href="../id470618/index.html">Pemodelan tematik berita menggunakan analisis faktor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>