<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß¶ üßòüèº ‚ôêÔ∏è Berpikir dengan Portal: membuat portal di Unreal Engine 4 üëéüèº ü§òüèæ ü§Ω</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini saya akan memberi tahu Anda cara membuat portal di Unreal Engine 4. Saya tidak menemukan sumber yang menjelaskan sistem seperti itu s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berpikir dengan Portal: membuat portal di Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448802/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif" alt="gambar"></div><br>  Pada artikel ini saya akan memberi tahu Anda cara membuat portal di Unreal Engine 4. Saya tidak menemukan sumber yang menjelaskan sistem seperti itu secara terperinci (memantau melalui portal dan melewati mereka), jadi saya memutuskan untuk menulis sendiri. <br><br><h2>  Apa itu portal? </h2><br>  Mari kita mulai dengan contoh dan penjelasan tentang apa itu portal.  Cara termudah untuk menggambarkan portal sebagai cara perjalanan dari satu ruang ke ruang lainnya.  Dalam beberapa permainan populer, konsep ini digunakan untuk efek visual dan bahkan untuk mekanisme permainan: <br><br><div class="spoiler">  <b class="spoiler_title">Contoh Portal Game (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/020/f86/611020f86b634e1946a79f86ee8c4024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/7b9/813/77d7b9813811fc5b1748d8d29c7599ad.gif"></div><br>  <i>Antichamber (2013) dan Portal (2007)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/671/ad1/527671ad1b23838f56c324d350bf2e1e.gif"></div><br>  <i>Prey, 2006</i> </div></div><br>  Dari tiga game, yang paling terkenal mungkin Portal, tapi saya pribadi selalu mengagumi Prey dan dialah yang ingin saya salin.  Pernah saya mencoba mengimplementasikan versi saya sendiri di Unreal Engine 4, tetapi saya tidak benar-benar berhasil, karena mesinnya tidak memiliki fungsionalitas.  Meskipun demikian, saya berhasil melakukan eksperimen ini: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Browser Anda tidak mendukung video HTML5. <source src="http://froyok.fr/vine_archive/videos/1318354931002269696.mp4" type="video/mp4"></video></div></div></div><br>  Namun, hanya dalam versi baru dari Unreal Engine akhirnya saya berhasil mencapai efek yang diinginkan: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5lga4ppJiuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Portal - bagaimana cara kerjanya? </h2><br>  Sebelum melanjutkan dengan spesifik, mari kita lihat gambaran umum tentang cara kerja portal. <br><br>  Sebenarnya, portal adalah jendela yang tidak keluar, tetapi ke tempat lain, yaitu, kami secara lokal menetapkan sudut pandang spesifik relatif terhadap objek dan mereplikasi sudut pandang ini di tempat lain.  Dengan menggunakan prinsip ini, kita dapat menghubungkan dua ruang, meskipun jaraknya sangat jauh.  Jendela menyerupai topeng yang memungkinkan kita untuk mengetahui di mana dan kapan menampilkan ruang lain, bukan yang asli.  Karena titik awal pandangan direplikasi di tempat lain, ini memberi kita ilusi kesinambungan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/d56/84b/6b3d5684bf30d66c8b60d551049f7a9b.png"></div><br>  Dalam gambar ini, perangkat tangkap (SceneCapture di UE4) terletak di depan ruang yang sesuai dengan ruang yang dilihat dari sudut pandang pemain.  Segala sesuatu yang terlihat setelah garis digantikan oleh apa yang dapat dilihat oleh tangkapan.  Karena perangkat penangkap dapat ditempatkan di antara pintu dan benda-benda lain, penting untuk menggunakan apa yang disebut "pesawat kliping".  Dalam kasus portal, kami ingin pesawat kliping dekat untuk menutupi objek yang terlihat di depan portal. <br><br>  Untuk meringkas.  Kami membutuhkan: <br><br><ul><li>  Lokasi Pemain </li><li>  Titik Masuk Portal </li><li>  Titik Keluar Portal </li><li>  Perangkat kliping dengan pesawat kliping </li></ul><br>  Bagaimana cara menerapkan ini di Unreal Engine? <br><br>  Saya membangun sistem saya berdasarkan dua kelas utama yang dikelola oleh <b>PlayerController</b> dan <b>Character</b> .  Kelas <b>Portal</b> adalah titik masuk portal sejati, yang titik pandang / keluarnya adalah aktor Target.  Ada juga <b>Manajer Portal</b> , yang dihasilkan oleh PlayerController dan diperbarui oleh Karakter untuk mengelola setiap portal di tingkat dan memperbaruinya, serta untuk memanipulasi objek SceneCapture (yang umum untuk semua portal). <br><br><blockquote>  Ingatlah bahwa tutorial ini mengharapkan Anda memiliki akses ke kelas Character dan PlayerController dari kode.  Dalam kasus saya, mereka disebut ExedreCharacter dan ExedrePlayerController. </blockquote><br><h2>  Membuat Kelas Aktor Portal </h2><br>  Mari kita mulai dengan aktor portal, yang akan digunakan untuk mengatur "windows" di mana kita akan melihat levelnya.  Tugas aktor adalah memberikan informasi tentang pemain untuk menghitung berbagai posisi dan belokan.  Dia juga akan terlibat dalam mengenali apakah pemain melintasi portal, dan teleportasinya. <br><br>  Sebelum memulai diskusi rinci tentang aktor, izinkan saya menjelaskan beberapa konsep yang saya buat untuk mengelola sistem portal: <br><br><ul><li>  Untuk penolakan perhitungan yang nyaman, portal memiliki status aktif-tidak aktif.  Keadaan ini diperbarui oleh Portal Manager. </li><li>  Portal memiliki sisi depan dan belakang yang ditentukan oleh posisi dan arahnya (vektor ke depan). </li><li>  Untuk mengetahui apakah pemain melewati portal, ia menyimpan posisi pemain sebelumnya dan membandingkannya dengan yang sekarang.  Jika pada ukuran sebelumnya pemain berada di depan portal, dan pada saat ini - di belakangnya, maka kami percaya bahwa pemain melewatinya.  Perilaku sebaliknya diabaikan. </li><li>  Portal memiliki volume terbatas, sehingga tidak melakukan perhitungan dan memeriksa sampai pemain ada di volume ini.  Contoh: Abaikan persimpangan jika pemain tidak benar-benar menyentuh portal. </li><li>  Lokasi pemain dihitung dari lokasi kamera untuk memastikan perilaku yang benar ketika sudut pandang melintasi portal tetapi bukan tubuh pemain. </li><li>  Portal menerima Target Render, yang menampilkan sudut pandang yang berbeda dalam setiap ukuran jika tekstur waktu berikutnya salah dan perlu diganti. </li><li>  Portal menyimpan tautan ke aktor lain yang disebut Target, untuk mengetahui di mana ruang lain yang harus dihubungi. </li></ul><br>  Menggunakan aturan-aturan ini, saya membuat kelas ExedrePortal baru yang diwarisi dari AActor sebagai titik awal.  Inilah judulnya: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortal.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API AExedrePortal : public AActor { GENERATED_UCLASS_BODY() protected: virtual void BeginPlay() override; public: virtual void Tick(float DeltaTime) override; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Status of the Portal (being visualized by the player or not) UFUNCTION(BlueprintPure, Category="Exedre|Portal") bool IsActive(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetActive( bool NewActive ); //Render target to use to display the portal UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void ClearRTT(); UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void SetRTT( UTexture* RenderTexture ); UFUNCTION(BlueprintNativeEvent, Category="Exedre|Portal") void ForceTick(); //Target of where the portal is looking UFUNCTION(BlueprintPure, Category="Exedre|Portal") AActor* GetTarget(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetTarget( AActor* NewTarget ); //Helpers UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void TeleportActor( AActor* ActorToTeleport ); protected: UPROPERTY(BlueprintReadOnly) USceneComponent* PortalRootComponent; private: bool bIsActive; AActor* Target; //Used for Tracking movement of a point FVector LastPosition; bool LastInFront; };</span></span></span></span></code> </pre> <br>  Seperti yang Anda lihat, ada sebagian besar perilaku yang dijelaskan di sini.  Sekarang mari kita lihat bagaimana mereka diproses di dalam tubuh (.cpp). <br><br><hr><br>  Perancang di sini sedang mempersiapkan komponen root.  Saya memutuskan untuk membuat dua komponen root, karena aktor portal akan menggabungkan efek grafis dan tabrakan / pengenalan.  Jadi saya membutuhkan cara sederhana untuk menentukan di mana jendela / portal pesawat, tanpa perlu fitur bluetooth atau trik lainnya.  PortalRootComponent akan menjadi dasar untuk semua perhitungan yang terkait dengan portal. <br><br>  Root portal diatur ke dinamis, seandainya kelas Blueprint menghidupkannya (misalnya, menggunakan animasi buka / tutup). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Sets default values AExedrePortal::AExedrePortal(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = true; bIsActive = false; RootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("RootComponent")); RootComponent-&gt;Mobility = EComponentMobility::Static; PortalRootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("PortalRootComponent")); PortalRootComponent-&gt;SetupAttachment( GetRootComponent() ); PortalRootComponent-&gt;SetRelativeLocation( FVector(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;SetRelativeRotation( FRotator(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;Mobility = EComponentMobility::Movable; }</span></span></code> </pre> <br><hr><br>  Hanya ada fungsi Get and Set, dan tidak lebih.  Kami akan mengelola keadaan aktivitas dari tempat lain. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsActive() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bIsActive; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetActive( <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> NewActive ) { bIsActive = NewActive; }</code> </pre> <br><hr><br>  Acara cetak biru, saya tidak melakukan apa pun di kelas C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ClearRTT_Implementation() { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetRTT_Implementation( UTexture* RenderTexture ) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ForceTick_Implementation() { }</code> </pre> <br><hr><br>  Fungsi Dapatkan dan Tetapkan untuk aktor Target.  Tidak ada yang lebih rumit di bagian ini juga. <br><br><pre> <code class="cpp hljs">AActor* AExedrePortal::GetTarget() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Target; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetTarget( AActor* NewTarget ) { Target = NewTarget; }</code> </pre> <br><hr><br>  Dengan fungsi ini, kita dapat dengan mudah memeriksa apakah suatu titik ada di depan sebuah pesawat, dan dalam kasus kita itu adalah sebuah portal.  Fungsi ini menggunakan struktur FPlane dari mesin UE4 untuk melakukan perhitungan. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-comment"><span class="hljs-comment">//If &lt; 0 means we are behind the Plane //See : http://api.unrealengine.com/INT/API/Runtime/Core/Math/FPlane/PlaneDot/index.html return ( PortalDot &gt;= 0 ); }</span></span></code> </pre> <br><hr><br>  Fungsi ini memeriksa untuk melihat apakah titik telah melewati bidang portal.  Di sinilah kita menggunakan posisi lama untuk mengetahui bagaimana perilaku titik tersebut.  Fungsi ini umum sehingga dapat bekerja dengan aktor apa pun, tetapi dalam kasus saya hanya digunakan dengan pemain. <br><br>  Fungsi menciptakan arah / segmen antara lokasi sebelumnya dan saat ini, dan kemudian memeriksa apakah mereka memotong bidang.  Jika demikian, maka kami memeriksa apakah melintasi ke arah yang benar (depan ke belakang?). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FVector IntersectionPoint; FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCrossing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInFront = PortalDot &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsIntersect = FMath::SegmentPlaneIntersection( LastPosition, Point, PortalPlane, IntersectionPoint ); <span class="hljs-comment"><span class="hljs-comment">//Did we intersect the portal since last Location ? //If yes, check the direction : crossing forward means we were in front and now at the back //If we crossed backward, ignore it (similar to Prey 2006) if( IsIntersect &amp;&amp; !IsInFront &amp;&amp; LastInFront ) { IsCrossing = true; } //Store values for Next check LastInFront = IsInFront; LastPosition = Point; return IsCrossing; }</span></span></code> </pre> <br><h2>  Aktor Teleport </h2><br>  Bagian terakhir dari aktor portal yang akan kita lihat adalah fungsi <b>TeleportActor ()</b> . <br><br>  Saat memindahkan aktor dari titik A ke titik B, Anda perlu meniru gerakan dan posisinya.  Misalnya, jika seorang pemain masuk ke portal, maka dalam kombinasi dengan efek visual yang cocok, akan tampak baginya bahwa ia melewati pintu biasa. <br><br>  Persimpangan portal terasa seperti bergerak dalam garis lurus, tetapi dalam kenyataannya sesuatu yang sama sekali berbeda terjadi.  Setelah keluar dari portal, pemain mungkin berada dalam konteks yang sangat berbeda.  Pertimbangkan sebuah contoh dari Portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/185/809/d4f/185809d4fd81675cdd6f1cc871eaf193.gif"></div><br>  Seperti yang Anda lihat, ketika melintasi portal, kamera berputar relatif terhadap vektor maju (rotate).  Ini karena titik awal dan akhir sejajar dengan bidang yang berbeda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/072/97f/b30/07297fb30171a80c1cc0d831701feb74.jpg"></div><br>  Oleh karena itu, agar ini berfungsi, kita perlu mengubah gerakan pemain menjadi ruang relatif portal untuk mengubahnya menjadi ruang Target.  Dengan menerapkan ini, kita dapat yakin bahwa setelah memasuki portal dan keluar dari sisi lain, pemain akan disejajarkan dengan benar sehubungan dengan ruang.  Ini berlaku tidak hanya pada posisi dan rotasi aktor, tetapi juga pada <b>kecepatannya</b> . <br><br><blockquote>  Jika kita teleport aktor tanpa perubahan, mengubahnya menjadi rotasi lokal, maka sebagai hasilnya, aktor dapat menemukan dirinya terbalik.  Ini mungkin cocok untuk objek, tetapi tidak berlaku untuk karakter atau pemain itu sendiri.  Anda perlu mengubah posisi aktor, seperti yang ditunjukkan di atas dalam contoh dari Portal. </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::TeleportActor( AActor* ActorToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ActorToTeleport == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//------------------------------- //Retrieve and save Player Velocity //(from the Movement Component) //------------------------------- FVector SavedVelocity = FVector::ZeroVector; AExedreCharacter* EC = nullptr; if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { EC = Cast&lt;AExedreCharacter&gt;( ActorToTeleport ); SavedVelocity = EC-&gt;GetCharMovementComponent()-&gt;GetCurrentVelocity(); } //------------------------------- //Compute and apply new location //------------------------------- FHitResult HitResult; FVector NewLocation = UTool::ConvertLocationToActorSpace( ActorToTeleport-&gt;GetActorLocation(), this, Target ); ActorToTeleport-&gt;SetActorLocation( NewLocation, false, &amp;HitResult, ETeleportType::TeleportPhysics ); //------------------------------- //Compute and apply new rotation //------------------------------- FRotator NewRotation = UTool::ConvertRotationToActorSpace( ActorToTeleport-&gt;GetActorRotation(), this, Target ); //Apply new rotation ActorToTeleport-&gt;SetActorRotation( NewRotation ); //------------------------------- //If we are teleporting a character we need to //update its controller as well and reapply its velocity //------------------------------- if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { //Update Controller AExedrePlayerController* EPC = EC-&gt;GetPlayerController(); if( EPC != nullptr ) { NewRotation = UTool::ConvertRotationToActorSpace( EPC-&gt;GetControlRotation(), this, Target ); EPC-&gt;SetControlRotation( NewRotation ); } //Reapply Velocity (Need to reorient direction into local space of Portal) { FVector Dots; Dots.X = FVector::DotProduct( SavedVelocity, GetActorForwardVector() ); Dots.Y = FVector::DotProduct( SavedVelocity, GetActorRightVector() ); Dots.Z = FVector::DotProduct( SavedVelocity, GetActorUpVector() ); FVector NewVelocity = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); EC-&gt;GetCharMovementComponent()-&gt;Velocity = NewVelocity; } } //Cleanup Teleport LastPosition = NewLocation; }</span></span></code> </pre> <br><hr><br>  Seperti yang mungkin Anda perhatikan, untuk memanggil rotasi / posisi, saya memanggil fungsi eksternal.  Mereka dipanggil dari kelas pengguna UTool, yang mendefinisikan fungsi statis yang dapat dipanggil dari mana saja (termasuk cetak biru).  Kode mereka ditunjukkan di bawah ini, Anda dapat mengimplementasikannya dengan cara yang menurut Anda paling baik (mungkin lebih mudah untuk menempatkan mereka di kelas aktor Portal). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertLocationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Location, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FVector::ZeroVector; } FVector Direction = Location - Reference-&gt;GetActorLocation(); FVector TargetLocation = Target-&gt;GetActorLocation(); FVector Dots; Dots.X = FVector::DotProduct( Direction, Reference-&gt;GetActorForwardVector() ); Dots.Y = FVector::DotProduct( Direction, Reference-&gt;GetActorRightVector() ); Dots.Z = FVector::DotProduct( Direction, Reference-&gt;GetActorUpVector() ); FVector NewDirection = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TargetLocation + NewDirection; }</code> </pre> <br>  Transformasi di sini dilakukan dengan menghitung produk skalar vektor untuk menentukan sudut yang berbeda.  Vektor Direction tidak dinormalisasi, yaitu, kita dapat kembali mengalikan hasil Dots dengan vektor Target untuk mendapatkan posisi pada jarak yang persis sama di ruang lokal aktor Target. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FRotator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertRotationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FRotator Rotation, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FRotator::ZeroRotator; } FTransform SourceTransform = Reference-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat QuatRotation = FQuat( Rotation ); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * QuatRotation; FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewWorldQuat.Rotator(); }</code> </pre> <br>  Mengubah transformasi agak sulit untuk diimplementasikan.  Pada akhirnya, solusi terbaik ternyata adalah penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">angka empat</a> , karena ini jauh lebih akurat daripada bekerja dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">sudut Euler</a> normal dan hanya memerlukan beberapa baris kode.  Rotasi dengan angka empat dilakukan menggunakan perkalian, jadi dalam kasus kami, menerapkan Inverse () ke rotasi yang ingin dikonversi, kami akan memindahkannya ke ruang lokal.  Selanjutnya, kita hanya perlu melipatgandakannya lagi dengan belokan Target untuk mendapatkan belokan terakhir. <br><br><h2>  Membuat Portal Mesh </h2><br>  Untuk terlihat cantik dari sudut pandang pemain, sistem portal saya menggunakan jaring khusus.  Mesh dibagi menjadi dua bidang yang berbeda: <br><br><ul><li>  <b>Pesawat 1</b> : Pesawat utama tempat target render ditampilkan.  Pesawat ini memiliki perilaku yang agak tidak biasa, karena tugasnya adalah untuk sedikit menjauh dari pemain saat ia mendekati untuk menghindari kliping oleh kamera.  Karena batas-batas pesawat tidak bergerak, tetapi hanya bagian tengahnya yang bergerak, ini memungkinkan pemain untuk melakukan penumpukan pada rendering portal tanpa artefak visual.  Tepi di tepi memiliki UV sendiri di bagian atas, sedangkan tepi bagian dalam memiliki UV sendiri di bagian bawah, yang membuatnya mudah untuk menutupi mereka di shader. </li><li>  <b>Pesawat 2</b> : Pesawat ini hanya digunakan untuk memperpanjang kotak pembatas standar mesh.  Normal dari simpul diarahkan ke bawah, sehingga bahkan pada tanah non-planar mesh tidak akan terlihat secara default (karena materi rendering tidak akan dua sisi). </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72e/125/f6f/72e125f6fd315caa2777f65dc0eaf39a.gif"></div><br>  Mengapa menggunakan jaring seperti ini? <br><br>  Saya memutuskan bahwa "pesawat 1" akan meregang ketika pemain mendekat.  Ini memungkinkan pemain untuk tumpang tindih portal dan melewatinya tanpa memotong (memotong).  Ini bisa terjadi, misalnya, jika kamera belum melewati bidang portal, tetapi kaki pemain sudah menyentuhnya.  Ini memungkinkan Anda untuk tidak memotong pemain dan menggandakan jala di sisi lain. <br><br>  Tugas "pesawat 2" adalah untuk memperpanjang kotak pembatas standar mesh.  Karena "bidang 1" datar, kotak pembatas pada satu sumbu memiliki ketebalan 0, dan jika kamera berada di belakangnya, mesin akan memotongnya (artinya, ia tidak akan membuatnya).  Plane 1 memiliki ukuran 128 √ó 128, sehingga dapat dengan mudah diskalakan menggunakan mesin.  Pesawat 2 sedikit lebih besar dan di bawah lantai (di bawah 0). <br><br>  Setelah membuat mesh, kami cukup mengekspornya dari editor 3D pihak ketiga dan mengimpor ke Unreal.  Ini akan digunakan pada langkah selanjutnya. <br><br><h2>  Membuat Materi Portal </h2><br>  Untuk menampilkan sisi lain portal, kita perlu membuat materi kita sendiri.  Buat materi baru di browser konten (Saya menyebutnya <b>MAT_PortalBase</b> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b0/402/a9c/7b0402a9cd6c6d62438e06fa3a7cd1f4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/96c/a1b/dea96ca1b613a92acc7ca35e0bbe44b1.png"></div><br>  Sekarang buka dan buat grafik berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfe/4fa/c17/cfe4fac175e5e399c9e615a6afd0b800.jpg"></div><br>  Begini cara kerjanya: <br><br><ul><li>  <b>FadeColor</b> adalah warna yang akan terlihat melalui portal saat itu sangat jauh.  Ini diperlukan karena kami tidak selalu me-render semua portal, jadi kami mengaburkan rendering ketika pemain / kamera berada jauh. </li><li>  Untuk mengetahui seberapa jauh pemain dari portal, saya menentukan <b>jarak</b> antara Posisi Kamera dan Posisi Aktor.  Lalu saya membagi jarak dengan nilai maksimum yang ingin saya lakukan perbandingan.  Misalnya, jika maksimum yang saya tetapkan adalah 2000, dan jarak ke pemain adalah 1000, maka kita mendapatkan 0,5.  Jika pemain lebih jauh, maka saya akan mendapatkan nilai lebih dari 1, jadi saya menggunakan titik saturasi untuk membatasinya.  Selanjutnya muncul simpul Smoothstep, yang digunakan untuk skala jarak sebagai gradien dan lebih akurat mengontrol naungan portal.  Sebagai contoh, saya ingin ketika pemain dekat, bayangan sepenuhnya hilang. </li><li>  Saya menggunakan perhitungan jarak sebagai nilai saluran alpha untuk simpul <b>Lerp</b> untuk mencampur warna shading dan <b>tekstur</b> yang akan membuat target portal. </li><li>  Akhirnya, saya mengisolasi komponen Y dari koordinat UV untuk membuat topeng yang memungkinkan Anda tahu simpul mana dari mesh akan didorong.  Saya kalikan topeng ini dengan jumlah tolakan yang saya butuhkan.  Saya menggunakan nilai negatif sehingga ketika normals dari simpul dikalikan dengan simpul, mereka bergerak ke arah yang berlawanan. </li></ul><br>  Setelah melakukan semua ini, kami membuat materi yang siap pakai. <br><br><h2>  Membuat Aktor Portal di Cetak Biru </h2><br>  Mari kita buat kelas cetak biru baru yang diwarisi dari aktor Portal.  Klik kanan pada browser konten dan pilih kelas Blueprint: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/28b/5a2/ead28b5a23369c2c86a076ec8bb1dda0.png"></div><br>  Sekarang masukkan "portal" di bidang pencarian untuk memilih kelas portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/da4/555/bd7da4555cff2dc953ab3b0b0f4d1057.png"></div><br>  Buka bluetooth jika belum terbuka.  Dalam daftar komponen Anda akan melihat hierarki berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/34c/308/73c34c308a70f644759dc9057b0facd2.png"></div><br>  Seperti yang kami harapkan, ada komponen root dan root portal.  Mari kita tambahkan komponen jala statis ke PortalRootComponent dan muat jala yang dibuat pada langkah sebelumnya ke dalamnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/ef3/11d/fa4ef311d11c803afc565060a9902c24.jpg"></div><br><hr><br>  Kami juga menambahkan Kotak Tabrakan, yang akan digunakan untuk menentukan apakah pemain ada di dalam volume portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b0/28f/df6/0b028fdf696598f6b3eca9af3049caa1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2a/85d/747/c2a85d747c8b76900cae32e9f9cc1a59.png"></div><br>  Kotak Tabrakan terletak di bawah komponen adegan yang terkait dengan root utama, dan bukan di bawah root Portal.  Saya juga menambahkan ikon (papan iklan) dan komponen panah untuk membuat portal lebih terlihat di tingkat.  Tentu saja ini tidak perlu. <br><br>  Sekarang mari kita mengatur materi dalam cetak biru. <br><br>  Untuk memulainya, kita membutuhkan dua variabel - satu akan bertipe <b>Aktor</b> dan nama adalah <b>PortalTarget</b> , yang kedua adalah tipe <b>Dynamic Material Instance</b> dan disebut <b>MaterialInstance</b> .  PortalTarget akan menjadi referensi ke posisi yang dilihat oleh jendela portal (oleh karena itu, variabelnya umum, dengan ikon mata terbuka) sehingga kita bisa mengubahnya ketika aktor ditempatkan di level.  MaterialInstance akan menyimpan tautan ke materi dinamis sehingga di masa mendatang kami dapat menetapkan target render portal dengan cepat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/0b9/772/4740b9772dfc7ce30cda63300f1682a5.png"></div><br>  Kita juga perlu menambahkan node acara kita sendiri.  Cara terbaik untuk membuka menu klik kanan di <b>Grafik Acara</b> dan menemukan nama-nama acara: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/719/d22/bc2719d224381581c9bdb8ea5ce7c365.png"></div><br>  Dan di sini untuk membuat diagram berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f4/400/24f/0f440024f5c322c6640609bb8d20bcad.jpg"></div><br><ul><li>  <b>Mulai Mainkan</b> : di sini kita memanggil fungsi induk SetTarget () dari portal untuk memberikannya tautan ke aktor, yang nantinya akan digunakan untuk SceneCapture.  Kemudian kami membuat Bahan Dinamis baru dan menetapkan nilai variabel MaterialInstance.  Dengan materi baru ini, kita dapat menugaskannya ke Komponen Jala Statis.  Saya juga memberi bahan tekstur tiruan, tapi ini opsional. </li><li>  <b>Clear RTT</b> : Tujuan dari fitur ini adalah untuk menghapus tekstur Target Render yang ditetapkan untuk materi portal.  Ini diluncurkan oleh manajer Portal. </li><li>  <b>Atur RTT</b> : tujuan fungsi ini adalah untuk mengatur bahan target render portal.  Ini diluncurkan oleh manajer Portal. </li></ul><br>  Sejauh ini kita sudah selesai dengan bluetooth, tetapi kita akan kembali lagi nanti untuk mengimplementasikan fungsi Tick. <br><br><h2>  Manajer portal </h2><br>  Jadi, sekarang kita memiliki semua elemen dasar yang diperlukan untuk membuat kelas baru yang diwarisi dari AActor, yang akan menjadi Portal Manager.  Anda mungkin tidak memerlukan kelas Portal Manajer di proyek Anda, tetapi dalam kasus saya, ini sangat menyederhanakan bekerja dengan beberapa aspek.  Berikut adalah daftar tugas yang dilakukan oleh manajer Portal: <br><br><ul><li>  Manajer Portal adalah aktor yang <b>dibuat oleh Kontroler Player</b> dan dilampirkan padanya untuk melacak keadaan dan evolusi pemain dalam level game. </li><li>  Buat dan hancurkan <b>render target portal</b> .  Idenya adalah untuk secara dinamis membuat tekstur target render yang cocok dengan resolusi layar pemain.  Selain itu, ketika mengubah resolusi selama permainan, manajer akan secara otomatis mengonversinya ke ukuran yang diinginkan. </li><li>  Manajer Portal <b>menemukan dan memperbarui</b> tingkat aktor Portal untuk memberi mereka target render.  Tugas ini dilakukan sedemikian rupa untuk memastikan kompatibilitas dengan streaming level.  Ketika aktor baru muncul, ia harus mendapatkan tekstur.  Selain itu, jika target Render berubah, manajer juga dapat menetapkan yang baru secara otomatis.  Ini membuatnya lebih mudah untuk mengelola sistem, daripada meminta setiap aktor Portal menghubungi manajer secara manual. </li><li>  Komponen <b>SceneCapture</b> dilampirkan ke manajer Portal, agar tidak membuat satu salinan untuk setiap portal.  Selain itu, ini memungkinkan Anda untuk menggunakannya kembali setiap kali kami beralih ke aktor portal tertentu di tingkat tersebut. </li><li>  Ketika portal memutuskan untuk <b>memindahkan</b> pemain, ia mengirim permintaan ke Portal Manager.  Ini diperlukan untuk memperbarui portal sumber dan tujuan (jika ada), sehingga transisi terjadi tanpa sambungan. </li><li>  Manajer Portal <b>diperbarui</b> pada akhir fungsi <b>Character tick ()</b> sehingga semuanya diperbarui dengan benar, termasuk kamera pemain.  Ini memastikan bahwa segala sesuatu di layar disinkronkan dan menghindari penundaan satu frame selama rendering oleh mesin. </li></ul><br>  Mari kita lihat header Portal Manager: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortalManager.generated.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Forward declaration class AExedrePlayerController; class AExedrePortal; class UExedreScriptedTexture; UCLASS() class EXEDRE_API AExedrePortalManager : public AActor { GENERATED_UCLASS_BODY() public: AExedrePortalManager(); //Called by a Portal actor when wanting to teleport something UFUNCTION(BlueprintCallable, Category="Portal") void RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ); //Save a reference to the PlayerControler void SetControllerOwner( AExedrePlayerController* NewOwner ); //Various setup that happens during spawn void Init(); //Manual Tick void Update( float DeltaTime ); //Find all the portals in world and update them //returns the most valid/usable one for the Player AExedrePortal* UpdatePortalsInWorld(); //Update SceneCapture void UpdateCapture( AExedrePortal* Portal ); //Accessor for Debug purpose UTexture* GetPortalTexture(); //Accessor for Debug purpose FTransform GetCameraTransform(); private: //Function to create the Portal render target void GeneratePortalTexture(); UPROPERTY() USceneCaptureComponent2D* SceneCapture; //Custom class, can be replaced by a "UCanvasRenderTarget2D" instead //See : https://api.unrealengine.com/INT/API/Runtime/Engine/Engine/UCanvasRenderTarget2D/index.html UPROPERTY() UExedreScriptedTexture* PortalTexture; UPROPERTY() AExedrePlayerController* ControllerOwner; int32 PreviousScreenSizeX; int32 PreviousScreenSizeY; float UpdateDelay; };</span></span></span></span></code> </pre> <br><hr><br>  Sebelum masuk ke detail, saya akan menunjukkan bagaimana seorang aktor dibuat dari kelas Player Controller, dipanggil dari fungsi BeginPlay (): <br><br><pre> <code class="cpp hljs"> FActorSpawnParameters SpawnParams; PortalManager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PortalManager = GetWorld()-&gt;SpawnActor&lt;AExedrePortalManager&gt;( AExedrePortalManager::StaticClass(), FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams); PortalManager-&gt;AttachToActor( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, FAttachmentTransformRules::SnapToTargetIncludingScale); PortalManager-&gt;SetControllerOwner( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); PortalManager-&gt;Init();</code> </pre> <br>  Jadi, kami membuat aktor, melampirkannya ke controller pemain (ini), dan kemudian menyimpan tautan dan memanggil fungsi Init (). <br><br>  Penting juga untuk dicatat bahwa kami memperbarui aktor secara manual dari kelas Karakter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedreCharacter::TickActor( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime, <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELevelTick TickType, FActorTickFunction&amp; ThisTickFunction ) { Super::TickActor( DeltaTime, TickType, ThisTickFunction ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) ); EPC-&gt;PortalManager-&gt;Update( DeltaTime ); } }</code> </pre> <br>  Dan inilah konstruktor dari Portal Manager.  Perhatikan bahwa Centang dinonaktifkan, lagi karena kami akan memperbarui Portal Manager secara manual melalui pemain. <br><br><pre> <code class="cpp hljs">AExedrePortalManager::AExedrePortalManager(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; PortalTexture = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; UpdateDelay = <span class="hljs-number"><span class="hljs-number">1.1f</span></span>; PreviousScreenSizeX = <span class="hljs-number"><span class="hljs-number">0</span></span>; PreviousScreenSizeY = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><hr><br>  Berikut adalah fungsi get / set Portal Manager (setelah itu kami akan beralih ke hal-hal yang lebih menarik): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::SetControllerOwner( AExedrePlayerController* NewOwner ) { ControllerOwner = NewOwner; } FTransform AExedrePortalManager::GetCameraTransform() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SceneCapture != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SceneCapture-&gt;GetComponentTransform(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FTransform(); } } UTexture* AExedrePortalManager::GetPortalTexture() { <span class="hljs-comment"><span class="hljs-comment">//Portal Texture is a custom component class that embed a UCanvasRenderTraget2D //The GetTexture() simply returns the RenderTarget contained in that class. //IsValidLowLevel() is used here as a way to ensure the Texture has not been destroyed or garbage collected. if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { return PortalTexture-&gt;GetTexture(); } else { return nullptr; } }</span></span></code> </pre> <br><hr><br>  Jelas, hal pertama yang harus dimulai adalah fungsi <b>Init ()</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tujuan utama dari fungsi ini adalah untuk membuat komponen SceneCapture (yaitu, perangkat penangkapan yang disebutkan di atas) dan mengkonfigurasinya dengan benar. </font><font style="vertical-align: inherit;">Itu dimulai dengan penciptaan objek baru dan pendaftarannya sebagai komponen aktor ini. </font><font style="vertical-align: inherit;">Kemudian kami beralih ke pengaturan properti yang terkait dengan tangkapan ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properti menyebutkan:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bCaptureEveryFrame = false</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : kami tidak ingin tangkapan diaktifkan ketika kami tidak membutuhkannya. </font><font style="vertical-align: inherit;">Kami akan mengelolanya secara manual.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bEnableClipPlane = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Properti yang cukup penting untuk rendering portal capture dengan benar.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bUseCustomProjectionMatrix = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ini memungkinkan kita untuk mengganti proyeksi Capture dengan proyeksi kita sendiri, berdasarkan sudut pandang pemain.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CaptureSource = ESceneCaptureSource :: SCS_SceneColorSceneDepth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Mode ini sedikit mahal, tetapi perlu untuk memberikan informasi yang cukup.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properti yang tersisa terutama terkait dengan parameter pasca pemrosesan. </font><font style="vertical-align: inherit;">Mereka adalah cara yang nyaman untuk mengontrol kualitas, dan karenanya menangkap kinerja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian terakhir memanggil fungsi yang membuat Target Render, yang akan kita lihat di bawah.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Init() { <span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------ //Create Camera //------------------------------------------------ SceneCapture = NewObject&lt;USceneCaptureComponent2D&gt;(this, USceneCaptureComponent2D::StaticClass(), *FString("PortalSceneCapture")); SceneCapture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); SceneCapture-&gt;RegisterComponent(); SceneCapture-&gt;bCaptureEveryFrame = false; SceneCapture-&gt;bCaptureOnMovement = false; SceneCapture-&gt;LODDistanceFactor = 3; //Force bigger LODs for faster computations SceneCapture-&gt;TextureTarget = nullptr; SceneCapture-&gt;bEnableClipPlane = true; SceneCapture-&gt;bUseCustomProjectionMatrix = true; SceneCapture-&gt;CaptureSource = ESceneCaptureSource::SCS_SceneColorSceneDepth; //Setup Post-Process of SceneCapture (optimization : disable Motion Blur, etc) FPostProcessSettings CaptureSettings; CaptureSettings.bOverride_AmbientOcclusionQuality = true; CaptureSettings.bOverride_MotionBlurAmount = true; CaptureSettings.bOverride_SceneFringeIntensity = true; CaptureSettings.bOverride_GrainIntensity = true; CaptureSettings.bOverride_ScreenSpaceReflectionQuality = true; CaptureSettings.AmbientOcclusionQuality = 0.0f; //0=lowest quality..100=maximum quality CaptureSettings.MotionBlurAmount = 0.0f; //0 = disabled CaptureSettings.SceneFringeIntensity = 0.0f; //0 = disabled CaptureSettings.GrainIntensity = 0.0f; //0 = disabled CaptureSettings.ScreenSpaceReflectionQuality = 0.0f; //0 = disabled CaptureSettings.bOverride_ScreenPercentage = true; CaptureSettings.ScreenPercentage = 100.0f; SceneCapture-&gt;PostProcessSettings = CaptureSettings; //------------------------------------------------ //Create RTT Buffer //------------------------------------------------ GeneratePortalTexture(); }</span></span></code> </pre> <br><hr><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeneratePortalTexture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah fungsi yang dipanggil saat diperlukan ketika Anda perlu membuat tekstur Target Render baru untuk portal. </font><font style="vertical-align: inherit;">Ini terjadi pada fungsi inisialisasi, tetapi juga dapat dipanggil selama peningkatan Portal Manager. </font><font style="vertical-align: inherit;">Itulah sebabnya fungsi ini memiliki pemeriksaan internal untuk mengubah resolusi viewport. </font><font style="vertical-align: inherit;">Jika itu tidak terjadi, maka pembaruan tidak dilakukan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus saya, saya membuat kelas pembungkus untuk UCanvasRenderTarget2D. Saya menyebutnya ExedreScriptedTexture, itu adalah komponen yang dapat dilampirkan ke aktor. Saya membuat kelas ini untuk mengelola target render dengan mudah dengan aktor yang memiliki tugas rendering. Dia melakukan inisialisasi yang tepat dari Target Render dan kompatibel dengan sistem UI saya sendiri. Namun, dalam konteks portal, tekstur RenderTarget2D reguler lebih dari cukup. Karena itu, Anda cukup menggunakannya.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::GeneratePortalTexture() { int32 CurrentSizeX = <span class="hljs-number"><span class="hljs-number">1920</span></span>; int32 CurrentSizeY = <span class="hljs-number"><span class="hljs-number">1080</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;GetViewportSize(CurrentSizeX, CurrentSizeY); } CurrentSizeX = FMath::Clamp( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(CurrentSizeX / <span class="hljs-number"><span class="hljs-number">1.7</span></span>), <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1920</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1920 / 1.5 = 1280 CurrentSizeY = FMath::Clamp( int(CurrentSizeY / 1.7), 128, 1080); if( CurrentSizeX == PreviousScreenSizeX &amp;&amp; CurrentSizeY == PreviousScreenSizeY ) { return; } PreviousScreenSizeX = CurrentSizeX; PreviousScreenSizeY = CurrentSizeY; //Cleanup existing RTT if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { PortalTexture-&gt;DestroyComponent(); GEngine-&gt;ForceGarbageCollection(); } //Create new RTT PortalTexture = nullptr; PortalTexture = NewObject&lt;UExedreScriptedTexture&gt;(this, UExedreScriptedTexture::StaticClass(), *FString("PortalRenderTarget")); PortalTexture-&gt;SizeX = CurrentSizeX; PortalTexture-&gt;SizeY = CurrentSizeY; //Custom properties of the UExedreScriptedTexture class PortalTexture-&gt;Gamma = 1.0f; PortalTexture-&gt;WrapModeX = 1; //Clamp PortalTexture-&gt;WrapModeY = 1; //Clamp PortalTexture-&gt;bDrawWidgets = false; PortalTexture-&gt;bGenerateMipMaps = false; PortalTexture-&gt;SetClearOnUpdate( false ); //Will be cleared by SceneCapture instead PortalTexture-&gt;Format = ERenderTargetFormat::RGBA16; //Needs 16b to get &gt;1 for Emissive PortalTexture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); PortalTexture-&gt;RegisterComponent(); PortalTexture-&gt;SetOwner( this ); PortalTexture-&gt;Init(); PortalTexture-&gt;SetFilterMode( TextureFilter::TF_Bilinear ); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti disebutkan di atas, saya membuat kelas saya sendiri, jadi properti yang ditetapkan di sini harus disesuaikan dengan Target Render yang biasa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting untuk memahami di mana tangkapan akan ditampilkan. </font><font style="vertical-align: inherit;">Karena target render akan ditampilkan dalam game, ini berarti bahwa ini akan terjadi sebelum seluruh pasca pemrosesan, dan oleh karena itu kita perlu membuat adegan dengan informasi yang cukup (untuk menyimpan nilai di atas 1 untuk membuat Bloom). </font><font style="vertical-align: inherit;">Itu sebabnya saya memilih format RGBA16 (perhatikan bahwa ia memiliki Enum sendiri, Anda harus menggunakan ETextureRenderTargetFormat sebagai gantinya). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk informasi lebih lanjut, lihat sumber-sumber berikut:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTextureRenderTarget2D</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETextureRenderTargetFormat</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USceneCaptureComponent2D</font></font></a> </li></ul><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya kami akan mempertimbangkan fungsi pembaruan. </font><font style="vertical-align: inherit;">Fungsi dasarnya cukup sederhana dan menyebabkan lebih kompleks. </font><font style="vertical-align: inherit;">Ada penundaan sebelum memanggil fungsi GeneratePortalTexture () untuk menghindari membuat ulang target render saat mengubah ukuran viewport (misalnya, di editor). </font><font style="vertical-align: inherit;">Selama publikasi game, penundaan ini dapat dihapus.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Update( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime ) { <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Generate Portal texture ? //----------------------------------- UpdateDelay += DeltaTime; if( UpdateDelay &gt; 1.0f ) { UpdateDelay = 0.0f; GeneratePortalTexture(); } //----------------------------------- //Find portals in the level and update them //----------------------------------- AExedrePortal* Portal = UpdatePortalsInWorld(); if( Portal != nullptr ) { UpdateCapture( Portal ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memanggil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menemukan semua portal yang ada di dunia saat ini (termasuk semua level yang dimuat) dan memperbaruinya. </font><font style="vertical-align: inherit;">Fungsi ini juga menentukan yang mana "aktif", yaitu </font><font style="vertical-align: inherit;">terlihat oleh pemain. </font><font style="vertical-align: inherit;">Jika kami menemukan portal yang aktif, kami memanggil </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang mengontrol komponen SceneCapture.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut cara kerja pembaruan dunia di dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ol><li>   <b></b>   (    ) </li><li>   <b>iterator</b> ,         </li><li>     ,   ,    <b>ClearRTT()</b> ,    .    <b> </b> (,   ). </li><li>  ,     <b></b>  ,    ,     ,     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemeriksaan yang menentukan kebenaran portal itu sederhana: kami memberikan prioritas ke portal yang paling dekat dengan pemain, karena ia kemungkinan besar akan menjadi yang paling terlihat dari sudut pandangnya. </font><font style="vertical-align: inherit;">Untuk menjatuhkan kerabat, tetapi, misalnya, portal yang terletak di belakang pemain, diperlukan pemeriksaan yang lebih kompleks, tetapi saya tidak ingin fokus pada tutorial ini, karena ini bisa menjadi sangat sulit.</font></font><br><br><pre> <code class="cpp hljs">AExedrePortal* AExedrePortalManager::UpdatePortalsInWorld() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update Portal actors in the world (and active one if nearby) //----------------------------------- AExedrePortal* ActivePortal = nullptr; FVector PlayerLocation = Character-&gt;GetActorLocation(); FVector CameraLocation = Character-&gt;GetCameraComponent()-&gt;GetComponentLocation(); float Distance = 4096.0f; for( TActorIterator&lt;AExedrePortal&gt;ActorItr( GetWorld() ); ActorItr; ++ActorItr ) { AExedrePortal* Portal = *ActorItr; FVector PortalLocation = Portal-&gt;GetActorLocation(); FVector PortalNormal = -1 * Portal-&gt;GetActorForwardVector(); //Reset Portal Portal-&gt;ClearRTT(); Portal-&gt;SetActive( false ); //Find the closest Portal when the player is Standing in front of float NewDistance = FMath::Abs( FVector::Dist( PlayerLocation, PortalLocation ) ); if( NewDistance &lt; Distance ) { Distance = NewDistance; ActivePortal = Portal; } } return ActivePortal; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saatnya untuk mempertimbangkan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah fitur pemutakhiran yang menangkap sisi lain portal. </font><font style="vertical-align: inherit;">Dari komentar semuanya harus jelas, tetapi di sini adalah deskripsi singkat:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mendapatkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke Character and Player Controller.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memeriksa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apakah semuanya sudah benar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Portal, komponen SceneCapture, Player).</font></font></li><li>   <b>Camera</b>    <b>Target</b>  . </li><li> <b></b>    ,     SceneCapture. </li><li>      SceneCapture     Target. </li><li> ,  SceneCapure  ,  ,   <b></b> . </li><li> <b> Render Target</b>  SceneCapture,  . </li><li>  <b> </b>  PlayerController. </li><li> ,    <b>Capture</b>  SceneCapture     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti yang dapat kita lihat, saat memindahkan pemain, elemen kunci dari perilaku alami dan tanpa cela dari SceneCapture adalah transformasi yang benar dari posisi dan rotasi portal ke ruang Target lokal. </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk definisi ConvertLocationToActorSpace (), lihat ‚ÄúTeleporting an Actor‚Äù. </font></font></blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::UpdateCapture( AExedrePortal* Portal ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update SceneCapture (discard if there is no active portal) //----------------------------------- if(SceneCapture != nullptr &amp;&amp; PortalTexture != nullptr &amp;&amp; Portal != nullptr &amp;&amp; Character != nullptr ) { UCameraComponent* PlayerCamera = Character-&gt;GetCameraComponent(); AActor* Target = Portal-&gt;GetTarget(); //Place the SceneCapture to the Target if( Target != nullptr ) { //------------------------------- //Compute new location in the space of the target actor //(which may not be aligned to world) //------------------------------- FVector NewLocation = UTool::ConvertLocationToActorSpace( PlayerCamera-&gt;GetComponentLocation(), Portal, Target ); SceneCapture-&gt;SetWorldLocation( NewLocation ); //------------------------------- //Compute new Rotation in the space of the //Target location //------------------------------- FTransform CameraTransform = PlayerCamera-&gt;GetComponentTransform(); FTransform SourceTransform = Portal-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * CameraTransform.GetRotation(); FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; //Update SceneCapture rotation SceneCapture-&gt;SetWorldRotation( NewWorldQuat ); //------------------------------- //Clip Plane : to ignore objects between the //SceneCapture and the Target of the portal //------------------------------- SceneCapture-&gt;ClipPlaneNormal = Target-&gt;GetActorForwardVector(); SceneCapture-&gt;ClipPlaneBase = Target-&gt;GetActorLocation() + (SceneCapture-&gt;ClipPlaneNormal * -1.5f); //Offset to avoid visible pixel border } //Switch on the valid Portal Portal-&gt;SetActive( true ); //Assign the Render Target Portal-&gt;SetRTT( PortalTexture-&gt;GetTexture() ); SceneCapture-&gt;TextureTarget = PortalTexture-&gt;GetTexture(); //Get the Projection Matrix SceneCapture-&gt;CustomProjectionMatrix = ControllerOwner-&gt;GetCameraProjectionMatrix(); //Say Cheeeeese ! SceneCapture-&gt;CaptureScene(); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCameraProjectionMatrix ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak ada secara default di kelas PlayerController, saya menambahkannya sendiri. </font><font style="vertical-align: inherit;">Itu ditunjukkan di bawah ini:</font></font><br><br><pre> <code class="cpp hljs">FMatrix AExedrePlayerController::GetCameraProjectionMatrix() { FMatrix ProjectionMatrix; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( GetLocalPlayer() != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { FSceneViewProjectionData PlayerProjectionData; GetLocalPlayer()-&gt;GetProjectionData( GetLocalPlayer()-&gt;ViewportClient-&gt;Viewport, EStereoscopicPass::eSSP_FULL, PlayerProjectionData ); ProjectionMatrix = PlayerProjectionData.ProjectionMatrix; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProjectionMatrix; }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, kita perlu mengimplementasikan panggilan ke fungsi Teleport. </font><font style="vertical-align: inherit;">Alasan pemrosesan sebagian dari teleportasi melalui Manajer Portal adalah bahwa perlu untuk menjamin pembaruan portal yang diperlukan, karena hanya Manajer yang memiliki informasi tentang semua portal di tempat kejadian. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita memiliki dua portal yang terhubung, maka ketika berpindah dari satu portal ke portal lainnya, kita perlu memperbarui keduanya dalam satu Tick. </font><font style="vertical-align: inherit;">Jika tidak, pemain akan berteleportasi dan akan berada di sisi lain portal, tetapi Target Portal tidak akan aktif sampai frame / ukuran berikutnya. </font><font style="vertical-align: inherit;">Ini akan membuat celah visual dengan bahan offset dari bidang jala yang kita lihat di atas.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { Portal-&gt;TeleportActor( TargetToTeleport ); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Force update //----------------------------------- AExedrePortal* FuturePortal = UpdatePortalsInWorld(); if( FuturePortal != nullptr ) { FuturePortal-&gt;ForceTick(); //Force update before the player render its view since he just teleported UpdateCapture( FuturePortal ); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yah, begitulah, akhirnya kami selesai dengan Portal Manager! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selesaikan cetak biru itu </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menyelesaikan Portal Manager, kita hanya perlu menyelesaikan aktor Portal itu sendiri, setelah itu sistem akan bekerja. </font><font style="vertical-align: inherit;">Satu-satunya hal yang hilang di sini adalah fitur Centang:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/455/bd3/f0f/455bd3f0f3b7c9f4f3fb36d5d1ae85d0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Begini cara kerjanya: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memperbarui </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehingga tidak tetap dalam kondisi aktif.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika portal saat ini </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak aktif</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sisa ukuran akan dibuang.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mendapatkan kelas Karakter untuk mengakses </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lokasi Kamera</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian pertama memeriksa apakah kamera berada di kotak tumbukan portal. </font><font style="vertical-align: inherit;">Jika demikian, maka kami mengimbangi portal mesh dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materialnya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian kedua adalah memeriksa ulang lokasi di dalam kotak tumbukan. </font><font style="vertical-align: inherit;">Jika dijalankan, maka kami memanggil fungsi yang memeriksa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apakah kami melewati portal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>        ,   Portal manager,    <b> Teleport</b> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam tangkapan layar grafik saya, Anda dapat melihat dua poin menarik: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Point Inside Box</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get Portal Manager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Saya belum menjelaskan kedua fungsi ini. Ini adalah fungsi statis yang saya definisikan di kelas saya sendiri sehingga Anda dapat memanggilnya dari mana saja. Ini adalah semacam kelas pembantu. Kode fungsi-fungsi ini ditunjukkan di bawah ini, Anda sendiri dapat memutuskan di mana memasukkannya. Jika Anda tidak membutuhkannya di luar sistem portal, Anda dapat memasukkannya langsung ke kelas aktor Portal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya saya ingin menggunakan sistem tumbukan untuk menemukan aktor portal di dalam kotak tumbukan, tetapi bagi saya sepertinya tidak cukup dapat diandalkan. Selain itu, menurut saya metode ini lebih cepat digunakan dan memiliki kelebihan: memperhitungkan rotasi aktor.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInsideBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Point, UBoxComponent* Box )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Box != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//From : //https://stackoverflow.com/questions/52673935/check-if-3d-point-inside-a-box/52674010 FVector Center = Box-&gt;GetComponentLocation(); FVector Half = Box-&gt;GetScaledBoxExtent(); FVector DirectionX = Box-&gt;GetForwardVector(); FVector DirectionY = Box-&gt;GetRightVector(); FVector DirectionZ = Box-&gt;GetUpVector(); FVector Direction = Point - Center; bool IsInside = FMath::Abs( FVector::DotProduct( Direction, DirectionX ) ) &lt;= Half.X &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionY ) ) &lt;= Half.Y &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionZ ) ) &lt;= Half.Z; return IsInside; } else { return false; } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AExedrePortalManager* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPortalManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AActor* Context )</span></span></span><span class="hljs-function"> </span></span>{ AExedrePortalManager* Manager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Retrieve the World from the Context actor if( Context != nullptr &amp;&amp; Context-&gt;GetWorld() != nullptr ) { //Find PlayerController AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( Context-&gt;GetWorld()-&gt;GetFirstPlayerController() ); //Retrieve the Portal Manager if( EPC != nullptr &amp;&amp; EPC-&gt;GetPortalManager() != nullptr ) { Manager = EPC-&gt;GetPortalManager(); } } return Manager; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian terakhir dari aktor Blueprint adalah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ForceTick</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ingatlah bahwa Force Tick dipanggil ketika pemain melintasi portal dan di sebelah portal lain yang Portal Manajernya memaksakan pembaruan. </font><font style="vertical-align: inherit;">Karena kami baru saja teleportasi, tidak perlu menggunakan kode yang sama, dan Anda dapat menggunakan versi yang disederhanakan:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/562/22e/cf356222e9d9c81dc38c57d021e51a90.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proses dimulai kira-kira bersamaan dengan fungsi Tick, tetapi kami hanya menjalankan bagian pertama dari urutan, yang memperbarui materi. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah kita sudah selesai? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hampir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kami menerapkan sistem portal dalam bentuk ini, maka kemungkinan besar kami akan menghadapi masalah berikut:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/f2f/9f7/4c1f2f9f71e8ce213764d42dad1d20c3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang sedang terjadi di sini? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam gif ini, frame rate game dibatasi hingga 6 FPS untuk menunjukkan masalahnya dengan lebih jelas. Dalam satu bingkai, kubus menghilang karena </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistem kliping</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unreal Engine menganggapnya tidak terlihat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini karena penemuan dilakukan dalam bingkai saat ini, dan kemudian digunakan di berikutnya. Ini menciptakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penundaan satu frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini biasanya dapat diatasi dengan memperluas kotak pembatas objek sehingga terdaftar sebelum terlihat. Namun, ini tidak akan berfungsi di sini, karena ketika kita melintasi portal, kita berpindah dari satu tempat ke tempat yang sama sekali berbeda.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menonaktifkan sistem kliping juga tidak mungkin, terutama karena pada level dengan banyak objek ini akan mengurangi kinerja. Selain itu, saya mencoba banyak tim dari mesin Unreal, tetapi tidak mendapatkan hasil positif: dalam semua kasus, penundaan satu frame tetap. Untungnya, setelah mempelajari secara terperinci kode sumber Unreal Engine, saya berhasil menemukan solusinya (jalurnya panjang - butuh lebih dari seminggu)! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti halnya komponen SceneCapture, Anda dapat memberi tahu kamera pemain bahwa kami melakukan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cut jump</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- posisi kamera melompati dua frame, yang berarti kita tidak bisa mengandalkan informasi dari frame sebelumnya. </font><font style="vertical-align: inherit;">Perilaku ini dapat diamati ketika menggunakan Matinee atau Sequencer, misalnya, ketika mengganti kamera: blur atau smoothing tidak dapat bergantung pada informasi dari frame sebelumnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan ini, kita perlu mempertimbangkan dua aspek:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LocalPlayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : kelas ini memproses berbagai informasi (misalnya, viewport pemain) dan dikaitkan dengan PlayerController. </font><font style="vertical-align: inherit;">Di sinilah kita dapat memengaruhi proses rendering kamera pemain.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerController</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ketika seorang pemain teleport, kelas ini mulai splicing berkat akses ke LocalPlayer.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keuntungan besar dari solusi ini adalah bahwa intervensi dalam proses rendering mesin minimal dan mudah dirawat di masa depan pembaruan Unreal Engine. </font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan membuat kelas baru yang diwarisi dari LocalPlayer. </font><font style="vertical-align: inherit;">Di bawah ini adalah tajuk yang mengidentifikasi dua komponen utama: mendefinisikan kembali perhitungan Scene Viewport dan fungsi baru untuk mengaktifkan pelekatan kamera.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Engine/LocalPlayer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API UExedreLocalPlayer : public ULocalPlayer { GENERATED_BODY() UExedreLocalPlayer(); public: FSceneView* CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) override; void PerformCameraCut(); private: bool bCameraCut; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Begini cara semuanya diterapkan: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Exedre.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.h"</span></span></span><span class="hljs-meta"> UExedreLocalPlayer::UExedreLocalPlayer() { bCameraCut = false; } FSceneView* UExedreLocalPlayer::CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ULocalPlayer::CalcSceneView() use a ViewInitOptions to create // a FSceneView which contains a "bCameraCut" variable // See : H:\GitHub\UnrealEngine\Engine\Source\Runtime\Renderer\Private\SceneCaptureRendering.cpp // as well for bCameraCutThisFrame in USceneCaptureComponent2D FSceneView* View = Super::CalcSceneView(ViewFamily, OutViewLocation, OutViewRotation, Viewport, ViewDrawer, StereoPass ); if( bCameraCut ) { View-&gt;bCameraCut = true; bCameraCut = false; } return View; } void UExedreLocalPlayer::PerformCameraCut() { bCameraCut = true; }</span></span></span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PerformCameraCut ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baru memulai Camera Cut dengan nilai boolean. </font><font style="vertical-align: inherit;">Ketika mesin memanggil fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pertama-tama kita menjalankan fungsi aslinya. </font><font style="vertical-align: inherit;">Kemudian kita periksa, kita perlu melakukan perekatan. </font><font style="vertical-align: inherit;">Jika demikian, kita mendefinisikan ulang variabel Camera Cut Boolean di dalam struktur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSceneView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang akan digunakan oleh proses rendering mesin, dan kemudian mengatur ulang variabel Boolean (menggunakannya).</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sisi Pengontrol Pemain, perubahannya minimal. </font><font style="vertical-align: inherit;">Anda perlu menambahkan variabel ke header untuk menyimpan tautan ke kelas asli LocalPlayer:</font></font><br><br><pre> <code class="cpp hljs"> UPROPERTY() UExedreLocalPlayer* LocalPlayer;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian dalam fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeginPlay ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"> LocalPlayer = Cast&lt;UExedreLocalPlayer&gt;( GetLocalPlayer() );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya juga menambahkan fungsi untuk meluncurkan Cut dengan cepat: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePlayerController::PerformCameraCut() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( LocalPlayer != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { LocalPlayer-&gt;PerformCameraCut(); } }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, dalam fungsi Portal Manager </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RequestTeleportByPortal (),</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita dapat mengeksekusi selama teleportasi Cut Kamera:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;PerformCameraCut(); } [...]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan itu saja! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Potongan Kamera harus dipanggil sebelum SceneCapture diperbarui, itulah sebabnya ia ada di awal fungsi.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasil akhir </font></font></h2><br> <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita telah belajar berpikir di portal. </font></font></a></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika sistem bekerja dengan baik, maka kita harus dapat membuat hal-hal ini:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika Anda mengalami masalah, periksa hal-hal berikut: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifikasi bahwa Portal Manager dibuat dan diinisialisasi dengan benar. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Target rendering dibuat dengan benar (Anda dapat menggunakan target yang dibuat di browser konten untuk memulai). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Portal diaktifkan dan dinonaktifkan dengan benar. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Portal memiliki aktor Target yang ditetapkan dengan benar di editor. </font></font></li></ul><br><h2>  Tanya Jawab </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertanyaan paling populer yang saya tanyakan tentang tutorial ini: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah mungkin untuk mengimplementasikan ini pada tumpul, dan tidak melalui C ++? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagian besar kode dapat diimplementasikan dalam tumpul, dengan pengecualian dua aspek:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetProjectionData () yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> digunakan untuk mendapatkan matriks proyeksi tidak tersedia dalam cetak biru.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang sangat penting untuk menyelesaikan masalah sistem kliping, tidak tersedia dalam cetak biru.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, Anda perlu menggunakan implementasi C ++ untuk mengakses kedua fungsi ini, atau memodifikasi kode sumber mesin agar dapat diakses melalui cetak biru. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah saya menggunakan sistem ini di VR? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya, sebagian besar. </font><font style="vertical-align: inherit;">Namun, beberapa bagian harus disesuaikan, misalnya:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda perlu menggunakan dua Target Render (satu untuk setiap mata) dan menutupi mereka di material portal untuk ditampilkan berdampingan di ruang layar. </font><font style="vertical-align: inherit;">Setiap target render harus setengah lebar dari resolusi perangkat VR.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda perlu menggunakan dua SceneCapture untuk membuat target dengan jarak yang benar (jarak antara mata) untuk membuat efek stereoskopik. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah utama adalah kinerja, karena sisi lain dari portal harus dirender dua kali. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah objek lain melewati portal?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak ada dalam kode saya. Namun, membuatnya lebih umum tidak begitu sulit. Untuk melakukan ini, portal perlu melacak lebih banyak informasi tentang semua objek terdekat untuk memeriksa apakah mereka melintasinya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah sistem mendukung rekursi (portal di dalam portal)?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tutorial ini bukan. Untuk rekursi, Anda memerlukan target render tambahan dan SceneCapture. Anda juga perlu menentukan RenderTarget mana yang akan di-render terlebih dahulu, dan seterusnya. Ini cukup sulit dan saya tidak ingin melakukan ini, karena untuk proyek saya ini tidak perlu. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah saya melewati portal di dekat tembok?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya tidak. </font><font style="vertical-align: inherit;">Namun, saya melihat dua cara untuk mengimplementasikan ini (secara teoritis):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nonaktifkan tabrakan pemain sehingga ia dapat melewati dinding. </font><font style="vertical-align: inherit;">Mudah diterapkan, tetapi akan menimbulkan banyak efek samping.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retas sistem tabrakan untuk membuat lubang secara dinamis, yang akan memungkinkan pemain untuk melewatinya. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda perlu memodifikasi sistem fisik mesin. </font><font style="vertical-align: inherit;">Namun, dari apa yang saya ketahui, setelah memuat level, fisika statis tidak dapat diperbarui. </font><font style="vertical-align: inherit;">Karena itu, untuk mendukung fitur ini akan membutuhkan banyak pekerjaan. </font><font style="vertical-align: inherit;">Jika portal Anda statis, maka Anda mungkin dapat mengatasi masalah ini dengan menggunakan streaming level untuk beralih di antara berbagai tabrakan.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448802/">https://habr.com/ru/post/id448802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448788/index.html">Pengujian Python dengan pytest. Bab 2, Fungsi Tes Penulisan</a></li>
<li><a href="../id448792/index.html">Pengujian Python dengan pytest. Perlengkapan Bawaan, Bab 4</a></li>
<li><a href="../id448796/index.html">Pengujian Python dengan pytest. Konfigurasi, BAB 6</a></li>
<li><a href="../id448798/index.html">Pengujian Python dengan pytest. Menggunakan pytest dengan alat lain, BAB 7</a></li>
<li><a href="../id448800/index.html">Konfigurasikan Visual Studio di seluruh organisasi Anda dengan .vsconfig</a></li>
<li><a href="../id448804/index.html">Bersiap untuk Hunted Runtime dan Notaris</a></li>
<li><a href="../id448808/index.html">Soal hal-hal sederhana, rumit. "Baja tidur." Cara melumasi baut berkarat atau Tidak WD-40 dengan satu ...</a></li>
<li><a href="../id448810/index.html">Bagaimana saya menangkap seorang hacker</a></li>
<li><a href="../id448812/index.html">Misi bulan "Bereshit" - mencari perpustakaan bulan pertama setelah kecelakaan pengangkutnya telah dimulai</a></li>
<li><a href="../id448814/index.html">Bahasa Bosque - Bahasa Pemrograman Baru Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>