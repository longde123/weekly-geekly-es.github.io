<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>〰️ 👶🏾 🔀 Go Bitmap Indexes: Recherche sauvage 👩🏾‍🏫 🚴🏿 👧🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Présentation 
 J'ai fait ce rapport en anglais lors de la conférence GopherCon Russia 2019 à Moscou et en russe lors de la réunion à Nizhny Novgorod. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go Bitmap Indexes: Recherche sauvage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/451938/"><img src="https://habrastorage.org/webt/hg/g_/eq/hgg_eq6037im5xzqx0ibzmdyoku.jpeg"><br><br><h2>  Présentation </h2><br>  J'ai fait ce rapport en anglais lors de la conférence GopherCon Russia 2019 à Moscou et en russe lors de la réunion à Nizhny Novgorod.  Il s'agit d'un index bitmap - moins courant que l'arbre B, mais non moins intéressant.  Je partage l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">enregistrement du</a> discours de la conférence en anglais et la transcription du texte en russe. <br><br>  Nous allons examiner comment fonctionne l'index bitmap, quand il est meilleur, quand il est pire que les autres index, et dans quels cas il est beaucoup plus rapide qu'eux;  Nous verrons quels SGBD populaires ont déjà des index bitmap.  essayez d'écrire le vôtre sur Go.  Et pour le dessert, nous utiliserons des bibliothèques prêtes à l'emploi pour créer notre propre base de données spécialisée ultra-rapide. <br><br>  J'espère vraiment que mon travail vous sera utile et intéressant.  C'est parti! <br><a name="habracut"></a><br><h2>  Présentation </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Bonjour à tous!  Il est six heures du soir, nous sommes tous super fatigués.  Le bon moment pour parler de la théorie ennuyeuse des index de base de données, non?  Ne vous inquiétez pas, j'aurai quelques lignes de code source ici et là.  :-) <br><br>  Si sans blagues, alors le rapport est plein d'informations, et nous n'avons pas beaucoup de temps.  Commençons donc. <br><img src="https://habrastorage.org/webt/ui/p9/0n/uip90nv7gann0i9cq_xqctdilh0.png"><br>  Aujourd'hui, je vais parler des éléments suivants: <br><br><ul><li>  quels sont les index; <br></li><li>  qu'est-ce qu'un index bitmap; <br></li><li>  où il est utilisé et où il n'est PAS utilisé et pourquoi; <br></li><li>  implémentation simple sur Go et un peu de mal avec le compilateur; <br></li><li>  implémentation un peu moins simple, mais beaucoup plus productive dans Go-assembler; <br></li><li>  «Problèmes» des index bitmap; <br></li><li>  implémentations existantes. <br></li></ul><br><br><h2>  Quels sont donc les index? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Un index est une structure de données distincte que nous détenons et mettons à jour en plus des données principales.  Il est utilisé pour accélérer la recherche.  Sans index, une recherche nécessiterait un passage complet à travers les données (un processus appelé analyse complète), et ce processus a une complexité algorithmique linéaire.  Mais les bases de données contiennent généralement une énorme quantité de données et la complexité linéaire est trop lente.  Idéalement, nous obtiendrions une logarithmique ou une constante. <br><br>  C'est un énorme sujet complexe, débordant de subtilités et de compromis, mais après avoir examiné des décennies de développement et de recherche de diverses bases de données, je suis prêt à affirmer qu'il n'y a que quelques approches largement utilisées pour créer des index de base de données. <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  La première approche consiste à réduire hiérarchiquement la zone de recherche, en divisant la zone de recherche en parties plus petites. <br><br>  Habituellement, nous faisons cela en utilisant toutes sortes d'arbres.  Un exemple est une grande boîte avec des matériaux dans votre placard, dans laquelle il y a des boîtes plus petites avec des matériaux divisés par divers sujets.  Si vous avez besoin de matériaux, vous les chercherez probablement dans une boîte avec les mots "Matériaux", et non dans celle qui dit "Cookies", non? <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  La deuxième approche consiste à sélectionner immédiatement l'élément ou le groupe d'éléments souhaité.  Nous le faisons dans des cartes de hachage ou dans des index inverses.  L'utilisation de cartes de hachage est très similaire à l'exemple précédent, mais au lieu d'une boîte avec des boîtes dans votre placard, il y a beaucoup de petites boîtes avec des éléments finaux. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  La troisième approche consiste à se débarrasser de la nécessité d'une recherche.  Nous le faisons en utilisant des filtres Bloom ou des filtres à coucou.  Les premiers fournissent une réponse instantanément, éliminant le besoin de chercher. <br><br><img src="https://habrastorage.org/webt/ic/b2/4f/icb24fzrjaf4ntui8cymh3orj3c.png"><br><br>  La dernière approche consiste à utiliser pleinement toutes les capacités que le fer moderne nous donne.  C'est exactement ce que nous faisons dans les index bitmap.  Oui, lors de leur utilisation, nous devons parfois parcourir l'intégralité de l'index, mais nous le faisons de manière très efficace. <br><br>  Comme je l'ai dit, le sujet des index de base de données est vaste et déborde de compromis.  Cela signifie que parfois nous pouvons utiliser plusieurs approches en même temps: si nous devons accélérer encore plus la recherche ou s'il est nécessaire de couvrir tous les types de recherche possibles. <br><br>  Aujourd'hui, je vais parler de l'approche la moins connue de ces derniers - sur les index bitmap. <br><br><h2>  Qui suis-je pour en parler? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Je travaille en tant que chef d'équipe à Badoo (vous connaissez peut-être mieux notre autre produit, Bumble).  Nous avons déjà plus de 400 millions d'utilisateurs dans le monde et de nombreuses fonctionnalités qui sont engagées dans la sélection de la meilleure paire pour eux.  Nous le faisons en utilisant des services personnalisés qui utilisent également des index bitmap. <br><br><h2>  Qu'est-ce qu'un index bitmap? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br>  Les index bitmap, comme leur nom nous l'indique, utilisent des bitmaps ou des bitsets pour implémenter un index de recherche.  D'un point de vue d'oiseau, cet index se compose d'un ou plusieurs bitmaps représentant des entités (telles que des personnes) et leurs propriétés ou paramètres (âge, couleur des yeux, etc.), et d'un algorithme qui utilise des opérations binaires (ET, OU, NON) pour répondre à une requête de recherche. <br><img src="https://habrastorage.org/webt/24/20/ey/2420eyiyck6eqjz7t6xf9zs-gvq.jpeg"><br>  On nous dit que les index bitmap sont les mieux adaptés et très productifs dans les cas où il existe une recherche qui combine des requêtes sur de nombreuses colonnes qui ont peu de cardinalité (imaginez la «couleur des yeux» ou «l'état matrimonial» contre quelque chose comme «la distance du centre-ville» )  Mais plus tard, je montrerai qu'ils fonctionnent parfaitement dans le cas de colonnes à cardinalité élevée. <br><br>  Prenons l'exemple le plus simple d'un index bitmap. <br><img src="https://habrastorage.org/webt/yc/rf/1d/ycrf1dwjkvooel8tctktagyxi0a.jpeg"><br>  Imaginez que nous avons une liste de restaurants de Moscou avec des propriétés binaires comme celles-ci: <br><br><ul><li>  près du métro (près du métro); <br></li><li>  il y a un parking privé (a un parking privé); <br></li><li>  il y a une véranda (a terrasse); <br></li><li>  Vous pouvez réserver une table (accepte les réservations); <br></li><li>  adapté aux végétariens (végétalien); <br></li><li>  cher (cher). <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Donnons à chaque restaurant un numéro de série commençant à 0 et allouons de la mémoire à 6 bitmaps (un pour chaque caractéristique).  Ensuite, nous remplissons ces bitmaps, selon que le restaurant possède ou non cette propriété.  Si le restaurant 4 a une véranda, le bit n ° 4 du bitmap "il y a une véranda" sera mis à 1 (s'il n'y a pas de véranda, alors à 0). <br><img src="https://habrastorage.org/webt/jl/ap/ge/jlapgeh1fk9cvapi-9gyxtlgnty.jpeg"><br>  Nous avons maintenant l'index bitmap le plus simple possible, et nous pouvons l'utiliser pour répondre à des requêtes comme: <br><br><ul><li>  «Montrez-moi des restaurants adaptés aux végétariens»; <br></li><li>  "Montrez-moi des restaurants bon marché avec une véranda où vous pouvez réserver une table." <br></li></ul><br><br><img src="https://habrastorage.org/webt/2p/wq/t7/2pwqt76nijteahvflvizdufiumy.jpeg"><br><img src="https://habrastorage.org/webt/_d/fg/wq/_dfgwq--uyewk4k_fryjd533tug.jpeg"><br>  Comment?  Voyons voir.  La première demande est très simple.  Tout ce que nous devons faire est de prendre le bitmap «adapté aux végétariens» et de le transformer en une liste de restaurants dont les morceaux sont affichés. <br><img src="https://habrastorage.org/webt/oe/0-/hd/oe0-hd5hqr6b6unvqtdoadn3jtu.jpeg"><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br>  La deuxième requête est un peu plus compliquée.  Nous devons utiliser l'opération NOT bit sur le bitmap «cher» pour obtenir une liste de restaurants bon marché, puis le définir avec le bitmap «vous pouvez réserver une table» et définir le résultat avec le bitmap «il y a une véranda».  Le bitmap résultant contiendra une liste d'établissements qui répondent à tous nos critères.  Dans cet exemple, ce n'est que le restaurant Yunost. <br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br>  Il y a beaucoup de théorie, mais ne vous inquiétez pas, nous verrons le code très bientôt. <br><br><h2>  Où sont utilisés les index bitmap? </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br>  Si vous "google" indexez le bitmap, 90% des réponses seront en quelque sorte liées à Oracle DB.  Mais le reste du SGBD supporte probablement aussi une chose aussi cool, non?  Pas vraiment. <br><br>  Passons en revue la liste des principaux suspects. <br><img src="https://habrastorage.org/webt/-k/xy/zn/-kxyznvnwct15_2jzp3rulwotic.jpeg"><br>  MySQL ne prend pas encore en charge les index bitmap, mais il existe une proposition avec une proposition pour ajouter cette option ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ). <br><br>  PostgreSQL ne prend pas en charge les index bitmap, mais utilise des bitmaps et des opérations bit simples pour combiner les résultats de la recherche sur plusieurs autres index. <br><br>  Tarantool possède des index de bits, il prend en charge une recherche simple sur eux. <br><br>  Redis a des champs de bits simples <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(https://redis.io/commands/bitfield</a> ) sans possibilité de les parcourir. <br><br>  MongoDB ne prend pas encore en charge les index bitmap, mais il existe également une proposition avec une proposition pour ajouter cette option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://jira.mongodb.org/browse/SERVER-1723</a> <br><br>  Elasticsearch utilise des bitmaps à l'intérieur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps</a> ). <br><br><br><img src="https://habrastorage.org/webt/kv/rd/zo/kvrdzoime8mqrf1vtl_iqwgjaea.jpeg"><br><br><ul><li>  Mais un nouveau voisin est apparu dans notre maison: Pilosa.  Il s'agit d'une nouvelle base de données non relationnelle écrite en Go.  Il ne contient que des index bitmap et base tout sur eux.  Nous parlerons d'elle un peu plus tard. <br></li></ul><br><br><h2>  Mise en œuvre Go </h2><br>  Mais pourquoi les index bitmap sont-ils si rarement utilisés?  Avant de répondre à cette question, je voudrais vous montrer l'implémentation d'un index bitmap très simple sur Go. <br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br>  Les bitmaps ne sont essentiellement que des éléments de données.  Dans Go, utilisons des tranches d'octets pour cela. <br><br>  Nous avons une image bitmap par caractéristique de restaurant, et chaque bit de l'image bitmap indique si un restaurant particulier a cette propriété ou non. <br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br>  Nous aurons besoin de deux fonctions auxiliaires.  L'un sera utilisé pour remplir nos bitmaps avec des données aléatoires.  Aléatoire, mais avec une certaine probabilité que le restaurant possède chaque propriété.  Par exemple, je pense qu'il y a très peu de restaurants à Moscou où vous ne pouvez pas réserver de table, et il me semble qu'environ 20% des établissements sont adaptés aux végétariens. <br><br>  La deuxième fonction convertira le bitmap en une liste de restaurants. <br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><br><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br>  Pour répondre à la demande «Montrez-moi les restaurants bon marché qui ont une véranda et où vous pouvez réserver une table», nous avons besoin de deux opérations de bit: NON et ET. <br><br>  Nous pouvons simplifier un peu notre code en utilisant l'opération plus complexe ET NON. <br><br>  Nous avons des fonctions pour chacune de ces opérations.  Les deux passent par les tranches, prennent les éléments correspondants de chacune, les combinent avec une opération de bits et mettent le résultat dans la tranche résultante. <br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br>  Et maintenant, nous pouvons utiliser nos bitmaps et fonctions pour répondre à une requête de recherche. <br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br>  Les performances ne sont pas si élevées, malgré le fait que les fonctions sont très simples et nous avons décemment économisé sur le fait que nous n'avons pas renvoyé une nouvelle tranche résultante à chaque appel de la fonction. <br><br>  Ayant un peu profilé avec pprof, j'ai remarqué que le compilateur Go manquait une optimisation très simple, mais très importante: la fonction inline. <br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br>  Le fait est que le compilateur Go a terriblement peur des boucles qui passent par des tranches et refuse catégoriquement les fonctions en ligne qui contiennent des boucles. <br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br>  Mais je n'ai pas peur, et je peux tromper le compilateur en utilisant goto au lieu d'une boucle, comme au bon vieux temps. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Et, comme vous pouvez le voir, le compilateur intègre désormais notre fonction avec bonheur!  En conséquence, nous parvenons à économiser environ 2 microsecondes.  Pas mal! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Le deuxième goulot d'étranglement est facile à voir si vous regardez attentivement la sortie de l'assembleur.  Le compilateur a ajouté une vérification liée aux tranches juste à l'intérieur de notre boucle la plus chaude.  Le fait est que Go est un langage sûr, le compilateur a peur que mes trois arguments (trois tranches) aient des tailles différentes.  Après tout, il y aura alors une possibilité théorique d'apparition du soi-disant débordement de tampon. <br><br>  Rassurons le compilateur en lui montrant que toutes les tranches sont de la même taille.  Nous pouvons le faire en ajoutant une simple vérification au début de notre fonction. <br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br>  Voyant cela, le compilateur saute joyeusement le test, et nous finissons par économiser encore 500 nanosecondes. <br><br><h2>  Grands lots </h2><br>  D'accord, nous avons réussi à réduire certaines performances de notre implémentation simple, mais ce résultat, en fait, est bien pire que possible avec le matériel actuel. <br><br>  Tout ce que nous faisons, ce sont des opérations de base sur les bits, et nos processeurs les exécutent très efficacement.  Mais, malheureusement, nous «alimentons» notre processeur avec de très petits travaux.  Nos fonctions effectuent des opérations octet par octet.  Nous pouvons très facilement régler notre code pour qu'il fonctionne avec des morceaux de 8 octets à l'aide de tranches UInt64. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Comme vous pouvez le voir, ce petit changement a accéléré notre programme de huit fois en raison d'une augmentation du lot de huit fois.  Le gain peut être considéré comme linéaire. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><br><h2>  Implémentation de l'assembleur </h2><br><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br>  Mais ce n'est pas la fin.  Nos processeurs peuvent fonctionner avec des morceaux de 16, 32 et même 64 octets.  De telles opérations "larges" sont appelées données multiples à instruction unique (SIMD; une instruction, beaucoup de données), et le processus de transformation du code pour qu'il utilise de telles opérations est appelé vectorisation. <br><br>  Malheureusement, le compilateur Go est loin d'être un excellent étudiant en vectorisation.  Actuellement, la seule façon de vectoriser du code sur Go est de prendre et de placer ces opérations manuellement à l'aide de l'assembleur Go. <br><br><img src="https://habrastorage.org/webt/qv/dr/ap/qvdrapgfhvfhrei2ies1w2vtcds.jpeg"><br><br>  Assembler Go est une étrange bête.  Vous savez probablement que l'assembleur est quelque chose qui est fortement lié à l'architecture de l'ordinateur pour lequel vous écrivez, mais ce n'est pas le cas avec Go.  L'assembleur Go ressemble plus à un IRL (langage de représentation intermédiaire) ou à un langage intermédiaire: il est pratiquement indépendant de la plateforme.  Rob Pike a fait une excellente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">présentation</a> à ce sujet il y a quelques années au GopherCon de Denver. <br><br>  De plus, Go utilise le format inhabituel Plan 9, qui diffère des formats AT&amp;T et Intel généralement reconnus. <br><img src="https://habrastorage.org/webt/kp/8r/px/kp8rpxg_xmp3faph2ysefnjavxk.jpeg"><br>  Il est sûr de dire que l'écriture manuelle de l'assembleur Go n'est pas l'activité la plus amusante. <br><br>  Mais, heureusement, il existe déjà deux outils de haut niveau qui nous aident à écrire l'assembleur Go: PeachPy et avo.  Les deux utilitaires génèrent des assembleurs Go à partir de code de niveau supérieur écrit en Python et Go, respectivement. <br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br>  Ces utilitaires simplifient des choses comme l'allocation de registres, les cycles d'écriture et simplifient généralement le processus d'entrée dans le monde de la programmation des assembleurs dans Go. <br><br>  Nous utiliserons avo, donc nos programmes seront des programmes Go presque normaux. <br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br>  Voici à quoi ressemble l'exemple le plus simple d'un programme avo.  Nous avons une fonction main () qui définit la fonction Add () à l'intérieur d'elle-même, ce qui signifie ajouter deux nombres.  Il existe des fonctions auxiliaires pour obtenir les paramètres par nom et obtenir l'un des registres de processeur gratuits et appropriés.  Chaque opération de processeur a une fonction correspondante sur avo, comme vu dans ADDQ.  Enfin, nous voyons une fonction d'aide pour stocker la valeur résultante. <br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br>  En appelant go generate, nous exécuterons le programme sur avo et à la fin deux fichiers seront générés: <br><br><ul><li>  add.s avec le code assembleur Go résultant; <br></li><li>  stub.go avec des en-têtes de fonction pour connecter deux mondes: Go et assembleur. <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br>  Maintenant que nous avons vu ce que fait et comment avo, jetons un œil à nos fonctions.  J'ai implémenté des versions scalaires et vectorielles (SIMD) de fonctions. <br><br>  Tout d'abord, regardez les versions scalaires. <br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br>  Comme dans l'exemple précédent, nous vous demandons de nous fournir un registre général gratuit et correct, nous n'avons pas besoin de calculer les décalages et les tailles des arguments.  Tout cela fait pour nous. <br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br>  Auparavant, nous utilisions des étiquettes et des goto (ou des sauts) pour améliorer les performances et tromper le compilateur Go, mais maintenant nous le faisons depuis le tout début.  Le fait est que les boucles sont un concept de niveau supérieur.  Dans l'assembleur, nous n'avons que des étiquettes et des sauts. <br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br>  Le code restant doit déjà être familier et compréhensible.  Nous émulons la boucle avec des étiquettes et des sauts, prenons une petite partie des données de nos deux tranches, les combinons avec une opération de bits (ET PAS dans ce cas), puis mettons le résultat dans la tranche résultante.  C’est tout. <br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br>  Voici à quoi ressemble le code assembleur final.  Nous n'avons pas eu besoin de calculer les décalages et les tailles (surlignés en vert) ou de garder une trace des registres utilisés (surlignés en rouge). <br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br>  Si nous comparons les performances de l'implémentation dans l'assembleur avec les performances de la meilleure implémentation dans Go, nous verrons que c'est la même chose.  Et c'est attendu.  Après tout, nous n'avons rien fait de spécial - nous venons de reproduire ce que le compilateur Go ferait. <br><br>  Malheureusement, nous ne pouvons pas forcer le compilateur à aligner nos fonctions écrites en assembleur.  Le compilateur Go n'a pas cette fonctionnalité aujourd'hui, bien que la demande d'ajout existe depuis un certain temps. <br><br>  C'est pourquoi il est impossible d'obtenir des avantages de petites fonctions dans l'assembleur.  Nous devons soit écrire de grandes fonctions, soit utiliser le nouveau package math / bits, soit contourner le côté assembleur. <br><br>  Voyons maintenant les versions vectorielles de nos fonctions. <br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br>  Pour cet exemple, j'ai décidé d'utiliser AVX2, nous allons donc utiliser des opérations qui fonctionnent avec des blocs de 32 octets.  La structure du code est très similaire à l'option scalaire: chargement des paramètres, merci de nous fournir un registre général gratuit, etc. <br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br>  L'une des innovations est que les opérations vectorielles plus larges utilisent des registres larges spéciaux.  Dans le cas de blocs de 32 octets, ce sont des registres avec le préfixe Y. C'est pourquoi vous voyez la fonction YMM () dans le code.  Si je devais utiliser l'AVX-512 avec des morceaux 64 bits, le préfixe serait Z. <br><br>  La deuxième innovation est que j'ai décidé d'utiliser une optimisation appelée déroulage de boucle, c'est-à-dire effectuer huit opérations de boucle manuellement avant de sauter au début de la boucle.  Cette optimisation réduit le nombre de brunchs (branches) dans le code, et elle est limitée par le nombre de registres gratuits disponibles. <br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br>  Et la performance?  Elle est belle!  Nous avons obtenu une accélération environ sept fois par rapport à la meilleure solution sur Go.  Impressionnant, hein? <br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br>  Mais même cette implémentation pourrait potentiellement être accélérée en utilisant AVX-512, la prélecture ou JIT (compilateur juste à temps) pour le planificateur de requêtes.  Mais c'est certainement un sujet pour un rapport séparé. <br><br><h2>  Problèmes d'index bitmap </h2><br>  Maintenant que nous avons déjà examiné une implémentation simple de l'index bitmap Go et un langage d'assemblage beaucoup plus efficace, parlons enfin des raisons pour lesquelles les index bitmap sont si rarement utilisés. <br><img src="https://habrastorage.org/webt/qs/yf/as/qsyfasqoxbr_heaolyqpd9ms7hk.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les anciens articles scientifiques, trois problèmes d'index bitmap sont mentionnés, mais les articles scientifiques plus récents et moi soutenons qu'ils ne sont plus pertinents. </font><font style="vertical-align: inherit;">Nous n'allons pas approfondir chacun de ces problèmes, mais nous les examinerons superficiellement.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le problème de la grande cardinalité </font></font></h2><br> ,  ,  bitmap-       ,   ,     (,    ),    ,      (   )          ,  ,  bitmap-   () . <br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br>      ,  ,      .       .             .     ,          —         . <br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br>        , , , roaring .         —  ,     bit runs —    ,       . <br><br>    roaring     .          ,        Go. <br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br>   ,        ,   (binning). ,     ,   .  —     ,  , ,       .       185,2   185,3 . <br><br> ,          1 . <br><br>      ,        50    250 ,   ,  ,            200 . <br><br> ,         . <br><br><h2>     </h2><br>   bitmap-   ,       . <br><br>          ,          .   ,             .  ,     ,    — lock contention,      . <br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br>             . <br><br>  —    .    bitmap- ,       .               lock contention. <br><br>     —    .       ,       ,   —    .    -   (,   100   500 )      . ,       ,          . <br><br>      :       . <br><br><h2>    </h2><br><br>   bitmap-   , ,   ,        ,   « ». <br><br>  ,  ,    AND, OR  . .      - «       200  300   ». <br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br>                   OR. <br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br>        . ,    50 .       50 . <br><br>       ,      .      range-encoded bitmaps. <br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br>           -  (, 200),      ,  . 200  .     300: 300  .  Et ainsi de suite. <br><br>   ,        ,      .     ,      300 ,      ,      199 .  C'est fait. <br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br>  ,       bitmap-.   ,   ,      . , S2  Google.            ,   .           « » (   ). <br><br><h2>  Solutions prêtes à l'emploi </h2><br>               .   -    - ,   ,    . <br><br>      ,   ,   bitmap-  .   ,   SIMD, . <br><br>  ,    ,   . <br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><h2> Roaring  </h2><br> -,    roaring bitmaps-,     .        ,     ,    bitmap-. <br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br>  ,       Go-   SIMD,  , Go-  ,    C, . <br><br><h2> Pilosa </h2><br>  ,    , —  Pilosa,  ,  ,  bitmap-  .    ,       . <br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg"><br> Pilosa  roaring         ,      ,     : , range-encoded bitmaps,    . . <br><br>       Pilosa       . <br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br>     ,    .      Pilosa,     ,         , ,   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après cela, nous utilisons NOT sur le champ «cher», puis coupons le résultat (ou AND) avec le champ terrasse et le champ réservations. </font><font style="vertical-align: inherit;">Et enfin, nous obtenons le résultat final. </font></font><br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'espère vraiment que dans un avenir prévisible dans les SGBD comme MySQL et PostgreSQL, ce nouveau type d'index apparaîtra également - les index bitmap.</font></font><br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><h2>  Conclusion </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br>  Si vous ne vous êtes pas encore endormi, merci.  J'ai dû aborder de nombreux sujets en passant en raison du temps limité, mais j'espère que le rapport a été utile et peut-être même motivant. <br><br>  Il est bon de connaître les index bitmap, même si vous n'en avez pas besoin pour le moment.  Laissez-les être un autre outil dans votre tiroir. <br><br>  Nous avons couvert diverses astuces de performance pour Go et les choses avec lesquelles le compilateur Go ne fonctionne pas très bien.  Mais il est absolument utile que tout programmeur Go le sache. <br><br>  C'est tout ce que je voulais dire.  Je vous remercie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451938/">https://habr.com/ru/post/fr451938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451928/index.html">Comment configurer l'analyse Web sur les pages AMP</a></li>
<li><a href="../fr451930/index.html">Automatisation de l'éclairage des cages d'escalier</a></li>
<li><a href="../fr451932/index.html">PHDays 9: Bienvenue dans la section Développement sûr</a></li>
<li><a href="../fr451934/index.html">Alexander Lamden: «Tout morceau de fer a un caractère»</a></li>
<li><a href="../fr451936/index.html">Recherche de vulnérabilités dans UC Browser</a></li>
<li><a href="../fr451942/index.html">Comment le bourdonnement en Afrique sauve des milliers de vies</a></li>
<li><a href="../fr451944/index.html">2019: année de DEX (échanges décentralisés)</a></li>
<li><a href="../fr451948/index.html">L'histoire des trois cartouches</a></li>
<li><a href="../fr451950/index.html">Centrales virtuelles. Est-il possible de gérer les sources d'énergie "verte"?</a></li>
<li><a href="../fr451954/index.html">Plus de télégrammes secrets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>