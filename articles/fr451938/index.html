<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ã€°ï¸ ğŸ‘¶ğŸ¾ ğŸ”€ Go Bitmap Indexes: Recherche sauvage ğŸ‘©ğŸ¾â€ğŸ« ğŸš´ğŸ¿ ğŸ‘§ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PrÃ©sentation 
 J'ai fait ce rapport en anglais lors de la confÃ©rence GopherCon Russia 2019 Ã  Moscou et en russe lors de la rÃ©union Ã  Nizhny Novgorod. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go Bitmap Indexes: Recherche sauvage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/451938/"><img src="https://habrastorage.org/webt/hg/g_/eq/hgg_eq6037im5xzqx0ibzmdyoku.jpeg"><br><br><h2>  PrÃ©sentation </h2><br>  J'ai fait ce rapport en anglais lors de la confÃ©rence GopherCon Russia 2019 Ã  Moscou et en russe lors de la rÃ©union Ã  Nizhny Novgorod.  Il s'agit d'un index bitmap - moins courant que l'arbre B, mais non moins intÃ©ressant.  Je partage l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">enregistrement du</a> discours de la confÃ©rence en anglais et la transcription du texte en russe. <br><br>  Nous allons examiner comment fonctionne l'index bitmap, quand il est meilleur, quand il est pire que les autres index, et dans quels cas il est beaucoup plus rapide qu'eux;  Nous verrons quels SGBD populaires ont dÃ©jÃ  des index bitmap.  essayez d'Ã©crire le vÃ´tre sur Go.  Et pour le dessert, nous utiliserons des bibliothÃ¨ques prÃªtes Ã  l'emploi pour crÃ©er notre propre base de donnÃ©es spÃ©cialisÃ©e ultra-rapide. <br><br>  J'espÃ¨re vraiment que mon travail vous sera utile et intÃ©ressant.  C'est parti! <br><a name="habracut"></a><br><h2>  PrÃ©sentation </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Bonjour Ã  tous!  Il est six heures du soir, nous sommes tous super fatiguÃ©s.  Le bon moment pour parler de la thÃ©orie ennuyeuse des index de base de donnÃ©es, non?  Ne vous inquiÃ©tez pas, j'aurai quelques lignes de code source ici et lÃ .  :-) <br><br>  Si sans blagues, alors le rapport est plein d'informations, et nous n'avons pas beaucoup de temps.  CommenÃ§ons donc. <br><img src="https://habrastorage.org/webt/ui/p9/0n/uip90nv7gann0i9cq_xqctdilh0.png"><br>  Aujourd'hui, je vais parler des Ã©lÃ©ments suivants: <br><br><ul><li>  quels sont les index; <br></li><li>  qu'est-ce qu'un index bitmap; <br></li><li>  oÃ¹ il est utilisÃ© et oÃ¹ il n'est PAS utilisÃ© et pourquoi; <br></li><li>  implÃ©mentation simple sur Go et un peu de mal avec le compilateur; <br></li><li>  implÃ©mentation un peu moins simple, mais beaucoup plus productive dans Go-assembler; <br></li><li>  Â«ProblÃ¨mesÂ» des index bitmap; <br></li><li>  implÃ©mentations existantes. <br></li></ul><br><br><h2>  Quels sont donc les index? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Un index est une structure de donnÃ©es distincte que nous dÃ©tenons et mettons Ã  jour en plus des donnÃ©es principales.  Il est utilisÃ© pour accÃ©lÃ©rer la recherche.  Sans index, une recherche nÃ©cessiterait un passage complet Ã  travers les donnÃ©es (un processus appelÃ© analyse complÃ¨te), et ce processus a une complexitÃ© algorithmique linÃ©aire.  Mais les bases de donnÃ©es contiennent gÃ©nÃ©ralement une Ã©norme quantitÃ© de donnÃ©es et la complexitÃ© linÃ©aire est trop lente.  IdÃ©alement, nous obtiendrions une logarithmique ou une constante. <br><br>  C'est un Ã©norme sujet complexe, dÃ©bordant de subtilitÃ©s et de compromis, mais aprÃ¨s avoir examinÃ© des dÃ©cennies de dÃ©veloppement et de recherche de diverses bases de donnÃ©es, je suis prÃªt Ã  affirmer qu'il n'y a que quelques approches largement utilisÃ©es pour crÃ©er des index de base de donnÃ©es. <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  La premiÃ¨re approche consiste Ã  rÃ©duire hiÃ©rarchiquement la zone de recherche, en divisant la zone de recherche en parties plus petites. <br><br>  Habituellement, nous faisons cela en utilisant toutes sortes d'arbres.  Un exemple est une grande boÃ®te avec des matÃ©riaux dans votre placard, dans laquelle il y a des boÃ®tes plus petites avec des matÃ©riaux divisÃ©s par divers sujets.  Si vous avez besoin de matÃ©riaux, vous les chercherez probablement dans une boÃ®te avec les mots "MatÃ©riaux", et non dans celle qui dit "Cookies", non? <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  La deuxiÃ¨me approche consiste Ã  sÃ©lectionner immÃ©diatement l'Ã©lÃ©ment ou le groupe d'Ã©lÃ©ments souhaitÃ©.  Nous le faisons dans des cartes de hachage ou dans des index inverses.  L'utilisation de cartes de hachage est trÃ¨s similaire Ã  l'exemple prÃ©cÃ©dent, mais au lieu d'une boÃ®te avec des boÃ®tes dans votre placard, il y a beaucoup de petites boÃ®tes avec des Ã©lÃ©ments finaux. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  La troisiÃ¨me approche consiste Ã  se dÃ©barrasser de la nÃ©cessitÃ© d'une recherche.  Nous le faisons en utilisant des filtres Bloom ou des filtres Ã  coucou.  Les premiers fournissent une rÃ©ponse instantanÃ©ment, Ã©liminant le besoin de chercher. <br><br><img src="https://habrastorage.org/webt/ic/b2/4f/icb24fzrjaf4ntui8cymh3orj3c.png"><br><br>  La derniÃ¨re approche consiste Ã  utiliser pleinement toutes les capacitÃ©s que le fer moderne nous donne.  C'est exactement ce que nous faisons dans les index bitmap.  Oui, lors de leur utilisation, nous devons parfois parcourir l'intÃ©gralitÃ© de l'index, mais nous le faisons de maniÃ¨re trÃ¨s efficace. <br><br>  Comme je l'ai dit, le sujet des index de base de donnÃ©es est vaste et dÃ©borde de compromis.  Cela signifie que parfois nous pouvons utiliser plusieurs approches en mÃªme temps: si nous devons accÃ©lÃ©rer encore plus la recherche ou s'il est nÃ©cessaire de couvrir tous les types de recherche possibles. <br><br>  Aujourd'hui, je vais parler de l'approche la moins connue de ces derniers - sur les index bitmap. <br><br><h2>  Qui suis-je pour en parler? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Je travaille en tant que chef d'Ã©quipe Ã  Badoo (vous connaissez peut-Ãªtre mieux notre autre produit, Bumble).  Nous avons dÃ©jÃ  plus de 400 millions d'utilisateurs dans le monde et de nombreuses fonctionnalitÃ©s qui sont engagÃ©es dans la sÃ©lection de la meilleure paire pour eux.  Nous le faisons en utilisant des services personnalisÃ©s qui utilisent Ã©galement des index bitmap. <br><br><h2>  Qu'est-ce qu'un index bitmap? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br>  Les index bitmap, comme leur nom nous l'indique, utilisent des bitmaps ou des bitsets pour implÃ©menter un index de recherche.  D'un point de vue d'oiseau, cet index se compose d'un ou plusieurs bitmaps reprÃ©sentant des entitÃ©s (telles que des personnes) et leurs propriÃ©tÃ©s ou paramÃ¨tres (Ã¢ge, couleur des yeux, etc.), et d'un algorithme qui utilise des opÃ©rations binaires (ET, OU, NON) pour rÃ©pondre Ã  une requÃªte de recherche. <br><img src="https://habrastorage.org/webt/24/20/ey/2420eyiyck6eqjz7t6xf9zs-gvq.jpeg"><br>  On nous dit que les index bitmap sont les mieux adaptÃ©s et trÃ¨s productifs dans les cas oÃ¹ il existe une recherche qui combine des requÃªtes sur de nombreuses colonnes qui ont peu de cardinalitÃ© (imaginez la Â«couleur des yeuxÂ» ou Â«l'Ã©tat matrimonialÂ» contre quelque chose comme Â«la distance du centre-villeÂ» )  Mais plus tard, je montrerai qu'ils fonctionnent parfaitement dans le cas de colonnes Ã  cardinalitÃ© Ã©levÃ©e. <br><br>  Prenons l'exemple le plus simple d'un index bitmap. <br><img src="https://habrastorage.org/webt/yc/rf/1d/ycrf1dwjkvooel8tctktagyxi0a.jpeg"><br>  Imaginez que nous avons une liste de restaurants de Moscou avec des propriÃ©tÃ©s binaires comme celles-ci: <br><br><ul><li>  prÃ¨s du mÃ©tro (prÃ¨s du mÃ©tro); <br></li><li>  il y a un parking privÃ© (a un parking privÃ©); <br></li><li>  il y a une vÃ©randa (a terrasse); <br></li><li>  Vous pouvez rÃ©server une table (accepte les rÃ©servations); <br></li><li>  adaptÃ© aux vÃ©gÃ©tariens (vÃ©gÃ©talien); <br></li><li>  cher (cher). <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Donnons Ã  chaque restaurant un numÃ©ro de sÃ©rie commenÃ§ant Ã  0 et allouons de la mÃ©moire Ã  6 bitmaps (un pour chaque caractÃ©ristique).  Ensuite, nous remplissons ces bitmaps, selon que le restaurant possÃ¨de ou non cette propriÃ©tÃ©.  Si le restaurant 4 a une vÃ©randa, le bit n Â° 4 du bitmap "il y a une vÃ©randa" sera mis Ã  1 (s'il n'y a pas de vÃ©randa, alors Ã  0). <br><img src="https://habrastorage.org/webt/jl/ap/ge/jlapgeh1fk9cvapi-9gyxtlgnty.jpeg"><br>  Nous avons maintenant l'index bitmap le plus simple possible, et nous pouvons l'utiliser pour rÃ©pondre Ã  des requÃªtes comme: <br><br><ul><li>  Â«Montrez-moi des restaurants adaptÃ©s aux vÃ©gÃ©tariensÂ»; <br></li><li>  "Montrez-moi des restaurants bon marchÃ© avec une vÃ©randa oÃ¹ vous pouvez rÃ©server une table." <br></li></ul><br><br><img src="https://habrastorage.org/webt/2p/wq/t7/2pwqt76nijteahvflvizdufiumy.jpeg"><br><img src="https://habrastorage.org/webt/_d/fg/wq/_dfgwq--uyewk4k_fryjd533tug.jpeg"><br>  Comment?  Voyons voir.  La premiÃ¨re demande est trÃ¨s simple.  Tout ce que nous devons faire est de prendre le bitmap Â«adaptÃ© aux vÃ©gÃ©tariensÂ» et de le transformer en une liste de restaurants dont les morceaux sont affichÃ©s. <br><img src="https://habrastorage.org/webt/oe/0-/hd/oe0-hd5hqr6b6unvqtdoadn3jtu.jpeg"><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br>  La deuxiÃ¨me requÃªte est un peu plus compliquÃ©e.  Nous devons utiliser l'opÃ©ration NOT bit sur le bitmap Â«cherÂ» pour obtenir une liste de restaurants bon marchÃ©, puis le dÃ©finir avec le bitmap Â«vous pouvez rÃ©server une tableÂ» et dÃ©finir le rÃ©sultat avec le bitmap Â«il y a une vÃ©randaÂ».  Le bitmap rÃ©sultant contiendra une liste d'Ã©tablissements qui rÃ©pondent Ã  tous nos critÃ¨res.  Dans cet exemple, ce n'est que le restaurant Yunost. <br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br>  Il y a beaucoup de thÃ©orie, mais ne vous inquiÃ©tez pas, nous verrons le code trÃ¨s bientÃ´t. <br><br><h2>  OÃ¹ sont utilisÃ©s les index bitmap? </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br>  Si vous "google" indexez le bitmap, 90% des rÃ©ponses seront en quelque sorte liÃ©es Ã  Oracle DB.  Mais le reste du SGBD supporte probablement aussi une chose aussi cool, non?  Pas vraiment. <br><br>  Passons en revue la liste des principaux suspects. <br><img src="https://habrastorage.org/webt/-k/xy/zn/-kxyznvnwct15_2jzp3rulwotic.jpeg"><br>  MySQL ne prend pas encore en charge les index bitmap, mais il existe une proposition avec une proposition pour ajouter cette option ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ). <br><br>  PostgreSQL ne prend pas en charge les index bitmap, mais utilise des bitmaps et des opÃ©rations bit simples pour combiner les rÃ©sultats de la recherche sur plusieurs autres index. <br><br>  Tarantool possÃ¨de des index de bits, il prend en charge une recherche simple sur eux. <br><br>  Redis a des champs de bits simples <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(https://redis.io/commands/bitfield</a> ) sans possibilitÃ© de les parcourir. <br><br>  MongoDB ne prend pas encore en charge les index bitmap, mais il existe Ã©galement une proposition avec une proposition pour ajouter cette option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://jira.mongodb.org/browse/SERVER-1723</a> <br><br>  Elasticsearch utilise des bitmaps Ã  l'intÃ©rieur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps</a> ). <br><br><br><img src="https://habrastorage.org/webt/kv/rd/zo/kvrdzoime8mqrf1vtl_iqwgjaea.jpeg"><br><br><ul><li>  Mais un nouveau voisin est apparu dans notre maison: Pilosa.  Il s'agit d'une nouvelle base de donnÃ©es non relationnelle Ã©crite en Go.  Il ne contient que des index bitmap et base tout sur eux.  Nous parlerons d'elle un peu plus tard. <br></li></ul><br><br><h2>  Mise en Å“uvre Go </h2><br>  Mais pourquoi les index bitmap sont-ils si rarement utilisÃ©s?  Avant de rÃ©pondre Ã  cette question, je voudrais vous montrer l'implÃ©mentation d'un index bitmap trÃ¨s simple sur Go. <br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br>  Les bitmaps ne sont essentiellement que des Ã©lÃ©ments de donnÃ©es.  Dans Go, utilisons des tranches d'octets pour cela. <br><br>  Nous avons une image bitmap par caractÃ©ristique de restaurant, et chaque bit de l'image bitmap indique si un restaurant particulier a cette propriÃ©tÃ© ou non. <br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br>  Nous aurons besoin de deux fonctions auxiliaires.  L'un sera utilisÃ© pour remplir nos bitmaps avec des donnÃ©es alÃ©atoires.  AlÃ©atoire, mais avec une certaine probabilitÃ© que le restaurant possÃ¨de chaque propriÃ©tÃ©.  Par exemple, je pense qu'il y a trÃ¨s peu de restaurants Ã  Moscou oÃ¹ vous ne pouvez pas rÃ©server de table, et il me semble qu'environ 20% des Ã©tablissements sont adaptÃ©s aux vÃ©gÃ©tariens. <br><br>  La deuxiÃ¨me fonction convertira le bitmap en une liste de restaurants. <br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><br><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br>  Pour rÃ©pondre Ã  la demande Â«Montrez-moi les restaurants bon marchÃ© qui ont une vÃ©randa et oÃ¹ vous pouvez rÃ©server une tableÂ», nous avons besoin de deux opÃ©rations de bit: NON et ET. <br><br>  Nous pouvons simplifier un peu notre code en utilisant l'opÃ©ration plus complexe ET NON. <br><br>  Nous avons des fonctions pour chacune de ces opÃ©rations.  Les deux passent par les tranches, prennent les Ã©lÃ©ments correspondants de chacune, les combinent avec une opÃ©ration de bits et mettent le rÃ©sultat dans la tranche rÃ©sultante. <br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br>  Et maintenant, nous pouvons utiliser nos bitmaps et fonctions pour rÃ©pondre Ã  une requÃªte de recherche. <br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br>  Les performances ne sont pas si Ã©levÃ©es, malgrÃ© le fait que les fonctions sont trÃ¨s simples et nous avons dÃ©cemment Ã©conomisÃ© sur le fait que nous n'avons pas renvoyÃ© une nouvelle tranche rÃ©sultante Ã  chaque appel de la fonction. <br><br>  Ayant un peu profilÃ© avec pprof, j'ai remarquÃ© que le compilateur Go manquait une optimisation trÃ¨s simple, mais trÃ¨s importante: la fonction inline. <br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br>  Le fait est que le compilateur Go a terriblement peur des boucles qui passent par des tranches et refuse catÃ©goriquement les fonctions en ligne qui contiennent des boucles. <br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br>  Mais je n'ai pas peur, et je peux tromper le compilateur en utilisant goto au lieu d'une boucle, comme au bon vieux temps. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Et, comme vous pouvez le voir, le compilateur intÃ¨gre dÃ©sormais notre fonction avec bonheur!  En consÃ©quence, nous parvenons Ã  Ã©conomiser environ 2 microsecondes.  Pas mal! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Le deuxiÃ¨me goulot d'Ã©tranglement est facile Ã  voir si vous regardez attentivement la sortie de l'assembleur.  Le compilateur a ajoutÃ© une vÃ©rification liÃ©e aux tranches juste Ã  l'intÃ©rieur de notre boucle la plus chaude.  Le fait est que Go est un langage sÃ»r, le compilateur a peur que mes trois arguments (trois tranches) aient des tailles diffÃ©rentes.  AprÃ¨s tout, il y aura alors une possibilitÃ© thÃ©orique d'apparition du soi-disant dÃ©bordement de tampon. <br><br>  Rassurons le compilateur en lui montrant que toutes les tranches sont de la mÃªme taille.  Nous pouvons le faire en ajoutant une simple vÃ©rification au dÃ©but de notre fonction. <br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br>  Voyant cela, le compilateur saute joyeusement le test, et nous finissons par Ã©conomiser encore 500 nanosecondes. <br><br><h2>  Grands lots </h2><br>  D'accord, nous avons rÃ©ussi Ã  rÃ©duire certaines performances de notre implÃ©mentation simple, mais ce rÃ©sultat, en fait, est bien pire que possible avec le matÃ©riel actuel. <br><br>  Tout ce que nous faisons, ce sont des opÃ©rations de base sur les bits, et nos processeurs les exÃ©cutent trÃ¨s efficacement.  Mais, malheureusement, nous Â«alimentonsÂ» notre processeur avec de trÃ¨s petits travaux.  Nos fonctions effectuent des opÃ©rations octet par octet.  Nous pouvons trÃ¨s facilement rÃ©gler notre code pour qu'il fonctionne avec des morceaux de 8 octets Ã  l'aide de tranches UInt64. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Comme vous pouvez le voir, ce petit changement a accÃ©lÃ©rÃ© notre programme de huit fois en raison d'une augmentation du lot de huit fois.  Le gain peut Ãªtre considÃ©rÃ© comme linÃ©aire. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><br><h2>  ImplÃ©mentation de l'assembleur </h2><br><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br>  Mais ce n'est pas la fin.  Nos processeurs peuvent fonctionner avec des morceaux de 16, 32 et mÃªme 64 octets.  De telles opÃ©rations "larges" sont appelÃ©es donnÃ©es multiples Ã  instruction unique (SIMD; une instruction, beaucoup de donnÃ©es), et le processus de transformation du code pour qu'il utilise de telles opÃ©rations est appelÃ© vectorisation. <br><br>  Malheureusement, le compilateur Go est loin d'Ãªtre un excellent Ã©tudiant en vectorisation.  Actuellement, la seule faÃ§on de vectoriser du code sur Go est de prendre et de placer ces opÃ©rations manuellement Ã  l'aide de l'assembleur Go. <br><br><img src="https://habrastorage.org/webt/qv/dr/ap/qvdrapgfhvfhrei2ies1w2vtcds.jpeg"><br><br>  Assembler Go est une Ã©trange bÃªte.  Vous savez probablement que l'assembleur est quelque chose qui est fortement liÃ© Ã  l'architecture de l'ordinateur pour lequel vous Ã©crivez, mais ce n'est pas le cas avec Go.  L'assembleur Go ressemble plus Ã  un IRL (langage de reprÃ©sentation intermÃ©diaire) ou Ã  un langage intermÃ©diaire: il est pratiquement indÃ©pendant de la plateforme.  Rob Pike a fait une excellente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prÃ©sentation</a> Ã  ce sujet il y a quelques annÃ©es au GopherCon de Denver. <br><br>  De plus, Go utilise le format inhabituel Plan 9, qui diffÃ¨re des formats AT&amp;T et Intel gÃ©nÃ©ralement reconnus. <br><img src="https://habrastorage.org/webt/kp/8r/px/kp8rpxg_xmp3faph2ysefnjavxk.jpeg"><br>  Il est sÃ»r de dire que l'Ã©criture manuelle de l'assembleur Go n'est pas l'activitÃ© la plus amusante. <br><br>  Mais, heureusement, il existe dÃ©jÃ  deux outils de haut niveau qui nous aident Ã  Ã©crire l'assembleur Go: PeachPy et avo.  Les deux utilitaires gÃ©nÃ¨rent des assembleurs Go Ã  partir de code de niveau supÃ©rieur Ã©crit en Python et Go, respectivement. <br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br>  Ces utilitaires simplifient des choses comme l'allocation de registres, les cycles d'Ã©criture et simplifient gÃ©nÃ©ralement le processus d'entrÃ©e dans le monde de la programmation des assembleurs dans Go. <br><br>  Nous utiliserons avo, donc nos programmes seront des programmes Go presque normaux. <br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br>  Voici Ã  quoi ressemble l'exemple le plus simple d'un programme avo.  Nous avons une fonction main () qui dÃ©finit la fonction Add () Ã  l'intÃ©rieur d'elle-mÃªme, ce qui signifie ajouter deux nombres.  Il existe des fonctions auxiliaires pour obtenir les paramÃ¨tres par nom et obtenir l'un des registres de processeur gratuits et appropriÃ©s.  Chaque opÃ©ration de processeur a une fonction correspondante sur avo, comme vu dans ADDQ.  Enfin, nous voyons une fonction d'aide pour stocker la valeur rÃ©sultante. <br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br>  En appelant go generate, nous exÃ©cuterons le programme sur avo et Ã  la fin deux fichiers seront gÃ©nÃ©rÃ©s: <br><br><ul><li>  add.s avec le code assembleur Go rÃ©sultant; <br></li><li>  stub.go avec des en-tÃªtes de fonction pour connecter deux mondes: Go et assembleur. <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br>  Maintenant que nous avons vu ce que fait et comment avo, jetons un Å“il Ã  nos fonctions.  J'ai implÃ©mentÃ© des versions scalaires et vectorielles (SIMD) de fonctions. <br><br>  Tout d'abord, regardez les versions scalaires. <br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br>  Comme dans l'exemple prÃ©cÃ©dent, nous vous demandons de nous fournir un registre gÃ©nÃ©ral gratuit et correct, nous n'avons pas besoin de calculer les dÃ©calages et les tailles des arguments.  Tout cela fait pour nous. <br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br>  Auparavant, nous utilisions des Ã©tiquettes et des goto (ou des sauts) pour amÃ©liorer les performances et tromper le compilateur Go, mais maintenant nous le faisons depuis le tout dÃ©but.  Le fait est que les boucles sont un concept de niveau supÃ©rieur.  Dans l'assembleur, nous n'avons que des Ã©tiquettes et des sauts. <br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br>  Le code restant doit dÃ©jÃ  Ãªtre familier et comprÃ©hensible.  Nous Ã©mulons la boucle avec des Ã©tiquettes et des sauts, prenons une petite partie des donnÃ©es de nos deux tranches, les combinons avec une opÃ©ration de bits (ET PAS dans ce cas), puis mettons le rÃ©sultat dans la tranche rÃ©sultante.  Câ€™est tout. <br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br>  Voici Ã  quoi ressemble le code assembleur final.  Nous n'avons pas eu besoin de calculer les dÃ©calages et les tailles (surlignÃ©s en vert) ou de garder une trace des registres utilisÃ©s (surlignÃ©s en rouge). <br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br>  Si nous comparons les performances de l'implÃ©mentation dans l'assembleur avec les performances de la meilleure implÃ©mentation dans Go, nous verrons que c'est la mÃªme chose.  Et c'est attendu.  AprÃ¨s tout, nous n'avons rien fait de spÃ©cial - nous venons de reproduire ce que le compilateur Go ferait. <br><br>  Malheureusement, nous ne pouvons pas forcer le compilateur Ã  aligner nos fonctions Ã©crites en assembleur.  Le compilateur Go n'a pas cette fonctionnalitÃ© aujourd'hui, bien que la demande d'ajout existe depuis un certain temps. <br><br>  C'est pourquoi il est impossible d'obtenir des avantages de petites fonctions dans l'assembleur.  Nous devons soit Ã©crire de grandes fonctions, soit utiliser le nouveau package math / bits, soit contourner le cÃ´tÃ© assembleur. <br><br>  Voyons maintenant les versions vectorielles de nos fonctions. <br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br>  Pour cet exemple, j'ai dÃ©cidÃ© d'utiliser AVX2, nous allons donc utiliser des opÃ©rations qui fonctionnent avec des blocs de 32 octets.  La structure du code est trÃ¨s similaire Ã  l'option scalaire: chargement des paramÃ¨tres, merci de nous fournir un registre gÃ©nÃ©ral gratuit, etc. <br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br>  L'une des innovations est que les opÃ©rations vectorielles plus larges utilisent des registres larges spÃ©ciaux.  Dans le cas de blocs de 32 octets, ce sont des registres avec le prÃ©fixe Y. C'est pourquoi vous voyez la fonction YMM () dans le code.  Si je devais utiliser l'AVX-512 avec des morceaux 64 bits, le prÃ©fixe serait Z. <br><br>  La deuxiÃ¨me innovation est que j'ai dÃ©cidÃ© d'utiliser une optimisation appelÃ©e dÃ©roulage de boucle, c'est-Ã -dire effectuer huit opÃ©rations de boucle manuellement avant de sauter au dÃ©but de la boucle.  Cette optimisation rÃ©duit le nombre de brunchs (branches) dans le code, et elle est limitÃ©e par le nombre de registres gratuits disponibles. <br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br>  Et la performance?  Elle est belle!  Nous avons obtenu une accÃ©lÃ©ration environ sept fois par rapport Ã  la meilleure solution sur Go.  Impressionnant, hein? <br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br>  Mais mÃªme cette implÃ©mentation pourrait potentiellement Ãªtre accÃ©lÃ©rÃ©e en utilisant AVX-512, la prÃ©lecture ou JIT (compilateur juste Ã  temps) pour le planificateur de requÃªtes.  Mais c'est certainement un sujet pour un rapport sÃ©parÃ©. <br><br><h2>  ProblÃ¨mes d'index bitmap </h2><br>  Maintenant que nous avons dÃ©jÃ  examinÃ© une implÃ©mentation simple de l'index bitmap Go et un langage d'assemblage beaucoup plus efficace, parlons enfin des raisons pour lesquelles les index bitmap sont si rarement utilisÃ©s. <br><img src="https://habrastorage.org/webt/qs/yf/as/qsyfasqoxbr_heaolyqpd9ms7hk.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les anciens articles scientifiques, trois problÃ¨mes d'index bitmap sont mentionnÃ©s, mais les articles scientifiques plus rÃ©cents et moi soutenons qu'ils ne sont plus pertinents. </font><font style="vertical-align: inherit;">Nous n'allons pas approfondir chacun de ces problÃ¨mes, mais nous les examinerons superficiellement.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le problÃ¨me de la grande cardinalitÃ© </font></font></h2><br> ,  ,  bitmap-       ,   ,     (,    ),    ,      (   )          ,  ,  bitmap-   () . <br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br>      ,  ,      .       .             .     ,          â€”         . <br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br>        , , , roaring .         â€”  ,     bit runs â€”    ,       . <br><br>    roaring     .          ,        Go. <br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br>   ,        ,   (binning). ,     ,   .  â€”     ,  , ,       .       185,2   185,3 . <br><br> ,          1 . <br><br>      ,        50    250 ,   ,  ,            200 . <br><br> ,         . <br><br><h2>     </h2><br>   bitmap-   ,       . <br><br>          ,          .   ,             .  ,     ,    â€” lock contention,      . <br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br>             . <br><br>  â€”    .    bitmap- ,       .               lock contention. <br><br>     â€”    .       ,       ,   â€”    .    -   (,   100   500 )      . ,       ,          . <br><br>      :       . <br><br><h2>    </h2><br><br>   bitmap-   , ,   ,        ,   Â« Â». <br><br>  ,  ,    AND, OR  . .      - Â«       200  300   Â». <br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br>                   OR. <br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br>        . ,    50 .       50 . <br><br>       ,      .      range-encoded bitmaps. <br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br>           -  (, 200),      ,  . 200  .     300: 300  .  Et ainsi de suite. <br><br>   ,        ,      .     ,      300 ,      ,      199 .  C'est fait. <br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br>  ,       bitmap-.   ,   ,      . , S2  Google.            ,   .           Â« Â» (   ). <br><br><h2>  Solutions prÃªtes Ã  l'emploi </h2><br>               .   -    - ,   ,    . <br><br>      ,   ,   bitmap-  .   ,   SIMD, . <br><br>  ,    ,   . <br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><h2> Roaring  </h2><br> -,    roaring bitmaps-,     .        ,     ,    bitmap-. <br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br>  ,       Go-   SIMD,  , Go-  ,    C, . <br><br><h2> Pilosa </h2><br>  ,    , â€”  Pilosa,  ,  ,  bitmap-  .    ,       . <br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg"><br> Pilosa  roaring         ,      ,     : , range-encoded bitmaps,    . . <br><br>       Pilosa       . <br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br>     ,    .      Pilosa,     ,         , ,   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AprÃ¨s cela, nous utilisons NOT sur le champ Â«cherÂ», puis coupons le rÃ©sultat (ou AND) avec le champ terrasse et le champ rÃ©servations. </font><font style="vertical-align: inherit;">Et enfin, nous obtenons le rÃ©sultat final. </font></font><br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'espÃ¨re vraiment que dans un avenir prÃ©visible dans les SGBD comme MySQL et PostgreSQL, ce nouveau type d'index apparaÃ®tra Ã©galement - les index bitmap.</font></font><br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><h2>  Conclusion </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br>  Si vous ne vous Ãªtes pas encore endormi, merci.  J'ai dÃ» aborder de nombreux sujets en passant en raison du temps limitÃ©, mais j'espÃ¨re que le rapport a Ã©tÃ© utile et peut-Ãªtre mÃªme motivant. <br><br>  Il est bon de connaÃ®tre les index bitmap, mÃªme si vous n'en avez pas besoin pour le moment.  Laissez-les Ãªtre un autre outil dans votre tiroir. <br><br>  Nous avons couvert diverses astuces de performance pour Go et les choses avec lesquelles le compilateur Go ne fonctionne pas trÃ¨s bien.  Mais il est absolument utile que tout programmeur Go le sache. <br><br>  C'est tout ce que je voulais dire.  Je vous remercie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451938/">https://habr.com/ru/post/fr451938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451928/index.html">Comment configurer l'analyse Web sur les pages AMP</a></li>
<li><a href="../fr451930/index.html">Automatisation de l'Ã©clairage des cages d'escalier</a></li>
<li><a href="../fr451932/index.html">PHDays 9: Bienvenue dans la section DÃ©veloppement sÃ»r</a></li>
<li><a href="../fr451934/index.html">Alexander Lamden: Â«Tout morceau de fer a un caractÃ¨reÂ»</a></li>
<li><a href="../fr451936/index.html">Recherche de vulnÃ©rabilitÃ©s dans UC Browser</a></li>
<li><a href="../fr451942/index.html">Comment le bourdonnement en Afrique sauve des milliers de vies</a></li>
<li><a href="../fr451944/index.html">2019: annÃ©e de DEX (Ã©changes dÃ©centralisÃ©s)</a></li>
<li><a href="../fr451948/index.html">L'histoire des trois cartouches</a></li>
<li><a href="../fr451950/index.html">Centrales virtuelles. Est-il possible de gÃ©rer les sources d'Ã©nergie "verte"?</a></li>
<li><a href="../fr451954/index.html">Plus de tÃ©lÃ©grammes secrets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>