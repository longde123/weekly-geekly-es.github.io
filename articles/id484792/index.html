<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍💻 🤸🏿 🌓 Optimalisasi model 3D untuk adegan game 🖐️ 🛬 👨🏻‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini melengkapi serangkaian publikasi dari studio Krasnodar Plarium tentang berbagai aspek bekerja dengan model 3D di Unity. Artikel sebelumnya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimalisasi model 3D untuk adegan game</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/484792/">  Artikel ini melengkapi serangkaian publikasi dari studio Krasnodar Plarium tentang berbagai aspek bekerja dengan model 3D di Unity.  Artikel sebelumnya: <a href="https://habr.com/ru/company/plarium/blog/440690/">"Fitur bekerja dengan Mesh in Unity"</a> , <a href="https://habr.com/ru/company/plarium/blog/443870/">"Unity: editing prosedural Mesh"</a> , <a href="https://habr.com/ru/company/plarium/blog/447820/">"Impor model 3D ke dalam Unity and pitfalls"</a> , <a href="https://habr.com/ru/company/plarium/blog/451794/">"Lekukan piksel dalam pemindaian tekstur"</a> . <br><br>  Hampir 2 tahun yang lalu kami menulis <a href="https://habr.com/ru/company/plarium/blog/348494/">sebuah artikel</a> di mana kami berbicara tentang opsi untuk mengoptimalkan geometri 3D dalam sebuah adegan dengan batasan sudut kamera dan rotasi objek yang sesuai.  Tidak banyak yang mengalir sejak saat itu, tetapi kesempatan untuk meningkatkan solusi, mempertimbangkan berbagai pendekatan dan memata-matai orang lain menghantui pikiran pengembang.  Pada artikel ini, kami akan menjelaskan versi peningkatan algoritma berdasarkan pada poligon lukisan, serta berbicara tentang mencoba mentransfer bagian dari pekerjaan ini ke paket 3D. <br><br><img src="https://habrastorage.org/webt/jl/v-/pz/jlv-pzi5qagnnmqhgkqaddzo1uo.jpeg"><a name="habracut"></a><br><br><h3>  Pangkas di tempat kejadian </h3><br>  Kami telah mempertimbangkan prinsip dasar dari algoritma ini dalam artikel di atas: kami memadamkan semua efek dan objek transparan, melukis poligon yang tidak diproses dalam satu warna, dan yang diproses dalam berbagai warna, membuat, dan mengekstrak hasilnya.  Dalam versi lama, mereka melukis sehingga semua hitam menjadi berlebihan, dan hanya satu segitiga yang ditandai dengan warna merah. <br><br>  <a href="https://habr.com/ru/company/plarium/blog/348494/">Dalam komentar</a> untuk artikel itu, salah satu pembaca menunjukkan kemungkinan mengoptimalkan algoritma dengan membangun korespondensi satu-ke-satu antara set poligon dan beberapa set angka unik.  Maka dimungkinkan untuk memproses lebih dari satu segitiga dengan cara yang sama.  Pertimbangkan opsi ini. <br><br>  Dalam hal ini, serta terakhir kali, beberapa pra-pelatihan seharusnya dihubungkan dengan menonaktifkan semua objek bersiul di atas panggung dan objek yang dijamin tidak akan mempengaruhi visibilitas model target.  Tampilan kamera diproses hampir secara independen, mereka hanya dihubungkan oleh buffer indeks umum poligon yang terlihat.  Selain itu, preprocessing geometri dilakukan untuk setiap sudut, selama poligon diputar yang dikembalikan ke kamera ( <b>backface</b> ).  Ini dilakukan karena pada tahap algoritma tertentu mesh sementara dibuat dengan jumlah simpul yang jauh lebih besar daripada yang asli.  Angka ini dapat dengan mudah melebihi ambang batas 65.535, yang akan membutuhkan gerakan tambahan dalam perhitungan dan akan menyebabkan penurunan kinerja.  Bagaimanapun, poligon ini akan dihapus, karena warnanya tidak akan jatuh ke dalam bingkai.  Namun, karena fakta bahwa setiap segitiga berpotensi menimbulkan tiga simpul sampah, menghilangkan poligon yang tidak perlu terlebih dahulu memfasilitasi tahap utama dari algoritma dan mengurangi biaya memori. <br><br>  Biarlah ada beberapa model 3D, geometri yang diwakili oleh mesh.  Untuk melukis poligon tertentu dalam warna yang unik, Anda harus melukis semua simpulnya dalam warna ini.  Karena dalam kasus umum satu simpul dapat menjadi bagian dari poligon yang berbeda, tidak mungkin untuk menyelesaikan masalah secara langsung.  Tidak masalah bagaimana kita mewarnai vertex apa pun, saat render, warnanya akan merayapi semua segitiga yang memilikinya, sesuai dengan algoritma interpolasi di sisi kartu video. <br><br><img src="https://habrastorage.org/webt/ay/td/qo/aytdqo0ah1fzsl7pcasymag9rf8.jpeg"><br>  <i>Contoh interpolasi warna saat menampilkan poligon dengan simpul umum</i> <br><br>  Oleh karena itu, perlu untuk membuat mesh dibagi menjadi beberapa poligon independen yang terpisah, sambil menjaga topologi dan geometri objek.  Dictum factum.  Kami mengubah array segitiga dan simpul sedemikian rupa sehingga untuk setiap segitiga 3 simpul unik akan dibuat, posisi yang ditentukan oleh simpul yang sesuai dari mesh asli.  Perlu dicatat bahwa dalam kasus umum, mesh seperti itu akan memiliki jumlah simpul yang jauh lebih besar dibandingkan dengan yang asli.  Dan jika angka ini melebihi 65.535, maka saat membuat mesh, Anda harus menentukan format pengindeksan yang sesuai. <br><br><div class="spoiler">  <b class="spoiler_title">Konversi mesh asli ke mesh dengan simpul unik untuk setiap poligon</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNotSmoothMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oVertices = origin.vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oTriangles = origin.triangles; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triangles.Length; i++) { vertices[i] = oVertices[oTriangles[i]]; triangles[i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh() { indexFormat = vertices.Length &gt; <span class="hljs-number"><span class="hljs-number">65535</span></span> ? IndexFormat.UInt32 : IndexFormat.UInt16, vertices = vertices, triangles = triangles }; }</code> </pre> <br></div></div><br>  Sekarang Anda perlu menentukan poligon mesh ini sehingga setelah operasi rendering adalah mungkin untuk menentukan mana yang masuk layar.  Seperti yang telah disebutkan, kami menghasilkan warna unik untuk poligon dan melukis masing-masing tiga simpul dalam warna yang sesuai.  Hasilnya adalah mesh baru, yang kami sebut <b>Byte-Colored Mesh</b> . <br><br><img src="https://habrastorage.org/webt/jl/l0/co/jll0coliukddunmhl5kizfzwpzq.jpeg"><br>  <i><b>Jaring berwarna byte</b></i> <br><br><div class="spoiler">  <b class="spoiler_title">Pewarnaan mesh di mana setiap titik hanya satu poligon</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorizePolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pColors = ColorsOfPolygons(mesh); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.vertexCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { colors[i] = pColors[i / <span class="hljs-number"><span class="hljs-number">3</span></span>]; } mesh.colors = colors; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetColorsOfPolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.triangles.Length / <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = Int2Color(i);<span class="hljs-comment"><span class="hljs-comment">//         ,     Color2Int //      ,       int     Color32 colors[i] = color; } return colors; }</span></span></code> </pre> <br></div></div><br>  Ingat pewarnaannya.  Sudah waktunya untuk membuat.  Kami melakukan rendering 3D untuk semua sudut kamera dan, saat memproses masing-masing, mengisi kembali buffer indeks poligon unik yang warnanya terdeteksi dalam bingkai.  Untuk saat perhitungan untuk kamera, Anda perlu mematikan anti-aliasing untuk menghindari tampilan warna baru karena interpolasi piksel tetangga. <br><br><div class="spoiler">  <b class="spoiler_title">Membaca dan menyimpan warna dari sudut kamera yang berbeda</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// CameraTransform —         //      SetCameraTransform private static HashSet&lt;Color&gt; GetVisibleColors(Camera camera, CameraTransform[] cameraTransforms) { var renderTexture = new RenderTexture(1920, 1080, 24);//for example var rtRect = new Rect(0, 0, renderTexture.width, renderTexture.height); var frame = new Texture2D(renderTexture.width, renderTexture.height, TextureFormat.RGB24, false);//    -  RGB24   ,    RGBA32 var visibleColorsSet = new HashSet&lt;Color&gt;(); foreach (var cameraTransform in cameraTransforms) { SetCameraTransform(camera, cameraTransform); CreateScreenShot(camera, renderTexture, frame, rtRect); visibleColorsSet.UnionWith(GetTextureColors(frame)); } return visibleColorsSet; } public static void SetCameraTransform(Camera camera, CameraTransform camTransform) { camera.transform.position = camTransform.Position; camera.transform.rotation = camTransform.Rotation; camera.fieldOfView = camTransform.FieldOfView; camera.orthographic = camTransform.IsOrthographic; camera.nearClipPlane = camTransform.NearClippingPlane; camera.farClipPlane = camTransform.FarClippingPlane; } private static HashSet&lt;Color&gt; GetTextureColors(Texture2D texture) { return new HashSet&lt;Color&gt;(texture.GetPixels()); } private static void CreateScreenShot(Camera cam, RenderTexture renderTexture, Texture2D screenShot, Rect renderTextureRect) { cam.targetTexture = renderTexture; cam.Render(); RenderTexture.active = cam.targetTexture; screenShot.ReadPixels(renderTextureRect, 0, 0); RenderTexture.active = null; cam.targetTexture = null; } }</span></span></code> </pre> <br></div></div><br>  Perlu disebutkan bahwa karena diskritisasi, beberapa segitiga mungkin tidak ditampilkan karena ukuran proyeksi mereka yang kecil ke layar, dan bukan karena sesuatu tumpang tindih atau mereka diputar di sisi yang salah.  Kami telah mengimplementasikan versi algoritma yang konservatif.  Dalam hal ini, <b>AABB dari</b> proyeksi segitiga pada layar dihitung, dan jika setidaknya salah satu sisinya kurang dari sisi texel dalam gambar, maka poligon tersebut ditandai sebagai terlihat.  Pendekatan ini melindungi terhadap artefak saat menjalankan algoritme dengan resolusi yang kurang dari resolusi layar perangkat target.  Jika Anda mengabaikan poligon kecil, hasilnya juga akan dapat diterima asalkan resolusi tekstur render yang digunakan lebih tinggi daripada resolusi layar perangkat yang dimaksud. <br><br>  Kami menerapkan algoritma pemangkasan ini di <b>Unity</b> dan menggunakannya untuk mengoptimalkan objek statis yang modelnya ditemukan di lokasi lebih dari sekali di berbagai posisi.  Ini terutama pemandangan: batu, pohon, patung, vas, dll yang merujuk pada cetakan yang sering digunakan.  Kami ingin mengoptimalkan objek seperti itu sebelumnya, pada tahap pembuatan dalam paket 3D, tetapi siapa yang tahu di mana pose fantasmagorik yang diinginkan oleh perancang level untuk meletakkan lilin favoritnya. <br><br>  Memotong set objek dari jenis yang sama dengan alat seperti itu mengurangi ukuran adegan, karena selama <b>batching statis,</b> data mesh <b>prefab</b> umum tetap disalin pada tahap build sebanyak kali objek yang ditarik aktif dengan mesh ini diwakili dalam adegan.  Metode kami juga membebaskan ruang di atlas tekstur, seperti <b>lightmap</b> .  Kami menggunakan ruang yang disimpan untuk meningkatkan detail bagian-bagian dari model yang selamat dari pembersihan. <br><br><h3>  Pangkas 3D </h3><br>  Namun demikian, lebih baik jika artis dapat memotong semua yang tidak perlu dalam editornya, sehingga mengurangi jumlah tahapan persiapan konten.  Ini dibenarkan ketika model digunakan dalam adegan dengan hanya satu rotasi yang telah ditentukan relatif terhadap kamera.  Sebelumnya, objek-objek yang akan secara tepat dialihkan ke pengguna di satu sisi sering disederhanakan secara manual sebelum diintegrasikan ke dalam proyek.  Penting untuk dicatat bahwa menerapkan penyederhanaan seperti itu secara pemrograman di <b>Unity</b> jauh lebih sulit karena kompleksitas pengemasan pengembangan <b>UV</b> , sehingga otomatisasi pada tahap paket 3D kadang-kadang membuat hidup lebih mudah bagi seorang seniman. <br><br>  Salah satu alat untuk bekerja dengan model 3D di perusahaan kami adalah <b>Blender</b> .  Kami naik ke sana.  Tampaknya perangkat lunak "dewasa" seperti itu, seperti <b>Blender</b> , harus memiliki fungsi serupa.  Namun, ternyata dia tidak boleh.  Saya harus melihat sepeda sendiri. <br><br>  Gagasan pertama adalah menggunakan alat seleksi yang familier - pada dasarnya ulangi bagian dari pekerjaan manual artis untuk satu sudut kamera: pilih poligon yang terlihat, seleksi terbalik, hapus.  Rencananya adalah ini: gerakkan kamera, tentukan proyeksi <b>AABB</b> dari model di setiap posisi, lalu minta hasil pemilihan poligon pada area yang sesuai dengan <b>AABB</b> , dapatkan penyatuan kumpulan poligon dari tampilan saat ini dengan yang sebelumnya dan hapus poligon yang tidak dipilih di akhir. <br><br>  Namun, selama implementasi skrip, kelemahan signifikan ditemukan dalam hal tugas.  Alat seleksi di <b>Blender (pilih persegi panjang, pilih lingkaran)</b> <a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">kehilangan keakuratan</a> dengan meningkatnya jumlah elemen yang dipilih per satuan luas layar (beberapa poligon tetap tidak dipilih), yang membuat penggunaannya dalam alat otomatisasi kami menjadi mustahil.  Fakta menarik: dalam <b>3ds yang</b> sama <b>Max</b> masalah seperti itu tidak diamati. <br><br><img src="https://habrastorage.org/webt/ai/rr/bf/airrbf1enz0jfiucjtrhrbzv8bw.jpeg"><br>  <i>Menyoroti dari jauh di <b>Blender</b></i> <br><br><img src="https://habrastorage.org/webt/gt/vy/mh/gtvymh56yk7vp5lrwsvuav4fjqq.jpeg"><br>  <i>Hasil seleksi</i> <br><br>  Upaya berikutnya ditujukan untuk memecahkan masalah di dahi: kami mengirim sinar dari kamera melalui setiap piksel viewport dan melihat poligon mana yang pertama kali berpotongan dengan setidaknya satu sinar.  Kami tidak berharap untuk hasil yang akurat dengan pendekatan ini, tetapi patut dicoba.  Hasilnya jelas: produktivitas sangat rendah saat memproses pada <b>CPU</b> atau lubang yang sama dengan sejumlah kecil sinar. <br><br>  Namun demikian, kami membuat pijakan untuk penerapan pendekatan yang lebih maju.  Idenya adalah untuk memilih sejumlah titik acak pada setiap poligon dan kemudian mengirim sinar dari kamera ke arah mereka.  Pendekatan ini bekerja dengan baik, tetapi kami memiliki beberapa kasus garis batas: poligon juga terputus, di mana sudut antara balok dan normalnya kira-kira sama dengan π / 2.  Dengan demikian, ketika kamera memperbesar karena distorsi perspektif, area cut-out bisa terbuka. <br><br>  Metode ini, menurut pendapat para seniman, terlalu agresif, jadi kami memutuskan untuk fokus hanya <b>memotong</b> bagian <b>belakang</b> . <br><br><h3>  Kesimpulan </h3><br>  Bukan rahasia lagi bahwa sikap hati-hati terhadap sumber daya perangkat saat membuat game adalah faktor paling penting yang mempengaruhi kualitas produk akhir.  Ini terutama berlaku untuk platform seluler, yang ingin menggunakan RAM secara aktif.  Mengurangi jumlah poligon memungkinkan Anda mengisi ruang atlas tekstur secara lebih efektif dan sedikit mengurangi beban komputasi. <br><br>  Juga, jangan lupa tentang biaya jam kerja dan biaya kesalahan saat menggunakan alat yang dijelaskan di atas, dan sejenisnya.  Pendekatan yang diusulkan mengasumsikan pipeline berfungsi dengan baik untuk pekerjaan departemen seni, terutama karyawan yang terlibat dalam integrasi model ke dalam proyek. <br><br>  Dengan demikian, setelah kondisi dan alat dibahas dalam artikel ini, kami mematuhi aturan berikut.  Jika diasumsikan bahwa model yang dibuat akan selalu diputar oleh satu sisi ke pengguna, dan juga jika dari sudut ini tumpang tindih dari beberapa bagian model oleh orang lain cukup kecil, maka artis menggunakan <b>alat</b> trim <b>backface</b> kami di editor 3D, memeriksa kebenaran dan hasil dengan kemasan pengembangan <b>UV.</b> .  Jika model sering digunakan dalam posisi yang berbeda atau memiliki geometri yang lebih kompleks, maka setelah mengimpor ke dalam proyek, kami menjalankan algoritma yang dijelaskan di bagian pertama artikel, memproses semua objek statis dalam adegan dengannya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484792/">https://habr.com/ru/post/id484792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484776/index.html">Acara digital di St. Petersburg dari 21 hingga 26 Januari</a></li>
<li><a href="../id484778/index.html">Intel Parallel Studio XE 2020: semua yang terbaik untuk pengembang</a></li>
<li><a href="../id484782/index.html">Toko Online Sisi Klien Blazor: Bagian 2 - CI / CD</a></li>
<li><a href="../id484788/index.html">Lebih banyak fitur untuk sistem Anda: integrasi telepon dan CRM / ERP / Helpdesk. Apa, bagaimana, dan mengapa?</a></li>
<li><a href="../id484790/index.html">Kisah bagaimana, karena satu opsi di server Windows, situs kami melambat</a></li>
<li><a href="../id484796/index.html">Bagaimana saya mendapatkan sertifikasi OSWE?</a></li>
<li><a href="../id484798/index.html">Mengapa pemilahan cepat sangat lambat? Metode Urutan Array Baru</a></li>
<li><a href="../id484800/index.html">Penganalisis Kode Sumber Inspektur Aplikasi Microsoft</a></li>
<li><a href="../id484802/index.html">Mode penghancuran diri: dekomposisi kapsul endoskopi karena cahaya</a></li>
<li><a href="../id484804/index.html">Apa yang harus dienkripsi dalam sistem perusahaan? Dan mengapa melakukan ini?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>