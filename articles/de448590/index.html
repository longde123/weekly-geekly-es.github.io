<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèª üçè üëú Bekannte Fremde oder noch einmal √ºber die Verwendung von Designmustern üë©üèΩ‚Äçü§ù‚Äçüë®üèø ü§¥üèª üéõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zum Thema Designmuster wurden unz√§hlige Artikel geschrieben und viele B√ºcher ver√∂ffentlicht. Dieses Thema h√∂rt jedoch nicht auf, relevant zu sein, da ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bekannte Fremde oder noch einmal √ºber die Verwendung von Designmustern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448590/"><p>  Zum Thema Designmuster wurden unz√§hlige Artikel geschrieben und viele B√ºcher ver√∂ffentlicht.  Dieses Thema h√∂rt jedoch nicht auf, relevant zu sein, da die Muster es uns erm√∂glichen, vorgefertigte, bew√§hrte L√∂sungen zu verwenden, mit denen wir die Zeit f√ºr die Projektentwicklung verk√ºrzen k√∂nnen, indem wir die Qualit√§t des Codes verbessern und die technischen Schulden reduzieren. </p><br><p>  Seit dem Aufkommen von Designmustern gibt es immer neue Beispiele f√ºr ihre effektive Verwendung.  Und das ist wunderbar.  Es gab jedoch eine Fliege in der Salbe: Jede Sprache hat ihre eigenen Besonderheiten.  Und Golang - und noch mehr (es gibt nicht einmal ein klassisches OOP-Modell).  Daher gibt es Variationen der Muster in Bezug auf einzelne Programmiersprachen.  In diesem Artikel m√∂chte ich auf das Thema Designmuster in Bezug auf Golang eingehen. </p><a name="habracut"></a><br><h1>  Dekorateur </h1><br><blockquote>  Mit der Decorator-Vorlage k√∂nnen Sie zus√§tzliches Verhalten (statisch oder dynamisch) mit dem Objekt verbinden, ohne das Verhalten anderer Objekte derselben Klasse zu beeinflussen.  Eine Vorlage wird h√§ufig verwendet, um dem Prinzip der Einzelverantwortung zu entsprechen, da Sie damit Funktionen zwischen Klassen austauschen k√∂nnen, um bestimmte Probleme zu l√∂sen. <br></blockquote><p>  Das bekannte DECORATOR-Muster ist in vielen Programmiersprachen weit verbreitet.  In Golang basiert die gesamte Middleware auf ihrer Basis.  Beispielsweise k√∂nnte die Abfrageprofilerstellung folgenderma√üen aussehen: </p><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfileMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { started := time.Now() next.ServeHTTP() elapsed := time.Now().Sub(started) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"HTTP: elapsed time %d"</span></span>, elapsed) }</code> </pre> <br><p>  In diesem Fall ist die Dekorationsschnittstelle die einzige Funktion.  Dies sollte in der Regel angestrebt werden.  Ein Dekorateur mit einer breiteren Oberfl√§che kann jedoch manchmal n√ºtzlich sein.  Betrachten Sie beispielsweise den Zugriff auf eine Datenbank (Paketdatenbank / SQL).  Angenommen, wir m√ºssen die gleiche Profilerstellung f√ºr Datenbankabfragen durchf√ºhren.  In diesem Fall brauchen wir: </p><br><ul><li>  Anstatt √ºber einen Zeiger direkt mit der Datenbank zu interagieren, m√ºssen wir √ºber die Schnittstelle zur Interaktion √ºbergehen (um das Verhalten von der Implementierung zu trennen). </li><li>  Erstellen Sie einen Wrapper f√ºr jede Methode, die eine SQL-Datenbankabfrage ausf√ºhrt. </li></ul><br><p>  Als Ergebnis erhalten wir einen Dekorateur, mit dem Sie alle Abfragen in der Datenbank profilieren k√∂nnen.  Die Vorteile dieses Ansatzes sind unbestreitbar: </p><br><ul><li>  Bewahrt die Code-Sauberkeit der zentralen Datenbankzugriffskomponente. </li><li>  Jeder Dekorateur setzt eine einzelne Anforderung um.  Dadurch wird eine einfache Implementierung erreicht. </li><li>  Aufgrund der Zusammensetzung der Dekorateure erhalten wir ein erweiterbares Modell, das sich leicht an unsere Bed√ºrfnisse anpassen l√§sst. </li><li>  Durch das einfache Herunterfahren des Profilers erhalten wir im Produktionsmodus keinen Leistungsaufwand. </li></ul><br><p>  So k√∂nnen Sie beispielsweise die folgenden Arten von Dekorateuren implementieren: </p><br><ul><li>  Herzschlag  Pingen Sie eine Datenbank an, um eine Verbindung zu ihr aufrechtzuerhalten. </li><li>  Profiler.  Die Ausgabe sowohl des Anforderungshauptteils als auch seiner Ausf√ºhrungszeit. </li><li>  Schn√ºffler.  Sammlung von Datenbankmetriken. </li><li>  Klon  Klonen der urspr√ºnglichen Datenbank f√ºr Debugging-Zwecke. </li></ul><br><p>  In der Regel ist bei der Implementierung von Rich Decorators nicht die Implementierung aller Methoden erforderlich: Es reicht aus, nicht implementierte Methoden an ein internes Objekt zu delegieren. </p><br><p>  Angenommen, wir m√ºssen einen erweiterten Logger implementieren, um DML-Abfragen f√ºr eine Datenbank zu verfolgen (um INSERT / UPDATE / DELETE-Abfragen zu verfolgen).  In diesem Fall m√ºssen wir nicht die gesamte Datenbankschnittstelle implementieren, sondern nur die Exec-Methode √ºberlappen. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyDatabase <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{ Query(...) (sql.Rows, error) QueryRow(...) error Exec(query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>) error Ping() error } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyExecutor <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MyDatabase } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *MyExecutor)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, args ...</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ... }</code> </pre> <br><p>  Wir sehen also, dass es nicht besonders schwierig ist, selbst einen reichen Dekorateur in der Golang-Sprache zu schaffen. </p><br><h1>  Vorlagenmethode </h1><br><blockquote>  Template-Methode (Eng. Template-Methode) - Ein Verhaltensentwurfsmuster, das die Basis des Algorithmus definiert und es den Erben erm√∂glicht, einige Schritte des Algorithmus neu zu definieren, ohne seine Struktur als Ganzes zu √§ndern. <br></blockquote><p>  Die Golang-Sprache unterst√ºtzt das OOP-Paradigma, sodass diese Vorlage nicht in ihrer reinen Form implementiert werden kann.  Nichts hindert uns jedoch daran, Konstruktoren mit geeigneten Funktionen zu improvisieren. </p><br><p>  Angenommen, wir m√ºssen eine Vorlagenmethode mit der folgenden Signatur definieren: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><p>  Bei der Deklaration reicht es aus, ein Feld eines Funktionstyps zu verwenden.  Um die Arbeit damit zu vereinfachen, k√∂nnen wir die Wrapper-Funktion verwenden, um den Aufruf mit dem fehlenden Parameter zu erg√§nzen und eine bestimmte Instanz, die entsprechende Konstruktorfunktion, zu erstellen. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MethodImpl <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(me *MyStruct, s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> } // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ms *MyStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ms.MethodImpl(ms, s) } <span class="hljs-comment"><span class="hljs-comment">// First constructor func NewStruct1() *MyStruct { return &amp;MyStruct{ MethodImpl: func(me *MyStruct, s string) error { // Implementation 1 ... }, } } // Second constructor func NewStruct2() *MyStruct { return &amp;MyStruct{ MethodImpl: func(me *MyStruct, s string) error { // Implementation 2 ... }, } } func main() { // Create object instance o := NewStruct2() // Call the template method err := o.Method("hello") ... }</span></span></code> </pre> <br><p>  Wie Sie dem Beispiel entnehmen k√∂nnen, unterscheidet sich die Semantik der Verwendung des Musters kaum von der klassischen OOP. </p><br><h1>  Adapter </h1><br><blockquote>  Mit dem Entwurfsmuster ‚ÄûAdapter‚Äú k√∂nnen Sie die Schnittstelle einer vorhandenen Klasse als andere Schnittstelle verwenden.  Diese Vorlage wird h√§ufig verwendet, um sicherzustellen, dass einige Klassen mit anderen zusammenarbeiten, ohne ihren Quellcode zu √§ndern. <br></blockquote><p>  Im Allgemeinen k√∂nnen Adapter als separate Funktionen und ganze Schnittstellen dienen.  Wenn bei Schnittstellen alles mehr oder weniger klar und vorhersehbar ist, dann gibt es aus Sicht der einzelnen Funktionen Feinheiten. </p><br><p>  Angenommen, wir schreiben einen Dienst mit einer internen API: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyService <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Create(ctx context.Context, order <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, err error) }</code> </pre> <br><p>  Wenn wir eine √∂ffentliche API mit einer anderen Schnittstelle bereitstellen m√ºssen (z. B. um mit gRPC zu arbeiten), k√∂nnen wir einfach die Adapterfunktionen verwenden, die sich mit der Konvertierung der Schnittstelle befassen.  Zu diesem Zweck ist es sehr bequem, Verschl√ºsse zu verwenden. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRequest</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">struct</span></span></span></span> { Order <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> CreateResponse <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s MyService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Decode request req := request.(CreateRequest) // Call service method id, err := s.Create(ctx, req.Order) // Encode response return CreateResponse{ID: id, Err: err}, nil } }</span></span></code> </pre> <br><p>  Die Funktion makeCreateEndpoint besteht aus drei Standardschritten: </p><br><ul><li>  Werte dekodieren </li><li>  Aufrufen einer Methode √ºber die interne API des zu implementierenden Dienstes </li><li>  Wertekodierung </li></ul><br><p>  Alle Endpunkte im Gokit-Paket basieren auf diesem Prinzip. </p><br><h1>  Besucher </h1><br><blockquote>  Die Vorlage "Besucher" ist eine M√∂glichkeit, den Algorithmus von der Struktur des Objekts zu trennen, in dem er arbeitet.  Das Ergebnis der Trennung ist die M√∂glichkeit, vorhandenen Objektstrukturen neue Operationen hinzuzuf√ºgen, ohne sie zu √§ndern.  Dies ist eine M√∂glichkeit, das Open / Closed-Prinzip einzuhalten. <br></blockquote><p>  Betrachten Sie das bekannte Besuchermuster am Beispiel geometrischer Formen. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Geometry <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Visit(GeometryVisitor) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GeometryVisitor <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { VisitPoint(p *Point) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) VisitLine(l *Line) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) VisitCircle(c *Circle) (<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Point <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X, Y <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitPoint(point) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Line <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X1, Y1 <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> X2, Y2 <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(line *Line)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitLine(line) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Circle <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ X, Y, R <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(circle *Circle)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v GeometryVisitor)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.VisitCircle(circle) }</code> </pre> <br><p>  Angenommen, wir m√∂chten eine Strategie zur Berechnung des Abstands von einem bestimmten Punkt zu einer bestimmten Form schreiben. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DistanceStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { X, Y <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *DistanceStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Evaluate distance from point(X, Y) to point p } func (s *DistanceStrategy) VisitLine(l *Line) (interface{}, error) { // Evaluate distance from point(X, Y) to line l } func (s *DistanceStrategy) VisitCircle(c *Circle) (interface{}, error) { // Evaluate distance from point(X, Y) to circle c } func main() { s := &amp;DistanceStrategy{X: 1, Y: 2} p := &amp;Point{X: 3, Y: 4} res, err := p.Visit(s) if err != nil { panic(err) } fmt.Printf("Distance is %g", res.(float32)) }</span></span></code> </pre> <br><p>  Ebenso k√∂nnen wir andere Strategien implementieren, die wir brauchen: </p><br><ul><li>  Vertikale Ausdehnung </li><li>  Die horizontale Ausdehnung des Objekts </li><li>  Erstellen eines minimalen Spanning Square (MBR) </li><li>  Andere Primitive brauchen wir. </li></ul><br><p>  Dar√ºber hinaus wissen zuvor definierte Zahlen (Punkt, Linie, Kreis ...) nichts √ºber diese Strategien.  Ihr einziges Wissen beschr√§nkt sich auf die GeometryVisitor-Oberfl√§che.  Auf diese Weise k√∂nnen Sie sie in einem separaten Paket isolieren. </p><br><p>  W√§hrend ich an einem kartografischen Projekt arbeitete, hatte ich einmal die Aufgabe, eine Funktion zum Bestimmen der Entfernung zwischen zwei beliebigen geografischen Objekten zu schreiben.  Die L√∂sungen waren sehr unterschiedlich, aber nicht effizient und elegant.  In Anbetracht des Besuchermusters fiel mir auf, dass es zur Auswahl der Zielmethode dient und etwas an einen separaten Rekursionsschritt erinnert, der, wie Sie wissen, die Aufgabe vereinfacht.  Dies veranlasste mich, Double Visitor zu verwenden.  Stellen Sie sich meine √úberraschung vor, als ich entdeckte, dass ein solcher Ansatz im Internet √ºberhaupt nicht erw√§hnt wird. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> geometryStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ G Geometry } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;pointStrategy{Point: p}) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *Line)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;lineStrategy{Line: l}) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d *geometryStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Circle)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sGVisit(&amp;circleStrategy{Circle: c}) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> pointStrategy <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ *Point } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point *pointStrategy)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Point)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Evaluate distance between point and p } func (point *pointStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between point and l } func (point *pointStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between point and c } type lineStrategy struct { *Line } func (line *lineStrategy) Visit(p *Point) (interface{}, error) { // Evaluate distance between line and p } func (line *lineStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between line and l } func (line *lineStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between line and c } type circleStrategy struct { *Circle } func (circle *circleStrategy) Visit(p *Point) (interface{}, error) { // Evaluate distance between circle and p } func (circle *circleStrategy) Visit(l *Line) (interface{}, error) { // Evaluate distance between circle and l } func (circle *circleStrategy) Visit(c *Circle) (interface{}, error) { // Evaluate distance between circle and c } func Distance(a, b Geometry) (float32, error) { return a.Visit(&amp;geometryStrategy{G: b}) }</span></span></code> </pre> <br><p>  Daher haben wir einen zweistufigen Selektionsmechanismus entwickelt, der aufgrund seiner Arbeit die geeignete Methode zur Berechnung des Abstands zwischen zwei Grundelementen aufruft.  Wir k√∂nnen nur diese Methoden schreiben und das Ziel ist erreicht.  Auf diese Weise kann ein elegant nicht deterministisches Problem auf eine Reihe elementarer Funktionen reduziert werden. </p><br><h1>  Fazit </h1><br><p>  Trotz der Tatsache, dass es in Golang kein klassisches OOP gibt, erzeugt die Sprache einen eigenen Dialekt von Mustern, die auf den St√§rken der Sprache spielen.  Diese Muster gehen den Standardweg von der Verweigerung zur universellen Akzeptanz und werden im Laufe der Zeit zu Best Practices. </p><br><p>  Wenn angesehene Habrozhiteli Gedanken zu Mustern haben, seien Sie bitte nicht sch√ºchtern und √§u√üern Sie Ihre Gedanken dazu. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448590/">https://habr.com/ru/post/de448590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448576/index.html">Transistorgeschichte Teil 2: Aus dem Schmelztiegel des Krieges</a></li>
<li><a href="../de448580/index.html">CQ CQ CQ Frohe Feiertage, Radio Amateur! #WorldAmateurRadioDay</a></li>
<li><a href="../de448582/index.html">Erstellen eines Trinkgeldrechners auf Kotlin: Wie funktioniert das?</a></li>
<li><a href="../de448584/index.html">7 h√§ufige Fehler bei der Verwendung von Pr√§positionen in Englisch und wie man sie vermeidet</a></li>
<li><a href="../de448588/index.html">Die Architektur des Netzwerklastenausgleichs in Yandex.Cloud</a></li>
<li><a href="../de448594/index.html">Kostenlose Antiviren- und Firewalls (UTM, NGFW) von Sophos</a></li>
<li><a href="../de448596/index.html">Tablet-Halter auf dem Laufband oder suchen Sie nach freien Schritten</a></li>
<li><a href="../de448602/index.html">Ist die √úberwachung tot? - Es lebe die √úberwachung</a></li>
<li><a href="../de448604/index.html">Gameboy in C #</a></li>
<li><a href="../de448606/index.html">Sidorin: Bei KnowledgeConf geht es darum, wie Wissen mit einer durchschnittlichen Arbeitsdauer an einem Ort in 2-3 Jahren aufrechterhalten werden kann</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>